<html lang="ja"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>第 8 章 最適化</title><link rel="stylesheet" type="text/css" href="mvl.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="MySQL 5.6 リファレンスマニュアル"><link rel="up" href="index.html" title="MySQL 5.6 リファレンスマニュアル"><link rel="prev" href="backup-and-recovery.html" title="第 7 章 バックアップとリカバリ"><link rel="next" href="language-structure.html" title="第 9 章 言語構造">
<script language="javascript" type="text/javascript">
  function addOnload(theFunc)
  {
    var previous = window.onload;
    if (typeof window.onload != 'function')
    {
      window.onload = theFunc;
    }
    else
    {
      window.onload = function()
      {
        previous();
        theFunc();
      }
    }
  }

  addOnload(function()
  {
    var base = new Date(1442918127*1000);
    var now = new Date();
    var diff = ((now-base)/1000)/(24*3600);

    if (diff > 90) {
      var nodes = document.getElementsByClassName('titlepage');
      nodes[0].innerHTML = '<p style="border: 5px #ff0000 solid; padding: 5px; margin 5px">' +
        'This copy of the manual is more than 90 days old. We encourage you to download a ' +
        'new version from <a href="http://dev.mysql.com">dev.mysql.com/doc</a>.</p>' + nodes[0].innerHTML;
    }
  });
</script>
<noscript></noscript>
</head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第 8 章 最適化</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="backup-and-recovery.html">前</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="language-structure.html">次へ</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="optimization"></a>第 8 章 最適化</h1></div></div></div><div class="toc"><p><b>目次</b></p><dl class="toc"><dt><span class="section"><a href="optimization.html#optimize-overview">8.1 最適化の概要</a></span></dt><dt><span class="section"><a href="optimization.html#statement-optimization">8.2 SQL ステートメントの最適化</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#select-optimization">8.2.1 SELECT ステートメントの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#non-select-optimization">8.2.2 DML ステートメントの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#permission-optimization">8.2.3 データベース権限の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#information-schema-optimization">8.2.4 INFORMATION_SCHEMA クエリーの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#miscellaneous-optimization-tips">8.2.5 その他の最適化のヒント</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#optimization-indexes">8.3 最適化とインデックス</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#mysql-indexes">8.3.1 MySQL のインデックスの使用の仕組み</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-primary-keys">8.3.2 主キーの使用</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-foreign-keys">8.3.3 外部キーの使用</a></span></dt><dt><span class="section"><a href="optimization.html#column-indexes">8.3.4 カラムインデックス</a></span></dt><dt><span class="section"><a href="optimization.html#multiple-column-indexes">8.3.5 マルチカラムインデックス</a></span></dt><dt><span class="section"><a href="optimization.html#verifying-index-usage">8.3.6 インデックスの使用の確認</a></span></dt><dt><span class="section"><a href="optimization.html#myisam-index-statistics">8.3.7 InnoDB および MyISAM インデックス統計コレクション</a></span></dt><dt><span class="section"><a href="optimization.html#index-btree-hash">8.3.8 B ツリーインデックスとハッシュインデックスの比較</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#optimizing-database-structure">8.4 データベース構造の最適化</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#data-size">8.4.1 データサイズの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimize-data-types">8.4.2 MySQL データ型の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimize-multi-tables">8.4.3 多数のテーブルの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#internal-temporary-tables">8.4.4 MySQL が内部一時テーブルを使用する仕組み</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#optimizing-innodb">8.5 InnoDB テーブルの最適化</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#optimizing-innodb-storage-layout">8.5.1 InnoDB テーブルのストレージレイアウトの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-transaction-management">8.5.2 InnoDB トランザクション管理の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-logging">8.5.3 InnoDB ロギングの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-bulk-data-loading">8.5.4 InnoDB テーブルの一括データロード</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-queries">8.5.5 InnoDB クエリーの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-ddl-operations">8.5.6 InnoDB DDL 操作の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-diskio">8.5.7 InnoDB ディスク I/O の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-configuration-variables">8.5.8 InnoDB 構成変数の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-many-tables">8.5.9 多くのテーブルのあるシステムに対する InnoDB の最適化</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#optimizing-myisam">8.6 MyISAM テーブルの最適化</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#optimizing-queries-myisam">8.6.1 MyISAM クエリーの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-myisam-bulk-data-loading">8.6.2 MyISAM テーブルの一括データロード</a></span></dt><dt><span class="section"><a href="optimization.html#repair-table-speed">8.6.3 REPAIR TABLE ステートメントの速度</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#optimizing-memory-tables">8.7 MEMORY テーブルの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#execution-plan-information">8.8 クエリー実行プランの理解</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#using-explain">8.8.1 EXPLAIN によるクエリーの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#explain-output">8.8.2 EXPLAIN 出力フォーマット</a></span></dt><dt><span class="section"><a href="optimization.html#explain-extended">8.8.3 EXPLAIN EXTENDED 出力フォーマット</a></span></dt><dt><span class="section"><a href="optimization.html#estimating-performance">8.8.4 クエリーパフォーマンスの推定</a></span></dt><dt><span class="section"><a href="optimization.html#controlling-optimizer">8.8.5 クエリーオプティマイザの制御</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#buffering-caching">8.9 バッファリングとキャッシュ</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#innodb-buffer-pool">8.9.1 InnoDB バッファープール</a></span></dt><dt><span class="section"><a href="optimization.html#myisam-key-cache">8.9.2 MyISAM キーキャッシュ</a></span></dt><dt><span class="section"><a href="optimization.html#query-cache">8.9.3 MySQL クエリーキャッシュ</a></span></dt><dt><span class="section"><a href="optimization.html#statement-caching">8.9.4 プリペアドステートメントおよびストアドプログラムのキャッシュ</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#locking-issues">8.10 ロック操作の最適化</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#internal-locking">8.10.1 内部ロック方法</a></span></dt><dt><span class="section"><a href="optimization.html#table-locking">8.10.2 テーブルロックの問題</a></span></dt><dt><span class="section"><a href="optimization.html#concurrent-inserts">8.10.3 同時挿入</a></span></dt><dt><span class="section"><a href="optimization.html#metadata-locking">8.10.4 メタデータのロック</a></span></dt><dt><span class="section"><a href="optimization.html#external-locking">8.10.5 外部ロック</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#optimizing-the-server">8.11 MySQL サーバーの最適化</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#system-optimization">8.11.1 システム要素およびスタートアップパラメータのチューニング</a></span></dt><dt><span class="section"><a href="optimization.html#server-parameters">8.11.2 サーバーパラメータのチューニング</a></span></dt><dt><span class="section"><a href="optimization.html#disk-issues">8.11.3 ディスク I/O の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-memory">8.11.4 メモリーの使用の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-network">8.11.5 ネットワークの使用の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#thread-pool-plugin">8.11.6 スレッドプールプラグイン</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#optimize-benchmarking">8.12 パフォーマンスの測定 (ベンチマーク)</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#select-benchmarking">8.12.1 式と関数の速度の測定</a></span></dt><dt><span class="section"><a href="optimization.html#mysql-benchmarks">8.12.2 MySQL ベンチマークスイート</a></span></dt><dt><span class="section"><a href="optimization.html#custom-benchmarks">8.12.3 独自のベンチマークの使用</a></span></dt><dt><span class="section"><a href="optimization.html#monitoring-performance-schema">8.12.4 performance_schema によるパフォーマンスの測定</a></span></dt><dt><span class="section"><a href="optimization.html#thread-information">8.12.5 スレッド情報の検査</a></span></dt></dl></dd></dl></div><a class="indexterm" name="idm139979116786560"></a><a class="indexterm" name="idm139979116785104"></a><a class="indexterm" name="idm139979116783760"></a><p>
    この章では、MySQL のパフォーマンスを最適化する方法について説明し、例を示します。最適化には、いくつかのレベルでの構成、チューニング、およびパフォーマンスの測定が含まれます。業務の役割 (開発者、データベース管理者、または両方の組み合わせ) に応じて、個々の SQL ステートメント、アプリケーション全体、単一のデータベースサーバー、または複数のネットワーク接続されたデータベースサーバーのレベルで最適化できます。プロアクティブにパフォーマンスを事前に計画する場合や、または問題の発生後に、構成やコードの問題のトラブルシューティングを行う場合があります。CPU やメモリーの使用を最適化することで、スケーラビリティーを向上し、データベースを低下させず、より多くの負荷を処理させることもできます。
  </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="optimize-overview"></a>8.1 最適化の概要</h2></div></div></div><p>
      データベースのパフォーマンスは、テーブル、クエリー、構成設定など、データベースレベルの複数の要因に依存します。これらのソフトウェア構造は、ハードウェアレベルでの CPU および I/O 操作につながり、それらを最小限にし、可能なかぎり効率的にする必要があります。データベースのパフォーマンスを行う際は、ソフトウェア側の高レベルのルールとガイドラインについて学び、時計を使ってパフォーマンスを測定することから始めます。熟練するにつれ、内部で起こっていることについて詳しく学習し、CPU サイクルや I/O 操作などの測定を開始します。
    </p><p>
      一般的なユーザーの目標は、既存のソフトウェアやハードウェア構成から、最高のデータベースパフォーマンスを得ることです。上級ユーザーは、MySQL ソフトウェア自体を改善する機会を見つけたり、独自のストレージエンジンやハードウェアアプライアンスを開発して、MySQL エコシステムを拡張したりします。
    </p><h3><a name="idm139979116776048"></a>データベースレベルでの最適化</h3><p>
      データベースアプリケーションを高速にすることにおいてもっとも重要な要素は、その基本設計です。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          テーブルは適切に構築されていますか。特に、カラムに適切なデータ型があり、各テーブルに、作業の種類に適切なカラムがありますか。たとえば、頻繁な更新を実行するアプリケーションでは、多くの場合に少数のカラムのある多数のテーブルを使用し、大量のデータを解析するアプリケーションでは、多くの場合に多数のカラムのある少数のテーブルを使用します。
        </p></li><li class="listitem"><p>
          クエリーを効率的にするため、適切な<a class="link" href="optimization.html#optimization-indexes" title="8.3 最適化とインデックス">インデックス</a>が設定されていますか。
        </p></li><li class="listitem"><p>
          テーブルごとに適切なストレージエンジンを使用しており、使用している各ストレージエンジンの長所と機能を生かしていますか。特に、<code class="literal"><a class="link" href="optimization.html#optimizing-innodb" title="8.5 InnoDB テーブルの最適化">InnoDB</a></code> などのトランザクションストレージエンジンまたは <code class="literal"><a class="link" href="optimization.html#optimizing-myisam" title="8.6 MyISAM テーブルの最適化">MyISAM</a></code> などの非トランザクションストレージエンジンの選択は、パフォーマンスとスケーラビリティーにきわめて重要な場合があります。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            MySQL 5.5 以上では、<code class="literal">InnoDB</code> は新しいテーブルのデフォルトのストレージエンジンです。実際に、高度な <code class="literal">InnoDB</code> パフォーマンス機能は、<code class="literal">InnoDB</code> テーブルが、特にビジーなデータベースに対して、多くの場合に単純な <code class="literal">MyISAM</code> テーブルよりパフォーマンスが優れていることを意味します。
          </p></div></li><li class="listitem"><p>
          各テーブルは適切な行フォーマットを使用していますか。この選択は、テーブルに使用されるストレージエンジンによっても異なります。特に、圧縮テーブルは使用するディスク領域が減るため、データの読み取りと書き込みに必要なディスク I/O も少なくなります。圧縮は、<code class="literal">InnoDB</code> テーブルでのあらゆる種類のワークロードと、読み取り専用 <code class="literal">MyISAM</code> テーブルに使用できます。
        </p></li><li class="listitem"><p>
          アプリケーションでは、適切な<a class="link" href="optimization.html#locking-issues" title="8.10 ロック操作の最適化">ロック戦略</a>を使用していますか。たとえば、データベース操作を同時に実行できるように、可能なかぎり共有アクセスを許可したり、重要な操作が最優先されるように、適切な場合に排他的アクセスを要求したりするなどです。ここでも、ストレージエンジンの選択が重要です。<code class="literal">InnoDB</code> ストレージエンジンは、ユーザーが関与せずに、ほとんどのロックの問題を処理するため、データベースの同時実行性を向上し、コードの実験やチューニングの量を削減できます。
        </p></li><li class="listitem"><p>
          <a class="link" href="optimization.html#buffering-caching" title="8.9 バッファリングとキャッシュ">キャッシュに使用されるメモリー領域</a>がすべて正しくサイズ設定されていますか。つまり、頻繁にアクセスされるデータを保持するために十分な大きさがありながらも、物理メモリーをオーバーロードし、ページングを発生させるほど大きくしません。構成する主なメモリー領域は、<code class="literal">InnoDB</code> バッファープール、<code class="literal">MyISAM</code> キーキャッシュ、MySQL クエリーキャッシュです。
        </p></li></ul></div><h3><a name="idm139979116751232"></a>ハードウェアレベルでの最適化</h3><p>
      データベースがビジーになるほど、どんなデータベースアプリケーションも最終的にハードウェアの制限に達します。データベース管理者は、アプリケーションをチューニングするか、サーバーを再構成してこれらの<a class="link" href="glossary.html#glos_bottleneck" title="ボトルネック">ボトルネック</a>を回避できるかどうか、または追加のハードウェアリソースが必要かどうかを評価する必要があります。システムボトルネックは一般に次の原因から発生します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ディスクシーク。ディスクがデータを検索するには時間がかかります。最新のディスクでは、通常この平均時間が 10 ms 未満であるため、理論的には 1 秒間に約 100 シーク実行できることになります。この時間は、新しいディスクでは徐々に改善されますが、1 つのテーブルに対して最適化することはきわめて困難です。シーク時間を最適化する方法は、複数のディスクにデータを分散することです。
        </p></li><li class="listitem"><p>
          ディスクの読み取りと書き込み。ディスクが正しい位置にある場合に、データを読み取りまたは書き込みする必要があります。最新のディスクでは、1 つのディスクで少なくとも 10 - 20M バイト/秒のスループットを実現します。これは、複数のディスクから並列で読み取ることができるため、シークより最適化が簡単です。
        </p></li><li class="listitem"><p>
          CPU サイクル。データがメインメモリー内にある場合、結果を得るために、それを処理する必要があります。メモリーの量と比較して大きなテーブルを使用することは、もっとも一般的な制限要因になります。しかし、小さいテーブルでは、通常速度は問題になりません。
        </p></li><li class="listitem"><p>
          メモリー帯域幅。CPU で、CPU キャッシュに収められるより多くのデータを必要とする場合、メインメモリーの帯域幅がボトルネックになります。これは、ほとんどのシステムでまれなボトルネックですが、認識しておくべきです。
        </p></li></ul></div><h3><a name="portability"></a>移植性とパフォーマンスのバランス</h3><a class="indexterm" name="idm139979116740992"></a><p>
      ポータブル MySQL プログラムで、パフォーマンス指向の SQL 拡張を使用するには、ステートメント内の MySQL 固有のキーワードを <code class="literal">/*! */</code> コメント区切り文字で囲むことができます。ほかの SQL サーバーはコメントにされたキーワードを無視します。コメントの作成については、<a class="xref" href="language-structure.html#comments" title="9.6 コメントの構文">セクション9.6「コメントの構文」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="statement-optimization"></a>8.2 SQL ステートメントの最適化</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#select-optimization">8.2.1 SELECT ステートメントの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#non-select-optimization">8.2.2 DML ステートメントの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#permission-optimization">8.2.3 データベース権限の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#information-schema-optimization">8.2.4 INFORMATION_SCHEMA クエリーの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#miscellaneous-optimization-tips">8.2.5 その他の最適化のヒント</a></span></dt></dl></div><a class="indexterm" name="idm139979116735952"></a><p>
      インタプリタから直接発行されるか、API によって内部で送信されるかに関係なく、データベースアプリケーションのコアロジックは SQL ステートメントによって実行されます。このセクションのチューニングのガイドラインは、あらゆる種類の MySQL アプリケーションの高速化に役立ちます。このガイドラインでは、データを読み取りおよび書き込みする SQL 操作、一般的な SQL 操作の内部オーバーヘッド、およびデータベースモニタリングなどの特定のシナリオで使われる操作について説明します。
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="select-optimization"></a>8.2.1 SELECT ステートメントの最適化</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#select-speed">8.2.1.1 SELECT ステートメントの速度</a></span></dt><dt><span class="section"><a href="optimization.html#where-optimizations">8.2.1.2 MySQL の WHERE 句の最適化の方法</a></span></dt><dt><span class="section"><a href="optimization.html#range-optimization">8.2.1.3 range の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#index-merge-optimization">8.2.1.4 インデックスマージの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#condition-pushdown-optimization">8.2.1.5 エンジンコンディションプッシュダウンの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#index-condition-pushdown-optimization">8.2.1.6 インデックスコンディションプッシュダウンの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#index-extensions">8.2.1.7 インデックス拡張の使用</a></span></dt><dt><span class="section"><a href="optimization.html#is-null-optimization">8.2.1.8 IS NULL の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#left-join-optimization">8.2.1.9 LEFT JOIN および RIGHT JOIN の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#nested-loop-joins">8.2.1.10 Nested Loop 結合アルゴリズム</a></span></dt><dt><span class="section"><a href="optimization.html#nested-join-optimization">8.2.1.11 ネストした結合の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#outer-join-simplification">8.2.1.12 外部結合の単純化</a></span></dt><dt><span class="section"><a href="optimization.html#mrr-optimization">8.2.1.13 Multi-Range Read の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#bnl-bka-optimization">8.2.1.14 Block Nested Loop 結合と Batched Key Access 結合</a></span></dt><dt><span class="section"><a href="optimization.html#order-by-optimization">8.2.1.15 ORDER BY の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#group-by-optimization">8.2.1.16 GROUP BY の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#distinct-optimization">8.2.1.17 DISTINCT の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#subquery-optimization">8.2.1.18 サブクエリーの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#limit-optimization">8.2.1.19 LIMIT クエリーの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#how-to-avoid-table-scan">8.2.1.20 フルテーブルスキャンを回避する方法</a></span></dt></dl></div><a class="indexterm" name="idm139979116730880"></a><a class="indexterm" name="idm139979116728768"></a><p>
        <code class="literal">SELECT</code> ステートメントの形式のクエリーは、データベースのすべてのルックアップ操作を実行します。動的 Web ページの 1 秒未満の応答時間を達成するためでも、または巨大な夜間のレポートを生成するための時間から数時間を取り除くためでも、これらのステートメントのチューニングは最優先です。
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="select-speed"></a>8.2.1.1 SELECT ステートメントの速度</h4></div></div></div><a class="indexterm" name="idm139979116723696"></a><a class="indexterm" name="idm139979116722256"></a><p>
          クエリーの最適化の主な考慮事項は次のとおりです。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              遅い <code class="literal">SELECT ... WHERE</code> クエリーを高速化するため、最初に確認することは、<a class="link" href="glossary.html#glos_index" title="インデックス">インデックス</a>を追加できるかどうかです。<code class="literal">WHERE</code> 句で使用するカラムにインデックスをセットアップし、評価、フィルタリング、および最終的な結果の取得を高速化します。無駄なディスク領域を避けるため、アプリケーションで使用される多くの関連クエリーを高速化する少数のインデックスのセットを構築します。
            </p><p>
              インデックスは、<a class="link" href="glossary.html#glos_join" title="結合">結合</a>や<a class="link" href="glossary.html#glos_foreign_key" title="外部キー">外部キー</a>などの機能を使用して、さまざまなテーブルを参照するクエリーに特に重要です。<code class="literal">EXPLAIN</code> ステートメントを使用して、<code class="literal">SELECT</code> に使用するインデックスを判断できます。<a class="xref" href="optimization.html#mysql-indexes" title="8.3.1 MySQL のインデックスの使用の仕組み">セクション8.3.1「MySQL のインデックスの使用の仕組み」</a>および<a class="xref" href="optimization.html#using-explain" title="8.8.1 EXPLAIN によるクエリーの最適化">セクション8.8.1「EXPLAIN によるクエリーの最適化」</a>を参照してください。
            </p></li><li class="listitem"><p>
              過度な時間がかかる関数呼び出しなどのクエリーの部分を特定し、チューニングします。クエリーの構築の仕方によっては、関数が結果セットのすべての行に対して 1 回ずつ、さらにはテーブル内のすべての行に対して 1 回ずつ呼び出されるなど、大幅に非効率性を拡大させていることがあります。
            </p></li><li class="listitem"><p>
              特に大きなテーブルの場合に、クエリーでの<a class="link" href="glossary.html#glos_full_table_scan" title="テーブルの完全スキャン">完全テーブルスキャン</a>の回数を最小にします。
            </p></li><li class="listitem"><p>
              <code class="literal">ANALYZE TABLE</code> ステートメントを定期的に使用して、テーブル統計を最新に維持し、オプティマイザが、効率的な実行プランを立てるために必要な情報が得られるようにします。
            </p></li><li class="listitem"><p>
              チューニング技法、インデックス作成技法、および各テーブルのストレージエンジンに固有の構成パラメータについて学習します。<code class="literal">InnoDB</code> と <code class="literal">MyISAM</code> のどちらでも、クエリーの高いパフォーマンスを可能にし、維持するための一連のガイドラインがあります。詳細については、<a class="xref" href="optimization.html#optimizing-innodb-queries" title="8.5.5 InnoDB クエリーの最適化">セクション8.5.5「InnoDB クエリーの最適化」</a>および<a class="xref" href="optimization.html#optimizing-queries-myisam" title="8.6.1 MyISAM クエリーの最適化">セクション8.6.1「MyISAM クエリーの最適化」</a>を参照してください。
            </p></li><li class="listitem"><p>
              特に、MySQL 5.6.4 以上では、<a class="xref" href="innodb-storage-engine.html#innodb-performance-ro-txn" title="14.13.14 InnoDB の読み取り専用トランザクションの最適化">セクション14.13.14「InnoDB の読み取り専用トランザクションの最適化」</a>の技法を使用して、<code class="literal">InnoDB</code> テーブルの単一クエリートランザクションを最適化できます。
            </p></li><li class="listitem"><p>
              特にオプティマイザで同じ変換の一部を自動的に実行する場合、理解が困難になるようなクエリーの変換を避けます。
            </p></li><li class="listitem"><p>
              いずれかの基本ガイドラインによって、パフォーマンスの問題が簡単に解決されない場合、<code class="literal">EXPLAIN</code> プランを読み、インデックス、<code class="literal">WHERE</code> 句、結合句などを調整して、特定のクエリーの内部の詳細を調査します。(ある程度の専門技術に達している場合は、<code class="literal">EXPLAIN</code> プランを読むことがすべてのクエリーの最初の手順になると考えられます。)
            </p></li><li class="listitem"><p>
              MySQL がキャッシュに使用するメモリー領域のサイズとプロパティーを調整します。<code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>、<code class="literal">MyISAM</code> キーキャッシュ、および MySQL クエリーキャッシュの効率的な使用によって、2 回目以降、メモリーから結果が取得されるため、繰り返しのクエリーの実行が高速化します。
            </p></li><li class="listitem"><p>
              キャッシュメモリー領域を使用して高速に実行するクエリーでも、必要なキャッシュメモリーを減らして、アプリケーションがよりスケーラブルになるように、さらに最適化できます。スケーラビリティーは、パフォーマンスを大幅に低下させずに、アプリケーションでより多くの同時ユーザー、大きなリクエストなどを処理できることを意味します。
            </p></li><li class="listitem"><p>
              クエリーの速度が、テーブルに同時にアクセスしているほかのセッションによって影響を受ける可能性があるロックの問題を処理します。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="where-optimizations"></a>8.2.1.2 MySQL の WHERE 句の最適化の方法</h4></div></div></div><a class="indexterm" name="idm139979116683232"></a><a class="indexterm" name="idm139979116681920"></a><p>
          このセクションでは、<code class="literal">WHERE</code> 句の処理で実行可能な最適化について説明します。例では <code class="literal">SELECT</code> ステートメントを使用していますが、<code class="literal">DELETE</code> および <code class="literal">UPDATE</code> ステートメント内の <code class="literal">WHERE</code> 句にも同じ最適化を適用します。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            MySQL オプティマイザへの取り組みは継続中であるため、MySQL が実行する最適化のすべてをここで説明しているわけではありません。
          </p></div><p>
          読みやすさを犠牲にしても、算術演算を高速化するように、クエリーを書き換えたいと考えがちです。MySQL では同様の最適化を自動的に実行するため、多くの場合にこの作業を回避でき、クエリーを理解しやすく、保守しやすい形式のままにしておくことができます。MySQL によって実行される最適化の一部を次に示します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              不要なかっこの削除:
            </p><pre class="programlisting">
   ((a AND b) AND c OR (((a AND b) AND (c AND d))))
-&gt; (a AND b AND c) OR (a AND b AND c AND d)
</pre></li><li class="listitem"><p>
              定数畳み込み:
            </p><pre class="programlisting">
   (a&lt;b AND b=c) AND a=5
-&gt; b&gt;5 AND b=c AND a=5
</pre></li><li class="listitem"><p>
              定数条件の削除 (定数畳み込みのために必要です):
            </p><pre class="programlisting">
   (B&gt;=5 AND B=5) OR (B=6 AND 5=5) OR (B=7 AND 5=6)
-&gt; B=5 OR B=6
</pre></li><li class="listitem"><p>
              インデックスによって使用される定数式は 1 回だけ評価されます。
            </p></li><li class="listitem"><p>
              <code class="literal">WHERE</code> を使用しない単一テーブルの <code class="literal">COUNT(*)</code> は、<code class="literal">MyISAM</code> テーブルと <code class="literal">MEMORY</code> テーブルのテーブル情報から直接取得されます。これは、1 つだけのテーブルで使用された場合に、<code class="literal">NOT NULL</code> 式にも実行されます。
            </p></li><li class="listitem"><p>
              無効な定数式の早期の検出。MySQL は一部の <code class="literal">SELECT</code> ステートメントが実行不可能であることをすみやかに検出し、行を返しません。
            </p></li><li class="listitem"><p>
              <code class="literal">GROUP BY</code> または集約関数 (<code class="literal">COUNT()</code>、<code class="literal">MIN()</code> など) を使用しない場合、<code class="literal">HAVING</code> は <code class="literal">WHERE</code> とマージされます。
            </p></li><li class="listitem"><p>
              結合内の各テーブルについて、テーブルの高速の <code class="literal">WHERE</code> 評価を取得し、可能なかぎり早く行をスキップするために、より単純な <code class="literal">WHERE</code> が構築されます。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979116651328"></a> <a class="indexterm" name="idm139979116649856"></a> クエリー内のほかのすべてのテーブルの前に、まず、すべての定数テーブルが読み取られます。定数テーブルは次のいずれかです。
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  空白のテーブルまたは 1 行のテーブル。
                </p></li><li class="listitem"><p>
                  <code class="literal">PRIMARY KEY</code> または <code class="literal">UNIQUE</code> インデックスでの <code class="literal">WHERE</code> 句で使用されるテーブル。ここではすべてのインデックス部分が定数式と比較され、<code class="literal">NOT NULL</code> として定義されます。
                </p></li></ul></div><p>
              次のテーブルはすべて定数テーブルとして使用されます。
            </p><pre class="programlisting">
SELECT * FROM t WHERE <em class="replaceable"><code>primary_key</code></em>=1;
SELECT * FROM t1,t2
  WHERE t1.<em class="replaceable"><code>primary_key</code></em>=1 AND t2.<em class="replaceable"><code>primary_key</code></em>=t1.id;
</pre></li><li class="listitem"><p>
              テーブルを結合するための最適な結合の組み合わせは、すべての可能性を試してみることで見つかります。<code class="literal">ORDER BY</code> および <code class="literal">GROUP BY</code> 句内のすべてのカラムが同じテーブルにある場合、結合する際に最初にそのテーブルが選ばれます。
            </p></li><li class="listitem"><p>
              <code class="literal">ORDER BY</code> 句と別の <code class="literal">GROUP BY</code> 句がある場合、または、<code class="literal">ORDER BY</code> または <code class="literal">GROUP BY</code> に結合キュー内の最初のテーブルと異なるテーブルのカラムが含まれている場合は、一時テーブルが作成されます。
            </p></li><li class="listitem"><p>
              <code class="literal">SQL_SMALL_RESULT</code> オプションを使用すると、MySQL ではインメモリー一時テーブルが使用されます。
            </p></li><li class="listitem"><p>
              オプティマイザがテーブルスキャンを使用する方が効率的であると判断しないかぎり、各テーブルインデックスがクエリーされ、最適なインデックスが使用されます。かつて、スキャンは、最適なインデックスがテーブルの 30% 超にまたがっているかどうかに基づいて使用されていましたが、固定のパーセンテージによって、インデックスを使用するか、スキャンを使用するかの選択が決定されなくなりました。現在のオプティマイザは複雑になり、テーブルサイズ、行数、I/O ブロックサイズなどの追加の要因に基づいて推定します。
            </p></li><li class="listitem"><p>
              場合によって、MySQL はデータファイルを参照しなくてもインデックスから行を読み取ることができます。インデックスから使用されるすべてのカラムが数値の場合、クエリーの解決にインデックスツリーのみが使用されます。
            </p></li><li class="listitem"><p>
              各行が出力される前に、<code class="literal">HAVING</code> 句に一致しないものはスキップされます。
            </p></li></ul></div><p>
          きわめて高速なクエリーのいくつかの例:
        </p><pre class="programlisting">
SELECT COUNT(*) FROM <em class="replaceable"><code>tbl_name</code></em>;

SELECT MIN(<em class="replaceable"><code>key_part1</code></em>),MAX(<em class="replaceable"><code>key_part1</code></em>) FROM <em class="replaceable"><code>tbl_name</code></em>;

SELECT MAX(<em class="replaceable"><code>key_part2</code></em>) FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_part1</code></em>=<em class="replaceable"><code>constant</code></em>;

SELECT ... FROM <em class="replaceable"><code>tbl_name</code></em>
  ORDER BY <em class="replaceable"><code>key_part1</code></em>,<em class="replaceable"><code>key_part2</code></em>,... LIMIT 10;

SELECT ... FROM <em class="replaceable"><code>tbl_name</code></em>
  ORDER BY <em class="replaceable"><code>key_part1</code></em> DESC, <em class="replaceable"><code>key_part2</code></em> DESC, ... LIMIT 10;
</pre><p>
          MySQL は、インデックス設定されたカラムが数値であるとして、インデックスツリーのみを使用して、次のクエリーを解決します。
        </p><pre class="programlisting">
SELECT <em class="replaceable"><code>key_part1</code></em>,<em class="replaceable"><code>key_part2</code></em> FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key_part1</code></em>=<em class="replaceable"><code>val</code></em>;

SELECT COUNT(*) FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_part1</code></em>=<em class="replaceable"><code>val1</code></em> AND <em class="replaceable"><code>key_part2</code></em>=<em class="replaceable"><code>val2</code></em>;

SELECT <em class="replaceable"><code>key_part2</code></em> FROM <em class="replaceable"><code>tbl_name</code></em> GROUP BY <em class="replaceable"><code>key_part1</code></em>;
</pre><p>
          次のクエリーは、個別のソーティングパスを使用せずに、インデックスを使用して、ソート順で行を取得します。
        </p><pre class="programlisting">
SELECT ... FROM <em class="replaceable"><code>tbl_name</code></em>
  ORDER BY <em class="replaceable"><code>key_part1</code></em>,<em class="replaceable"><code>key_part2</code></em>,... ;

SELECT ... FROM <em class="replaceable"><code>tbl_name</code></em>
  ORDER BY <em class="replaceable"><code>key_part1</code></em> DESC, <em class="replaceable"><code>key_part2</code></em> DESC, ... ;
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="range-optimization"></a>8.2.1.3 range の最適化</h4></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#range-access-single-part">8.2.1.3.1 シングルパートインデックスの range アクセスメソッド</a></span></dt><dt><span class="section"><a href="optimization.html#range-access-multi-part">8.2.1.3.2 マルチパートインデックスの range アクセスメソッド</a></span></dt><dt><span class="section"><a href="optimization.html#equality-range-optimization">8.2.1.3.3 複数値比較の等価範囲の最適化</a></span></dt></dl></div><p>
          <code class="literal">range</code> アクセスメソッドは単一のインデックスを使用して、1 つまたは複数のインデックス値間隔の中に含まれるテーブル行のサブセットを取得します。これは、シングルパートまたはマルチパートインデックスに使用できます。次のセクションでは、<code class="literal">WHERE</code> 句から間隔を抽出する方法について詳しく説明します。
        </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="range-access-single-part"></a>8.2.1.3.1 シングルパートインデックスの range アクセスメソッド</h5></div></div></div><p>
            シングルパートインデックスでは、インデックス値間隔は <code class="literal">WHERE</code> 句内の対応する条件によって便利に表すことができるため、<span class="quote">「<span class="quote">間隔</span>」</span>よりも<em class="firstterm">範囲条件</em>について説明します。
          </p><p>
            シングルパートインデックスの範囲条件の定義は次のとおりです。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <code class="literal">BTREE</code> と <code class="literal">HASH</code> の両方のインデックスで、<code class="literal">=</code>、<code class="literal">&lt;=&gt;</code>、<code class="literal">IN()</code>、<code class="literal">IS NULL</code>、または <code class="literal">IS NOT NULL</code> 演算子を使用した場合、キーパートと定数値の比較は範囲条件です。
              </p></li><li class="listitem"><p>
                さらに、<code class="literal">BTREE</code> インデックスでは、<code class="literal">&gt;</code>、<code class="literal">&lt;</code>、<code class="literal">&gt;=</code>、<code class="literal">&lt;=</code>、<code class="literal">BETWEEN</code>、<code class="literal">!=</code>、または <code class="literal">&lt;&gt;</code> 演算子、または <code class="literal">LIKE</code> への引数が、ワイルドカード文字で始まっていない定数文字列である場合の <code class="literal">LIKE</code> 比較を使用した場合に、キーパートと定数値の比較は範囲条件です。
              </p></li><li class="listitem"><p>
                すべての種類のインデックスで、<code class="literal">OR</code> または <code class="literal">AND</code> で組み合わされた複数の範囲条件は、1 つの範囲条件を形成します。
              </p></li></ul></div><p>
            先述の<span class="quote">「<span class="quote">定数値</span>」</span>とは次のいずれかを意味します。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                クエリー文字列からの定数
              </p></li><li class="listitem"><p>
                同じ結合からの <code class="literal">const</code> または <code class="literal">system</code> テーブルのカラム
              </p></li><li class="listitem"><p>
                非相関サブクエリーの結果
              </p></li><li class="listitem"><p>
                以前の型の部分式からのみ構成された式
              </p></li></ul></div><p>
            以下に <code class="literal">WHERE</code> 句内で範囲条件を使用したクエリーのいくつかの例を示します。
          </p><pre class="programlisting">
SELECT * FROM t1
  WHERE <em class="replaceable"><code>key_col</code></em> &gt; 1
  AND <em class="replaceable"><code>key_col</code></em> &lt; 10;

SELECT * FROM t1
  WHERE <em class="replaceable"><code>key_col</code></em> = 1
  OR <em class="replaceable"><code>key_col</code></em> IN (15,18,20);

SELECT * FROM t1
  WHERE <em class="replaceable"><code>key_col</code></em> LIKE 'ab%'
  OR <em class="replaceable"><code>key_col</code></em> BETWEEN 'bar' AND 'foo';
</pre><p>
            定数伝播フェーズ中に、一部の非定数値が定数に変換されることがあります。
          </p><p>
            MySQL は可能なインデックスごとに、<code class="literal">WHERE</code> 句から範囲条件を抽出しようとします。抽出プロセス時に、範囲条件の構築に使用できない条件はドロップされ、重複する範囲を生成する条件は組み合わされて、空の範囲を生成する条件は削除されます。
          </p><p>
            <code class="literal">key1</code> がインデックス設定されたカラムで <code class="literal">nonkey</code> がインデックス設定されていない、次のステートメントを考慮します。
          </p><pre class="programlisting">
SELECT * FROM t1 WHERE
  (key1 &lt; 'abc' AND (key1 LIKE 'abcde%' OR key1 LIKE '%b')) OR
  (key1 &lt; 'bar' AND nonkey = 4) OR
  (key1 &lt; 'uux' AND key1 &gt; 'z');
</pre><p>
            キー <code class="literal">key1</code> の抽出プロセスは次のとおりです。
          </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                元の <code class="literal">WHERE</code> 句から始めます。
              </p><pre class="programlisting">
(key1 &lt; 'abc' AND (key1 LIKE 'abcde%' OR key1 LIKE '%b')) OR
(key1 &lt; 'bar' AND nonkey = 4) OR
(key1 &lt; 'uux' AND key1 &gt; 'z')
</pre></li><li class="listitem"><p>
                <code class="literal">nonkey = 4</code> と <code class="literal">key1 LIKE '%b'</code> は、範囲スキャンに使用できないため、削除します。それらを削除する正しい方法は、範囲スキャンの実行時に一致する行を見落とさないように、それらを <code class="literal">TRUE</code> で置き換えることです。<code class="literal">TRUE</code> で置き換えると、次のようになります。
              </p><pre class="programlisting">
(key1 &lt; 'abc' AND (key1 LIKE 'abcde%' OR TRUE)) OR
(key1 &lt; 'bar' AND TRUE) OR
(key1 &lt; 'uux' AND key1 &gt; 'z')
</pre></li><li class="listitem"><p>
                常に true または false である条件を縮小します。
              </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    <code class="literal">(key1 LIKE 'abcde%' OR TRUE)</code> は常に true です
                  </p></li><li class="listitem"><p>
                    <code class="literal">(key1 &lt; 'uux' AND key1 &gt; 'z')</code> は常に false です
                  </p></li></ul></div><p>
                これらの条件を定数で置き換えると、次のようになります。
              </p><pre class="programlisting">
(key1 &lt; 'abc' AND TRUE) OR (key1 &lt; 'bar' AND TRUE) OR (FALSE)
</pre><p>
                不要な <code class="literal">TRUE</code> および <code class="literal">FALSE</code> 定数を削除すると、次のようになります。
              </p><pre class="programlisting">
(key1 &lt; 'abc') OR (key1 &lt; 'bar')
</pre></li><li class="listitem"><p>
                重複する間隔を 1 つに組み合わせて、範囲スキャンに使用される最終的な条件が生成されます。
              </p><pre class="programlisting">
(key1 &lt; 'bar')
</pre></li></ol></div><p>
            一般に (前の例で示したように)、範囲スキャンに使用される条件は、<code class="literal">WHERE</code> 句より制限がゆるくなります。MySQL は、範囲条件を満たすが、完全な <code class="literal">WHERE</code> 句でない行をフィルタ処理する追加のチェックを実行します。
          </p><p>
            範囲条件抽出アルゴリズムは、任意の深さのネストの <code class="literal">AND</code>/<code class="literal">OR</code> 構造を処理でき、その出力は <code class="literal">WHERE</code> 句内の条件が存在する順番に依存しません。
          </p><p>
            現在、MySQL では、空間インデックスに対して、<code class="literal">range</code> アクセスメソッドの複数の範囲のマージをサポートしていません。この制限を回避するには、同じ <code class="literal">SELECT</code> ステートメントで <code class="literal">UNION</code> を使用できますが、ただし、各空間述語は、別の <code class="literal">SELECT</code> に入れます。
          </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="range-access-multi-part"></a>8.2.1.3.2 マルチパートインデックスの range アクセスメソッド</h5></div></div></div><p>
            マルチパートインデックスの範囲条件は、シングルパートインデックスの範囲条件の拡張です。マルチパートインデックスの範囲条件は、インデックス行を 1 つまたは複数のキータプル間隔内に入るように制限します。キータプル間隔は、インデックスからの順序付けを使用して、キータプルのセットに定義されます。
          </p><p>
            たとえば、<code class="literal">key1(<em class="replaceable"><code>key_part1</code></em>、<em class="replaceable"><code>key_part2</code></em>、<em class="replaceable"><code>key_part3</code></em>)</code> として定義されたマルチパートインデックスと、キー順で示された次のキータプルのセットを考慮します。
          </p><pre class="programlisting">
<em class="replaceable"><code>key_part1</code></em>  <em class="replaceable"><code>key_part2</code></em>  <em class="replaceable"><code>key_part3</code></em>
  NULL       1          'abc'
  NULL       1          'xyz'
  NULL       2          'foo'
   1         1          'abc'
   1         1          'xyz'
   1         2          'abc'
   2         1          'aaa'
</pre><p>
            条件 <code class="literal"><em class="replaceable"><code>key_part1</code></em> = 1</code> は次の間隔を定義します。
          </p><pre class="programlisting">
(1,-inf,-inf) &lt;= (<em class="replaceable"><code>key_part1</code></em>,<em class="replaceable"><code>key_part2</code></em>,<em class="replaceable"><code>key_part3</code></em>) &lt; (1,+inf,+inf)
</pre><p>
            間隔は前のデータセットの 4、5、6 番目のタプルをカバーし、range アクセスメソッドで使用できます。
          </p><p>
            対照的に、条件 <code class="literal"><em class="replaceable"><code>key_part3</code></em> = 'abc'</code> は単一の間隔を定義せず、range アクセスメソッドで使用できません。
          </p><p>
            次の説明では、マルチパートインデックスに対して、範囲条件がどのように作用するかを詳しく示します。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <code class="literal">HASH</code> インデックスでは、同一の値を含む各間隔を使用できます。これは次の形式の条件に対してのみ、間隔を生成できることを意味します。
              </p><pre class="programlisting">
    <em class="replaceable"><code>key_part1</code></em> <em class="replaceable"><code>cmp</code></em> <em class="replaceable"><code>const1</code></em>
AND <em class="replaceable"><code>key_part2</code></em> <em class="replaceable"><code>cmp</code></em> <em class="replaceable"><code>const2</code></em>
AND ...
AND <em class="replaceable"><code>key_partN</code></em> <em class="replaceable"><code>cmp</code></em> <em class="replaceable"><code>constN</code></em>;
</pre><p>
                ここで、<em class="replaceable"><code>const1</code></em>、<em class="replaceable"><code>const2</code></em>、… は定数で、<em class="replaceable"><code>cmp</code></em> は、<code class="literal">=</code>、<code class="literal">&lt;=&gt;</code>、または <code class="literal">IS NULL</code> 比較演算子のいずれかで、条件はすべてのインデックスパートをカバーします。(つまり、<em class="replaceable"><code>N</code></em> パートインデックスの各パートに 1 つずつ <em class="replaceable"><code>N</code></em> 条件があります。)たとえば、次は 3 パート <code class="literal">HASH</code> インデックスの範囲条件です。
              </p><pre class="programlisting">
<em class="replaceable"><code>key_part1</code></em> = 1 AND <em class="replaceable"><code>key_part2</code></em> IS NULL AND <em class="replaceable"><code>key_part3</code></em> = 'foo'
</pre><p>
                何を定数とみなすかの定義については、「<a class="xref" href="optimization.html#range-access-single-part" title="8.2.1.3.1 シングルパートインデックスの range アクセスメソッド">セクション8.2.1.3.1「シングルパートインデックスの range アクセスメソッド」</a>」を参照してください。
              </p></li><li class="listitem"><p>
                <code class="literal">BTREE</code> インデックスでは、各条件で <code class="literal">=</code>、<code class="literal">&lt;=&gt;</code>、<code class="literal">IS NULL</code>、<code class="literal">&gt;</code>、<code class="literal">&lt;</code>、<code class="literal">&gt;=</code>、<code class="literal">&lt;=</code>、<code class="literal">!=</code>、<code class="literal">&lt;&gt;</code>、<code class="literal">BETWEEN</code>、または <code class="literal">LIKE '<em class="replaceable"><code>pattern</code></em>'</code> (ここで <code class="literal">'<em class="replaceable"><code>pattern</code></em>'</code> はワイルドカードで始まらない) を使用して、キーパートと定数値を比較する、<code class="literal">AND</code> で組み合わされた条件に、間隔を使用できます。条件に一致するすべての行を含む単一のキータプルを判断できる場合にかぎり、1 つの間隔を使用できます (または <code class="literal">&lt;&gt;</code> または <code class="literal">!=</code> を使用する場合は 2 つの間隔)。
              </p><p>
                オプティマイザは、比較演算子が <code class="literal">=</code>、<code class="literal">&lt;=&gt;</code>、または <code class="literal">IS NULL</code> である場合にかぎり、追加のキーパートを使用して、間隔を判断しようとします。演算子が <code class="literal">&gt;</code>、<code class="literal">&lt;</code>、<code class="literal">&gt;=</code>、<code class="literal">&lt;=</code>、<code class="literal">!=</code>、<code class="literal">&lt;&gt;</code>、<code class="literal">BETWEEN</code>、または <code class="literal">LIKE</code> の場合、オプティマイザはそれを使用しますが、追加のキーパートは考慮しません。次の式では、オプティマイザは最初の比較からの <code class="literal">=</code> を使用します。さらに 2 番目の比較からの <code class="literal">&gt;=</code> も使用しますが、それ以上のキーパートを考慮せず、間隔の構築に 3 番目の比較を使用しません。
              </p><pre class="programlisting">
<em class="replaceable"><code>key_part1</code></em> = 'foo' AND <em class="replaceable"><code>key_part2</code></em> &gt;= 10 AND <em class="replaceable"><code>key_part3</code></em> &gt; 10
</pre><p>
                単一の間隔は次のとおりです。
              </p><pre class="programlisting">
('foo',10,-inf) &lt; (<em class="replaceable"><code>key_part1</code></em>,<em class="replaceable"><code>key_part2</code></em>,<em class="replaceable"><code>key_part3</code></em>) &lt; ('foo',+inf,+inf)
</pre><p>
                作成された間隔に初期条件よりも多い行が含まれる可能性があります。たとえば、前の間隔は値 <code class="literal">('foo', 11, 0)</code> を含みますが、これは元の条件を満たしません。
              </p></li><li class="listitem"><p>
                間隔内に含まれる行セットをカバーする条件が <code class="literal">OR</code> で組み合わされている場合、それらは、それらの間隔の和集合内に含まれる行セットをカバーする条件を形成します。条件が <code class="literal">AND</code> で組み合わされている場合、それらは間隔の共通集合内に含まれる行セットを対象とする条件を形成します。たとえば、2 パートインデックスでのこの条件の場合: 
              </p><pre class="programlisting">
(<em class="replaceable"><code>key_part1</code></em> = 1 AND <em class="replaceable"><code>key_part2</code></em> &lt; 2) OR (<em class="replaceable"><code>key_part1</code></em> &gt; 5)
</pre><p>
                間隔は次のとおりです。
              </p><pre class="programlisting">
(1,-inf) &lt; (<em class="replaceable"><code>key_part1</code></em>,<em class="replaceable"><code>key_part2</code></em>) &lt; (1,2)
(5,-inf) &lt; (<em class="replaceable"><code>key_part1</code></em>,<em class="replaceable"><code>key_part2</code></em>)
</pre><p>
                この例で、1 行目の間隔は、左境界に 1 つのキーパートを使用し、右境界に 2 つのキーパートを使用しています。2 行目の間隔は 1 つのキーパートのみを使用しています。<code class="literal">EXPLAIN</code> 出力の <code class="literal">key_len</code> カラムは、使用されたキープリフィクスの最大長を示しています。
              </p><p>
                場合によって、<code class="literal">key_len</code> はキーパートが使用されたことを示しますが、それが予期したものではないことがあります。<em class="replaceable"><code>key_part1</code></em> と <em class="replaceable"><code>key_part2</code></em> が <code class="literal">NULL</code> になることがあるとします。次に、<code class="literal">key_len</code> カラムに、次の条件の 2 つのキーパート長が表示されます。
              </p><pre class="programlisting">
<em class="replaceable"><code>key_part1</code></em> &gt;= 1 AND <em class="replaceable"><code>key_part2</code></em> &lt; 2
</pre><p>
                しかし、実際は条件が次に変換されます。
              </p><pre class="programlisting">
<em class="replaceable"><code>key_part1</code></em> &gt;= 1 AND <em class="replaceable"><code>key_part2</code></em> IS NOT NULL
</pre></li></ul></div><p>
            「<a class="xref" href="optimization.html#range-access-single-part" title="8.2.1.3.1 シングルパートインデックスの range アクセスメソッド">セクション8.2.1.3.1「シングルパートインデックスの range アクセスメソッド」</a>」では、単一パートインデックスで、範囲条件の間隔を組み合わせたり、削除したりするために、どのように最適化が実行されるかを説明しています。マルチパートインデックスでの範囲条件にも類似の手順が実行されます。
          </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="equality-range-optimization"></a>8.2.1.3.3 複数値比較の等価範囲の最適化</h5></div></div></div><p>
            <em class="replaceable"><code>col_name</code></em> がインデックス設定されたカラムである次の式を考慮します。
          </p><pre class="programlisting">
<em class="replaceable"><code>col_name</code></em> IN(<em class="replaceable"><code>val1</code></em>, ..., <em class="replaceable"><code>valN</code></em>)
<em class="replaceable"><code>col_name</code></em> = <em class="replaceable"><code>val1</code></em> OR ... OR <em class="replaceable"><code>col_name</code></em> = <em class="replaceable"><code>valN</code></em>
</pre><p>
            <em class="replaceable"><code>col_name</code></em> が複数の値のいずれかと等しい場合に、各式は true になります。これらの比較は等価範囲比較です (ここで<span class="quote">「<span class="quote">範囲</span>」</span>は単一の値です)。オプティマイザは、次のように等価範囲比較の対象とする行の読み取りのコストを推定します。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <em class="replaceable"><code>col_name</code></em> に一意のインデックスがある場合、指定した値を持つことができる行は多くても 1 つであるため、各範囲の行の見積もりは 1 です。
              </p></li><li class="listitem"><p>
                そうでない場合は、オプティマイザは、インデックスのダイブまたはインデックス統計を使用して、各範囲の行数を推定できます。
              </p></li></ul></div><p>
            インデックスダイブでは、オプティマイザは範囲の両端でダイブを作成し、範囲内の行数を見積もりとして使用します。たとえば、式 <code class="literal"><em class="replaceable"><code>col_name</code></em> IN (10, 20, 30)</code> には 3 つの等価範囲があり、オプティマイザは範囲あたり 2 つのダイブを作成して、行の見積もりを生成します。ダイブのペアごとに、指定した値を持つ行数の見積もりを生成します。
          </p><p>
            インデックスダイブは、正確な行見積もりを提供しますが、式内の比較値の数が増えるほど、オプティマイザの行見積もりの生成に時間がかかるようになります。インデックス統計の使用は、インデックスダイブより正確ではありませんが、大きな値リストの場合に、行見積もりが高速になります。
          </p><p>
            <code class="literal">eq_range_index_dive_limit</code> システム変数を使用して、オプティマイザが行の見積もり戦略を別の戦略に切り替える値の数を構成できます。統計の使用を無効にして、常にインデックスダイブを使用するには、<code class="literal">eq_range_index_dive_limit</code> を 0 に設定します。最大 <em class="replaceable"><code>N</code></em> 個の等価範囲の比較にインデックスダイブの使用を許可するには、<code class="literal">eq_range_index_dive_limit</code> を <em class="replaceable"><code>N</code></em> + 1 に設定します。
          </p><p>
            <code class="literal">eq_range_index_dive_limit</code> は MySQL 5.6.5 以降で使用できます。5.6.5 より前では、オプティマイザは <code class="literal">eq_range_index_dive_limit=0</code> と同等のインデックスダイブを使用します。
          </p><p>
            最適な推定を行うためにテーブルインデックス統計を更新するには、<code class="literal">ANALYZE TABLE</code> を使用します。
          </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="index-merge-optimization"></a>8.2.1.4 インデックスマージの最適化</h4></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#index-merge-intersection">8.2.1.4.1 インデックスマージ共通集合アクセスアルゴリズム</a></span></dt><dt><span class="section"><a href="optimization.html#index-merge-union">8.2.1.4.2 インデックスマージ和集合アクセスアルゴリズム</a></span></dt><dt><span class="section"><a href="optimization.html#index-merge-sort-union">8.2.1.4.3 インデックスマージソート和集合アクセスアルゴリズム</a></span></dt></dl></div><a class="indexterm" name="idm139979116405568"></a><a class="indexterm" name="idm139979116404288"></a><a class="indexterm" name="idm139979116402736"></a><p>
          <em class="firstterm">インデックスマージ</em>メソッドは、複数の <code class="literal">range</code> スキャンによって、行を取得しそれらの結果を 1 つにマージするために使用されます。このマージによって、その基盤となるスキャンの和集合、共通集合、または共通集合の和集合を生成できます。このアクセスメソッドは、1 つのテーブルからのインデックススキャンをマージします。複数のテーブルにわたるスキャンはマージしません。
        </p><p>
          <code class="literal">EXPLAIN</code> 出力では、インデックスマージメソッドは <code class="literal">type</code> カラムに <code class="literal">index_merge</code> と表示されます。この場合、<code class="literal">key</code> カラムには使用されたインデックスのリストが含まれ、<code class="literal">key_len</code> にはそれらのインデックスの最長のキーパートのリストが含まれます。
        </p><p>
          例:
        </p><pre class="programlisting">
SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key1</code></em> = 10 OR <em class="replaceable"><code>key2</code></em> = 20;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE (<em class="replaceable"><code>key1</code></em> = 10 OR <em class="replaceable"><code>key2</code></em> = 20) AND <em class="replaceable"><code>non_key</code></em>=30;

SELECT * FROM t1, t2
  WHERE (t1.<em class="replaceable"><code>key1</code></em> IN (1,2) OR t1.<em class="replaceable"><code>key2</code></em> LIKE '<em class="replaceable"><code>value</code></em>%')
  AND t2.<em class="replaceable"><code>key1</code></em>=t1.<em class="replaceable"><code>some_col</code></em>;

SELECT * FROM t1, t2
  WHERE t1.<em class="replaceable"><code>key1</code></em>=1
  AND (t2.<em class="replaceable"><code>key1</code></em>=t1.<em class="replaceable"><code>some_col</code></em> OR t2.<em class="replaceable"><code>key2</code></em>=t1.<em class="replaceable"><code>some_col2</code></em>);
</pre><p>
          インデックスマージメソッドにはいくつかのアクセスアルゴリズムがあります (<code class="literal">EXPLAIN</code> 出力の <code class="literal">Extra</code> フィールドで確認されます)。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">Using intersect(...)</code>
            </p></li><li class="listitem"><p>
              <code class="literal">Using union(...)</code>
            </p></li><li class="listitem"><p>
              <code class="literal">Using sort_union(...)</code>
            </p></li></ul></div><p>
          次のセクションでは、これらのメソッドについて詳しく説明します。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            インデックスマージ最適化アルゴリズムには次の既知の不具合があります。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                クエリーに <code class="literal">AND</code>/<code class="literal">OR</code> の深いネストのある複雑な <code class="literal">WHERE</code> 句があり、MySQL が最適なプランを選択しない場合、次の同一律を使用して、項を分配してみてください。
              </p><pre class="programlisting">
(<em class="replaceable"><code>x</code></em> AND <em class="replaceable"><code>y</code></em>) OR <em class="replaceable"><code>z</code></em> = (<em class="replaceable"><code>x</code></em> OR <em class="replaceable"><code>z</code></em>) AND (<em class="replaceable"><code>y</code></em> OR <em class="replaceable"><code>z</code></em>)
(<em class="replaceable"><code>x</code></em> OR <em class="replaceable"><code>y</code></em>) AND <em class="replaceable"><code>z</code></em> = (<em class="replaceable"><code>x</code></em> AND <em class="replaceable"><code>z</code></em>) OR (<em class="replaceable"><code>y</code></em> AND <em class="replaceable"><code>z</code></em>)
</pre></li><li class="listitem"><p>
                インデックスマージは全文インデックスには適用できません。将来の MySQL リリースでこれらを扱うように、それを拡張する予定です。
              </p></li><li class="listitem"><p>
                MySQL 5.6.6 より前では、一部のキーに対して範囲スキャンが使用可能な場合、オプティマイザはインデックスマージ和集合またはインデックスマージソート和集合アルゴリズムを使用することを考慮しません。たとえば、次のクエリーを考慮します。
              </p><pre class="programlisting">
SELECT * FROM t1 WHERE (goodkey1 &lt; 10 OR goodkey2 &lt; 20) AND badkey &lt; 30;
</pre><p>
                このクエリーでは、2 つのプランが使用可能です。
              </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                    <code class="literal">(goodkey1 &lt; 10 OR goodkey2 &lt; 20)</code> 条件を使用したインデックスマージスキャン。
                  </p></li><li class="listitem"><p>
                    <code class="literal">badkey &lt; 30</code> 条件を使用した範囲スキャン。
                  </p></li></ul></div><p>
                ただし、オプティマイザは 2 つめのプランしか考慮しません。
              </p></li></ul></div></div><p>
          インデックスマージアクセスメソッドの可能性のあるさまざまなバリアントとその他のアクセスメソッドとの選択は、使用可能な各種オプションのコスト見積もりに基づきます。
        </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="index-merge-intersection"></a>8.2.1.4.1 インデックスマージ共通集合アクセスアルゴリズム</h5></div></div></div><p>
            このアクセスアルゴリズムは、<code class="literal">WHERE</code> 句が、<code class="literal">AND</code> で結合されたさまざまなキーに対する複数の範囲条件に変換され、各条件が次のいずれかである場合に採用できます。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                この形式では、インデックスには正確に <em class="replaceable"><code>N</code></em> 個のパートがあります (つまり、すべてのインデックスパートがカバーされます)。
              </p><pre class="programlisting">
<em class="replaceable"><code>key_part1</code></em>=<em class="replaceable"><code>const1</code></em> AND <em class="replaceable"><code>key_part2</code></em>=<em class="replaceable"><code>const2</code></em> ... AND <em class="replaceable"><code>key_partN</code></em>=<em class="replaceable"><code>constN</code></em>
</pre></li><li class="listitem"><p>
                <code class="literal">InnoDB</code> テーブルの主キーに対する範囲条件。
              </p></li></ul></div><p>
            例:
          </p><pre class="programlisting">
SELECT * FROM <em class="replaceable"><code>innodb_table</code></em> WHERE <em class="replaceable"><code>primary_key</code></em> &lt; 10 AND <em class="replaceable"><code>key_col1</code></em>=20;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE (<em class="replaceable"><code>key1_part1</code></em>=1 AND <em class="replaceable"><code>key1_part2</code></em>=2) AND <em class="replaceable"><code>key2</code></em>=2;
</pre><p>
            インデックスマージ共通集合アルゴリズムは、使用されたすべてのインデックスの同時スキャンを実行し、マージされたインデックススキャンから受け取る行シーケンスの共通集合を生成します。
          </p><p>
            クエリーに使用されているすべてのカラムが、使用されるインデックスによってカバーされている場合、完全なテーブル行は取得されません (この場合、<code class="literal">EXPLAIN</code> 出力の <code class="literal">Extra</code> フィールドに <code class="literal">Using index</code> が含まれます)。次はそのようなクエリーの例です。
          </p><pre class="programlisting">
SELECT COUNT(*) FROM t1 WHERE key1=1 AND key2=1;
</pre><p>
            使用されるインデックスで、クエリーに使用されているすべてのカラムがカバーされない場合、使用されているすべてのキーの範囲条件が満たされている場合にのみ、完全な行が取得されます。
          </p><p>
            マージされた条件のいずれかが <code class="literal">InnoDB</code> テーブルの主キーに対する条件である場合、それは行の取得には使用されませんが、ほかの条件を使用して取得された行をフィルタ処理するために使用されます。
          </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="index-merge-union"></a>8.2.1.4.2 インデックスマージ和集合アクセスアルゴリズム</h5></div></div></div><p>
            このアルゴリズムの適用基準はインデックスマージメソッド共通集合アルゴリズムの場合と似ています。このアルゴリズムは、テーブルの <code class="literal">WHERE</code> 句が、<code class="literal">OR</code> で組み合わされたさまざまなキーに対する複数の範囲条件に変換されており、各条件が次のいずれかである場合に採用できます。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                この形式では、インデックスには正確に <em class="replaceable"><code>N</code></em> 個のパートがあります (つまり、すべてのインデックスパートがカバーされます)。
              </p><pre class="programlisting">
<em class="replaceable"><code>key_part1</code></em>=<em class="replaceable"><code>const1</code></em> AND <em class="replaceable"><code>key_part2</code></em>=<em class="replaceable"><code>const2</code></em> ... AND <em class="replaceable"><code>key_partN</code></em>=<em class="replaceable"><code>constN</code></em>
</pre></li><li class="listitem"><p>
                <code class="literal">InnoDB</code> テーブルの主キーに対する範囲条件。
              </p></li><li class="listitem"><p>
                インデックスマージメソッド共通集合アルゴリズムを適用できる条件。
              </p></li></ul></div><p>
            例:
          </p><pre class="programlisting">
SELECT * FROM t1 WHERE <em class="replaceable"><code>key1</code></em>=1 OR <em class="replaceable"><code>key2</code></em>=2 OR <em class="replaceable"><code>key3</code></em>=3;

SELECT * FROM <em class="replaceable"><code>innodb_table</code></em> WHERE (<em class="replaceable"><code>key1</code></em>=1 AND <em class="replaceable"><code>key2</code></em>=2) OR
  (<em class="replaceable"><code>key3</code></em>='foo' AND <em class="replaceable"><code>key4</code></em>='bar') AND <em class="replaceable"><code>key5</code></em>=5;
</pre></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="index-merge-sort-union"></a>8.2.1.4.3 インデックスマージソート和集合アクセスアルゴリズム</h5></div></div></div><p>
            このアクセスアルゴリズムは、<code class="literal">WHERE</code> 句が、<code class="literal">OR</code> で組み合わされた複数の範囲条件に変換されているが、インデックスマージメソッド和集合アルゴリズムを適用できない場合に採用されます。
          </p><p>
            例:
          </p><pre class="programlisting">
SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key_col1</code></em> &lt; 10 OR <em class="replaceable"><code>key_col2</code></em> &lt; 20;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE (<em class="replaceable"><code>key_col1</code></em> &gt; 10 OR <em class="replaceable"><code>key_col2</code></em> = 20) AND <em class="replaceable"><code>nonkey_col</code></em>=30;
</pre><p>
            ソート和集合アルゴリズムと和集合アルゴリズムの違いは、ソート和集合アルゴリズムでは、行を返す前にまずすべての行の行 ID をフェッチし、それらをソートする必要があることです。
          </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="condition-pushdown-optimization"></a>8.2.1.5 エンジンコンディションプッシュダウンの最適化</h4></div></div></div><p>
          この最適化は、インデックスが設定されていないカラムと定数との直接比較の効率性を向上します。このような場合、条件が評価のためにストレージエンジンに<span class="quote">「<span class="quote">プッシュダウン</span>」</span>されます。この最適化は、<code class="literal">NDB</code> ストレージエンジンでのみ使用できます。
        </p><p>
          MySQL Cluster では、この最適化によって、クラスタのデータノードとクエリーを発行した MySQL Server 間で、ネットワーク経由で一致しない行を送る必要性をなくすことができ、それを使用した場合のクエリーを、コンディションプッシュダウンが可能であっても使用しない場合より、5 - 10 倍高速化できます。
        </p><p>
          MySQL Cluster テーブルが次のように定義されているとします。
        </p><pre class="programlisting">
CREATE TABLE t1 (
    a INT,
    b INT,
    KEY(a)
) ENGINE=NDB;
</pre><p>
          コンディションプッシュダウンは、インデックスが設定されていないカラムと定数との比較を含む、ここに示すようなクエリーで使用できます。
        </p><pre class="programlisting">
SELECT a, b FROM t1 WHERE b = 10;
</pre><p>
          コンディションプッシュダウンの使用は、<code class="literal">EXPLAIN</code> の出力で確認できます。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT a,b FROM t1 WHERE b = 10\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t1
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 10
        Extra: Using where with pushed condition
</pre><p>
          ただし、コンディションプッシュダウンは、これらの 2 つのクエリーのいずれかと一緒に使用することは<span class="emphasis"><em>できません</em></span>。
        </p><pre class="programlisting">
SELECT a,b FROM t1 WHERE a = 10;
SELECT a,b FROM t1 WHERE b + 1 = 10;
</pre><p>
          カラム <code class="literal">a</code> にインデックスが存在するため、コンディションプッシュダウンは最初のクエリーには適用できません。(インデックスアクセスメソッドの方が効率的であるため、コンディションプッシュダウンよりも優先して選択されます。) インデックスが設定されていないカラム <code class="literal">b</code> を含む比較は間接的であるため、2 つめのクエリーにコンディションプッシュダウンを採用することはできません。(ただし、<code class="literal">WHERE</code> 句内で <code class="literal">b + 1 = 10</code> を <code class="literal">b = 9</code> にまとめる場合はコンディションプッシュダウンを適用できます。) 
        </p><p>
          <code class="literal">&gt;</code> または <code class="literal">&lt;</code> 演算子を使用して、インデックス設定されたカラムを定数と比較する場合にもコンディションプッシュダウンを採用できます。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT a, b FROM t1 WHERE a &lt; 2\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t1
         type: range
possible_keys: a
          key: a
      key_len: 5
          ref: NULL
         rows: 2
        Extra: Using where with pushed condition
</pre><p>
          コンディションプッシュダウンでサポートされるその他の比較には、次が含まれます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal"><em class="replaceable"><code>column</code></em> [NOT] LIKE <em class="replaceable"><code>pattern</code></em></code>
            </p><p>
              <em class="replaceable"><code>pattern</code></em> は、照合するパターンを含む文字列リテラルである必要があります。構文については、<a class="xref" href="functions.html#string-comparison-functions" title="12.5.1 文字列比較関数">セクション12.5.1「文字列比較関数」</a>を参照してください。
            </p></li><li class="listitem"><p>
              <code class="literal"><em class="replaceable"><code>column</code></em> IS [NOT] NULL</code>
            </p></li><li class="listitem"><p>
              <code class="literal"><em class="replaceable"><code>column</code></em> IN (<em class="replaceable"><code>value_list</code></em>)</code>
            </p><p>
              <em class="replaceable"><code>value_list</code></em> の各項目は定数のリテラル値である必要があります。
            </p></li><li class="listitem"><p>
              <code class="literal"><em class="replaceable"><code>column</code></em> BETWEEN <em class="replaceable"><code>constant1</code></em> AND <em class="replaceable"><code>constant2</code></em></code>
            </p><p>
              <em class="replaceable"><code>constant1</code></em> と <em class="replaceable"><code>constant2</code></em> はそれぞれ、定数のリテラル値である必要があります。
            </p></li></ul></div><p>
          前のリストのすべての場合で、条件をカラムと定数との 1 つ以上の直接比較の形式に変換できます。
        </p><p>
          エンジンコンディションプッシュダウンはデフォルトで有効です。サーバーの起動時にそれを無効にするには、<code class="literal">optimizer_switch</code> システム変数を設定します。たとえば、<code class="filename">my.cnf</code> ファイルで、次の行を使用します。
        </p><pre class="programlisting">
[mysqld]
optimizer_switch=engine_condition_pushdown=off
</pre><p>
          実行時に、次のようにコンディションプッシュダウンを有効にします。
        </p><pre class="programlisting">
SET optimizer_switch='engine_condition_pushdown=off';
</pre><p><b>制限 </b>
            エンジンコンディションプッシュダウンには次の制限があります。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              コンディションプッシュダウンは、<code class="literal">NDB</code> ストレージエンジンによってのみサポートされます。
            </p></li><li class="listitem"><p>
              カラムは定数とのみ比較できますが、これには、定数値に評価される式も含まれます。
            </p></li><li class="listitem"><p>
              比較に使用されるカラムは、<code class="literal">BLOB</code> 型または <code class="literal">TEXT</code> 型のいずれかであってはいけません。
            </p></li><li class="listitem"><p>
              カラムと比較される文字列値は、カラムと同じ照合順序を使用する必要があります。
            </p></li><li class="listitem"><p>
              結合は直接サポートされていません。複数のテーブルを含む条件は、可能な場合に個別にプッシュされます。実際にプッシュダウンされる条件を判断するには、<code class="literal">EXPLAIN EXTENDED</code> を使用します。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="index-condition-pushdown-optimization"></a>8.2.1.6 インデックスコンディションプッシュダウンの最適化</h4></div></div></div><p>
          インデックスコンディションプッシュダウン (ICP) は、MySQL がインデックスを使用してテーブルから行を取得する場合の最適化です。ICP を使用しない場合、ストレージエンジンはインデックスをトラバースして、ベーステーブル内で行を検索し、MySQL Server に返し、MySQL Server が行に対して <code class="literal">WHERE</code> 条件を評価します。ICP を有効にすると、インデックスからのフィールドだけを使用して <code class="literal">WHERE</code> 条件の部分を評価できる場合は、MySQL Server はこの <code class="literal">WHERE</code> 条件の部分をストレージエンジンにプッシュダウンします。ストレージエンジンは、インデックスエントリを使用して、プッシュされたインデックス条件を評価し、これが満たされている場合にのみ、テーブルから行を読み取ります。ICP は、ストレージエンジンがベーステーブルにアクセスする必要がある回数と、MySQL サーバーがストレージエンジンにアクセスする必要がある回数を削減できます。
        </p><p>
          インデックスコンディションプッシュダウン最適化は、完全なテーブル行にアクセスする必要がある場合に、<code class="literal">range</code>、<code class="literal">ref</code>、<code class="literal">eq_ref</code>、および <code class="literal">ref_or_null</code> アクセスメソッドで使用されます。この戦略は、<code class="literal">InnoDB</code> テーブルと <code class="literal">MyISAM</code> テーブルに使用できます。(インデックスコンディションプッシュダウンは、MySQL 5.6 ではパーティション化されたテーブルでサポートされていません。この問題は MySQL 5.7 で解決されています。)ただし、<code class="literal">InnoDB</code> テーブルの場合、ICP はセカンダリインデックスにのみ使用されます。ICP の目標は、完全なレコードの読み取りの回数を減らし、それによって IO 操作を減らすことです。<code class="literal">InnoDB</code> のクラスタ化されたインデックスの場合、完全なレコードはすでに <code class="literal">InnoDB</code> バッファーに読み込まれています。この場合に ICP を使用しても IO は削減されません。
        </p><p>
          この最適化の仕組みを確認するには、まずインデックスコンディションプッシュダウンが使用されない場合に、インデックススキャンがどのように進められるかを考察します。
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              まず、インデックスタプルを読み取り、次にそのインデックスタプルを使用して、完全なテーブル行を見つけて読み取ることで、次の行を取得します。
            </p></li><li class="listitem"><p>
              このテーブルに適用される <code class="literal">WHERE</code> 条件の部分をテストします。テスト結果に基づいて行を受け入れるか、拒否します。
            </p></li></ol></div><p>
          インデックスコンディションプッシュダウンが使用される場合、代わりにスキャンは次のように進められます。
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              次の行のインデックスタプルを取得します (ただし完全なテーブル行ではありません)。
            </p></li><li class="listitem"><p>
              このテーブルに適用され、インデックスカラムのみを使用してチェックできる <code class="literal">WHERE</code> 条件の部分をテストします。条件が満たされている場合、次の行のインデックスタプルに進みます。
            </p></li><li class="listitem"><p>
              条件が満たされている場合、インデックスタプルを使用して、完全なテーブル行を見つけて読み取ります。
            </p></li><li class="listitem"><p>
              このテーブルに適用される <code class="literal">WHERE</code> 条件の残りの部分をテストします。テスト結果に基づいて行を受け入れるか、拒否します。
            </p></li></ol></div><p>
          インデックスコンディションプッシュダウンが使用されると、<code class="literal">EXPLAIN</code> 出力の <code class="literal">Extra</code> カラムに <code class="literal">Using index condition</code> と表示されます。完全なテーブル行を読み取る必要がある場合に適用されないため、<code class="literal">Index only</code> は表示されません。
        </p><p>
          人とその住所に関する情報を格納するテーブルがあり、そのテーブルに、<code class="literal">INDEX (zipcode, lastname, firstname)</code> と定義されたインデックスがあるとします。ある個人の <code class="literal">zipcode</code> 値を知っているが、名前が確かでない場合に、次のように検索できます。
        </p><pre class="programlisting">
SELECT * FROM people
  WHERE zipcode='95054'
  AND lastname LIKE '%etrunia%'
  AND address LIKE '%Main Street%';
</pre><p>
          MySQL はインデックスを使用して、<code class="literal">zipcode='95054'</code> を持つ人をスキャンします。2 番目の部分 (<code class="literal">lastname LIKE '%etrunia%'</code>) は、スキャンする必要がある行数を制限するために使用できないため、インデックスコンディションプッシュダウンを使用しない場合に、このクエリーでは <code class="literal">zipcode='95054'</code> を持つすべての人の完全なテーブル行を取得する必要があります。
        </p><p>
          インデックスコンディションプッシュダウンを使用すると、MySQL は完全なテーブル行を読み取る前に、<code class="literal">lastname LIKE '%etrunia%'</code> 部分をチェックします。これにより、<code class="literal">lastname</code> 条件に一致しないすべてのインデックスタプルに対応する完全な行の読み取りが避けられます。
        </p><p>
          インデックスコンディションプッシュダウンはデフォルトで有効です。これは、<code class="literal">optimizer_switch</code> システム変数で <code class="literal">index_condition_pushdown</code> フラグを設定することで制御できます。<a class="xref" href="optimization.html#switchable-optimizations" title="8.8.5.2 切り替え可能な最適化の制御">セクション8.8.5.2「切り替え可能な最適化の制御」</a>を参照してください。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="index-extensions"></a>8.2.1.7 インデックス拡張の使用</h4></div></div></div><p>
          <code class="literal">InnoDB</code> は、自動的に各セカンダリインデックスに主キーカラムを追加して、それを拡張します。このテーブル定義について考えます。
        </p><pre class="programlisting">
CREATE TABLE t1 (
  i1 INT NOT NULL DEFAULT 0,
  i2 INT NOT NULL DEFAULT 0,
  d DATE DEFAULT NULL,
  PRIMARY KEY (i1, i2),
  INDEX k_d (d)
) ENGINE = InnoDB;
</pre><p>
          このテーブルでは、カラム <code class="literal">(i1, i2)</code> に主キーを定義しています。さらに、カラム <code class="literal">(d)</code> にセカンダリインデックス <code class="literal">k_d</code> を定義していますが、内部で <code class="literal">InnoDB</code> はこのインデックスを拡張し、それをカラム <code class="literal">(d, i1, i2)</code> として処理します。
        </p><p>
          MySQL 5.6.9 より前では、オプティマイザは拡張セカンダリインデックスの使用方法や使用するかどうかを判断する際に、その主キーカラムを考慮しません。5.6.9 以降、オプティマイザは主キーカラムを考慮するようになったため、より効率的なクエリー実行プランやパフォーマンスの向上につながる可能性があります。
        </p><p>
          オプティマイザは、<code class="literal">ref</code>、<code class="literal">range</code>、および <code class="literal">index_merge</code> インデックスアクセス、ルースインデックススキャン、結合とソートの最適化、および <code class="literal">MIN()</code>/<code class="literal">MAX()</code> 最適化に拡張セカンダリインデックスを使用できます。
        </p><p>
          次の例に、オプティマイザが拡張セカンダリインデックスを使用するかどうかによって、実行プランにどのような影響を与えるか示します。これらの行に <code class="literal">t1</code> が移入されているとします。
        </p><pre class="programlisting">
INSERT INTO t1 VALUES
(1, 1, '1998-01-01'), (1, 2, '1999-01-01'),
(1, 3, '2000-01-01'), (1, 4, '2001-01-01'),
(1, 5, '2002-01-01'), (2, 1, '1998-01-01'),
(2, 2, '1999-01-01'), (2, 3, '2000-01-01'),
(2, 4, '2001-01-01'), (2, 5, '2002-01-01'),
(3, 1, '1998-01-01'), (3, 2, '1999-01-01'),
(3, 3, '2000-01-01'), (3, 4, '2001-01-01'),
(3, 5, '2002-01-01'), (4, 1, '1998-01-01'),
(4, 2, '1999-01-01'), (4, 3, '2000-01-01'),
(4, 4, '2001-01-01'), (4, 5, '2002-01-01'),
(5, 1, '1998-01-01'), (5, 2, '1999-01-01'),
(5, 3, '2000-01-01'), (5, 4, '2001-01-01'),
(5, 5, '2002-01-01');
</pre><p>
          ここで次のクエリーを考慮します。
        </p><pre class="programlisting">
EXPLAIN SELECT COUNT(*) FROM t1 WHERE i1 = 3 AND d = '2000-01-01'
</pre><p>
          この例では、主キーがカラム <code class="literal">(i1, i2)</code> で構成され、クエリーで <code class="literal">i2</code> を参照していないため、オプティマイザは主キーを使用できません。代わりに、オプティマイザは <code class="literal">(d)</code> に対してセカンダリインデックス <code class="literal">k_d</code> を使用でき、実行プランは拡張インデックスを使用するかどうかによって異なります。
        </p><p>
          オプティマイザがインデックス拡張を考慮しない場合、それはインデックス <code class="literal">k_d</code> を <code class="literal">(d)</code> のみとして扱います。クエリーの <code class="literal">EXPLAIN</code> では次の結果が生成されます。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT COUNT(*) FROM t1 WHERE i1 = 3 AND d = '2000-01-01'\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t1
         type: ref
possible_keys: PRIMARY,k_d
          key: k_d
      key_len: 4
          ref: const
         rows: 5
        Extra: Using where; Using index
</pre><p>
          オプティマイザがインデックス拡張を考慮する場合、それはインデックス <code class="literal">k_d</code> を <code class="literal">(d, i1, i2)</code> として扱います。この場合、それは左端のインデックスプリフィクス <code class="literal">(d, i1)</code> を使用して、より適切な実行プランを生成できます。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT COUNT(*) FROM t1 WHERE i1 = 3 AND d = '2000-01-01'\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t1
         type: ref
possible_keys: PRIMARY,k_d
          key: k_d
      key_len: 8
          ref: const,const
         rows: 1
        Extra: Using index
</pre><p>
          どちらの場合も <code class="literal">key</code> は、オプティマイザがセカンダリインデックス <code class="literal">k_d</code> を使用することを示しますが、<code class="literal">EXPLAIN</code> 出力には、拡張インデックスの使用による次のような改善が示されます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">key_len</code> は 4 バイトから 8 バイトになり、キールックアップでカラム <code class="literal">d</code> だけでなく、<code class="literal">d</code> と <code class="literal">i1</code> も使用されていることを示しています。
            </p></li><li class="listitem"><p>
              キールックアップで 1 つではなく 2 つのキーパートが使用されるため、<code class="literal">ref</code> 値が <code class="literal">const</code> から <code class="literal">const,const</code> に変更されています。
            </p></li><li class="listitem"><p>
              <code class="literal">rows</code> 数は 5 から 1 に減少し、<code class="literal">InnoDB</code> が結果を生成するために調査する必要がある行数が少なくなることを示しています。
            </p></li><li class="listitem"><p>
              <code class="literal">Extra</code> 値が <code class="literal">Using where; Using index</code> から <code class="literal">Using index</code> に変更されています。このことは、データ行のカラムを参照せずに、インデックスのみを使用して、行を読み取れることを意味します。
            </p></li></ul></div><p>
          拡張インデックスの使用のオプティマイザの動作の違いは、<code class="literal">SHOW STATUS</code> でも確認できます。
        </p><pre class="programlisting">
FLUSH TABLE t1;
FLUSH STATUS;
SELECT COUNT(*) FROM t1 WHERE i1 = 3 AND d = '2000-01-01';
SHOW STATUS LIKE 'handler_read%'
</pre><p>
          前のステートメントには <code class="literal">FLUSH TABLE</code> と <code class="literal">FLUSH STATUS</code> が含まれ、テーブルキャッシュをフラッシュし、ステータスカウンタをクリアします。
        </p><p>
          インデックス拡張を使用しないと、<code class="literal">SHOW STATUS</code> は次の結果を生成します。
        </p><pre class="programlisting">
+-----------------------+-------+
| Variable_name         | Value |
+-----------------------+-------+
| Handler_read_first    | 0     |
| Handler_read_key      | 1     |
| Handler_read_last     | 0     |
| Handler_read_next     | 5     |
| Handler_read_prev     | 0     |
| Handler_read_rnd      | 0     |
| Handler_read_rnd_next | 0     |
+-----------------------+-------+
</pre><p>
          インデックス拡張を使用すると、<code class="literal">SHOW STATUS</code> は次の結果を生成します。<code class="literal">Handler_read_next</code> 値が 5 から 1 に減少し、インデックスをより効率的に使用していることを示しています。
        </p><pre class="programlisting">
+-----------------------+-------+
| Variable_name         | Value |
+-----------------------+-------+
| Handler_read_first    | 0     |
| Handler_read_key      | 1     |
| Handler_read_last     | 0     |
| Handler_read_next     | 1     |
| Handler_read_prev     | 0     |
| Handler_read_rnd      | 0     |
| Handler_read_rnd_next | 0     |
+-----------------------+-------+
</pre><p>
          <code class="literal">optimizer_switch</code> システム変数の <code class="literal">use_index_extensions</code> フラグにより、<code class="literal">InnoDB</code> テーブルのセカンダリインデックスの使用方法を判断する際に、オプティマイザが主キーカラムを考慮するかどうかを制御できます。デフォルトで、<code class="literal">use_index_extensions</code> は有効です。インデックス拡張の使用を無効にするとパフォーマンスが向上するかどうかを確認するには、次のステートメントを使用します。
        </p><pre class="programlisting">
SET optimizer_switch = 'use_index_extensions=off';
</pre><p>
          オプティマイザによるインデックス拡張の使用は、インデックス (16) のキーパートの数と最大キー長 (3072 バイト) への通常の制限によります。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="is-null-optimization"></a>8.2.1.8 IS NULL の最適化</h4></div></div></div><a class="indexterm" name="idm139979116142336"></a><a class="indexterm" name="idm139979116141024"></a><p>
          MySQL は、<em class="replaceable"><code>col_name</code></em> <code class="literal">=</code> <em class="replaceable"><code>constant_value</code></em> に対して使用できる同じ最適化を <em class="replaceable"><code>col_name</code></em> <code class="literal">IS NULL</code> に対しても実行できます。たとえば、MySQL は、インデックスと範囲を使用して、<code class="literal">IS NULL</code> を含む <code class="literal">NULL</code> を検索できます。
        </p><p>
          例:
        </p><pre class="programlisting">
SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key_col</code></em> IS NULL;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key_col</code></em> &lt;=&gt; NULL;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_col</code></em>=<em class="replaceable"><code>const1</code></em> OR <em class="replaceable"><code>key_col</code></em>=<em class="replaceable"><code>const2</code></em> OR <em class="replaceable"><code>key_col</code></em> IS NULL;
</pre><p>
          <code class="literal">WHERE</code> 句に、<code class="literal">NOT NULL</code> として宣言されているカラムの <em class="replaceable"><code>col_name</code></em> <code class="literal">IS NULL</code> 条件が含まれている場合、その式は最適化により除去されます。この最適化は、とにかくカラムで <code class="literal">NULL</code> が生成される可能性がある場合には行われません。たとえば、<code class="literal">LEFT JOIN</code> の右側のテーブルから取得されている場合です。
        </p><p>
          MySQL は、解決済みのサブクエリーで一般的な形式である <code class="literal"><em class="replaceable"><code>col_name</code></em> = <em class="replaceable"><code>expr</code></em> OR <em class="replaceable"><code>col_name</code></em> IS NULL</code> の組み合わせを最適化することもできます。この最適化が使用された場合、<code class="literal">EXPLAIN</code> で <code class="literal">ref_or_null</code> と示されます。
        </p><p>
          この最適化は、任意のキーパートに対して 1 つの <code class="literal">IS NULL</code> を処理できます。
        </p><p>
          テーブル <code class="literal">t2</code> のカラム <code class="literal">a</code> および <code class="literal">b</code> にインデックスがあるとして、最適化されるクエリーのいくつかの例:
        </p><pre class="programlisting">
SELECT * FROM t1 WHERE t1.a=<em class="replaceable"><code>expr</code></em> OR t1.a IS NULL;

SELECT * FROM t1, t2 WHERE t1.a=t2.a OR t2.a IS NULL;

SELECT * FROM t1, t2
  WHERE (t1.a=t2.a OR t2.a IS NULL) AND t2.b=t1.b;

SELECT * FROM t1, t2
  WHERE t1.a=t2.a AND (t2.b=t1.b OR t2.b IS NULL);

SELECT * FROM t1, t2
  WHERE (t1.a=t2.a AND t2.a IS NULL AND ...)
  OR (t1.a=t2.a AND t2.a IS NULL AND ...);
</pre><p>
          <code class="literal">ref_or_null</code> はまずリファレンスキーの読み取りを行い、次に <code class="literal">NULL</code> キー値のある行の個別の検索を実行します。
        </p><p>
          この最適化では、1 つの <code class="literal">IS NULL</code> レベルしか処理できません。次のクエリーでは、MySQL は式 <code class="literal">(t1.a=t2.a AND t2.a IS NULL)</code> に対してのみキールックアップを使用し、<code class="literal">b</code> に対してはキーパートを使用できません。
        </p><pre class="programlisting">
SELECT * FROM t1, t2
  WHERE (t1.a=t2.a AND t2.a IS NULL)
  OR (t1.b=t2.b AND t2.b IS NULL);
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="left-join-optimization"></a>8.2.1.9 LEFT JOIN および RIGHT JOIN の最適化</h4></div></div></div><a class="indexterm" name="idm139979116105344"></a><a class="indexterm" name="idm139979116104032"></a><p>
          MySQL は次のように <code class="literal"><em class="replaceable"><code>A</code></em> LEFT JOIN <em class="replaceable"><code>B</code></em> join_condition</code> を実装します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              テーブル <em class="replaceable"><code>B</code></em> は、テーブル <em class="replaceable"><code>A</code></em> と <em class="replaceable"><code>A</code></em> が依存するすべてのテーブルに依存して設定されます。
            </p></li><li class="listitem"><p>
              テーブル <em class="replaceable"><code>A</code></em> は、<code class="literal">LEFT JOIN</code> 条件で使用されるすべてのテーブル (<em class="replaceable"><code>B</code></em> を除く) に依存して設定されます。
            </p></li><li class="listitem"><p>
              <code class="literal">LEFT JOIN</code> 条件は、テーブル <em class="replaceable"><code>B</code></em> からの行の取得方法を決定するために使用されます。(言い換えると、<code class="literal">WHERE</code> 句内のすべての条件が使用されません)。
            </p></li><li class="listitem"><p>
              テーブルは常にそれが依存するすべてのテーブルのあとに読み取られることを除き、すべての標準の結合最適化が実行されます。循環依存関係がある場合、MySQL はエラーを発行します。
            </p></li><li class="listitem"><p>
              すべての標準 <code class="literal">WHERE</code> 最適化が実行されます。
            </p></li><li class="listitem"><p>
              <em class="replaceable"><code>A</code></em> に <code class="literal">WHERE</code> 句に一致する行があるが、<em class="replaceable"><code>B</code></em> に <code class="literal">ON</code> 条件に一致する行がない場合、すべてのカラムが <code class="literal">NULL</code> に設定された追加の <em class="replaceable"><code>B</code></em> 行が生成されます。
            </p></li><li class="listitem"><p>
              <code class="literal">LEFT JOIN</code> を使用して、一部のテーブルに存在しない行を検索し、<code class="literal">WHERE</code> 部分の <code class="literal"><em class="replaceable"><code>col_name</code></em> IS NULL</code> のテストを実行した場合 (ここで <em class="replaceable"><code>col_name</code></em> は <code class="literal">NOT NULL</code> と宣言されているカラム)、MySQL は <code class="literal">LEFT JOIN</code> 条件に一致する 1 つの行が見つかったあとに、それ以上の行 (の特定のキーの組み合わせ) の検索を停止します。
            </p></li></ul></div><p>
          <code class="literal">RIGHT JOIN</code> の実装は、テーブルの役割が逆の <code class="literal">LEFT JOIN</code> の場合と類似しています。
        </p><p>
          <a class="indexterm" name="idm139979116076352"></a> 結合オプティマイザは、テーブルを結合すべき順序を計算します。<code class="literal">LEFT JOIN</code> または <code class="literal">STRAIGHT_JOIN</code> によって強制されるテーブル読み取り順序は、確認するテーブル配列が少なくなるため、結合オプティマイザがはるかに高速にその作業を実行するのに役立ちます。これは、次のような種類のクエリーを実行する場合、<code class="literal">LEFT JOIN</code> によって <code class="literal">d</code> の前に <code class="literal">b</code> を読み取るように強制されるため、MySQL がその完全スキャンを実行することを意味します。
        </p><pre class="programlisting">
SELECT *
  FROM a JOIN b LEFT JOIN c ON (c.key=a.key)
  LEFT JOIN d ON (d.key=a.key)
  WHERE b.key=d.key;
</pre><p>
          この例の修正は、<code class="literal">a</code> と <code class="literal">b</code> が <code class="literal">FROM</code> 句内に示される順序を逆にすることです。
        </p><pre class="programlisting">
SELECT *
  FROM b JOIN a LEFT JOIN c ON (c.key=a.key)
  LEFT JOIN d ON (d.key=a.key)
  WHERE b.key=d.key;
</pre><p>
          <code class="literal">LEFT JOIN</code> では、生成された <code class="literal">NULL</code> 行に対して、<code class="literal">WHERE</code> 条件が常に false である場合、<code class="literal">LEFT JOIN</code> は通常の結合に変更されます。たとえば、<code class="literal">t2.column1</code> が <code class="literal">NULL</code> であった場合、次のクエリーの <code class="literal">WHERE</code> 句は false になります。
        </p><pre class="programlisting">
SELECT * FROM t1 LEFT JOIN t2 ON (column1) WHERE t2.column2=5;
</pre><p>
          そのため、クエリーを通常の結合に変換しても問題ありません。
        </p><pre class="programlisting">
SELECT * FROM t1, t2 WHERE t2.column2=5 AND t1.column1=t2.column1;
</pre><p>
          <a class="indexterm" name="idm139979116057952"></a> これにより、テーブル <code class="literal">t1</code> の前にテーブル <code class="literal">t2</code> を使用することがより適切なクエリー計画になる場合に、MySQL はそれを実行できるため、高速化できます。テーブルの結合順序についてヒントを提供するには、<code class="literal">STRAIGHT_JOIN</code> を使用します。(<a class="xref" href="sql-syntax.html#select" title="13.2.9 SELECT 構文">セクション13.2.9「SELECT 構文」</a>を参照してください。)
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="nested-loop-joins"></a>8.2.1.10 Nested Loop 結合アルゴリズム</h4></div></div></div><a class="indexterm" name="idm139979116051792"></a><a class="indexterm" name="idm139979116050272"></a><a class="indexterm" name="idm139979116048320"></a><a class="indexterm" name="idm139979116046768"></a><p>
          MySQL は、Nested Loop アルゴリズムまたはそのバリエーションを使用してテーブル間の結合を実行します。
        </p><p>
          <span class="bold"><strong>Nested Loop 結合アルゴリズム</strong></span>
        </p><p>
          単純な Nested Loop Join (NLJ) アルゴリズムは、ループ内の最初のテーブルから行を一度に 1 つずつ読み取り、各行を、結合の次のテーブルを処理するネストしたループに渡します。このプロセスは、結合するテーブルが残っている回数だけ繰り返されます。
        </p><p>
          3 つのテーブル <code class="literal">t1</code>、<code class="literal">t2</code>、および <code class="literal">t3</code> 間の結合が、次の結合型を使用して実行されるとします。
        </p><pre class="programlisting">
Table   Join Type
t1      range
t2      ref
t3      ALL
</pre><p>
          単純な NLJ アルゴリズムを使用した場合、結合は次のように処理されます。
        </p><pre class="programlisting">
for each row in t1 matching range {
  for each row in t2 matching reference key {
    for each row in t3 {
      if row satisfies join conditions,
      send to client
    }
  }
}
</pre><p>
          NLJ アルゴリズムでは、外側のループから内側のループに、一度に 1 つずつ行を渡すため、一般に内側のループで処理されるテーブルを何回も読み取ります。
        </p><p>
          <span class="bold"><strong>Block Nested Loop 結合アルゴリズム</strong></span>
        </p><p>
          Block Nested-Loop (BNL) 結合アルゴリズムは、外側のループで読み取られた行のバッファリングを使用して、内側のループでテーブルを読み取る必要がある回数が削減されます。たとえば、バッファーに 10 行が読み込まれ、このバッファーが次の内側のループに渡される場合、内側のループで読み取られる各行をバッファー内のすべての 10 行と比較できます。これにより、内部テーブルを読み取る必要のある回数が大幅に減少します。
        </p><p>
          MySQL は、次の条件下で結合バッファリングを使用します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">join_buffer_size</code> システム変数によって各結合バッファーのサイズが決まります。
            </p></li><li class="listitem"><p>
              結合バッファリングは、結合の型が <code class="literal">ALL</code> または <code class="literal">index</code> である (つまり、使用できるキーがなく、データ行またはインデックス行の完全スキャンがそれぞれ実行される場合) か、または <code class="literal">range</code> である場合に使用できます。MySQL 5.6 では、<a class="xref" href="optimization.html#bnl-bka-optimization" title="8.2.1.14 Block Nested Loop 結合と Batched Key Access 結合">セクション8.2.1.14「Block Nested Loop 結合と Batched Key Access 結合」</a>に説明するように、バッファリングの使用が外部結合に適用できるように拡張されています。
            </p></li><li class="listitem"><p>
              バッファリング可能な結合ごとに 1 つのバッファーが割り当てられるため、特定のクエリーが、複数の結合バッファーを使用して処理されることがあります。
            </p></li><li class="listitem"><p>
              <code class="literal">ALL</code> 型または <code class="literal">index</code> 型であっても、最初の非定数テーブルには結合バッファーが割り当てられません。
            </p></li><li class="listitem"><p>
              結合バッファーは、結合の実行前に割り当てられ、クエリーの完了後に解放されます。
            </p></li><li class="listitem"><p>
              結合バッファーには、行全体ではなく、結合に関連するカラムだけが格納されます。
            </p></li></ul></div><p>
          NLJ アルゴリズム (バッファリングなし) で先述した結合の例では、結合は結合バッファリングを使用すると、次のように実行されます。
        </p><pre class="programlisting">
for each row in t1 matching range {
  for each row in t2 matching reference key {
    store used columns from t1, t2 in join buffer
    if buffer is full {
      for each row in t3 {
        for each t1, t2 combination in join buffer {
          if row satisfies join conditions,
          send to client
        }
      }
      empty buffer
    }
  }
}

if buffer is not empty {
  for each row in t3 {
    for each t1, t2 combination in join buffer {
      if row satisfies join conditions,
      send to client
    }
  }
}
</pre><p>
          <em class="replaceable"><code>S</code></em> が結合バッファー内の格納される各 <code class="literal">t1</code>、<code class="literal">t2</code> の組み合わせのサイズであり、<em class="replaceable"><code>C</code></em> がバッファー内の組み合わせの数である場合、テーブル <code class="literal">t3</code> がスキャンされる回数は:
        </p><pre class="programlisting">
(<em class="replaceable"><code>S</code></em> * <em class="replaceable"><code>C</code></em>)/join_buffer_size + 1
</pre><p>
          <code class="literal">join_buffer_size</code> が前のすべての行の組み合わせを保持できるだけの大きさになる時点まで、<code class="literal">join_buffer_size</code> の値が大きくなるほど、<code class="literal">t3</code> スキャンの回数は減少します。その時点では、さらに大きくしても速度は向上しなくなります。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="nested-join-optimization"></a>8.2.1.11 ネストした結合の最適化</h4></div></div></div><p>
          結合を表す構文では、ネストした結合を使用できます。次の説明は、<a class="xref" href="sql-syntax.html#join" title="13.2.9.2 JOIN 構文">セクション13.2.9.2「JOIN 構文」</a>に説明する結合構文について言及しています。
        </p><p>
          <em class="replaceable"><code>table_factor</code></em> の構文は SQL 標準と比較して拡張されています。後者は <em class="replaceable"><code>table_reference</code></em> のみを受け付け、かっこ内のそれらのリストは受け付けません。これは、<em class="replaceable"><code>table_reference</code></em> 項目のリストの各カンマを内部結合と同等とみなす場合、保守的な拡張です。例:
        </p><pre class="programlisting">
SELECT * FROM t1 LEFT JOIN (t2, t3, t4)
                 ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)
</pre><p>
          次と同等です。
        </p><pre class="programlisting">
SELECT * FROM t1 LEFT JOIN (t2 CROSS JOIN t3 CROSS JOIN t4)
                 ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)
</pre><p>
          MySQL では、<code class="literal">CROSS JOIN</code> は <code class="literal">INNER JOIN</code> と構文上同等です (それらは相互に置き換え可能です)。標準 SQL では、それらは同等ではありません。<code class="literal">INNER JOIN</code> は <code class="literal">ON</code> 句と一緒に使用します。<code class="literal">CROSS JOIN</code> はそうでない場合でも使用できます。
        </p><p>
          一般に、内部結合操作のみを含む結合式内のかっこは無視できます。かっこを削除し、操作を左側にグループ化すると、結合式は: 
        </p><pre class="programlisting">
t1 LEFT JOIN (t2 LEFT JOIN t3 ON t2.b=t3.b OR t2.b IS NULL)
   ON t1.a=t2.a
</pre><p>
          次の式に変換されます。
        </p><pre class="programlisting">
(t1 LEFT JOIN t2 ON t1.a=t2.a) LEFT JOIN t3
    ON t2.b=t3.b OR t2.b IS NULL
</pre><p>
          まだ、2 つの式は同等ではありません。これを確認するには、テーブル <code class="literal">t1</code>、<code class="literal">t2</code>、<code class="literal">t3</code> が次の状態であるとします。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              テーブル <code class="literal">t1</code> には行 <code class="literal">(1)</code>、<code class="literal">(2)</code> が含まれます
            </p></li><li class="listitem"><p>
              テーブル <code class="literal">t2</code> には行 <code class="literal">(1,101)</code> が含まれます
            </p></li><li class="listitem"><p>
              テーブル <code class="literal">t3</code> には行 <code class="literal">(101)</code> が含まれます
            </p></li></ul></div><p>
          この場合、最初の式は行 <code class="literal">(1,1,101,101)</code>、<code class="literal">(2,NULL,NULL,NULL)</code> を含む結果セットを返し、2 番目の式は行 <code class="literal">(1,1,101,101)</code>、<code class="literal">(2,NULL,NULL,101)</code> を返します。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT *</code></strong>
    -&gt; <strong class="userinput"><code>FROM t1</code></strong>
    -&gt;      <strong class="userinput"><code>LEFT JOIN</code></strong>
    -&gt;      <strong class="userinput"><code>(t2 LEFT JOIN t3 ON t2.b=t3.b OR t2.b IS NULL)</code></strong>
    -&gt;      <strong class="userinput"><code>ON t1.a=t2.a;</code></strong>
+------+------+------+------+
| a    | a    | b    | b    |
+------+------+------+------+
|    1 |    1 |  101 |  101 |
|    2 | NULL | NULL | NULL |
+------+------+------+------+

mysql&gt; <strong class="userinput"><code>SELECT *</code></strong>
    -&gt; <strong class="userinput"><code>FROM (t1 LEFT JOIN t2 ON t1.a=t2.a)</code></strong>
    -&gt;      <strong class="userinput"><code>LEFT JOIN t3</code></strong>
    -&gt;      <strong class="userinput"><code>ON t2.b=t3.b OR t2.b IS NULL;</code></strong>
+------+------+------+------+
| a    | a    | b    | b    |
+------+------+------+------+
|    1 |    1 |  101 |  101 |
|    2 | NULL | NULL |  101 |
+------+------+------+------+
</pre><p>
          次の例では、外部結合操作が内部結合操作と一緒に使用されています。
        </p><pre class="programlisting">
t1 LEFT JOIN (t2, t3) ON t1.a=t2.a
</pre><p>
          その式は次の式に変換できません。
        </p><pre class="programlisting">
t1 LEFT JOIN t2 ON t1.a=t2.a, t3.
</pre><p>
          指定されたテーブル状態では、次の 2 つの式は異なる行セットを返します。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT *</code></strong>
    -&gt; <strong class="userinput"><code>FROM t1 LEFT JOIN (t2, t3) ON t1.a=t2.a;</code></strong>
+------+------+------+------+
| a    | a    | b    | b    |
+------+------+------+------+
|    1 |    1 |  101 |  101 |
|    2 | NULL | NULL | NULL |
+------+------+------+------+

mysql&gt; <strong class="userinput"><code>SELECT *</code></strong>
    -&gt; <strong class="userinput"><code>FROM t1 LEFT JOIN t2 ON t1.a=t2.a, t3;</code></strong>
+------+------+------+------+
| a    | a    | b    | b    |
+------+------+------+------+
|    1 |    1 |  101 |  101 |
|    2 | NULL | NULL |  101 |
+------+------+------+------+
</pre><p>
          したがって、外部結合演算子を含む結合式のかっこを省略すると、元の式の結果セットが変わることがあります。
        </p><p>
          正確に言えば、左外部結合操作の右オペランドと右結合操作の左オペランドのかっこを無視することはできません。言い換えれば、外部結合操作の内部テーブル式のかっこを無視することはできません。ほかのオペランド (外部テーブルのオペランド) のかっこは無視できます。
        </p><p>
          次の式: 
        </p><pre class="programlisting">
(t1,t2) LEFT JOIN t3 ON P(t2.b,t3.b)
</pre><p>
          は次の式と同等です。
        </p><pre class="programlisting">
t1, t2 LEFT JOIN t3 ON P(t2.b,t3.b)
</pre><p>
          任意のテーブル <code class="literal">t1,t2,t3</code> と属性 <code class="literal">t2.b</code> および <code class="literal">t3.b</code> に対する任意の条件 <code class="literal">P</code> の場合。
        </p><p>
          結合式 (<em class="replaceable"><code>join_table</code></em>) の結合操作の実行順序が左から右でない場合は常に、ネストした結合と呼びます。次のクエリーを考慮します。
        </p><pre class="programlisting">
SELECT * FROM t1 LEFT JOIN (t2 LEFT JOIN t3 ON t2.b=t3.b) ON t1.a=t2.a
  WHERE t1.a &gt; 1

SELECT * FROM t1 LEFT JOIN (t2, t3) ON t1.a=t2.a
  WHERE (t2.b=t3.b OR t2.b IS NULL) AND t1.a &gt; 1
</pre><p>
          それらのクエリーは次のネストした結合が含まれるとみなされます。
        </p><pre class="programlisting">
t2 LEFT JOIN t3 ON t2.b=t3.b
t2, t3
</pre><p>
          最初のクエリーでは、左結合操作によってネストした結合が形成され、2 番目のクエリーでは、内部結合操作によってそれが形成されます。
        </p><p>
          最初のクエリーでは、かっこを省略できます。結合式の文法構造によって結合操作の実行の同じ順序が決定されます。2 番目のクエリーでは、かっこを省略できますが、それらがなくてもここの結合式は一義的に解釈できます。(ここの拡張構文では、2 番目のクエリーの <code class="literal">(t2, t3)</code> のかっこは必要ですが、理論上はなくても解析できます。<code class="literal">LEFT JOIN</code> と <code class="literal">ON</code> が式 <code class="literal">(t2,t3)</code> の左と右の区切り文字の役割を果たすため、クエリーの構文構造が一義的になります。)
        </p><p>
          前の例でこれらの点を説明します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              内部結合のみを含む (外部結合を含まない) 結合式の場合、かっこは削除できます。かっこを削除して、左から右に評価できます (実際には、任意の順序でテーブルを評価できます)。
            </p></li><li class="listitem"><p>
              一般に、外部結合、または内部結合と混在した外部結合の場合には、同じことが当てはまりません。かっこの削除によって、結果が変わることがあります。
            </p></li></ul></div><a class="indexterm" name="idm139979115945328"></a><a class="indexterm" name="idm139979115943120"></a><p>
          ネストした外部結合を含むクエリーは内部結合を含むクエリーと同じパイプライン方式で実行されます。正確には、Nested Loop 結合アルゴリズムのバリエーションが利用されます。Nested Loop 結合がクエリーを実行する際に利用するアルゴリズムスキーマを思い出してください。たとえば、次の形式の 3 つのテーブル <code class="literal">T1,T2,T3</code> に対する結合クエリーがあるとします。
        </p><pre class="programlisting">
SELECT * FROM T1 INNER JOIN T2 ON P1(T1,T2)
                 INNER JOIN T3 ON P2(T2,T3)
  WHERE P(T1,T2,T3).
</pre><p>
          ここでは、<code class="literal">P1(T1,T2)</code> と <code class="literal">P2(T3,T3)</code> が何らかの結合条件 (式での) で、<code class="literal">P(T1,T2,T3)</code> はテーブル <code class="literal">T1,T2,T3</code> のカラムに対する条件です。
        </p><p>
          Nested Loop 結合アルゴリズムでは、このクエリーを次のように実行します。
        </p><pre class="programlisting">
FOR each row t1 in T1 {
  FOR each row t2 in T2 such that P1(t1,t2) {
    FOR each row t3 in T3 such that P2(t2,t3) {
      IF P(t1,t2,t3) {
         t:=t1||t2||t3; OUTPUT t;
      }
    }
  }
}
</pre><p>
          表記 <code class="literal">t1||t2||t3</code> は、<span class="quote">「<span class="quote">行 <code class="literal">t1</code>、<code class="literal">t2</code>、および <code class="literal">t3</code> のカラムを連結させて行が構築される</span>」</span>ことを意味します。次のいくつかの例では、行名が表示される場所の <code class="literal">NULL</code> は、その行の各カラムに <code class="literal">NULL</code> が使用されることを意味します。たとえば、<code class="literal">t1||t2||NULL</code> は、行 <span class="quote">「<span class="quote"><code class="literal">t1</code> と <code class="literal">t2</code> のカラムと、<code class="literal">t3</code> の各カラムの <code class="literal">NULL</code> を連結させて行が構築される</span>」</span>ことを意味します。
        </p><p>
          ここで、ネストした外部結合のあるクエリーを考慮しましょう。
        </p><pre class="programlisting">
SELECT * FROM T1 LEFT JOIN
              (T2 LEFT JOIN T3 ON P2(T2,T3))
              ON P1(T1,T2)
  WHERE P(T1,T2,T3).
</pre><p>
          このクエリーでは、Nested Loop パターンを変更して、次を取得します。
        </p><pre class="programlisting">
FOR each row t1 in T1 {
  BOOL f1:=FALSE;
  FOR each row t2 in T2 such that P1(t1,t2) {
    BOOL f2:=FALSE;
    FOR each row t3 in T3 such that P2(t2,t3) {
      IF P(t1,t2,t3) {
        t:=t1||t2||t3; OUTPUT t;
      }
      f2=TRUE;
      f1=TRUE;
    }
    IF (!f2) {
      IF P(t1,t2,NULL) {
        t:=t1||t2||NULL; OUTPUT t;
      }
      f1=TRUE;
    }
  }
  IF (!f1) {
    IF P(t1,NULL,NULL) {
      t:=t1||NULL||NULL; OUTPUT t;
    }
  }
}
</pre><p>
          一般に、外部結合操作の最初の内部テーブルのネストしたループでは、ループの前にオフにされ、ループのあとにチェックされるフラグが導入されます。フラグは、外部テーブルの現在行で、内側オペランドを表すテーブルからの一致が見つかったときにオンにされます。ループサイクルの最後でフラグがまだオフの場合は、外部テーブルの現在行で一致が見つかりませんでした。この例では、行が内部テーブルのカラムの <code class="literal">NULL</code> 値で補完されます。結果の行は、出力の最終チェックまたは次のネストしたループに渡されますが、行が、埋め込まれたすべての外部結合の結合条件を満たしている場合に限られます。
        </p><p>
          ここでの例では、次の式で表された外部結合テーブルが埋め込まれています。
        </p><pre class="programlisting">
(T2 LEFT JOIN T3 ON P2(T2,T3))
</pre><p>
          内部結合を含むクエリーでは、オプティマイザは次のようなネストしたループの異なる順序を選択することがあります。
        </p><pre class="programlisting">
FOR each row t3 in T3 {
  FOR each row t2 in T2 such that P2(t2,t3) {
    FOR each row t1 in T1 such that P1(t1,t2) {
      IF P(t1,t2,t3) {
         t:=t1||t2||t3; OUTPUT t;
      }
    }
  }
}
</pre><p>
          外部結合を含むクエリーでは、オプティマイザは外部テーブルのループが内部テーブルのループの前に実行される順序のみを選択できます。つまり、外部結合を含むクエリーでは、1 つだけのネスト順序しか使用できません。次のクエリーでは、オプティマイザは 2 つの異なるネストを評価します。
        </p><pre class="programlisting">
SELECT * T1 LEFT JOIN (T2,T3) ON P1(T1,T2) AND P2(T1,T3)
  WHERE P(T1,T2,T3)
</pre><p>
          ネストは次のようになります。
        </p><pre class="programlisting">
FOR each row t1 in T1 {
  BOOL f1:=FALSE;
  FOR each row t2 in T2 such that P1(t1,t2) {
    FOR each row t3 in T3 such that P2(t1,t3) {
      IF P(t1,t2,t3) {
        t:=t1||t2||t3; OUTPUT t;
      }
      f1:=TRUE
    }
  }
  IF (!f1) {
    IF P(t1,NULL,NULL) {
      t:=t1||NULL||NULL; OUTPUT t;
    }
  }
}
</pre><p>
          および:
        </p><pre class="programlisting">
FOR each row t1 in T1 {
  BOOL f1:=FALSE;
  FOR each row t3 in T3 such that P2(t1,t3) {
    FOR each row t2 in T2 such that P1(t1,t2) {
      IF P(t1,t2,t3) {
        t:=t1||t2||t3; OUTPUT t;
      }
      f1:=TRUE
    }
  }
  IF (!f1) {
    IF P(t1,NULL,NULL) {
      t:=t1||NULL||NULL; OUTPUT t;
    }
  }
}
</pre><p>
          両方のネストで、<code class="literal">T1</code> は外部結合で使用されているため、外側のループで処理される必要があります。<code class="literal">T2</code> と <code class="literal">T3</code> は内部結合で使用されているため、その結合は内側のループで処理される必要があります。ただし、結合は内部結合であるため、<code class="literal">T2</code> と <code class="literal">T3</code> はどちらの順序でも処理できます。
        </p><p>
          内部結合の Nested Loop アルゴリズムについて説明した際に、クエリー実行のパフォーマンスに与える影響が大きい場合があるという詳細については省きました。いわゆる<span class="quote">「<span class="quote">プッシュダウン</span>」</span> 条件については説明しませんでした。たとえば、<code class="literal">WHERE</code> 条件 <code class="literal">P(T1,T2,T3)</code> を論理積標準形によって表現できるとします。
        </p><pre class="programlisting">
P(T1,T2,T2) = C1(T1) AND C2(T2) AND C3(T3).
</pre><p>
          この場合、MySQL は実際に内部結合を含むクエリーの実行に、次の Nested Loop スキーマを使用します。
        </p><pre class="programlisting">
FOR each row t1 in T1 such that C1(t1) {
  FOR each row t2 in T2 such that P1(t1,t2) AND C2(t2)  {
    FOR each row t3 in T3 such that P2(t2,t3) AND C3(t3) {
      IF P(t1,t2,t3) {
         t:=t1||t2||t3; OUTPUT t;
      }
    }
  }
}
</pre><p>
          等位項 <code class="literal">C1(T1)</code>、<code class="literal">C2(T2)</code>、<code class="literal">C3(T3)</code> がそれぞれ、もっとも内側のループから、評価可能なもっとも外側のループまで押し出されることがわかります。<code class="literal">C1(T1)</code> がきわめて制限の強い条件である場合、このコンディションプッシュダウンによって、テーブル <code class="literal">T1</code> から内側ループに渡される行数が大幅に少なくなることがあります。結果として、クエリーの実行時間が大幅に短縮される可能性があります。
        </p><p>
          外部結合を含むクエリーでは、外部テーブルの現在行で内部テーブルに一致があることが見つかったあとにのみ、<code class="literal">WHERE</code> 条件がチェックされます。そのため、内側のネストしたループからのプッシュ条件の最適化は、外部結合を含むクエリーには直接適用できません。ここでは、一致が検出されたときにオンにされるフラグによって保護された、条件付きプッシュダウン述語を導入する必要があります。
        </p><p>
          次の外部結合のある例の場合:
        </p><pre class="programlisting">
P(T1,T2,T3)=C1(T1) AND C(T2) AND C3(T3)
</pre><p>
          保護されたプッシュダウン条件を使用した Nested Loop スキーマは次のようになります。
        </p><pre class="programlisting">
FOR each row t1 in T1 such that C1(t1) {
  BOOL f1:=FALSE;
  FOR each row t2 in T2
      such that P1(t1,t2) AND (f1?C2(t2):TRUE) {
    BOOL f2:=FALSE;
    FOR each row t3 in T3
        such that P2(t2,t3) AND (f1&amp;&amp;f2?C3(t3):TRUE) {
      IF (f1&amp;&amp;f2?TRUE:(C2(t2) AND C3(t3))) {
        t:=t1||t2||t3; OUTPUT t;
      }
      f2=TRUE;
      f1=TRUE;
    }
    IF (!f2) {
      IF (f1?TRUE:C2(t2) &amp;&amp; P(t1,t2,NULL)) {
        t:=t1||t2||NULL; OUTPUT t;
      }
      f1=TRUE;
    }
  }
  IF (!f1 &amp;&amp; P(t1,NULL,NULL)) {
      t:=t1||NULL||NULL; OUTPUT t;
  }
}
</pre><p>
          一般に、プッシュダウン述語は <code class="literal">P1(T1,T2)</code> や <code class="literal">P(T2,T3)</code> などの結合条件から抽出できます。この場合、プッシュダウン述語は、対応する外部結合操作によって生成される <code class="literal">NULL</code> が補完された行の述語のチェックを妨げるフラグによっても保護されます。
        </p><p>
          ここで、ある内部テーブルから、同じネストした結合内の別の内部テーブルへのキーによるアクセスは、それが <code class="literal">WHERE</code> 条件からの述語によって引き起こされている場合に、禁止されます。(この例では、条件付きキーアクセスを使用できますが、この手法はまだ MySQL 5.6 に採用されていません。)
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="outer-join-simplification"></a>8.2.1.12 外部結合の単純化</h4></div></div></div><p>
          クエリーの <code class="literal">FROM</code> 句内のテーブル式は、多くの場合単純化されます。
        </p><p>
          パーサー段階で、右外部結合操作を含むクエリーは、左結合操作のみを含む同等のクエリーに変換されます。一般的な場合、変換は次のルールに従って実行されます。
        </p><pre class="programlisting">
(T1, ...) RIGHT JOIN (T2,...) ON P(T1,...,T2,...) =
(T2, ...) LEFT JOIN (T1,...) ON P(T1,...,T2,...)
</pre><p>
          形式 <code class="literal">T1 INNER JOIN T2 ON P(T1,T2)</code> のすべての内部結合式は、<code class="literal">WHERE</code> 条件に (または埋め込まれる結合の結合条件が存在する場合は、それに) 等位項として結合されるリスト <code class="literal">T1,T2</code>、<code class="literal">P(T1,T2)</code> によって、置き換えられます。
        </p><p>
          オプティマイザは、外部結合操作を含む結合クエリーのプランを評価する際、そのような各操作で、外部テーブルが内部テーブルより前にアクセスされるプランのみを考慮に入れます。そのようなプランのみ、Nested Loop スキーマによって、外部結合操作を含むクエリーを実行できるため、オプティマイザのオプションが制限されます。
        </p><p>
          次の形式のクエリーがあるとします。
        </p><pre class="programlisting">
SELECT * T1 LEFT JOIN T2 ON P1(T1,T2)
  WHERE P(T1,T2) AND R(T2)
</pre><p>
          テーブル <code class="literal">T2</code> の一致する行数を大幅に狭める <code class="literal">R(T2)</code> を使用しています。クエリーをそのまま実行した場合、オプティマイザは、テーブル <code class="literal">T2</code> の前にテーブル <code class="literal">T1</code> にアクセスする以外に選択肢がなく、きわめて非効率的な実行プランにつながる可能性があります。
        </p><p>
          さいわい、MySQL では、<code class="literal">WHERE</code> 条件が NULL を受け付けない場合に、それらのクエリーを外部結合操作を含まないクエリーに変換します。条件は、操作のために構築された <code class="literal">NULL</code> で補完された行に対し、<code class="literal">FALSE</code> または <code class="literal">UNKNOWN</code> に評価する場合に、外部結合操作に対して NULL を受け付けないと呼ばれます。
        </p><p>
          したがって、この外部結合の場合: 
        </p><pre class="programlisting">
T1 LEFT JOIN T2 ON T1.A=T2.A
</pre><p>
          次のような条件は NULL を受け付けません。
        </p><pre class="programlisting">
T2.B IS NOT NULL,
T2.B &gt; 3,
T2.C &lt;= T1.C,
T2.B &lt; 2 OR T2.C &gt; 1
</pre><p>
          次のような条件は NULL を受け付けます。
        </p><pre class="programlisting">
T2.B IS NULL,
T1.B &lt; 3 OR T2.B IS NOT NULL,
T1.B &lt; 3 OR T2.B &gt; 3
</pre><p>
          条件が外部結合操作に対して NULL を受け付けるかどうかをチェックする一般的なルールは単純です。条件は次の場合に NULL を受け付けます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              その形式が <code class="literal">A IS NOT NULL</code> で、<code class="literal">A</code> がいずれかの内部テーブルの属性である場合
            </p></li><li class="listitem"><p>
              いずれかの引数が <code class="literal">NULL</code> である場合に、<code class="literal">UNKNOWN</code> に評価する内部テーブルへの参照を含む述語である場合
            </p></li><li class="listitem"><p>
              NULL を受け付けない条件を等位項として含む論理積である場合
            </p></li><li class="listitem"><p>
              NULL を受け付けない条件の論理和である場合。
            </p></li></ul></div><p>
          条件は、クエリー内で、ある外部結合操作に対しては NULL を受け付けないが、ほかの外部結合操作に対しては NULL を受け付ける場合があります。次のクエリーで: 
        </p><pre class="programlisting">
SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
                 LEFT JOIN T3 ON T3.B=T1.B
  WHERE T3.C &gt; 0
</pre><p>
          <code class="literal">WHERE</code> 条件は、2 番目の外部結合操作に対しては NULL を受け付けませんが、最初の外部結合操作に対しては NULL を受け付けます。
        </p><p>
          <code class="literal">WHERE</code> 条件がクエリーの外部結合操作に対して NULL を受け付けない場合、外部結合操作は内部結合操作に置き換えられます。
        </p><p>
          たとえば、前のクエリーは次のクエリーに置き換えられます。
        </p><pre class="programlisting">
SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
                 INNER JOIN T3 ON T3.B=T1.B
  WHERE T3.C &gt; 0
</pre><p>
          元のクエリーでは、オプティマイザは、1 つのアクセス順序 <code class="literal">T1,T2,T3</code> のみと互換性のあるプランを評価します。置換先のクエリーでは、さらにアクセスシーケンス <code class="literal">T3,T1,T2</code> も考慮します。
        </p><p>
          ある外部結合操作の変換によって、別の操作の変換がトリガーされることがあります。そのため、次のクエリー: 
        </p><pre class="programlisting">
SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
                 LEFT JOIN T3 ON T3.B=T2.B
  WHERE T3.C &gt; 0
</pre><p>
          は、まず次のクエリーに変換されます。
        </p><pre class="programlisting">
SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
                 INNER JOIN T3 ON T3.B=T2.B
  WHERE T3.C &gt; 0
</pre><p>
          これは次のクエリーと同等です。
        </p><pre class="programlisting">
SELECT * FROM (T1 LEFT JOIN T2 ON T2.A=T1.A), T3
  WHERE T3.C &gt; 0 AND T3.B=T2.B
</pre><p>
          ここで、条件 <code class="literal">T3.B=T2.B</code> は NULL を受け付けず、外部結合をまったく含まないクエリーを取得するため、残りの外部結合操作を内部結合に置き換えることができます。
        </p><pre class="programlisting">
SELECT * FROM (T1 INNER JOIN T2 ON T2.A=T1.A), T3
  WHERE T3.C &gt; 0 AND T3.B=T2.B
</pre><p>
          場合によっては、埋め込まれた外部結合操作を置き換えることに成功しても、埋め込む外部結合を変換できない場合があります。次のクエリー: 
        </p><pre class="programlisting">
SELECT * FROM T1 LEFT JOIN
              (T2 LEFT JOIN T3 ON T3.B=T2.B)
              ON T2.A=T1.A
  WHERE T3.C &gt; 0
</pre><p>
          は次に変換されます。
        </p><pre class="programlisting">
SELECT * FROM T1 LEFT JOIN
              (T2 INNER JOIN T3 ON T3.B=T2.B)
              ON T2.A=T1.A
  WHERE T3.C &gt; 0,
</pre><p>
          それは埋め込む外部結合操作を含む形式にのみ書き換えることができます。
        </p><pre class="programlisting">
SELECT * FROM T1 LEFT JOIN
              (T2,T3)
              ON (T2.A=T1.A AND T3.B=T2.B)
  WHERE T3.C &gt; 0.
</pre><p>
          クエリーに埋め込まれた外部結合操作を変換しようとする場合、<code class="literal">WHERE</code> 条件と一緒に埋め込む外部結合に対して、結合条件を考慮する必要があります。次のクエリーで: 
        </p><pre class="programlisting">
SELECT * FROM T1 LEFT JOIN
              (T2 LEFT JOIN T3 ON T3.B=T2.B)
              ON T2.A=T1.A AND T3.C=T1.C
  WHERE T3.D &gt; 0 OR T1.D &gt; 0
</pre><p>
          <code class="literal">WHERE</code> 条件は埋め込まれた外部結合に対しては NULL を受け付けますが、埋め込む外部結合 <code class="literal">T2.A=T1.A AND T3.C=T1.C</code> の結合条件は NULL を受け付けません。そのため、クエリーは次に変換できます。
        </p><pre class="programlisting">
SELECT * FROM T1 LEFT JOIN
              (T2, T3)
              ON T2.A=T1.A AND T3.C=T1.C AND T3.B=T2.B
  WHERE T3.D &gt; 0 OR T1.D &gt; 0
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mrr-optimization"></a>8.2.1.13 Multi-Range Read の最適化</h4></div></div></div><a class="indexterm" name="idm139979115829072"></a><a class="indexterm" name="idm139979115826960"></a><p>
          セカンダリインデックスでの範囲スキャンを使用して行を読み取ると、テーブルが大きく、ストレージエンジンのキャッシュに格納されていない場合、ベーステーブルへのランダムディスクアクセスが多発する結果になることがあります。Disk-Sweep Multi-Range Read (MRR) 最適化を使用すると、MySQL は、最初にインデックスだけをスキャンし、該当する行のキーを収集することによって、範囲スキャンのランダムディスクアクセスの回数を軽減しようとします。続いてキーがソートされ、最後に主キーの順序を使用してベーステーブルから行が取得されます。Disk-Sweep MRR の目的は、ランダムディスクアクセスの回数を減らし、その代わりに、ベーステーブルデータの順次スキャンを増やすことです。
        </p><p>
          Multi-Range Read の最適化には、次のメリットがあります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              MRR により、データ行はインデックスタプルに基づいて、ランダムな順序ではなく、順次アクセスできます。サーバーはクエリー条件を満たすインデックスタプルセットを取得し、それらをデータ行 ID 順に従ってソートし、ソートされたタプルを使用して、データ行を順番に取得します。これにより、データアクセスの効率が向上し、負荷が軽減されます。
            </p></li><li class="listitem"><p>
              MRR により、範囲インデックススキャンや結合属性にインデックスを使用する等価結合などの、インデックスタプル経由でのデータ行へのアクセスを必要とする操作のキーアクセスのリクエストのバッチ処理が可能になります。MRR はインデックス範囲のシーケンスを反復処理して、対象のインデックスタプルを取得します。これらの結果が累積されると、それらは対応するデータ行にアクセスするために使用されます。データ行の読み取りを開始する前に、すべてのインデックスタプルを取得する必要はありません。
            </p></li></ul></div><p>
          次のシナリオでは、MRR の最適化に利益がある場合について説明しています。
        </p><p>
          シナリオ A: インデックス範囲スキャンと等価結合操作で、<code class="literal">InnoDB</code> テーブルと <code class="literal">MyISAM</code> テーブルに対して MRR を使用できます。
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              インデックスタプルの一部はバッファーに累積されます。
            </p></li><li class="listitem"><p>
              バッファー内のタプルはそれらのデータ行 ID によってソートされます。
            </p></li><li class="listitem"><p>
              データ行には、ソートされたインデックスタプルシーケンスに従ってアクセスされます。
            </p></li></ol></div><p>
          シナリオ B: 複数範囲インデックススキャンで、または属性によって等価結合を実行する際に、<code class="literal">NDB</code> テーブルに対して、MRR を使用できます。
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              単一キー範囲の可能性のある範囲の一部は、クエリーが送信される中央ノード上のバッファーに累積されます。
            </p></li><li class="listitem"><p>
              範囲はデータ行にアクセスする実行ノードに送信されます。
            </p></li><li class="listitem"><p>
              アクセスされた行はパッケージに格納され、中央ノードに返送されます。
            </p></li><li class="listitem"><p>
              受け取ったデータ行を含むパッケージはバッファーに入れられます。
            </p></li><li class="listitem"><p>
              データ行がバッファーから読み取られます。
            </p></li></ol></div><p>
          MRR が使用された場合は、<code class="literal">EXPLAIN</code> 出力の <code class="literal">Extra</code> カラムに <code class="literal">Using MRR</code> と示されます。
        </p><p>
          <code class="literal">InnoDB</code> と <code class="literal">MyISAM</code> は、クエリー結果を生成するために完全なテーブル行にアクセスする必要がない場合、MRR を使用しません。これは、(<a class="link" href="glossary.html#glos_covering_index" title="カバリングインデックス">カバーするインデックス</a>経由で) インデックスタプル内の情報に完全に基づいて結果を生成できる場合であり、MRR にメリットはありません。
        </p><p>
          MRR を使用でき、<code class="literal">(<em class="replaceable"><code>key_part1</code></em>, <em class="replaceable"><code>key_part2</code></em>)</code> にインデックスがあると想定するクエリーの例:
        </p><pre class="programlisting">
SELECT * FROM t
  WHERE <em class="replaceable"><code>key_part1</code></em> &gt;= 1000 AND <em class="replaceable"><code>key_part1</code></em> &lt; 2000
  AND <em class="replaceable"><code>key_part2</code></em> = 10000;
</pre><p>
          インデックスは <code class="literal">(<em class="replaceable"><code>key_part1</code></em>, <em class="replaceable"><code>key_part2</code></em>)</code> 値のタプルから構成され、最初に <em class="replaceable"><code>key_part1</code></em> によって、次に <em class="replaceable"><code>key_part2</code></em> によって順序付けされます。
        </p><p>
          MRR を使用しないと、インデックススキャンでは、インデックスタプル内の <em class="replaceable"><code>key_part2</code></em> 値に関係なく、1000 から最大 2000 の <em class="replaceable"><code>key_part1</code></em> 範囲のすべてのインデックスタプルがカバーされます。スキャンは範囲内のタプルに 10000 以外の <em class="replaceable"><code>key_part2</code></em> 値が含まれるかぎり、追加の作業を実行します。
        </p><p>
          MRR を使用すると、スキャンが <em class="replaceable"><code>key_part1</code></em> の 1 つの値 (1000、1001、...、1999) に 1 つずつ、複数の範囲に分割されます。これらの各スキャンは、<em class="replaceable"><code>key_part2</code></em> = 10000 のタプルのみを検索する必要があります。インデックスに <em class="replaceable"><code>key_part2</code></em> が 10000 でない多数のタプルが含まれる場合、MRR により、読み取られるインデックスタプルが大幅に少なくなります。
        </p><p>
          これを間隔表記を使用して表すには、非 MRR スキャンで、<em class="replaceable"><code>key_part2</code></em> = 10000 のタプルでない多数のタプルが含まれる可能性のあるインデックス範囲 <code class="literal">[{1000, 10000}, {2000, MIN_INT})</code> を調査する必要があります。MRR スキャンでは、<em class="replaceable"><code>key_part2</code></em> = 10000 のタプルのみを含む複数の単一ポイント間隔 <code class="literal">[{1000, 10000}]</code>、...、<code class="literal">[{1999, 10000}]</code> を調査します。
        </p><p>
          2 つの <code class="literal">optimizer_switch</code> システム変数フラグは、MRR 最適化の使用へのインタフェースを提供します。<code class="literal">mrr</code> フラグは MRR を有効にするかどうかを制御します。<code class="literal">mrr</code> が有効である (<code class="literal">on</code>) 場合、<code class="literal">mrr_cost_based</code> フラグは、オプティマイザが MRR を使用するか使用しないかをコストベースで選択しようと試みる (<code class="literal">on</code>) か、または可能なかぎり MRR を使用する (<code class="literal">off</code>) かどうかを制御します。デフォルトで、<code class="literal">mrr</code> は <code class="literal">on</code> で <code class="literal">mrr_cost_based</code> は <code class="literal">on</code> です。<a class="xref" href="optimization.html#switchable-optimizations" title="8.8.5.2 切り替え可能な最適化の制御">セクション8.8.5.2「切り替え可能な最適化の制御」</a>を参照してください。
        </p><p>
          MRR では、ストレージエンジンが、そのバッファーに割り当てることができるメモリーの量のガイドラインとして、<code class="literal">read_rnd_buffer_size</code> システム変数の値を使用します。エンジンは最大 <code class="literal">read_rnd_buffer_size</code> バイトを使用して、単一のパスで処理する範囲の数を判断します。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="bnl-bka-optimization"></a>8.2.1.14 Block Nested Loop 結合と Batched Key Access 結合</h4></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#join-buffer-management">8.2.1.14.1 Block Nested Loop および Batched Key Access アルゴリズムの結合バッファー管理</a></span></dt><dt><span class="section"><a href="optimization.html#bnl-optimization">8.2.1.14.2 外部結合と準結合の Block Nested Loop アルゴリズム</a></span></dt><dt><span class="section"><a href="optimization.html#bka-optimization">8.2.1.14.3 Batched Key Access 結合</a></span></dt></dl></div><a class="indexterm" name="idm139979115766464"></a><a class="indexterm" name="idm139979115764352"></a><a class="indexterm" name="idm139979115762432"></a><a class="indexterm" name="idm139979115760288"></a><p>
          MySQL 5.6 では、結合したテーブルと結合バッファーの両方へのインデックスアクセスを使用する、Batched Key Access (BKA) 結合アルゴリズムが使用できるようになりました。BKA アルゴリズムは、ネストした外部結合を含む、内部結合、外部結合、および準結合操作をサポートします。BKA には、テーブルスキャンの効率性の向上による結合パフォーマンスの改善というメリットもあります。さらに、以前内部結合にのみ使用されていた Block Nested Loop (BNL) 結合アルゴリズムが拡張され、ネストした外部結合を含む、外部結合と準結合操作にも採用できます。
        </p><p>
          次のセクションでは、元の BNL アルゴリズムの拡張の基礎にある結合バッファー管理、拡張 BNL アルゴリズム、および BKA アルゴリズムについて説明します。準結合戦略については、「<a class="xref" href="optimization.html#semi-joins" title="8.2.1.18.1 準結合変換によるサブクエリーの最適化">セクション8.2.1.18.1「準結合変換によるサブクエリーの最適化」</a>」を参照してください。
        </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="join-buffer-management"></a>8.2.1.14.1 Block Nested Loop および Batched Key Access アルゴリズムの結合バッファー管理</h5></div></div></div><p>
            MySQL 5.6 では、MySQL Server は、内部テーブルへのインデックスアクセスなしの内部結合だけでなく、外部結合と、サブクエリーのフラット化のあとに見られる準結合も実行するために結合バッファーを使用できます。さらに、内部テーブルへのインデックスアクセスがある場合、結合バッファーを効率的に使用できます。
          </p><p>
            結合バッファー管理コードは、目的の行カラムの値を格納する際に、結合バッファー領域を少し効率的に利用します。行カラムの値が <code class="literal">NULL</code> の場合に行カラムにバッファー内の追加バイトを割り当てず、<code class="literal">VARCHAR</code> 型の値には最小数のバイトが割り当てられます。
          </p><p>
            コードでは、標準と増分の 2 つの種類のバッファーをサポートします。結合テーブル <code class="literal">t1</code> と <code class="literal">t2</code> に結合バッファー <code class="literal">B1</code> が使用されており、この操作の結果が結合バッファー <code class="literal">B2</code> を使用して、テーブル <code class="literal">t3</code> と結合されるとします。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                標準結合バッファーには、各結合オペランドからのカラムが格納されます。<code class="literal">B2</code> が標準結合バッファーである場合、<code class="literal">B2</code> に入れられる各行 <em class="replaceable"><code>r</code></em> は、<code class="literal">B1</code> からの行 <em class="replaceable"><code>r1</code></em> のカラムと、テーブル <code class="literal">t2</code> からの一致する行 <em class="replaceable"><code>r2</code></em> の対象のカラムから構成されます。
              </p></li><li class="listitem"><p>
                増分結合バッファーには、2 つめの結合オペランドによって生成されるテーブルの行からのカラムのみが格納されます。つまり、それは 1 つめのオペランドバッファーからの行の増分になります。<code class="literal">B2</code> が増分結合バッファーである場合、それには、<code class="literal">B1</code> からの行 <em class="replaceable"><code>r1</code></em> へのリンクとともに、行 <em class="replaceable"><code>r2</code></em> の対象のカラムが格納されます。
              </p></li></ul></div><p>
            増分結合バッファーは常に、前の結合操作からの結合バッファーに相対的な増分になるため、最初の結合操作からのバッファーは常に標準バッファーになります。直前の例では、テーブル <code class="literal">t1</code> および <code class="literal">t2</code> を結合するために使用されるバッファー <code class="literal">B1</code> は標準バッファーである必要があります。
          </p><p>
            結合操作に使用される増分バッファーの各行には、結合されるテーブルからの行の対象カラムのみが格納されます。これらのカラムには、最初の結合オペランドによって生成されたテーブルからの一致する行の対象カラムへの参照が追加されます。増分バッファー内の複数の行から、カラムが前の結合バッファーに格納されている同じ行 <em class="replaceable"><code>r</code></em> を参照できます。ただし、これらのすべての行が行 <em class="replaceable"><code>r</code></em> に一致する場合にかぎります。
          </p><p>
            増分バッファーにより、前の結合操作で使用されたバッファーからのカラムのコピーの頻度を少なくできます。これにより、一般に、最初の結合オペランドによって生成された行が 2 つめの結合オペランドによって生成される複数の行に一致する可能性があるため、バッファー領域が節約されます。最初のオペランドからの行のコピーを何回も行う必要がありません。さらに、増分バッファーにより、コピー時間の短縮のため、処理時間も節約されます。
          </p><p>
            MySQL 5.6.3 現在、<code class="literal">optimizer_switch</code> システム変数の <code class="literal">block_nested_loop</code> および <code class="literal">batched_key_access</code> フラグによって、オプティマイザがどのように Block Nested Loop 結合アルゴリズムと Batched Key Access 結合アルゴリズムを使用するかを制御します。デフォルトで、<code class="literal">block_nested_loop</code> は <code class="literal">on</code> で <code class="literal">batched_key_access</code> は <code class="literal">off</code> です。<a class="xref" href="optimization.html#switchable-optimizations" title="8.8.5.2 切り替え可能な最適化の制御">セクション8.8.5.2「切り替え可能な最適化の制御」</a>を参照してください。
          </p><p>
            MySQL 5.6.3 より前では、<code class="literal">optimizer_join_cache_level</code> システム変数によって、結合バッファー管理を制御します。この変数の指定可能な値とそれらの意味については、<a class="xref" href="server-administration.html#server-system-variables" title="5.1.4 サーバーシステム変数">セクション5.1.4「サーバーシステム変数」</a>の説明を参照してください。
          </p><p>
            準結合戦略については、「<a class="xref" href="optimization.html#semi-joins" title="8.2.1.18.1 準結合変換によるサブクエリーの最適化">セクション8.2.1.18.1「準結合変換によるサブクエリーの最適化」</a>」を参照してください。
          </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="bnl-optimization"></a>8.2.1.14.2 外部結合と準結合の Block Nested Loop アルゴリズム</h5></div></div></div><a class="indexterm" name="idm139979115716608"></a><a class="indexterm" name="idm139979115714496"></a><p>
            MySQL 5.6 では、BNL アルゴリズムの元の実装が、外部結合および準結合操作をサポートするように拡張されています。
          </p><p>
            結合バッファーを使用して、これらの操作が実行されると、バッファーに入れられた各行に一致フラグが付加されます。
          </p><p>
            結合バッファーを使用して、外部結合操作が実行された場合、2 つめのオペランドによって生成されたテーブルの各行で、結合バッファー内の各行に対する一致がチェックされます。一致が見つかると、新しく拡張された行が形成され (元の行に 2 つめのオペランドからのカラムを追加)、残りの結合操作によるさらなる拡張のために送られます。さらに、バッファー内の一致した行の一致フラグが有効にされます。結合されるテーブル内のすべての行が調査されたあとに、結合バッファーがスキャンされます。有効にされた一致フラグがないバッファーからの各行は、<code class="literal">NULL</code> の補完 (2 つめのオペランドの各カラムの <code class="literal">NULL</code> 値) によって拡張され、残りの結合操作によるさらなる拡張のために送られます。
          </p><p>
            MySQL 5.6.3 現在、<code class="literal">optimizer_switch</code> システム変数の <code class="literal">block_nested_loop</code> フラグによって、オプティマイザが Block Nested Loop アルゴリズムを使用する方法を制御します。デフォルトで、<code class="literal">block_nested_loop</code> は <code class="literal">on</code> です。<a class="xref" href="optimization.html#switchable-optimizations" title="8.8.5.2 切り替え可能な最適化の制御">セクション8.8.5.2「切り替え可能な最適化の制御」</a>を参照してください。
          </p><p>
            MySQL 5.6.3 より前では、<code class="literal">optimizer_join_cache_level</code> システム変数によって、結合バッファー管理を制御します。この変数の指定可能な値とそれらの意味については、<a class="xref" href="server-administration.html#server-system-variables" title="5.1.4 サーバーシステム変数">セクション5.1.4「サーバーシステム変数」</a>の説明を参照してください。
          </p><p>
            <code class="literal">EXPLAIN</code> 出力で、<code class="literal">Extra</code> 値に <code class="literal">Using join buffer (Block Nested Loop)</code> が含まれ、<code class="literal">type</code> 値が <code class="literal">ALL</code>、<code class="literal">index</code>、または <code class="literal">range</code> の場合に、テーブルへの BNL の使用が示されます。
          </p><p>
            準結合戦略については、「<a class="xref" href="optimization.html#semi-joins" title="8.2.1.18.1 準結合変換によるサブクエリーの最適化">セクション8.2.1.18.1「準結合変換によるサブクエリーの最適化」</a>」を参照してください。
          </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="bka-optimization"></a>8.2.1.14.3 Batched Key Access 結合</h5></div></div></div><a class="indexterm" name="idm139979115691040"></a><a class="indexterm" name="idm139979115688928"></a><p>
            MySQL 5.6.3 では Batched Key Access (BKA) 結合アルゴリズムと呼ばれるテーブルの結合の方法を実装しています。BKA は、2 つめの結合オペランドによって生成されるテーブルへのインデックスアクセスがある場合に適用できます。BNL 結合アルゴリズムと同様、BKA 結合アルゴリズムでは、結合バッファーを使用して、結合操作の最初のオペランドによって生成された行の対象カラムを累積します。次に、BKA アルゴリズムは、バッファー内のすべての行に対し、結合されるテーブルにアクセスするためのキーを構築し、これらのキーをインデックスルックアップのために、データベースエンジンに一括で送信します。キーは、Multi-Range Read (MRR) インタフェース経由で、エンジンに送信されます (<a class="xref" href="optimization.html#mrr-optimization" title="8.2.1.13 Multi-Range Read の最適化">セクション8.2.1.13「Multi-Range Read の最適化」</a>を参照してください)。キーの送信後、MRR エンジン関数は最適な方法で、インデックス内のルックアップを実行し、これらのキーによって見つかった結合されたテーブルの行をフェッチし、BKA 結合アルゴリズムに一致する行の提供を開始します。一致する各行は結合バッファー内の行への参照が組み合わされます。
          </p><p>
            BKA が使用される場合、<code class="literal">join_buffer_size</code> の値によって、ストレージエンジンへの個々のリクエストでのキーのバッチの大きさが定義されます。バッファーが大きいほど、結合操作の右側テーブルへの順次アクセスが増え、パフォーマンスを著しく向上させることができます。
          </p><p>
            BKA を使用するには、<code class="literal">optimizer_switch</code> システム変数の <code class="literal">batched_key_access</code> フラグが <code class="literal">on</code> に設定されている必要があります。BKA では MRR を使用するため、<code class="literal">mrr</code> フラグも <code class="literal">on</code> に設定されている必要があります。現在、MRR のコスト見積もりはきわめて悲観的です。したがって、BKA を使用するには、<code class="literal">mrr_cost_based</code> を <code class="literal">off</code> にする必要もあります。次の設定によって、BKA が有効になります。
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET optimizer_switch='mrr=on,mrr_cost_based=off,batched_key_access=on';</code></strong>
</pre><p>
            MRR 関数が実行される 2 つのシナリオがあります。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                最初のシナリオは、<code class="literal">InnoDB</code> や <code class="literal">MyISAM</code> などの従来のディスクベースのストレージエンジンで使用されます。これらのエンジンでは通常、結合バッファーからのすべての行のキーが一度に MRR インタフェースに送信されます。エンジン固有の MRR 関数は、送信されたキーのインデックスルックアップを実行し、それらから行 ID (または主キー) を取得して、BKA アルゴリズムからのリクエストによって、これらの選択されたすべての行 ID の行を 1 つずつフェッチします。各行は、結合バッファー内の一致した行へのアクセスを可能にするアソシエーション参照とともに返されます。行は MRR 関数によって最適な方法でフェッチされます。それらは、行 ID (主キー) 順でフェッチされます。これにより、読み取りがランダムな順序ではなく、ディスク順になるため、パフォーマンスが向上します。
              </p></li><li class="listitem"><p>
                2 つめのシナリオは、<code class="literal">NDB</code> などのリモートストレージエンジンで使用されます。結合バッファーからの行の一部のキーのパッケージが、それらのアソシエーションとともに、MySQL Server (SQL ノード) によって、MySQL Cluster データノードに送信されます。返信で、SQL ノードは、対応するアソシエーションが組み合わされた一致する行のパッケージ (または複数のパッケージ) を受け取ります。BKA 結合アルゴリズムでは、これらの行を取得し、新しく結合された行を構築します。次に、新しいキーセットがデータノードに送信され、返されたパッケージからの行が新しい結合された行の構築に使用されます。このプロセスは、結合バッファーからの最後のキーがデータノードに送信され、SQL ノードがこれらのキーに一致するすべての行を受け取り、結合するまで、続行されます。これにより、SQL ノードによってデータノードに送信されるキーを含むパッケージが少なくなることは、結合操作を実行するために、それとデータノード間のラウンドトリップが少なくなることを意味するため、パフォーマンスが向上します。
              </p></li></ul></div><p>
            最初のシナリオでは、結合バッファーの一部がインデックスルックアップによって選択され、MRR 関数へのパラメータとして渡される行 ID (主キー) を格納するために予約されます。
          </p><p>
            結合バッファーからの行に対して構築されるキーを格納するための特別なバッファーはありません。代わりに、バッファー内の次の行のキーを構築する関数が、MRR 関数へのパラメータとして渡されます。
          </p><p>
            <code class="literal">EXPLAIN</code> 出力で、<code class="literal">Extra</code> 値に <code class="literal">Using join buffer (Batched Key Access)</code> が含まれ、<code class="literal">type</code> 値が <code class="literal">ref</code> または <code class="literal">eq_ref</code> の場合に、テーブルへの BKA の使用が示されます。
          </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="order-by-optimization"></a>8.2.1.15 ORDER BY の最適化</h4></div></div></div><p>
          場合によって、MySQL は、インデックスを使用して、特別なソートを行わずに <code class="literal">ORDER BY</code> 句を満たすことができます。
        </p><p>
          インデックスのすべての未使用の部分とすべての特別な <code class="literal">ORDER BY</code> カラムが <code class="literal">WHERE</code> 句内で定数であるかぎり、<code class="literal">ORDER BY</code> がインデックスに完全に一致しない場合でもインデックスを使用できます。次のクエリーではインデックスを使用して <code class="literal">ORDER BY</code> 部分を解決します。
        </p><pre class="programlisting">
SELECT * FROM t1
  ORDER BY <em class="replaceable"><code>key_part1</code></em>,<em class="replaceable"><code>key_part2</code></em>,... ;

SELECT * FROM t1
  WHERE <em class="replaceable"><code>key_part1</code></em> = <em class="replaceable"><code>constant</code></em>
  ORDER BY <em class="replaceable"><code>key_part2</code></em>;

SELECT * FROM t1
  ORDER BY <em class="replaceable"><code>key_part1</code></em> DESC, <em class="replaceable"><code>key_part2</code></em> DESC;

SELECT * FROM t1
  WHERE <em class="replaceable"><code>key_part1</code></em> = 1
  ORDER BY <em class="replaceable"><code>key_part1</code></em> DESC, <em class="replaceable"><code>key_part2</code></em> DESC;

SELECT * FROM t1
  WHERE <em class="replaceable"><code>key_part1</code></em> &gt; <em class="replaceable"><code>constant</code></em>
  ORDER BY <em class="replaceable"><code>key_part1</code></em> ASC;

SELECT * FROM t1
  WHERE <em class="replaceable"><code>key_part1</code></em> &lt; <em class="replaceable"><code>constant</code></em>
  ORDER BY <em class="replaceable"><code>key_part1</code></em> DESC;

SELECT * FROM t1
  WHERE <em class="replaceable"><code>key_part1</code></em> = <em class="replaceable"><code>constant1</code></em> AND <em class="replaceable"><code>key_part2</code></em> &gt; <em class="replaceable"><code>constant2</code></em>
  ORDER BY <em class="replaceable"><code>key_part2</code></em>;
</pre><p>
          場合によって、MySQL は <code class="literal">WHERE</code> 句に一致する行を見つけるためにインデックスを使用しても、<code class="literal">ORDER BY</code> を解決するために、インデックスを使用<span class="emphasis"><em>できない</em></span>ことがあります。これらの例には、次のようなものが含まれます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              さまざまなキーに対して <code class="literal">ORDER BY</code> を使用します。
            </p><pre class="programlisting">
SELECT * FROM t1 ORDER BY <em class="replaceable"><code>key1</code></em>, <em class="replaceable"><code>key2</code></em>;
</pre></li><li class="listitem"><p>
              キーの連続しない部分に対して <code class="literal">ORDER BY</code> を使用します。
            </p><pre class="programlisting">
SELECT * FROM t1 WHERE <em class="replaceable"><code>key2</code></em>=<em class="replaceable"><code>constant</code></em> ORDER BY <em class="replaceable"><code>key_part2</code></em>;
</pre></li><li class="listitem"><p>
              <code class="literal">ASC</code> と <code class="literal">DESC</code> を混在させます。
            </p><pre class="programlisting">
SELECT * FROM t1 ORDER BY <em class="replaceable"><code>key_part1</code></em> DESC, <em class="replaceable"><code>key_part2</code></em> ASC;
</pre></li><li class="listitem"><p>
              行をフェッチするために使用されるキーが <code class="literal">ORDER BY</code> で使用されるキーと同じでありません。
            </p><pre class="programlisting">
SELECT * FROM t1 WHERE <em class="replaceable"><code>key2</code></em>=<em class="replaceable"><code>constant</code></em> ORDER BY <em class="replaceable"><code>key1</code></em>;
</pre></li><li class="listitem"><p>
              キーカラム名以外の項を含む式で <code class="literal">ORDER BY</code> を使用します。
            </p><pre class="programlisting">
SELECT * FROM t1 ORDER BY ABS(<em class="replaceable"><code>key</code></em>);
SELECT * FROM t1 ORDER BY -<em class="replaceable"><code>key</code></em>;
</pre></li><li class="listitem"><p>
              多数のテーブルを結合しようとしており、<code class="literal">ORDER BY</code> 内のカラムがすべて、行の取得に使用される最初の非定数テーブルからのものとはかぎりません。(これは <code class="literal">EXPLAIN</code> 出力で、<code class="literal">const</code> 結合型を持たない最初のテーブルです。) 
            </p></li><li class="listitem"><p>
              <code class="literal">ORDER BY</code> 式と <code class="literal">GROUP BY</code> 式が異なります。
            </p></li><li class="listitem"><p>
              <code class="literal">ORDER BY</code> 句に指定されたカラムのプリフィクスのみにインデックスを設定しています。この場合、インデックスを使用してソート順序を完全には解決できません。たとえば、<code class="literal">CHAR(20)</code> カラムがあり、その先頭の 10 バイトだけにインデックスを設定している場合、インデックスで、10 バイト目を越える値を区別できないため、<code class="literal">filesort</code> が必要になります。
            </p></li><li class="listitem"><p>
              使用されたテーブルインデックスの種類が、行を順番に格納しません。たとえば、これは、<code class="literal">MEMORY</code> テーブルの <code class="literal">HASH</code> インデックスに当てはまります。
            </p></li></ul></div><p>
          インデックスをソートに使用できるかどうかは、カラムエイリアスの使用によって影響を受けることがあります。カラム <code class="literal">t1.a</code> にインデックスが設定されているとします。次のステートメントでは、選択リスト内のカラム名は <code class="literal">a</code> です。これは <code class="literal">t1.a</code> を指しているため、<code class="literal">ORDER BY</code> 内の <code class="literal">a</code> への参照にはインデックスを使用できます。
        </p><pre class="programlisting">
SELECT a FROM t1 ORDER BY a;
</pre><p>
          次のステートメントでも、選択リスト内のカラム名は <code class="literal">a</code> ですが、これはエイリアス名です。これは <code class="literal">ABS(a)</code> を指しているため、<code class="literal">ORDER BY</code> 内の <code class="literal">a</code> への参照にはインデックスを使用できません。
        </p><pre class="programlisting">
SELECT ABS(a) AS a FROM t1 ORDER BY a;
</pre><p>
          次のステートメントでは、<code class="literal">ORDER BY</code> は、選択リスト内のカラムの名前でない名前を参照しています。ただし、<code class="literal">t1</code> には <code class="literal">a</code> というカラムがあるため、<code class="literal">ORDER BY</code> はそれを使用し、インデックスを使用できます。(当然ながら、結果のソート順序は、<code class="literal">ABS(a)</code> の順序とはまったく異なる可能性があります。) 
        </p><pre class="programlisting">
SELECT ABS(a) AS b FROM t1 ORDER BY a;
</pre><a class="indexterm" name="idm139979115590816"></a><a class="indexterm" name="idm139979115588784"></a><p>
          デフォルトで、MySQL はすべての <code class="literal">GROUP BY <em class="replaceable"><code>col1</code></em>, <em class="replaceable"><code>col2</code></em>, ...</code> クエリーを、<code class="literal">ORDER BY <em class="replaceable"><code>col1</code></em>, <em class="replaceable"><code>col2</code></em>, ...</code> とクエリーに指定したかのように、ソートします。同じカラムリストを含む明示的な <code class="literal">ORDER BY</code> 句が含まれている場合、ソート処理は引き続き行われますが、速度の低下なく、MySQL が最適化によってそれを除去します。クエリーに <code class="literal">GROUP BY</code> が含まれているが、結果のソートのオーバーヘッドを避けたい場合は、<code class="literal">ORDER BY NULL</code> を指定することでソートを抑止できます。例:
        </p><pre class="programlisting">
INSERT INTO foo
SELECT a, COUNT(*) FROM bar GROUP BY a ORDER BY NULL;
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            MySQL 5.6 における暗黙の <code class="literal">GROUP BY</code> ソートへの依存は、非推奨になっています。グループ化された結果の特定のソート順序を実現するには、明示的な <code class="literal">ORDER BY</code> 句を使用することをお勧めします。<code class="literal">GROUP BY</code> ソートは、たとえば、オプティマイザがもっとも効率的であると考えるどのような方法でも、グループ化を指示できるようにしたり、ソートオーバーヘッドを回避したりするためなどに、今後のリリースで変更される可能性のある MySQL 拡張機能です。
          </p></div><p>
          <code class="literal">EXPLAIN SELECT ... ORDER BY</code> を使用すると、MySQL がインデックスを使用してクエリーを解決できるかどうかを確認できます。<code class="literal">Extra</code> カラムに <code class="literal">Using filesort</code> と表示された場合、それはできません。「<a class="xref" href="optimization.html#using-explain" title="8.8.1 EXPLAIN によるクエリーの最適化">セクション8.8.1「EXPLAIN によるクエリーの最適化」</a>」を参照してください。filesort は、<code class="literal">MEMORY</code> ストレージエンジンによって使用されるものと似た固定長の行ストレージフォーマットを使用します。<code class="literal">VARCHAR</code> などの可変長型は、固定長を使用して格納されます。
        </p><a class="indexterm" name="idm139979115568768"></a><a class="indexterm" name="idm139979115567264"></a><p>
          MySQL には、結果をソートして取得するために 2 つの <code class="literal">filesort</code> アルゴリズムがあります。元のメソッドは <code class="literal">ORDER BY</code> カラムだけを使用します。変更されたメソッドは <code class="literal">ORDER BY</code> カラムだけでなく、クエリーによって参照されるすべてのカラムを使用します。
        </p><p>
          どちらの <code class="literal">filesort</code> アルゴリズムを使用するかはオプティマイザが選択します。通常は変更されたアルゴリズムが使用されますが、<code class="literal">BLOB</code> カラムや <code class="literal">TEXT</code> カラムが含まれる場合を除きます。その場合には元のアルゴリズムが使用されます。どちらのアルゴリズムでも、ソートバッファーサイズは <code class="literal">sort_buffer_size</code> システム変数値です。
        </p><p>
          元の <code class="literal">filesort</code> アルゴリズムは次のように動作します。
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              キーに従って、またはテーブルスキャンによって、すべての行を読み取ります。<code class="literal">WHERE</code> 句に一致しない行をスキップします。
            </p></li><li class="listitem"><p>
              行ごとに、ソートバッファーに値のペア (ソートキー値と行 ID) を格納します。
            </p></li><li class="listitem"><p>
              すべてのペアがソートバッファーに収まる場合は、一時ファイルが作成されません。そうでない場合は、ソートバッファーがいっぱいになると、メモリー内でそれに対して qsort (quicksort) が実行され、それが一時ファイルに書き込まれます。ソートされたブロックへのポインタを保存します。
            </p></li><li class="listitem"><p>
              すべての行が読み取られるまで、前の手順を繰り返します。
            </p></li><li class="listitem"><p>
              別の一時ファイルで、最大 <code class="literal">MERGEBUFF</code> (7) 領域の 1 つのブロックへのマルチマージを実行します。最初のファイルのすべてのブロックが 2 番目のファイルに格納されるまで、この処理を繰り返します。
            </p></li><li class="listitem"><p>
              残りが <code class="literal">MERGEBUFF2</code> (15) ブロックより少なくなるまで、次を繰り返します。
            </p></li><li class="listitem"><p>
              最後のマルチマージで、行 ID (値のペアの最後の部分) のみが結果ファイルに書き込まれます。
            </p></li><li class="listitem"><p>
              結果ファイルで、行 ID を使用して、ソートされた順序で行を読み取ります。これを最適化するには、行 ID の大きなブロックを読み取り、それらをソートして、それらを使用して、ソートされた順序で行を行バッファーに読み込みます。行バッファーサイズは <code class="literal">read_rnd_buffer_size</code> システム変数値です。この手順のコードは <code class="filename">sql/records.cc</code> ソースファイルにあります。
            </p></li></ol></div><p>
          このアプローチの問題の 1 つは、<code class="literal">WHERE</code> 句の評価時に 1 回と値のペアのソート後にもう 1 回と、2 回行を読み取ることです。さらに、1 回目は行が連続してアクセスされても (テーブルスキャンを実行する場合など)、2 回目はそれらがランダムにアクセスされます。(ソートキーは順序付けされますが、行の位置は順序付けされません。)
        </p><p>
          変更された <code class="literal">filesort</code> アルゴリズムには、行を 2 回読み取ることを回避する最適化が組み込まれています。それは、ソートキー値を記録しますが、行 ID の代わりに、クエリーで参照されているカラムを記録します。変更された <code class="literal">filesort</code> アルゴリズムは次のように動作します。
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              <code class="literal">WHERE</code> 句に一致する行を読み取ります。
            </p></li><li class="listitem"><p>
              行ごとに、ソートキー値とクエリーで参照されるカラムから構成される値のタプルを記録します。
            </p></li><li class="listitem"><p>
              ソートバッファーがいっぱいになると、メモリー内でソートキー値によってタプルをソートし、それを一時ファイルに書き込みます。
            </p></li><li class="listitem"><p>
              一時ファイルのマージソート後、ソートされた順序で行を取得しますが、2 回目はテーブルにアクセスするのではなく、ソートされたタプルから直接必要なカラムを読み取ります。
            </p></li></ol></div><p>
          変更された <code class="literal">filesort</code> アルゴリズムを使用すると、タプルが元のメソッドで使用されるペアより長くなり、ソートバッファーに収まるそれらの数が少なくなります。その結果、追加の I/O によって、変更されたアプローチの方が速くなるのではなく、遅くなる可能性があります。速度の低下を防ぐため、オプティマイザはソートタプル内の追加のカラムの合計サイズが <code class="literal">max_length_for_sort_data</code> システム変数の値を超えない場合にのみ、変更されたアルゴリズムを使用します。(この変数の値を著しく高く設定すると、高いディスクアクティビティーと低い CPU アクティビティーの組み合わせが見られます。)
        </p><p>
          <code class="literal">filesort</code> が実行されると、<code class="literal">EXPLAIN</code> 出力で、<code class="literal">Extra</code> カラムに <code class="literal">Using filesort</code> が含まれます。さらに、オプティマイザトレース出力には <code class="literal">filesort_summary</code> ブロックが含まれます。例:
        </p><pre class="programlisting">
"filesort_summary": {
  "rows": 100,
  "examined_rows": 100,
  "number_of_tmp_files": 0,
  "sort_buffer_size": 25192,
  "sort_mode": "&lt;sort_key, additional_fields&gt;"
}
</pre><p>
          <code class="literal">sort_mode</code> 値は、使用されたアルゴリズムとソートバッファー内のタプルの内容に関する情報を提供します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">&lt;sort_key, rowid&gt;</code>: ソートバッファータプルには、ソートキー値と元のテーブル行の行 ID が含まれます。タプルはソートキー値でソートされ、行 ID は、テーブルからの行の読み取りに使用されます。
            </p></li><li class="listitem"><p>
              <code class="literal">&lt;sort_key, additional_fields&gt;</code>: ソートバッファータプルには、ソートキー値とクエリーで参照されているカラムが含まれます。タプルはソートキー値でソートされ、カラム値は、タプルから直接読み取られます。
            </p></li></ul></div><p>
          オプティマイザのトレースについては、「<a class="ulink" href="http://dev.mysql.com/doc/internals/en/optimizer-tracing.html" target="_top">MySQL Internals: Tracing the Optimizer</a>」を参照してください。
        </p><p>
          テーブル <code class="literal">t1</code> に、4 つの <code class="literal">VARCHAR</code> カラム <code class="literal">a</code>、<code class="literal">b</code>、<code class="literal">c</code>、および <code class="literal">d</code> があり、オプティマイザはこのクエリーに <code class="literal">filesort</code> を使用するとします。
        </p><pre class="programlisting">
SELECT * FROM t1 ORDER BY a, b;
</pre><p>
          クエリーは <code class="literal">a</code> と <code class="literal">b</code> でソートしますが、すべてのカラムを返すため、クエリーによって参照されているカラムは <code class="literal">a</code>、<code class="literal">b</code>、<code class="literal">c</code>、および <code class="literal">d</code> です。オプティマイザがどの <code class="literal">filesort</code> アルゴリズムを選択するかによって、クエリーは次のように実行されます。
        </p><p>
          元のアルゴリズムの場合、ソートバッファータプルの内容は次のようになります。
        </p><pre class="programlisting">
(fixed size a value, fixed size b value,
row ID into t1)
</pre><p>
          オプティマイザは固定サイズ値でソートします。ソート後、オプティマイザは、順番にタプルを読み取り、各タプル内の行 ID を使用して、<code class="literal">t1</code> から行を読み取り、選択リストカラム値を取得します。
        </p><p>
          変更されたアルゴリズムの場合、ソートバッファータプルの内容は次のようになります。
        </p><pre class="programlisting">
(fixed size a value, fixed size b value,
a value, b value, c value, d value)
</pre><p>
          オプティマイザは固定サイズ値でソートします。ソート後、オプティマイザは、順番にタプルを読み取り、<code class="literal">a</code>、<code class="literal">b</code>、<code class="literal">c</code>、および <code class="literal">d</code> の値を使用して、<code class="literal">t1</code> を再度読み取ることなく、選択リストカラム値を取得します。
        </p><p>
          <code class="literal">filesort</code> が使用されない遅いクエリーでは、<code class="literal">max_length_for_sort_data</code> を <code class="literal">filesort</code> がトリガーされる適切な値まで小さくしてみてください。
        </p><p>
          <code class="literal">ORDER BY</code> 速度を向上するには、MySQL で、追加のソートフェーズではなく、インデックスを使用させることができるかどうかをチェックします。これが不可能な場合は、次の戦略を試すことができます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">sort_buffer_size</code> 変数値を増やします。
            </p></li><li class="listitem"><p>
              <code class="literal">read_rnd_buffer_size</code> 変数値を増やします。
            </p></li><li class="listitem"><p>
              カラムに格納された値を保持するために必要なだけの大きさでカラムを宣言することにより、行あたりに使用する RAM を減らします。たとえば、値が 16 文字を超えることがない場合は、<code class="literal">CHAR(16)</code> の方が <code class="literal">CHAR(200)</code> よりも適切です。
            </p></li><li class="listitem"><p>
              <code class="literal">tmpdir</code> システム変数を変更して、大量の空き領域のある専用ファイルシステムを指すようにします。変数値には、ラウンドロビン方式で使用される複数のパスをリストできます。この機能を使用して、複数のディレクトリに負荷を分散できます。パスは UNIX ではコロン文字 (<span class="quote">「<span class="quote"><code class="literal">:</code></span>」</span>)、Windows ではセミコロン文字 (<span class="quote">「<span class="quote"><code class="literal">;</code></span>」</span>) で区切るようにしてください。パスには、同じディスク上の異なるパーティションではなく、異なる<span class="emphasis"><em>物理</em></span>ディスクにあるファイルシステム内のディレクトリを指定してください。
            </p></li></ul></div><p>
          <code class="literal">ORDER BY</code> にインデックスが使用されないが、<code class="literal">LIMIT</code> 句も存在する場合、オプティマイザはマージファイルの使用を避け、メモリー内で行をソートできます。詳細は、<a class="xref" href="optimization.html#limit-optimization" title="8.2.1.19 LIMIT クエリーの最適化">セクション8.2.1.19「LIMIT クエリーの最適化」</a>を参照してください。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="group-by-optimization"></a>8.2.1.16 GROUP BY の最適化</h4></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#loose-index-scan">8.2.1.16.1 ルースインデックススキャン</a></span></dt><dt><span class="section"><a href="optimization.html#tight-index-scan">8.2.1.16.2 タイトインデックススキャン</a></span></dt></dl></div><a class="indexterm" name="idm139979115473568"></a><a class="indexterm" name="idm139979115472256"></a><p>
          <code class="literal">GROUP BY</code> 句を満たすもっとも一般的な方法は、テーブル全体をスキャンし、各グループのすべての行が連続する新しい一時テーブルを作成することであり、それにより、この一時テーブルを使用してグループを見つけて、集約関数 (ある場合) を適用できます。場合によって、MySQL はインデックスアクセスを使用することで、それよりはるかに適切に実行し、一時テーブルの作成を回避できます。
        </p><p>
          <code class="literal">GROUP BY</code> にインデックスを使用するためのもっとも重要な前提条件は、すべての <code class="literal">GROUP BY</code> カラムが同じインデックスから属性を参照することと、インデックスがそのキーを正しい順序で格納する (たとえば、これは <code class="literal">BTREE</code> インデックスで、<code class="literal">HASH</code> インデックスではありません) ことです。一時テーブルの使用をインデックスアクセスに置き換えられるかどうかは、クエリー内でインデックスのどの部分が使用されているか、その部分に指定された条件、および選択された集約関数にもよります。
        </p><p>
          次のセクションで詳しく説明するように、インデックスアクセスによって <code class="literal">GROUP BY</code> クエリーを実行する方法は 2 つあります。最初の方法では、グループ化操作はすべての範囲述語 (ある場合) とともに適用されます。2 つめの方法では、まず範囲スキャンを実行し、次に結果タプルをグループ化します。
        </p><p>
          MySQL では、<code class="literal">GROUP BY</code> はソートに使用されるため、サーバーはグループ化に <code class="literal">ORDER BY</code> 最適化を適用することもあります。<a class="xref" href="optimization.html#order-by-optimization" title="8.2.1.15 ORDER BY の最適化">セクション8.2.1.15「ORDER BY の最適化」</a>を参照してください。
        </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="loose-index-scan"></a>8.2.1.16.1 ルースインデックススキャン</h5></div></div></div><p>
            <code class="literal">GROUP BY</code> を処理するもっとも効率的な方法は、インデックスを使用してグループ化するカラムを直接取得することです。このアクセスメソッドでは、MySQL はキーが順序付けられている、インデックス型のプロパティーを使用します。(たとえば、<code class="literal">BTREE</code>)。このプロパティーにより、インデックス内のすべての <code class="literal">WHERE</code> 条件を満たすキーを考慮する必要なく、インデックス内のルックアップグループを使用できます。このアクセスメソッドはインデックス内のキーの一部だけを考慮するため、<em class="firstterm">ルースインデックススキャン</em>と呼ばれています。<code class="literal">WHERE</code> 句がない場合、ルースインデックススキャンでは、グループの数だけキーを読み取りますが、これはすべてのキーの数よりもはるかに少ないことがあります。<code class="literal">WHERE</code> 句に範囲述語が含まれる場合 (<a class="xref" href="optimization.html#using-explain" title="8.8.1 EXPLAIN によるクエリーの最適化">セクション8.8.1「EXPLAIN によるクエリーの最適化」</a>の <code class="literal">range</code> 結合型の説明を参照してください)、ルースインデックススキャンでは範囲条件を満たす各グループの最初のキーをルックアップし、再度最小限の数のキーを読み取ります。これは次の条件の下で可能です。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                クエリーが単一テーブルに対するものです。
              </p></li><li class="listitem"><p>
                <code class="literal">GROUP BY</code> はインデックスの左端のプリフィクスを形成するカラムのみを指定し、ほかのカラムは指定しません。(<code class="literal">GROUP BY</code> の代わりに、クエリーに <code class="literal">DISTINCT</code> 句がある場合、個々のすべての属性がインデックスの左端のプリフィクスを形成するカラムを参照します。)たとえば、テーブル <code class="literal">t1</code> の <code class="literal">(c1,c2,c3)</code> にインデックスがある場合、クエリーに <code class="literal">GROUP BY c1, c2,</code> がある場合に、ルースインデックススキャンを適用できます。クエリーに <code class="literal">GROUP BY c2, c3</code> (カラムは左端のプリフィクスでない) または <code class="literal">GROUP BY c1, c2, c4</code> (<code class="literal">c4</code> はインデックス内にない) がある場合は適用できません。
              </p></li><li class="listitem"><p>
                選択リスト (ある場合) で使用されている集約関数が、<code class="literal">MIN()</code> と <code class="literal">MAX()</code> だけであり、それらはすべて同じカラムを参照します。カラムはインデックス内にある必要があり、<code class="literal">GROUP BY</code> にあるカラムを追跡する必要があります。
              </p></li><li class="listitem"><p>
                クエリーで参照された <code class="literal">GROUP BY</code> からの部分以外のインデックスの部分は、定数である必要があります (つまり、定数と同等のもので参照されている必要があります) が、<code class="literal">MIN()</code> または <code class="literal">MAX()</code> 関数の引数を除きます。
              </p></li><li class="listitem"><p>
                インデックス内のカラムの場合、プリフィクスだけでなく、完全なカラム値にインデックスが設定されている必要があります。たとえば、<code class="literal">c1 VARCHAR(20), INDEX (c1(10))</code> では、インデックスはルースインデックススキャンに使用できません。
              </p></li></ul></div><p>
            ルースインデックススキャンをクエリーに適用できる場合、<code class="literal">EXPLAIN</code> 出力で、<code class="literal">Extra</code> カラムに <code class="literal">Using index for group-by</code> と示されます。
          </p><p>
            テーブル <code class="literal">t1(c1,c2,c3,c4)</code> にインデックス <code class="literal">idx(c1,c2,c3)</code> があると仮定します。ルースインデックススキャンアクセスメソッドは、次のクエリーに使用できます。
          </p><pre class="programlisting">
SELECT c1, c2 FROM t1 GROUP BY c1, c2;
SELECT DISTINCT c1, c2 FROM t1;
SELECT c1, MIN(c2) FROM t1 GROUP BY c1;
SELECT c1, c2 FROM t1 WHERE c1 &lt; <em class="replaceable"><code>const</code></em> GROUP BY c1, c2;
SELECT MAX(c3), MIN(c3), c1, c2 FROM t1 WHERE c2 &gt; <em class="replaceable"><code>const</code></em> GROUP BY c1, c2;
SELECT c2 FROM t1 WHERE c1 &lt; <em class="replaceable"><code>const</code></em> GROUP BY c1, c2;
SELECT c1, c2 FROM t1 WHERE c3 = <em class="replaceable"><code>const</code></em> GROUP BY c1, c2;
</pre><p>
            次に示す理由により、以下のクエリーはこのクイック選択メソッドで実行できません。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <code class="literal">MIN()</code> または <code class="literal">MAX()</code> 以外の集約関数があります。
              </p><pre class="programlisting">
SELECT c1, SUM(c2) FROM t1 GROUP BY c1;
</pre></li><li class="listitem"><p>
                <code class="literal">GROUP BY</code> 句内のカラムがインデックスの左端のプリフィクスを形成していません。
              </p><pre class="programlisting">
SELECT c1, c2 FROM t1 GROUP BY c2, c3;
</pre></li><li class="listitem"><p>
                クエリーは <code class="literal">GROUP BY</code> 部分のあとに続くキーの部分を参照し、そこに定数と同等のものがありません。
              </p><pre class="programlisting">
SELECT c1, c3 FROM t1 GROUP BY c1, c2;
</pre><p>
                クエリーに <code class="literal">WHERE c3 = <em class="replaceable"><code>const</code></em></code> が含まれる場合、ルースインデックススキャンを使用できます。
              </p></li></ul></div><p>
            ルースインデックススキャンアクセスメソッドは、選択リスト内で、すでにサポートされている <code class="literal">MIN()</code> および <code class="literal">MAX()</code> 参照に加えて、ほかの形式の集約関数参照にも適用できます。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <code class="literal">AVG(DISTINCT)</code>、<code class="literal">SUM(DISTINCT)</code>、および <code class="literal">COUNT(DISTINCT)</code> がサポートされています。<code class="literal">AVG(DISTINCT)</code> と <code class="literal">SUM(DISTINCT)</code> は 1 つの引数をとります。<code class="literal">COUNT(DISTINCT)</code> には複数のカラム引数を指定できます。
              </p></li><li class="listitem"><p>
                クエリーに <code class="literal">GROUP BY</code> または <code class="literal">DISTINCT</code> 句があってはいけません。
              </p></li><li class="listitem"><p>
                ここでも先述したルーススキャンの制限が適用されます。
              </p></li></ul></div><p>
            テーブル <code class="literal">t1(c1,c2,c3,c4)</code> にインデックス <code class="literal">idx(c1,c2,c3)</code> があると仮定します。ルースインデックススキャンアクセスメソッドは、次のクエリーに使用できます。
          </p><pre class="programlisting">
SELECT COUNT(DISTINCT c1), SUM(DISTINCT c1) FROM t1;

SELECT COUNT(DISTINCT c1, c2), COUNT(DISTINCT c2, c1) FROM t1;
</pre><p>
            ルースインデックススキャンは次のクエリーに適用できません。
          </p><pre class="programlisting">
SELECT DISTINCT COUNT(DISTINCT c1) FROM t1;

SELECT COUNT(DISTINCT c1) FROM t1 GROUP BY c1;
</pre></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="tight-index-scan"></a>8.2.1.16.2 タイトインデックススキャン</h5></div></div></div><p>
            タイトインデックススキャンは、クエリー条件によって、フルインデックススキャンまたは範囲インデックススキャンのいずれかになります。
          </p><p>
            ルースインデックススキャンの条件が満たされていなくても、<code class="literal">GROUP BY</code> クエリーの一時テーブルの作成を回避できる場合があります。<code class="literal">WHERE</code> 句に範囲条件がある場合、このメソッドはこれらの条件を満たすキーだけを読み取ります。そうでない場合は、インデックススキャンを実行します。このメソッドは <code class="literal">WHERE</code> 句によって定義された各範囲内のすべてのキーを読み取るか、または範囲条件がなければインデックス全体をスキャンするため、<em class="firstterm">タイトインデックススキャン</em>と呼んでいます。タイトインデックススキャンでは、範囲条件を満たすすべてのキーが見つかったあとにのみ、グループ化操作が実行されます。
          </p><p>
            このメソッドが機能するためには、クエリー内のすべてのカラムに、<code class="literal">GROUP BY</code> キーの前にくるか、または間の部分にあるキーの部分を参照する定数同等条件があれば十分です。同等条件からの定数は、インデックスの完全なプリフィクスを形成できるように、検索キーの<span class="quote">「<span class="quote">ギャップ</span>」</span>を埋めます。これらのインデックスのプリフィクスは、インデックスルックアップに使用できます。<code class="literal">GROUP BY</code> 結果のソートが必要で、インデックスのプリフィクスである検索キーを形成できる場合、順序付けされたインデックス内のプリフィクスによる検索で、すでにすべてのキーが順番に取得されているため、MySQL は余分なソート操作も避けられます。
          </p><p>
            テーブル <code class="literal">t1(c1,c2,c3,c4)</code> にインデックス <code class="literal">idx(c1,c2,c3)</code> があると仮定します。次のクエリーは、前述のルースインデックススキャンアクセスメソッドでは機能しませんが、タイトインデックススキャンアクセスメソッドでは機能します。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <code class="literal">GROUP BY</code> にはギャップがありますが、条件 <code class="literal">c2 = 'a'</code> によってカバーされます。
              </p><pre class="programlisting">
SELECT c1, c2, c3 FROM t1 WHERE c2 = 'a' GROUP BY c1, c3;
</pre></li><li class="listitem"><p>
                <code class="literal">GROUP BY</code> は、キーの最初の部分から開始されませんが、その部分に対して定数を与える条件があります。
              </p><pre class="programlisting">
SELECT c1, c2, c3 FROM t1 WHERE c1 = 'a' GROUP BY c2, c3;
</pre></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="distinct-optimization"></a>8.2.1.17 DISTINCT の最適化</h4></div></div></div><a class="indexterm" name="idm139979115372432"></a><a class="indexterm" name="idm139979115371120"></a><p>
          <code class="literal">ORDER BY</code> と組み合わされた <code class="literal">DISTINCT</code> では多くの場合に一時テーブルが必要です。
        </p><p>
          <code class="literal">DISTINCT</code> では <code class="literal">GROUP BY</code> を使用できるため、MySQL が <code class="literal">ORDER BY</code> または <code class="literal">HAVING</code> 句内の選択したカラムの部分でないカラムをどのように処理するかを学んでください。<a class="xref" href="functions.html#group-by-handling" title="12.19.3 MySQL での GROUP BY の処理">セクション12.19.3「MySQL での GROUP BY の処理」</a>を参照してください。
        </p><p>
          ほとんどの場合、<code class="literal">DISTINCT</code> 句は <code class="literal">GROUP BY</code> の特殊な例と考えることができます。たとえば、次の 2 つのクエリーは同等です。
        </p><pre class="programlisting">
SELECT DISTINCT c1, c2, c3 FROM t1
WHERE c1 &gt; <em class="replaceable"><code>const</code></em>;

SELECT c1, c2, c3 FROM t1
WHERE c1 &gt; <em class="replaceable"><code>const</code></em> GROUP BY c1, c2, c3;
</pre><p>
          この同等性のため、<code class="literal">GROUP BY</code> クエリーに適用できる最適化は <code class="literal">DISTINCT</code> 句のあるクエリーにも適用できます。そのため、<code class="literal">DISTINCT</code> クエリー最適化の可能性の詳細については、<a class="xref" href="optimization.html#group-by-optimization" title="8.2.1.16 GROUP BY の最適化">セクション8.2.1.16「GROUP BY の最適化」</a>を参照してください。
        </p><p>
          <code class="literal">LIMIT <em class="replaceable"><code>row_count</code></em></code> を <code class="literal">DISTINCT</code> と組み合わせた場合、MySQL は <em class="replaceable"><code>row_count</code></em> 固有の行が見つかるとただちに停止します。
        </p><p>
          クエリーに指定されたすべてのテーブルのカラムを使用しない場合、MySQL は最初の一致が見つかるとただちに未使用テーブルのスキャンを停止します。次の例では、<code class="literal">t1</code> が <code class="literal">t2</code> の前に使用され (これは、<code class="literal">EXPLAIN</code> で確認できます)、MySQL は <code class="literal">t2</code> (<code class="literal">t1</code> 内の特定の行の) で、最初の行を見つけると、<code class="literal">t2</code> からの読み取りを停止します。
        </p><pre class="programlisting">
SELECT DISTINCT t1.a FROM t1, t2 where t1.a=t2.a;
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="subquery-optimization"></a>8.2.1.18 サブクエリーの最適化</h4></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#semi-joins">8.2.1.18.1 準結合変換によるサブクエリーの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#subquery-materialization">8.2.1.18.2 サブクエリー実体化によるサブクエリーの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#from-clause-subquery-optimization">8.2.1.18.3 FROM 句内のサブクエリー (派生テーブル) の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#subquery-optimization-with-exists">8.2.1.18.4 EXISTS 戦略によるサブクエリーの最適化</a></span></dt></dl></div><a class="indexterm" name="idm139979115344912"></a><a class="indexterm" name="idm139979115343456"></a><p>
          MySQL クエリーオプティマイザには、サブクエリーの評価に使用できるさまざまな戦略があります。<code class="literal">IN</code> (または <code class="literal">=ANY</code>) サブクエリーの場合、オプティマイザには次の選択肢があります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              準結合
            </p></li><li class="listitem"><p>
              実体化
            </p></li><li class="listitem"><p>
              <code class="literal">EXISTS</code> 戦略
            </p></li></ul></div><p>
          <code class="literal">NOT IN</code> (または <code class="literal">&lt;&gt;ALL</code>) サブクエリーの場合、オプティマイザには次の選択肢があります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              実体化
            </p></li><li class="listitem"><p>
              <code class="literal">EXISTS</code> 戦略
            </p></li></ul></div><p>
          次のセクションでは、これらの最適化戦略について詳しく説明します。
        </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="semi-joins"></a>8.2.1.18.1 準結合変換によるサブクエリーの最適化</h5></div></div></div><a class="indexterm" name="idm139979115328944"></a><p>
            MySQL 5.6.5 現在、オプティマイザは、このセクションで説明するように、準結合戦略を使用して、サブクエリーの実行を改善します。
          </p><p>
            2 つのテーブル間の内部結合の場合、結合は、他方のテーブルに一致がある回数だけ、一方のテーブルから 1 行を返します。ただし、問題によっては、重要な情報は一致の数ではなく、一致があるかどうかだけの場合があります。コースカリキュラムのクラスとクラス名簿 (各クラスに登録されている生徒) をそれぞれ一覧表示する <code class="literal">class</code> と <code class="literal">roster</code> というテーブルがあるとします。実際に生徒が登録されているクラスを一覧表示するには、次の結合を使用できます。
          </p><pre class="programlisting">
SELECT class.class_num, class.class_name
FROM class INNER JOIN roster
WHERE class.class_num = roster.class_num;
</pre><p>
            ただし、結果には、登録された生徒ごとに、各クラスが 1 回ずつ一覧表示されます。ここでの問題では、これは不要な情報の重複です。
          </p><p>
            <code class="literal">class_num</code> が <code class="literal">class</code> テーブル内の主キーとすると、重複の抑制は、<code class="literal">SELECT DISTINCT</code> を使用して実現できますが、あとで重複を除去するためにだけ、まずすべての一致する行を生成することは非効率的です。
          </p><p>
            同じ重複のない結果は、次のサブクエリーを使用して取得できます。
          </p><pre class="programlisting">
SELECT class_num, class_name
FROM class
WHERE class_num IN (SELECT class_num FROM roster);
</pre><p>
            ここで、オプティマイザは <code class="literal">IN</code> 句に <code class="literal">roster</code> テーブルから各クラス番号のインスタンスを 1 つだけ返すサブクエリーが必要であることを認識できます。この場合、クエリーは<em class="firstterm">準結合</em>として実行できます。つまり、<code class="literal">roster</code> 内の行に一致する <code class="literal">class</code> 内の各行のインスタンスを 1 つだけ返す操作です。
          </p><p>
            MySQL 5.6.6 より前では、外部クエリーの指定は、単純なテーブルスキャンやカンマ構文を使用した内部結合に制限されており、ビュー参照は不可能でした。5.6.6 現在、外部クエリー指定で外部結合および内部結合構文を使用でき、テーブル参照がベーステーブルでなければいけないという制限はなくなりました。
          </p><p>
            MySQL では、サブクエリーは準結合として扱われるために、次の条件を満たしている必要があります。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                それは、おそらく <code class="literal">AND</code> 式内の項として、<code class="literal">WHERE</code> 句または <code class="literal">ON</code> 句のトップレベルに表示される <code class="literal">IN</code> (または <code class="literal">=ANY</code>) サブクエリーである必要があります。例:
              </p><pre class="programlisting">
SELECT ...
FROM ot1, ...
WHERE (oe1, ...) IN (SELECT ie1, ... FROM it1, ... WHERE ...);
</pre><p>
                ここで、<code class="literal">ot_<em class="replaceable"><code>i</code></em></code> と <code class="literal">it_<em class="replaceable"><code>i</code></em></code> は、クエリーの外側部分と内側部分のテーブルを表し、<code class="literal">oe_<em class="replaceable"><code>i</code></em></code> と <code class="literal">ie_<em class="replaceable"><code>i</code></em></code> は、外部テーブルと内部テーブル内のカラムを参照する式を表します。
              </p></li><li class="listitem"><p>
                それは <code class="literal">UNION</code> コンストラクトのない単一の <code class="literal">SELECT</code> である必要があります。
              </p></li><li class="listitem"><p>
                それには <code class="literal">GROUP BY</code> または <code class="literal">HAVING</code> 句または集約関数が含まれていてはなりません。
              </p></li><li class="listitem"><p>
                それには、<code class="literal">LIMIT</code> を使用した <code class="literal">ORDER BY</code> があってはなりません。
              </p></li><li class="listitem"><p>
                外部テーブルとおよび内部テーブルの合計数が結合で許可されている最大テーブル数より少なくなければなりません。
              </p></li></ul></div><p>
            サブクエリーは相関する場合と相関しない場合があります。<code class="literal">LIMIT</code> と同様に、<code class="literal">ORDER BY</code> も使用しなければ、<code class="literal">DISTINCT</code> を使用できます。
          </p><p>
            サブクエリーが先述の条件を満たしている場合、MySQL はそれを準結合に変換し、次の戦略からコストに基づいた選択を行います。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                サブクエリーを結合に変換するか、テーブルプルアウトを使用して、クエリーをサブクエリーテーブルと外部テーブル間の内部結合として実行します。テーブルプルアウトは、テーブルをサブクエリーから外部クエリーに引き出します。
              </p></li><li class="listitem"><p>
                重複の除去: 準結合を結合のように実行し、一時テーブルを使用して、重複レコードを削除します。
              </p></li><li class="listitem"><p>
                FirstMatch: 行の組み合わせの内部テーブルをスキャンし、指定した値グループの複数のインスタンスがある場合、それらすべてを返すのではなく、1 つを選択します。これはスキャンを「ショートカット」し、不要な行の生成をなくします。
              </p></li><li class="listitem"><p>
                LooseScan: 各サブクエリーの値グループから単一の値を選択できるようにするインデックスを使用して、サブクエリーテーブルをスキャンします。
              </p></li><li class="listitem"><p>
                サブクエリーをインデックス付きの一時テーブルに実体化し、その一時テーブルを使用して、結合を実行します。インデックスは重複の削除に使用されます。さらに、インデックスはあとで一時テーブルと外部テーブルを結合する際のルックアップにも使用されることがあります。そうでない場合はテーブルがスキャンされます。
              </p></li></ul></div><p>
            重複の除去を除いて、これらの各戦略を有効または無効にするには、<code class="literal">optimizer_switch</code> システム変数を使用します。<code class="literal">semijoin</code> フラグは準結合を使用するかどうかを制御します。これが <code class="literal">on</code> に設定されている場合、<code class="literal">firstmatch</code>、<code class="literal">loosescan</code>、および <code class="literal">materialization</code> フラグによって、使用可能な準結合戦略を詳細に制御できます。これらのフラグはデフォルトで <code class="literal">on</code> です。<a class="xref" href="optimization.html#switchable-optimizations" title="8.8.5.2 切り替え可能な最適化の制御">セクション8.8.5.2「切り替え可能な最適化の制御」</a>を参照してください。
          </p><p>
            準結合戦略の使用は、<code class="literal">EXPLAIN</code> 出力で次のように示されます。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                準結合されたテーブルは、外側の選択に表示されます。<code class="literal">EXPLAIN EXTENDED</code> と <code class="literal">SHOW WARNINGS</code> には書き換えられたクエリーが示され、準結合構造が表示されます。ここから、準結合から引き出されたテーブルについての情報を得ることができます。サブクエリーが準結合に変換された場合、サブクエリー述語がなくなっており、そのテーブルと <code class="literal">WHERE</code> 句が外部クエリー結合リストと <code class="literal">WHERE</code> 句にマージされたことがわかります。
              </p></li><li class="listitem"><p>
                重複の除去のための一時テーブルの使用は、<code class="literal">Extra</code> カラムの <code class="literal">Start temporary</code> と <code class="literal">End temporary</code> によって示されます。引き出されておらず、<code class="literal">Start temporary</code> と <code class="literal">End temporary</code> によってカバーされる <code class="literal">EXPLAIN</code> 出力行の範囲内にあるテーブルは、一時テーブルにそれらの <code class="literal">rowid</code> が格納されます。
              </p></li><li class="listitem"><p>
                <code class="literal">Extra</code> カラムの <code class="literal">FirstMatch(<em class="replaceable"><code>tbl_name</code></em>)</code> は結合のショートカットを示します。
              </p></li><li class="listitem"><p>
                <code class="literal">Extra</code> カラムの <code class="literal">LooseScan(<em class="replaceable"><code>m</code></em>..<em class="replaceable"><code>n</code></em>)</code> は LooseScan 戦略の使用を示します。<em class="replaceable"><code>m</code></em> と <em class="replaceable"><code>n</code></em> はキーパート番号です。
              </p></li><li class="listitem"><p>
                MySQL 5.6.7 現在、実体化のための一時テーブルの使用は、<code class="literal">MATERIALIZED</code> の <code class="literal">select_type</code> 値のある行と、<code class="literal">&lt;subquery<em class="replaceable"><code>N</code></em>&gt;</code> の <code class="literal">table</code> 値のある行によって示されます。
              </p><p>
                MySQL 5.6.7 より前では、実体化のための一時テーブルの使用は、<code class="literal">Extra</code> カラムに、単一のテーブルが使用された場合 <code class="literal">Materialize</code> によって示され、複数のテーブルが使用された場合 <code class="literal">Start materialize</code> と <code class="literal">End materialize</code> によって示されます。<code class="literal">Scan</code> が存在する場合、テーブルの読み取りに一時テーブルインデックスは使用されません。そうでない場合は、インデックスルックアップが使用されます。
              </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="subquery-materialization"></a>8.2.1.18.2 サブクエリー実体化によるサブクエリーの最適化</h5></div></div></div><a class="indexterm" name="idm139979115242928"></a><a class="indexterm" name="idm139979115241488"></a><a class="indexterm" name="idm139979115240112"></a><p>
            MySQL 5.6.5 現在、オプティマイザは、サブクエリー処理の効率向上を可能にする戦略として、サブクエリー実体化を使用します。
          </p><p>
            実体化を使用しない場合、オプティマイザは、非相関サブクエリーを相関サブクエリーとして書き換えることがあります。たとえば、次の <code class="literal">IN</code> サブクエリーは非相関です (<em class="replaceable"><code>where_condition</code></em> には <code class="literal">t2</code> からのカラムのみが含まれ、<code class="literal">t1</code> からは含まれません)。
          </p><pre class="programlisting">
SELECT * FROM t1
WHERE t1.a IN (SELECT t2.b FROM t2 WHERE <em class="replaceable"><code>where_condition</code></em>);
</pre><p>
            オプティマイザはこれを <code class="literal">EXISTS</code> 相関サブクエリーとして書き換えることがあります。
          </p><pre class="programlisting">
SELECT * FROM t1
WHERE EXISTS (SELECT t2.b FROM t2 WHERE <em class="replaceable"><code>where_condition</code></em> AND t1.a=t2.b);
</pre><p>
            一時テーブルを使用したサブクエリー実体化により、そのような書き換えを回避し、外部クエリーの行ごとに 1 回ではなく、1 回だけサブクエリーを実行させることができます。実体化は、通常メモリー内に一時テーブルとしてサブクエリー結果を生成することによって、クエリー実行を高速化します。MySQL ははじめてサブクエリー結果を必要としたときに、その結果を一時テーブルに実体化します。あとで結果が必要になったときに、MySQL は再度一時テーブルを参照します。テーブルはルックアップを高速にし、負荷を軽減するため、ハッシュインデックスによってインデックス設定されます。このインデックスは一意で、重複がないため、テーブルを小さくします。
          </p><p>
            サブクエリー実体化では、可能なかぎりインメモリー一時テーブルを使用しようとし、テーブルが大きくなりすぎた場合、ディスク上のストレージに戻ります。<a class="xref" href="optimization.html#internal-temporary-tables" title="8.4.4 MySQL が内部一時テーブルを使用する仕組み">セクション8.4.4「MySQL が内部一時テーブルを使用する仕組み」</a>を参照してください。
          </p><p>
            MySQL で使用されるサブクエリー実体化では、<code class="literal">optimizer_switch</code> システム変数の <code class="literal">materialization</code> フラグが <code class="literal">on</code> である必要があります。その後実体化は、任意の場所 (選択リスト、<code class="literal">WHERE</code>、<code class="literal">ON</code>、<code class="literal">GROUP BY</code>、<code class="literal">HAVING</code>、または <code class="literal">ORDER BY</code> 内) に存在する、次のいずれかのユースケースに分類される述語のサブクエリー述語に適用されます。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                外側の式 <em class="replaceable"><code>oe_i</code></em> または内側の式 <em class="replaceable"><code>ie_i</code></em> が NULL 可能でない場合に、述語はこの形式になります。<em class="replaceable"><code>N</code></em> には 1 以上を指定できます。
              </p><pre class="programlisting">
(<em class="replaceable"><code>oe_1</code></em>, <em class="replaceable"><code>oe_2</code></em>, ..., <em class="replaceable"><code>oe_N</code></em>) [NOT] IN (SELECT <em class="replaceable"><code>ie_1</code></em>, <em class="replaceable"><code>i_2</code></em>, ..., <em class="replaceable"><code>ie_N</code></em> ...)
</pre></li><li class="listitem"><p>
                単一の外側の式 <em class="replaceable"><code>oe</code></em> と内側の式 <em class="replaceable"><code>ie</code></em> がある場合に、述語はこの形式になります。式は NULL 可能にできます。
              </p><pre class="programlisting">
<em class="replaceable"><code>oe</code></em> [NOT] IN (SELECT <em class="replaceable"><code>ie</code></em> ...)
</pre></li><li class="listitem"><p>
                述語は <code class="literal">IN</code> または <code class="literal">NOT IN</code> で <code class="literal">UNKNOWN</code> (<code class="literal">NULL</code>) の結果は <code class="literal">FALSE</code> の結果と同じ意味になります。
              </p></li></ul></div><p>
            次の例に、<code class="literal">UNKNOWN</code> および <code class="literal">FALSE</code> 述語評価の同等性の要件が、サブクエリー実体化を使用できるかどうかにどのように影響するかを示します。サブクエリーが非相関になるように、<em class="replaceable"><code>where_condition</code></em> に <code class="literal">t2</code> からのカラムのみが含まれ、<code class="literal">t1</code> からは含まれないとします。
          </p><p>
            このクエリーは実体化の対象になります。
          </p><pre class="programlisting">
SELECT * FROM t1
WHERE t1.a IN (SELECT t2.b FROM t2 WHERE <em class="replaceable"><code>where_condition</code></em>);
</pre><p>
            ここでは、<code class="literal">IN</code> 述語が <code class="literal">UNKNOWN</code> を返すか、<code class="literal">FALSE</code> を返すかは問題ではありません。どちらも <code class="literal">t1</code> からの行はクエリー結果に含まれません。
          </p><p>
            サブクエリー実体化が使用されない例は、<code class="literal">t2.b</code> が NULL 可能カラムである次のクエリーです。
          </p><pre class="programlisting">
SELECT * FROM t1
WHERE (t1.a,t1.b) NOT IN (SELECT t2.a,t2.b FROM t2
                          WHERE <em class="replaceable"><code>where_condition</code></em>);
</pre><p>
            クエリーで <code class="literal">EXPLAIN</code> を使用すると、オプティマイザがサブクエリー実体化を使用しているかどうかの何らかの指示が得られます。実体化を使用しないクエリー実行と比較して、<code class="literal">select_type</code> が <code class="literal">DEPENDENT SUBQUERY</code> から <code class="literal">SUBQUERY</code> に変更されることがあります。これは、外部行ごとに 1 回実行されるサブクエリーの場合、実体化によってサブクエリーが 1 回だけ実行されるようにできることを示します。さらに、<code class="literal">EXPLAIN EXTENDED</code> の場合、次の <code class="literal">SHOW WARNINGS</code> によって表示されるテキストには <code class="literal">materialize</code> <code class="literal">materialize</code> および <code class="literal">materialized-subquery</code> (MySQL 5.6.6 より前では <code class="literal">materialized subselect</code>) が含まれます。
          </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="from-clause-subquery-optimization"></a>8.2.1.18.3 FROM 句内のサブクエリー (派生テーブル) の最適化</h5></div></div></div><a class="indexterm" name="idm139979115182144"></a><p>
            MySQL 5.6.3 現在、オプティマイザは <code class="literal">FROM</code> 句内のサブクエリー (つまり派生テーブル) をより効率的に処理します。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <code class="literal">FROM</code> 句内のサブクエリーの実体化は、クエリー実行中にその内容が必要になるまで延期されるので、パフォーマンスが向上します。
              </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                    これまで、<code class="literal">FROM</code> 句内のサブクエリーは <code class="literal">EXPLAIN SELECT</code> ステートメントに対して実体化されていました。これにより、<code class="literal">EXPLAIN</code> の目的がクエリーを実行することではなく、クエリー計画情報を取得することであっても、<code class="literal">SELECT</code> が部分的に実行されました。この実体化は行われなくなったため、<code class="literal">EXPLAIN</code> はそのようなクエリーに対して高速化しています。
                  </p></li><li class="listitem"><p>
                    <code class="literal">EXPLAIN</code> 以外のクエリーでは、実体化の遅延によって、それをまったく実行する必要がなくなることがあります。<code class="literal">FROM</code> 句内のサブクエリーの結果を別のテーブルに結合するクエリーを考慮します。オプティマイザはその他方のテーブルを最初に処理し、それが行を返さないことがわかると、それ以上結合を実行する必要はないため、オプティマイザはサブクエリーの実体化を完全にスキップできます。
                  </p></li></ul></div></li><li class="listitem"><p>
                クエリー実行中に、オプティマイザは派生テーブルにインデックスを追加して、そこからの行の取得を高速化できます。
              </p></li></ul></div><p>
            <code class="literal">SELECT</code> クエリーの <code class="literal">FROM</code> 句にサブクエリーが表示される、次の <code class="literal">EXPLAIN</code> ステートメントを考慮します。
          </p><pre class="programlisting">
EXPLAIN SELECT * FROM (SELECT * FROM t1);
</pre><p>
            オプティマイザは、<code class="literal">SELECT</code> 実行中に結果が必要になるまで、サブクエリーの実体化を遅延させて、それを回避します。この例では、クエリーが実行されないため、結果が必要になることはありません。
          </p><p>
            実行されるクエリーの場合でも、サブクエリー実体化の遅延によって、オプティマイザは実体化を完全に避けられることがあります。<code class="literal">FROM</code> 句内のサブクエリーの結果を別のテーブルに結合する次のクエリーを考慮します。
          </p><pre class="programlisting">
SELECT * FROM t1
  JOIN (SELECT t2.f1 FROM t2) AS derived_t2 ON t1.f2=derived_t2.f1
  WHERE t1.f1 &gt; 0;
</pre><p>
            最適化によって <code class="literal">t1</code> が最初に処理され、<code class="literal">WHERE</code> 句で空の結果が生成された場合、結合は空である必要があり、サブクエリーは実体化される必要はありません。
          </p><p>
            最悪の場合 (派生テーブルが実体化される)、追加の作業が実行されないため、クエリーの実行に MySQL 5.6.3 より前と同じ時間がかかります。最善の場合 (派生テーブルが実体化されない)、実体化の実行に必要な時間の分だけ、クエリーの実行が速くなります。
          </p><p>
            <code class="literal">FROM</code> 句内のサブクエリーに実体化が必要な場合、オプティマイザは、実体化されたテーブルにインデックスを追加して、結果へのアクセスを高速化できます。そのようなインデックスによって、テーブルに <code class="literal">ref</code> アクセスできる場合、クエリー実行中に読み取る必要があるデータの量を大幅に削減できます。次のクエリーを考慮してください。
          </p><pre class="programlisting">
SELECT * FROM t1
  JOIN (SELECT * FROM t2) AS derived_t2 ON t1.f1=derived_t2.f1;
</pre><p>
            オプティマイザは、<code class="literal">derived_t2</code> のカラム <code class="literal">f1</code> に対してインデックスを構築することで、最低コストの実行プランでの <code class="literal">ref</code> アクセスの使用が可能になる場合に、そのようにします。インデックスの追加後、オプティマイザは、実体化された派生テーブルをインデックス付きの通常のテーブルと同じように扱うことができ、生成されたインデックスから同様の利点が得られます。インデックス作成のオーバーヘッドは、インデックスを使用しないクエリー実行のコストと比較して無視できます。<code class="literal">ref</code> アクセスが、ほかのアクセスメソッドよりコストが高くなる場合は、インデックスが作成されず、オプティマイザは何も失いません。
          </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="subquery-optimization-with-exists"></a>8.2.1.18.4 EXISTS 戦略によるサブクエリーの最適化</h5></div></div></div><a class="indexterm" name="idm139979115143008"></a><a class="indexterm" name="idm139979115140864"></a><p>
            <code class="literal">IN</code> 演算子を使用して (または、同等の <code class="literal">=ANY</code> を使用して) サブクエリーの結果をテストする比較に、特定の最適化を適用できます。このセクションでは、これらの最適化について、特に <code class="literal">NULL</code> 値が存在する課題に関して説明します。説明の最後の部分では、オプティマイザを支援するためにユーザーが実行できることに関する提案も紹介します。
          </p><p>
            次のようなサブクエリーの比較を考慮します。
          </p><pre class="programlisting">
<em class="replaceable"><code>outer_expr</code></em> IN (SELECT <em class="replaceable"><code>inner_expr</code></em> FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>)
</pre><p>
            MySQL は<span class="quote">「<span class="quote">外側から内側に</span>」</span>クエリーを評価します。つまり、まず外側の式 <em class="replaceable"><code>outer_expr</code></em> の値を取得してから、サブクエリーを実行し、それによって生成される行を取得します。
          </p><p>
            内側の式 <em class="replaceable"><code>inner_expr</code></em> が <em class="replaceable"><code>outer_expr</code></em> と等しい行だけが目的の行であることをサブクエリーに<span class="quote">「<span class="quote">通知する</span>」</span>ことは、かなり役に立つ最適化です。これを実行するには、適切な等式をサブクエリーの <code class="literal">WHERE</code> 句にプッシュダウンします。つまり、この比較は次のように変換されます。
          </p><pre class="programlisting">
EXISTS (SELECT 1 FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em> AND <em class="replaceable"><code>outer_expr</code></em>=<em class="replaceable"><code>inner_expr</code></em>)
</pre><p>
            変換後、MySQL はプッシュダウンされた等式を使用して、サブクエリーの評価時に検査する必要のある行数を制限できます。
          </p><p>
            より一般的には、<em class="replaceable"><code>N</code></em> 個の値と <em class="replaceable"><code>N</code></em> 値の行を返すサブクエリーとの比較は、同じ変換の対象になります。<em class="replaceable"><code>oe_i</code></em> と <em class="replaceable"><code>ie_i</code></em> が対応する外側と内側の式の値を表す場合、次のサブクエリー比較は:
          </p><pre class="programlisting">
(<em class="replaceable"><code>oe_1</code></em>, ..., <em class="replaceable"><code>oe_N</code></em>) IN
  (SELECT <em class="replaceable"><code>ie_1</code></em>, ..., <em class="replaceable"><code>ie_N</code></em> FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>)
</pre><p>
            次のようになります。
          </p><pre class="programlisting">
EXISTS (SELECT 1 FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>
                          AND <em class="replaceable"><code>oe_1</code></em> = <em class="replaceable"><code>ie_1</code></em>
                          AND ...
                          AND <em class="replaceable"><code>oe_N</code></em> = <em class="replaceable"><code>ie_N</code></em>)
</pre><p>
            以下の説明では、簡単にするために、1 組の外側と内側の式の値があると仮定します。
          </p><p>
            先述の変換には制限があります。これは、可能性のある <code class="literal">NULL</code> 値を無視する場合にかぎり有効です。つまり、<span class="quote">「<span class="quote">プッシュダウン</span>」</span>戦略は、次の 2 つの条件が両方とも true であるかぎり機能します。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <em class="replaceable"><code>outer_expr</code></em> と <em class="replaceable"><code>inner_expr</code></em> は <code class="literal">NULL</code> にできません。
              </p></li><li class="listitem"><p>
                <code class="literal">FALSE</code> サブクエリー結果と <code class="literal">NULL</code> を区別する必要はありません。(サブクエリーが <code class="literal">WHERE</code> 句内の <code class="literal">OR</code> または <code class="literal">AND</code> 式の一部である場合に、MySQL はユーザーが気にしないものと想定します。)
              </p></li></ul></div><p>
            これらの条件の一方または両方が成立しない場合、最適化は複雑になります。
          </p><p>
            <em class="replaceable"><code>outer_expr</code></em> は <code class="literal">NULL</code> 以外の値であることがわかっているが、サブクエリーは <em class="replaceable"><code>outer_expr</code></em> = <em class="replaceable"><code>inner_expr</code></em> となるような行を生成しないものとします。その場合、<code class="literal"><em class="replaceable"><code>outer_expr</code></em> IN (SELECT ...)</code> は次のように評価されます。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <em class="replaceable"><code>inner_expr</code></em> が <code class="literal">NULL</code> である行を <code class="literal">SELECT</code> が生成する場合は <code class="literal">NULL</code>
              </p></li><li class="listitem"><p>
                <code class="literal">SELECT</code> が <code class="literal">NULL</code> 以外の値のみを生成するかまたは何も生成しない場合は <code class="literal">FALSE</code>
              </p></li></ul></div><p>
            この状況では、<code class="literal"><em class="replaceable"><code>outer_expr</code></em> = <em class="replaceable"><code>inner_expr</code></em></code> である行を探すアプローチは有効でなくなります。そのような行を探すことは必要ですが、何も見つからない場合には、<em class="replaceable"><code>inner_expr</code></em> が <code class="literal">NULL</code> となる行も探します。大ざっぱに言うと、サブクエリーは次のように変換できます。
          </p><pre class="programlisting">
EXISTS (SELECT 1 FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em> AND
        (<em class="replaceable"><code>outer_expr</code></em>=<em class="replaceable"><code>inner_expr</code></em> OR <em class="replaceable"><code>inner_expr</code></em> IS NULL))
</pre><p>
            追加の <code class="literal">IS NULL</code> 条件を評価する必要性は、MySQL に <code class="literal">ref_or_null</code> アクセスメソッドがある理由です。
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>EXPLAIN</code></strong>
    -&gt; <strong class="userinput"><code>SELECT <em class="replaceable"><code>outer_expr</code></em> IN (SELECT t2.maybe_null_key</code></strong>
    -&gt;                       <strong class="userinput"><code>FROM t2, t3 WHERE ...)</code></strong>
    -&gt; FROM t1;
*************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: t1
...
*************************** 2. row ***************************
           id: 2
  select_type: DEPENDENT SUBQUERY
        table: t2
         type: ref_or_null
possible_keys: maybe_null_key
          key: maybe_null_key
      key_len: 5
          ref: func
         rows: 2
        Extra: Using where; Using index
...
</pre><p>
            <code class="literal">unique_subquery</code> および <code class="literal">index_subquery</code> サブクエリー固有のアクセスメソッドには <span class="quote">「<span class="quote">or <code class="literal">NULL</code></span>」</span> バリアントもあります。ただし、それらは <code class="literal">EXPLAIN</code> の出力に表示されないため、<code class="literal">EXPLAIN EXTENDED</code> のあとに <code class="literal">SHOW WARNINGS</code> を付けて使用する必要があります (警告メッセージの <code class="literal">checking NULL</code> に注意してください)。
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>EXPLAIN EXTENDED</code></strong>
    -&gt; <strong class="userinput"><code>SELECT <em class="replaceable"><code>outer_expr</code></em> IN (SELECT maybe_null_key FROM t2) FROM t1\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: t1
...
*************************** 2. row ***************************
           id: 2
  select_type: DEPENDENT SUBQUERY
        table: t2
         type: index_subquery
possible_keys: maybe_null_key
          key: maybe_null_key
      key_len: 5
          ref: func
         rows: 2
        Extra: Using index

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS\G</code></strong>
*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: select (`test`.`t1`.`outer_expr`,
         (((`test`.`t1`.`outer_expr`) in t2 on
         maybe_null_key checking NULL))) AS `outer_expr IN (SELECT
         maybe_null_key FROM t2)` from `test`.`t1`
</pre><p>
            追加の <code class="literal">OR ... IS NULL</code> 条件によってクエリーの実行は多少複雑になり、サブクエリー内の最適化の一部も適用できなくなりますが、通常これは許容できます。
          </p><p>
            <em class="replaceable"><code>outer_expr</code></em> が <code class="literal">NULL</code> になる可能性がある場合、状況ははるかに悪くなります。<span class="quote">「<span class="quote">不明な値</span>」</span>としての <code class="literal">NULL</code> の SQL の解釈によると、<code class="literal">NULL IN (SELECT <em class="replaceable"><code>inner_expr</code></em> ...)</code> は次のように評価されるはずです。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <code class="literal">SELECT</code> が何らかの行を生成する場合は <code class="literal">NULL</code>
              </p></li><li class="listitem"><p>
                <code class="literal">SELECT</code> が行を生成しない場合は <code class="literal">FALSE</code>
              </p></li></ul></div><p>
            正しい評価には、<code class="literal">SELECT</code> がとにかく何らかの行を生成したかどうかを確認できるようにする必要があるため、<code class="literal"><em class="replaceable"><code>outer_expr</code></em> = <em class="replaceable"><code>inner_expr</code></em></code> をサブクエリーにプッシュダウンすることはできません。等式をプッシュダウンできないと、多くの実際のサブクエリーが非常に遅くなるため、これは問題になります。
          </p><p>
            基本的に、<em class="replaceable"><code>outer_expr</code></em> の値に応じて、サブクエリーを実行するさまざまな方法が存在する必要があります。
          </p><p>
            オプティマイザは速度よりも SQL 準拠を選択するため、<em class="replaceable"><code>outer_expr</code></em> が <code class="literal">NULL</code> になる可能性を考慮します。
          </p><p>
            <em class="replaceable"><code>outer_expr</code></em> が <code class="literal">NULL</code> の場合、次の式を評価するには、<code class="literal">SELECT</code> を実行して何らかの行が生成されるかどうかを判断する必要があります。
          </p><pre class="programlisting">
NULL IN (SELECT <em class="replaceable"><code>inner_expr</code></em> FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>)
</pre><p>
            ここで、先述の種類のプッシュダウンされた等式を使用せずに、元の <code class="literal">SELECT</code> を実行する必要があります。
          </p><p>
            一方、<em class="replaceable"><code>outer_expr</code></em> が <code class="literal">NULL</code> でない場合、次の比較が絶対に必要です:
          </p><pre class="programlisting">
<em class="replaceable"><code>outer_expr</code></em> IN (SELECT <em class="replaceable"><code>inner_expr</code></em> FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>)
</pre><p>
            この比較をプッシュダウンされた条件を使用する式に変換
          </p><pre class="programlisting">
EXISTS (SELECT 1 FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em> AND <em class="replaceable"><code>outer_expr</code></em>=<em class="replaceable"><code>inner_expr</code></em>)
</pre><p>
            この変換を行わないと、サブクエリーが遅くなります。条件をサブクエリーにプッシュダウンするかどうかのジレンマを解決するには、条件を<span class="quote">「<span class="quote">トリガー</span>」</span>関数にラップします。したがって、次の形式の式は:
          </p><pre class="programlisting">
<em class="replaceable"><code>outer_expr</code></em> IN (SELECT <em class="replaceable"><code>inner_expr</code></em> FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>)
</pre><p>
            次のように変換されます。
          </p><pre class="programlisting">
EXISTS (SELECT 1 FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>
                          AND trigcond(<em class="replaceable"><code>outer_expr</code></em>=<em class="replaceable"><code>inner_expr</code></em>))
</pre><p>
            より一般的には、サブクエリーの比較が外側の式と内側の式の複数のペアに基づく場合、変換は次の比較をします。
          </p><pre class="programlisting">
(<em class="replaceable"><code>oe_1</code></em>, ..., <em class="replaceable"><code>oe_N</code></em>) IN (SELECT <em class="replaceable"><code>ie_1</code></em>, ..., <em class="replaceable"><code>ie_N</code></em> FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>)
</pre><p>
            さらに、それを次の式に変換します。
          </p><pre class="programlisting">
EXISTS (SELECT 1 FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>
                          AND trigcond(<em class="replaceable"><code>oe_1</code></em>=<em class="replaceable"><code>ie_1</code></em>)
                          AND ...
                          AND trigcond(<em class="replaceable"><code>oe_N</code></em>=<em class="replaceable"><code>ie_N</code></em>)
       )
</pre><p>
            各 <code class="literal">trigcond(<em class="replaceable"><code>X</code></em>)</code> は、次の値に評価される特殊な関数です。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <span class="quote">「<span class="quote">リンクされた</span>」</span>外側の式 <em class="replaceable"><code>oe_i</code></em> が <code class="literal">NULL</code> でない場合は <em class="replaceable"><code>X</code></em>
              </p></li><li class="listitem"><p>
                <span class="quote">「<span class="quote">リンクされた</span>」</span>外側の式 <em class="replaceable"><code>oe_i</code></em> が <code class="literal">NULL</code> の場合は <code class="literal">TRUE</code>
              </p></li></ul></div><p>
            トリガー関数は、<code class="literal">CREATE TRIGGER</code> で作成する種類のトリガーでは<span class="emphasis"><em>ありません</em></span>。
          </p><p>
            <code class="literal">trigcond()</code> 関数にラップされた等式は、クエリーオプティマイザにとって最高の述語ではありません。ほとんどの最適化では、クエリーの実行時にオンまたはオフになる可能性のある述語を処理できないため、<code class="literal">trigcond(<em class="replaceable"><code>X</code></em>)</code> をすべて不明な関数であるとみなし、無視します。現時点では、トリガー等式は次の最適化で使用できます。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                参照の最適化: <code class="literal">trigcond(<em class="replaceable"><code>X</code></em>=<em class="replaceable"><code>Y</code></em> [OR <em class="replaceable"><code>Y</code></em> IS NULL])</code> を使用して、<code class="literal">ref</code>、<code class="literal">eq_ref</code>、または <code class="literal">ref_or_null</code> テーブルアクセスを構築できます。
              </p></li><li class="listitem"><p>
                インデックスルックアップベースのサブクエリー実行エンジン: <code class="literal">trigcond(<em class="replaceable"><code>X</code></em>=<em class="replaceable"><code>Y</code></em>)</code> を使用して、<code class="literal">unique_subquery</code> または <code class="literal">index_subquery</code> アクセスを構築できます。
              </p></li><li class="listitem"><p>
                テーブル条件ジェネレータ: サブクエリーが複数のテーブルの結合である場合、トリガー条件は可能なかぎり早く確認されます。
              </p></li></ul></div><p>
            オプティマイザがトリガー条件を使用して、何らかの種類のインデックスルックアップベースのアクセスを作成する場合 (上記リストの最初の 2 項目に関して)、条件がオフである場合のフォールバック戦略が必要です。このフォールバック戦略は常に同じで、フルテーブルスキャンを実行します。<code class="literal">EXPLAIN</code> の出力で、フォールバックは <code class="literal">Extra</code> カラムに <code class="literal">Full scan on NULL key</code> と表示されます。
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT t1.col1,</code></strong>
    -&gt; <strong class="userinput"><code>t1.col1 IN (SELECT t2.key1 FROM t2 WHERE t2.col2=t1.col2) FROM t1\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: t1
        ...
*************************** 2. row ***************************
           id: 2
  select_type: DEPENDENT SUBQUERY
        table: t2
         type: index_subquery
possible_keys: key1
          key: key1
      key_len: 5
          ref: func
         rows: 2
        Extra: Using where; Full scan on NULL key
</pre><p>
            <code class="literal">EXPLAIN EXTENDED</code> に続いて <code class="literal">SHOW WARNINGS</code> を実行すると、トリガー条件を確認できます。
          </p><pre class="programlisting">
*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: select `test`.`t1`.`col1` AS `col1`,
         &lt;in_optimizer&gt;(`test`.`t1`.`col1`,
         &lt;exists&gt;(&lt;index_lookup&gt;(&lt;cache&gt;(`test`.`t1`.`col1`) in t2
         on key1 checking NULL
         where (`test`.`t2`.`col2` = `test`.`t1`.`col2`) having
         trigcond(&lt;is_not_null_test&gt;(`test`.`t2`.`key1`))))) AS
         `t1.col1 IN (select t2.key1 from t2 where t2.col2=t1.col2)`
         from `test`.`t1`
</pre><p>
            トリガー条件を使用すると、パフォーマンスに多少の影響があります。現在 <code class="literal">NULL IN (SELECT ...)</code> 式では、以前に実行されなかった (遅い) フルテーブルスキャンが行われる可能性があります。これは正しい結果を得るための代価です (トリガー条件戦略の目的は、速度ではなく適合性を向上させることでした)。
          </p><p>
            複数テーブルサブクエリーでは、外側の式が <code class="literal">NULL</code> である場合に、結合オプティマイザが最適化を行わないため、<code class="literal">NULL IN (SELECT ...)</code> の実行が特に遅くなります。それは、左辺が <code class="literal">NULL</code> の場合のサブクエリーの評価はめったにないものと想定しています (そうでないことを示す統計があっても)。一方、外側の式が <code class="literal">NULL</code> になる可能性があっても実際にそうなることがない場合、パフォーマンスの低下はありません。
          </p><p>
            クエリーオプティマイザでクエリーがより適切に実行されるようにするには、次のヒントを使用してください。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                カラムが実際に <code class="literal">NOT NULL</code> である場合は、そのように宣言します。(これにより、カラムの条件テストを簡単にすることで、オプティマイザのほかの側面にも役立ちます。)
              </p></li><li class="listitem"><p>
                <code class="literal">NULL</code> と <code class="literal">FALSE</code> サブクエリー結果を区別する必要がない場合、遅い実行パスを簡単に回避できます。次のような比較を置き換えます。
              </p><pre class="programlisting">
<em class="replaceable"><code>outer_expr</code></em> IN (SELECT <em class="replaceable"><code>inner_expr</code></em> FROM ...)
</pre><p>
                次の式で:
              </p><pre class="programlisting">
(<em class="replaceable"><code>outer_expr</code></em> IS NOT NULL) AND (<em class="replaceable"><code>outer_expr</code></em> IN (SELECT <em class="replaceable"><code>inner_expr</code></em> FROM ...))
</pre><p>
                これにより、MySQL は式の結果が明確になるとただちに <code class="literal">AND</code> 部分の評価を停止するため、<code class="literal">NULL IN (SELECT ...)</code> が評価されることはなくなります。
              </p></li></ul></div><p>
            <code class="literal">subquery_materialization_cost_based</code> により、サブクエリー実体化と <code class="literal">IN -&gt; EXISTS</code> サブクエリー変換の選択を制御できます。<a class="xref" href="optimization.html#switchable-optimizations" title="8.8.5.2 切り替え可能な最適化の制御">セクション8.8.5.2「切り替え可能な最適化の制御」</a>を参照してください。
          </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="limit-optimization"></a>8.2.1.19 LIMIT クエリーの最適化</h4></div></div></div><a class="indexterm" name="idm139979114968880"></a><a class="indexterm" name="idm139979114967568"></a><p>
          結果セットから指定した数の行のみが必要な場合、結果セット全体をフェッチして、余分なデータを破棄するのではなく、クエリーで <code class="literal">LIMIT</code> 句を使用します。
        </p><p>
          MySQL は <code class="literal">LIMIT <em class="replaceable"><code>row_count</code></em></code> 句があり <code class="literal">HAVING</code> 句のないクエリーを最適化することがあります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">LIMIT</code> で少数の行のみを選択すると、MySQL では、通常フルテーブルスキャンを実行するより望ましい特定の場合に、インデックスが使用されます。
            </p></li><li class="listitem"><p>
              <code class="literal">ORDER BY</code> とともに <code class="literal">LIMIT <em class="replaceable"><code>row_count</code></em></code> を使用した場合、MySQL では、結果全体をソートするのではなく、ソートされた結果の最初の <em class="replaceable"><code>row_count</code></em> 行が見つかるとすぐにソートを終了します。インデックスを使用して順序付けが行われている場合、これはきわめて高速になります。filesort を実行する必要がある場合、最初の <em class="replaceable"><code>row_count</code></em> を見つける前に、<code class="literal">LIMIT</code> 句を使用しないクエリーに一致するすべての行が選択され、それらのほとんどまたはすべてがソートされます。初期の行が見つかったら、MySQL は結果セットの残りをすべてソートしません。
            </p><p>
              この動作をはっきり示している現象の 1 つは、このセクションで後述するように、<code class="literal">LIMIT</code> を付けるか付けないかで <code class="literal">ORDER BY</code> クエリーは異なる順序で行を返す場合があることです。
            </p></li><li class="listitem"><p>
              <code class="literal">LIMIT <em class="replaceable"><code>row_count</code></em></code> を <code class="literal">DISTINCT</code> と組み合わせた場合、MySQL は <em class="replaceable"><code>row_count</code></em> 固有の行が見つかるとただちに停止します。
            </p></li><li class="listitem"><p>
              場合によって、<code class="literal">GROUP BY</code> はキーを順番に読み取り (またはキーのソートを実行し)、次にキー値が変わるまでサマリーを計算して解決できます。この場合、<code class="literal">LIMIT <em class="replaceable"><code>row_count</code></em></code> は不要な <code class="literal">GROUP BY</code> 値を計算しません。
            </p></li><li class="listitem"><p>
              MySQL は必要な数の行をクライアントに送信するとただちに、<code class="literal">SQL_CALC_FOUND_ROWS</code> が使用されていないかぎり、クエリーを中止します。
            </p></li><li class="listitem"><p>
              <code class="literal">LIMIT 0</code> は迅速に空のセットを返します。これは、クエリーの妥当性のチェックに役立つことがあります。いずれかの MySQL API を使用している場合、それは結果カラムの型の取得にも使用できます。この技法は <span class="command"><strong>mysql</strong></span> クライアントプログラムでは機能せず、そのような場合には、単に <code class="literal">Empty set</code> を表示します。代わりに、この目的では <code class="literal">SHOW COLUMNS</code> または <code class="literal">DESCRIBE</code> を使用します。
            </p></li><li class="listitem"><p>
              サーバーは、クエリーを解決するために一時テーブルを使用する場合、<code class="literal">LIMIT <em class="replaceable"><code>row_count</code></em></code> 句を使用して、必要な領域の量を計算します。
            </p></li></ul></div><p>
          複数の行の <code class="literal">ORDER BY</code> カラムに同一の値がある場合、サーバーは自由にそれらの行を任意の順序で返しますが、その実行は実行プラン全体によって異なることがあります。言い換えると、それらの行のソート順序は、順序付けされていないカラムに関して決定的ではありません。
        </p><p>
          実行プランに影響する 1 つの要素は <code class="literal">LIMIT</code> であるため、<code class="literal">LIMIT</code> を付けるか付けないかで <code class="literal">ORDER BY</code> クエリーは異なる順序で行を返すことがあります。<code class="literal">category</code> カラムによってソートされるが、<code class="literal">id</code> および <code class="literal">rating</code> カラムに関して非決定的である次のクエリーを考慮します。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT * FROM ratings ORDER BY category;</code></strong>
+----+----------+--------+
| id | category | rating |
+----+----------+--------+
|  1 |        1 |    4.5 |
|  5 |        1 |    3.2 |
|  3 |        2 |    3.7 |
|  4 |        2 |    3.5 |
|  6 |        2 |    3.5 |
|  2 |        3 |    5.0 |
|  7 |        3 |    2.7 |
+----+----------+--------+
</pre><p>
          <code class="literal">LIMIT</code> を含めると、各 <code class="literal">category</code> 値内の行の順序に影響することがあります。たとえば、これは有効なクエリー結果です。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT * FROM ratings ORDER BY category LIMIT 5;</code></strong>
+----+----------+--------+
| id | category | rating |
+----+----------+--------+
|  1 |        1 |    4.5 |
|  5 |        1 |    3.2 |
|  4 |        2 |    3.5 |
|  3 |        2 |    3.7 |
|  6 |        2 |    3.5 |
+----+----------+--------+
</pre><p>
          各ケースで、行は <code class="literal">ORDER BY</code> カラムによってソートされますが、SQL 標準で必要とされるのはこれだけです。
        </p><p>
          <code class="literal">LIMIT</code> を使用してもしなくても同じ行順序を確保することが重要な場合は、<code class="literal">ORDER BY</code> 句に順序を決定的にする追加カラムを含めます。たとえば、<code class="literal">id</code> 値が一意である場合、指定した <code class="literal">category</code> 値の行を <code class="literal">id</code> 順で表示させるようにソートできます。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT * FROM ratings ORDER BY category, id;</code></strong>
+----+----------+--------+
| id | category | rating |
+----+----------+--------+
|  1 |        1 |    4.5 |
|  5 |        1 |    3.2 |
|  3 |        2 |    3.7 |
|  4 |        2 |    3.5 |
|  6 |        2 |    3.5 |
|  2 |        3 |    5.0 |
|  7 |        3 |    2.7 |
+----+----------+--------+

mysql&gt; <strong class="userinput"><code>SELECT * FROM ratings ORDER BY category, id LIMIT 5;</code></strong>
+----+----------+--------+
| id | category | rating |
+----+----------+--------+
|  1 |        1 |    4.5 |
|  5 |        1 |    3.2 |
|  3 |        2 |    3.7 |
|  4 |        2 |    3.5 |
|  6 |        2 |    3.5 |
+----+----------+--------+
</pre><p>
          MySQL 5.6.2 時点で、オプティマイザは次の形式のクエリー (およびサブクエリー) をより効率的に処理します。
        </p><pre class="programlisting">
SELECT ... FROM <em class="replaceable"><code>single_table</code></em> ... ORDER BY <em class="replaceable"><code>non_index_column</code></em> [DESC] LIMIT [<em class="replaceable"><code>M</code></em>,]<em class="replaceable"><code>N</code></em>;
</pre><p>
          この種のクエリーは、大きな結果セットの数行だけを表示する Web アプリケーションで一般的なものです。例:
        </p><pre class="programlisting">
SELECT col1, ... FROM t1 ... ORDER BY name LIMIT 10;
SELECT col1, ... FROM t1 ... ORDER BY RAND() LIMIT 15;
</pre><p>
          ソートバッファーには、<code class="literal">sort_buffer_size</code> のサイズが入ります。<em class="replaceable"><code>N</code></em> 行 (<em class="replaceable"><code>M</code></em> が指定された場合は <em class="replaceable"><code>M</code></em>+<em class="replaceable"><code>N</code></em> 行) のソート要素が、ソートバッファーに収まるほど小さい場合、サーバーはマージファイルの使用を回避し、ソートバッファーを優先度キューとして扱うことでメモリー内で完全にソートを実行できます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              テーブルをスキャンし、キュー内のソート順で選択された各行から選択リストカラムを挿入します。キューがいっぱいになった場合、ソート順で最後の行を押し出します。
            </p></li><li class="listitem"><p>
              キューから最初の <em class="replaceable"><code>N</code></em> 行を返します。(<em class="replaceable"><code>M</code></em> が指定されている場合、最初の <em class="replaceable"><code>M</code></em> 行をスキップし、次の <em class="replaceable"><code>N</code></em> 行を返します。)
            </p></li></ul></div><p>
          以前、サーバーはソートにマージファイルを使用して、この操作を実行していました。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              テーブルをスキャンし、テーブルの最後まで次の手順を繰り返します。
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  ソートバッファーがいっぱいになるまで、行を選択します。
                </p></li><li class="listitem"><p>
                  バッファー内の最初の <em class="replaceable"><code>N</code></em> 行 (<em class="replaceable"><code>M</code></em> が指定された場合は <em class="replaceable"><code>M</code></em>+<em class="replaceable"><code>N</code></em> 行) をマージファイルに書き込みます。
                </p></li></ul></div></li><li class="listitem"><p>
              マージファイルをソートして、最初の <em class="replaceable"><code>N</code></em> 行を返します。(<em class="replaceable"><code>M</code></em> が指定されている場合、最初の <em class="replaceable"><code>M</code></em> 行をスキップし、次の <em class="replaceable"><code>N</code></em> 行を返します。)
            </p></li></ul></div><p>
          テーブルスキャンのコストは、キュー方法でもマージファイル方法でも同じであるため、オプティマイザはその他のコストに基づいて、方法を選択します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              キュー方法では、キューに行を順番に挿入するために多くの CPU を必要とします
            </p></li><li class="listitem"><p>
              マージファイル方法では、ファイルの書き込みと読み取りの I/O コストとそれをソートするための CPU コストがあります
            </p></li></ul></div><p>
          オプティマイザは、<em class="replaceable"><code>N</code></em> の特定の値と行サイズのこれらの要素のバランスを考慮します。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="how-to-avoid-table-scan"></a>8.2.1.20 フルテーブルスキャンを回避する方法</h4></div></div></div><a class="indexterm" name="idm139979114886032"></a><a class="indexterm" name="idm139979114883936"></a><a class="indexterm" name="idm139979114881872"></a><p>
          MySQL が<a class="link" href="glossary.html#glos_full_table_scan" title="テーブルの完全スキャン">フルテーブルスキャン</a>を使用してクエリーを解決する場合、<code class="literal">EXPLAIN</code> からの出力には <code class="literal">type</code> カラムに <code class="literal">ALL</code> と示されます。これは通常は次の条件で発生します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              テーブルがきわめて小さいため、キールックアップで煩わされるよりもテーブルスキャンを実行する方が速くなります。これは、10 行未満の行や短い行長のテーブルによくあります。
            </p></li><li class="listitem"><p>
              インデックスが設定されたカラムに対して、<code class="literal">ON</code> または <code class="literal">WHERE</code> 句に使用可能な制限がありません。
            </p></li><li class="listitem"><p>
              インデックスが設定されたカラムと定数値を比較していて、MySQL が (インデックスツリーに基づいて) その定数がテーブルのきわめて大きい部分をカバーしており、テーブルスキャンが高速に行われると計算しました。<a class="xref" href="optimization.html#where-optimizations" title="8.2.1.2 MySQL の WHERE 句の最適化の方法">セクション8.2.1.2「MySQL の WHERE 句の最適化の方法」</a>を参照してください。
            </p></li><li class="listitem"><p>
              別のカラム経由で、カーディナリティーが低い (多数の行がキー値に一致する) キーを使用しています。この場合、MySQL は、キーを使用して、多数のキールックアップが実行され、テーブルスキャンが高速であると想定します。
            </p></li></ul></div><p>
          小さいテーブルでは、テーブルスキャンは多くの場合に適切であり、実行の影響は無視できます。大きいテーブルでは、オプティマイザがテーブルスキャンを誤って選択しないように、次の技法を試してください。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">ANALYZE TABLE <em class="replaceable"><code>tbl_name</code></em></code> を使用して、スキャンされるテーブルのキー分布を更新します。<a class="xref" href="sql-syntax.html#analyze-table" title="13.7.2.1 ANALYZE TABLE 構文">セクション13.7.2.1「ANALYZE TABLE 構文」</a>を参照してください。
            </p></li><li class="listitem"><p>
              スキャンされるテーブルに <code class="literal">FORCE INDEX</code> を使用して、MySQL に、テーブルスキャンは指定したインデックスを使用するのと比較して著しく負荷が大きいことを伝えます。
            </p><pre class="programlisting">
SELECT * FROM t1, t2 FORCE INDEX (<em class="replaceable"><code>index_for_column</code></em>)
  WHERE t1.<em class="replaceable"><code>col_name</code></em>=t2.<em class="replaceable"><code>col_name</code></em>;
</pre><p>
              <a class="xref" href="sql-syntax.html#index-hints" title="13.2.9.3 インデックスヒントの構文">セクション13.2.9.3「インデックスヒントの構文」</a>を参照してください。
            </p></li><li class="listitem"><p>
              <code class="option">--max-seeks-for-key=1000</code> オプションを使用して <span class="command"><strong>mysqld</strong></span> を開始するか、または <code class="literal">SET max_seeks_for_key=1000</code> を使用して、オプティマイザに、キースキャンでは 1,000 より多くのキーシークは発生しないと想定するように伝えます。<a class="xref" href="server-administration.html#server-system-variables" title="5.1.4 サーバーシステム変数">セクション5.1.4「サーバーシステム変数」</a>を参照してください。
            </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="non-select-optimization"></a>8.2.2 DML ステートメントの最適化</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#insert-speed">8.2.2.1 INSERT ステートメントの速度</a></span></dt><dt><span class="section"><a href="optimization.html#update-speed">8.2.2.2 UPDATE ステートメントの速度</a></span></dt><dt><span class="section"><a href="optimization.html#delete-speed">8.2.2.3 DELETE ステートメントの速度</a></span></dt></dl></div><a class="indexterm" name="idm139979114853856"></a><p>
        このセクションでは、データ操作言語 (DML) ステートメントの <code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、および <code class="literal">DELETE</code> を高速化する方法について説明します。従来の OLTP アプリケーションと最近の Web アプリケーションは一般に多くの小さな DML 操作を実行し、そこでは並列性が不可欠です。データ分析およびレポートアプリケーションは一般に、同時に多くの行に影響する DML 操作を実行しますが、ここでの主な考慮事項は大量のデータを書き込み、インデックスを最新に維持するための I/O です。大量のデータの挿入と更新 (業界では ETL (<span class="quote">「<span class="quote">extract-transform-load</span>」</span>) と呼ばれる) では、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、および <code class="literal">DELETE</code> ステートメントの効果を模倣する、その他の SQL ステートメントや外部コマンドを使用することがあります。
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="insert-speed"></a>8.2.2.1 INSERT ステートメントの速度</h4></div></div></div><a class="indexterm" name="idm139979114842688"></a><a class="indexterm" name="idm139979114841376"></a><a class="indexterm" name="idm139979114839232"></a><a class="indexterm" name="idm139979114837200"></a><p>
          挿入の速度を最適化するには、多くの小さな操作を 1 つの大きな操作に組み合わせます。理想的には、単一の接続を作成し、多くの新しい行のデータを一度に送信し、すべてのインデックスの更新と一貫性チェックを最後まで延期します。
        </p><p>
          行の挿入に必要な時間は、次の要因によって決まります。ここでの数はおよその割合を示しています。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              接続: (3)
            </p></li><li class="listitem"><p>
              サーバーへのクエリーの送信: (2)
            </p></li><li class="listitem"><p>
              クエリーの解析: (2)
            </p></li><li class="listitem"><p>
              行の挿入: (1 ×行サイズ)
            </p></li><li class="listitem"><p>
              インデックスの挿入: (1 ×インデックス数)
            </p></li><li class="listitem"><p>
              クローズ: (1)
            </p></li></ul></div><p>
          これには、テーブルを開く初期オーバーヘッドを考慮に入れていません。これは同時実行クエリーごとに 1 回実行されます。
        </p><p>
          テーブルのサイズによって、log <em class="replaceable"><code>N</code></em> だけインデックスの挿入が遅くなります (B ツリーインデックスであるとして)。
        </p><p>
          次の方法を使用して、挿入を高速化できます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              同じクライアントから同時に多数の行を挿入する場合は、複数の <code class="literal">VALUES</code> リストで <code class="literal">INSERT</code> ステートメントを使用して、同時に複数の行を挿入します。これは、個別の単一行の <code class="literal">INSERT</code> ステートメントを使用するより、大幅に (場合によっては数倍) 速くなります。空ではないテーブルにデータを追加する場合は、データの挿入をさらに速くするために、<code class="literal">bulk_insert_buffer_size</code> 変数を調整できます。<a class="xref" href="server-administration.html#server-system-variables" title="5.1.4 サーバーシステム変数">セクション5.1.4「サーバーシステム変数」</a>を参照してください。
            </p></li><li class="listitem"><p>
              テキストファイルからテーブルをロードする場合は <code class="literal">LOAD DATA INFILE</code> を使用します。通常、これは <code class="literal">INSERT</code> ステートメントを使用する場合より、20 倍速くなります。<a class="xref" href="sql-syntax.html#load-data" title="13.2.6 LOAD DATA INFILE 構文">セクション13.2.6「LOAD DATA INFILE 構文」</a>を参照してください。
            </p></li><li class="listitem"><p>
              カラムにデフォルト値があることを利用します。挿入する値がデフォルト値と異なる場合にのみ、明示的に値を挿入します。これにより、MySQL が実行する必要がある解析が減り、挿入速度が向上します。
            </p></li><li class="listitem"><p>
              <code class="literal">InnoDB</code> テーブルに固有のヒントについては、<a class="xref" href="optimization.html#optimizing-innodb-bulk-data-loading" title="8.5.4 InnoDB テーブルの一括データロード">セクション8.5.4「InnoDB テーブルの一括データロード」</a>を参照してください。
            </p></li><li class="listitem"><p>
              <code class="literal">MyISAM</code> テーブルに固有のヒントについては、<a class="xref" href="optimization.html#optimizing-myisam-bulk-data-loading" title="8.6.2 MyISAM テーブルの一括データロード">セクション8.6.2「MyISAM テーブルの一括データロード」</a>を参照してください。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="update-speed"></a>8.2.2.2 UPDATE ステートメントの速度</h4></div></div></div><a class="indexterm" name="idm139979114806896"></a><p>
          更新ステートメントは、<code class="literal">SELECT</code> クエリーと同様に最適化されますが、書き込みの追加のオーバーヘッドがあります。書き込みの速度は更新されるデータの量と更新されるインデックス数によって異なります。変更がないインデックスは更新されません。
        </p><p>
          更新を速くするもう 1 つの方法は、更新を遅延して、あとで 1 行で多くの更新を実行することです。複数の更新をまとめて実行することで、テーブルをロックした場合に、一度に 1 つずつ実行するよりはるかに高速になります。
        </p><p>
          動的な行フォーマットを使用する <code class="literal">MyISAM</code> テーブルの場合、行を長い合計長に更新すると、行が分割されることがあります。頻繁にこれを実行する場合は、ときどき <code class="literal">OPTIMIZE TABLE</code> を使用することがきわめて重要になります。<a class="xref" href="sql-syntax.html#optimize-table" title="13.7.2.4 OPTIMIZE TABLE 構文">セクション13.7.2.4「OPTIMIZE TABLE 構文」</a>を参照してください。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="delete-speed"></a>8.2.2.3 DELETE ステートメントの速度</h4></div></div></div><a class="indexterm" name="idm139979114797056"></a><p>
          <code class="literal">MyISAM</code> テーブル内の個々の行を削除するために必要な時間は、インデックスの数に正確に比例します。行をもっと速く削除するには、<code class="literal">key_buffer_size</code> システム変数を増やして、キーキャッシュのサイズを大きくできます。<a class="xref" href="optimization.html#server-parameters" title="8.11.2 サーバーパラメータのチューニング">セクション8.11.2「サーバーパラメータのチューニング」</a>を参照してください。
        </p><p>
          <code class="literal">MyISAM</code> テーブルからすべての行を削除するには、<code class="literal">TRUNCATE TABLE <em class="replaceable"><code>tbl_name</code></em></code> の方が <code class="literal">DELETE FROM <em class="replaceable"><code>tbl_name</code></em></code> より速くなります。切り捨て操作はトランザクションセーフではありません。アクティブなトランザクションやアクティブなテーブルロックの途中で試みるとエラーが発生します。<a class="xref" href="sql-syntax.html#truncate-table" title="13.1.33 TRUNCATE TABLE 構文">セクション13.1.33「TRUNCATE TABLE 構文」</a>を参照してください。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="permission-optimization"></a>8.2.3 データベース権限の最適化</h3></div></div></div><a class="indexterm" name="idm139979114785744"></a><a class="indexterm" name="idm139979114783600"></a><p>
        権限のセットアップが複雑であるほど、すべての SQL ステートメントに適用されるオーバーヘッドが大きくなります。<code class="literal">GRANT</code> ステートメントによって確立された権限を簡単にすることで、クライアントがステートメントを実行するときの MySQL の権限チェックのオーバーヘッドを軽減できます。たとえば、テーブルレベルやカラムレベルの権限を付与しない場合、サーバーは <code class="literal">tables_priv</code> と <code class="literal">columns_priv</code> テーブルの内容をチェックする必要はなくなります。同じように、どのアカウントにもリソース制限を設けない場合、サーバーはリソースのカウントを実行する必要がありません。ステートメント処理の負荷が著しく高い場合は、簡略化した付与構造を使用して、権限チェックのオーバーヘッドを軽減することを考慮してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="information-schema-optimization"></a>8.2.4 INFORMATION_SCHEMA クエリーの最適化</h3></div></div></div><p>
        データベースをモニターするアプリケーションでは、<code class="literal">INFORMATION_SCHEMA</code> テーブルを頻繁に使用することがあります。<code class="literal">INFORMATION_SCHEMA</code> テーブルに対する特定の種類のクエリーは、高速に実行するように最適化できます。この目標は、ファイル操作 (ディレクトリのスキャンやテーブルファイルを開くなど) を最小限にし、これらの動的テーブルを構成する情報を収集することです。これらの最適化は、<code class="literal">INFORMATION_SCHEMA</code> テーブルの検索にどのような照合順序が使われるかに影響します。詳細は、<a class="xref" href="globalization.html#charset-collation-information-schema" title="10.1.7.9 照合順序と INFORMATION_SCHEMA 検索">セクション10.1.7.9「照合順序と INFORMATION_SCHEMA 検索」</a>を参照してください。
      </p><p>
        <span class="bold"><strong>1) <code class="literal">WHERE</code> 句のデータベース名とテーブル名には定数のルックアップ値を使用してみます</strong></span>
      </p><p>
        この原則は次のように活用できます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            データベースやテーブルをルックアップするには、リテラル値、定数を返す関数、スカラーサブクエリーなど、定数に評価される式を使用します。
          </p></li><li class="listitem"><p>
            一致するデータベースディレクトリ名を見つけるためにデータディレクトリのスキャンが必要になるため、非定数のデータベース名ルックアップ値を使用する (またはルックアップ値を使用しない) クエリーを避けます。
          </p></li><li class="listitem"><p>
            データベース内では、一致するテーブルファイルを見つけるためにデータベースディレクトリのスキャンが必要になるため、非定数のテーブル名ルックアップ値を使用する (またはルックアップ値を使用しない) クエリーを避けます。
          </p></li></ul></div><p>
        この原則は、定数のルックアップ値によって、サーバーがディレクトリスキャンを回避できるカラムを示している次の表で示されている <code class="literal">INFORMATION_SCHEMA</code> テーブルに適用されます。たとえば、<code class="literal">TABLES</code> から選択する場合は、<code class="literal">WHERE</code> 句で <code class="literal">TABLE_SCHEMA</code> に定数のルックアップ値を使用すると、データディレクトリのスキャンを回避できます。
      </p><div class="informaltable"><table summary="この表には、INFORMATION_SCHEMA テーブルと、定数のルックアップ値によって、サーバーのディレクトリスキャンを回避できるテーブルカラムを示しています。" border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">テーブル</th><th scope="col">データディレクトリスキャンを避けるために指定するカラム</th><th scope="col">データベースディレクトリスキャンを避けるために指定するカラム</th></tr></thead><tbody><tr><td scope="row"><code class="literal">COLUMNS</code></td><td><code class="literal">TABLE_SCHEMA</code></td><td><code class="literal">TABLE_NAME</code></td></tr><tr><td scope="row"><code class="literal">KEY_COLUMN_USAGE</code></td><td><code class="literal">TABLE_SCHEMA</code></td><td><code class="literal">TABLE_NAME</code></td></tr><tr><td scope="row"><code class="literal">PARTITIONS</code></td><td><code class="literal">TABLE_SCHEMA</code></td><td><code class="literal">TABLE_NAME</code></td></tr><tr><td scope="row"><code class="literal">REFERENTIAL_CONSTRAINTS</code></td><td><code class="literal">CONSTRAINT_SCHEMA</code></td><td><code class="literal">TABLE_NAME</code></td></tr><tr><td scope="row"><code class="literal">STATISTICS</code></td><td><code class="literal">TABLE_SCHEMA</code></td><td><code class="literal">TABLE_NAME</code></td></tr><tr><td scope="row"><code class="literal">TABLES</code></td><td><code class="literal">TABLE_SCHEMA</code></td><td><code class="literal">TABLE_NAME</code></td></tr><tr><td scope="row"><code class="literal">TABLE_CONSTRAINTS</code></td><td><code class="literal">TABLE_SCHEMA</code></td><td><code class="literal">TABLE_NAME</code></td></tr><tr><td scope="row"><code class="literal">TRIGGERS</code></td><td><code class="literal">EVENT_OBJECT_SCHEMA</code></td><td><code class="literal">EVENT_OBJECT_TABLE</code></td></tr><tr><td scope="row"><code class="literal">VIEWS</code></td><td><code class="literal">TABLE_SCHEMA</code></td><td><code class="literal">TABLE_NAME</code></td></tr></tbody></table></div><p>
        特定の定数のデータベース名に制限されたクエリーの利点は、指定したデータベースディレクトリのみをチェックするだけで済むことです。例:
      </p><pre class="programlisting">SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA = 'test';
</pre><p>
        リテラルのデータベース名 <code class="literal">test</code> を使用すると、データベースがいくつあるかに関係なく、サーバーは <code class="literal">test</code> データベースディレクトリだけをチェックできます。対照的に、次のクエリーでは、パターン <code class="literal">'test%'</code> に一致するデータベース名を特定するために、データディレクトリのスキャンが必要であるため、効率が低下します。
      </p><pre class="programlisting">SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA LIKE 'test%';
</pre><p>
        特定の定数のテーブル名に制限されたクエリーの場合、対応するデータベースディレクトリ内の指定したテーブルのみをチェックするだけで済みます。例:
      </p><pre class="programlisting">SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA = 'test' AND TABLE_NAME = 't1';
</pre><p>
        リテラルのテーブル名 <code class="literal">t1</code> を使用すると、<code class="literal">test</code> データベースにテーブルがいくつあるかに関係なく、サーバーは <code class="literal">t1</code> テーブルのファイルだけをチェックできます。対照的に、次のクエリーでは、パターン <code class="literal">'t%'</code> に一致するテーブル名を特定するために、<code class="literal">test</code> データベースディレクトリのスキャンが必要です。
      </p><pre class="programlisting">SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA = 'test' AND TABLE_NAME LIKE 't%';
</pre><p>
        次のクエリーでは、パターン <code class="literal">'test%'</code> に一致するデータベース名を特定するためにデータディレクトリをスキャンする必要があり、一致するデータベースごとに、パターン <code class="literal">'t%'</code> に一致するテーブル名を特定するためにデータベースディレクトリをスキャンする必要があります。
      </p><pre class="programlisting">SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA = 'test%' AND TABLE_NAME LIKE 't%';
</pre><p>
        <span class="bold"><strong>2) 開く必要のあるテーブルファイルの数が最小になるクエリーを書きます</strong></span>
      </p><p>
        特定の <code class="literal">INFORMATION_SCHEMA</code> テーブルカラムを参照するクエリーでは、開く必要のあるテーブルファイルの数を最小にするいくつかの最適化を使用できます。例:
      </p><pre class="programlisting">SELECT TABLE_NAME, ENGINE FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA = 'test';
</pre><p>
        この場合、サーバーがデータベースディレクトリをスキャンしてデータベース内のテーブルの名前を特定したら、さらにファイルシステムをルックアップしなくても、それらの名前を使用できるようになります。したがって、<code class="literal">TABLE_NAME</code> はファイルを開く必要はありません。<code class="literal">ENGINE</code> (ストレージエンジン) の値は、テーブルの <code class="filename">.frm</code> ファイルを開くことで特定でき、<code class="filename">.MYD</code> や <code class="filename">.MYI</code> などのほかのテーブルファイルにアクセスすることはありません。
      </p><p>
        <code class="literal">MyISAM</code> テーブルの <code class="literal">INDEX_LENGTH</code> など、一部の値では <code class="filename">.MYD</code> または <code class="filename">.MYI</code> ファイルも開く必要があります。
      </p><p>
        ファイルオープンの最適化の種類は、次のように表されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">SKIP_OPEN_TABLE</code>: テーブルファイルを開く必要はありません。データベースディレクトリをスキャンすることによって、クエリー内ですでに情報を使用できるようになっています。
          </p></li><li class="listitem"><p>
            <code class="literal">OPEN_FRM_ONLY</code>: テーブルの <code class="filename">.frm</code> ファイルのみを開く必要があります。
          </p></li><li class="listitem"><p>
            <code class="literal">OPEN_TRIGGER_ONLY</code>: テーブルの <code class="filename">.TRG</code> ファイルのみを開く必要があります。
          </p></li><li class="listitem"><p>
            <code class="literal">OPEN_FULL_TABLE</code>: 最適化されていない情報のルックアップ。<code class="filename">.frm</code>、<code class="filename">.MYD</code>、および <code class="filename">.MYI</code> ファイルを開く必要があります。
          </p></li></ul></div><p>
        次のリストに、上記の最適化の種類がどのように <code class="literal">INFORMATION_SCHEMA</code> テーブルカラムに適用されるかを示します。指定されていないテーブルとカラムには、最適化が適用されません。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">COLUMNS</code>: <code class="literal">OPEN_FRM_ONLY</code> がすべてのカラムに適用されます
          </p></li><li class="listitem"><p>
            <code class="literal">KEY_COLUMN_USAGE</code>: <code class="literal">OPEN_FULL_TABLE</code> がすべてのカラムに適用されます
          </p></li><li class="listitem"><p>
            <code class="literal">PARTITIONS</code>: <code class="literal">OPEN_FULL_TABLE</code> がすべてのカラムに適用されます
          </p></li><li class="listitem"><p>
            <code class="literal">REFERENTIAL_CONSTRAINTS</code>: <code class="literal">OPEN_FULL_TABLE</code> がすべてのカラムに適用されます
          </p></li><li class="listitem"><p>
            <code class="literal">STATISTICS</code>:
          </p><div class="informaltable"><table summary="この表に、INFORMATION_SCHEMA STATISTICS テーブルカラムに適用される最適化の種類を示します。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">カラム</th><th scope="col">最適化の種類</th></tr></thead><tbody><tr><td scope="row"><code class="literal">TABLE_CATALOG</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td scope="row"><code class="literal">TABLE_SCHEMA</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td scope="row"><code class="literal">TABLE_NAME</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td scope="row"><code class="literal">NON_UNIQUE</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td scope="row"><code class="literal">INDEX_SCHEMA</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td scope="row"><code class="literal">INDEX_NAME</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td scope="row"><code class="literal">SEQ_IN_INDEX</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td scope="row"><code class="literal">COLUMN_NAME</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td scope="row"><code class="literal">COLLATION</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td scope="row"><code class="literal">CARDINALITY</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td scope="row"><code class="literal">SUB_PART</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td scope="row"><code class="literal">PACKED</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td scope="row"><code class="literal">NULLABLE</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td scope="row"><code class="literal">INDEX_TYPE</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td scope="row"><code class="literal">COMMENT</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr></tbody></table></div></li><li class="listitem"><p>
            <code class="literal">TABLES</code>:
          </p><div class="informaltable"><table summary="この表に、INFORMATION_SCHEMA TABLES テーブルカラムに適用される最適化の種類を示します。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">カラム</th><th scope="col">最適化の種類</th></tr></thead><tbody><tr><td scope="row"><code class="literal">TABLE_CATALOG</code></td><td><code class="literal">SKIP_OPEN_TABLE</code></td></tr><tr><td scope="row"><code class="literal">TABLE_SCHEMA</code></td><td><code class="literal">SKIP_OPEN_TABLE</code></td></tr><tr><td scope="row"><code class="literal">TABLE_NAME</code></td><td><code class="literal">SKIP_OPEN_TABLE</code></td></tr><tr><td scope="row"><code class="literal">TABLE_TYPE</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td scope="row"><code class="literal">ENGINE</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td scope="row"><code class="literal">VERSION</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td scope="row"><code class="literal">ROW_FORMAT</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td scope="row"><code class="literal">TABLE_ROWS</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td scope="row"><code class="literal">AVG_ROW_LENGTH</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td scope="row"><code class="literal">DATA_LENGTH</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td scope="row"><code class="literal">MAX_DATA_LENGTH</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td scope="row"><code class="literal">INDEX_LENGTH</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td scope="row"><code class="literal">DATA_FREE</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td scope="row"><code class="literal">AUTO_INCREMENT</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td scope="row"><code class="literal">CREATE_TIME</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td scope="row"><code class="literal">UPDATE_TIME</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td scope="row"><code class="literal">CHECK_TIME</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td scope="row"><code class="literal">TABLE_COLLATION</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td scope="row"><code class="literal">CHECKSUM</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td scope="row"><code class="literal">CREATE_OPTIONS</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td scope="row"><code class="literal">TABLE_COMMENT</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr></tbody></table></div></li><li class="listitem"><p>
            <code class="literal">TABLE_CONSTRAINTS</code>: <code class="literal">OPEN_FULL_TABLE</code> がすべてのカラムに適用されます
          </p></li><li class="listitem"><p>
            <code class="literal">TRIGGERS</code>: <code class="literal">OPEN_TRIGGER_ONLY</code> がすべてのカラムに適用されます
          </p></li><li class="listitem"><p>
            <code class="literal">VIEWS</code>:
          </p><div class="informaltable"><table summary="この表に、 INFORMATION_SCHEMA VIEWS テーブルカラムに適用される最適化の種類を示します。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">カラム</th><th scope="col">最適化の種類</th></tr></thead><tbody><tr><td scope="row"><code class="literal">TABLE_CATALOG</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td scope="row"><code class="literal">TABLE_SCHEMA</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td scope="row"><code class="literal">TABLE_NAME</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td scope="row"><code class="literal">VIEW_DEFINITION</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td scope="row"><code class="literal">CHECK_OPTION</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td scope="row"><code class="literal">IS_UPDATABLE</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td scope="row"><code class="literal">DEFINER</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td scope="row"><code class="literal">SECURITY_TYPE</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td scope="row"><code class="literal">CHARACTER_SET_CLIENT</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td scope="row"><code class="literal">COLLATION_CONNECTION</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr></tbody></table></div></li></ul></div><p>
        <span class="bold"><strong>3) <code class="literal">EXPLAIN</code> を使用して、サーバーがクエリーに <code class="literal">INFORMATION_SCHEMA</code> 最適化を使用できるかどうかを判断します</strong></span>
      </p><p>
        これは特に、複数のデータベースの情報を検索し、長時間かかり、パフォーマンスに影響を与える可能性のある <code class="literal">INFORMATION_SCHEMA</code> クエリーに適用されます。先述の最適化のうち、サーバーが <code class="literal">INFORMATION_SCHEMA</code> クエリーの評価に使用できるものがあれば、<code class="literal">EXPLAIN</code> の出力の <code class="literal">Extra</code> 値に示されます。次の例は、<code class="literal">Extra</code> 値に表示されることが予想される情報の種類を示しています。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT TABLE_NAME FROM INFORMATION_SCHEMA.VIEWS WHERE</code></strong>
    -&gt; <strong class="userinput"><code>TABLE_SCHEMA = 'test' AND TABLE_NAME = 'v1'\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: VIEWS
         type: ALL
possible_keys: NULL
          key: TABLE_SCHEMA,TABLE_NAME
      key_len: NULL
          ref: NULL
         rows: NULL
        Extra: Using where; Open_frm_only; Scanned 0 databases
</pre><p>
        定数のデータベースルックアップ値およびテーブルルックアップ値を使用すると、サーバーはディレクトリスキャンを回避できます。<code class="literal">VIEWS.TABLE_NAME</code> の参照では、<code class="filename">.frm</code> ファイルのみを開く必要があります。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT TABLE_NAME, ROW_FORMAT FROM INFORMATION_SCHEMA.TABLES\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: TABLES
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: NULL
        Extra: Open_full_table; Scanned all databases
</pre><p>
        ルックアップ値が指定されていない (<code class="literal">WHERE</code> 句がない) ため、サーバーはデータディレクトリと各データベースディレクトリをスキャンする必要があります。このようにして特定された各テーブルについて、テーブル名と行フォーマットが選択されます。<code class="literal">TABLE_NAME</code> では、さらにテーブルファイルを開く必要はありません (<code class="literal">SKIP_OPEN_TABLE</code> 最適化が適用されます)。<code class="literal">ROW_FORMAT</code> では、すべてのテーブルファイルを開く必要があります (<code class="literal">OPEN_FULL_TABLE</code> が適用されます)。<code class="literal">EXPLAIN</code> は <code class="literal">OPEN_FULL_TABLE</code> (<code class="literal">SKIP_OPEN_TABLE</code> より負荷が大きいため) をレポートします。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT TABLE_NAME, TABLE_TYPE FROM INFORMATION_SCHEMA.TABLES</code></strong>
    -&gt; <strong class="userinput"><code>WHERE TABLE_SCHEMA = 'test'\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: TABLES
         type: ALL
possible_keys: NULL
          key: TABLE_SCHEMA
      key_len: NULL
          ref: NULL
         rows: NULL
        Extra: Using where; Open_frm_only; Scanned 1 database
</pre><p>
        テーブル名のルックアップ値が指定されていないため、サーバーは <code class="literal">test</code> データベースディレクトリをスキャンする必要があります。<code class="literal">TABLE_NAME</code> カラムと <code class="literal">TABLE_TYPE</code> カラムには、それぞれ <code class="literal">SKIP_OPEN_TABLE</code> 最適化と <code class="literal">OPEN_FRM_ONLY</code> 最適化が適用されます。<code class="literal">EXPLAIN</code> は <code class="literal">OPEN_FRM_ONLY</code> (これの方が負荷が大きいため) をレポートします。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT B.TABLE_NAME</code></strong>
    -&gt; <strong class="userinput"><code>FROM INFORMATION_SCHEMA.TABLES AS A, INFORMATION_SCHEMA.COLUMNS AS B</code></strong>
    -&gt; <strong class="userinput"><code>WHERE A.TABLE_SCHEMA = 'test'</code></strong>
    -&gt; <strong class="userinput"><code>AND A.TABLE_NAME = 't1'</code></strong>
    -&gt; <strong class="userinput"><code>AND B.TABLE_NAME = A.TABLE_NAME\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: A
         type: ALL
possible_keys: NULL
          key: TABLE_SCHEMA,TABLE_NAME
      key_len: NULL
          ref: NULL
         rows: NULL
        Extra: Using where; Skip_open_table; Scanned 0 databases
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: B
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: NULL
        Extra: Using where; Open_frm_only; Scanned all databases;
               Using join buffer
</pre><p>
        最初の <code class="literal">EXPLAIN</code> 出力行の場合: 定数のデータベースルックアップ値およびテーブルルックアップ値により、サーバーは <code class="literal">TABLES</code> の値のディレクトリスキャンを回避できます。<code class="literal">TABLES.TABLE_NAME</code> の参照には、さらにテーブルファイルは必要ありません。
      </p><p>
        2 つめの <code class="literal">EXPLAIN</code> 出力行の場合 : <code class="literal">COLUMNS</code> テーブルのすべての値が <code class="literal">OPEN_FRM_ONLY</code> ルックアップであるため、<code class="literal">COLUMNS.TABLE_NAME</code> では、<code class="filename">.frm</code> ファイルを開く必要があります。
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT * FROM INFORMATION_SCHEMA.COLLATIONS\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: COLLATIONS
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: NULL
        Extra:
</pre><p>
        この場合、<code class="literal">COLLATIONS</code> は最適化を使用できる <code class="literal">INFORMATION_SCHEMA</code> テーブルのいずれでもないため、最適化は適用されません。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="miscellaneous-optimization-tips"></a>8.2.5 その他の最適化のヒント</h3></div></div></div><a class="indexterm" name="idm139979114501856"></a><a class="indexterm" name="idm139979114499712"></a><p>
        このセクションでは、クエリー処理速度を向上するためのさまざまな多くのヒントを示します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            接続のオーバーヘッドを回避するには、データベースに対して永続的な接続を使用します。永続的な接続を使用できないため、データベースに対して多くの新しい接続を開始する場合、<code class="literal">thread_cache_size</code> 変数の値の変更が必要になることがあります。<a class="xref" href="optimization.html#server-parameters" title="8.11.2 サーバーパラメータのチューニング">セクション8.11.2「サーバーパラメータのチューニング」</a>を参照してください。
          </p></li><li class="listitem"><p>
            すべてのクエリーがテーブル内に作成したインデックスを実際に使用していることを常に確認します。MySQL では、<code class="literal">EXPLAIN</code> ステートメントでこれを実行できます。「<a class="xref" href="optimization.html#using-explain" title="8.8.1 EXPLAIN によるクエリーの最適化">セクション8.8.1「EXPLAIN によるクエリーの最適化」</a>」を参照してください。
          </p></li><li class="listitem"><p>
            頻繁に更新される <code class="literal">MyISAM</code> テーブルに対する複雑な <code class="literal">SELECT</code> クエリーを避け、リーダーとライターの競合のために発生するテーブルロックの問題を回避するようにしてください。
          </p></li><li class="listitem"><p>
            <code class="literal">MyISAM</code> は同時挿入をサポートしています。テーブルのデータファイルの途中に空きブロックがなければ、ほかのスレッドがテーブルから読み取るのと同時に新しい行をそれに <code class="literal">INSERT</code> できます。これを実行できることが重要な場合、行の削除を避けるようにテーブルを使用することを考慮してください。別の可能性は、テーブルの大量の行を削除したあとに <code class="literal">OPTIMIZE TABLE</code> を実行して、テーブルをデフラグすることです。この動作は <code class="literal">concurrent_insert</code> 変数の設定によって変更されます。行を削除したテーブルにも新しい行を強制的に追加 (したがって同時挿入を許可) できます。<a class="xref" href="optimization.html#concurrent-inserts" title="8.10.3 同時挿入">セクション8.10.3「同時挿入」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">ARCHIVE</code> テーブルで発生したデータ圧縮問題を修正するには、<code class="literal">OPTIMIZE TABLE</code> を使用できます。<a class="xref" href="storage-engines.html#archive-storage-engine" title="15.5 ARCHIVE ストレージエンジン">セクション15.5「ARCHIVE ストレージエンジン」</a>を参照してください。
          </p></li><li class="listitem"><p>
            通常 <code class="literal"><em class="replaceable"><code>expr1</code></em>、<em class="replaceable"><code>expr2</code></em>、...</code> の順で行を取得する場合は、<code class="literal">ALTER TABLE ... ORDER BY <em class="replaceable"><code>expr1</code></em>, <em class="replaceable"><code>expr2</code></em>, ...</code> を使用します。テーブルを大幅に変更したあとにこのオプションを使用することで、パフォーマンスを向上できることがあります。
          </p></li><li class="listitem"><p>
            場合によって、ほかのカラムの情報に基づいて<span class="quote">「<span class="quote">ハッシュされた</span>」</span>カラムを導入することが役立つ場合があります。このカラムが短く、十分に一意で、インデックスが設定されている場合は、多数のカラムに<span class="quote">「<span class="quote">広範な</span>」</span>インデックスを使用するより大幅に高速化できる可能性があります。MySQL では、この追加カラムをきわめて簡単に使用できます。
          </p><pre class="programlisting">
SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>hash_col</code></em>=MD5(CONCAT(<em class="replaceable"><code>col1</code></em>,<em class="replaceable"><code>col2</code></em>))
  AND <em class="replaceable"><code>col1</code></em>='<em class="replaceable"><code>constant</code></em>' AND <em class="replaceable"><code>col2</code></em>='<em class="replaceable"><code>constant</code></em>';
</pre></li><li class="listitem"><p>
            頻繁に変更される <code class="literal">MyISAM</code> テーブルでは、すべての可変長カラム (<code class="literal">VARCHAR</code>、<code class="literal">TEXT</code>、および <code class="literal">BLOB</code>) を避けるようにします。テーブルに 1 つしか可変長カラムが含まれていない場合でも、テーブルは動的行フォーマットを使用します。<a class="xref" href="storage-engines.html" title="第 15 章 代替ストレージエンジン">第15章「<i>代替ストレージエンジン</i>」</a>を参照してください。
          </p></li><li class="listitem"><p>
            一般に、行が大きくなるためだけに、1 つのテーブルを異なるテーブルに分割することは有益ではありません。行へのアクセスで、もっとも大きくパフォーマンスに打撃を与えるものは、行の先頭バイトを見つけるために必要なディスクシークです。データが見つかったあとは、ほとんどの最新のディスクで、大多数のアプリケーションに十分な速度で行全体を読み取ることができます。テーブルを分割することがかなりの違いをもたらす状況は、固定の行サイズに変更できる動的行フォーマットを使用している <code class="literal">MyISAM</code> テーブルの場合か、またはテーブルを著しく頻繁にスキャンする必要があるが、ほとんどのカラムには必要でない場合だけです。<a class="xref" href="storage-engines.html" title="第 15 章 代替ストレージエンジン">第15章「<i>代替ストレージエンジン</i>」</a>を参照してください。
          </p></li><li class="listitem"><p>
            多数の行の情報に基づいたカウントなど、結果を頻繁に計算する必要がある場合、新しいテーブルを導入し、リアルタイムでカウンタを更新する方が望ましいことがあります。次のような形式の更新はきわめて高速です。
          </p><pre class="programlisting">
UPDATE <em class="replaceable"><code>tbl_name</code></em> SET <em class="replaceable"><code>count_col</code></em>=<em class="replaceable"><code>count_col</code></em>+1 WHERE <em class="replaceable"><code>key_col</code></em>=<em class="replaceable"><code>constant</code></em>;
</pre><p>
            これは、テーブルレベルのロック (単一ライターと複数リーダー) しかない <code class="literal">MyISAM</code> のような MySQL ストレージエンジンを使用する場合に、きわめて重要です。また、この場合に行ロックマネージャーが実行する必要があることは少ないため、ほとんどのデータベースシステムでパフォーマンスが向上します。
          </p></li><li class="listitem"><p>
            大きなログテーブルから統計を収集する必要がある場合は、ログテーブル全体をスキャンするのではなく、サマリーテーブルを使用します。サマリーの管理は、<span class="quote">「<span class="quote">ライブ</span>」</span>で統計を計算しようとする場合よりはるかに高速になるはずです。状況が変わった (ビジネス上の決定に応じて) 場合、ログから新しいサマリーテーブルを再生成する方が、実行中のアプリケーションを変更するより早いです。
          </p></li><li class="listitem"><p>
            可能であれば、統計レポートに必要なデータが、ライブデータから定期的に生成されるサマリーテーブルからのみ作成される<span class="quote">「<span class="quote">ライブ</span>」</span>または<span class="quote">「<span class="quote">統計</span>」</span>として、レポートを分類します。
          </p></li><li class="listitem"><p>
            カラムにデフォルト値があることを利用します。挿入する値がデフォルト値と異なる場合にのみ、明示的に値を挿入します。これにより、MySQL が実行する必要がある解析が減り、挿入速度が向上します。
          </p></li><li class="listitem"><p>
            状況によっては、データを <code class="literal">BLOB</code> カラムにパックし、格納すると便利です。この場合、情報をパックおよびアンパックするコードをアプリケーションに追加する必要がありますが、これにより、特定の段階で大量のアクセスを省略できます。これは、行とカラムのテーブル構造にうまく準拠していないデータがある場合に実用的です。
          </p></li><li class="listitem"><p>
            通常、すべてのデータを非冗長に維持しようとしてください (データベース理論で<em class="firstterm">第 3 正規形</em>と呼ばれるものを順守します)。ただし、高速化を図るために、情報を複製したり、サマリーテーブルを作成したりすることが有利になる状況もあります。
          </p></li><li class="listitem"><p>
            ストアドルーチンや UDF (ユーザー定義関数) は特定のタスクでパフォーマンスの向上に適切な方法である場合があります。詳しくは、<a class="xref" href="stored-programs-views.html#stored-routines" title="20.2 ストアドルーチン (プロシージャーと関数) の使用">セクション20.2「ストアドルーチン (プロシージャーと関数) の使用」</a>および<a class="xref" href="extending-mysql.html#adding-functions" title="24.3 MySQL への新しい関数の追加">セクション24.3「MySQL への新しい関数の追加」</a>を参照してください。
          </p></li><li class="listitem"><p>
            アプリケーションでクエリーや応答をキャッシュしてから、多くの挿入や更新をまとめて実行することによって、パフォーマンスを向上できます。データベースシステムで MySQL のようにテーブルロックをサポートしている場合、これはすべての更新後にインデックスキャッシュが 1 回だけフラッシュされるようにするために役立つはずです。同様の結果を得るために、MySQL のクエリーキャッシュを利用することもできます。<a class="xref" href="optimization.html#query-cache" title="8.9.3 MySQL クエリーキャッシュ">セクション8.9.3「MySQL クエリーキャッシュ」</a>を参照してください。
          </p></li><li class="listitem"><p>
            1 つの SQL ステートメントで多数の行を格納するには、複数行の <code class="literal">INSERT</code> ステートメントを使用します。(これは比較的移植可能な技法です。)
          </p></li><li class="listitem"><p>
            大量のデータをロードするには <code class="literal">LOAD DATA INFILE</code> を使用します。これは <code class="literal">INSERT</code> ステートメントを使用するより高速になります。
          </p></li><li class="listitem"><p>
            テーブルの各行を 1 つの一意の値で識別できるように、<code class="literal">AUTO_INCREMENT</code> カラムを使用します。
          </p></li><li class="listitem"><p>
            ときどき <code class="literal">OPTIMIZE TABLE</code> を使用して、動的形式の <code class="literal">MyISAM</code> テーブルによる断片化を回避します。<a class="xref" href="storage-engines.html#myisam-table-formats" title="15.2.3 MyISAM テーブルのストレージフォーマット">セクション15.2.3「MyISAM テーブルのストレージフォーマット」</a>を参照してください。
          </p></li><li class="listitem"><p>
            可能であれば、<code class="literal">MEMORY</code> テーブルを使用して、高速化を図ります。<a class="xref" href="storage-engines.html#memory-storage-engine" title="15.3 MEMORY ストレージエンジン">セクション15.3「MEMORY ストレージエンジン」</a>を参照してください。Web ブラウザで Cookie が有効にされていないユーザーに対して最後に表示されたバナーに関する情報など、頻繁にアクセスされる非クリティカルデータには <code class="literal">MEMORY</code> テーブルが役立ちます。ユーザーセッションも、揮発状態データを処理するために、多くの Web アプリケーション環境で使用できるもう 1 つの代替方法です。
          </p></li><li class="listitem"><p>
            Web サーバーでは、イメージとその他のバイナリアセットが通常、ファイルとして格納されているはずです。つまり、データベース内にはファイル自体ではなく、ファイルへの参照のみを格納します。ほとんどの Web サーバーは、データベースコンテンツよりファイルのキャッシュに優れているため、ファイルの使用は一般に高速です。
          </p></li><li class="listitem"><p>
            対応するカラムに基づいた結合が速くなるように、異なるテーブル内の同一の情報を持つカラムは同一のデータ型を持つように宣言するべきです。
          </p></li><li class="listitem"><p>
            カラム名が簡単になるようにします。たとえば、<code class="literal">customer</code> というテーブルでは <code class="literal">customer_name</code> ではなく <code class="literal">name</code> のカラム名を使用します。名前をほかの SQL サーバーに移植できるようにするため、18 文字より短くすることを考慮します。
          </p></li><li class="listitem"><p>
            実際に高速化が必要である場合、別の SQL サーバーがサポートするデータストレージの低レベルインタフェースを調べます。たとえば、MySQL <code class="literal">MyISAM</code> ストレージエンジンに直接アクセスすることによって、SQL インタフェースを使用する場合と比較して 2 倍から 5 倍の速度の向上が得られる可能性があります。これを実行可能にするには、データがアプリケーションと同じサーバー上にある必要があり、通常 1 プロセスのみからアクセスするようにしてください (外部ファイルロックは非常に遅いため)。これらの問題は、MySQL サーバーに低レベルの <code class="literal">MyISAM</code> コマンドを導入することで解消できます (これが、必要に応じてパフォーマンスを向上させる 1 つの簡単な方法になります)。データベースインタフェースを慎重に設計することで、この種類の最適化をきわめて簡単にサポートできるはずです。
          </p></li><li class="listitem"><p>
            数値データを使用している場合、多くの場合にテキストファイルにアクセスするより、ライブ接続を使用して、データベースから情報にアクセスする方が高速です。データベース内の情報はテキストファイルよりコンパクトなフォーマットで格納される可能性が高いため、それへのアクセスにかかわるディスクアクセスが少なくなります。さらに、テキストファイルを解析して、行とカラムの境界を見つける必要がないため、アプリケーション内のコードも節約できます。
          </p></li><li class="listitem"><p>
            レプリケーションは、特定の操作でパフォーマンスの向上を実現できます。クライアントの取得をレプリケーションサーバー間で分散して、負荷を分割できます。バックアップを作成する間のマスターの速度低下を避けるため、スレーブサーバーを使用して、バックアップを作成できます。<a class="xref" href="replication.html" title="第 17 章 レプリケーション">第17章「<i>レプリケーション</i>」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">DELAY_KEY_WRITE=1</code> テーブルオプションを使用して <code class="literal">MyISAM</code> テーブルを宣言すると、テーブルが閉じられるまで、ディスクにフラッシュされないため、インデックスの更新が速くなります。短所は、そのようなテーブルが開いている間に、何かによってサーバーが強制終了させられた場合に、<code class="option">--myisam-recover-options</code> オプションを使用してサーバーを実行するか、サーバーを再起動する前に <span class="command"><strong>myisamchk</strong></span> を実行して、テーブルが問題ないことを確認する必要があることです。(ただし、この場合でも、キー情報は常にデータ行から生成できるため、<code class="literal">DELAY_KEY_WRITE</code> を使用しても何も失われないはずです。)
          </p></li><li class="listitem"><p>
            <code class="literal">SELECT</code> ステートメントの優先度を挿入より高くしたい場合、サポートされる非トランザクションテーブルに、<code class="literal">INSERT LOW_PRIORITY</code> を使用します。
          </p></li><li class="listitem"><p>
            キューに割り込んで先に取得されるようにするには、サポートされる非トランザクションテーブルに <code class="literal">SELECT HIGH_PRIORITY</code> を使用します。つまり、書き込みの実行を待機している別のクライアントがある場合でも、<code class="literal">SELECT</code> が実行されます。
          </p><p>
            <code class="literal">LOW_PRIORITY</code> と <code class="literal">HIGH_PRIORITY</code> はテーブルレベルのロックのみを使用する非トランザクションストレージエンジンにのみ効果があります。
          </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="optimization-indexes"></a>8.3 最適化とインデックス</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#mysql-indexes">8.3.1 MySQL のインデックスの使用の仕組み</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-primary-keys">8.3.2 主キーの使用</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-foreign-keys">8.3.3 外部キーの使用</a></span></dt><dt><span class="section"><a href="optimization.html#column-indexes">8.3.4 カラムインデックス</a></span></dt><dt><span class="section"><a href="optimization.html#multiple-column-indexes">8.3.5 マルチカラムインデックス</a></span></dt><dt><span class="section"><a href="optimization.html#verifying-index-usage">8.3.6 インデックスの使用の確認</a></span></dt><dt><span class="section"><a href="optimization.html#myisam-index-statistics">8.3.7 InnoDB および MyISAM インデックス統計コレクション</a></span></dt><dt><span class="section"><a href="optimization.html#index-btree-hash">8.3.8 B ツリーインデックスとハッシュインデックスの比較</a></span></dt></dl></div><a class="indexterm" name="idm139979114390464"></a><p>
      <code class="literal">SELECT</code> 操作のパフォーマンスを向上する最善の方法は、クエリーでテストされる 1 つ以上のカラムにインデックスを作成することです。インデックスエントリは、テーブル行へのポインタのように動作し、クエリーが <code class="literal">WHERE</code> 句の条件に一致する行を迅速に特定し、それらの行のほかのカラム値を取得できます。すべての MySQL データ型にインデックスを設定できます。
    </p><p>
      クエリーで使用されている可能なすべてのカラムにインデックスを作成しようとしがちですが、不要なインデックスは領域を無駄にし、MySQL が使用するインデックスを判断するための時間を無駄にします。各インデックスを更新する必要があるため、インデックスは挿入、更新、削除のコストも追加します。最適なインデックスのセットを使用して、高速のクエリーを実現するために、適切なバランスを見つける必要があります。
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="mysql-indexes"></a>8.3.1 MySQL のインデックスの使用の仕組み</h3></div></div></div><a class="indexterm" name="idm139979114383264"></a><p>
        インデックスは特定のカラム値のある行をすばやく見つけるために使用されます。インデックスがないと、MySQL は関連する行を見つけるために、先頭行から始めてテーブル全体を読み取る必要があります。テーブルが大きいほど、このコストが大きくなります。テーブルに問題のカラムのインデックスが含まれている場合、MySQL はすべてのデータを調べる必要なく、データファイルの途中のシークする位置をすばやく特定できます。これはすべての行を順次読み取るよりはるかに高速です。
      </p><p>
        ほとんどの MySQL インデックス (<code class="literal">PRIMARY KEY</code>、<code class="literal">UNIQUE</code>、<code class="literal">INDEX</code>、および <code class="literal">FULLTEXT</code>) は <a class="link" href="glossary.html#glos_b_tree" title="B ツリー">B ツリー</a>に格納されます。例外: 空間データ型のインデックスは R ツリーを使用します。<code class="literal">MEMORY</code> テーブルは<a class="link" href="glossary.html#glos_hash_index" title="ハッシュインデックス">ハッシュインデックス</a>もサポートします。<code class="literal">InnoDB</code> は <code class="literal">FULLTEXT</code> インデックスの逆のリストを使用します。
      </p><p>
        一般に、インデックスは次の説明に示すように使われます。ハッシュインデックス (<code class="literal">MEMORY</code> テーブルで使用されているような) に固有の特性については、<a class="xref" href="optimization.html#index-btree-hash" title="8.3.8 B ツリーインデックスとハッシュインデックスの比較">セクション8.3.8「B ツリーインデックスとハッシュインデックスの比較」</a>で説明しています。
      </p><p>
        MySQL はこれらの操作にインデックスを使用します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">WHERE</code> 句に一致する行をすばやく見つけるため。
          </p></li><li class="listitem"><p>
            行を考慮に入れないようにするため。複数のインデックスから選択する場合、MySQL は通常最小数の行を見つけるインデックス (もっとも<a class="link" href="glossary.html#glos_selectivity" title="選択性">選択的な</a>インデックス) を使用します。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979114364176"></a> <a class="indexterm" name="idm139979114362000"></a>テーブルにマルチカラムインデックスがある場合、オプティマイザは、インデックスの左端のプリフィクスを使用して行をルックアップできます。たとえば、<code class="literal">(col1, col2, col3)</code> に 3 カラムのインデックスがある場合、<code class="literal">(col1)</code>、<code class="literal">(col1, col2)</code>、および <code class="literal">(col1, col2, col3)</code> に対して、インデックス検索機能を使用できます。詳細については、<a class="xref" href="optimization.html#multiple-column-indexes" title="8.3.5 マルチカラムインデックス">セクション8.3.5「マルチカラムインデックス」</a>を参照してください。
          </p></li><li class="listitem"><p>
            結合の実行時に、ほかのテーブルから行を取得するため。カラムが同じ型とサイズで宣言されていると、MySQL はカラムのインデックスをより効率的に使用できます。このコンテキストでは、<code class="literal">VARCHAR</code> と <code class="literal">CHAR</code> は同じサイズで宣言されていれば同じとみなされます。たとえば、<code class="literal">VARCHAR(10)</code> と <code class="literal">CHAR(10)</code> は同じサイズですが、<code class="literal">VARCHAR(10)</code> と <code class="literal">CHAR(15)</code> は異なります。
          </p><p>
            非バイナリ文字列カラム間での比較の場合、両方のカラムで同じ文字セットを使用しているべきです。たとえば、<code class="literal">utf8</code> カラムと <code class="literal">latin1</code> カラムの比較はインデックスの使用の可能性を否定します。
          </p><p>
            異種のカラムの比較 (文字列カラムを時間または数値カラムと比較するなど) では、値を変換せずに直接比較できない場合、インデックスの使用が妨げられることがあります。数値カラム内の <code class="literal">1</code> などの特定の値の場合、<code class="literal">'1'</code>、<code class="literal">' 1'</code>、<code class="literal">'00001'</code>、または <code class="literal">'01.e1'</code> などの文字列カラム内の任意の数の値と等しくなる可能性があります。これは、文字列カラムのインデックスの使用を除外します。
          </p></li><li class="listitem"><p>
            特定のインデックス設定されたカラム <em class="replaceable"><code>key_col</code></em> に対して、<code class="literal">MIN()</code> あるいは <code class="literal">MAX()</code> 値を見つけるため。これはインデックス内の <em class="replaceable"><code>key_col</code></em> より前に発生するすべてのキーパートで、<code class="literal">WHERE <em class="replaceable"><code>key_part_N</code></em> = <em class="replaceable"><code>constant</code></em></code> が使用されているかどうかをチェックするプリプロセッサによって最適化されます。この場合、MySQL は各 <code class="literal">MIN()</code> または <code class="literal">MAX()</code> 式に対して単一キールックアップを行い、それを定数で置き換えます。すべての式が定数で置き換えられた場合、クエリーは同時に返されます。例:
          </p><pre class="programlisting">
SELECT MIN(<em class="replaceable"><code>key_part2</code></em>),MAX(<em class="replaceable"><code>key_part2</code></em>)
  FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key_part1</code></em>=10;
</pre></li><li class="listitem"><p>
            使用可能なインデックスの左端のプリフィクスに対してソートまたはグループ化が行われている場合 (たとえば、<code class="literal">ORDER BY <em class="replaceable"><code>key_part1</code></em>, <em class="replaceable"><code>key_part2</code></em></code>) に、テーブルをソートまたはグループ化するため。すべてのキーパートのあとに <code class="literal">DESC</code> が付けられている場合、キーは逆の順序で読み取られます。<a class="xref" href="optimization.html#order-by-optimization" title="8.2.1.15 ORDER BY の最適化">セクション8.2.1.15「ORDER BY の最適化」</a>および<a class="xref" href="optimization.html#group-by-optimization" title="8.2.1.16 GROUP BY の最適化">セクション8.2.1.16「GROUP BY の最適化」</a>を参照してください。
          </p></li><li class="listitem"><p>
            場合によって、データ行を参照しないで値を取得するように、クエリーを最適化できます。(クエリーの必要なすべての結果を提供するインデックスは、<a class="link" href="glossary.html#glos_covering_index" title="カバリングインデックス">カバーするインデックス</a>と呼ばれます。)クエリーがテーブルから特定のインデックスに含まれるカラムのみを使用している場合、きわめて高速に、選択した値をインデックスツリーから取得できます。
          </p><pre class="programlisting">
SELECT <em class="replaceable"><code>key_part3</code></em> FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_part1</code></em>=1
</pre></li></ul></div><p>
        小さなテーブルまたは、レポートクエリーが行の大半またはすべてを処理する大きなテーブルに対するクエリーでは、インデックスはあまり重要ではありません。クエリーで行の大半にアクセスする必要がある場合は、順次読み取る方が、インデックスを処理するより高速です。クエリーですべての行が必要でない場合でも、順次読み取りは、ディスクシークを最小にします。詳細は、<a class="xref" href="optimization.html#how-to-avoid-table-scan" title="8.2.1.20 フルテーブルスキャンを回避する方法">セクション8.2.1.20「フルテーブルスキャンを回避する方法」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="optimizing-primary-keys"></a>8.3.2 主キーの使用</h3></div></div></div><a class="indexterm" name="idm139979114319360"></a><p>
        テーブルの主キーは、もっとも重要なクエリーで使用するカラムやカラムのセットを表します。それには、高速のクエリーパフォーマンスのため、インデックスが関連付けられます。それには <code class="literal">NULL</code> 値を含めることができないため、クエリーパフォーマンスは <code class="literal">NOT NULL</code> 最適化からメリットが得られます。<code class="literal">InnoDB</code> ストレージエンジンによって、テーブルデータが、主キーカラムに基づいて、超高速ルックアップおよびソートを実行するように物理的に編成されます。
      </p><p>
        テーブルが大きく、重要でも、主キーとして使用する明確なカラムやカラムのセットがない場合は、自動インクリメント値で個別のカラムを作成して、主キーとして使用できます。これらの一意の ID は、外部キーを使用してテーブルを結合する場合に、ほかのテーブル内の対応する行へのポインタとして使用できます。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="optimizing-foreign-keys"></a>8.3.3 外部キーの使用</h3></div></div></div><a class="indexterm" name="idm139979114311280"></a><p>
        テーブルに多くのカラムがあり、多くのさまざまなカラムの組み合わせをクエリーする場合、あまり頻繁に使用されないデータをそれぞれ少数のカラムを持つ個別のテーブルに分割し、それらを、メインテーブルの数値 ID カラムを複製してメインテーブルに関連付けると、効率的なことがあります。そのようにして、小さな各テーブルに、そのデータの高速ルックアップのための主キーを設定でき、結合操作を使用して必要とするカラムのセットだけをクエリーできます。データの分散状況に応じて、関連カラムがディスク上にまとめてパックされるため、クエリーで実行する I/O が少なくなり、使用するキャッシュメモリーが減る可能性があります。(パフォーマンスを最大にするため、クエリーはディスクから可能なかぎり少ないデータブロックを読み取ろうとします。数個のカラムしかないテーブルでは各データブロックにより多くのデータを収めることができます。)
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="column-indexes"></a>8.3.4 カラムインデックス</h3></div></div></div><a class="indexterm" name="idm139979114305744"></a><a class="indexterm" name="idm139979114303632"></a><a class="indexterm" name="idm139979114301600"></a><p>
        もっとも一般的なインデックスの種類には、単一カラムがあり、データ構造にそのカラムの値のコピーを格納し、対応するカラム値のある行を高速にルックアップできます。B ツリーデータ構造により、インデックスは、<code class="literal">WHERE</code> 句内の <code class="literal">=</code>、<code class="literal">&gt;</code>、<code class="literal">≤</code>、<code class="literal">BETWEEN</code>、<code class="literal">IN</code> などの演算子に対応する特定の値、値のセット、または値の範囲をすばやく見つけることができます。
      </p><p>
        テーブルあたりの最大インデックス数とインデックスの最大長は、ストレージエンジンごとに定義されます。<a class="xref" href="storage-engines.html" title="第 15 章 代替ストレージエンジン">第15章「<i>代替ストレージエンジン</i>」</a>を参照してください。すべてのストレージエンジンは、1 テーブルあたり 16 個以上のインデックスと 256 バイト以上の合計インデックス長をサポートします。ほとんどのストレージエンジンでは、制限が高く設定されています。
      </p><a class="indexterm" name="idm139979114292800"></a><a class="indexterm" name="idm139979114290640"></a><a class="indexterm" name="idm139979114288592"></a><a class="indexterm" name="idm139979114286512"></a><h4><a name="idm139979114284464"></a>プリフィクスインデックス</h4><p>
        インデックス指定で<code class="literal"><em class="replaceable"><code>col_name</code></em>(<em class="replaceable"><code>N</code></em>)</code> 構文を使用して、文字列カラムの先頭の <em class="replaceable"><code>N</code></em> 文字のみを使用するインデックスを作成できます。このようにカラム値のプリフィクスのみのインデックスを作成すると、インデックスファイルをかなり小さくできます。<code class="literal">BLOB</code> または <code class="literal">TEXT</code> カラムにインデックス設定する場合、インデックスのプリフィクス長を指定する<span class="emphasis"><em>必要があります</em></span>。例:
      </p><pre class="programlisting">
CREATE TABLE test (blob_col BLOB, INDEX(blob_col(10)));
</pre><p>
        プリフィクスは最大 1000 バイト長 (<code class="literal">innodb_large_prefix</code> を設定していないかぎり、<code class="literal">InnoDB</code> テーブルの場合は 767 バイト) です。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          プリフィクスの制限はバイト単位で測定されますが、<code class="literal">CREATE TABLE</code> ステートメントでのプリフィクス長は文字数で解釈されます。<span class="emphasis"><em>複数バイト文字セットを使用するカラムのプリフィクス長を指定する場合はこれを考慮してください</em></span>。
        </p></div><h4><a name="idm139979114272528"></a>FULLTEXT インデックス</h4><p>
        <code class="literal">FULLTEXT</code> インデックスの作成も可能です。これらは全文検索に使用されます。<code class="literal">InnoDB</code> および <code class="literal">MyISAM</code> ストレージエンジンのみが、<code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、および <code class="literal">TEXT</code> カラムに対してのみ、<code class="literal">FULLTEXT</code> インデックスをサポートしています。インデックス設定は常にカラム全体に対して行われ、カラムプリフィクスインデックス設定はサポートされていません。詳細については、<a class="xref" href="functions.html#fulltext-search" title="12.9 全文検索関数">セクション12.9「全文検索関数」</a>を参照してください。
      </p><p>
        最適化は、単一の <code class="literal">InnoDB</code> テーブルに対する特定の種類の <code class="literal">FULLTEXT</code> クエリーに適用されます。これらの特性を持つクエリーは特に効率的です。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            ドキュメント ID またはドキュメント ID と検索ランクのみを返す <code class="literal">FULLTEXT</code> クエリー。
          </p></li><li class="listitem"><p>
            一致する行をスコアの降順でソートし、<code class="literal">LIMIT</code> 句を適用して、上位 N 個の一致する行を取得する <code class="literal">FULLTEXT</code> クエリー。この最適化を適用するには、<code class="literal">WHERE</code> 句がなく、降順の単一の <code class="literal">ORDER BY</code> 句のみがある必要があります。
          </p></li><li class="listitem"><p>
            検索語に一致する行の <code class="literal">COUNT(*)</code> 値のみを取得し、追加の <code class="literal">WHERE</code> 句がない <code class="literal">FULLTEXT</code> クエリー。<code class="literal">WHERE</code> 句を <code class="literal">&gt; 0</code> 比較演算子を使用せずに、<code class="literal">WHERE MATCH(<em class="replaceable"><code>text</code></em>) AGAINST ('<em class="replaceable"><code>other_text</code></em>')</code> とコーディングします。
          </p></li></ul></div><h4><a name="idm139979114248688"></a>空間インデックス</h4><p>
        空間データ型にインデックスを作成することもできます。現在、<code class="literal">MyISAM</code> のみが空間型への R ツリーインデックスをサポートしています。ほかのストレージエンジンは、空間型のインデックス設定に B ツリーを使用します (<code class="literal">ARCHIVE</code> を除きます。これは空間型のインデックス設定をサポートしていません)。
      </p><h4><a name="idm139979114245344"></a>MEMORY ストレージエンジンでのインデックス</h4><p>
        <code class="literal">MEMORY</code> ストレージエンジンはデフォルトで <code class="literal">HASH</code> インデックスを使用しますが、<code class="literal">BTREE</code> インデックスもサポートしています。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="multiple-column-indexes"></a>8.3.5 マルチカラムインデックス</h3></div></div></div><a class="indexterm" name="idm139979114240560"></a><a class="indexterm" name="idm139979114239104"></a><a class="indexterm" name="idm139979114237072"></a><p>
        MySQL は複合インデックス (つまり、複数のカラムに対するインデックス) を作成できます。インデックスは最大 16 カラムで構成できます。特定のデータ型では、カラムのプリフィクスにインデックスを設定できます (<a class="xref" href="optimization.html#column-indexes" title="8.3.4 カラムインデックス">セクション8.3.4「カラムインデックス」</a>を参照してください)。
      </p><p>
        MySQL では、インデックスで、すべてのカラムをテストするクエリーまたは最初のカラム、最初の 2 つのカラム、最初の 3 つのカラムというようにテストするクエリーにマルチカラムインデックスを使用できます。インデックス定義の正しい順序でカラムを指定する場合、単一の複合インデックスにより、同じテーブルへの複数の種類のクエリーを高速化できます。
      </p><p>
        マルチカラムインデックスは、インデックス設定されたカラムの値を連結して作成された値を格納する行である、ソート済みの配列とみなすことができます。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          複合インデックスの代わりに、ほかのカラムの情報に基づいて<span class="quote">「<span class="quote">ハッシュされた</span>」</span>カラムを導入できます。このカラムが短く、十分に一意で、インデックスが設定されている場合は、多数のカラムへの<span class="quote">「<span class="quote">広範な</span>」</span>インデックスより速くなる可能性があります。MySQL では、この追加カラムをきわめて簡単に使用できます。
        </p><pre class="programlisting">
SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>hash_col</code></em>=MD5(CONCAT(<em class="replaceable"><code>val1</code></em>,<em class="replaceable"><code>val2</code></em>))
  AND <em class="replaceable"><code>col1</code></em>=<em class="replaceable"><code>val1</code></em> AND <em class="replaceable"><code>col2</code></em>=<em class="replaceable"><code>val2</code></em>;
</pre></div><p>
        テーブルが次のような仕様であるとします。
      </p><pre class="programlisting">
CREATE TABLE test (
    id         INT NOT NULL,
    last_name  CHAR(30) NOT NULL,
    first_name CHAR(30) NOT NULL,
    PRIMARY KEY (id),
    INDEX name (last_name,first_name)
);
</pre><p>
        <code class="literal">name</code> インデックスは、<code class="literal">last_name</code> カラムと <code class="literal">first_name</code> カラムに対するインデックスです。このインデックスは、<code class="literal">last_name</code> 値と <code class="literal">first_name</code> 値の組み合わせに既知の範囲の値を指定するクエリーで、ルックアップに使用できます。そのカラムはインデックスの左端のプリフィクスであるため、<code class="literal">last_name</code> 値だけを指定するクエリーにも使用できます (このセクションで後述するように)。そのため、<code class="literal">name</code> インデックスは、次のクエリーでのルックアップに使用されます。
      </p><pre class="programlisting">
SELECT * FROM test WHERE last_name='Widenius';

SELECT * FROM test
  WHERE last_name='Widenius' AND first_name='Michael';

SELECT * FROM test
  WHERE last_name='Widenius'
  AND (first_name='Michael' OR first_name='Monty');

SELECT * FROM test
  WHERE last_name='Widenius'
  AND first_name &gt;='M' AND first_name &lt; 'N';
</pre><p>
        ただし、<code class="literal">name</code> インデックスは次のクエリーでのルックアップには使用<span class="emphasis"><em>されません</em></span>。
      </p><pre class="programlisting">
SELECT * FROM test WHERE first_name='Michael';

SELECT * FROM test
  WHERE last_name='Widenius' OR first_name='Michael';
</pre><p>
        次の <code class="literal">SELECT</code> ステートメントを発行するとします。
      </p><pre class="programlisting">
SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE col1=<em class="replaceable"><code>val1</code></em> AND col2=<em class="replaceable"><code>val2</code></em>;
</pre><p>
        <code class="literal">col1</code> と <code class="literal">col2</code> に対するマルチカラムインデックスが存在する場合、該当する行を直接フェッチできます。<code class="literal">col1</code> および <code class="literal">col2</code> に対して個別の単一カラムのインデックスが存在する場合、オプティマイザは、インデックスマージ最適化 (<a class="xref" href="optimization.html#index-merge-optimization" title="8.2.1.4 インデックスマージの最適化">セクション8.2.1.4「インデックスマージの最適化」</a>を参照してください) の使用を試みるか、またはより多くの行を除外するインデックスを判断して、そのインデックスを使用して行をフェッチすることで、もっとも制限の厳しいインデックスを見つけようとします。
      </p><a class="indexterm" name="idm139979114205168"></a><a class="indexterm" name="idm139979114203040"></a><p>
        テーブルにマルチカラムインデックスがある場合、オプティマイザは、インデックスの左端のプリフィクスを使用して行をルックアップできます。たとえば、<code class="literal">(col1, col2, col3)</code> に 3 カラムのインデックスがある場合、<code class="literal">(col1)</code>、<code class="literal">(col1, col2)</code>、および <code class="literal">(col1, col2, col3)</code> に対して、インデックス検索機能を使用できます。
      </p><p>
        カラムがインデックスの左端のプリフィクスを形成していない場合、MySQL はこのインデックスを使用してルックアップを実行できません。ここに示す <code class="literal">SELECT</code> ステートメントがあるとします。
      </p><pre class="programlisting">
SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE col1=<em class="replaceable"><code>val1</code></em>;
SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE col1=<em class="replaceable"><code>val1</code></em> AND col2=<em class="replaceable"><code>val2</code></em>;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE col2=<em class="replaceable"><code>val2</code></em>;
SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE col2=<em class="replaceable"><code>val2</code></em> AND col3=<em class="replaceable"><code>val3</code></em>;
</pre><p>
        <code class="literal">(col1, col2, col3)</code> にインデックスが存在する場合、最初の 2 つのクエリーだけがインデックスを使用します。3 つめと 4 つめのクエリーには、インデックス設定されたカラムがかかわりますが、<code class="literal">(col2)</code> と <code class="literal">(col2, col3)</code> は <code class="literal">(col1, col2, col3)</code> の左端のプリフィクスではありません。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="verifying-index-usage"></a>8.3.6 インデックスの使用の確認</h3></div></div></div><p>
        すべてのクエリーがテーブル内に作成したインデックスを実際に使用していることを常に確認します。<a class="xref" href="optimization.html#using-explain" title="8.8.1 EXPLAIN によるクエリーの最適化">セクション8.8.1「EXPLAIN によるクエリーの最適化」</a>に説明するように、<code class="literal">EXPLAIN</code> ステートメントを使用します。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="myisam-index-statistics"></a>8.3.7 InnoDB および MyISAM インデックス統計コレクション</h3></div></div></div><p>
        ストレージエンジンはオプティマイザによって使用されるテーブルに関する統計を収集します。テーブル統計は値グループに基づきますが、ここで値グループは同じキープリフィクス値を持つ行のセットです。オプティマイザの目的で、重要な統計は平均値グループサイズです。
      </p><p>
        MySQL は平均値グループサイズを次のように使用します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            各 <code class="literal">ref</code> アクセスごとに読み取る必要がある行数を見積もるため
          </p></li><li class="listitem"><p>
            部分結合で生成される行数、つまりこの形式の操作で生成される行数を見積もるため:
          </p><pre class="programlisting">
(...) JOIN <em class="replaceable"><code>tbl_name</code></em> ON <em class="replaceable"><code>tbl_name</code></em>.<em class="replaceable"><code>key</code></em> = <em class="replaceable"><code>expr</code></em>
</pre></li></ul></div><p>
        インデックスの平均値グループサイズが増えるほど、ルックアップあたりの平均行数が増えるため、それらの 2 つの目的でインデックスが役立たなくなります。インデックスが最適化の目的に役立つようにするには、各インデックス値でターゲットとするテーブル内の行を少なくすることがもっとも適切です。指定したインデックス値が多数の行を生成する場合、そのインデックスはあまり役に立たず、MySQL がそれを使用する可能性は少なくなります。
      </p><p>
        平均値グループサイズは、値グループの数であるテーブルカーディナリティーと関連しています。<code class="literal">SHOW INDEX</code> ステートメントは、<em class="replaceable"><code>N/S</code></em> に基づいて、カーディナリティー値を表示します。ここで <em class="replaceable"><code>N</code></em> はテーブル内の行数で、<em class="replaceable"><code>S</code></em> は平均値グループサイズです。その比率から、テーブル内の値グループの概数がわかります。
      </p><p>
        <code class="literal">&lt;=&gt;</code> 比較演算子に基づいた結合では、<code class="literal">NULL</code> の扱いはほかの値と異なりません。ほかのどの <em class="replaceable"><code>N</code></em> に対しても <code class="literal"><em class="replaceable"><code>N</code></em> &lt;=&gt; <em class="replaceable"><code>N</code></em></code> とまったく同じように、<code class="literal">NULL &lt;=&gt; NULL</code> です。
      </p><p>
        ただし、<code class="literal">=</code> 演算子に基づく結合では、<code class="literal">NULL</code> は <code class="literal">NULL</code> 以外の値と異なります。<em class="replaceable"><code>expr1</code></em> または <em class="replaceable"><code>expr2</code></em> (または両方) が <code class="literal">NULL</code> である場合、<code class="literal"><em class="replaceable"><code>expr1</code></em> = <em class="replaceable"><code>expr2</code></em></code> は true になりません。これは、形式 <code class="literal"><em class="replaceable"><code>tbl_name.key</code></em> = <em class="replaceable"><code>expr</code></em></code> の比較の <code class="literal">ref</code> アクセスに影響を与えます。<em class="replaceable"><code>expr</code></em> の現在値が <code class="literal">NULL</code> の場合、比較は true にならないため、MySQL はテーブルにアクセスしません。
      </p><p>
        <code class="literal">=</code> 比較では、テーブルにある <code class="literal">NULL</code> 値の数は問題になりません。最適化の目的で、関連のある値は <code class="literal">NULL</code> 以外の値グループの平均サイズです。ただし、MySQL では現在その平均サイズを収集したり、使用したりできません。
      </p><p>
        <code class="literal">InnoDB</code> および <code class="literal">MyISAM</code> テーブルでは、<code class="literal">innodb_stats_method</code> および <code class="literal">myisam_stats_method</code> システム変数をそれぞれ使用して、テーブル統計のコレクションに対していくらかの制御ができます。これらの変数には、3 つの可能性のある値を使用でき、次のように異なります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            変数が <code class="literal">nulls_equal</code> に設定されている場合、すべての <code class="literal">NULL</code> 値が同一として扱われます (つまり、それらすべてが単一の値グループを形成します)。
          </p><p>
            <code class="literal">NULL</code> 値グループサイズが、<code class="literal">NULL</code> 以外の値グループサイズよりはるかに大きい場合、このメソッドは平均値グループサイズを上方に歪めます。これにより、オプティマイザには、<code class="literal">NULL</code> 以外の値を検索する結合に対して、インデックスが実際以上に役に立たないかのように見えます。結果として、<code class="literal">nulls_equal</code> メソッドにより、オプティマイザに <code class="literal">ref</code> アクセスに対してインデックスを使用すべきときでも使用させないようにすることがあります。
          </p></li><li class="listitem"><p>
            変数が <code class="literal">nulls_unequal</code> に設定されている場合、<code class="literal">NULL</code> 値は同じとみなされません。代わりに、各 <code class="literal">NULL</code> 値はサイズ 1 の個別の値グループを形成します。
          </p><p>
            多くの <code class="literal">NULL</code> 値がある場合、このメソッドは平均値グループサイズを下方に歪めます。<code class="literal">NULL</code> 以外の平均値グループサイズが大きい場合、<code class="literal">NULL</code> 値をサイズ 1 のグループとしてカウントすると、オプティマイザは <code class="literal">NULL</code> 以外の値を検索する結合に対して、インデックスの値を多く見積もりすぎます。結果として、<code class="literal">nulls_unequal</code> メソッドによって、ほかのメソッドの方が適している可能性がある場合に、オプティマイザに <code class="literal">ref</code> ルックアップに対してこのインデックスを使用させることがあります。
          </p></li><li class="listitem"><p>
            変数が <code class="literal">nulls_ignored</code> に設定されている場合、<code class="literal">NULL</code> 値は無視されます。
          </p></li></ul></div><p>
        <code class="literal">=</code> より <code class="literal">&lt;=&gt;</code> を使用する多くの結合を使用する傾向がある場合、比較で <code class="literal">NULL</code> 値は特別ではなく、<code class="literal">NULL</code> は互いに等しくなります。この場合、<code class="literal">nulls_equal</code> は適切な統計メソッドです。
      </p><p>
        <code class="literal">innodb_stats_method</code> システム変数にはグローバル値があります。<code class="literal">myisam_stats_method</code> システム変数にはグローバル値とセッション値の両方があります。グローバル値を設定すると、対応するストレージエンジンからのテーブルの統計収集に影響します。セッション値を設定すると、現在のクライアント接続のみに対する統計収集に影響します。これは、<code class="literal">myisam_stats_method</code> のセッション値を設定することで、ほかのクライアントに影響を与えずに、指定したメソッドで、テーブルの統計を強制的に再生成させることができることを意味します。
      </p><p>
        テーブル統計を再生成するには、次のいずれかのメソッドを使用できます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <span class="command"><strong>myisamchk --stats_method=<em class="replaceable"><code>method_name</code></em> --analyze</strong></span> を実行します
          </p></li><li class="listitem"><p>
            テーブルを変更して、統計を古くさせ (たとえば、行を挿入してから削除します)、次に <code class="literal">myisam_stats_method</code> を設定して、<code class="literal">ANALYZE TABLE</code> ステートメントを発行します。
          </p></li></ul></div><p>
        <code class="literal">innodb_stats_method</code> と <code class="literal">myisam_stats_method</code> の使用に関するいくつかの警告は次のとおりです。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            先述したように、テーブル統計を明示的に収集させることができます。ただし、MySQL は統計を自動的に収集することもあります。たとえば、テーブルへのステートメントの実行の途中で、そうしたステートメントの中にはテーブルを変更するものもあり、MySQL は統計を収集する場合があります。(たとえば、これは一括挿入や削除、または一部の <code class="literal">ALTER TABLE</code> ステートメントで行われることがあります。)これが行われた場合、その時点での <code class="literal">innodb_stats_method</code> または <code class="literal">myisam_stats_method</code> の値を使用して、統計が収集されます。そのため、あるメソッドを使用して統計を収集しても、あとでテーブルの統計が自動的に収集されたときに、システム変数にほかのメソッドが設定されていると、そのほかのメソッドが使われます。
          </p></li><li class="listitem"><p>
            特定のテーブルの統計の生成に使用されたメソッドを伝える方法はありません。
          </p></li><li class="listitem"><p>
            これらの変数は <code class="literal">InnoDB</code> および <code class="literal">MyISAM</code> テーブルにのみ適用されます。ほかのストレージエンジンはテーブル統計を収集するメソッドが 1 つしかありません。通常、それは <code class="literal">nulls_equal</code> メソッドに近いものになります。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="index-btree-hash"></a>8.3.8 B ツリーインデックスとハッシュインデックスの比較</h3></div></div></div><a class="indexterm" name="idm139979114099040"></a><a class="indexterm" name="idm139979114097552"></a><p>
        B ツリーおよびハッシュデータ構造を理解することは、インデックスにこれらのデータ構造を使用するさまざまなストレージエンジンで (特に B ツリーインデックスを使用するか、ハッシュインデックスを使用するかを選択できる <code class="literal">MEMORY</code> ストレージエンジンの場合に)、さまざまなクエリーがどのように実行されるかを予測するのに役立つ可能性があります。
      </p><h4><a name="idm139979114094112"></a>B ツリーインデックスの特性</h4><a class="indexterm" name="idm139979114093344"></a><a class="indexterm" name="idm139979114091280"></a><a class="indexterm" name="idm139979114089216"></a><a class="indexterm" name="idm139979114087184"></a><p>
        B ツリーインデックスは <code class="literal">=</code>、<code class="literal">&gt;</code>、<code class="literal">&gt;=</code>、<code class="literal">&lt;</code>、<code class="literal">&lt;=</code>、または <code class="literal">BETWEEN</code> 演算子を使用する式で、カラム比較に使用できます。このインデックスは、<code class="literal">LIKE</code> への引数がワイルドカード文字で始まらない定数文字列の場合の <code class="literal">LIKE</code> 比較にも使用できます。たとえば、次の <code class="literal">SELECT</code> ステートメントはインデックスを使用します。
      </p><pre class="programlisting">
SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key_col</code></em> LIKE 'Patrick%';
SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key_col</code></em> LIKE 'Pat%_ck%';
</pre><p>
        最初のステートメントでは、<code class="literal">'Patrick' &lt;= <em class="replaceable"><code>key_col</code></em> &lt; 'Patricl'</code> の行のみが考慮されます。2 つめのステートメントでは、<code class="literal">'Pat' &lt;= <em class="replaceable"><code>key_col</code></em> &lt; 'Pau'</code> の行のみが考慮されます。
      </p><p>
        次の <code class="literal">SELECT</code> ステートメントはインデックスを使用しません。
      </p><pre class="programlisting">
SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key_col</code></em> LIKE '%Patrick%';
SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key_col</code></em> LIKE <em class="replaceable"><code>other_col</code></em>;
</pre><p>
        最初のステートメントでは、<code class="literal">LIKE</code> 値はワイルドカード文字で始まります。2 つめのステートメントでは、<code class="literal">LIKE</code> 値は定数ではありません。
      </p><p>
        <code class="literal">... LIKE '%<em class="replaceable"><code>string</code></em>%'</code> を使用し、<em class="replaceable"><code>string</code></em> が 3 文字より長い場合、MySQL は <em class="firstterm">Turbo Boyer-Moore アルゴリズム</em>を使用して、文字列のパターンを初期化してから、このパターンを使用して検索をより迅速に実行します。
      </p><a class="indexterm" name="idm139979114058752"></a><a class="indexterm" name="idm139979114056576"></a><p>
        <code class="literal"><em class="replaceable"><code>col_name</code></em> IS NULL</code> を使用した検索では、<em class="replaceable"><code>col_name</code></em> にインデックスが設定されている場合にインデックスが使用されます。
      </p><p>
        <code class="literal">WHERE</code> 句内のすべての <code class="literal">AND</code> レベルにまたがっていないインデックスは、クエリーの最適化に使用されません。言い換えると、インデックスの使用を可能にするには、インデックスのプリフィクスがすべての <code class="literal">AND</code> グループで使用されている必要があります。
      </p><p>
        次の <code class="literal">WHERE</code> 句ではインデックスが使用されます。
      </p><pre class="programlisting">
... WHERE <em class="replaceable"><code>index_part1</code></em>=1 AND <em class="replaceable"><code>index_part2</code></em>=2 AND <em class="replaceable"><code>other_column</code></em>=3

    /* <em class="replaceable"><code>index</code></em> = 1 OR <em class="replaceable"><code>index</code></em> = 2 */
... WHERE <em class="replaceable"><code>index</code></em>=1 OR A=10 AND <em class="replaceable"><code>index</code></em>=2

    /* optimized like "<em class="replaceable"><code>index_part1</code></em>='hello'" */
... WHERE <em class="replaceable"><code>index_part1</code></em>='hello' AND <em class="replaceable"><code>index_part3</code></em>=5

    /* Can use index on <em class="replaceable"><code>index1</code></em> but not on <em class="replaceable"><code>index2</code></em> or <em class="replaceable"><code>index3</code></em> */
... WHERE <em class="replaceable"><code>index1</code></em>=1 AND <em class="replaceable"><code>index2</code></em>=2 OR <em class="replaceable"><code>index1</code></em>=3 AND <em class="replaceable"><code>index3</code></em>=3;
</pre><p>
        これらの <code class="literal">WHERE</code> 句ではインデックスが使用<span class="emphasis"><em>されません</em></span>。
      </p><pre class="programlisting">
    /* <em class="replaceable"><code>index_part1</code></em> is not used */
... WHERE <em class="replaceable"><code>index_part2</code></em>=1 AND <em class="replaceable"><code>index_part3</code></em>=2

    /*  Index is not used in both parts of the WHERE clause  */
... WHERE <em class="replaceable"><code>index</code></em>=1 OR A=10

    /* No index spans all rows  */
... WHERE <em class="replaceable"><code>index_part1</code></em>=1 OR <em class="replaceable"><code>index_part2</code></em>=10
</pre><p>
        MySQL ではインデックスが使用できる場合でも使用しないことがあります。これが発生する 1 つの状況は、オプティマイザが、インデックスを使用することによって MySQL がテーブルの大部分の行にアクセスする必要があると推定した場合です。(この場合、必要なシークが少ないため、テーブルスキャンの方がはるかに高速になる可能性があります。) ただし、そのようなクエリーで、行の一部のみを取得する <code class="literal">LIMIT</code> を使用している場合、結果で返す少数の行をはるかにすばやく見つけることができるため、MySQL はとにかくインデックスを使用します。
      </p><h4><a name="idm139979114031984"></a>ハッシュインデックスの特性</h4><a class="indexterm" name="idm139979114031264"></a><p>
        ハッシュインデックスは先述したものといくらか異なる特性を持ちます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            それらは、<code class="literal">=</code> または <code class="literal">&lt;=&gt;</code> 演算子を使用する等価比較にのみ使用されます (ただし<span class="emphasis"><em>きわめて</em></span>高速です)。それらは、値の範囲を見つける <code class="literal">&lt;</code> などの比較演算子には使用されません。この種類の単一値ルックアップに依存するシステムは、<span class="quote">「<span class="quote">キー値ストア</span>」</span>として知られています。そのようなアプリケーションで MySQL を使用するには、可能なかぎりハッシュインデックスを使用します。
          </p></li><li class="listitem"><p>
            オプティマイザはハッシュインデックスを使用して、<code class="literal">ORDER BY</code> 操作を高速化することはできません。(この種類のインデックスは順番に次のエントリを検索するために使用できません。)
          </p></li><li class="listitem"><p>
            MySQL は 2 つの値の間におよそどのくらいの行数があるかを判断できません (これは範囲オプティマイザによって使用するインデックスを特定するために使用されます)。これは、<code class="literal">MyISAM</code> または <code class="literal">InnoDB</code> テーブルをハッシュインデックス設定された <code class="literal">MEMORY</code> テーブルに変更した場合に、一部のクエリーに影響することがあります。
          </p></li><li class="listitem"><p>
            行の検索にはキー全体のみを使用できます。(B ツリーインデックスでは、キーの任意の左端のプリフィクスを使用して行を検索できます。)
          </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="optimizing-database-structure"></a>8.4 データベース構造の最適化</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#data-size">8.4.1 データサイズの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimize-data-types">8.4.2 MySQL データ型の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimize-multi-tables">8.4.3 多数のテーブルの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#internal-temporary-tables">8.4.4 MySQL が内部一時テーブルを使用する仕組み</a></span></dt></dl></div><p>
      データベース設計者としての役割では、スキーマ、テーブル、およびカラムを編成するもっとも効率的な方法を探します。アプリケーションコードをチューニングする場合、I/O を最小にし、関連項目をまとめて、データボリュームが増加してもパフォーマンスを高く維持するように、事前に計画します。効率的なデータベース設計から始めることで、チームメンバーは高性能のアプリケーションコードを簡単に書けるようになり、アプリケーションが発展して、書き換えられても、データベースを持ちこたえさせる可能性が高くなります。
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="data-size"></a>8.4.1 データサイズの最適化</h3></div></div></div><a class="indexterm" name="idm139979114013024"></a><a class="indexterm" name="idm139979114010912"></a><a class="indexterm" name="idm139979114008880"></a><a class="indexterm" name="idm139979114006832"></a><a class="indexterm" name="idm139979114004768"></a><p>
        ディスク上の領域を最小にするようにテーブルを設計します。これにより、ディスクに対して読み取りおよび書き込みされるデータの量が減ることで、大幅な改善が見られます。内容がクエリー実行中にアクティブに処理される間、テーブルが小さいほど、通常必要なメインメモリーの量は少なくなります。テーブルデータの領域の削減により、インデックスも小さくなり、高速に処理できます。
      </p><p>
        MySQL は多数のさまざまなストレージエンジン (テーブル型) と行フォーマットをサポートしています。テーブルごとに、使用するストレージとインデックス設定方法を決定できます。アプリケーションに適切なテーブル形式を選択することで、大幅なパフォーマンスの向上が得られることがあります。<a class="xref" href="storage-engines.html" title="第 15 章 代替ストレージエンジン">第15章「<i>代替ストレージエンジン</i>」</a>を参照してください。
      </p><p>
        ここで挙げられた技法を使用して、テーブルのパフォーマンス改善とストレージ領域の最小化を図ることができます。
      </p><h4><a name="idm139979113999200"></a>テーブルカラム</h4><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            可能なかぎりもっとも効率的 (最小) のデータ型を使用します。MySQL にはディスク領域とメモリーを節約する多くの専用の型があります。たとえば、可能な場合は、小さなテーブルを取得するために、小さな整数型を使用します。<code class="literal">MEDIUMINT</code> カラムが使用する領域は 25% 少ないため、<code class="literal">MEDIUMINT</code> は多くの場合に <code class="literal">INT</code> より適切な選択肢です。
          </p></li><li class="listitem"><p>
            可能な場合は、カラムを <code class="literal">NOT NULL</code> として宣言します。それにより、インデックスを適切に使用し、各値が <code class="literal">NULL</code> であるかどうかをテストするためのオーバーヘッドがなくなることで、SQL の操作が速くなります。カラムあたり 1 ビットでいくらかのストレージ領域も節約します。テーブルで実際に <code class="literal">NULL</code> 値が必要な場合、それらを使用します。単にすべてのカラムで <code class="literal">NULL</code> 値を許可するデフォルトの設定を避けます。
          </p></li></ul></div><h4><a name="idm139979113988896"></a>行フォーマット</h4><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">InnoDB</code> テーブルはコンパクトストレージフォーマットを使用します。5.0.3 より前の MySQL のバージョンでは、<code class="literal">InnoDB</code> の行に、固定サイズのカラムでも、カラム数や各カラムの長さなど、いくつかの冗長な情報が含まれます。デフォルトで、テーブルはコンパクト形式 (<code class="literal">ROW_FORMAT=COMPACT</code>) で作成されます。MySQL の古いバージョンにダウングレードしたい場合、<code class="literal">ROW_FORMAT=REDUNDANT</code> で古い形式を要求できます。
          </p><p>
            コンパクト行フォーマットの存在により、行のストレージ領域が約 20% 減少しますが、一部の操作で CPU の使用が増加する犠牲を伴います。ワークロードが、キャッシュヒット率とディスク速度によって制限される通常のワークロードであれば、速くなる可能性があります。CPU 速度によって制限されるまれな例では、遅くなることがあります。
          </p><p>
            コンパクト <code class="literal">InnoDB</code> 形式では UTF-8 データを含む <code class="literal">CHAR</code> カラムが格納される方法も変わります。UTF-8 エンコード文字の最大長が 3 バイトであるとして、<code class="literal">ROW_FORMAT=REDUNDANT</code> では、UTF-8 <code class="literal">CHAR(<em class="replaceable"><code>N</code></em>)</code> は 3 × <em class="replaceable"><code>N</code></em> バイトを占有します。多くの言語は主にシングルバイト UTF-8 文字を使用して書くことができるため、固定のストレージ長は多くの場合に領域を無駄にします。<code class="literal">ROW_FORMAT=COMPACT</code> 形式では、<code class="literal">InnoDB</code> は <em class="replaceable"><code>N</code></em> から 3 × <em class="replaceable"><code>N</code></em> バイトの範囲のストレージの可変容量を、必要に応じて末尾のスペースを取り除いて、これらのカラムに割り当てます。最小のストレージ長は、一般的な場合にインプレース更新を容易にする <em class="replaceable"><code>N</code></em> バイトとして保持されます。
          </p></li><li class="listitem"><p>
            テーブルデータを圧縮形式で保存することで、さらに領域を最小にするには、<code class="literal">InnoDB</code> テーブルを作成する際に <code class="literal">ROW_FORMAT=COMPRESSED</code> を指定するか、既存の <code class="literal">MyISAM</code> テーブルに対して、<span class="command"><strong>myisampack</strong></span> コマンドを実行します。(<code class="literal">InnoDB</code> 圧縮テーブルは読み取り可能で書き込み可能ですが、<code class="literal">MyISAM</code> 圧縮テーブルは読み取り専用です。)
          </p></li><li class="listitem"><p>
            <code class="literal">MyISAM</code> テーブルで、可変長カラム (<code class="literal">VARCHAR</code>、<code class="literal">TEXT</code>、あるいは <code class="literal">BLOB</code> など) がない場合は、固定サイズ行フォーマットが使用されます。これは高速ですが、いくらか領域を無駄にすることがあります。<a class="xref" href="storage-engines.html#myisam-table-formats" title="15.2.3 MyISAM テーブルのストレージフォーマット">セクション15.2.3「MyISAM テーブルのストレージフォーマット」</a>を参照してください。<code class="literal">CREATE TABLE</code> オプション <code class="literal">ROW_FORMAT=FIXED</code> によって、<code class="literal">VARCHAR</code> カラムがある場合でも、固定長の行を必要としていることを伝えることができます。
          </p></li></ul></div><h4><a name="idm139979113959472"></a>インデックス</h4><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            テーブルのプライマリインデックスは可能なかぎり短くしてください。これにより、各行の識別が容易になり効率的になります。<code class="literal">InnoDB</code> テーブルの場合、主キーカラムは、各セカンダリインデックスエントリに複製されるため、多数のセカンダリインデックスがある場合に、短い主キーによって、かなりの領域が節約されます。
          </p></li><li class="listitem"><p>
            クエリーパフォーマンスを向上するために必要なインデックスのみを作成します。インデックスは取得には有効ですが、挿入および更新操作を遅くします。ほとんどカラムの組み合わせに対して検索することによって、テーブルにアクセスする場合、カラムごとに個別のインデックスを作成するのではなく、それらに対して単一の複合インデックスを作成します。インデックスの最初の部分は、もっとも使用されるカラムにするべきです。テーブルから選択する場合に、<span class="emphasis"><em>常に</em></span>多くのカラムを使用する場合、適切なインデックスの圧縮を取得するため、インデックスの最初のカラムは、もっとも重複の多いカラムにするべきです。
          </p></li><li class="listitem"><p>
            長い文字列カラムで、最初の数文字に一意のプリフィクスがある可能性が高い場合、MySQL のカラムの左端の部分へのインデックスの作成のサポート (<a class="xref" href="sql-syntax.html#create-index" title="13.1.13 CREATE INDEX 構文">セクション13.1.13「CREATE INDEX 構文」</a>を参照してください) を使用して、このプリフィクスのみにインデックスを設定することをお勧めします。短いインデックスほど速くなるのは、必要なディスク領域が少ないだけでなく、インデックスキャッシュでのヒットが多くなり、そのためにディスクシークが少なくなるためでもあります。<a class="xref" href="optimization.html#server-parameters" title="8.11.2 サーバーパラメータのチューニング">セクション8.11.2「サーバーパラメータのチューニング」</a>を参照してください。
          </p></li></ul></div><h4><a name="idm139979113949712"></a>結合</h4><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            状況によって、頻繁にスキャンされるテーブルを 2 つに分割することで、メリットがある場合があります。これは特に、それが動的形式テーブルで、テーブルのスキャン時に、関連行を見つけるために使用できる小さな静的形式テーブルを使用できる場合に当てはまります。
          </p></li><li class="listitem"><p>
            対応するカラムに基づいた結合を高速化するには、異なるテーブル内の同一の情報を持つカラムを同一のデータ型で宣言します。
          </p></li><li class="listitem"><p>
            異なるテーブルで同じ名前を使用し、結合クエリーを簡略化できるように、カラム名を簡単にします。たとえば、<code class="literal">customer</code> というテーブルでは <code class="literal">customer_name</code> ではなく <code class="literal">name</code> のカラム名を使用します。名前をほかの SQL サーバーに移植できるようにするため、18 文字より短くすることを考慮します。
          </p></li></ul></div><h4><a name="idm139979113942400"></a>正規化</h4><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            通常、すべてのデータを非冗長に維持しようとしてください (データベース理論で<em class="firstterm">第 3 正規形</em>と呼ばれるものを順守します)。名前や住所などの長い値を繰り返す代わりに、それらに一意の ID を割り当て、複数の小さなテーブルで必要なだけこれらの ID を繰り返し、結合句で ID を参照して、クエリーでテーブルを結合します。
          </p></li><li class="listitem"><p>
            たとえば、大きなテーブルからすべてのデータを解析するビジネスインテリジェンスシナリオなどで、ディスク領域やデータの複数のコピーを維持する保守コストより、速度の方が重要である場合、正規化ルールを緩和して、情報を複製したり、サマリーテーブルを作成したりして、速度を向上させることができます。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="optimize-data-types"></a>8.4.2 MySQL データ型の最適化</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#optimize-numeric">8.4.2.1 数値データの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimize-character">8.4.2.2 文字および文字列型の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimize-blob">8.4.2.3 BLOB 型の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#procedure-analyse">8.4.2.4 PROCEDURE ANALYSE の使用</a></span></dt></dl></div><p></p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="optimize-numeric"></a>8.4.2.1 数値データの最適化</h4></div></div></div><a class="indexterm" name="idm139979113935136"></a><p></p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              文字列または数値として表すことができる一意の ID やその他の値の場合、文字列カラムより数値カラムをお勧めします。大きな数値は、対応する文字列より少ないバイト数で格納できるため、それらの転送と比較が高速になり、使用するメモリーが少なくなります。
            </p></li><li class="listitem"><p>
              数値データを使用している場合、多くの場合にテキストファイルにアクセスするより、ライブ接続を使用して、データベースから情報にアクセスする方が高速です。データベース内の情報はテキストファイルよりコンパクトなフォーマットで格納される可能性が高いため、それへのアクセスにかかわるディスクアクセスが少なくなります。また、テキストファイルを解析して、行とカラムの境界を見つけることを回避できるため、アプリケーションのコードも節約できます。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="optimize-character"></a>8.4.2.2 文字および文字列型の最適化</h4></div></div></div><a class="indexterm" name="idm139979113927600"></a><p>
          文字および文字列カラムの場合、次のガイドラインに従います。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              言語固有の照合機能が必要でない場合は、比較およびソート操作を速くするため、バイナリ照合順序を使用します。特定のクエリー内でバイナリ照合順序を使用するには、<a class="link" href="globalization.html#charset-binary-op" title="10.1.7.7 BINARY 演算子">BINARY</a> 演算子を使用できます。
            </p></li><li class="listitem"><p>
              さまざまなカラムの値を比較する場合、可能なかぎり、それらのカラムを同じ文字セットと照合順序で宣言し、クエリー実行中の文字列変換を避けます。
            </p></li><li class="listitem"><p>
              サイズが 8K バイト未満のカラム値では、<code class="literal">BLOB</code> の代わりにバイナリ <code class="literal">VARCHAR</code> を使用します。<code class="literal">GROUP BY</code> および <code class="literal">ORDER BY</code> 句は一時テーブルを生成する可能性があり、これらの一時テーブルでは、元のテーブルに <code class="literal">BLOB</code> カラムが含まれない場合に、<code class="literal">MEMORY</code> ストレージエンジンを使用することがあります。
            </p></li><li class="listitem"><p>
              テーブルに名前や住所などの文字列カラムが含まれるが、多くのクエリーでそれらのカラムを取得しない場合、文字列カラムを個別のテーブルに分割し、必要に応じて、外部キーで結合クエリーを使用することを考慮します。MySQL で行から何らかの値を取得する場合、その行 (およびおそらくその他の隣接する行) のすべてのカラムを含むデータブロックを読み取ります。もっとも頻繁に使用するカラムのみで、各行を小さくすることで、より多くの行を各データブロックに収めることができます。そのようなコンパクトなテーブルは、一般的なクエリーのディスク I/O やメモリーの使用量を削減します。
            </p></li><li class="listitem"><p>
              <code class="literal">InnoDB</code> テーブルで主キーとして、ランダムに生成された値を使用する場合、可能であれば、現在の日時などの降順の値でプリフィクスを付けます。連続したプライマリ値が、相互に物理的に近くに保存されていれば、<code class="literal">InnoDB</code> はそれらを高速に挿入し、取得できます。
            </p></li><li class="listitem"><p>
              数値カラムの方が通常同等の文字列カラムより推奨される理由については、<a class="xref" href="optimization.html#optimize-numeric" title="8.4.2.1 数値データの最適化">セクション8.4.2.1「数値データの最適化」</a>を参照してください。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="optimize-blob"></a>8.4.2.3 BLOB 型の最適化</h4></div></div></div><a class="indexterm" name="idm139979113906688"></a><p></p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              テキストデータを格納する大きな BLOB を保存する場合、まずそれを圧縮することを考慮します。テーブル全体が <code class="literal">InnoDB</code> または <code class="literal">MyISAM</code> によって圧縮されている場合は、この技法を使用しないでください。
            </p></li><li class="listitem"><p>
              複数のカラムのあるテーブルで、BLOB カラムを使用しないクエリーのメモリー要件を削減するには、BLOB カラムを個別のテーブルに分割し、必要に応じて、結合クエリーでそれを参照することを考慮します。
            </p></li><li class="listitem"><p>
              BLOB 値を取得し、表示するためのパフォーマンス要件は、ほかのデータ型と大きく異なることがあるため、BLOB 固有テーブルを別のストレージデバイスまたは個別のデータベースインスタンスに置くことができます。たとえば、BLOB を取得するには、大量の順次ディスク読み取りが必要で、<a class="link" href="glossary.html#glos_ssd" title="SSD">SSD デバイス</a>より、従来のハードドライブの方が適しています。
            </p></li><li class="listitem"><p>
              バイナリ <code class="literal">VARCHAR</code> カラムの方が同等の BLOB カラムより推奨されることがある理由については、<a class="xref" href="optimization.html#optimize-character" title="8.4.2.2 文字および文字列型の最適化">セクション8.4.2.2「文字および文字列型の最適化」</a>を参照してください。
            </p></li><li class="listitem"><p>
              きわめて長いテキスト文字列に対して、同等性をテストする代わりに、個別のカラムにカラムのハッシュを格納し、そのカラムにインデックスを設定して、クエリー内のハッシュ値をテストします。(<code class="literal">MD5()</code> または <code class="literal">CRC32()</code> 関数を使用して、ハッシュ値を生成します。)ハッシュ関数は、異なる入力で重複した結果を生成することがあるため、引き続きクエリーに句 <code class="literal">AND <em class="replaceable"><code>blob_column</code></em> = <em class="replaceable"><code>long_string_value</code></em></code> を含めて、誤った一致に対して保護します。パフォーマンスは、ハッシュ値の小さく、簡単にスキャンされるインデックスからメリットが得られます。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="procedure-analyse"></a>8.4.2.4 PROCEDURE ANALYSE の使用</h4></div></div></div><p>
          <code class="literal">ANALYSE([<em class="replaceable"><code>max_elements</code></em>[,<em class="replaceable"><code>max_memory</code></em>]])</code>
        </p><a class="indexterm" name="idm139979113882960"></a><a class="indexterm" name="idm139979113881616"></a><p>
          <code class="literal">ANALYSE()</code> はクエリーからの結果を調査し、テーブルサイズの削減に役立つ可能性がある各カラムの最適なデータ型を提案する結果の分析を返します。この分析を取得するには、<code class="literal">SELECT</code> ステートメントの末尾に <code class="literal">PROCEDURE ANALYSE</code> を追加します。
        </p><pre class="programlisting">
SELECT ... FROM ... WHERE ... PROCEDURE ANALYSE([<em class="replaceable"><code>max_elements</code></em>,[<em class="replaceable"><code>max_memory</code></em>]])
</pre><p>
          例:
        </p><pre class="programlisting">
SELECT col1, col2 FROM table1 PROCEDURE ANALYSE(10, 2000);
</pre><p>
          結果には、クエリーによって返された値のいくつかの統計が表示され、カラムの最適なデータ型が提案されます。これは、既存のテーブルのチェックや新しいデータのインポート後に役立つことがあります。<code class="literal">ENUM</code> データ型が適切でない場合に、<code class="literal">PROCEDURE ANALYSE()</code> がそれを提案しないように、引数の異なる設定を試してみる必要がある場合があります。
        </p><p>
          引数はオプションで次のように使用します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <em class="replaceable"><code>max_elements</code></em> (デフォルト 256) は、<code class="literal">ANALYSE()</code> がカラムあたりに認識する個々の値の最大数です。これは、<code class="literal">ANALYSE()</code> によって、最適なデータ型が型 <code class="literal">ENUM</code> であるかどうかをチェックするために使用されます。<em class="replaceable"><code>max_elements</code></em> 個を超える個別の値がある場合、<code class="literal">ENUM</code> は提案される型ではありません。
            </p></li><li class="listitem"><p>
              <em class="replaceable"><code>max_memory</code></em> (デフォルト 8192) は <code class="literal">ANALYSE()</code> がすべての個別の値を見つけようとする間に、カラムごとに割り当てるべき最大メモリー量です。
            </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="optimize-multi-tables"></a>8.4.3 多数のテーブルの最適化</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#table-cache">8.4.3.1 MySQL でのテーブルのオープンとクローズの方法</a></span></dt><dt><span class="section"><a href="optimization.html#creating-many-tables">8.4.3.2 同じデータベースに大量のテーブルを作成することの短所</a></span></dt></dl></div><a class="indexterm" name="idm139979113859584"></a><p>
        各クエリーを高速にするいくつかの技法には、多数のテーブルへのデータの分割が含まれます。テーブルの数が数千または数百万にもなる場合、これらすべてのテーブルの処理のオーバーヘッドは新たなパフォーマンスの考慮事項になります。
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="table-cache"></a>8.4.3.1 MySQL でのテーブルのオープンとクローズの方法</h4></div></div></div><a class="indexterm" name="idm139979113855360"></a><a class="indexterm" name="idm139979113854048"></a><a class="indexterm" name="idm139979113851904"></a><a class="indexterm" name="idm139979113849872"></a><a class="indexterm" name="idm139979113847840"></a><a class="indexterm" name="idm139979113845808"></a><a class="indexterm" name="idm139979113844432"></a><a class="indexterm" name="idm139979113842400"></a><p>
          <span class="command"><strong>mysqladmin status</strong></span> コマンドを実行すると、次のように表示されるはずです。
        </p><pre class="programlisting">
Uptime: 426 Running threads: 1 Questions: 11082
Reloads: 1 Open tables: 12
</pre><p>
          テーブルが 6 つしかない場合に、12 の <code class="literal">Open tables</code> 値はいくぶん不可解に思うことがあります。
        </p><p>
          MySQL はマルチスレッド対応であるため、特定のテーブルに対して多くのクライアントが同時にクエリーを発行している場合があります。同じテーブルに対して、複数のクライアントセッションが異なる状態を持つ問題を最小にするため、テーブルは各同時セッションに独立して開かれます。これは追加メモリーを使用しますが、一般にパフォーマンスは向上します。<code class="literal">MyISAM</code> テーブルでは、テーブルを開いているクライアントごとに、データファイルに 1 つの追加のファイルディスクリプタが必要になります。(対照的に、インデックスファイルディスクリプタはすべてのセッションで共有されます。)
        </p><p>
          <code class="literal">table_open_cache</code> および <code class="literal">max_connections</code> システム変数は、サーバーが開いたままにするファイルの最大数に影響します。これらの値のいずれかまたは両方を増やすと、オープンファイルディスクリプタのプロセスあたりの数に関して、オペレーティングシステムによって適用されている制限に達する可能性があります。多くのオペレーティングシステムでは、オープンファイル制限を増やすことができますが、方法はシステムによって大きく異なります。制限値を増やすことができるかどうか、およびその実行方法については、使用するオペレーティングシステムのドキュメントを参照してください。
        </p><p>
          <code class="literal">table_open_cache</code> は <code class="literal">max_connections</code> に関連します。たとえば、200 の同時実行接続の場合、少なくとも <code class="literal">200 * <em class="replaceable"><code>N</code></em></code> のテーブルキャッシュサイズを指定します。ここで <em class="replaceable"><code>N</code></em> は実行するクエリーの結合あたりのテーブルの最大数です。また、一時テーブルとファイル用のいくつかの追加のファイルディスクリプタを予約する必要もあります。
        </p><p>
          オペレーティングシステムで、<code class="literal">table_open_cache</code> の設定に示されたオープンファイルディスクリプタの数を処理できることを確認してください。<code class="literal">table_open_cache</code> の設定が大きすぎると、MySQL がファイルディスクリプタを使い果たして接続を拒否し、クエリーの実行に失敗して、信頼性が大幅に低下します。また、<code class="literal">MyISAM</code> ストレージエンジンでは一意のオープンテーブルごとに 2 つのファイルディスクリプタが必要であることも考慮に入れる必要があります。<span class="command"><strong>mysqld</strong></span> に <code class="option">--open-files-limit</code> スタートアップオプションを使用すると、MySQL で使用可能なファイルディスクリプタの数を増やすことができます。<a class="xref" href="error-handling.html#not-enough-file-handles" title="B.5.2.18 'File' が見つかりません、および同様のエラー">セクションB.5.2.18「'File' が見つかりません、および同様のエラー」</a>を参照してください。
        </p><p>
          オープンテーブルのキャッシュは、<code class="literal">table_open_cache</code> エントリのレベルで保持されます。サーバーはスタートアップ時にキャッシュサイズを自動サイズ設定します。サイズを明示的に設定するには、スタートアップ時に <code class="literal">table_open_cache</code> システム変数を設定します。MySQL は、クエリーを実行するために、一時的にこれより多くのテーブルを開くことがあります。
        </p><p>
          次の状況では、MySQL は未使用のテーブルを閉じ、それをテーブルキャッシュから削除します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              キャッシュがいっぱいで、スレッドがキャッシュにないテーブルを開こうとした場合。
            </p></li><li class="listitem"><p>
              キャッシュに <code class="literal">table_open_cache</code> を超えるエントリがあり、キャッシュ内のテーブルがどのスレッドによっても使用されなくなった場合。
            </p></li><li class="listitem"><p>
              テーブルフラッシュ操作が行われた場合。これは、だれかが <code class="literal">FLUSH TABLES</code> ステートメントを発行するか、または <span class="command"><strong>mysqladmin flush-tables</strong></span> または <span class="command"><strong>mysqladmin refresh</strong></span> コマンドを実行した場合に行われます。
            </p></li></ul></div><p>
          テーブルキャッシュがいっぱいになると、サーバーは次の手順に従って使用するキャッシュエントリを見つけます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              現在使用中でないテーブルは、もっとも長く使用されていないテーブルから、解放されます。
            </p></li><li class="listitem"><p>
              新しいテーブルを開く必要があるが、キャッシュがいっぱいで、解放できるテーブルがない場合、必要に応じてキャッシュが一時的に拡張されます。キャッシュが一時的に拡張された状況で、テーブルが使用中から未使用状態になったときは、そのテーブルが閉じられ、キャッシュから解放されます。
            </p></li></ul></div><p>
          <code class="literal">MyISAM</code> テーブルは同時アクセスごとに開かれます。つまり、2 つのスレッドで同じテーブルにアクセスする場合、または 1 つのスレッドが同一クエリーでテーブルに 2 回アクセスする場合 (テーブルをそれ自体に結合することによってなど) は、テーブルを 2 回開く必要があることを意味します。同時オープンは、それぞれテーブルキャッシュにエントリが必要になります。いずれかの <code class="literal">MyISAM</code> テーブルを最初に開くと、データファイルに 1 つとインデックスファイルに 1 つの 2 つのファイルディスクリプタが必要になります。テーブルの追加の使用では、それぞれデータファイルに 1 つだけのファイルディスクリプタが必要です。インデックスファイルディスクリプタはすべてのスレッドで共有されます。
        </p><p>
          <code class="literal">HANDLER <em class="replaceable"><code>tbl_name</code></em> OPEN</code> ステートメントを使用してテーブルを開く場合、専用のテーブルオブジェクトがスレッドに割り当てられます。このテーブルオブジェクトはほかのスレッドと共有されず、スレッドが <code class="literal">HANDLER <em class="replaceable"><code>tbl_name</code></em> CLOSE</code> を呼び出すか、スレッドが終了するまでクローズされません。これが発生すると、テーブルがテーブルキャッシュに戻されます (キャッシュがいっぱいでない場合)。<a class="xref" href="sql-syntax.html#handler" title="13.2.4 HANDLER 構文">セクション13.2.4「HANDLER 構文」</a>を参照してください。
        </p><p>
          テーブルキャッシュが小さすぎるかどうかは、<span class="command"><strong>mysqld</strong></span> のステータス変数 <code class="literal">Opened_tables</code> をチェックして判断できます。これは、サーバーの起動以降のテーブルを開く操作の数を示します。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW GLOBAL STATUS LIKE 'Opened_tables';</code></strong>
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| Opened_tables | 2741  |
+---------------+-------+
</pre><p>
          多くの <code class="literal">FLUSH TABLES</code> ステートメントを発行していない場合でも、値がきわめて大きいか、急増した場合、テーブルキャッシュサイズを増やします。<a class="xref" href="server-administration.html#server-system-variables" title="5.1.4 サーバーシステム変数">セクション5.1.4「サーバーシステム変数」</a>および<a class="xref" href="server-administration.html#server-status-variables" title="5.1.6 サーバーステータス変数">セクション5.1.6「サーバーステータス変数」</a>を参照してください。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="creating-many-tables"></a>8.4.3.2 同じデータベースに大量のテーブルを作成することの短所</h4></div></div></div><a class="indexterm" name="idm139979113787936"></a><p>
          同じデータベースディレクトリに多数の <code class="literal">MyISAM</code> テーブルがある場合、オープン、クローズ、および作成操作が遅くなります。多数のテーブルに対して <code class="literal">SELECT</code> ステートメントを実行した場合、開く必要があるテーブルごとに、別のテーブルを閉じる必要があるため、テーブルキャッシュがいっぱいの場合にオーバーヘッドが少し発生します。テーブルキャッシュで許可されるエントリ数を増やすことによって、このオーバーヘッドを減らすことができます。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="internal-temporary-tables"></a>8.4.4 MySQL が内部一時テーブルを使用する仕組み</h3></div></div></div><a class="indexterm" name="idm139979113781296"></a><p>
        場合により、サーバーはクエリーの処理中に内部一時テーブルを作成します。それらのテーブルは、メモリー内に保持して、<code class="literal">MEMORY</code> ストレージエンジンによって処理したり、ディスク上に格納して、<code class="literal">MyISAM</code> ストレージエンジンによって処理したりできます。サーバーは最初にインメモリーテーブルとして内部で一時テーブルを作成し、それが大きくなりすぎた場合に、それをディスク上テーブルに変換することがあります。サーバーが内部一時テーブルを作成するタイミングや、サーバーがそれを管理するためにどのストレージエンジンを使用するかに関して、ユーザーは直接制御できません。
      </p><p>
        一時テーブルは、次のような条件で作成される可能性があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">UNION</code> クエリーが一時テーブルを使用します。
          </p></li><li class="listitem"><p>
            <code class="literal">TEMPTABLE</code> アルゴリズムを使用して評価されるものや、<code class="literal">UNION</code> またはアグリゲーションを使用するものなど、一部のビューで一時テーブルを必要とします。
          </p></li><li class="listitem"><p>
            <code class="literal">ORDER BY</code> 句と別の <code class="literal">GROUP BY</code> 句がある場合、または、<code class="literal">ORDER BY</code> または <code class="literal">GROUP BY</code> に結合キュー内の最初のテーブルと異なるテーブルのカラムが含まれている場合は、一時テーブルが作成されます。
          </p></li><li class="listitem"><p>
            <code class="literal">DISTINCT</code> と <code class="literal">ORDER BY</code> の組み合わせで、一時テーブルが必要になることがあります。
          </p></li><li class="listitem"><p>
            <code class="literal">SQL_SMALL_RESULT</code> オプションを使用すると、MySQL では、クエリーにディスク上ストレージを必要とする要素 (後述) も含まれていないかぎり、インメモリー一時テーブルが使用されます。
          </p></li><li class="listitem"><p>
            複数テーブル <code class="literal">UPDATE</code> ステートメント。
          </p></li><li class="listitem"><p>
            <code class="literal">GROUP_CONCAT()</code> または <code class="literal">COUNT(DISTINCT)</code> 評価。
          </p></li><li class="listitem"><p>
            派生テーブル (<code class="literal">FROM</code> 句内のサブクエリー)。
          </p></li><li class="listitem"><p>
            サブクエリーまたは準結合実体化のために作成されるテーブル。
          </p></li></ul></div><p>
        クエリーで一時テーブルを必要とするかどうかを判断するには、<code class="literal">EXPLAIN</code> を使用し、<code class="literal">Extra</code> カラムをチェックして、そこに <code class="literal">Using temporary</code> と示されているかどうかを確認します (<a class="xref" href="optimization.html#using-explain" title="8.8.1 EXPLAIN によるクエリーの最適化">セクション8.8.1「EXPLAIN によるクエリーの最適化」</a>を参照してください)。<code class="literal">EXPLAIN</code> では、派生されるか、実体化された一時テーブルに対して、必ずしも <code class="literal">Using temporary</code> と表示しないことがあります。
      </p><p>
        内部一時テーブルが最初にインメモリーテーブルとして作成されたが、これが大きくなりすぎた場合、MySQL はこれを自動的にディスク上のテーブルに変換します。インメモリー一時テーブルの最大サイズは、<code class="literal">tmp_table_size</code> と <code class="literal">max_heap_table_size</code> の最小値です。これは、<code class="literal">CREATE TABLE</code> によって明示的に作成された <code class="literal">MEMORY</code> テーブルと異なります。そのようなテーブルの場合、<code class="literal">max_heap_table_size</code> システム変数でのみ、テーブルがどのくらい拡大でき、ディスク上フォーマットへの変換がないことが判断されます。
      </p><p>
        サーバーは内部一時テーブル (メモリー内またはディスク上のいずれか) を作成すると、<code class="literal">Created_tmp_tables</code> ステータス変数を増分します。サーバーはディスク上にテーブルを作成する (内部で、またはインメモリーテーブルを変換して) 場合、<code class="literal">Created_tmp_disk_tables</code> ステータス変数を増分します。
      </p><p>
        状況によっては、インメモリー一時テーブルの使用が妨げられる場合があり、その場合サーバーは代わりにディスク上テーブルを使用します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            テーブル内の <code class="literal">BLOB</code> または <code class="literal">TEXT</code> カラムの存在
          </p></li><li class="listitem"><p>
            <code class="literal">GROUP BY</code> または <code class="literal">DISTINCT</code> 句内の、バイナリ文字列の場合に 512 バイトまたは非バイナリ文字列の場合に 512 文字より大きい文字列カラムの存在。(MySQL 5.6.15 より前のこの制限は、文字列の型に関係なく 512 バイトです。)
          </p></li><li class="listitem"><p>
            <code class="literal">UNION</code> または <code class="literal">UNION ALL</code> が使用された場合に、<code class="literal">SELECT</code> リスト内の 512 (バイナリ文字列の場合はバイト数、非バイナリ文字列の場合は文字数) より大きい最大長を持つ文字列カラムの存在。
          </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="optimizing-innodb"></a>8.5 InnoDB テーブルの最適化</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#optimizing-innodb-storage-layout">8.5.1 InnoDB テーブルのストレージレイアウトの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-transaction-management">8.5.2 InnoDB トランザクション管理の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-logging">8.5.3 InnoDB ロギングの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-bulk-data-loading">8.5.4 InnoDB テーブルの一括データロード</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-queries">8.5.5 InnoDB クエリーの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-ddl-operations">8.5.6 InnoDB DDL 操作の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-diskio">8.5.7 InnoDB ディスク I/O の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-configuration-variables">8.5.8 InnoDB 構成変数の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-innodb-many-tables">8.5.9 多くのテーブルのあるシステムに対する InnoDB の最適化</a></span></dt></dl></div><a class="indexterm" name="idm139979113727376"></a><a class="indexterm" name="idm139979113724512"></a><p>
      <code class="literal">InnoDB</code> は、MySQL のお客様が一般に、信頼性と並列性が重要である本番環境のデータベースで使用するストレージエンジンです。<code class="literal">InnoDB</code> は MySQL 5.5 以上のデフォルトのストレージエンジンであるため、以前より頻繁に <code class="literal">InnoDB</code> テーブルを目にすることが予想されます。このセクションでは、<code class="literal">InnoDB</code> テーブルに対するデータベース操作を最適化する方法について説明します。
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="optimizing-innodb-storage-layout"></a>8.5.1 InnoDB テーブルのストレージレイアウトの最適化</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            データが安定したサイズに達するか、拡大しているテーブルが数十または数百メガバイト単位で増大した場合、<code class="literal">OPTIMIZE TABLE</code> ステートメントを使用して、テーブルを再編成し、無駄なスペースを圧縮することを考慮します。再編成されたテーブルでは、フルテーブルスキャンを実行するために必要なディスク I/O が減ります。これは、インデックスの使用の改善やアプリケーションコードのチューニングなどのほかの技法が現実的でない場合に、パフォーマンスを向上できる直接的な技法です。
          </p><p>
            <code class="literal">OPTIMIZE TABLE</code> はテーブルのデータ部分をコピーし、インデックスを再構築します。インデックス内へのデータのパックの改善とテーブルスペース内およびディスク上の断片化の削減からメリットが得られます。このメリットは各テーブル内のデータによって異なります。利点が大きいものとそうでないものがあること、またはテーブルの次回の最適化まで、時間の経過とともに利点が減っていくことに気付く場合があります。この操作は、テーブルが大きい場合や再構築されるインデックスがバッファープールに収まらない場合に、遅くなることがあります。大量のデータをテーブルに追加したあとの最初の実行では、多くの場合にその後の実行よりかなり遅くなります。
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> では、長い <code class="literal">PRIMARY KEY</code> (長い値を持つ単一カラムまたは長い複合値を形成する複数のカラムのいずれか) があると、大量のディスク領域を無駄にします。行の主キー値は、同じ行を指すすべてのセカンダリインデックスレコードに複製されます。(<a class="xref" href="innodb-storage-engine.html#innodb-table-and-index" title="14.2.13 InnoDB テーブルおよびインデックスの構造">セクション14.2.13「InnoDB テーブルおよびインデックスの構造」</a>を参照してください。)主キーが長い場合、<code class="literal">AUTO_INCREMENT</code> カラムを主キーとして作成するか、カラム全体ではなく、長い <code class="literal">VARCHAR</code> カラムのプリフィクスをインデックス設定します。
          </p></li><li class="listitem"><p>
            可変長の文字列を格納するために、または多くの <code class="literal">NULL</code> 値を持つカラムに対して、<code class="literal">CHAR</code> の代わりに <code class="literal">VARCHAR</code> データ型を使用します。<code class="literal">CHAR(<em class="replaceable"><code>N</code></em>)</code> カラムは、文字列が短いか、その値が <code class="literal">NULL</code> だとしても、データを格納するために常に <em class="replaceable"><code>N</code></em> 文字を必要とします。テーブルが小さいほどバッファープールに収まりやすく、ディスク I/O が減ります。
          </p><p>
            <code class="literal">COMPACT</code> 行フォーマット (MySQL 5.6 でのデフォルトの <code class="literal">InnoDB</code> フォーマット) と <code class="literal">utf8</code> や <code class="literal">sjis</code> などの可変長文字セットを使用する場合、<code class="literal">CHAR(<em class="replaceable"><code>N</code></em>)</code> カラムは可変量でも、やはり <em class="replaceable"><code>N</code></em> バイト以上の領域を占有します。
          </p></li><li class="listitem"><p>
            大きいか、繰り返しの多い大量のテキストや数値データを格納するテーブルでは、<code class="literal">COMPRESSED</code> 行フォーマットを使用することを考慮します。データをバッファープールに入れたり、フルテーブルスキャンを実行したりするために必要なディスク I/O が減ります。永続的な決断を下す前に、<code class="literal">COMPRESSED</code> と <code class="literal">COMPACT</code> の行フォーマットを使用して達成できる圧縮の量を測定してください。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="optimizing-innodb-transaction-management"></a>8.5.2 InnoDB トランザクション管理の最適化</h3></div></div></div><p>
        <code class="literal">InnoDB</code> トランザクション処理を最適化するには、トランザクション機能のパフォーマンスオーバーヘッドとサーバーのワークロードの理想的なバランスを見つけます。たとえば、アプリケーションで、秒あたり数千回コミットする場合にパフォーマンスの問題が発生し、2、3 時間に 1 回だけコミットする場合に別のパフォーマンスの問題が発生することがあります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            デフォルトの MySQL 設定 <code class="literal">AUTOCOMMIT=1</code> は、ビジーなデータベースサーバーにパフォーマンスの制限を課すことがあります。現実的であれば、<code class="literal">SET AUTOCOMMIT=0</code> または <code class="literal">START TRANSACTION</code> ステートメントを発行し、すべての変更を行なったあとに、<code class="literal">COMMIT</code> ステートメントを発行することで、複数の関連 DML 操作を単一のトランザクションにまとめます。
          </p><p>
            <code class="literal">InnoDB</code> は、トランザクションによってデータベースが変更された場合、そのトランザクションのコミットのたびにディスクにログをフラッシュする必要があります。変更のたびにあとでコミットされる場合 (デフォルトの自動コミット設定のように)、ストレージデバイスの I/O スループットによって、秒あたりに可能な操作数が制限されます。
          </p></li><li class="listitem"><p>
            または、単一の <code class="literal">SELECT</code> ステートメントのみから構成されるトランザクションの場合、<code class="literal">AUTOCOMMIT</code> をオンにすると、<code class="literal">InnoDB</code> が読み取り専用トランザクションを認識し、それらを最適化するのに役立ちます。要件については、<a class="xref" href="innodb-storage-engine.html#innodb-performance-ro-txn" title="14.13.14 InnoDB の読み取り専用トランザクションの最適化">セクション14.13.14「InnoDB の読み取り専用トランザクションの最適化」</a>を参照してください。
          </p></li><li class="listitem"><p>
            大量の行の挿入、更新、または削除後のロールバックの実行は避けます。大きなトランザクションによってサーバーのパフォーマンスが低下する場合、それをロールバックすると、問題が悪化し、元の DML 操作の数倍の実行時間がかかる可能性があります。ロールバックはサーバーの起動時に再度開始されるため、データベースプロセスを強制終了しても役立ちません。
          </p><p>
            この問題の発生の可能性を最小にするには: すべての DML の変更をただちにディスクに書き込むのではなく、キャッシュできるように、<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>のサイズを増やします。挿入に加えて、更新および削除操作がバッファリングされるように、<code class="literal">innodb_change_buffering=all</code> を設定します。大きな DML 操作中に、<code class="literal">COMMIT</code> ステートメントを定期的に発行し、可能であれば単一の削除または更新を少数の行に対して操作する複数のステートメントに分割することを考慮します。
          </p><p>
            ロールバックの暴走が発生した場合にそれを解消するには、ロールバックが CPU に依存して高速に実行するように、バッファープールを増加するか、<a class="xref" href="innodb-storage-engine.html#innodb-recovery" title="14.16.1 InnoDB のリカバリプロセス">セクション14.16.1「InnoDB のリカバリプロセス」</a>に説明するように、サーバーを強制終了し、<code class="literal">innodb_force_recovery=3</code> で再起動します。
          </p><p>
            この問題は、MySQL 5.5 以上または InnoDB プラグイン付きの MySQL 5.1 では、あまり目立たなくなっていると予想されます。デフォルトの設定 <code class="literal">innodb_change_buffering=all</code> により、更新および削除操作がメモリー内にキャッシュされ、それらがそもそも高速に実行されるようになり、必要な場合にロールバックも高速になったためです。多くの挿入、更新、または削除を伴う長時間実行トランザクションを処理するサーバーでこのパラメータ設定を使うようにしてください。
          </p></li><li class="listitem"><p>
            クラッシュが発生した場合に、最新のコミットされたトランザクションの一部の損失を許容できる場合は、<code class="literal">innodb_flush_log_at_trx_commit</code> パラメータを 0 に設定できます。フラッシュが保証されていなくても、<code class="literal">InnoDB</code> はとにかく 1 秒に 1 回ログをフラッシュしようとします。さらに、<code class="literal">innodb_support_xa</code> の値を 0 に設定し、これにより、ディスク上データとバイナリログの同期によるディスクフラッシュの数を減らします。
          </p></li><li class="listitem"><p>
            行が変更されるか削除される場合、行と関連付けられた<a class="link" href="glossary.html#glos_undo_log" title="Undo ログ">Undo ログ</a>はただちに、またはトランザクションのコミットの直後でも、物理的に削除されません。以前または同時に開始したトランザクションが終了するまで古いデータは保持されるため、それらのトランザクションは変更または削除された行の以前の状態にアクセスできます。そのため、長時間実行トランザクションは、<code class="literal">InnoDB</code> が別のトランザクションによって変更されたデータをパージすることを妨げることがあります。
          </p></li><li class="listitem"><p>
            長時間実行トランザクション内で行が変更されるか、削除された場合、<code class="literal">READ COMMITTED</code> および <code class="literal">REPEATABLE READ</code> 分離レベルを使用するほかのトランザクションは、古いデータを再構築するために、それらの同じ行を読み取る場合、多くの作業を実行する必要があります。
          </p></li><li class="listitem"><p>
            長時間実行トランザクションでテーブルが変更された場合、ほかのトランザクションからのそのテーブルに対するクエリーは、<a class="link" href="glossary.html#glos_covering_index" title="カバリングインデックス">カバリングインデックス</a>技法を利用しません。通常、セカンダリインデックスからすべての結果カラムを取得できるクエリーは、代わりにテーブルデータから該当する値をルックアップします。
          </p><p>
            セカンダリインデックスページに、新しすぎる <code class="literal">PAGE_MAX_TRX_ID</code> があることが検出された場合、またはセカンダリインデックス内のレコードに削除がマークされている場合、<code class="literal">InnoDB</code> はクラスタ化されたインデックスを使用してレコードをルックアップする必要がある可能性があります。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="optimizing-innodb-logging"></a>8.5.3 InnoDB ロギングの最適化</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            バッファープールと同じくらいの大きさまでログファイルを大きくします。<code class="literal">InnoDB</code> がログファイルにいっぱいまで書き込んだ場合、チェックポイントでバッファープールの変更された内容をディスクに書き込む必要があります。小さいログファイルは多くの不必要なディスク書き込みを発生させます。従来、大きなログファイルは長いリカバリ時間の原因になっていましたが、現在リカバリは大幅に速くなったため、確信を持って大きなログファイルを使うことができます。
          </p></li><li class="listitem"><p>
            ログバッファーのサイズも十分に大きく (約 8M バイト) してください。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="optimizing-innodb-bulk-data-loading"></a>8.5.4 InnoDB テーブルの一括データロード</h3></div></div></div><a class="indexterm" name="idm139979113642400"></a><p>
        これらのパフォーマンスのヒントは、<a class="xref" href="optimization.html#insert-speed" title="8.2.2.1 INSERT ステートメントの速度">セクション8.2.2.1「INSERT ステートメントの速度」</a>の高速挿入の一般的なガイドラインを補足するものです。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">InnoDB</code> にデータをインポートする場合、自動コミットモードでは挿入のたびに、ディスクへのログのフラッシュを実行するため、それをオフにします。インポート操作時に自動コミットを無効にするには、それを、<code class="literal">SET autocommit</code> ステートメントと <code class="literal">COMMIT</code> ステートメントで囲みます。
          </p><pre class="programlisting">
SET autocommit=0;
<em class="replaceable"><code>... SQL import statements ...</code></em>
COMMIT;
</pre><p>
            <span class="command"><strong>mysqldump</strong></span> オプション <code class="option">--opt</code> は、それらを <code class="literal">SET autocommit</code> ステートメントと <code class="literal">COMMIT</code> ステートメントで囲まなくても、<code class="literal">InnoDB</code> テーブルに高速にインポートするダンプファイルを作成します。
          </p></li><li class="listitem"><p>
            副キーに <code class="literal">UNIQUE</code> 制約がある場合、インポートセッション中に一意性チェックを一時的にオフにすることで、テーブルインポートを高速化できます。
          </p><pre class="programlisting">
SET unique_checks=0;
<em class="replaceable"><code>... SQL import statements ...</code></em>
SET unique_checks=1;
</pre><p>
            大きいテーブルの場合、<code class="literal">InnoDB</code> はその挿入バッファーを使用して、セカンダリインデックスレコードを一括して書き込むことができるため、これにより、大量のディスク I/O が節約されます。データに重複キーが含まれていないことを確認してください。
          </p></li><li class="listitem"><p>
            テーブルに <code class="literal">FOREIGN KEY</code> 制約がある場合、インポートセッションの間の外部キーチェックをオフにすることで、テーブルインポートを高速化できます。
          </p><pre class="programlisting">
SET foreign_key_checks=0;
<em class="replaceable"><code>... SQL import statements ...</code></em>
SET foreign_key_checks=1;
</pre><p>
            大きいテーブルの場合、これにより、大量のディスク I/O を節約できます。
          </p></li><li class="listitem"><p>
            多くの行を挿入する必要がある場合、複数行 <code class="literal">INSERT</code> 構文を使用して、クライアントとサーバー間の通信オーバーヘッドを軽減します。
          </p><pre class="programlisting">
INSERT INTO yourtable VALUES (1,2), (5,5), ...;
</pre><p>
            このヒントは、<code class="literal">InnoDB</code> テーブルだけではなく、任意のテーブルへの挿入に有効です。
          </p></li><li class="listitem"><p>
            自動インクリメントカラムのあるテーブルへの一括挿入を実行する場合、<code class="literal">innodb_autoinc_lock_mode</code> をデフォルト値の 1 の代わりに 2 に設定します。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-auto-increment-configurable" title="14.6.5.2 構成可能な InnoDB の自動インクリメントロック">セクション14.6.5.2「構成可能な InnoDB の自動インクリメントロック」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> <code class="literal">FULLTEXT</code> インデックスにデータをロードする場合の最高のパフォーマンスのため、次の一連のステップに従います。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                テーブル作成時に、<code class="literal">FTS_DOC_ID_INDEX</code> という一意のインデックスで、型 <code class="literal">BIGINT UNSIGNED NOT NULL</code> のカラム <code class="literal">FTS_DOC_ID</code> を定義します。例:
              </p><pre class="programlisting">
CREATE TABLE t1 (
FTS_DOC_ID BIGINT unsigned NOT NULL AUTO_INCREMENT,
title varchar(255) NOT NULL DEFAULT ”,
text mediumtext NOT NULL,
PRIMARY KEY (`FTS_DOC_ID`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
CREATE UNIQUE INDEX FTS_DOC_ID_INDEX on t1(FTS_DOC_ID);
              </pre></li><li class="listitem"><p>
                テーブルにデータをロードします。
              </p></li><li class="listitem"><p>
                データがロードされたら、<code class="literal">FULLTEXT</code> インデックスを作成します。
              </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              テーブル作成時に <code class="literal">FTS_DOC_ID</code> カラムを追加する場合、<code class="literal">FTS_DOC_ID</code> は各 <code class="literal">INSERT</code> または <code class="literal">UPDATE</code> によって単調に増分される必要があるため、<code class="literal">FULLTEXT</code> インデックス設定されたカラムが更新されたときに、<code class="literal">FTS_DOC_ID</code> カラムが更新されることを確認します。テーブル作成時に <code class="literal">FTS_DOC_ID</code> を追加せず、<code class="literal">InnoDB</code> に自動的に DOC ID を管理させるようにした場合、<code class="literal">InnoDB</code> は次の <code class="literal">CREATE FULLTEXT INDEX</code> 呼び出しで、<code class="literal">FTS_DOC_ID</code> を非表示カラムとして追加します。ただし、このアプローチでは、パフォーマンスに影響するテーブルの再構築が必要になります。
            </p></div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="optimizing-innodb-queries"></a>8.5.5 InnoDB クエリーの最適化</h3></div></div></div><p>
        <code class="literal">InnoDB</code> テーブルのクエリーをチューニングするには、各テーブルに適切なインデックスのセットを作成します。詳細は、<a class="xref" href="optimization.html#mysql-indexes" title="8.3.1 MySQL のインデックスの使用の仕組み">セクション8.3.1「MySQL のインデックスの使用の仕組み」</a>を参照してください。<code class="literal">InnoDB</code> インデックスに関する次のガイドラインに従います。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            各 <code class="literal">InnoDB</code> テーブルには<a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a> がある (それをリクエストするかしないかに関係なく) ため、もっとも重要で緊急を要するクエリーで使用されるカラムとして、テーブルごとに主キーカラムのセットを指定します。
          </p></li><li class="listitem"><p>
            主キーのカラム値は各セカンダリインデックスに複製されるため、あまり多く、長すぎるカラムを指定しないでください。インデックスに不要なデータが含まれていると、このデータを読み取る I/O とそれをキャッシュするメモリーによって、サーバーのパフォーマンスとスケーラビリティーが低下します。
          </p></li><li class="listitem"><p>
            各クエリーで使用できるインデックスは 1 つだけであるため、カラムごとに個別の<a class="link" href="glossary.html#glos_secondary_index" title="セカンダリインデックス">セカンダリインデックス</a>を作成しないでください。ほんの少数の異なる値を持ち、めったにテストされないカラムへのインデックスは、どのクエリーにも役立たない可能性があります。同じテーブルに対して多くのクエリーがあり、カラムのさまざまな組み合わせをテストする場合、多数の単一カラムインデックスよりも、少数の<a class="link" href="glossary.html#glos_concatenated_index" title="連結されたインデックス">連結されたインデックス</a>を作成してみてください。インデックスに結果セットに必要なすべてのカラムが含まれている (<a class="link" href="glossary.html#glos_covering_index" title="カバリングインデックス">カバリングインデックス</a>と呼ばれます) 場合、クエリーはテーブルデータをまったく読み取らなくても済む可能性があります。
          </p></li><li class="listitem"><p>
            インデックス設定されたカラムに <code class="literal">NULL</code> 値が含まれることがない場合は、テーブルの作成時に、それを <code class="literal">NOT NULL</code> として宣言します。オプティマイザは、各カラムに <code class="literal">NULL</code> 値が含まれているかどうかを知っていれば、クエリーに使用するためにもっとも効率的なインデックスをより適切に判断できます。
          </p></li><li class="listitem"><p>
            MySQL 5.6.4 以上では、<a class="xref" href="innodb-storage-engine.html#innodb-performance-ro-txn" title="14.13.14 InnoDB の読み取り専用トランザクションの最適化">セクション14.13.14「InnoDB の読み取り専用トランザクションの最適化」</a>の技法を使用して、<code class="literal">InnoDB</code> テーブルの単一クエリートランザクションを最適化できます。
          </p></li><li class="listitem"><p>
            頻繁に更新されないテーブルに対して、たびたび繰り返しのクエリーを行う場合、クエリーキャッシュを有効にします。
          </p><pre class="programlisting">
[mysqld]
query_cache_type = 1
query_cache_size = 10M
</pre></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="optimizing-innodb-ddl-operations"></a>8.5.6 InnoDB DDL 操作の最適化</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            テーブルとインデックスに対する DDL 操作 (<code class="literal">CREATE</code>、<code class="literal">ALTER</code>、および <code class="literal">DROP</code> ステートメント) で、<code class="literal">InnoDB</code> テーブルのもっとも重要な側面は、MySQL 5.5 以上でのセカンダリインデックスの作成と削除が MySQL 5.1 以前よりはるかに速くなっていることです。詳細は、<a class="ulink" href="http://dev.mysql.com/doc/refman/5.5/en/innodb-create-index.html" target="_top">InnoDB Fast Index Creation</a>を参照してください。
          </p></li><li class="listitem"><p>
            <span class="quote">「<span class="quote">高速のインデックス作成</span>」</span>により、特定の場合で、データをテーブルにロードする前にインデックスを削除し、次にデータのロード後にインデックスを再作成することが高速になります。
          </p></li><li class="listitem"><p>
            テーブルを空にするには <code class="literal">DELETE FROM <em class="replaceable"><code>tbl_name</code></em></code> ではなく、<code class="literal">TRUNCATE TABLE</code> を使用します。外部キー制約により、<code class="literal">TRUNCATE</code> ステートメントを通常の <code class="literal">DELETE</code> ステートメントのように動作させることができます。その場合、<code class="literal">DROP TABLE</code> や <code class="literal">CREATE TABLE</code> のようなコマンドのシーケンスがもっとも速くなる可能性があります。
          </p></li><li class="listitem"><p>
            主キーは、各 <code class="literal">InnoDB</code> テーブルのストレージレイアウトに不可欠であり、主キーの定義の変更には、テーブル全体の再編成が必要であるため、常に主キーを <code class="literal">CREATE TABLE</code> ステートメントの一部としてセットアップし、あとで主キーを <code class="literal">ALTER</code> または <code class="literal">DROP</code> する必要がないように、事前に計画してください。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="optimizing-innodb-diskio"></a>8.5.7 InnoDB ディスク I/O の最適化</h3></div></div></div><a class="indexterm" name="idm139979113547472"></a><p>
        データベース設計と SQL 操作のチューニング技法のベストプラクティスに従っても、データベースが大量のディスク I/O アクティビティーによってまだ遅い場合は、ディスク I/O に関するこれらの低レベル技法を調査してください。Unix <code class="filename">top</code> ツールまたは Windows タスクマネージャーに、ワークロードの CPU 使用率が 70% 未満であることが示されている場合、ワークロードはディスクに依存している可能性があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            テーブルデータを <code class="literal">InnoDB</code> バッファープールにキャッシュすると、ディスク I/O を必要とせずに、クエリーでそれを繰り返し処理できます。バッファープールサイズは、<code class="literal">innodb_buffer_pool_size</code> オプションで指定します。このメモリー領域はきわめて重要であるため、ビジーなデータベースでは多くの場合、サイズを物理メモリーの量の約 80% に指定します。詳細については、<a class="xref" href="optimization.html#innodb-buffer-pool" title="8.9.1 InnoDB バッファープール">セクション8.9.1「InnoDB バッファープール」</a>を参照してください。
          </p></li><li class="listitem"><p>
            GNU/Linux および Unix の一部のバージョンでは、Unix <code class="literal">fsync()</code> 呼び出し (これは <code class="literal">InnoDB</code> がデフォルトで使用します) および類似のメソッドによるファイルのディスクへのフラッシュが驚くほど低速です。データベースの書き込みパフォーマンスが問題である場合、<code class="literal">innodb_flush_method</code> パラメータを <code class="literal">O_DSYNC</code> に設定してベンチマークを実行します。
          </p></li><li class="listitem"><p>
            x86_64 アーキテクチャー (AMD Opteron) の Solaris 10 で <code class="literal">InnoDB</code> ストレージエンジンを使用する場合、<code class="literal">InnoDB</code> 関連ファイルにダイレクト I/O を使用して、<code class="literal">InnoDB</code> のパフォーマンスの低下を回避します。<code class="literal">InnoDB</code> 関連ファイルを格納するために使用される UFS ファイルシステム全体にダイレクト I/O を使用するには、それを <code class="literal">forcedirectio</code> オプションでマウントします。<code class="literal">mount_ufs(1M)</code> を参照してください。(Solaris 10/x86_64 のデフォルトではこのオプションを使用<span class="emphasis"><em>しません</em></span>)。ダイレクト I/O をファイルシステム全体ではなく、<code class="literal">InnoDB</code> ファイル操作にのみ適用するには、<code class="literal">innodb_flush_method = O_DIRECT</code> を設定します。この設定では、<code class="literal">InnoDB</code> はデータファイルへの I/O (ログファイルへの I/O ではなく) に <code class="literal">fcntl()</code> ではなく、<code class="literal">directio()</code> を呼び出します。
          </p></li><li class="listitem"><p>
            Solaris 2.6 以上の任意のリリースおよび任意のプラットフォーム (sparc/x86/x64/amd64) で、大きな <code class="literal">innodb_buffer_pool_size</code> 値を使用して、<code class="literal">InnoDB</code> ストレージエンジンを使用する場合、先述の <code class="literal">forcedirectio</code> マウントオプションを使用して、raw デバイスまたは個別のダイレクト I/O UFS ファイルシステムで、<code class="literal">InnoDB</code> データファイルおよびログファイルのベンチマークを実行します。(ログファイルのダイレクト I/O が必要な場合、<code class="literal">innodb_flush_method</code> を設定する代わりに、マウントオプションを使用する必要があります。)Veritas ファイルシステム VxFS のユーザーは、<code class="literal">convosync=direct</code> マウントオプションを使用してください。
          </p><p>
            ダイレクト I/O ファイルシステムに、<code class="literal">MyISAM</code> テーブルのファイルなど、ほかの MySQL データファイルを配置しないでください。実行ファイルやライブラリは、ディレクト I/O ファイルシステムに配置<span class="emphasis"><em>しないでください</em></span>。
          </p></li><li class="listitem"><p>
            RAID 構成または別のディスクへのシンボリックリンクをセットアップするために追加のストレージデバイスを使用できるようにする場合、追加の低レベル I/O のヒントについては、<a class="xref" href="optimization.html#disk-issues" title="8.11.3 ディスク I/O の最適化">セクション8.11.3「ディスク I/O の最適化」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_checkpoint" title="チェックポイント">チェックポイント</a>操作のため、スループットが周期的に低下する場合、<code class="literal">innodb_io_capacity</code> 構成オプションの値を増加することを考慮します。値を大きくすると、<a class="link" href="glossary.html#glos_flush" title="フラッシュ">フラッシュ</a>が頻繁になり、スループットを低下させる可能性のある作業のバックログが避けられます。
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_flush" title="フラッシュ">フラッシュ</a>操作によって、システムが遅くならない場合は、<code class="literal">innodb_io_capacity</code> 構成オプションの値を小さくすることを考慮します。一般に、このオプション値はできるかぎり小さくしますが、前の箇条書きで示したように、スループットに周期的な低下が発生するほど小さくしないでください。オプション値を小さくすることができる一般的なシナリオでは、<code class="literal">SHOW ENGINE INNODB STATUS</code> からの出力に、次のような組み合わせが示されることがあります。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                履歴リストの長さが短く、数千未満です。
              </p></li><li class="listitem"><p>
                挿入バッファーマージ数が挿入された行数に近いです。
              </p></li><li class="listitem"><p>
                バッファープール内の変更されたページが、一貫してバッファープールの <code class="literal">innodb_max_dirty_pages_pct</code> をはるかに下回っています。(サーバーが一括挿入を実行していないときに測定します。変更されたページの一括挿入時に、パーセンテージが大幅に高くなるのは正常です。)
              </p></li><li class="listitem"><p>
                <code class="literal">Log sequence number - Last checkpoint</code> が、<code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_log_file" title="ログファイル">ログファイル</a>の合計サイズの 7/8 未満か、理想的には 6/8 未満です。
              </p></li></ul></div></li><li class="listitem"><p>
            I/O に依存したワークロードのチューニング時に考慮するその他の <code class="literal">InnoDB</code> 構成オプションには次が含まれます: <code class="literal">innodb_adaptive_flushing</code>、<code class="literal">innodb_change_buffer_max_size</code>、<code class="literal">innodb_change_buffering</code>、<code class="literal">innodb_flush_neighbors</code>、


            <code class="literal">innodb_log_buffer_size</code>、<code class="literal">innodb_log_file_size</code>、<code class="literal">innodb_lru_scan_depth</code>、<code class="literal">innodb_max_dirty_pages_pct</code>、<code class="literal">innodb_max_purge_lag</code>、<code class="literal">innodb_open_files</code>、<code class="literal">innodb_page_size</code>、<code class="literal">innodb_random_read_ahead</code>、<code class="literal">innodb_read_ahead_threshold</code>、<code class="literal">innodb_read_io_threads</code>、<code class="literal">innodb_rollback_segments</code>、<code class="literal">innodb_write_io_threads</code>、および <code class="literal">sync_binlog</code>。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="optimizing-innodb-configuration-variables"></a>8.5.8 InnoDB 構成変数の最適化</h3></div></div></div><p>
        軽量の予測可能な負荷のあるサーバーと、常時ほぼいっぱいの容量で実行していたり、高アクティビティーの急増が発生したりするサーバーとでは、もっとも適切に機能する設定が異なります。
      </p><p>
        <code class="literal">InnoDB</code> ストレージエンジンは、多くの最適化を自動的に実行するため、多くのパフォーマンスチューニングタスクには、データベースが適切に実行していることを確認するためのモニタリングと、パフォーマンスの低下時の構成オプションの変更が含まれます。詳細な <code class="literal">InnoDB</code> のパフォーマンスモニタリングについては、<a class="xref" href="innodb-storage-engine.html#innodb-performance-schema" title="14.13.11 InnoDB の MySQL パフォーマンススキーマとの統合">セクション14.13.11「InnoDB の MySQL パフォーマンススキーマとの統合」</a>を参照してください。
      </p><p>
        もっとも重要で、最新の <code class="literal">InnoDB</code> パフォーマンス機能については、<a class="xref" href="innodb-storage-engine.html#innodb-performance" title="14.13 InnoDB のパフォーマンス">セクション14.13「InnoDB のパフォーマンス」</a>を参照してください。以前のバージョンで <code class="literal">InnoDB</code> テーブルを使用していた場合でも、これらの機能は <span class="quote">「<span class="quote">InnoDB プラグイン</span>」</span>からのものであるため、なじみがないと思われます。プラグインは MySQL 5.1 の組み込みの <code class="literal">InnoDB</code> と共存でき、MySQL 5.5 以上でのデフォルトのストレージエンジンになります。
      </p><p>
        実行できる主な構成ステップは次のようになります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            高性能メモリーアロケータを装備するシステムで、<code class="literal">InnoDB</code> がそれらを使用できるようにします。<a class="xref" href="innodb-storage-engine.html#innodb-performance-use_sys_malloc" title="14.13.3 InnoDB のためのメモリーアロケータの構成">セクション14.13.3「InnoDB のためのメモリーアロケータの構成」</a>を参照してください。
          </p></li><li class="listitem"><p>
            頻繁な小さなディスク書き込みを避けるため、<code class="literal">InnoDB</code> が変更されたデータをバッファーする DML 操作の種類を制御します。<a class="xref" href="innodb-storage-engine.html#innodb-performance-change_buffering" title="14.13.4 InnoDB 変更バッファリングの構成">セクション14.13.4「InnoDB 変更バッファリングの構成」</a>を参照してください。デフォルトはすべての種類の DML 操作をバッファーすることであるため、バッファリングの量を減らす必要がある場合にのみ、この設定を変更してください。
          </p></li><li class="listitem"><p>
            <code class="literal">innodb_adaptive_hash_index</code> オプションを使用して、アダプティブハッシュインデックス機能をオンまたはオフにします。詳しくは<a class="xref" href="innodb-storage-engine.html#innodb-adaptive-hash" title="14.2.13.6 適応型ハッシュインデックス">セクション14.2.13.6「適応型ハッシュインデックス」</a>をご覧ください。異常なアクティビティーの間にこの設定を変更し、その後、その元の設定にリストアできます。
          </p></li><li class="listitem"><p>
            コンテキストスイッチングがボトルネックである場合に、<code class="literal">InnoDB</code> が処理する同時スレッドの数に制限を設定します。<a class="xref" href="innodb-storage-engine.html#innodb-performance-thread_concurrency" title="14.13.5 InnoDB のスレッド並列性の構成">セクション14.13.5「InnoDB のスレッド並列性の構成」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> がその先読み操作で実行するプリフェッチの量を制御します。システムに未使用の I/O 容量がある場合、先読みによってクエリーのパフォーマンスが向上することがあります。先読みが多すぎると、負荷の大きいシステムで、パフォーマンスが周期的に低下する可能性があります。<a class="xref" href="innodb-storage-engine.html#innodb-performance-read_ahead" title="14.13.1.1 InnoDB バッファープールのプリフェッチ (先読み) の構成">セクション14.13.1.1「InnoDB バッファープールのプリフェッチ (先読み) の構成」</a>を参照してください。
          </p></li><li class="listitem"><p>
            デフォルト値で十分に活用されていないハイエンド I/O サブシステムがある場合、読み取りまたは書き込み操作のバックグラウンドスレッドの数を増やします。<a class="xref" href="innodb-storage-engine.html#innodb-performance-multiple_io_threads" title="14.13.6 InnoDB バックグラウンド I/O スレッドの数の構成">セクション14.13.6「InnoDB バックグラウンド I/O スレッドの数の構成」</a>を参照してください。
          </p></li><li class="listitem"><p>
            バックグラウンドで <code class="literal">InnoDB</code> が実行する I/O の量を制御します。<a class="xref" href="innodb-storage-engine.html#innodb-performance-thread_io_rate" title="14.13.8 InnoDB マスタースレッドの I/O レートの構成">セクション14.13.8「InnoDB マスタースレッドの I/O レートの構成」</a>を参照してください。バックグラウンド I/O の量は MySQL 5.1 より大きいため、パフォーマンスに周期的な低下が観察された場合、この設定を縮小した方がよいことがあります。
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> が特定の種類のバックグラウンドの書き込みを実行するタイミングを判断するアルゴリズムを制御します。<a class="xref" href="innodb-storage-engine.html#innodb-performance-adaptive_flushing" title="14.13.1.2 InnoDB バッファープールのフラッシュの頻度の構成">セクション14.13.1.2「InnoDB バッファープールのフラッシュの頻度の構成」</a>を参照してください。アルゴリズムはワークロードの種類によって機能する場合と機能しない場合があるため、パフォーマンスに周期的な低下が観察された場合は、この設定をオフした方がよいことがあります。
          </p></li><li class="listitem"><p>
            コンテキストスイッチングの遅延を最小にするため、マルチコアプロセッサとそれらのキャッシュメモリー構成を利用します。<a class="xref" href="innodb-storage-engine.html#innodb-performance-spin_lock_polling" title="14.13.10 スピンロックのポーリングの構成">セクション14.13.10「スピンロックのポーリングの構成」</a>を参照してください。
          </p></li><li class="listitem"><p>
            テーブルスキャンなどの一度だけの操作が、<code class="literal">InnoDB</code> バッファーキャッシュに格納された頻繁にアクセスされるデータを妨げることを防ぎます。<a class="xref" href="innodb-storage-engine.html#innodb-performance-midpoint_insertion" title="14.13.1.3 バッファープールをスキャンに耐えられるようにする">セクション14.13.1.3「バッファープールをスキャンに耐えられるようにする」</a>を参照してください。
          </p></li><li class="listitem"><p>
            信頼性とクラッシュリカバリに適切なサイズにログファイルを調整します。<code class="literal">InnoDB</code> ログファイルは、多くの場合にクラッシュ後の長い起動時間を避けるため、小さく維持されてきました。MySQL 5.5.4 で導入された最適化によって、クラッシュ<a class="link" href="glossary.html#glos_crash_recovery" title="クラッシュリカバリ">リカバリ</a>プロセスの特定のステップが高速化します。特に、<a class="link" href="glossary.html#glos_redo_log" title="Redo ログ">Redo ログ</a>のスキャンと Redo ログの適用は、メモリー管理のアルゴリズムの改善のため、高速化します。長い起動時間を避けるため、ログファイルを人為的に小さく維持していた場合、ログファイルサイズを拡大し、Redo ログレコードのリサイクルのために発生する I/O を削減することを考慮できるようになりました。
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> バッファープールのインスタンスのサイズと数を構成します。特に数ギガバイトのバッファープールのあるシステムに重要です。<a class="xref" href="innodb-storage-engine.html#innodb-multiple-buffer-pools" title="14.13.1.4 複数のバッファープールインスタンスの使用">セクション14.13.1.4「複数のバッファープールインスタンスの使用」</a>を参照してください。
          </p></li><li class="listitem"><p>
            同時トランザクションの最大数を増やします。これはきわめてビジーなデータベースのスケーラビリティーを劇的に向上します。<a class="xref" href="innodb-storage-engine.html#innodb-multiple-rollback-segments" title="14.13.12 複数のロールバックセグメントによるスケーラビリティーの向上">セクション14.13.12「複数のロールバックセグメントによるスケーラビリティーの向上」</a>を参照してください。この機能は、日常の操作中のアクションを必要としませんが、データベースの MySQL 5.5 へのアップグレード中またはその後に、<a class="link" href="glossary.html#glos_slow_shutdown" title="低速シャットダウン">低速シャットダウン</a>を実行して、制限を大きくできるようにする必要があります。
          </p></li><li class="listitem"><p>
            パージ操作 (ガベージコレクションの一種) をバックグラウンドスレッドに移動します。<a class="xref" href="innodb-storage-engine.html#innodb-improved-purge-scheduling" title="14.13.13 InnoDB のパージスケジューリングの構成">セクション14.13.13「InnoDB のパージスケジューリングの構成」</a>を参照してください。この設定の結果を効率的に測定するには、ほかの I/O 関連およびスレッド関連の構成設定を先にチューニングします。
          </p></li><li class="listitem"><p>
            ビジーなサーバーで SQL 操作が列を成し、<span class="quote">「<span class="quote">渋滞</span>」</span>が発生しないように、<code class="literal">InnoDB</code> が同時スレッド間で実行するスイッチングの量を削減します。<code class="literal">innodb_thread_concurrency</code> オプションの値を設定します (強力な最新のシステムで最大約 32)。<code class="literal">innodb_concurrency_tickets</code> オプションの値を一般に 5000 程度に増やします。このオプションの組み合わせにより、<code class="literal">InnoDB</code> が一度に処理するスレッド数に制限を設定し、各スレッドがスワップアウトされるまでに大量の作業を実行できるようにするため、待機スレッドの数が少なくなり、過度なコンテキストスイッチングが発生せずに、操作を完了できます。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="optimizing-innodb-many-tables"></a>8.5.9 多くのテーブルのあるシステムに対する InnoDB の最適化</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">InnoDB</code> は、起動後テーブルにはじめてアクセスされたときに、そのテーブルのインデックス<a class="link" href="glossary.html#glos_cardinality" title="カーディナリティー">カーディナリティー</a>値を計算し、そのような値をテーブルに保存しません。データを多くのテーブルに分割しているシステムでは、このステップに大量の時間がかかることがあります。このオーバーヘッドは最初のテーブルオープン操作にのみ適用されるため、テーブルをあとで使用するために<span class="quote">「<span class="quote">ウォームアップ</span>」</span>するには、<code class="literal">SELECT 1 FROM <em class="replaceable"><code>tbl_name</code></em> LIMIT 1</code> などのステートメントを発行して、起動後すぐにそれにアクセスします。
          </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="optimizing-myisam"></a>8.6 MyISAM テーブルの最適化</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#optimizing-queries-myisam">8.6.1 MyISAM クエリーの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-myisam-bulk-data-loading">8.6.2 MyISAM テーブルの一括データロード</a></span></dt><dt><span class="section"><a href="optimization.html#repair-table-speed">8.6.3 REPAIR TABLE ステートメントの速度</a></span></dt></dl></div><a class="indexterm" name="idm139979113410096"></a><p>
      <code class="literal">MyISAM</code> ストレージエンジンは、テーブルロックによって同時更新を実行する機能を制限するため、読み取りが大半のデータや並列性の低い操作で最適に実行します。MySQL 5.6 では、<code class="literal">MyISAM</code> ではなく、<code class="literal">InnoDB</code> がデフォルトのストレージエンジンです。
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="optimizing-queries-myisam"></a>8.6.1 MyISAM クエリーの最適化</h3></div></div></div><p>
        <code class="literal">MyISAM</code> テーブルのクエリーを高速化するためのいくつかの一般的なヒント:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            MySQL がクエリーをより適切に最適化できるようにするには、テーブルにデータがロードされたあとに、それに対して <code class="literal">ANALYZE TABLE</code> を使用するか、または <span class="command"><strong>myisamchk --analyze</strong></span> を実行します。これにより、同じ値がある平均行数を示す各インデックスパートの値を更新します。(一意のインデックスの場合、これは常に 1 です。)MySQL はこれを使用して、非定数式に基づいて、2 つのテーブルを結合する際に選択するインデックスを決定します。<code class="literal">SHOW INDEX FROM <em class="replaceable"><code>tbl_name</code></em></code> を使用し、<code class="literal">Cardinality</code> 値を調べることで、テーブル分析の結果を確認できます。<span class="command"><strong>myisamchk --description --verbose</strong></span> はインデックスの分布情報を示します。
          </p></li><li class="listitem"><p>
            インデックスに従ってインデックスとデータをソートするには、<span class="command"><strong>myisamchk --sort-index --sort-records=1</strong></span> を使用します (インデックス 1 でソートすると仮定して)。インデックスに従って順番にすべての行を読み取りたいと考える一意のインデックスがある場合、これはクエリーを高速にする適切な方法です。この方法で大きなテーブルをはじめてソートするときは、長い時間がかかることがあります。
          </p></li><li class="listitem"><p>
            頻繁に更新される <code class="literal">MyISAM</code> テーブルに対する複雑な <code class="literal">SELECT</code> クエリーを避け、リーダーとライターの競合のために発生するテーブルロックの問題を回避するようにしてください。
          </p></li><li class="listitem"><p>
            <code class="literal">MyISAM</code> は同時挿入をサポートしています。テーブルのデータファイルの途中に空きブロックがなければ、ほかのスレッドがテーブルから読み取るのと同時に新しい行をそれに <code class="literal">INSERT</code> できます。これを実行できることが重要な場合、行の削除を避けるようにテーブルを使用することを考慮してください。別の可能性は、テーブルの大量の行を削除したあとに <code class="literal">OPTIMIZE TABLE</code> を実行して、テーブルをデフラグすることです。この動作は <code class="literal">concurrent_insert</code> 変数の設定によって変更されます。行を削除したテーブルにも新しい行を強制的に追加 (したがって同時挿入を許可) できます。<a class="xref" href="optimization.html#concurrent-inserts" title="8.10.3 同時挿入">セクション8.10.3「同時挿入」</a>を参照してください。
          </p></li><li class="listitem"><p>
            頻繁に変更される <code class="literal">MyISAM</code> テーブルでは、すべての可変長カラム (<code class="literal">VARCHAR</code>、<code class="literal">TEXT</code>、および <code class="literal">BLOB</code>) を避けるようにします。テーブルに 1 つしか可変長カラムが含まれていない場合でも、テーブルは動的行フォーマットを使用します。<a class="xref" href="storage-engines.html" title="第 15 章 代替ストレージエンジン">第15章「<i>代替ストレージエンジン</i>」</a>を参照してください。
          </p></li><li class="listitem"><p>
            一般に、行が大きくなるためだけに、1 つのテーブルを異なるテーブルに分割することは有益ではありません。行へのアクセスで、もっとも大きくパフォーマンスに打撃を与えるものは、行の先頭バイトを見つけるために必要なディスクシークです。データが見つかったあとは、ほとんどの最新のディスクで、大多数のアプリケーションに十分な速度で行全体を読み取ることができます。テーブルを分割することがかなりの違いをもたらす状況は、固定の行サイズに変更できる動的行フォーマットを使用している <code class="literal">MyISAM</code> テーブルの場合か、またはテーブルを著しく頻繁にスキャンする必要があるが、ほとんどのカラムには必要でない場合だけです。<a class="xref" href="storage-engines.html" title="第 15 章 代替ストレージエンジン">第15章「<i>代替ストレージエンジン</i>」</a>を参照してください。
          </p></li><li class="listitem"><p>
            通常 <code class="literal"><em class="replaceable"><code>expr1</code></em>、<em class="replaceable"><code>expr2</code></em>、...</code> の順で行を取得する場合は、<code class="literal">ALTER TABLE ... ORDER BY <em class="replaceable"><code>expr1</code></em>, <em class="replaceable"><code>expr2</code></em>, ...</code> を使用します。テーブルを大幅に変更したあとにこのオプションを使用することで、パフォーマンスを向上できることがあります。
          </p></li><li class="listitem"><p>
            多数の行の情報に基づいたカウントなど、結果を頻繁に計算する必要がある場合、新しいテーブルを導入し、リアルタイムでカウンタを更新する方が望ましいことがあります。次のような形式の更新はきわめて高速です。
          </p><pre class="programlisting">
UPDATE <em class="replaceable"><code>tbl_name</code></em> SET <em class="replaceable"><code>count_col</code></em>=<em class="replaceable"><code>count_col</code></em>+1 WHERE <em class="replaceable"><code>key_col</code></em>=<em class="replaceable"><code>constant</code></em>;
</pre><p>
            これは、テーブルレベルのロック (単一ライターと複数リーダー) しかない <code class="literal">MyISAM</code> のような MySQL ストレージエンジンを使用する場合に、きわめて重要です。また、この場合に行ロックマネージャーが実行する必要があることは少ないため、ほとんどのデータベースシステムでパフォーマンスが向上します。
          </p></li><li class="listitem"><p>
            データが書き込まれるタイミングを知る必要がない場合は、<code class="literal">MyISAM</code> (またはその他のサポートされる非トランザクションテーブル) に <code class="literal">INSERT DELAYED</code> を使用します。多くの行を 1 回のディスク書き込みで書き込むことができるため、これにより、挿入の全体の影響が少なくなります。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              MySQL 5.6.6 現在、<code class="literal">INSERT DELAYED</code> は非推奨であり、将来のリリースで削除されます。代わりに <code class="literal">INSERT</code> (<code class="literal">DELAYED</code> を付けない) を使用してください。
            </p></div></li><li class="listitem"><p>
            定期的に <code class="literal">OPTIMIZE TABLE</code> を使用して、動的フォーマット <code class="literal">MyISAM</code> テーブルの断片化を防ぎます。<a class="xref" href="storage-engines.html#myisam-table-formats" title="15.2.3 MyISAM テーブルのストレージフォーマット">セクション15.2.3「MyISAM テーブルのストレージフォーマット」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">DELAY_KEY_WRITE=1</code> テーブルオプションを使用して <code class="literal">MyISAM</code> テーブルを宣言すると、テーブルが閉じられるまで、ディスクにフラッシュされないため、インデックスの更新が速くなります。短所は、そのようなテーブルが開いている間に、何かによってサーバーが強制終了させられた場合に、<code class="option">--myisam-recover-options</code> オプションを使用してサーバーを実行するか、サーバーを再起動する前に <span class="command"><strong>myisamchk</strong></span> を実行して、テーブルが問題ないことを確認する必要があることです。(ただし、この場合でも、キー情報は常にデータ行から生成できるため、<code class="literal">DELAY_KEY_WRITE</code> を使用しても何も失われないはずです。)
          </p></li><li class="listitem"><p>
            <code class="literal">MyISAM</code> インデックスでは、文字列の前後のスペースが自動的に圧縮されます。<a class="xref" href="sql-syntax.html#create-index" title="13.1.13 CREATE INDEX 構文">セクション13.1.13「CREATE INDEX 構文」</a>を参照してください。
          </p></li><li class="listitem"><p>
            アプリケーションでクエリーや応答をキャッシュしてから、多くの挿入や更新をまとめて実行することによって、パフォーマンスを向上できます。この操作中にテーブルをロックすることで、すべての更新後にインデックスキャッシュが 1 回だけフラッシュされます。同様の結果を得るために、MySQL のクエリーキャッシュを利用することもできます。<a class="xref" href="optimization.html#query-cache" title="8.9.3 MySQL クエリーキャッシュ">セクション8.9.3「MySQL クエリーキャッシュ」</a>を参照してください。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="optimizing-myisam-bulk-data-loading"></a>8.6.2 MyISAM テーブルの一括データロード</h3></div></div></div><a class="indexterm" name="idm139979113341664"></a><p>
        これらのパフォーマンスのヒントは、<a class="xref" href="optimization.html#insert-speed" title="8.2.2.1 INSERT ステートメントの速度">セクション8.2.2.1「INSERT ステートメントの速度」</a>の高速挿入の一般的なガイドラインを補足するものです。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            複数のクライアントが大量の行を挿入する場合のパフォーマンスを向上するには、<code class="literal">INSERT DELAYED</code> ステートメントを使用します。<a class="xref" href="sql-syntax.html#insert-delayed" title="13.2.5.2 INSERT DELAYED 構文">セクション13.2.5.2「INSERT DELAYED 構文」</a>を参照してください。この技法は、<code class="literal">MyISAM</code> およびその他の一部のストレージエンジンには有効ですが、<code class="literal">InnoDB</code> には機能しません。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              MySQL 5.6.6 現在、<code class="literal">INSERT DELAYED</code> は非推奨であり、将来のリリースで削除されます。代わりに <code class="literal">INSERT</code> (<code class="literal">DELAYED</code> を付けない) を使用してください。
            </p></div></li><li class="listitem"><p>
            <code class="literal">MyISAM</code> テーブルでは、データファイルの途中に削除された行がない場合、<code class="literal">SELECT</code> ステートメントの実行中に同時に、同時挿入を使用して行を追加できます。<a class="xref" href="optimization.html#concurrent-inserts" title="8.10.3 同時挿入">セクション8.10.3「同時挿入」</a>を参照してください。
          </p></li><li class="listitem"><p>
            少しの追加作業で、<code class="literal">MyISAM</code> テーブルに多数のインデックスがある場合に、テーブルの <code class="literal">LOAD DATA INFILE</code> の実行をさらに高速化できます。次の手順を使用します。
          </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                <code class="literal">FLUSH TABLES</code> ステートメントまたは <span class="command"><strong>mysqladmin flush-tables</strong></span> コマンドを実行します。
              </p></li><li class="listitem"><p>
                テーブルのインデックスのすべての使用を削除するには、<span class="command"><strong>myisamchk --keys-used=0 -rq <em class="replaceable"><code>/path/to/db/tbl_name</code></em></strong></span> を使用します。
              </p></li><li class="listitem"><p>
                <code class="literal">LOAD DATA INFILE</code> を使用して、テーブルにデータを挿入します。これはインデックスを更新しないため、非常に高速です。
              </p></li><li class="listitem"><p>
                今後、テーブルから読み取りだけをする場合は、<span class="command"><strong>myisampack</strong></span> を使用してそれを圧縮します。<a class="xref" href="storage-engines.html#compressed-format" title="15.2.3.3 圧縮テーブルの特徴">セクション15.2.3.3「圧縮テーブルの特徴」</a>を参照してください。
              </p></li><li class="listitem"><p>
                <span class="command"><strong>myisamchk -rq <em class="replaceable"><code>/path/to/db/tbl_name</code></em></strong></span> を使用してインデックスを再作成します。これにより、ディスクに書き込む前にメモリー内にインデックスツリーを作成し、大量のディスクシークを回避するため、<code class="literal">LOAD DATA INFILE</code> 時のインデックスの更新よりかなり高速になります。結果のインデックスツリーは完全にバランスも取れています。
              </p></li><li class="listitem"><p>
                <code class="literal">FLUSH TABLES</code> ステートメントまたは <span class="command"><strong>mysqladmin flush-tables</strong></span> コマンドを実行します。
              </p></li></ol></div><p>
            データを挿入する <code class="literal">MyISAM</code> テーブルが空の場合は、<code class="literal">LOAD DATA INFILE</code> は先述の最適化を自動的に実行します。自動の最適化と明示的に手順を使用することの主な違いは、サーバーに <code class="literal">LOAD DATA INFILE</code> ステートメントの実行時に、インデックスの再作成で割り当てさせることができる量より、<span class="command"><strong>myisamchk</strong></span> ではインデックスの作成のためにはるかに多くの一時メモリーを割り当てることができることです。
          </p><p>
            <span class="command"><strong>myisamchk</strong></span> の代わりに次のステートメントを使用して、<code class="literal">MyISAM</code> テーブルの一意でないインデックスを無効または有効にすることもできます。これらのステートメントを使用すると、<code class="literal">FLUSH TABLE</code> 操作をスキップできます。
          </p><pre class="programlisting">
ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> DISABLE KEYS;
ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> ENABLE KEYS;
</pre></li><li class="listitem"><p>
            非トランザクションテーブルに対して、複数ステートメントで実行される <code class="literal">INSERT</code> 操作を高速化するには、テーブルをロックします。
          </p><pre class="programlisting">
LOCK TABLES a WRITE;
INSERT INTO a VALUES (1,23),(2,34),(4,33);
INSERT INTO a VALUES (8,26),(6,29);
...
UNLOCK TABLES;
</pre><p>
            これは、すべての <code class="literal">INSERT</code> ステートメントの完了後に、インデックスバッファーが 1 回だけディスクにフラッシュされるため、パフォーマンスにメリットがあります。通常は、<code class="literal">INSERT</code> ステートメントの数と同じだけ、インデックスバッファーのフラッシュが行われます。すべての行を 1 つの <code class="literal">INSERT</code> で挿入できる場合は、明示的なロックステートメントは必要ありません。
          </p><p>
            ロックは複数接続テストの合計時間も短縮しますが、個々の接続がロックを待機するため、それらの最大待機時間は長くなることがあります。次のように 5 台のクライアントが同時に挿入の実行を試みるとします。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                接続 1 は 1000 回の挿入を実行します
              </p></li><li class="listitem"><p>
                接続 2、3、および 4 は 1 回の挿入を実行します
              </p></li><li class="listitem"><p>
                接続 5 は 1000 回の挿入を実行します
              </p></li></ul></div><p>
            ロックを使用しない場合、接続 2、3、および 4 は 1 と 5 の前に終了します。ロックを使用した場合、接続 2、3、および 4 は 1 または 5 の前に終了しない可能性がありますが、合計時間は約 40% 高速化するはずです。
          </p><p>
            MySQL では、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、および <code class="literal">DELETE</code> 操作はきわめて高速ですが、約 5 回超の連続した挿入や更新を実行するすべての操作の周囲にロックを追加することによって、全体のパフォーマンスを向上できます。著しく多くの連続した挿入を実行する場合、<code class="literal">LOCK TABLES</code> のあとにときどき (1,000 行程度ごとに) <code class="literal">UNLOCK TABLES</code> を実行して、ほかのスレッドのテーブルへのアクセスを許可できます。これによってもパフォーマンスの向上が得られます。
          </p><p>
            上記の戦略を使用した場合でも、データのロードには <code class="literal">LOAD DATA INFILE</code> より <code class="literal">INSERT</code> の方がはるかに遅くなります。
          </p></li><li class="listitem"><p>
            <code class="literal">MyISAM</code> テーブルの <code class="literal">LOAD DATA INFILE</code> と <code class="literal">INSERT</code> の両方に対してパフォーマンスを向上するには、<code class="literal">key_buffer_size</code> システム変数を増やして、キーキャッシュを拡張します。<a class="xref" href="optimization.html#server-parameters" title="8.11.2 サーバーパラメータのチューニング">セクション8.11.2「サーバーパラメータのチューニング」</a>を参照してください。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="repair-table-speed"></a>8.6.3 REPAIR TABLE ステートメントの速度</h3></div></div></div><p>
        <code class="literal">MyISAM</code> テーブルの <code class="literal">REPAIR TABLE</code> は、修復操作に <span class="command"><strong>myisamchk</strong></span> を使用することと似ており、同じパフォーマンス最適化の一部が適用されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <span class="command"><strong>myisamchk</strong></span> にはメモリー割り当てを制御する変数があります。<a class="xref" href="programs.html#myisamchk-memory" title="4.6.3.6 myisamchk メモリー使用量">セクション4.6.3.6「myisamchk メモリー使用量」</a>に説明するように、これらの変数を設定してパフォーマンスを向上できることがあります。
          </p></li><li class="listitem"><p>
            <code class="literal">REPAIR TABLE</code> では、同じ原則が適用されますが、修復はサーバーによって実行されるため、<span class="command"><strong>myisamchk</strong></span> 変数の代わりに、サーバーシステム変数を設定します。さらに、メモリー割り当て変数の設定に加えて、<code class="literal">myisam_max_sort_file_size</code> システム変数を増やすと、修復で高速の filesort 方法が使用され、キーキャッシュ方法による遅い修復が避けられる可能性が高くなります。テーブルファイルのコピーを保持できるだけの十分な空き領域があることを確認したら、システムの最大ファイルサイズに変数を設定します。元のテーブルファイルを格納しているファイルシステムで、空き領域が使用できる必要があります。
          </p></li></ul></div><p>
        次のオプションを使用して、そのメモリー割り当て変数を設定して、<span class="command"><strong>myisamchk</strong></span> テーブル修復操作が実行されたとします。
      </p><pre class="programlisting">
--key_buffer_size=128M --myisam_sort_buffer_size=256M
--read_buffer_size=64M --write_buffer_size=64M
</pre><p>
        それらの <span class="command"><strong>myisamchk</strong></span> 変数の一部はサーバーシステム変数に対応します。
      </p><div class="informaltable"><table summary="この表は myisamchk 変数と対応するサーバーシステム変数を示しています。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col"><span class="command"><strong>myisamchk</strong></span> 変数</th><th scope="col">システム変数</th></tr></thead><tbody><tr><td scope="row"><code class="literal">key_buffer_size</code></td><td><code class="literal">key_buffer_size</code></td></tr><tr><td scope="row"><code class="literal">myisam_sort_buffer_size</code></td><td><code class="literal">myisam_sort_buffer_size</code></td></tr><tr><td scope="row"><code class="literal">read_buffer_size</code></td><td><code class="literal">read_buffer_size</code></td></tr><tr><td scope="row"><code class="literal">write_buffer_size</code></td><td>none</td></tr></tbody></table></div><p>
        各サーバーシステム変数は実行時に設定でき、それらの一部 (<code class="literal">myisam_sort_buffer_size</code>、<code class="literal">read_buffer_size</code>) にはグローバル値に加えてセッション値もあります。セッション値を設定することで、現在のセッションへの変更の影響を制限し、ほかのユーザーに影響しません。グローバルのみの変数 (<code class="literal">key_buffer_size</code>、<code class="literal">myisam_max_sort_file_size</code>) を変更すると、ほかのユーザーにも影響します。<code class="literal">key_buffer_size</code> の場合、バッファーがそれらのユーザーと共有されることを考慮しておく必要があります。たとえば、<span class="command"><strong>myisamchk</strong></span> <code class="literal">key_buffer_size</code> 変数を 128M バイトに設定した場合、対応する <code class="literal">key_buffer_size</code> システム変数をそれより大きく設定し (それがすでに大きく設定されていない場合)、ほかのセッションのアクティビティーによるキーバッファーの使用を許可できます。ただし、グローバルキーバッファーサイズを変更すると、バッファーが無効になり、ディスク I/O が増加して、ほかのセッションが遅くなります。この問題を回避する代替策は、個別のキーキャッシュを使用し、それを修復対象のテーブルのインデックスに割り当て、修復が完了したら、その割り当てを解除することです。<a class="xref" href="optimization.html#multiple-key-caches" title="8.9.2.2 複合キーキャッシュ">セクション8.9.2.2「複合キーキャッシュ」</a>を参照してください。
      </p><p>
        先述の説明に基づいて、<code class="literal">REPAIR TABLE</code> 操作は、次のように実行して、<span class="command"><strong>myisamchk</strong></span> コマンドに似た設定を使用できます。ここでは、個別の 128M バイトのキーバッファーが割り当てられ、ファイルシステムは 100G バイト以上のファイルサイズを許可するものとします。
      </p><pre class="programlisting">
SET SESSION myisam_sort_buffer_size = 256*1024*1024;
SET SESSION read_buffer_size = 64*1024*1024;
SET GLOBAL myisam_max_sort_file_size = 100*1024*1024*1024;
SET GLOBAL repair_cache.key_buffer_size = 128*1024*1024;
CACHE INDEX <em class="replaceable"><code>tbl_name</code></em> IN repair_cache;
LOAD INDEX INTO CACHE <em class="replaceable"><code>tbl_name</code></em>;
REPAIR TABLE <em class="replaceable"><code>tbl_name</code></em> ;
SET GLOBAL repair_cache.key_buffer_size = 0;
</pre><p>
        グローバル変数を変更するが、ほかのユーザーへの影響を最小にするため、<code class="literal">REPAIR TABLE</code> 操作の間にのみ実行するようにしたい場合、その値をユーザー変数に保存して、あとでそれをリストアします。例:
      </p><pre class="programlisting">
SET @old_myisam_sort_buffer_size = @@global.myisam_max_sort_file_size;
SET GLOBAL myisam_max_sort_file_size = 100*1024*1024*1024;
REPAIR TABLE tbl_name ;
SET GLOBAL myisam_max_sort_file_size = @old_myisam_max_sort_file_size;
</pre><p>
        <code class="literal">REPAIR TABLE</code> に影響するシステム変数は、変数をデフォルトで有効にしたい場合、サーバーの起動時にグローバルに設定できます。たとえば、次の行をサーバーの <code class="filename">my.cnf</code> ファイルに追加します。
      </p><pre class="programlisting">
[mysqld]
myisam_sort_buffer_size=256M
key_buffer_size=1G
myisam_max_sort_file_size=100G
</pre><p>
        これらの設定には <code class="literal">read_buffer_size</code> は含まれません。<code class="literal">read_buffer_size</code> をグローバルに大きな値に設定すると、すべてのセッションに対してそれが実行され、多くの同時セッションのあるサーバーに過剰なメモリーが割り当てられるため、パフォーマンスが低下する可能性があります。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="optimizing-memory-tables"></a>8.7 MEMORY テーブルの最適化</h2></div></div></div><a class="indexterm" name="idm139979113210672"></a><p>
      頻繁にアクセスされ、読み取り専用かめったに更新されない非クリティカルデータに <code class="literal">MEMORY</code> テーブルを使用することを考慮します。現実的なワークロードで、同等の <code class="literal">InnoDB</code> または <code class="literal">MyISAM</code> テーブルに対してアプリケーションのベンチマークを実行し、追加のパフォーマンスが、データの損失のリスクやアプリケーションの起動時にディスクベースのテーブルからデータをコピーすることのオーバーヘッドに値するかを確認します。
    </p><p>
      <code class="literal">MEMORY</code> テーブルで最高のパフォーマンスを得るには、各テーブルに対するクエリーの種類を調査し、関連付けられた各インデックスに使用する B ツリーインデックスまたはハッシュインデックスのいずれかの種類を指定します。<code class="literal">CREATE INDEX</code> ステートメントで、句 <code class="literal">USING BTREE</code> または <code class="literal">USING HASH</code> を使用します。B ツリーインデックスは、<code class="literal">&gt;</code> や <code class="literal">BETWEEN</code> などの操作によって、greater-than または less-than の比較を実行するクエリーで高速です。ハッシュインデックスは、<code class="literal">=</code> 演算子によって単一の値、または <code class="literal">IN</code> 演算子によって制限された値のセットをルックアップするクエリーでのみ高速です。<code class="literal">USING BTREE</code> が多くの場合にデフォルトの <code class="literal">USING HASH</code> より適切な選択である理由については、<a class="xref" href="optimization.html#how-to-avoid-table-scan" title="8.2.1.20 フルテーブルスキャンを回避する方法">セクション8.2.1.20「フルテーブルスキャンを回避する方法」</a>を参照してください。さまざまな種類の <code class="literal">MEMORY</code> インデックスの実装の詳細については、<a class="xref" href="optimization.html#index-btree-hash" title="8.3.8 B ツリーインデックスとハッシュインデックスの比較">セクション8.3.8「B ツリーインデックスとハッシュインデックスの比較」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="execution-plan-information"></a>8.8 クエリー実行プランの理解</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#using-explain">8.8.1 EXPLAIN によるクエリーの最適化</a></span></dt><dt><span class="section"><a href="optimization.html#explain-output">8.8.2 EXPLAIN 出力フォーマット</a></span></dt><dt><span class="section"><a href="optimization.html#explain-extended">8.8.3 EXPLAIN EXTENDED 出力フォーマット</a></span></dt><dt><span class="section"><a href="optimization.html#estimating-performance">8.8.4 クエリーパフォーマンスの推定</a></span></dt><dt><span class="section"><a href="optimization.html#controlling-optimizer">8.8.5 クエリーオプティマイザの制御</a></span></dt></dl></div><p>
      <code class="literal">WHERE</code> 句内のテーブル、カラム、インデックス、および条件の詳細に応じて、MySQL オプティマイザは SQL クエリーに含まれるルックアップを効率的に実行するための多くの技法を考慮します。巨大なテーブルに対するクエリーは、すべての行を読み取らなくても実行でき、複数のテーブルを含む結合は、行のすべての組み合わせを比較しなくても実行できます。オプティマイザがもっとも効率的なクエリーを実行するために選択する操作のセットは、<span class="quote">「<span class="quote">クエリー実行プラン</span>」</span>と呼ばれ、<code class="literal">EXPLAIN</code> プランとも呼ばれます。目的は、クエリーが適切に最適化されていることを示す <code class="literal">EXPLAIN</code> プランの側面を認識し、非効率的な操作が見られた場合に、プランを改善するための SQL 構文とインデックス設定技法を学ぶことです。
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="using-explain"></a>8.8.1 EXPLAIN によるクエリーの最適化</h3></div></div></div><a class="indexterm" name="idm139979113186384"></a><a class="indexterm" name="idm139979113185072"></a><p>
        <code class="literal">EXPLAIN</code> ステートメントを使用して、MySQL がステートメントを実行する方法に関する情報を取得できます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            MySQL 5.6.3 現在、<code class="literal">EXPLAIN</code> に使用できる説明可能なステートメントは、<code class="literal">SELECT</code>、<code class="literal">DELETE</code>、<code class="literal">INSERT</code>、<code class="literal">REPLACE</code>、および <code class="literal">UPDATE</code> です。MySQL 5.6.3 より前では、<code class="literal">SELECT</code> が唯一の説明可能なステートメントです。
          </p></li><li class="listitem"><p>
            説明可能なステートメントで <code class="literal">EXPLAIN</code> を使用すると、MySQL は、オプティマイザからのステートメント実行プランに関する情報を表示します。つまり、MySQL はテーブルがどのように、どんな順番で結合されているかに関する情報を含む、ステートメントを処理する方法を説明します。<code class="literal">EXPLAIN</code> を使用して、実行プラン情報を取得することについては、<a class="xref" href="optimization.html#explain-output" title="8.8.2 EXPLAIN 出力フォーマット">セクション8.8.2「EXPLAIN 出力フォーマット」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">EXPLAIN EXTENDED</code> を使用して、追加の実行プラン情報を取得できます。<a class="xref" href="optimization.html#explain-extended" title="8.8.3 EXPLAIN EXTENDED 出力フォーマット">セクション8.8.3「EXPLAIN EXTENDED 出力フォーマット」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">EXPLAIN PARTITIONS</code> は、パーティション化されたテーブルを含むクエリーの調査に役立ちます。<a class="xref" href="partitioning.html#partitioning-info" title="19.3.5 パーティションに関する情報を取得する">セクション19.3.5「パーティションに関する情報を取得する」</a>を参照してください。
          </p></li><li class="listitem"><p>
            MySQL 5.6.3 現在、<code class="literal">FORMAT</code> オプションを使用して、出力フォーマットを選択できます。<code class="literal">TRADITIONAL</code> は表形式で出力を表示します。<code class="literal">FORMAT</code> オプションが存在しない場合、これはデフォルトです。<code class="literal">JSON</code> フォーマットは JSON フォーマットで情報を表示します。<code class="literal">FORMAT = JSON</code> を使用すると、出力には拡張されたパーティション情報が含まれます。
          </p></li></ul></div><p>
        <a class="indexterm" name="idm139979113156464"></a> <code class="literal">EXPLAIN</code> によって、インデックスを使用して行を見つけることで、ステートメントが高速に実行されるように、テーブルにインデックスを追加するべき場所がわかります。また、<code class="literal">EXPLAIN</code> を使用して、オプティマイザがテーブルを最適な順序で結合しているかどうかを確認することもできます。<code class="literal">SELECT</code> ステートメントでテーブルが指定されている順序に対応する結合順序を使用するように、オプティマイザにヒントを提供するには、ステートメントを <code class="literal">SELECT</code> だけでなく、<code class="literal">SELECT STRAIGHT_JOIN</code> で始めます。(<a class="xref" href="sql-syntax.html#select" title="13.2.9 SELECT 構文">セクション13.2.9「SELECT 構文」</a>を参照してください。)
      </p><p>
        インデックスが使われるはずであると思うタイミングでそれらが使われていない問題がある場合、<code class="literal">ANALYZE TABLE</code> を実行して、オプティマイザが行う選択に影響する可能性があるキーのカーディナリティーなどのテーブル統計を更新します。<a class="xref" href="sql-syntax.html#analyze-table" title="13.7.2.1 ANALYZE TABLE 構文">セクション13.7.2.1「ANALYZE TABLE 構文」</a>を参照してください。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">EXPLAIN</code> はテーブル内のカラムに関する情報を取得するためにも使用できます。<code class="literal">EXPLAIN <em class="replaceable"><code>tbl_name</code></em></code> は <code class="literal">DESCRIBE <em class="replaceable"><code>tbl_name</code></em></code> および <code class="literal">SHOW COLUMNS FROM <em class="replaceable"><code>tbl_name</code></em></code> と同義です。詳細については、<a class="xref" href="sql-syntax.html#describe" title="13.8.1 DESCRIBE 構文">セクション13.8.1「DESCRIBE 構文」</a>および<a class="xref" href="sql-syntax.html#show-columns" title="13.7.5.6 SHOW COLUMNS 構文">セクション13.7.5.6「SHOW COLUMNS 構文」</a>を参照してください。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="explain-output"></a>8.8.2 EXPLAIN 出力フォーマット</h3></div></div></div><p>
        <code class="literal">EXPLAIN</code> ステートメントは <code class="literal">SELECT</code> ステートメントの実行プランに関する情報を提供します。
      </p><p>
        <code class="literal">EXPLAIN</code> は <code class="literal">SELECT</code> ステートメントで使用される各テーブルに関する情報の行を返します。これは、MySQL がステートメントの処理中にテーブルを読み取る順番で、出力にテーブルを一覧表示します。MySQL は Nested Loop 結合メソッドを使用して、すべての結合を解決します。これは、MySQL が最初のテーブルから行を読み取り、次に 2 つめのテーブル、3 つめのテーブルというように、一致する行を見つけることを意味します。すべてのテーブルが処理されると、MySQL は選択したカラムを出力し、さらに一致する行があるテーブルが見つかるまで、テーブルリストを逆戻りします。次の行がテーブルから読み取られ、プロセスは次のテーブルに進みます。
      </p><p>
        <code class="literal">EXTENDED</code> キーワードを使用すると、<code class="literal">EXPLAIN</code> は、<code class="literal">EXPLAIN</code> ステートメントに続けて <code class="literal">SHOW WARNINGS</code> ステートメントを発行することで表示できる追加の情報を生成します。<code class="literal">EXPLAIN EXTENDED</code> は<code class="literal">フィルタ処理された</code>カラムも表示します。<a class="xref" href="optimization.html#explain-extended" title="8.8.3 EXPLAIN EXTENDED 出力フォーマット">セクション8.8.3「EXPLAIN EXTENDED 出力フォーマット」</a>を参照してください。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">EXTENDED</code> キーワードと <code class="literal">PARTITIONS</code> キーワードを、同じ <code class="literal">EXPLAIN</code> ステートメントで一緒に使用することはできません。
        </p></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <a class="link" href="optimization.html#explain-output-columns" title="EXPLAIN 出力カラム"><code class="literal">EXPLAIN</code> 出力カラム</a>
          </p></li><li class="listitem"><p>
            <a class="link" href="optimization.html#explain-join-types" title="EXPLAIN 結合型"><code class="literal">EXPLAIN</code> 結合型</a>
          </p></li><li class="listitem"><p>
            <a class="link" href="optimization.html#explain-extra-information" title="EXPLAIN の追加情報"><code class="literal">EXPLAIN</code> 追加情報</a>
          </p></li><li class="listitem"><p>
            <a class="link" href="optimization.html#explain-output-interpretation" title="EXPLAIN 出力の解釈"><code class="literal">EXPLAIN</code> 出力の解釈</a>
          </p></li></ul></div><h4><a name="explain-output-columns"></a>EXPLAIN 出力カラム</h4><p>
        このセクションでは、<code class="literal">EXPLAIN</code> によって生成される出力カラムについて説明します。あとのセクションで、<a class="link" href="optimization.html#explain-join-types" title="EXPLAIN 結合型"><code class="literal">type</code></a> と <a class="link" href="optimization.html#explain-extra-information" title="EXPLAIN の追加情報"><code class="literal">Extra</code></a> カラムに関する追加情報を提供します。
      </p><p>
        <code class="literal">EXPLAIN</code> からの各出力行は 1 つのテーブルに関する情報を提供します。各行には、<a class="xref" href="optimization.html#explain-output-column-table" title="表 8.1 EXPLAIN 出力カラム">表8.1「EXPLAIN 出力カラム」</a>で要約し、次の表に詳しく説明している値が格納されます。
      </p><div class="table"><a name="explain-output-column-table"></a><p class="title"><b>表 8.1 EXPLAIN 出力カラム</b></p><div class="table-contents"><table summary="EXPLAIN 出力カラム" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">カラム</th><th scope="col">意味</th></tr></thead><tbody><tr><td scope="row"><a class="link" href="optimization.html#explain_id"><code class="literal">id</code></a></td><td><code class="literal">SELECT</code> 識別子。</td></tr><tr><td scope="row"><a class="link" href="optimization.html#explain_select_type"><code class="literal">select_type</code></a></td><td><code class="literal">SELECT</code> 型</td></tr><tr><td scope="row"><a class="link" href="optimization.html#explain_table"><code class="literal">table</code></a></td><td>出力行のテーブル</td></tr><tr><td scope="row"><a class="link" href="optimization.html#explain_partitions"><code class="literal">partitions</code></a></td><td>一致するパーティション</td></tr><tr><td scope="row"><a class="link" href="optimization.html#explain_type"><code class="literal">type</code></a></td><td>結合型</td></tr><tr><td scope="row"><a class="link" href="optimization.html#explain_possible_keys"><code class="literal">possible_keys</code></a></td><td>選択可能なインデックス</td></tr><tr><td scope="row"><a class="link" href="optimization.html#explain_key"><code class="literal">key</code></a></td><td>実際に選択されたインデックス</td></tr><tr><td scope="row"><a class="link" href="optimization.html#explain_key_len"><code class="literal">key_len</code></a></td><td>選択されたキーの長さ</td></tr><tr><td scope="row"><a class="link" href="optimization.html#explain_ref"><code class="literal">ref</code></a></td><td>インデックスと比較されるカラム</td></tr><tr><td scope="row"><a class="link" href="optimization.html#explain_rows"><code class="literal">rows</code></a></td><td>調査される行の見積もり</td></tr><tr><td scope="row"><a class="link" href="optimization.html#explain_filtered"><code class="literal">filtered</code></a></td><td>テーブル条件によってフィルタ処理される行の割合</td></tr><tr><td scope="row"><a class="link" href="optimization.html#explain_extra"><code class="literal">Extra</code></a></td><td>追加情報</td></tr></tbody></table></div></div><br class="table-break"><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="explain_id"></a>
            <code class="literal">id</code>
          </p><p>
            <code class="literal">SELECT</code> 識別子。これはクエリー内の <code class="literal">SELECT</code> の連番です。行がほかの行の和集合結果を参照する場合に、値は <code class="literal">NULL</code> になることがあります。この場合、<code class="literal">table</code> カラムには、<code class="literal">&lt;union<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>N</code></em>&gt;</code> などの値が表示され、行が <em class="replaceable"><code>M</code></em> および <em class="replaceable"><code>N</code></em> の <code class="literal">id</code> 値のある行の和集合を参照していることが示されます。
          </p></li><li class="listitem"><p><a name="explain_select_type"></a>
            <code class="literal">select_type</code>
          </p><p>
            <code class="literal">SELECT</code> の種類で、次の表に示すもののいずれかになります。
          </p><div class="informaltable"><table summary="この表では select_type 値を示し、それぞれの意味を説明しています。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col"><code class="literal">select_type</code> 値</th><th scope="col">意味</th></tr></thead><tbody><tr><td scope="row"><code class="literal">SIMPLE</code></td><td>単純な <code class="literal">SELECT</code> (<code class="literal">UNION</code> やサブクエリーを使用しません)</td></tr><tr><td scope="row"><code class="literal">PRIMARY</code></td><td>もっとも外側の <code class="literal">SELECT</code></td></tr><tr><td scope="row"><code class="literal">UNION</code></td><td><code class="literal">UNION</code> 内の 2 つめ以降の <code class="literal">SELECT</code> ステートメント</td></tr><tr><td scope="row"><code class="literal">DEPENDENT UNION</code></td><td><code class="literal">UNION</code> 内の 2 つめ以降の <code class="literal">SELECT</code> ステートメントで、外側のクエリーに依存します</td></tr><tr><td scope="row"><code class="literal">UNION RESULT</code></td><td><code class="literal">UNION</code> の結果。</td></tr><tr><td scope="row"><code class="literal">SUBQUERY</code></td><td>サブクエリー内の最初の <code class="literal">SELECT</code></td></tr><tr><td scope="row"><code class="literal">DEPENDENT SUBQUERY</code></td><td>サブクエリー内の最初の <code class="literal">SELECT</code> で、外側のクエリーに依存します</td></tr><tr><td scope="row"><code class="literal">DERIVED</code></td><td>派生テーブル <code class="literal">SELECT</code> (<code class="literal">FROM</code> 句内のサブクエリー)</td></tr><tr><td scope="row"><code class="literal">MATERIALIZED</code></td><td>実体化されたサブクエリー</td></tr><tr><td scope="row"><code class="literal">UNCACHEABLE SUBQUERY</code></td><td>結果をキャッシュできず、外側のクエリーの行ごとに再評価される必要があるサブクエリー</td></tr><tr><td scope="row"><code class="literal">UNCACHEABLE UNION</code></td><td>キャッシュ不可能なサブクエリー (<code class="literal">UNCACHEABLE SUBQUERY</code> を参照してください) に属する <code class="literal">UNION</code> 内の 2 つめ以降の SELECT</td></tr></tbody></table></div><p>
            <code class="literal">DEPENDENT</code> は一般に、相関サブクエリーの使用を示します。<a class="xref" href="sql-syntax.html#correlated-subqueries" title="13.2.10.7 相関サブクエリー">セクション13.2.10.7「相関サブクエリー」</a>を参照してください。
          </p><p>
            <code class="literal">DEPENDENT SUBQUERY</code> の評価は <code class="literal">UNCACHEABLE SUBQUERY</code> の評価とは異なります。<code class="literal">DEPENDENT SUBQUERY</code> の場合、その外部コンテキストの変数の異なる値の各セットにつき、一回だけサブクエリーが再評価されます。<code class="literal">UNCACHEABLE SUBQUERY</code> の場合、外部コンテキストの行ごとにサブクエリーが再評価されます。
          </p><p>
            サブクエリーのキャッシュ可能性は、クエリーキャッシュへのクエリー結果のキャッシュ (これについては<a class="xref" href="optimization.html#query-cache-operation" title="8.9.3.1 クエリーキャッシュの動作">セクション8.9.3.1「クエリーキャッシュの動作」</a>で説明しています) と異なります。サブクエリーのキャッシュは、クエリー実行中に行われ、クエリーキャッシュは、クエリーの実行が終了したあとにのみ、結果を格納するために使用されます。
          </p></li><li class="listitem"><p><a name="explain_table"></a>
            <code class="literal">table</code>
          </p><p>
            出力の行で参照しているテーブルの名前。これも次のいずれかの値になることがあります。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">&lt;union<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>N</code></em>&gt;</code>: 行は <em class="replaceable"><code>M</code></em> および <em class="replaceable"><code>N</code></em> の <code class="literal">id</code> 値のある行の和集合を参照しています。
              </p></li><li class="listitem"><p>
                <code class="literal">&lt;derived<em class="replaceable"><code>N</code></em>&gt;</code>: 行は <em class="replaceable"><code>N</code></em> の <code class="literal">id</code> 値のある行の派生テーブル結果を参照しています。派生テーブルは、たとえば <code class="literal">FROM</code> 句内のサブクエリーの結果などになります。
              </p></li><li class="listitem"><p>
                <code class="literal">&lt;subquery<em class="replaceable"><code>N</code></em>&gt;</code>: 行は <em class="replaceable"><code>N</code></em> の <code class="literal">id</code> 値のある行の実体化されたサブクエリーの結果を参照しています。<a class="xref" href="optimization.html#subquery-materialization" title="8.2.1.18.2 サブクエリー実体化によるサブクエリーの最適化">セクション8.2.1.18.2「サブクエリー実体化によるサブクエリーの最適化」</a>を参照してください。
              </p></li></ul></div></li><li class="listitem"><p><a name="explain_partitions"></a>
            <code class="literal">partitions</code>
          </p><p>
            クエリーでレコードが照合されるパーティション。このカラムは、<code class="literal">PARTITIONS</code> キーワードが使用されている場合にのみ表示されます。パーティション化されていないテーブルの場合、この値は <code class="literal">NULL</code> です。<a class="xref" href="partitioning.html#partitioning-info" title="19.3.5 パーティションに関する情報を取得する">セクション19.3.5「パーティションに関する情報を取得する」</a>を参照してください。
          </p></li><li class="listitem"><p><a name="explain_type"></a>
            <code class="literal">type</code>
          </p><p>
            結合型。さまざまな型の説明については、「<a class="link" href="optimization.html#explain-join-types" title="EXPLAIN 結合型"><code class="literal">EXPLAIN</code> 結合型</a>」を参照してください。
          </p></li><li class="listitem"><p><a name="explain_possible_keys"></a>
            <code class="literal">possible_keys</code>
          </p><p>
            <code class="literal">possible_keys</code> カラムは、MySQL がこのテーブル内の行の検索に使用するために選択できるインデックスを示します。このカラムは <code class="literal">EXPLAIN</code> の出力に表示されたテーブルの順序にまったく依存しません。つまり、<code class="literal">possible_keys</code> のキーの一部は、生成されたテーブルの順序で実際に使用できないことがあります。
          </p><p>
            このカラムが <code class="literal">NULL</code> の場合は、関連するインデックスがありません。この場合、<code class="literal">WHERE</code> 句を調査して、それがインデックス設定に適したカラムを参照しているかどうかをチェックすることで、クエリーのパフォーマンスを向上できることがあります。その場合は、適切なインデックスを作成し、再度 <code class="literal">EXPLAIN</code> でクエリーをチェックします。<a class="xref" href="sql-syntax.html#alter-table" title="13.1.7 ALTER TABLE 構文">セクション13.1.7「ALTER TABLE 構文」</a>を参照してください。
          </p><p>
            テーブルにあるインデックスを確認するには、<code class="literal">SHOW INDEX FROM <em class="replaceable"><code>tbl_name</code></em></code> を使用します。
          </p></li><li class="listitem"><p><a name="explain_key"></a>
            <code class="literal">key</code>
          </p><p>
            <code class="literal">key</code> カラムは、MySQL が実際に使用することを決定したキー (インデックス) を示します。MySQL が行をルックアップするために、いずれかの <code class="literal">possible_keys</code> インデックスを使用することを決定した場合、キー値としてそのインデックスが一覧表示されます。
          </p><p>
            <code class="literal">key</code> は <code class="literal">possible_keys</code> 値に存在しないインデックスを指定している可能性があります。これは <code class="literal">possible_keys</code> インデックスのどれも行のルックアップに適していない場合に発生する可能性がありますが、クエリーによって選択されるすべてのカラムはほかのインデックスのカラムになります。つまり、指定されたインデックスは選択されたカラムをカバーするため、取得する行を決定するために使用されませんが、インデックススキャンはデータ行スキャンよりも効率的です。
          </p><p>
            <code class="literal">InnoDB</code> は各セカンダリインデックスとともに主キー値を保存するため、<code class="literal">InnoDB</code> では、クエリーで主キーも選択している場合でも、セカンダリインデックスで選択されたカラムをカバーしている可能性があります。<code class="literal">key</code> が <code class="literal">NULL</code> の場合、MySQL はクエリーをより効率的に実行するために使用するインデックスを見つけられませんでした。
          </p><p>
            MySQL で <code class="literal">possible_keys</code> カラムに示されたインデックスを強制的に使用させるか、無視させるには、クエリーで <code class="literal">FORCE INDEX</code>、<code class="literal">USE INDEX</code>、または <code class="literal">IGNORE INDEX</code> を使用します。<a class="xref" href="sql-syntax.html#index-hints" title="13.2.9.3 インデックスヒントの構文">セクション13.2.9.3「インデックスヒントの構文」</a>を参照してください。
          </p><p>
            <code class="literal">MyISAM</code> テーブルと <code class="literal">NDB</code> テーブルの場合、<code class="literal">ANALYZE TABLE</code> を実行することで、オプティマイザがより適切なインデックスを選択するために役立ちます。<code class="literal">NDB</code> テーブルの場合、これにより、分散されたプッシュダウン結合のパフォーマンスも向上します。<code class="literal">MyISAM</code> テーブルの場合、<span class="command"><strong>myisamchk --analyze</strong></span> は <code class="literal">ANALYZE TABLE</code> と同じことを実行します。<a class="xref" href="backup-and-recovery.html#myisam-table-maintenance" title="7.6 MyISAM テーブルの保守とクラッシュリカバリ">セクション7.6「MyISAM テーブルの保守とクラッシュリカバリ」</a>を参照してください。
          </p></li><li class="listitem"><p><a name="explain_key_len"></a>
            <code class="literal">key_len</code>
          </p><p>
            <code class="literal">key_len</code> カラムは、MySQL が使用することを決定したキーの長さを示します。<code class="literal">key</code> カラムに <code class="literal">NULL</code> と示されている場合、この長さは <code class="literal">NULL</code> になります。<code class="literal">key_len</code> の値によって、MySQL が実際に使用するマルチパートキーのパート数を判断できます。
          </p></li><li class="listitem"><p><a name="explain_ref"></a>
            <code class="literal">ref</code>
          </p><p>
            <code class="literal">ref</code> カラムは、テーブルから行を選択するために、<code class="literal">key</code> カラムに指定されたインデックスに対して比較されるカラムまたは定数を示します。
          </p><p>
            値が <code class="literal">func</code> の場合、使用される値は、特定の関数の結果です。どの関数か確認するには、<code class="literal">EXPLAIN EXTENDED</code> のあとに <code class="literal">SHOW WARNINGS</code> を付けて使用します。関数は、実際には算術演算子などの演算子である場合があります。
          </p></li><li class="listitem"><p><a name="explain_rows"></a>
            <code class="literal">rows</code>
          </p><p>
            <code class="literal">rows</code> カラムは、MySQL がクエリーを実行するために調査する必要があると考える行数を示します。
          </p><p>
            <code class="literal">InnoDB</code> テーブルの場合、これは推定値であり、常に正確ではないことがあります。
          </p></li><li class="listitem"><p><a name="explain_filtered"></a>
            <code class="literal">filtered</code>
          </p><p>
            <code class="literal">filtered</code> カラムは、テーブル条件によってフィルタ処理されるテーブル行の推定の割合を示します。つまり、<code class="literal">rows</code> は調査される推定の行数を示し、<code class="literal">rows</code> × <code class="literal">filtered</code> / <code class="literal">100</code> が前のテーブルと結合される行数を示します。<code class="literal">EXPLAIN EXTENDED</code> を使用すると、このカラムが表示されます。
          </p></li><li class="listitem"><p><a name="explain_extra"></a>
            <code class="literal">Extra</code>
          </p><p>
            このカラムには、MySQL がクエリーを解決する方法に関する追加情報が含まれます。さまざまな値の説明については、「<a class="link" href="optimization.html#explain-extra-information" title="EXPLAIN の追加情報"><code class="literal">EXPLAIN</code> の追加情報</a>」を参照してください。
          </p></li></ul></div><h4><a name="explain-join-types"></a>EXPLAIN 結合型</h4><p>
        <code class="literal">EXPLAIN</code> 出力の <code class="literal">type</code> カラムには、テーブルの結合方法が示されます。次のリストに、もっとも適切な型からもっとも不適切な型の順番で並べた結合型を示します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="jointype_system"></a>
            <a class="indexterm" name="idm139979112918544"></a> <a class="indexterm" name="idm139979112916544"></a> <a class="indexterm" name="idm139979112914384"></a> <code class="literal">system</code>
          </p><p>
            テーブルには行が 1 つしかありません (= system テーブル)。これは、<code class="literal">const</code> 結合型の特殊なケースです。
          </p></li><li class="listitem"><p><a name="jointype_const"></a>
            <a class="indexterm" name="idm139979112908608"></a> <a class="indexterm" name="idm139979112906608"></a> <a class="indexterm" name="idm139979112904448"></a> <code class="literal">const</code>
          </p><p>
            テーブルには、一致するレコードが最大で 1 つあり、クエリーの開始時に読み取られます。行が 1 つしかないため、この行のカラムの値は、オプティマイザの残りによって定数とみなされることがあります。<code class="literal">const</code> テーブルは、1 回しか読み取られないため、非常に高速です。
          </p><p>
            <code class="literal">const</code> は <code class="literal">PRIMARY KEY</code> または <code class="literal">UNIQUE</code> インデックスのすべてのパートを定数値と比較する場合に使用されます。次のクエリーでは、<em class="replaceable"><code>tbl_name</code></em> は <code class="literal">const</code> テーブルとして使用できます。
          </p><pre class="programlisting">
SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>primary_key</code></em>=1;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>primary_key_part1</code></em>=1 AND <em class="replaceable"><code>primary_key_part2</code></em>=2;
</pre></li><li class="listitem"><p><a name="jointype_eq_ref"></a>
            <a class="indexterm" name="idm139979112890608"></a> <a class="indexterm" name="idm139979112888608"></a> <code class="literal">eq_ref</code>
          </p><p>
            前のテーブルの行の組み合わせごとに、このテーブルから 1 行ずつ読み取られます。<code class="literal">system</code> と <code class="literal">const</code> 型以外で、これは最適な結合型です。これは、結合でインデックスのすべてのパートが使用されており、インデックスが <code class="literal">PRIMARY KEY</code> または <code class="literal">UNIQUE NOT NULL</code> インデックスである場合に使用されます。
          </p><p>
            <code class="literal">eq_ref</code> は、<code class="literal">=</code> 演算子を使用して比較されるインデックス設定されたカラムに使用できます。比較値は、定数またはこのテーブルより前に読み取られたテーブルのカラムを使用する式を指定できます。次の例では、MySQL は <code class="literal">eq_ref</code> 結合を使用して、<em class="replaceable"><code>ref_table</code></em> を処理できます。
          </p><pre class="programlisting">
SELECT * FROM <em class="replaceable"><code>ref_table</code></em>,<em class="replaceable"><code>other_table</code></em>
  WHERE <em class="replaceable"><code>ref_table</code></em>.<em class="replaceable"><code>key_column</code></em>=<em class="replaceable"><code>other_table</code></em>.<em class="replaceable"><code>column</code></em>;

SELECT * FROM <em class="replaceable"><code>ref_table</code></em>,<em class="replaceable"><code>other_table</code></em>
  WHERE <em class="replaceable"><code>ref_table</code></em>.<em class="replaceable"><code>key_column_part1</code></em>=<em class="replaceable"><code>other_table</code></em>.<em class="replaceable"><code>column</code></em>
  AND <em class="replaceable"><code>ref_table</code></em>.<em class="replaceable"><code>key_column_part2</code></em>=1;
</pre></li><li class="listitem"><p><a name="jointype_ref"></a>
            <a class="indexterm" name="idm139979112868960"></a> <a class="indexterm" name="idm139979112867024"></a> <code class="literal">ref</code>
          </p><p>
            前のテーブルの行の組み合わせごとに、一致するインデックス値を持つすべての行がこのテーブルから読み取られます。<code class="literal">ref</code> は、結合でキーの左端のプリフィクスのみが使用される場合、またはキーが <code class="literal">PRIMARY KEY</code> や <code class="literal">UNIQUE</code> インデックスではない場合 (つまり、結合で、キー値に基づいて単一の行を選択できない場合) に使用されます。使用されているキーがほんの数行にしか一致しない場合、これは適切な結合型です。
          </p><p>
            <code class="literal">ref</code> は、<code class="literal">=</code> または <code class="literal">&lt;=&gt;</code> 演算子を使用して比較されるインデックス設定されたカラムに使用できます。次の例では、MySQL は <code class="literal">ref</code> 結合を使用して、<em class="replaceable"><code>ref_table</code></em> を処理できます。
          </p><pre class="programlisting">
SELECT * FROM <em class="replaceable"><code>ref_table</code></em> WHERE <em class="replaceable"><code>key_column</code></em>=<em class="replaceable"><code>expr</code></em>;

SELECT * FROM <em class="replaceable"><code>ref_table</code></em>,<em class="replaceable"><code>other_table</code></em>
  WHERE <em class="replaceable"><code>ref_table</code></em>.<em class="replaceable"><code>key_column</code></em>=<em class="replaceable"><code>other_table</code></em>.<em class="replaceable"><code>column</code></em>;

SELECT * FROM <em class="replaceable"><code>ref_table</code></em>,<em class="replaceable"><code>other_table</code></em>
  WHERE <em class="replaceable"><code>ref_table</code></em>.<em class="replaceable"><code>key_column_part1</code></em>=<em class="replaceable"><code>other_table</code></em>.<em class="replaceable"><code>column</code></em>
  AND <em class="replaceable"><code>ref_table</code></em>.<em class="replaceable"><code>key_column_part2</code></em>=1;
</pre></li><li class="listitem"><p><a name="jointype_fulltext"></a>
            <a class="indexterm" name="idm139979112845520"></a> <a class="indexterm" name="idm139979112843520"></a> <code class="literal">fulltext</code>
          </p><p>
            結合は <code class="literal">FULLTEXT</code> インデックスを使用して実行されます。
          </p></li><li class="listitem"><p><a name="jointype_ref_or_null"></a>
            <a class="indexterm" name="idm139979112837936"></a> <a class="indexterm" name="idm139979112835936"></a> <code class="literal">ref_or_null</code>
          </p><p>
            この結合型は、<code class="literal">ref</code> と似ていますが、MySQL が <code class="literal">NULL</code> 値を含む行の追加検索を実行することが追加されます。この結合型の最適化は、ほとんどの場合に、サブクエリーの解決で使用されます。次の例では、MySQL は <code class="literal">ref_or_null</code> 結合を使用して、<em class="replaceable"><code>ref_table</code></em> を処理できます。
          </p><pre class="programlisting">
SELECT * FROM <em class="replaceable"><code>ref_table</code></em>
  WHERE <em class="replaceable"><code>key_column</code></em>=<em class="replaceable"><code>expr</code></em> OR <em class="replaceable"><code>key_column</code></em> IS NULL;
</pre><p>
            <a class="xref" href="optimization.html#is-null-optimization" title="8.2.1.8 IS NULL の最適化">セクション8.2.1.8「IS NULL の最適化」</a>を参照してください。
          </p></li><li class="listitem"><p><a name="jointype_index_merge"></a>
            <a class="indexterm" name="idm139979112823856"></a> <a class="indexterm" name="idm139979112821856"></a> <code class="literal">index_merge</code>
          </p><p>
            この結合型はインデックスマージ最適化が使用されたことを示します。この場合、出力行の <code class="literal">key</code> カラムには使用されたインデックスのリストが含まれ、<code class="literal">key_len</code> には使用されたインデックスの最長キーパートのリストが含まれます。詳細については、<a class="xref" href="optimization.html#index-merge-optimization" title="8.2.1.4 インデックスマージの最適化">セクション8.2.1.4「インデックスマージの最適化」</a>を参照してください。
          </p></li><li class="listitem"><p><a name="jointype_unique_subquery"></a>
            <a class="indexterm" name="idm139979112814304"></a> <a class="indexterm" name="idm139979112812272"></a> <code class="literal">unique_subquery</code>
          </p><p>
            この型は、次の形式の <code class="literal">IN</code> サブクエリーの <code class="literal">ref</code> を置き換えます。
          </p><pre class="programlisting">
<em class="replaceable"><code>value</code></em> IN (SELECT <em class="replaceable"><code>primary_key</code></em> FROM <em class="replaceable"><code>single_table</code></em> WHERE <em class="replaceable"><code>some_expr</code></em>)
</pre><p>
            <code class="literal">unique_subquery</code> は、効率化のため、サブクエリーを完全に置き換える単なるインデックスルックアップ関数です。
          </p></li><li class="listitem"><p><a name="jointype_index_subquery"></a>
            <a class="indexterm" name="idm139979112801696"></a> <a class="indexterm" name="idm139979112799696"></a> <code class="literal">index_subquery</code>
          </p><p>
            この結合型は <code class="literal">unique_subquery</code> に似ています。<code class="literal">IN</code> サブクエリーを置き換えますが、次の形式のサブクエリー内の一意でないインデックスに対して機能します。
          </p><pre class="programlisting">
<em class="replaceable"><code>value</code></em> IN (SELECT <em class="replaceable"><code>key_column</code></em> FROM <em class="replaceable"><code>single_table</code></em> WHERE <em class="replaceable"><code>some_expr</code></em>)
</pre></li><li class="listitem"><p><a name="jointype_range"></a>
            <a class="indexterm" name="idm139979112790480"></a> <a class="indexterm" name="idm139979112788480"></a> <code class="literal">range</code>
          </p><p>
            行を選択するためのインデックスを使用して、特定の範囲にある行のみが取得されます。出力行の <code class="literal">key</code> カラムは、使用されるインデックスを示します。<code class="literal">key_len</code> には使用された最長のインデックスパートが格納されます。この型の <code class="literal">ref</code> カラムは <code class="literal">NULL</code> です。
          </p><p>
            <code class="literal">range</code> は、<code class="literal">=</code>、<code class="literal">&lt;&gt;</code>、<code class="literal">&gt;</code>、<code class="literal">&gt;=</code>、<code class="literal">&lt;</code>、<code class="literal">&lt;=</code>、<code class="literal">IS NULL</code>、<code class="literal">&lt;=&gt;</code>、<code class="literal">BETWEEN</code>、または <code class="literal">IN()</code> 演算子のいずれかを使用して、キーカラムを定数と比較する場合に使用できます。
          </p><pre class="programlisting">
SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_column</code></em> = 10;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_column</code></em> BETWEEN 10 and 20;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_column</code></em> IN (10,20,30);

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_part1</code></em> = 10 AND <em class="replaceable"><code>key_part2</code></em> IN (10,20,30);
</pre></li><li class="listitem"><p><a name="jointype_index"></a>
            <a class="indexterm" name="idm139979112762496"></a> <a class="indexterm" name="idm139979112760496"></a> <code class="literal">index</code>
          </p><p>
            <code class="literal">index</code> 結合型は、インデックスツリーがスキャンされることを除いて、<code class="literal">ALL</code> と同じです。これは 2 つの方法で行われます。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                インデックスがクエリーのカバリングインデックスで、使用すると、テーブルから必要なすべてのデータを満たすことができる場合、インデックスツリーのみがスキャンされます。この場合、<code class="literal">Extra</code> カラムには <code class="literal">Using index</code> と示されます。インデックスのサイズは通常テーブルデータより小さいため、インデックスのみのスキャンは通常、<code class="literal">ALL</code> より高速です。
              </p></li><li class="listitem"><p>
                フルテーブルスキャンは、インデックスからの読み取りを使用して、インデックス順でデータ行をルックアップして実行されます。<code class="literal">Extra</code> カラムに <code class="literal">Uses index</code> が表示されません。
              </p></li></ul></div><p>
            MySQL は、クエリーで単一のインデックスの一部であるカラムのみが使用されている場合に、この結合型を使用できます。
          </p></li><li class="listitem"><p><a name="jointype_all"></a>
            <a class="indexterm" name="idm139979112745904"></a> <a class="indexterm" name="idm139979112743968"></a> <code class="literal">ALL</code>
          </p><p>
            フルテーブルスキャンは、前のテーブルの行の組み合わせごとに実行されます。これは、通常テーブルが <code class="literal">const</code> とマークされていない最初のテーブルである場合には適しておらず、通常ほかのすべてのケースで<span class="emphasis"><em>著しく</em></span>不適切です。通常、定数値または以前のテーブルからのカラム値に基づいて、テーブルからの行の取得を可能にするインデックスを追加することで、<code class="literal">ALL</code> を回避できます。
          </p></li></ul></div><h4><a name="explain-extra-information"></a>EXPLAIN の追加情報</h4><p>
        <code class="literal">EXPLAIN</code> 出力の <code class="literal">Extra</code> カラムには、MySQL がクエリーを解決する方法に関する追加情報が含まれます。次のリストに、このカラムに表示される可能性のある値について説明します。クエリーを可能なかぎり高速にしたい場合は、<code class="literal">Using filesort</code> および <code class="literal">Using temporary</code> の <code class="literal">Extra</code> 値に注意します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Child of '<em class="replaceable"><code>table</code></em>' pushed join@1</code>
          </p><p>
            このテーブルは、NDB カーネルにプッシュダウンできる結合内の <em class="replaceable"><code>table</code></em> の子として参照されます。MySQL Cluster で、プッシュダウンされた結合が有効な場合にのみ適用されます。詳細と例については、<code class="literal">ndb_join_pushdown</code> サーバーシステム変数の説明を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">const row not found</code>
          </p><p>
            <code class="literal">SELECT ... FROM <em class="replaceable"><code>tbl_name</code></em></code> などのクエリーの場合、テーブルは空でした。
          </p></li><li class="listitem"><p>
            <code class="literal">Deleting all rows</code>
          </p><p>
            <code class="literal">DELETE</code> に対し、一部のストレージエンジン (<code class="literal">MyISAM</code> など) は簡単で高速にすべての行テーブルを削除するハンドラメソッドをサポートしています。この <code class="literal">Extra</code> 値は、エンジンでこの最適化が使用された場合に表示されます。
          </p></li><li class="listitem"><p>
            <code class="literal">Distinct</code>
          </p><p>
            MySQL は個別の値を検索するため、最初に一致する行が見つかったら、現在の行の組み合わせについてのそれ以上の行の検索を停止します。
          </p></li><li class="listitem"><p>
            <code class="literal">FirstMatch(<em class="replaceable"><code>tbl_name</code></em>)</code>
          </p><p>
            <em class="replaceable"><code>tbl_name</code></em> には、準結合 FirstMatch 結合ショートカット戦略が使用されます。
          </p></li><li class="listitem"><p>
            <code class="literal">Full scan on NULL key</code>
          </p><p>
            これは、オプティマイザがインデックスルックアップアクセスメソッドを使用できない場合の代替の戦略として、サブクエリーの最適化で行われます。
          </p></li><li class="listitem"><p>
            <code class="literal">Impossible HAVING</code>
          </p><p>
            <code class="literal">HAVING</code> 句は常に false で、どの行も選択できません。
          </p></li><li class="listitem"><p>
            <code class="literal">Impossible WHERE</code>
          </p><p>
            <code class="literal">WHERE</code> 句は常に false で、どの行も選択できません。
          </p></li><li class="listitem"><p>
            <code class="literal">Impossible WHERE noticed after reading const tables</code>
          </p><p>
            MySQL はすべての <code class="literal">const</code> (および <code class="literal">system</code>) テーブルを読み取り、<code class="literal">WHERE</code> 句が常に false であることを通知します。
          </p></li><li class="listitem"><p>
            <code class="literal">LooseScan(<em class="replaceable"><code>m</code></em>..<em class="replaceable"><code>n</code></em>)</code>
          </p><p>
            準結合 LooseScan 戦略が使用されます。<em class="replaceable"><code>m</code></em> と <em class="replaceable"><code>n</code></em> はキーパート番号です。
          </p></li><li class="listitem"><p>
            <code class="literal">Materialize</code>、<code class="literal">Scan</code>
          </p><p>
            MySQL 5.6.7 より前では、これは単一の実体化された一時テーブルの使用を示します。<code class="literal">Scan</code> が存在する場合、テーブルの読み取りに一時テーブルインデックスは使用されません。そうでない場合は、インデックスルックアップが使用されます。さらに、<code class="literal">Start materialize</code> エントリも参照してください。
          </p><p>
            MySQL 5.6.7 現在、実体化は、<code class="literal">MATERIALIZED</code> の <code class="literal">select_type</code> 値のある行と、<code class="literal">&lt;subquery<em class="replaceable"><code>N</code></em>&gt;</code> の <code class="literal">table</code> 値のある行によって示されます。
          </p></li><li class="listitem"><p>
            <code class="literal">No matching min/max row</code>
          </p><p>
            <code class="literal">SELECT MIN(...) FROM ... WHERE <em class="replaceable"><code>condition</code></em></code> などのクエリーの条件を満たす行がありません。
          </p></li><li class="listitem"><p>
            <code class="literal">no matching row in const table</code>
          </p><p>
            結合のあるクエリーで、空のテーブルまたは一意のインデックス条件を満足する行がないテーブルがありました。
          </p></li><li class="listitem"><p>
            <code class="literal">No matching rows after partition pruning</code>
          </p><p>
            <code class="literal">DELETE</code> または <code class="literal">UPDATE</code> に対し、オプティマイザはパーティションのプルーニング後に削除または更新するものが何も見つかりませんでした。それは、<code class="literal">SELECT</code> ステートメントの <code class="literal">Impossible WHERE</code> に意味が似ています。
          </p></li><li class="listitem"><p>
            <code class="literal">No tables used</code>
          </p><p>
            クエリーに <code class="literal">FROM</code> 句がないか、<code class="literal">FROM DUAL</code> 句があります。
          </p><p>
            <code class="literal">INSERT</code> または <code class="literal">REPLACE</code> ステートメントで、<code class="literal">SELECT</code> パートがない場合に、<code class="literal">EXPLAIN</code> にこの値が表示されます。たとえば、<code class="literal">EXPLAIN INSERT INTO t VALUES(10)</code> に対して、それは <code class="literal">EXPLAIN INSERT INTO t SELECT 10 FROM DUAL</code> と同等であるために表示されます。
          </p></li><li class="listitem"><p>
            <code class="literal">Not exists</code>
          </p><p>
            MySQL はクエリーに対する <code class="literal">LEFT JOIN</code> 最適化を実行でき、<code class="literal">LEFT JOIN</code> 条件に一致する 1 つの行が見つかったら、前の行の組み合わせについて、このテーブルでそれ以上の行を調査しません。これは、このように最適化できるクエリーの種類の例です。
          </p><pre class="programlisting">
SELECT * FROM t1 LEFT JOIN t2 ON t1.id=t2.id
  WHERE t2.id IS NULL;
</pre><p>
            <code class="literal">t2.id</code> が <code class="literal">NOT NULL</code> で定義されているとします。この場合、MySQL は <code class="literal">t1</code> をスキャンし、<code class="literal">t1.id</code> の値を使用して <code class="literal">t2</code> 内の行をルックアップします。MySQL が <code class="literal">t2</code> 内に一致する行を見つけた場合、<code class="literal">t2.id</code> は <code class="literal">NULL</code> にならないことがわかっているため、同じ <code class="literal">id</code> 値を持つ <code class="literal">t2</code> 内の残りの行をスキャンしません。つまり、<code class="literal">t1</code> の各行について、MySQL は、<code class="literal">t2</code> 内の実際に一致する行数にかかわらず、<code class="literal">t2</code> 内の単一のルックアップのみを実行する必要があります。
          </p></li><li class="listitem"><p>
            <code class="literal">Range checked for each record (index map: <em class="replaceable"><code>N</code></em>)</code>
          </p><p>
            MySQL は使用に適したインデックスを見つけられませんでしたが、前のテーブルからのカラム値がわかったあとに、いくつかのインデックスが使用できることがわかりました。以前のテーブルの行の組み合わせごとに、MySQL は <code class="literal">range</code> または <code class="literal">index_merge</code> アクセスメソッドを使用して、行を取得できるかどうかをチェックします。これは、非常に高速ではありませんが、インデックスがまったくない結合の実行より高速です。前のテーブルのすべてのカラム値がわかっており、定数とみなされることを除き、適用基準は、<a class="xref" href="optimization.html#range-optimization" title="8.2.1.3 range の最適化">セクション8.2.1.3「range の最適化」</a>と<a class="xref" href="optimization.html#index-merge-optimization" title="8.2.1.4 インデックスマージの最適化">セクション8.2.1.4「インデックスマージの最適化」</a>で説明されているとおりです。
          </p><p>
            インデックスは、テーブルの <code class="literal">SHOW INDEX</code> に示される同じ順序で 1 から番号付けされます。インデックスマップ値 <em class="replaceable"><code>N</code></em> は、候補となるインデックスを示すビットマスク値です。たとえば、<code class="literal">0x19</code> (2 進数の 11001) の値は、インデックス 1、4、および 5 が考慮されることを示します。
          </p></li><li class="listitem"><p>
            <code class="literal">Scanned <em class="replaceable"><code>N</code></em> databases</code>
          </p><p>
            これは、<a class="xref" href="optimization.html#information-schema-optimization" title="8.2.4 INFORMATION_SCHEMA クエリーの最適化">セクション8.2.4「INFORMATION_SCHEMA クエリーの最適化」</a>に説明するように、サーバーが <code class="literal">INFORMATION_SCHEMA</code> テーブルのクエリーを処理する際に実行するディレクトリスキャンの数を示します。<em class="replaceable"><code>N</code></em> の値は 0、1、または <code class="literal">all</code> です。
          </p></li><li class="listitem"><p>
            <code class="literal">Select tables optimized away</code>
          </p><p>
            クエリーにはすべてインデックスを使用して解決された集約関数 (<code class="literal">MIN()</code>、<code class="literal">MAX()</code>)、または <code class="literal">COUNT(*)</code> のみが含まれていますが、<code class="literal">GROUP BY</code> 句は含まれていませんでした。オプティマイザは 1 行のみを返すべきであると判断しました。
          </p></li><li class="listitem"><p>
            <code class="literal">Skip_open_table</code>、<code class="literal">Open_frm_only</code>、<code class="literal">Open_trigger_only</code>、<code class="literal">Open_full_table</code>
          </p><p>
            これらの値は、<a class="xref" href="optimization.html#information-schema-optimization" title="8.2.4 INFORMATION_SCHEMA クエリーの最適化">セクション8.2.4「INFORMATION_SCHEMA クエリーの最適化」</a>に説明するように、<code class="literal">INFORMATION_SCHEMA</code> テーブルに対するクエリーに適用するファイルオープン最適化を示します。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">Skip_open_table</code>: テーブルファイルを開く必要はありません。データベースディレクトリをスキャンすることによって、クエリー内ですでに情報を使用できるようになっています。
              </p></li><li class="listitem"><p>
                <code class="literal">Open_frm_only</code>: テーブルの <code class="filename">.frm</code> ファイルのみを開く必要があります。
              </p></li><li class="listitem"><p>
                <code class="literal">Open_trigger_only</code>: テーブルの <code class="filename">.TRG</code> ファイルのみを開く必要があります。
              </p></li><li class="listitem"><p>
                <code class="literal">Open_full_table</code>: 最適化されていない情報のルックアップ。<code class="filename">.frm</code>、<code class="filename">.MYD</code>、および <code class="filename">.MYI</code> ファイルを開く必要があります。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">Start materialize</code>、<code class="literal">End materialize</code>、<code class="literal">Scan</code>
          </p><p>
            MySQL 5.6.7 より前では、これは複数の実体化された一時テーブルの使用を示します。<code class="literal">Scan</code> が存在する場合、テーブルの読み取りに一時テーブルインデックスは使用されません。そうでない場合は、インデックスルックアップが使用されます。さらに、<code class="literal">Materialize</code> エントリも参照してください。
          </p><p>
            MySQL 5.6.7 現在、実体化は、<code class="literal">MATERIALIZED</code> の <code class="literal">select_type</code> 値のある行と、<code class="literal">&lt;subquery<em class="replaceable"><code>N</code></em>&gt;</code> の <code class="literal">table</code> 値のある行によって示されます。
          </p></li><li class="listitem"><p>
            <code class="literal">Start temporary</code>、<code class="literal">End temporary</code>
          </p><p>
            これは、準結合重複除去戦略の一時テーブルの使用を示します。
          </p></li><li class="listitem"><p>
            <code class="literal">unique row not found</code>
          </p><p>
            <code class="literal">SELECT ... FROM <em class="replaceable"><code>tbl_name</code></em></code> などのクエリーの場合に、テーブルに <code class="literal">UNIQUE</code> インデックスまたは <code class="literal">PRIMARY KEY</code> の条件を満たす行がありません。
          </p></li><li class="listitem"><p>
            <code class="literal">Using filesort</code>
          </p><p>
            MySQL はソート順で行を取得する方法を見つけるために、追加のパスを実行する必要があります。ソートは、結合型に従ってすべての行を進み、ソートキーと <code class="literal">WHERE</code> 句に一致するすべての行について行へのポインタを格納して実行されます。次にキーがソートされ、ソート順で行が取得されます。<a class="xref" href="optimization.html#order-by-optimization" title="8.2.1.15 ORDER BY の最適化">セクション8.2.1.15「ORDER BY の最適化」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">Using index</code>
          </p><p>
            実際の行を読み取るための追加のシークを実行する必要がなく、インデックスツリーの情報のみを使用して、テーブルからカラム情報が取得されます。この戦略は、クエリーで単一のインデックスの一部であるカラムのみを使用している場合に使用できます。
          </p><p>
            <code class="literal">Extra</code> カラムに <code class="literal">Using where</code> とも示されている場合、キー値のルックアップを実行するためにインデックスが使用されていることを意味します。<code class="literal">Using where</code> がない場合、オプティマイザはインデックスを読み取って、データ行の読み取りを回避できますが、それをルックアップに使用していません。たとえば、インデックスがクエリーのカバリングインデックスである場合、オプティマイザはそれをルックアップに使用せずにそれをスキャンできます。
          </p><p>
            ユーザー定義のクラスタ化されたインデックスを持つ <code class="literal">InnoDB</code> テーブルの場合、そのインデックスは <code class="literal">Extra</code> カラムに <code class="literal">Using index</code> がない場合でも使用できます。これは、<code class="literal">type</code> が <code class="literal">index</code> で <code class="literal">key</code> が <code class="literal">PRIMARY</code> の場合です。
          </p></li><li class="listitem"><p>
            <code class="literal">Using index condition</code>
          </p><p>
            インデックスタプルにアクセスし、まずそれらをテストして、すべてのテーブル行を読み取るかどうかを判断することによって、テーブルが読み取られます。このように、必要でないかぎり、すべてのテーブル行の読み取りを遅延 (<span class="quote">「<span class="quote">プッシュダウン</span>」</span>) するためにインデックス情報が使用されます。<a class="xref" href="optimization.html#index-condition-pushdown-optimization" title="8.2.1.6 インデックスコンディションプッシュダウンの最適化">セクション8.2.1.6「インデックスコンディションプッシュダウンの最適化」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">Using index for group-by</code>
          </p><p>
            <code class="literal">Using index</code> テーブルアクセスメソッドと同様に、<code class="literal">Using index for group-by</code> は MySQL が、実際のテーブルへの追加のディスクアクセスをせずに、<code class="literal">GROUP BY</code> または <code class="literal">DISTINCT</code> クエリーのすべてのカラムを取得するために使用できるインデックスを見つけたことを示します。さらに、各グループに対して、少数のインデックスエントリだけが読み取られるように、インデックスがもっとも効率的に使われます。詳細については、<a class="xref" href="optimization.html#group-by-optimization" title="8.2.1.16 GROUP BY の最適化">セクション8.2.1.16「GROUP BY の最適化」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">Using join buffer (Block Nested Loop)</code>、<code class="literal">Using join buffer (Batched Key Access)</code>
          </p><p>
            初期の結合からのテーブルは、部分ごとに結合バッファーに読み込まれ、それらの行がバッファーから使用されて、現在のテーブルとの結合が実行されます。<code class="literal">(Block Nested Loop)</code> は Block Nested Loop アルゴリズムの使用を示し、<code class="literal">(Batched Key Access)</code> は Batched Key Access アルゴリズムの使用を示します。つまり、<code class="literal">EXPLAIN</code> 出力の前の行のテーブルからのキーがバッファリングされ、<code class="literal">Using join buffer</code> が表示された行によって表されるテーブルから、一致する行が一括してフェッチされます。
          </p></li><li class="listitem"><p>
            <code class="literal">Using MRR</code>
          </p><p>
            テーブルは Multi-Range Read 最適化戦略を使用して読み取られます。<a class="xref" href="optimization.html#mrr-optimization" title="8.2.1.13 Multi-Range Read の最適化">セクション8.2.1.13「Multi-Range Read の最適化」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">Using sort_union(...)</code>、<code class="literal">Using union(...)</code>、<code class="literal">Using intersect(...)</code>
          </p><p>
            これらは <code class="literal">index_merge</code> 結合型でインデックススキャンがどのようにマージされるかを示しています。<a class="xref" href="optimization.html#index-merge-optimization" title="8.2.1.4 インデックスマージの最適化">セクション8.2.1.4「インデックスマージの最適化」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">Using temporary</code>
          </p><p>
            クエリーを解決するために、MySQL は結果を保持する一時テーブルを作成する必要があります。これは一般に、クエリーに、カラムを異なって一覧表示する <code class="literal">GROUP BY</code> 句と <code class="literal">ORDER BY</code> 句が含まれる場合に発生します。
          </p></li><li class="listitem"><p>
            <code class="literal">Using where</code>
          </p><p>
            <code class="literal">WHERE</code> 句は、次のテーブルに対して照合されるか、またはクライアントに送信される行を制限するために使用されます。具体的にテーブルからすべての行をフェッチするか、調査する意図がないかぎり、<code class="literal">Extra</code> 値が <code class="literal">Using where</code> でなく、テーブル結合型が <code class="literal">ALL</code> または <code class="literal">index</code> である場合、クエリーに何らかの誤りがある可能性があります。
          </p></li><li class="listitem"><p>
            <code class="literal">Using where with pushed condition</code>
          </p><p>
            この項目は <code class="literal">NDB</code> テーブル<span class="emphasis"><em>のみ</em></span>に適用されます。つまり、MySQL Cluster がコンディションプッシュダウン最適化を使用して、インデックス設定されていないカラムと定数の直接比較の効率を向上します。そのような場合、条件がクラスタのデータノードに<span class="quote">「<span class="quote">プッシュダウン</span>」</span>され、すべてのデータノードで同時に評価されます。これにより、一致しない行をネットワーク経由で送る必要がなくなり、コンディションプッシュダウンを使用できるが使用しない場合より、そのようなクエリーを 5 - 10 倍高速化できます。詳細については、<a class="xref" href="optimization.html#condition-pushdown-optimization" title="8.2.1.5 エンジンコンディションプッシュダウンの最適化">セクション8.2.1.5「エンジンコンディションプッシュダウンの最適化」</a>を参照してください。
          </p></li></ul></div><h4><a name="explain-output-interpretation"></a>EXPLAIN 出力の解釈</h4><p>
        <code class="literal">EXPLAIN</code> 出力の <code class="literal">rows</code> カラムの値の積を取得することで、結合がどの程度適しているかを示す適切な目安を得ることができます。これは、クエリーを実行するために MySQL が調査する必要がある行数を大ざっぱに示すはずです。<code class="literal">max_join_size</code> システム変数によってクエリーを制限する場合、この行の積は、どの複数テーブル <code class="literal">SELECT</code> ステートメントを実行し、どれを中止するかを判断するためにも使用されます。<a class="xref" href="optimization.html#server-parameters" title="8.11.2 サーバーパラメータのチューニング">セクション8.11.2「サーバーパラメータのチューニング」</a>を参照してください。
      </p><p>
        次の例は、<code class="literal">EXPLAIN</code> によって得られた情報に基づいて、複数テーブル結合を段階的に最適化する方法を示しています。
      </p><p>
        ここに示す <code class="literal">SELECT</code> ステートメントがあり、<code class="literal">EXPLAIN</code> を使用して調査するつもりであるとします。
      </p><pre class="programlisting">
EXPLAIN SELECT tt.TicketNumber, tt.TimeIn,
               tt.ProjectReference, tt.EstimatedShipDate,
               tt.ActualShipDate, tt.ClientID,
               tt.ServiceCodes, tt.RepetitiveID,
               tt.CurrentProcess, tt.CurrentDPPerson,
               tt.RecordVolume, tt.DPPrinted, et.COUNTRY,
               et_1.COUNTRY, do.CUSTNAME
        FROM tt, et, et AS et_1, do
        WHERE tt.SubmitTime IS NULL
          AND tt.ActualPC = et.EMPLOYID
          AND tt.AssignedPC = et_1.EMPLOYID
          AND tt.ClientID = do.CUSTNMBR;
</pre><p>
        この例では次のように想定しています。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            比較対象のカラムは次のように宣言されています。
          </p><div class="informaltable"><table summary="この表は、先述の EXPLAIN の例で比較されているカラムのテーブル名、カラム名、データ型の概要を示しています。" border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">テーブル</th><th scope="col">カラム</th><th scope="col">データ型</th></tr></thead><tbody><tr><td scope="row"><code class="literal">tt</code></td><td><code class="literal">ActualPC</code></td><td><code class="literal">CHAR(10)</code></td></tr><tr><td scope="row"><code class="literal">tt</code></td><td><code class="literal">AssignedPC</code></td><td><code class="literal">CHAR(10)</code></td></tr><tr><td scope="row"><code class="literal">tt</code></td><td><code class="literal">ClientID</code></td><td><code class="literal">CHAR(10)</code></td></tr><tr><td scope="row"><code class="literal">et</code></td><td><code class="literal">EMPLOYID</code></td><td><code class="literal">CHAR(15)</code></td></tr><tr><td scope="row"><code class="literal">do</code></td><td><code class="literal">CUSTNMBR</code></td><td><code class="literal">CHAR(15)</code></td></tr></tbody></table></div></li><li class="listitem"><p>
            テーブルには次のインデックスがあります。
          </p><div class="informaltable"><table summary="この表は先述の EXPLAIN の例の一部である各テーブルのインデックスを一覧表示しています。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">テーブル</th><th scope="col">インデックス</th></tr></thead><tbody><tr><td scope="row"><code class="literal">tt</code></td><td><code class="literal">ActualPC</code></td></tr><tr><td scope="row"><code class="literal">tt</code></td><td><code class="literal">AssignedPC</code></td></tr><tr><td scope="row"><code class="literal">tt</code></td><td><code class="literal">ClientID</code></td></tr><tr><td scope="row"><code class="literal">et</code></td><td><code class="literal">EMPLOYID</code> (主キー)</td></tr><tr><td scope="row"><code class="literal">do</code></td><td><code class="literal">CUSTNMBR</code> (主キー)</td></tr></tbody></table></div></li><li class="listitem"><p>
            <code class="literal">tt.ActualPC</code> 値は均一に分布されていません。
          </p></li></ul></div><p>
        最初、最適化が実行される前は、<code class="literal">EXPLAIN</code> ステートメントで次の情報が生成されました。
      </p><pre class="programlisting">
table type possible_keys key  key_len ref  rows  Extra
et    ALL  PRIMARY       NULL NULL    NULL 74
do    ALL  PRIMARY       NULL NULL    NULL 2135
et_1  ALL  PRIMARY       NULL NULL    NULL 74
tt    ALL  AssignedPC,   NULL NULL    NULL 3872
           ClientID,
           ActualPC
      Range checked for each record (index map: 0x23)
</pre><p>
        各テーブルの <code class="literal">type</code> は <code class="literal">ALL</code> であるため、この出力は MySQL がすべてのテーブル、つまりすべての行の組み合わせのデカルト積を生成することを示しています。これは、各テーブルの行数の積を調査する必要があるため、著しく時間がかかります。このケースの場合は、この積が 74 × 2135 × 74 × 3872 = 45,268,558,720 行になります。テーブルがもっと大きければ、どのくらい時間がかかっていたか簡単に想像がつきます。
      </p><p>
        ここでの問題の 1 つは、カラムが同じ型とサイズで宣言されている場合に、MySQL はカラムに対してインデックスをより効率的に使用できることです。このコンテキストでは、<code class="literal">VARCHAR</code> と <code class="literal">CHAR</code> は同じサイズとして宣言されている場合、それらは同じとみなされます。<code class="literal">tt.ActualPC</code> は <code class="literal">CHAR(10)</code> として宣言されており、<code class="literal">et.EMPLOYID</code> は <code class="literal">CHAR(15)</code> であるため、長さの不一致があります。
      </p><p>
        このカラム長の不一致を修正するには、<code class="literal">ALTER TABLE</code> を使用して <code class="literal">ActualPC</code> を 10 文字から 15 文字に長くします。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>ALTER TABLE tt MODIFY ActualPC VARCHAR(15);</code></strong>
</pre><p>
        これで <code class="literal">tt.ActualPC</code> と <code class="literal">et.EMPLOYID</code> はいずれも <code class="literal">VARCHAR(15)</code> になります。<code class="literal">EXPLAIN</code> ステートメントを再度実行すると、次の結果が生成されます。
      </p><pre class="programlisting">
table type   possible_keys key     key_len ref         rows    Extra
tt    ALL    AssignedPC,   NULL    NULL    NULL        3872    Using
             ClientID,                                         where
             ActualPC
do    ALL    PRIMARY       NULL    NULL    NULL        2135
      Range checked for each record (index map: 0x1)
et_1  ALL    PRIMARY       NULL    NULL    NULL        74
      Range checked for each record (index map: 0x1)
et    eq_ref PRIMARY       PRIMARY 15      tt.ActualPC 1
</pre><p>
        これは完全ではありませんが、はるかに改善されています。<code class="literal">rows</code> 値の積は 74 の係数分だけ少なくなります。このバージョンは、数秒で実行します。
      </p><p>
        2 つめの変更を実行して、<code class="literal">tt.AssignedPC = et_1.EMPLOYID</code> と <code class="literal">tt.ClientID = do.CUSTNMBR</code> の比較でのカラム長の不一致を解消できます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>ALTER TABLE tt MODIFY AssignedPC VARCHAR(15),</code></strong>
    -&gt;                <strong class="userinput"><code>MODIFY ClientID   VARCHAR(15);</code></strong>
</pre><p>
        その変更後、<code class="literal">EXPLAIN</code> は次に示す出力を生成します。
      </p><pre class="programlisting">
table type   possible_keys key      key_len ref           rows Extra
et    ALL    PRIMARY       NULL     NULL    NULL          74
tt    ref    AssignedPC,   ActualPC 15      et.EMPLOYID   52   Using
             ClientID,                                         where
             ActualPC
et_1  eq_ref PRIMARY       PRIMARY  15      tt.AssignedPC 1
do    eq_ref PRIMARY       PRIMARY  15      tt.ClientID   1
</pre><p>
        この時点で、クエリーはほぼ可能なかぎり十分に最適化されています。残りの問題は、MySQL はデフォルトで <code class="literal">tt.ActualPC</code> カラムの値が均一に分布しているものと想定しますが、<code class="literal">tt</code> テーブルにはそれが当てはまらないことです。さいわい、MySQL にキー分布を分析するように伝えることは簡単です。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>ANALYZE TABLE tt;</code></strong>
</pre><p>
        追加のインデックス情報によって、結合が完全になり、<code class="literal">EXPLAIN</code> が次の結果を生成します。
      </p><pre class="programlisting">
table type   possible_keys key     key_len ref           rows Extra
tt    ALL    AssignedPC    NULL    NULL    NULL          3872 Using
             ClientID,                                        where
             ActualPC
et    eq_ref PRIMARY       PRIMARY 15      tt.ActualPC   1
et_1  eq_ref PRIMARY       PRIMARY 15      tt.AssignedPC 1
do    eq_ref PRIMARY       PRIMARY 15      tt.ClientID   1
</pre><p>
        <a class="indexterm" name="idm139979112451104"></a> <code class="literal">EXPLAIN</code> の出力の <code class="literal">rows</code> カラムは、MySQL 結合オプティマイザの学習による推測です。<code class="literal">rows</code> の積とクエリーが返す実際の行数を比較して、数値が実際と近いかどうかをチェックしてください。数値がかなり異なる場合は、<code class="literal">SELECT</code> ステートメントで <code class="literal">STRAIGHT_JOIN</code> を使用し、<code class="literal">FROM</code> 句で異なる順序でテーブルを一覧表示してみるとパフォーマンスを改善できる可能性があります。
      </p><p>
        場合によっては、サブクエリーで <code class="literal">EXPLAIN SELECT</code> を使用するときに、データを変更するステートメントを実行できることもあります。詳細については、<a class="xref" href="sql-syntax.html#from-clause-subqueries" title="13.2.10.8 FROM 句内のサブクエリー">セクション13.2.10.8「FROM 句内のサブクエリー」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="explain-extended"></a>8.8.3 EXPLAIN EXTENDED 出力フォーマット</h3></div></div></div><p>
        <code class="literal">EXPLAIN</code> を <code class="literal">EXTENDED</code> キーワードを付けて使用すると、出力に、ほかの場合に表示されない <code class="literal">filtered</code> カラムが含まれます。このカラムは、テーブル条件によってフィルタ処理されるテーブル行の推定の割合を示します。さらに、ステートメントは、<code class="literal">EXPLAIN</code> ステートメントに続けて <code class="literal">SHOW WARNINGS</code> ステートメントを発行することで表示できる追加の情報を生成します。<code class="literal">SHOW WARNINGS</code> 出力の <code class="literal">Message</code> 値には、オプティマイザが <code class="literal">SELECT</code> ステートメント内のテーブルおよびカラム名をどのように修飾するか、書き換えおよび最適化ルールの適用後に <code class="literal">SELECT</code> がどのように見えるか、および場合によって最適化プロセスに関するその他のメモが表示されます。
      </p><p>
        これは拡張された出力の例です。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>EXPLAIN EXTENDED</code></strong>
    -&gt; <strong class="userinput"><code>SELECT t1.a, t1.a IN (SELECT t2.a FROM t2) FROM t1\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: t1
         type: index
possible_keys: NULL
          key: PRIMARY
      key_len: 4
          ref: NULL
         rows: 4
     filtered: 100.00
        Extra: Using index
*************************** 2. row ***************************
           id: 2
  select_type: SUBQUERY
        table: t2
         type: index
possible_keys: a
          key: a
      key_len: 5
          ref: NULL
         rows: 3
     filtered: 100.00
        Extra: Using index
2 rows in set, 1 warning (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS\G</code></strong>
*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: /* select#1 */ select `test`.`t1`.`a` AS `a`,
         &lt;in_optimizer&gt;(`test`.`t1`.`a`,`test`.`t1`.`a` in
         ( &lt;materialize&gt; (/* select#2 */ select `test`.`t2`.`a`
         from `test`.`t2` where 1 having 1 ),
         &lt;primary_index_lookup&gt;(`test`.`t1`.`a` in
         &lt;temporary table&gt; on &lt;auto_key&gt;
         where ((`test`.`t1`.`a` = `materialized-subquery`.`a`))))) AS `t1.a
         IN (SELECT t2.a FROM t2)` from `test`.`t1`
1 row in set (0.00 sec)
</pre><p>
        MySQL 5.6.3 現在、<code class="literal">EXPLAIN EXTENDED</code> は <code class="literal">SELECT</code>、<code class="literal">DELETE</code>、<code class="literal">INSERT</code>、<code class="literal">REPLACE</code>、および <code class="literal">UPDATE</code> ステートメントで使用できます。ただし、次の <code class="literal">SHOW WARNINGS</code> ステートメントは、<code class="literal">SELECT</code> ステートメントに対してのみ、空でない結果を表示します。MySQL 5.6.3 より前では、<code class="literal">EXPLAIN EXTENDED</code> は <code class="literal">SELECT</code> ステートメントでのみ使用できます。
      </p><p>
        <code class="literal">SHOW WARNINGS</code> によって表示されるステートメントには、クエリーの書き換えやオプティマイザのアクションに関する情報を提供する特別なマーカーが含まれることがあるため、ステートメントは必ずしも有効な SQL ではなく、実行されることを目的としていません。出力には、オプティマイザによってとられたアクションに関する追加の SQL でない説明のメモを提供する <code class="literal">Message</code> 値のある行が含まれることもあります。
      </p><p>
        次のリストに、<code class="literal">SHOW WARNINGS</code> によって表示され、<code class="literal">EXTENDED</code> 出力に示される可能性がある特別なマーカーを説明します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">&lt;auto_key&gt;</code>
          </p><p>
            一時テーブルの自動的に生成されるキー。
          </p></li><li class="listitem"><p>
            <code class="literal">&lt;cache&gt;(<em class="replaceable"><code>expr</code></em>)</code>
          </p><p>
            式 (スカラーサブクエリーなど) が 1 回実行され、あとで使用するために、結果の値がメモリーに保存されます。複数の値から構成される結果の場合は、一時テーブルが作成されることがあり、代わりに <code class="literal">&lt;temporary table&gt;</code> が表示されます。
          </p></li><li class="listitem"><p>
            <code class="literal">&lt;exists&gt;(<em class="replaceable"><code>query fragment</code></em>)</code>
          </p><p>
            サブクエリー述語は <code class="literal">EXISTS</code> 述語に変換され、サブクエリーは <code class="literal">EXISTS</code> 述語と一緒に使用できるように変換されます。
          </p></li><li class="listitem"><p>
            <code class="literal">&lt;in_optimizer&gt;(<em class="replaceable"><code>query fragment</code></em>)</code>
          </p><p>
            これは、ユーザーにとっては意味がない内部オプティマイザオブジェクトです。
          </p></li><li class="listitem"><p>
            <code class="literal">&lt;index_lookup&gt;(<em class="replaceable"><code>query fragment</code></em>)</code>
          </p><p>
            対象の行を見つけるためにインデックスルックアップを使用して、クエリーフラグメントが処理されます。
          </p></li><li class="listitem"><p>
            <code class="literal">&lt;if&gt;(<em class="replaceable"><code>condition</code></em>, <em class="replaceable"><code>expr1</code></em>, <em class="replaceable"><code>expr2</code></em>)</code>
          </p><p>
            条件が true の場合は <em class="replaceable"><code>expr1</code></em>、そうでない場合は <em class="replaceable"><code>expr2</code></em> に評価されます。
          </p></li><li class="listitem"><p>
            <code class="literal">&lt;is_not_null_test&gt;(<em class="replaceable"><code>expr</code></em>)</code>
          </p><p>
            式が <code class="literal">NULL</code> に評価されないことを確認するためのテスト。
          </p></li><li class="listitem"><p>
            <code class="literal">&lt;materialize&gt;(<em class="replaceable"><code>query fragment</code></em>)</code>
          </p><p>
            サブクエリーの実体化が使用されます。
          </p></li><li class="listitem"><p>
            <code class="literal">`materialized-subquery`.<em class="replaceable"><code>col_name</code></em></code>, <code class="literal">`materialized subselect`.<em class="replaceable"><code>col_name</code></em></code>
          </p><p>
            サブクエリーの評価の結果を保持するために実体化された内部一時テーブル内のカラム <em class="replaceable"><code>col_name</code></em> への参照。
          </p></li><li class="listitem"><p>
            <code class="literal">&lt;primary_index_lookup&gt;(<em class="replaceable"><code>query fragment</code></em>)</code>
          </p><p>
            対象の行を見つけるために主キールックアップを使用して、クエリーフラグメントが処理されます。
          </p></li><li class="listitem"><p>
            <code class="literal">&lt;ref_null_helper&gt;(<em class="replaceable"><code>expr</code></em>)</code>
          </p><p>
            これは、ユーザーにとっては意味がない内部オプティマイザオブジェクトです。
          </p></li><li class="listitem"><p>
            <code class="literal">/* select#<em class="replaceable"><code>N</code></em> */ <em class="replaceable"><code>select_stmt</code></em></code>
          </p><p>
            <code class="literal">SELECT</code> は、<code class="literal">EXTENDED</code> <code class="literal">EXPLAIN</code> 以外の出力で、<em class="replaceable"><code>N</code></em> の <code class="literal">id</code> 値を持つ行に関連付けられます。
          </p></li><li class="listitem"><p>
            <code class="literal"><em class="replaceable"><code>outer_tables</code></em> semi join (<em class="replaceable"><code>inner_tables</code></em>)</code>
          </p><p>
            準結合操作。<em class="replaceable"><code>inner_tables</code></em> は、取り出されなかったテーブルを示します。<a class="xref" href="optimization.html#semi-joins" title="8.2.1.18.1 準結合変換によるサブクエリーの最適化">セクション8.2.1.18.1「準結合変換によるサブクエリーの最適化」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">&lt;temporary table&gt;</code>
          </p><p>
            これは、中間結果をキャッシュするために作成される内部一時テーブルを表します。
          </p></li></ul></div><p>
        一部のテーブルが <code class="literal">const</code> または <code class="literal">system</code> 型である場合、これらのテーブルからのカラムを含む式は、オプティマイザによって早期に評価され、表示されるステートメントに含まれません。ただし、<code class="literal">FORMAT=JSON</code> では、一部の <code class="literal">const</code> テーブルアクセスが定数値を使用する <code class="literal">ref</code> アクセスとして表示されます。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="estimating-performance"></a>8.8.4 クエリーパフォーマンスの推定</h3></div></div></div><a class="indexterm" name="idm139979112354608"></a><a class="indexterm" name="idm139979112352464"></a><a class="indexterm" name="idm139979112350400"></a><p>
        ほとんどの場合、ディスクシークをカウントしてクエリーパフォーマンスを推定できます。小さいテーブルの場合は一般に 1 回のディスクシークでレコードが見つかります (インデックスがキャッシュされている可能性が高いため)。大きなテーブルの場合、B ツリーインデックスを使用して、それを推定できますが、行を見つけるためにこのように多くのシークが必要です。<code class="literal">log(<em class="replaceable"><code>row_count</code></em>) / log(<em class="replaceable"><code>index_block_length</code></em> / 3 * 2 / (<em class="replaceable"><code>index_length</code></em> + <em class="replaceable"><code>data_pointer_length</code></em>)) + 1</code>。
      </p><p>
        MySQL では、インデックスブロックが通常 1,024 バイトで、データポインタは通常 4 バイトです。3 バイトのキー値長 (<code class="literal">MEDIUMINT</code> のサイズ) の 500,000 行のテーブルの場合、この公式は <code class="literal">log(500,000)/log(1024/3*2/(3+4)) + 1</code> = <code class="literal">4</code> シークを示します。
      </p><p>
        このインデックスには、約 500,000 * 7 * 3/2 = 5.2M バイト (2/3 の一般的なインデックスバッファー充てん率と想定して) のストレージが必要であるため、インデックスの多くをメモリーに置く可能性が高く、データを読み取り、行を見つけるために 1 つか 2 つの呼び出しだけで済みます。
      </p><p>
        ただし、書き込みについては、新しいインデックス値の配置場所を見つけるために 4 つのシークリクエスト、およびインデックスの更新と行の書き込みに通常 2 回のシークが必要になります。
      </p><p>
        前の説明は、アプリケーションのパフォーマンスが log <em class="replaceable"><code>N</code></em> ずつ徐々に低下することを意味しているわけではありません。OS または MySQL サーバーによってすべてがキャッシュされているかぎり、テーブルが大きくなってもほんの少し遅くなるだけです。データがキャッシュできないほど大きくなると、アプリケーションがディスクシーク (これは log <em class="replaceable"><code>N</code></em>N ずつ増加する) によってのみ制限されるまで著しく遅くなり始めます。これを回避するには、データの増加に合わせてキーキャッシュを増やします。<code class="literal">MyISAM</code> テーブルでは、キーキャッシュサイズは <code class="literal">key_buffer_size</code> システム変数によって制御されます。<a class="xref" href="optimization.html#server-parameters" title="8.11.2 サーバーパラメータのチューニング">セクション8.11.2「サーバーパラメータのチューニング」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="controlling-optimizer"></a>8.8.5 クエリーオプティマイザの制御</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#controlling-query-plan-evaluation">8.8.5.1 クエリー計画評価の制御</a></span></dt><dt><span class="section"><a href="optimization.html#switchable-optimizations">8.8.5.2 切り替え可能な最適化の制御</a></span></dt></dl></div><a class="indexterm" name="idm139979112333456"></a><p>
        MySQL では、クエリー計画の評価方法や有効にされている切り替え可能な最適化に影響するシステム変数によって、オプティマイザを制御します。
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="controlling-query-plan-evaluation"></a>8.8.5.1 クエリー計画評価の制御</h4></div></div></div><a class="indexterm" name="idm139979112329552"></a><p>
          クエリーオプティマイザのタスクは SQL クエリーを実行するために最適なプランを見つけることです。<span class="quote">「<span class="quote">良い</span>」</span>プランと<span class="quote">「<span class="quote">悪い</span>」</span>プランのパフォーマンスの差は、桁違い (つまり、数秒に対して数時間や数日にまで) になる可能性があるため、MySQL のオプティマイザを含むほとんどのクエリーオプティマイザは、多かれ少なかれ、すべての可能なクエリー評価プランの中から最適なプランを徹底的に探します。結合クエリーに対して、MySQL オプティマイザによって調査される可能なプランの数は、クエリーで参照されるテーブル数とともに指数関数的に増大します。少数のテーブル (一般に 7 から 10 未満) の場合、これは問題になりません。ただし、大きなクエリーが送信された場合、クエリーの最適化に費やされる時間が、サーバーのパフォーマンスの大きなボトルネックになりやすいことがあります。
        </p><p>
          クエリー最適化のより柔軟な方法により、ユーザーはオプティマイザが最適なクエリー評価プランをどの程度徹底的に探すかを制御できます。一般的な考えは、オプティマイザによって調査されるプランが少ないほど、クエリーのコンパイルに費やす時間も少なくなるということです。一方、オプティマイザは一部のプランをスキップするため、最適なプランを見逃す可能性もあります。
        </p><p>
          評価するプランの数に関して、オプティマイザの動作を 2 つのシステム変数を使用して制御できます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">optimizer_prune_level</code> 変数は、オプティマイザに、テーブルごとにアクセスされる行数の見積もりに基づいて、特定のプランをスキップするように伝えます。経験上、この種類の<span class="quote">「<span class="quote">学習による推測</span>」</span>は最適なプランをめったに見逃すことはなく、クエリーのコンパイル時間を劇的に短縮できます。デフォルトでこのオプションがオン <code class="literal">optimizer_prune_level=1</code> であるのはこのためです。ただし、オプティマイザがより適したクエリー計画を見逃したと思う場合は、クエリーのコンパイルにかなりの時間がかかるリスクを伴いますが、このオプションをオフにする (<code class="literal">optimizer_prune_level=0</code>) ことができます。この経験則を使用しても、オプティマイザはまだ指数関数的な数のプランを探索します。
            </p></li><li class="listitem"><p>
              <code class="literal">optimizer_search_depth</code> 変数は、オプティマイザがそれ以上拡張すべきかどうかを評価するために、不完全な各プランの<span class="quote">「<span class="quote">将来</span>」</span>をどの程度見通すかを伝えます。<code class="literal">optimizer_search_depth</code> の値を小さくするほど、クエリーのコンパイル時間が桁違いに少なくなる可能性があります。たとえば、12、13、またはそれ以上のテーブルのクエリーは、<code class="literal">optimizer_search_depth</code> がクエリー内のテーブル数に近い場合、コンパイルに数時間または数日間も容易に必要になることがあります。同時に、3 か 4 に等しい <code class="literal">optimizer_search_depth</code> でコンパイルされた場合、オプティマイザは同じクエリーで 1 分以内にコンパイルできることがあります。<code class="literal">optimizer_search_depth</code> の適切な値が不明な場合、この変数を 0 に設定することで、オプティマイザに自動的に値を決定させることができます。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="switchable-optimizations"></a>8.8.5.2 切り替え可能な最適化の制御</h4></div></div></div><a class="indexterm" name="idm139979112308432"></a><a class="indexterm" name="idm139979112306896"></a><p>
          <code class="literal">optimizer_switch</code> システム変数を使用するとオプティマイザの動作を制御できます。その値はフラグのセットで、それぞれ対応するオプティマイザの動作を有効にするかまたは無効にするかを示す <code class="literal">on</code> または <code class="literal">off</code> の値を持ちます。この変数はグローバル値およびセッション値を持ち、実行時に変更できます。グローバル値のデフォルトはサーバーの起動時に設定できます。
        </p><p>
          オプティマイザの現在のフラグセットを表示するには、変数値を選択します。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT @@optimizer_switch\G</code></strong>
*************************** 1. row ***************************
@@optimizer_switch: index_merge=on,index_merge_union=on,
                    index_merge_sort_union=on,
                    index_merge_intersection=on,
                    engine_condition_pushdown=on,
                    index_condition_pushdown=on,
                    mrr=on,mrr_cost_based=on,
                    block_nested_loop=on,batched_key_access=off,
                    materialization=on,semijoin=on,loosescan=on,
                    firstmatch=on,
                    subquery_materialization_cost_based=on,
                    use_index_extensions=on
</pre><p>
          <code class="literal">optimizer_switch</code> の値を変更するには、1 つ以上のコマンドのカンマ区切りのリストから構成される値を割り当てます。
        </p><pre class="programlisting">
SET [GLOBAL|SESSION] optimizer_switch='<em class="replaceable"><code>command</code></em>[,<em class="replaceable"><code>command</code></em>]...';
</pre><p>
          各 <em class="replaceable"><code>command</code></em> 値は、次の表に示すいずれかの形式になるようにしてください。
        </p><div class="informaltable"><table summary="この表は、SET optimizer_switch コマンドの command 値の構文を説明しています。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">コマンドの構文</th><th scope="col">意味</th></tr></thead><tbody><tr><td scope="row"><code class="literal">default</code></td><td>すべての最適化をそのデフォルト値にリセットします</td></tr><tr><td scope="row"><code class="literal"><em class="replaceable"><code>opt_name</code></em>=default</code></td><td>指定した最適化をそのデフォルト値に設定します</td></tr><tr><td scope="row"><code class="literal"><em class="replaceable"><code>opt_name</code></em>=off</code></td><td>指定した最適化を無効にします</td></tr><tr><td scope="row"><code class="literal"><em class="replaceable"><code>opt_name</code></em>=on</code></td><td>指定した最適化を有効にします</td></tr></tbody></table></div><p>
          <code class="literal">default</code> コマンドが存在する場合最初に実行されますが、値の中のコマンドの順序は問題ではありません。<em class="replaceable"><code>opt_name</code></em> フラグを <code class="literal">default</code> に設定すると、そのデフォルト値が <code class="literal">on</code> または <code class="literal">off</code> のどちらであってもそれに設定されます。値に特定の <em class="replaceable"><code>opt_name</code></em> を複数回指定することは許可されず、エラーが発生します。値のエラーによって、割り当てがエラーを伴って失敗し、<code class="literal">optimizer_switch</code> の値が変更されないままになります。
        </p><p>
          次の表に、最適化戦略別にグループ化した、許可される <em class="replaceable"><code>opt_name</code></em> フラグ名を一覧表示します。
        </p><div class="informaltable"><table summary="この表は、最適化戦略別にグループ化された、許可される opt_name フラグ名を一覧表示しています。" border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">最適化</th><th scope="col">フラグ名</th><th scope="col">意味</th></tr></thead><tbody><tr><td scope="row">Batched Key Access</td><td><code class="literal">batched_key_access</code></td><td>BKA 結合アルゴリズムの使用を制御します</td></tr><tr><td scope="row">Block Nested Loop</td><td><code class="literal">block_nested_loop</code></td><td>BNL 結合アルゴリズムの使用を制御します</td></tr><tr><td scope="row">エンジンコンディションプッシュダウン</td><td><code class="literal">engine_condition_pushdown</code></td><td>エンジンコンディションプッシュダウンを制御します</td></tr><tr><td scope="row">インデックスコンディションプッシュダウン</td><td><code class="literal">index_condition_pushdown</code></td><td>インデックスコンディションプッシュダウンを制御します</td></tr><tr><td scope="row">インデックス拡張</td><td><code class="literal">use_index_extensions</code></td><td>インデックス拡張の使用を制御します</td></tr><tr><td scope="row">インデックスマージ</td><td><code class="literal">index_merge</code></td><td>すべてのインデックスマージ最適化を制御します</td></tr><tr><td scope="row"> </td><td><code class="literal">index_merge_intersection</code></td><td>インデックスマージ共通集合アクセス最適化を制御します</td></tr><tr><td scope="row"> </td><td><code class="literal">index_merge_sort_union</code></td><td>インデックスマージソート和集合アクセス最適化を制御します</td></tr><tr><td scope="row"> </td><td><code class="literal">index_merge_union</code></td><td>インデックスマージ和集合アクセス最適化を制御します</td></tr><tr><td scope="row">Multi-Range Read</td><td><code class="literal">mrr</code></td><td>Multi-Range Read 戦略を制御します</td></tr><tr><td scope="row"> </td><td><code class="literal">mrr_cost_based</code></td><td><code class="literal">mrr=on</code> の場合にコストベースの MRR の使用を制御します</td></tr><tr><td scope="row">準結合</td><td><code class="literal">semijoin</code></td><td>すべての準結合戦略を制御します</td></tr><tr><td scope="row"> </td><td><code class="literal">firstmatch</code></td><td>準結合 FirstMatch 戦略を制御します</td></tr><tr><td scope="row"> </td><td><code class="literal">loosescan</code></td><td>準結合 LooseScan 戦略を制御します (<code class="literal">GROUP BY</code> の LooseScan と混同しないでください)</td></tr><tr><td scope="row">サブクエリー実体化</td><td><code class="literal">materialization</code></td><td>実体化を制御します (準結合実体化を含む)</td></tr><tr><td scope="row"> </td><td><code class="literal">subquery_materialization_cost_based</code></td><td>使用されたコストベースの実体化の選択</td></tr></tbody></table></div><p>
          <code class="literal">block_nested_loop</code> および <code class="literal">batched_key_access</code> フラグは MySQL 5.6.3 で追加されました。<code class="literal">batched_key_access</code> が <code class="literal">on</code> に設定されている場合に何らかの効果を持つためには、<code class="literal">mrr</code> フラグも <code class="literal">on</code> である必要があります。現在、MRR のコスト見積もりはきわめて悲観的です。したがって、BKA を使用するには、<code class="literal">mrr_cost_based</code> を <code class="literal">off</code> にする必要もあります。
        </p><p>
          <code class="literal">semijoin</code>、<code class="literal">firstmatch</code>、<code class="literal">loosescan</code>、および <code class="literal">materialization</code> フラグは MySQL 5.6.5 で、準結合およびサブクエリー実体化戦略を制御できるようにするために追加されました。<code class="literal">semijoin</code> フラグは準結合を使用するかどうかを制御します。これが <code class="literal">on</code> に設定されている場合、<code class="literal">firstmatch</code> および <code class="literal">loosescan</code> フラグによって、使用可能な準結合戦略を詳細に制御できます。<code class="literal">materialization</code> フラグはサブクエリー実体化を使用するかどうかを制御します。<code class="literal">semijoin</code> と <code class="literal">materialization</code> が両方とも <code class="literal">on</code> の場合、該当すれば準結合でも実体化が使用されます。これらのフラグはデフォルトで <code class="literal">on</code> です。
        </p><p>
          <code class="literal">subquery_materialization_cost_based</code> は、MySQL 5.6.7 で、サブクエリー実体化と <code class="literal">IN -&gt; EXISTS</code> サブクエリー変換の選択を制御できるようにするために追加されました。フラグが <code class="literal">on</code> (デフォルト) の場合、オプティマイザは、サブクエリー実体化と <code class="literal">IN -&gt; EXISTS</code> サブクエリー変換のどちらの方法も使用できる場合に、コストベースの選択を実行します。フラグが <code class="literal">off</code> の場合、オプティマイザは、MySQL 5.6.7 より前の動作だった <code class="literal">IN -&gt; EXISTS</code> サブクエリー変換より、サブクエリー実体化を選択します。
        </p><p>
          個々の最適化戦略の詳細については、次のセクションを参照してください。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <a class="xref" href="optimization.html#bnl-bka-optimization" title="8.2.1.14 Block Nested Loop 結合と Batched Key Access 結合">セクション8.2.1.14「Block Nested Loop 結合と Batched Key Access 結合」</a>
            </p></li><li class="listitem"><p>
              <a class="xref" href="optimization.html#condition-pushdown-optimization" title="8.2.1.5 エンジンコンディションプッシュダウンの最適化">セクション8.2.1.5「エンジンコンディションプッシュダウンの最適化」</a>
            </p></li><li class="listitem"><p>
              <a class="xref" href="optimization.html#index-extensions" title="8.2.1.7 インデックス拡張の使用">セクション8.2.1.7「インデックス拡張の使用」</a>
            </p></li><li class="listitem"><p>
              <a class="xref" href="optimization.html#index-condition-pushdown-optimization" title="8.2.1.6 インデックスコンディションプッシュダウンの最適化">セクション8.2.1.6「インデックスコンディションプッシュダウンの最適化」</a>
            </p></li><li class="listitem"><p>
              <a class="xref" href="optimization.html#index-merge-optimization" title="8.2.1.4 インデックスマージの最適化">セクション8.2.1.4「インデックスマージの最適化」</a>
            </p></li><li class="listitem"><p>
              <a class="xref" href="optimization.html#mrr-optimization" title="8.2.1.13 Multi-Range Read の最適化">セクション8.2.1.13「Multi-Range Read の最適化」</a>
            </p></li><li class="listitem"><p>
              <a class="xref" href="optimization.html#subquery-optimization" title="8.2.1.18 サブクエリーの最適化">セクション8.2.1.18「サブクエリーの最適化」</a>
            </p></li></ul></div><p>
          <code class="literal">optimizer_switch</code> に値を割り当てると、指定されていないフラグはそれらの現在の値を維持します。これにより、ほかの動作に影響を与えることなく、単一のステートメントで特定のオプティマイザの動作を有効または無効にできます。ステートメントは、ほかの存在するオプティマイザフラグやそれらの値に依存しません。すべてのインデックスマージ最適化が有効になっているとします。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT @@optimizer_switch\G</code></strong>
*************************** 1. row ***************************
@@optimizer_switch: index_merge=on,index_merge_union=on,
                    index_merge_sort_union=on,
                    index_merge_intersection=on,
                    engine_condition_pushdown=on,
                    index_condition_pushdown=on,
                    mrr=on,mrr_cost_based=on,
                    block_nested_loop=on,batched_key_access=off,
                    materialization=on,semijoin=on,loosescan=on,
                    firstmatch=on,
                    subquery_materialization_cost_based=on,
                    use_index_extensions=on
</pre><p>
          サーバーが特定のクエリーに対して、インデックスマージ和集合アクセスメソッドとインデックスマージソート和集合アクセスメソッドを使用しており、それらがなければオプティマイザの実行が改善されるかどうかをチェックする場合は、変数値を次のように設定します。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET optimizer_switch='index_merge_union=off,index_merge_sort_union=off';</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT @@optimizer_switch\G</code></strong>
*************************** 1. row ***************************
@@optimizer_switch: index_merge=on,index_merge_union=off,
                    index_merge_sort_union=off,
                    index_merge_intersection=on,
                    engine_condition_pushdown=on,
                    index_condition_pushdown=on,
                    mrr=on,mrr_cost_based=on,
                    block_nested_loop=on,batched_key_access=off,
                    materialization=on,semijoin=on,loosescan=on,
                    firstmatch=on,
                    subquery_materialization_cost_based=on,
                    use_index_extensions=on
</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="buffering-caching"></a>8.9 バッファリングとキャッシュ</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#innodb-buffer-pool">8.9.1 InnoDB バッファープール</a></span></dt><dt><span class="section"><a href="optimization.html#myisam-key-cache">8.9.2 MyISAM キーキャッシュ</a></span></dt><dt><span class="section"><a href="optimization.html#query-cache">8.9.3 MySQL クエリーキャッシュ</a></span></dt><dt><span class="section"><a href="optimization.html#statement-caching">8.9.4 プリペアドステートメントおよびストアドプログラムのキャッシュ</a></span></dt></dl></div><p>
      MySQL は、パフォーマンスを向上するため、メモリーバッファーに情報をキャッシュするいくつかの戦略を使用します。
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-buffer-pool"></a>8.9.1 InnoDB バッファープール</h3></div></div></div><a class="indexterm" name="idm139979112187808"></a><a class="indexterm" name="idm139979112186320"></a><a class="indexterm" name="idm139979112184944"></a><p>
        <code class="literal">InnoDB</code> は、データとインデックスをメモリーにキャッシュするための<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>と呼ばれるストレージ領域を維持しています。<code class="literal">InnoDB</code> バッファープールの仕組みを知り、頻繁にアクセスされるデータをメモリーに維持するためにそれを利用することは、MySQL チューニングの重要な側面です。
      </p><h4><a name="idm139979112180032"></a>ガイドライン</h4><p>
        理想的には、バッファープールのサイズをできるだけ大きな値に設定して、サーバー上のほかのプロセスが過剰なページングなく実行するように、十分なメモリーを残します。バッファープールが大きいほど、<code class="literal">InnoDB</code> はさらにインメモリーデータベースのように動作し、ディスクから 1 回データを読み取り、後続の読み取り時に、メモリーからデータにアクセスします。パフォーマンス向上のため、ディスク書き込みをグループ化できるように、バッファープールは挿入および更新操作によって変更されたデータもキャッシュします。
      </p><p>
        システムの一般的なワークロードに応じて、バッファープール内の各パートの割合を調整した方がよい場合があります。バッファープールがいっぱいになったときにキャッシュするブロックを選択する方法をチューニングし、バックアップやレポートなどの操作のアクティビティーが急増しても頻繁にアクセスされるデータをメモリーに保持できます。
      </p><p>
        大きなメモリーサイズを備える 64 ビットシステムでは、バッファープールを複数のパートに分割することで、同時操作中のメモリー構造の競合を最小にできます。詳細については、<a class="xref" href="innodb-storage-engine.html#innodb-multiple-buffer-pools" title="14.13.1.4 複数のバッファープールインスタンスの使用">セクション14.13.1.4「複数のバッファープールインスタンスの使用」</a>を参照してください。
      </p><h4><a name="idm139979112174400"></a>内部の詳細</h4><p>
        <code class="literal">InnoDB</code> は、LRU (Least Recently Used) アルゴリズムのバリエーションを使用して、プールをリストとして管理します。プールに新しいブロックを追加するために、空きが必要な場合、<code class="literal">InnoDB</code> は最近もっとも使用されていないブロックを削除し、新しいブロックをリストの途中に追加します。この<span class="quote">「<span class="quote">ミッドポイント挿入戦略</span>」</span>はリストを 2 つのサブリストとして扱います。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            先頭は、最近アクセスされた<span class="quote">「<span class="quote">新しい</span>」</span> (または<span class="quote">「<span class="quote">若い</span>」</span>) ブロックのサブリストです。
          </p></li><li class="listitem"><p>
            末尾は、最近あまりアクセスされていない<span class="quote">「<span class="quote">古い</span>」</span>ブロックのサブリストです。
          </p></li></ul></div><p>
        このアルゴリズムでは、クエリーによって頻繁に使用されるブロックを新しいサブリストに維持します。古いサブリストはあまり使用されないブロックを格納し、これらのブロックは<a class="link" href="glossary.html#glos_eviction" title="エビクション">エビクション</a>の候補になります。
      </p><p>
        LRU アルゴリズムはデフォルトで次のように動作します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            バッファープールの 3/8 が古いサブリストに割り振られます。
          </p></li><li class="listitem"><p>
            リストのミッドポイントは、新しいサブリストの末尾と古いサブリストの先頭が接する境界です。
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> がブロックをバッファープールに読み込むと、最初にそれをミッドポイント (古いサブリストの先頭) に挿入します。ブロックを読み取ることができるのは、SQL クエリーなどのユーザー指定の操作や、<code class="literal">InnoDB</code> によって自動的に実行される<a class="link" href="glossary.html#glos_read_ahead" title="先読み">先読み</a>操作の一部として、必要であるためです。
          </p></li><li class="listitem"><p>
            古いサブリスト内のブロックにアクセスすると、それが<span class="quote">「<span class="quote">若く</span>」</span>なり、バッファープールの先頭 (新しいサブリストの先頭) に移動されます。ブロックが必要であるために読み取られた場合、最初のアクセスはただちに行われ、ブロックが若くなります。先読みのためにブロックが読み取られた場合、最初のアクセスはただちに行われません (ブロックが削除されるまでまったく行われないこともあります)。
          </p></li><li class="listitem"><p>
            データベースが動作すると、アクセスされていないバッファープール内のブロックが、リストの末尾に移動されることによって、<span class="quote">「<span class="quote">古く</span>」</span>なります。新しいサブリストと古いサブリストの両方のブロックは、ほかのブロックが新しくなると、古くなります。古いサブリストのブロックは、ブロックがミッドポイントに挿入されたときも古くなります。最終的に、長い間使われないままのブロックは、古いサブリストの末尾に到達し、削除されます。
          </p></li></ul></div><p>
        デフォルトで、クエリーによって読み取られたブロックは、ただちに新しいサブリストに移動され、それらが長時間バッファープールにとどまることを意味します。テーブルスキャン (<span class="command"><strong>mysqldump</strong></span> 操作または <code class="literal">WHERE</code> 句のない <code class="literal">SELECT</code> ステートメントで実行されるような) によって、大量のデータがバッファープールに取り込まれ、新しいデータが再度使われることがない場合でも、同等の量の古いデータが削除されることがあります。同様に、先読みバックグラウンドスレッドによってロードされ、その後 1 回だけアクセスされたブロックは新しいリストの先頭に移動されます。こうした状況では、頻繁に使用されるブロックが古いサブリストに押し出され、そこでそれらがエビクション対象になることがあります。
      </p><h4><a name="idm139979112149264"></a>構成オプション</h4><p>
        いくつかの <code class="literal">InnoDB</code> システム変数で、バッファープールのサイズを制御し、LRU アルゴリズムをチューニングできます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">innodb_buffer_pool_size</code>
          </p><p>
            バッファープールのサイズを指定します。バッファープールが小さく、十分なメモリーがある場合、プールを大きくすると、クエリーが <code class="literal">InnoDB</code> テーブルにアクセスするときに必要なディスク I/O の量が減ることによってパフォーマンスが向上することがあります。
          </p></li><li class="listitem"><p>
            <code class="literal">innodb_buffer_pool_instances</code>
          </p><p>
            バッファープールを、それぞれ独自の LRU リストと関連データ構造を持つユーザー指定の数の個別の領域に分割して、同時メモリー読み取りおよび書き込み操作中の競合を削減します。このオプションは、<code class="literal">innodb_buffer_pool_size</code> を 1G バイト以上のサイズに設定した場合にのみ有効になります。指定した合計サイズは、すべてのバッファープール間で分割されます。最高の効率を得るには、<code class="literal">innodb_buffer_pool_instances</code> と <code class="literal">innodb_buffer_pool_size</code> の組み合わせを、各バッファープールインスタンスが少なくとも 1G バイトになるように指定します。
          </p></li><li class="listitem"><p>
            <code class="literal">innodb_old_blocks_pct</code>
          </p><p>
            <code class="literal">InnoDB</code> が古いブロックサブリストに使用するバッファープールのおおよその割合を指定します。値の範囲は 5 から 95 です。デフォルト値は 37 (つまり、プールの 3/8 ) です。
          </p></li><li class="listitem"><p>
            <code class="literal">innodb_old_blocks_time</code>
          </p><p>
            古いサブリストに挿入されたブロックが、その最初のアクセス後、新しいサブリストに移動するまでに、そこにとどまる必要のある時間をミリ秒 (ms) 単位で指定します。デフォルト値は 0 です。挿入後にどのくらいの期間でアクセスが発生するかに関係なく、古いサブリストに挿入されたブロックは、Innodb がバッファープールから、挿入されたブロックのページの 1/4 を削除したときに、新しいサブリストに移動されます。この値が 0 より大きい場合、ブロックは最初のアクセス後、少なくともそのミリ秒でアクセスが発生するまで、古いサブリストに残ります。たとえば、1000 の値では、ブロックは最初のアクセス後、それらが新しいサブリストに移動される資格を得るまで、1 秒間古いサブリストにとどまります。
          </p></li></ul></div><p>
        <code class="literal">innodb_old_blocks_time</code> を 0 より大きく設定すると、1 回のテーブルスキャンで、スキャンだけに使用されたブロックによって新しいサブリストがいっぱいになることを防ぎます。スキャンで読み取られるブロック内の行は、すばやく連続して何回もアクセスされますが、その後ブロックは使用されません。<code class="literal">innodb_old_blocks_time</code> がブロックを処理するより長い時間の値に設定されていれば、ブロックは<span class="quote">「<span class="quote">古い</span>」</span>サブリストに残り、リストの末尾まで古くなり、すぐに削除されます。このようにすると、1 回のスキャンだけに使用されるブロックが、新しいサブリスト内の頻繁に使用されるブロックの損失を促進しません。
      </p><p>
        <code class="literal">innodb_old_blocks_time</code> は実行時に設定できるため、テーブルスキャンやダンプなどの操作の実行中にそれを一時的に変更できます。
      </p><pre class="programlisting">
SET GLOBAL innodb_old_blocks_time = 1000;
<em class="replaceable"><code>... perform queries that scan tables ...</code></em>
SET GLOBAL innodb_old_blocks_time = 0;
</pre><p>
        目的が、テーブルの内容をバッファープールに入れることによって、バッファープールを<span class="quote">「<span class="quote">ウォームアップ</span>」</span>することである場合、この戦略は適用されません。たとえば、通常の使用期間後、データは通常バッファープール内にあるため、ベンチマークテストでは、多くの場合サーバーの起動時にテーブルまたはインデックススキャンを実行します。この場合、少なくともウォームアップフェーズが完了するまで、<code class="literal">innodb_old_blocks_time</code> を 0 に設定されたままにします。
      </p><h4><a name="idm139979112119760"></a>バッファープールのモニタリング</h4><p>
        InnoDB 標準モニターからの出力には、<code class="literal">BUFFER POOL AND MEMORY</code> セクションに、バッファープール LRU アルゴリズムの操作に属するいくつかのフィールドが含まれます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Old database pages</code>: バッファープールの古いサブリスト内のページ数。
          </p></li><li class="listitem"><p>
            <code class="literal">Pages made young, not young</code>: バッファープールの先頭 (新しいサブリスト) に移動された古いページ数と、新しくなることなく、古いサブリストに残されているページ数。
          </p></li><li class="listitem"><p>
            <code class="literal">youngs/s non-youngs/s</code>: 若くされたか、またはされなかった古いページへのアクセスの数。このメトリックは、2 つの点で、前の項目のそれとは異なります。まず、これは古いページにのみ関連します。2 つめに、それはページへのアクセス数に基づき、ページ数に基づきません。(特定のページに複数のアクセスがあることがあり、そのすべてがカウントされます。)
          </p></li><li class="listitem"><p>
            <code class="literal">young-making rate</code>: ブロックがバッファープールの先頭に移動されるヒット。
          </p></li><li class="listitem"><p>
            <code class="literal">not</code>: ブロックがバッファープールの先頭に移動されないヒット (満たされていない遅延のため)。
          </p></li></ul></div><p>
        <code class="literal">young-making</code> 率と <code class="literal">not</code> 率は通常バッファープール全体のヒット率まで達することはありません。古いサブリスト内のブロックのヒットによって、それらが新しいサブリストに移動されますが、新しいサブリスト内のブロックへのヒットでは、それらが先頭から特定の距離にある場合にのみ、リストの先頭に移動されます。
      </p><p>
        モニターからの先述の情報が、LRU のチューニングの決定に役立つことがあります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            大きなスキャンが実行中でないときに、<code class="literal">youngs/s</code> 値がきわめて低いことが確認された場合、遅延時間を減らすか、古いサブリストに使用されるバッファープールの割合を増やす必要がある可能性があることを示しています。割合を増やすと、古いサブリストが大きくなるため、そのサブリスト内のブロックが末尾に移動され、削除されるまで長くかかるようになります。これにより、再度アクセスされ、若くされる可能性が高くなります。
          </p></li><li class="listitem"><p>
            大きなテーブルスキャンの実行中 (および大量の <code class="literal">youngs/s</code>) に大量の <code class="literal">non-youngs/s</code> が確認されない場合、遅延値を大きくするようにチューニングします。
          </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">InnoDB</code> モニターの出力で示される 1 秒あたりの平均は、現在の時間と <code class="literal">InnoDB</code> モニターの出力が最後に出力された時間の間の経過時間に基づいています。
        </p></div><p>
        InnoDB モニターの詳細については、<a class="xref" href="innodb-storage-engine.html#innodb-monitors" title="14.15 InnoDB モニター">セクション14.15「InnoDB モニター」</a>を参照してください。
      </p><p>
        <code class="literal">INNODB_BUFFER_POOL_STATS</code> テーブルと <code class="literal">InnoDB</code> バッファープールの<a class="link" href="server-administration.html#server-status-variables" title="5.1.6 サーバーステータス変数">サーバーステータス変数</a>は、<code class="literal">SHOW ENGINE INNODB STATUS</code> 出力によって提供される、多くの同じバッファープール情報を提供します。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="myisam-key-cache"></a>8.9.2 MyISAM キーキャッシュ</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#shared-key-cache">8.9.2.1 共有キーキャッシュアクセス</a></span></dt><dt><span class="section"><a href="optimization.html#multiple-key-caches">8.9.2.2 複合キーキャッシュ</a></span></dt><dt><span class="section"><a href="optimization.html#midpoint-insertion">8.9.2.3 ミッドポイント挿入戦略</a></span></dt><dt><span class="section"><a href="optimization.html#index-preloading">8.9.2.4 インデックスプリロード</a></span></dt><dt><span class="section"><a href="optimization.html#key-cache-block-size">8.9.2.5 キーキャッシュブロックサイズ</a></span></dt><dt><span class="section"><a href="optimization.html#key-cache-restructuring">8.9.2.6 キーキャッシュの再構築</a></span></dt></dl></div><a class="indexterm" name="idm139979112091040"></a><a class="indexterm" name="idm139979112089552"></a><p>
        ディスク I/O を最小にするために、<code class="literal">MyISAM</code> ストレージエンジンは多くのデータベース管理システムで使用されている戦略を利用します。それは、もっとも頻繁にアクセスされるテーブルブロックをメモリー内で保持するキャッシュメカニズムを採用しています。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            インデックスブロックの場合、<em class="firstterm">キーキャッシュ</em> (または<em class="firstterm">キーバッファー</em>) と呼ばれる特別な構造が維持されます。その構造には、もっとも多く使用されるインデックスブロックが置かれる多数のブロックバッファーが含まれます。
          </p></li><li class="listitem"><p>
            データブロックに対しては、MySQL は特別なキャッシュを使用しません。代わりに、ネイティブオペレーティングシステムのファイルシステムキャッシュに依存します。
          </p></li></ul></div><p>
        このセクションではまず <code class="literal">MyISAM</code> キーキャッシュの基本動作について説明します。次に、キーキャッシュパフォーマンスを向上させる機能と、キャッシュ操作をより適切に制御できるようにする機能について説明します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            複数のセッションが同時にキャッシュにアクセスできます。
          </p></li><li class="listitem"><p>
            複数のキーキャッシュをセットアップし、特定のキャッシュにテーブルインデックスを割り当てることができます。
          </p></li></ul></div><p>
        キーキャッシュのサイズを制御するには、<code class="literal">key_buffer_size</code> システム変数を使用します。この変数がゼロに設定されている場合、キーキャッシュは使われません。キーキャッシュは、<code class="literal">key_buffer_size</code> 値が小さすぎて、最小数のブロックバッファー (8) を割り当てられない場合も使用されません。
      </p><p>
        キーキャッシュが動作していない場合、インデックスファイルはオペレーティングシステムによって提供されるネイティブファイルシステムバッファリングのみを使用してアクセスされます。(つまり、テーブルインデックスブロックは、テーブルデータブロックに採用されている同じ戦略を使用してアクセスされます。)
      </p><p>
        インデックスブロックは <code class="literal">MyISAM</code> インデックスファイルへの連続したアクセスの単位です。通常、インデックスブロックのサイズは、インデックス B ツリーのノードのサイズと等しくなります。(インデックスはディスク上で B ツリーデータ構造を使用して表されます。ツリーの下部にあるノードはリーフノードです。リーフノードの上にあるノードは非リーフノードです。) 
      </p><p>
        キーキャッシュ構造内のすべてのブロックバッファーは同じサイズです。このサイズは、テーブルインデックスブロックのサイズと等しいか、大きいか、小さくできます。通常これら 2 つの値のうちの一方は、他方の倍数になります。
      </p><p>
        いずれかのテーブルインデックスブロックのデータにアクセスする必要がある場合、サーバーはまず、キーキャッシュの何らかのブロックバッファーでそれを使用できるかどうかを確認します。そうである場合、サーバーはディスク上ではなく、キーキャッシュ内のデータにアクセスします。つまり、ディスクから読み取ったり、それに書き込んだりするのではなく、キャッシュから読み取ったり、それに書き込んだりします。そうでない場合、サーバーは別のテーブルインデックスブロックを含むキャッシュブロックバッファーを選択し、そのデータを必要なテーブルインデックスブロックのコピーで置き換えます。新しいインデックスブロックがキャッシュに入れられるとただちに、インデックスデータにアクセスできます。
      </p><p>
        置き換えのために選択されているブロックが変更されていた場合、ブロックは<span class="quote">「<span class="quote">ダーティー</span>」</span>とみなされます。この場合、置き換えられる前に、その内容が取得元のテーブルインデックスにフラッシュされます。
      </p><p>
        通常サーバーは <em class="firstterm">LRU (Least Recently Used)</em> 戦略に従います。置き換えるブロックを選択する場合、直近で使用されていないインデックスブロックを選択します。この選択を簡単にするため、キーキャッシュモジュールは、使用されたすべてのブロックを特別なリスト (<em class="firstterm">LRU チェーン</em>) に使用時間で順序付けして保持しています。ブロックがアクセスされると、それは直近で使用されたものになり、リストの末尾に置かれます。ブロックを置き換える必要がある場合、リストの先頭にあるブロックが、直近で使用されていないことになり、エビクションの最初の候補になります。
      </p><p>
        <code class="literal">InnoDB</code> ストレージエンジンは、そのバッファープールを管理するためにも LRU アルゴリズムを使用します。<a class="xref" href="optimization.html#innodb-buffer-pool" title="8.9.1 InnoDB バッファープール">セクション8.9.1「InnoDB バッファープール」</a>を参照してください。
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="shared-key-cache"></a>8.9.2.1 共有キーキャッシュアクセス</h4></div></div></div><p>
          スレッドはキーキャッシュバッファーに同時にアクセスでき、次の条件に従います。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              更新中でないバッファーは複数のセッションによってアクセスできます。
            </p></li><li class="listitem"><p>
              更新中のバッファーは、更新が完了するまで、それを使用する必要があるセッションを待機させます。
            </p></li><li class="listitem"><p>
              複数のセッションは、互いに干渉しないかぎり (つまり、それらは異なるインデックスブロックを必要とし、そのため、異なるキャッシュブロックが置き換えられるかぎり)、キャッシュブロックの置換を引き起こすリクエストを開始できます。
            </p></li></ul></div><p>
          キーキャッシュへの共有アクセスによって、サーバーのスループットを大幅に向上できます。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="multiple-key-caches"></a>8.9.2.2 複合キーキャッシュ</h4></div></div></div><p>
          キーキャッシュへの共有アクセスはパフォーマンスを向上させますが、セッション間の競合を完全には排除しません。それらはまだキーキャッシュバッファーへのアクセスを管理する制御構造を得るために争います。キーキャッシュアクセスの競合をもっと軽減するために、MySQL は複合キーキャッシュも提供しています。この機能により、異なるキーキャッシュにさまざまなテーブルインデックスを割り当てることができます。
        </p><p>
          複合キーキャッシュがある場合、サーバーは特定の <code class="literal">MyISAM</code> テーブルに対してクエリーを処理する際に、使用すべきキャッシュを知っている必要があります。デフォルトでは、すべての <code class="literal">MyISAM</code> テーブルインデックスはデフォルトのキーキャッシュにキャッシュされます。テーブルインデックスを特定のキーキャッシュに割り当てるには、<code class="literal">CACHE INDEX</code> ステートメントを使用します (<a class="xref" href="sql-syntax.html#cache-index" title="13.7.6.2 CACHE INDEX 構文">セクション13.7.6.2「CACHE INDEX 構文」</a>を参照してください)。たとえば、次のステートメントは <code class="literal">t1</code>、<code class="literal">t2</code>、および <code class="literal">t3</code> テーブルから、<code class="literal">hot_cache</code> という名前のキーキャッシュにインデックスを割り当てます。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CACHE INDEX t1, t2, t3 IN hot_cache;</code></strong>
+---------+--------------------+----------+----------+
| Table   | Op                 | Msg_type | Msg_text |
+---------+--------------------+----------+----------+
| test.t1 | assign_to_keycache | status   | OK       |
| test.t2 | assign_to_keycache | status   | OK       |
| test.t3 | assign_to_keycache | status   | OK       |
+---------+--------------------+----------+----------+
</pre><p>
          <code class="literal">CACHE INDEX</code> ステートメントで参照されているキーキャッシュは、<code class="literal">SET GLOBAL</code> パラメータ設定ステートメントでそのサイズを設定するか、またはサーバー起動オプションを使用して作成できます。例:
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET GLOBAL keycache1.key_buffer_size=128*1024;</code></strong>
</pre><p>
          キーキャッシュを破棄するには、そのサイズをゼロに設定します。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET GLOBAL keycache1.key_buffer_size=0;</code></strong>
</pre><p>
          デフォルトのキーキャッシュは破棄できません。これを実行するすべての試みは無視されます。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET GLOBAL key_buffer_size = 0;</code></strong>

mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'key_buffer_size';</code></strong>
+-----------------+---------+
| Variable_name   | Value   |
+-----------------+---------+
| key_buffer_size | 8384512 |
+-----------------+---------+
</pre><p>
          キーキャッシュ変数は名前とコンポーネントのある構造化システム変数です。<code class="literal">keycache1.key_buffer_size</code> の場合、<code class="literal">keycache1</code> はキャッシュ変数名であり、<code class="literal">key_buffer_size</code> はキャッシュコンポーネントです。構造化キーキャッシュシステム変数を参照するために使用する構文の詳細については、<a class="xref" href="server-administration.html#structured-system-variables" title="5.1.5.1 構造化システム変数">セクション5.1.5.1「構造化システム変数」</a>を参照してください。
        </p><p>
          デフォルトで、テーブルインデックスは、サーバー起動時に作成されるメイン (デフォルト) キーキャッシュに割り当てられます。キーキャッシュが破棄されると、それに割り当てられたすべてのインデックスはデフォルトのキーキャッシュに再割り当てされます。
        </p><p>
          ビジーなサーバーの場合、3 つのキーキャッシュを含む戦略を使用できます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              すべてのキーキャッシュに割り当てられたスペースの 20% を占める<span class="quote">「<span class="quote">ホット</span>」</span>キーキャッシュ。これは、検索に頻繁に使用されるが、更新されないテーブルに使用します。
            </p></li><li class="listitem"><p>
              すべてのキーキャッシュに割り当てられたスペースの 20% を占める<span class="quote">「<span class="quote">コールド</span>」</span>キーキャッシュ。このキャッシュは、一時テーブルなどの中規模の集中的に変更されるテーブルに使用します。
            </p></li><li class="listitem"><p>
              キーキャッシュスペースの 60% を占める<span class="quote">「<span class="quote">ウォーム</span>」</span>キーキャッシュ。これは、デフォルトでほかのすべてのテーブルに使用されるように、デフォルトのキーキャッシュとして使用します。
            </p></li></ul></div><p>
          3 つのキーキャッシュを使用することに利点がある理由の 1 つは、1 つのキーキャッシュ構造へのアクセスが、ほかへのアクセスをブロックしないことです。あるキャッシュに割り当てられたテーブルにアクセスするステートメントは、ほかのキャッシュに割り当てられたテーブルにアクセスするステートメントと競合しません。パフォーマンスの向上はほかの理由でも発生します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              ホットキャッシュはクエリーの取得にのみ使用されるため、その内容が変更されることはありません。その結果、インデックスブロックをディスクから取り出す必要がある場合常に、置き換えのために選択されたキャッシュブロックの内容を最初にフラッシュする必要はありません。
            </p></li><li class="listitem"><p>
              ホットキャッシュに割り当てられたインデックスの場合、インデックススキャンを必要とするクエリーがなければ、インデックス B ツリーの非リーフノードに対応するインデックスブロックがキャッシュに残っている可能性が高くなります。
            </p></li><li class="listitem"><p>
              一時テーブルに対するもっとも頻繁に実行される更新操作は、更新されるノードがキャッシュ内にあり、最初にディスクから読み取られる必要がない場合、はるかに高速に実行されます。一時テーブルのインデックスのサイズがコールドキーキャッシュのサイズと同程度である場合、更新されるノードがキャッシュ内にある可能性が高くなります。
            </p></li></ul></div><p>
          <code class="literal">CACHE INDEX</code> ステートメントは、テーブルとキーキャッシュ間のアソシエーションをセットアップしますが、そのアソシエーションはサーバーが再起動されるたびに失われます。サーバーが起動するたびにアソシエーションを有効にしたい場合、これを実現する 1 つの方法はオプションファイルを使用することです。キーキャッシュを構成する変数設定と、実行される <code class="literal">CACHE INDEX</code> ステートメントを含むファイルを指定する <code class="literal">init-file</code> オプションを含めます。例:
        </p><pre class="programlisting">
key_buffer_size = 4G
hot_cache.key_buffer_size = 2G
cold_cache.key_buffer_size = 2G
init_file=/<em class="replaceable"><code>path</code></em>/<em class="replaceable"><code>to</code></em>/<em class="replaceable"><code>data-directory</code></em>/mysqld_init.sql
</pre><p>
          サーバーが起動するたびに <code class="filename">mysqld_init.sql</code> 内のステートメントが実行されます。ファイルには 1 行に 1 つずつ SQL ステートメントを含めてください。次の例は <code class="literal">hot_cache</code> と <code class="literal">cold_cache</code> に複数のテーブルをそれぞれ割り当てます。
        </p><pre class="programlisting">
CACHE INDEX db1.t1, db1.t2, db2.t3 IN hot_cache
CACHE INDEX db1.t4, db2.t5, db2.t6 IN cold_cache
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="midpoint-insertion"></a>8.9.2.3 ミッドポイント挿入戦略</h4></div></div></div><p>
          デフォルトで、キーキャッシュ管理システムは、削除されるキーキャッシュブロックの選択に、単純な LRU 戦略を使用しますが、<em class="firstterm">ミッドポイント挿入戦略</em>というさらに高度な方法もサポートしています。
        </p><p>
          ミッドポイント挿入戦略を使用すると、LRU チェーンがホットサブリストとウォームサブリストの 2 つのパートに分割されます。2 つのパート間の分割点は固定ではありませんが、キーキャッシュ管理システムでは、ウォームパートが<span class="quote">「<span class="quote">短くなりすぎ</span>」</span>ず、常にキーキャッシュブロックの少なくとも <code class="literal">key_cache_division_limit</code> パーセントを含むように配慮されます。<code class="literal">key_cache_division_limit</code> は構造化キーキャッシュ変数のコンポーネントであるため、その値はキャッシュごとに設定可能なパラメータです。
        </p><p>
          インデックスブロックがテーブルからキーキャッシュに読み込まれると、それはウォームサブリストの末尾に置かれます。特定の数のヒット (ブロックのアクセス) 後、それはホットサブリストに昇格されます。現在のところ、ブロックを昇格させるために必要なヒット数 (3) はすべてのインデックスブロックで同じです。
        </p><p>
          ホットサブリストに昇格されるブロックはリストの末尾に置かれます。ブロックはこのサブリスト内で循環されます。ブロックが十分な時間サブリストの先頭にとどまっている場合、それはウォームサブリストに降格されます。この時間はキーキャッシュの <code class="literal">key_cache_age_threshold</code> コンポーネントの値によって決定されます。
        </p><p>
          しきい値は、<em class="replaceable"><code>N</code></em> ブロックを含むキーキャッシュの場合、最後の <code class="literal"><em class="replaceable"><code>N</code></em> * key_cache_age_threshold / 100</code> ヒット内にアクセスされないホットサブリストの先頭のブロックが、ウォームサブリストの先頭に移動されることを規定します。置き換えられるブロックは常にウォームサブリストの先頭から取得されるため、その後、それは削除の最初の候補になります。
        </p><p>
          ミッドポイント挿入戦略により、価値の高いブロックを常にキャッシュ内に保持できます。単純な LRU 戦略を使用したい場合は、<code class="literal">key_cache_division_limit</code> 値をそのデフォルトの 100 に設定したままにします。
        </p><p>
          ミッドポイント挿入戦略は、インデックススキャンを必要とするクエリーの実行で、価値の高い高レベル B ツリーノードに対応するすべてのインデックスブロックを、キャッシュから効率的に押し出す際のパフォーマンスの向上に役立ちます。これを回避するには、<code class="literal">key_cache_division_limit</code> を 100 よりかなり小さい値に設定して、ミッドポイント挿入戦略を使用する必要があります。これにより、インデックススキャン操作中でも、価値の高い頻繁にヒットされるノードがホットサブリストに保持されます。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="index-preloading"></a>8.9.2.4 インデックスプリロード</h4></div></div></div><p>
          キーキャッシュ内に、インデックス全体のブロックを保持するために十分なブロックがあるか、または少なくともその非リーフノードに対応するブロックがある場合、使用を開始する前に、キーキャッシュにインデックスブロックをプリロードすることは役立ちます。プリロードにより、インデックスブロックをディスクから順番に読み取ることで、もっとも効率的にテーブルインデックスをキーキャッシュバッファーに挿入できます。
        </p><p>
          プリロードしない場合、ブロックは、引き続きクエリーによって必要とされるときに、キーキャッシュに置かれます。ブロックはキャッシュ内にとどまりますが、それらのすべてに対して十分なバッファーがあるため、ディスクからランダムな順序で、順番ではなくフェッチされます。
        </p><p>
          インデックスをキャッシュにプリロードするには <code class="literal">LOAD INDEX INTO CACHE</code> ステートメントを使用します。たとえば、次のステートメントはテーブル <code class="literal">t1</code> および <code class="literal">t2</code> のインデックスのノード (インデックスブロック) をプリロードします。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>LOAD INDEX INTO CACHE t1, t2 IGNORE LEAVES;</code></strong>
+---------+--------------+----------+----------+
| Table   | Op           | Msg_type | Msg_text |
+---------+--------------+----------+----------+
| test.t1 | preload_keys | status   | OK       |
| test.t2 | preload_keys | status   | OK       |
+---------+--------------+----------+----------+
</pre><p>
          <code class="literal">IGNORE LEAVES</code> 修飾子によって、インデックスの非リーフノードのブロックのみがプリロードされます。したがって、上記のステートメントは <code class="literal">t1</code> からすべてのインデックスブロックをプリロードしますが、<code class="literal">t2</code> からは非リーフノードのブロックのみをプリロードします。
        </p><p>
          インデックスが <code class="literal">CACHE INDEX</code> ステートメントを使用してキーキャッシュに割り当てられている場合、プリロードによって、インデックスブロックがそのキャッシュに置かれます。そうでない場合は、インデックスはデフォルトのキーキャッシュにロードされます。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="key-cache-block-size"></a>8.9.2.5 キーキャッシュブロックサイズ</h4></div></div></div><p>
          <code class="literal">key_cache_block_size</code> 変数を使用して、個々のキーキャッシュのブロックバッファーのサイズを指定できます。これによって、インデックスファイルの I/O 操作のパフォーマンスをチューニングできます。
        </p><p>
          I/O 操作の最適なパフォーマンスは、読み取りバッファーのサイズがネイティブオペレーティングシステム I/O バッファーのサイズに等しい場合に達成されます。ただし、キーノードのサイズを I/O バッファーのサイズと等しく設定しても、常に全体の最適なパフォーマンスが確保されるわけではありません。大きなリーフノードを読み取る場合、サーバーは大量の不要なデータを取り出し、事実上ほかのリーフノードの読み取りを妨げます。
        </p><p>
          <code class="literal">MyISAM</code> テーブルの <code class="filename">.MYI</code> インデックスファイルのブロックのサイズを制御するには、サーバーの起動時に <code class="option">--myisam-block-size</code> オプションを使用します。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="key-cache-restructuring"></a>8.9.2.6 キーキャッシュの再構築</h4></div></div></div><p>
          キーキャッシュはそのパラメータ値を更新することで、いつでも再構築できます。例:
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET GLOBAL cold_cache.key_buffer_size=4*1024*1024;</code></strong>
</pre><p>
          <code class="literal">key_buffer_size</code> または <code class="literal">key_cache_block_size</code> キーキャッシュコンポーネントに、コンポーネントの現在値と異なる値を割り当てた場合、サーバーはキャッシュの古い構造を破棄し、新しい値に基づいた新しい構造を作成します。キャッシュにダーティーブロックが含まれる場合、サーバーはキャッシュを破棄し、再作成する前にディスクにそれらを保存します。ほかのキーキャッシュパラメータを変更した場合は、再構築が行われません。
        </p><p>
          キーキャッシュを再構築する場合、サーバーはまずダーティーバッファーの内容をディスクにフラッシュします。その後、キャッシュの内容は使用できなくなります。しかし、再構築は、キャッシュに割り当てられたインデックスを使用する必要があるクエリーをブロックしません。代わりに、サーバーはネイティブファイルシステムキャッシュを使用して、テーブルインデックスに直接アクセスします。ファイルシステムキャッシュはキーキャッシュを使用するときほど効率的ではないため、クエリーが実行されても速度の低下が予想されます。キャッシュが再構築されると、それに割り当てられたインデックスをキャッシュするためにふたたび使用できるようになり、インデックスのファイルシステムキャッシュの使用は停止されます。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="query-cache"></a>8.9.3 MySQL クエリーキャッシュ</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#query-cache-operation">8.9.3.1 クエリーキャッシュの動作</a></span></dt><dt><span class="section"><a href="optimization.html#query-cache-in-select">8.9.3.2 クエリーキャッシュ SELECT オプション</a></span></dt><dt><span class="section"><a href="optimization.html#query-cache-configuration">8.9.3.3 クエリーキャッシュの構成</a></span></dt><dt><span class="section"><a href="optimization.html#query-cache-status-and-maintenance">8.9.3.4 クエリーキャッシュのステータスと保守</a></span></dt></dl></div><a class="indexterm" name="idm139979111960864"></a><a class="indexterm" name="idm139979111959408"></a><p>
        クエリーキャッシュには、クライアントに送信された対応する結果とともに、<code class="literal">SELECT</code> ステートメントのテキストが格納されます。あとで同じステートメントを受け取った場合、サーバーはそのステートメントを再度解析して実行する代わりに、クエリーキャッシュから結果を取得します。クエリーキャッシュはセッション間で共有されるため、1 つのクライアントで生成された結果セットを、別のクライアントによって発行された同じクエリーへの応答で送信できます。
      </p><p>
        クエリーキャッシュは、あまり頻繁に変更されないテーブルがあり、それに対してサーバーが多くの同一のクエリーを受け取る環境で役立つことがあります。これは、データベースの内容に基づいて、多くの動的ページを生成する多くの Web サーバーに一般的な状況です。
      </p><p>
        クエリーキャッシュは古くなったデータを返しません。テーブルが変更されると、クエリーキャッシュ内の関連エントリがフラッシュされます。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          同じ <code class="literal">MyISAM</code> テーブルを更新する複数の <span class="command"><strong>mysqld</strong></span> サーバーがある環境では、クエリーキャッシュは機能しません。
        </p></div><p>
        クエリーキャッシュは、<a class="xref" href="optimization.html#query-cache-operation" title="8.9.3.1 クエリーキャッシュの動作">セクション8.9.3.1「クエリーキャッシュの動作」</a>に説明された条件の下で、準備されたステートメントに使用されます。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          MySQL 5.6.5 現在、クエリーキャッシュは、パーティション化されたテーブルに対してはサポートされておらず、パーティション化されたテーブルを含むクエリーには自動的に無効にされます。そのようなクエリーに対しては、クエリーキャッシュを有効にできません。(Bug #53775)
        </p></div><p>
        クエリーキャッシュの一部のパフォーマンスデータを次に示します。これらの結果は、2G バイトの RAM と 64M バイトのクエリーキャッシュを搭載する Linux Alpha 2 × 500MHz システムで、MySQL ベンチマークスイートを実行して生成されました。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            実行しているすべてのクエリーは単純です (1 行のテーブルから行を選択するなど) が、それでも異なっているため、クエリーをキャッシュできない場合、クエリーキャッシュをアクティブにしておくためのオーバーヘッドは 13% です。これは最悪のケースのシナリオとみなすことができます。実際には、クエリーははるかに複雑になる傾向があるため、オーバーヘッドは通常かなり低くなります。
          </p></li><li class="listitem"><p>
            単一行テーブル内の単一行の検索は、クエリーキャッシュがあると、それがない場合より、238% 高速化します。これは、キャッシュされているクエリーに予想される最小の高速化に近いとみなすことができます。
          </p></li></ul></div><p>
        サーバーの起動時にクエリーキャッシュを無効にするには、<code class="literal">query_cache_size</code> システム変数を 0 に設定します。クエリーキャッシュコードを無効にすることによって、目立ったオーバーヘッドはなくなります。
      </p><p>
        クエリーキャッシュは、かなりのパフォーマンスの改善の可能性を提供しますが、すべての環境でそうなるものと想定しないでください。クエリーキャッシュの構成やサーバーのワークロードによっては、実際にパフォーマンスの低下が見られることもあります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            クエリーキャッシュのサイズを過度に大きくすると、キャッシュの保守に必要なオーバーヘッドが増え、それを有効にすることのメリットに勝る可能性があります。数十メガバイトのサイズが通常は有益です。数百メガバイトのサイズはそうでない可能性があります。
          </p></li><li class="listitem"><p>
            サーバーのワークロードは、クエリーキャッシュの効率にかなりの影響を与えます。ほぼ全体が固定の <code class="literal">SELECT</code> ステートメントのセットで構成される複合クエリーでは、頻繁な <code class="literal">INSERT</code> ステートメントによってキャッシュ内の結果が絶えず無効にされるような複合クエリーよりも、キャッシュを有効にすることでメリットが得られる可能性がはるかに高くなります。場合によっては、回避方法として、<code class="literal">SQL_NO_CACHE</code> オプションを使用して、頻繁に変更されるテーブルを使用する <code class="literal">SELECT</code> ステートメントに対して、結果をキャッシュに入れないようにします。(<a class="xref" href="optimization.html#query-cache-in-select" title="8.9.3.2 クエリーキャッシュ SELECT オプション">セクション8.9.3.2「クエリーキャッシュ SELECT オプション」</a>を参照してください。)
          </p></li></ul></div><p>
        クエリーキャッシュを使用することでメリットがあるかどうかを確認するには、キャッシュを有効および無効にして MySQL サーバーの動作をテストします。サーバーのワークロードが変わるとクエリーキャッシュの効率も変わることがあるため、その後、定期的に再テストします。
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="query-cache-operation"></a>8.9.3.1 クエリーキャッシュの動作</h4></div></div></div><p>
          このセクションでは、クエリーキャッシュが動作可能な場合のその仕組みについて説明します。<a class="xref" href="optimization.html#query-cache-configuration" title="8.9.3.3 クエリーキャッシュの構成">セクション8.9.3.3「クエリーキャッシュの構成」</a>では、それを動作可能にするかどうかを制御する方法について説明しています。
        </p><p>
          受信したクエリーは、解析前にクエリーキャッシュにあるそれらと比較されるため、次の 2 つのクエリーは、クエリーキャッシュによって異なるものとみなされます。
        </p><pre class="programlisting">
SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
Select * from <em class="replaceable"><code>tbl_name</code></em>
</pre><p>
          クエリーは、同一とみなされるためには、<span class="emphasis"><em>正確に</em></span>同じ (バイトごと) である必要があります。さらに、ほかの理由で、同一のクエリー文字列が異なるものとして扱われることもあります。異なるデータベース、異なるプロトコルバージョン、または異なるデフォルトの文字セットを使用するクエリーは、異なるクエリーとみなされ、別々にキャッシュされます。
        </p><p>
          次の種類のクエリーにはキャッシュが使用されません。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              外部クエリーのサブクエリーであるクエリー
            </p></li><li class="listitem"><p>
              ストアドファンクション、トリガー、またはイベントの本体内で実行されるクエリー
            </p></li></ul></div><p>
          クエリー結果をクエリーキャッシュからフェッチする前に、MySQL は、関連するすべてのデータベースとテーブルに対して、ユーザーが <code class="literal">SELECT</code> 権限を持っているかどうかをチェックします。これが当てはまらない場合、キャッシュ結果は使用されません。
        </p><p>
          クエリー結果がクエリーキャッシュから返される場合、サーバーは <code class="literal">Com_select</code> ではなく <code class="literal">Qcache_hits</code> ステータス変数を増やします。<a class="xref" href="optimization.html#query-cache-status-and-maintenance" title="8.9.3.4 クエリーキャッシュのステータスと保守">セクション8.9.3.4「クエリーキャッシュのステータスと保守」</a>を参照してください。
        </p><p>
          テーブルが変更された場合、そのテーブルを使用するキャッシュされたすべてのクエリーが無効になり、キャッシュから削除されます。これには、変更されたテーブルにマップされた <code class="literal">MERGE</code> テーブルを使用するクエリーも含まれます。テーブルは、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、<code class="literal">DELETE</code>、<code class="literal">TRUNCATE TABLE</code>、<code class="literal">ALTER TABLE</code>、<code class="literal">DROP TABLE</code>、または <code class="literal">DROP DATABASE</code> などの多くの種類のステートメントによって変更できます。
        </p><p>
          <code class="literal">InnoDB</code> テーブルを使用する際のトランザクション内でもクエリーキャッシュは機能します。
        </p><p>
          MySQL 5.6 では、ビュー上の <code class="literal">SELECT</code> クエリーからの結果がキャッシュされます。
        </p><p>
          クエリーキャッシュは、<code class="literal">SELECT SQL_CALC_FOUND_ROWS ...</code> クエリーに対して機能し、後続の <code class="literal">SELECT FOUND_ROWS()</code> クエリーで返される値を格納します。<code class="literal">FOUND_ROWS()</code> は前のクエリーがキャッシュからフェッチされている場合でも、見つかった行の数もキャッシュに格納されているため、正確な値を返します。<code class="literal">SELECT FOUND_ROWS()</code> クエリー自体はキャッシュできません。
        </p><p>
          <code class="literal">mysql_stmt_prepare()</code> および <code class="literal">mysql_stmt_execute()</code> を使用し、バイナリプロトコルを使用して発行されたプリペアドステートメント (<a class="xref" href="connectors-apis.html#c-api-prepared-statements" title="23.8.8 C API プリペアドステートメント">セクション23.8.8「C API プリペアドステートメント」</a>を参照してください) はキャッシュが制限されます。クエリーキャッシュ内のステートメントとの比較は、<code class="literal">?</code> パラメータマーカーの拡張後のステートメントのテキストに基づきます。ステートメントは、バイナリプロトコルを使用して実行されたほかのキャッシュされたステートメントとのみ比較されます。つまり、クエリーキャッシュの目的で、バイナリプロトコルを使用して発行されたプリペアドステートメントは、テキストプロトコルを使用して発行されたプリペアドステートメント (<a class="xref" href="sql-syntax.html#sql-syntax-prepared-statements" title="13.5 準備済みステートメントのための SQL 構文">セクション13.5「準備済みステートメントのための SQL 構文」</a>を参照してください) と区別されます。
        </p><p>
          クエリーに次の表に示すいずれかの関数が含まれる場合、クエリーはキャッシュできません。
        </p><div class="informaltable"><table summary="この表は、クエリー内で使用された場合、クエリーがキャッシュされない関数を一覧表示しています。" border="1"><colgroup><col><col><col></colgroup><tbody><tr><td scope="row"><code class="literal">AES_DECRYPT()</code> (5.7.4 現在)</td><td><code class="literal">AES_ENCRYPT()</code> (5.7.4 現在)</td><td><code class="literal">BENCHMARK()</code></td></tr><tr><td scope="row"><code class="literal">CONNECTION_ID()</code></td><td><code class="literal">CONVERT_TZ()</code></td><td><code class="literal">CURDATE()</code></td></tr><tr><td scope="row"><code class="literal">CURRENT_DATE()</code></td><td><code class="literal">CURRENT_TIME()</code></td><td><code class="literal">CURRENT_TIMESTAMP()</code></td></tr><tr><td scope="row"><code class="literal">CURTIME()</code></td><td><code class="literal">DATABASE()</code></td><td>1 つのパラメータを持つ <code class="literal">ENCRYPT()</code></td></tr><tr><td scope="row"><code class="literal">FOUND_ROWS()</code></td><td><code class="literal">GET_LOCK()</code></td><td><code class="literal">LAST_INSERT_ID()</code></td></tr><tr><td scope="row"><code class="literal">LOAD_FILE()</code></td><td><code class="literal">MASTER_POS_WAIT()</code></td><td><code class="literal">NOW()</code></td></tr><tr><td scope="row"><code class="literal">PASSWORD()</code></td><td><code class="literal">RAND()</code></td><td><code class="literal">RANDOM_BYTES()</code></td></tr><tr><td scope="row"><code class="literal">RELEASE_LOCK()</code></td><td><code class="literal">SLEEP()</code></td><td><code class="literal">SYSDATE()</code></td></tr><tr><td scope="row">パラメータを持たない <code class="literal">UNIX_TIMESTAMP()</code></td><td><code class="literal">USER()</code></td><td><code class="literal">UUID()</code></td></tr><tr><td scope="row"><code class="literal">UUID_SHORT()</code></td><td> </td><td> </td></tr></tbody></table></div><p>
          次の条件下のクエリーもキャッシュされません。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              それがユーザー定義関数 (UDF) またはストアドファンクションを参照している。
            </p></li><li class="listitem"><p>
              それがユーザー変数またはローカルに保存されたプログラム変数を参照している。
            </p></li><li class="listitem"><p>
              それが <code class="literal">mysql</code>、<code class="literal">INFORMATION_SCHEMA</code>、または <code class="literal">performance_schema</code> データベース内のテーブルを参照している。
            </p></li><li class="listitem"><p>
              (<span class="emphasis"><em>MySQL 5.6.5 以降</em></span>:) それがパーティション化されたテーブルを参照している。
            </p></li><li class="listitem"><p>
              それが次のいずれかの形式である。
            </p><pre class="programlisting">
SELECT ... LOCK IN SHARE MODE
SELECT ... FOR UPDATE
SELECT ... INTO OUTFILE ...
SELECT ... INTO DUMPFILE ...
SELECT * FROM ... WHERE autoincrement_col IS NULL
</pre><p>
              最後の形式は、最後の挿入 ID 値を取得するための ODBC の回避方法として使用されるため、キャッシュされません。<a class="xref" href="connectors-apis.html" title="第 23 章 Connector および API">第23章「<i>Connector および API</i>」</a>の Connector/ODBC のセクションを参照してください。
            </p><p>
              <code class="literal">SERIALIZABLE</code> 分離レベルを使用するトランザクション内のステートメントは <code class="literal">LOCK IN SHARE MODE</code> ロックを使用するため、それらもキャッシュできません。
            </p></li><li class="listitem"><p>
              それが <code class="literal">TEMPORARY</code> テーブルを使用している。
            </p></li><li class="listitem"><p>
              それがどのテーブルも使用していない。
            </p></li><li class="listitem"><p>
              それが警告を生成する。
            </p></li><li class="listitem"><p>
              ユーザーが関連するすべてのテーブルのカラムレベルの権限を持っている。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="query-cache-in-select"></a>8.9.3.2 クエリーキャッシュ SELECT オプション</h4></div></div></div><p>
          クエリーキャッシュ関連の 2 つのオプションを <code class="literal">SELECT</code> ステートメントに指定できます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <a class="indexterm" name="idm139979111833312"></a> <code class="literal">SQL_CACHE</code>
            </p><p>
              クエリー結果がキャッシュ可能で、<code class="literal">query_cache_type</code> システム変数の値が <code class="literal">ON</code> または <code class="literal">DEMAND</code> である場合、クエリー結果はキャッシュされます。
            </p></li><li class="listitem"><a class="indexterm" name="idm139979111827648"></a><p>
              <code class="literal">SQL_NO_CACHE</code>
            </p><p>
              サーバーはクエリーキャッシュを使用しません。それは、結果がすでにキャッシュされているかどうかを確認するためにクエリーキャッシュをチェックせず、クエリー結果もキャッシュしません。(パーサーの制限のため、スペース文字の前後に <code class="literal">SQL_NO_CACHE</code> キーワードを付ける必要があります。改行などのスペース以外では、結果がすでにキャッシュされているかどうかを確認するために、サーバーにクエリーキャッシュをチェックさせます。)
            </p></li></ul></div><p>
          例:
        </p><pre class="programlisting">
SELECT SQL_CACHE id, name FROM customer;
SELECT SQL_NO_CACHE id, name FROM customer;
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="query-cache-configuration"></a>8.9.3.3 クエリーキャッシュの構成</h4></div></div></div><p>
          <code class="literal">have_query_cache</code> サーバーシステム変数は、クエリーキャッシュが使用できるかどうかを示します。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'have_query_cache';</code></strong>
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| have_query_cache | YES   |
+------------------+-------+
</pre><p>
          標準 MySQL バイナリを使用している場合、クエリーキャッシュが無効にされている場合でも、この値は常に <code class="literal">YES</code> です。
        </p><p>
          ほかのいくつかのシステム変数は、クエリーキャッシュ操作を制御します。これらは、<span class="command"><strong>mysqld</strong></span> の起動時に、オプションファイルやコマンド行で設定できます。クエリーキャッシュシステム変数はすべて、<code class="literal">query_cache_</code> で始まる名前を持ちます。それらについては、ここで提供している追加の構成情報とともに、<a class="xref" href="server-administration.html#server-system-variables" title="5.1.4 サーバーシステム変数">セクション5.1.4「サーバーシステム変数」</a>で簡単に説明しています。
        </p><p>
          クエリーキャッシュのサイズを設定するには、<code class="literal">query_cache_size</code> システム変数を設定します。それを 0 に設定すると、<code class="literal">query_cache_type=0</code> を設定するのと同様に、クエリーキャッシュが無効になります。デフォルトでは、クエリーキャッシュは無効化されます。これは 1M のデフォルトのサイズと、0 の <code class="literal">query_cache_type</code> のデフォルトを使用して実現されます。(MySQL 5.6.8 より前では、1 のデフォルトの <code class="literal">query_cache_type</code> で、デフォルトのサイズは 0 です。)
        </p><p>
          オーバーヘッドを大幅に削減するには、クエリーキャッシュを使用しない場合に <code class="literal">query_cache_type=0</code> でサーバーも起動します。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            Windows Configuration Wizard を使用して、MySQL をインストールまたは構成する場合、<code class="literal">query_cache_size</code> のデフォルト値が、使用可能なさまざまな構成の種類に基づいて、自動的に構成されます。Windows Configuration Wizard を使用する場合、選択した構成のため、クエリーキャッシュが有効になる (つまり、ゼロではない値に設定される) ことがあります。クエリーキャッシュは、<code class="literal">query_cache_type</code> 変数の設定によっても制御されます。構成が行われたあとに、<code class="filename">my.ini</code> ファイルに設定されたこれらの変数の値をチェックしてください。
          </p></div><p>
          <code class="literal">query_cache_size</code> をゼロ以外の値に設定する場合は、その構造を割り当てるために、クエリーキャッシュに約 40KB の最小サイズが必要であることを覚えておいてください。(正確なサイズはシステムアーキテクチャーによります。)小さすぎる値を設定すると、この例のように警告を受け取ります。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET GLOBAL query_cache_size = 40000;</code></strong>
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS\G</code></strong>
*************************** 1. row ***************************
  Level: Warning
   Code: 1282
Message: Query cache failed to set size 39936;
         new query cache size is 0

mysql&gt; <strong class="userinput"><code>SET GLOBAL query_cache_size = 41984;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'query_cache_size';</code></strong>
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| query_cache_size | 41984 |
+------------------+-------+
</pre><p>
          クエリーキャッシュで実際にクエリー結果を保持できるようにするには、そのサイズを大きく設定する必要があります。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET GLOBAL query_cache_size = 1000000;</code></strong>
Query OK, 0 rows affected (0.04 sec)

mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'query_cache_size';</code></strong>
+------------------+--------+
| Variable_name    | Value  |
+------------------+--------+
| query_cache_size | 999424 |
+------------------+--------+
1 row in set (0.00 sec)
</pre><p>
          <code class="literal">query_cache_size</code> 値は、もっとも近い 1024 バイトブロックに調整されます。そのため、レポートされる値は、割り当てた値と異なることがあります。
        </p><p>
          クエリーキャッシュのサイズが 0 より大きい場合、<code class="literal">query_cache_type</code> 変数はその動作に影響します。この変数は次の値に設定できます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">0</code> または <code class="literal">OFF</code> の値は、キャッシュまたはキャッシュされた結果の取得を妨げます。
            </p></li><li class="listitem"><p>
              <code class="literal">1</code> または <code class="literal">ON</code> の値は、<code class="literal">SELECT SQL_NO_CACHE</code> から始まるステートメントを除いて、キャッシュを有効にします。
            </p></li><li class="listitem"><p>
              <code class="literal">2</code> または <code class="literal">DEMAND</code> の値は、<code class="literal">SELECT SQL_CACHE</code> で始まるステートメントのみをキャッシュさせます。
            </p></li></ul></div><p>
          <code class="literal">query_cache_size</code> が 0 の場合、<code class="literal">query_cache_type</code> 変数も 0 に設定してください。この場合、サーバーはクエリーキャッシュ相互排他ロックをまったく獲得しません。これは、実行時にクエリーキャッシュを有効にできず、クエリー実行のオーバーヘッドが削減されることを意味します。
        </p><p>
          <code class="literal">GLOBAL</code> <code class="literal">query_cache_type</code> 値を設定すると、変更が行われたあとに接続するすべてのクライアントのクエリーキャッシュの動作が決定されます。<code class="literal">SESSION</code> <code class="literal">query_cache_type</code> 値を設定して、個々のクライアントでそれぞれ独自の接続のキャッシュ動作を制御できます。たとえば、クライアントは次のように独自のクエリーへのクエリーキャッシュの使用を無効にできます。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET SESSION query_cache_type = OFF;</code></strong>
</pre><p>
          サーバーの起動時 (<code class="literal">SET</code> ステートメントによる実行時ではなく) に <code class="literal">query_cache_type</code> を設定する場合、数値のみが許可されます。
        </p><p>
          キャッシュ可能な個々のクエリー結果の最大サイズを制御するには、<code class="literal">query_cache_limit</code> システム変数を設定します。デフォルト値は 1M バイトです。
        </p><p>
          キャッシュを大きすぎるサイズに設定しないでください。更新時にキャッシュをロックするスレッドの必要性のため、きわめて大きいキャッシュではロックの競合問題が見られることがあります。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            コマンド行または構成ファイルに <code class="option">--maximum-query_cache_size=<em class="replaceable"><code>32M</code></em></code> オプションを使用して、<code class="literal">SET</code> ステートメントで実行時にクエリーキャッシュに指定できる最大サイズを設定できます。
          </p></div><p>
          クエリーがキャッシュされるようにすると、その結果 (クライアントに送信されたデータ) が結果の取得時に、クエリーキャッシュに格納されます。そのため、データは通常 1 つの大きなまとまりで処理されません。クエリーキャッシュはオンデマンドでこのデータを格納するためのブロックを割り当てるため、1 つのブロックがいっぱいになると、新しいブロックが割り当てられます。メモリーの割り当て操作はコスト (時間的) がかかるため、クエリーキャッシュは <code class="literal">query_cache_min_res_unit</code> システム変数によって指定された最小サイズでブロックを割り当てます。クエリーが実行されると、未使用のメモリーが解放されるように、最後の結果ブロックが実際のデータサイズにトリミングされます。サーバーで実行するクエリーの種類によっては、<code class="literal">query_cache_min_res_unit</code> の値をチューニングすることが有効であるとわかる場合があります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">query_cache_min_res_unit</code> のデフォルト値は 4K バイトです。ほとんどの場合、これで十分であるはずです。
            </p></li><li class="listitem"><p>
              小さい結果の大量のクエリーがある場合、多数の空きブロックに示されるように、デフォルトのブロックサイズはメモリーの断片化につながることがあります。断片化は、メモリー不足のために、クエリーキャッシュにキャッシュからクエリーを強制的にプルーニング (削除) させる可能性があります。この場合、<code class="literal">query_cache_min_res_unit</code> の値を減らします。空きブロックと、プルーニングによって削除されたクエリーの数は <code class="literal">Qcache_free_blocks</code> および <code class="literal">Qcache_lowmem_prunes</code> ステータス変数の値によって得られます。
            </p></li><li class="listitem"><p>
              ほとんどのクエリーの結果が大きい (<code class="literal">Qcache_total_blocks</code> および <code class="literal">Qcache_queries_in_cache</code> ステータス変数をチェックします) 場合、<code class="literal">query_cache_min_res_unit</code> を増やして、パフォーマンスを向上できます。ただし、大きくしすぎないようにしてください (前の項目を参照してください)。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="query-cache-status-and-maintenance"></a>8.9.3.4 クエリーキャッシュのステータスと保守</h4></div></div></div><p>
          MySQL サーバーにクエリーキャッシュが存在するかどうかをチェックするには、次のステートメントを使用します。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'have_query_cache';</code></strong>
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| have_query_cache | YES   |
+------------------+-------+
</pre><p>
          <code class="literal">FLUSH QUERY CACHE</code> ステートメントによって、クエリーキャッシュをデフラグして、そのメモリーの利用を改善できます。このステートメントは、キャッシュからクエリーを削除しません。
        </p><p>
          <code class="literal">RESET QUERY CACHE</code> ステートメントは、クエリーキャッシュからすべてのクエリー結果を削除します。<code class="literal">FLUSH TABLES</code> ステートメントもこれを実行します。
        </p><p>
          クエリーキャッシュのパフォーマンスをモニターするには、<code class="literal">SHOW STATUS</code> を使用して、キャッシュのステータス変数を表示します。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW STATUS LIKE 'Qcache%';</code></strong>
+-------------------------+--------+
| Variable_name           | Value  |
+-------------------------+--------+
| Qcache_free_blocks      | 36     |
| Qcache_free_memory      | 138488 |
| Qcache_hits             | 79570  |
| Qcache_inserts          | 27087  |
| Qcache_lowmem_prunes    | 3114   |
| Qcache_not_cached       | 22989  |
| Qcache_queries_in_cache | 415    |
| Qcache_total_blocks     | 912    |
+-------------------------+--------+
</pre><p>
          これらの各変数の説明は、<a class="xref" href="server-administration.html#server-status-variables" title="5.1.6 サーバーステータス変数">セクション5.1.6「サーバーステータス変数」</a>にあります。ここでは、それらのいくつかの使用方法について説明します。
        </p><p>
          <code class="literal">SELECT</code> クエリーの合計数は、次の式で得られます。
        </p><pre class="programlisting">
  Com_select
+ Qcache_hits
+ queries with errors found by parser
</pre><p>
          <code class="literal">Com_select</code> 値は次の式で得られます。
        </p><pre class="programlisting">
  Qcache_inserts
+ Qcache_not_cached
+ queries with errors found during the column-privileges check
</pre><p>
          クエリーキャッシュでは、可変長ブロックを使用するため、<code class="literal">Qcache_total_blocks</code> および <code class="literal">Qcache_free_blocks</code> に、クエリーキャッシュのメモリー断片化が示されることがあります。<code class="literal">FLUSH QUERY CACHE</code> 後には、空きブロックが 1 つだけ残ります。
        </p><p>
          キャッシュされるすべてのクエリーには、少なくとも 2 つのブロック (1 つはクエリーテキスト用で、1 つ以上はクエリー結果用) が必要です。さらに、クエリーで使用される各テーブルにも 1 つのブロックが必要です。ただし、複数のクエリーで同じテーブルを使用している場合、1 つのテーブルブロックだけを割り当てる必要があります。
        </p><p>
          <code class="literal">Qcache_lowmem_prunes</code> ステータス変数によって提供される情報は、クエリーキャッシュサイズをチューニングするのに役立つことがあります。それは、新しいクエリーのキャッシュのためにメモリーを解放するために、キャッシュから削除されたクエリーの数をカウントします。クエリーキャッシュは、LRU (Least Recently Used) 戦略を使用して、キャッシュから削除するクエリーを決定します。チューニング情報は、<a class="xref" href="optimization.html#query-cache-configuration" title="8.9.3.3 クエリーキャッシュの構成">セクション8.9.3.3「クエリーキャッシュの構成」</a>にあります。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="statement-caching"></a>8.9.4 プリペアドステートメントおよびストアドプログラムのキャッシュ</h3></div></div></div><a class="indexterm" name="idm139979111715376"></a><a class="indexterm" name="idm139979111713232"></a><p>
        セッション中にクライアントが複数回実行する可能性がある特定のステートメントに対し、サーバーはステートメントを内部構造に変換し、実行時にその構造が使用されるようにキャッシュします。キャッシュによって、セッション中にそれが再度必要になった場合に、ステートメントを再変換するオーバーヘッドが避けられるため、サーバーはより効率的に実行できます。変換とキャッシュは、次のステートメントに対して行われます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            SQL レベルで処理されるもの (<code class="literal">PREPARE</code> ステートメントを使用して) とバイナリクライアント/サーバープロトコルを使用して処理されるもの (<code class="literal">mysql_stmt_prepare()</code> C API 関数を使用して) の両方のプリペアドステートメント。<code class="literal">max_prepared_stmt_count</code> システム変数は、サーバーがキャッシュするステートメントの合計数を制御します。(すべてのセッションでのプリペアドステートメントの合計数。)
          </p></li><li class="listitem"><p>
            ストアドプログラム (ストアドプロシージャーおよび関数、トリガー、およびイベント)。この場合、サーバーはプログラム本体全体を変換し、キャッシュします。<code class="literal">stored_program_cache</code> システム変数は、サーバーがセッションあたりにキャッシュするストアドプログラムのおおよその数を示します。
          </p></li></ul></div><p>
        サーバーは、セッション単位でプリペアドステートメントおよびストアドプログラム用のキャッシュを保守します。1 つのセッションでキャッシュされたステートメントは、ほかのセッションからアクセスできません。セッションが終了すると、サーバーはそのためにキャッシュされたすべてのステートメントを破棄します。
      </p><p>
        サーバーがキャッシュされた内部ステートメント構造を使用する場合、構造が古くなっていないことに注意する必要があります。ステートメントによって使用されているオブジェクトにメタデータの変更があり、現在のオブジェクト定義と内部ステートメント構造で表されている定義に不一致が発生することがあります。メタデータの変更は、テーブルの作成、削除、変更、名前変更、切り捨てを行う DDL ステートメントや、テーブルの解析、最適化、修復を行う DDL ステートメントなどに対して発生します。テーブルの内容の変更 (<code class="literal">INSERT</code> や <code class="literal">UPDATE</code> などによる) ではメタデータが変更されず、<code class="literal">SELECT</code> ステートメントも変更されません。
      </p><p>
        次にこの問題を説明します。クライアントがこのステートメントを準備するとします。
      </p><pre class="programlisting">
PREPARE s1 FROM 'SELECT * FROM t1';
</pre><p>
        <code class="literal">SELECT *</code> は内部構造からテーブル内のカラムのリストに展開します。テーブル内のカラムのセットが <code class="literal">ALTER TABLE</code> によって変更されている場合、プリペアドステートメントが古くなります。次回にクライアントが <code class="literal">s1</code> を実行したときに、サーバーがこの変更を検出しない場合、プリペアドステートメントは正しくない結果を返します。
      </p><p>
        プリペアドステートメントによって参照されているテーブルやビューのメタデータの変更に原因がある問題を避けるため、サーバーはこれらの変更を検出し、次回の実行時にステートメントを自動的に再準備します。つまり、サーバーはステートメントを再解析し、内部構造を再構築します。再解析は、キャッシュ内に新しいエントリのための空きを作るために暗黙的に、または <code class="literal">FLUSH TABLES</code> によって明示的に、参照されているテーブルやビューがテーブル定義キャッシュからフラッシュされたあとにも行われます。
      </p><p>
        同様に、ストアドプログラムによって使用されているオブジェクトに変更が発生した場合、サーバーはプログラム内の影響のあるステートメントを再解析します。(MySQL 5.6.6 より前では、サーバーはストアドプログラムに影響するメタデータの変更を検出しないため、そのような変更によって、誤った結果やエラーが発生する可能性があります。)
      </p><p>
        サーバーは式内のオブジェクトのメタデータの変更も検出します。これらは、<code class="literal">DECLARE CURSOR</code> などのストアドプログラムに固有のステートメントや <code class="literal">IF</code>、<code class="literal">CASE</code>、および <code class="literal">RETURN</code> などのフロー制御ステートメントで使用できます。
      </p><p>
        ストアドプログラム全体の再解析を避けるため、サーバーは必要に応じて、プログラム内の影響のあるステートメントや式のみを再解析します。例:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            テーブルまたはビューのメタデータが変更されているとします。再解析は、テーブルやビューにアクセスするプログラム内の <code class="literal">SELECT *</code> に対して行われますが、テーブルやビューにアクセスしない <code class="literal">SELECT *</code> に対しては行われません。
          </p></li><li class="listitem"><p>
            ステートメントが影響を受ける場合、サーバーは可能なかぎり部分的にのみそれを再解析します。この <code class="literal">CASE</code> ステートメントを考慮します。
          </p><pre class="programlisting">
CASE <em class="replaceable"><code>case_expr</code></em>
  WHEN <em class="replaceable"><code>when_expr1</code></em> ...
  WHEN <em class="replaceable"><code>when_expr2</code></em> ...
  WHEN <em class="replaceable"><code>when_expr3</code></em> ...
  ...
END CASE
</pre><p>
            メタデータの変更が <code class="literal">WHEN <em class="replaceable"><code>when_expr3</code></em></code> にのみ影響する場合、その式が再解析されます。<em class="replaceable"><code>case_expr</code></em> およびその他の <code class="literal">WHEN</code> 式は再解析されません。
          </p></li></ul></div><p>
        再解析では、元の内部形式への変換に有効であったデフォルトのデータベースと SQL モードが使われます。
      </p><p>
        サーバーは最大 3 回再解析を試みます。すべての試みが失敗した場合、エラーが発生します。
      </p><p>
        再解析は自動ですが、それが行われた場合、プリペアドステートメントとストアドプログラムのパフォーマンスが低下します。
      </p><p>
        プリペアドステートメントの場合、<code class="literal">Com_stmt_reprepare</code> ステータス変数が再準備の数を追跡します。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="locking-issues"></a>8.10 ロック操作の最適化</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#internal-locking">8.10.1 内部ロック方法</a></span></dt><dt><span class="section"><a href="optimization.html#table-locking">8.10.2 テーブルロックの問題</a></span></dt><dt><span class="section"><a href="optimization.html#concurrent-inserts">8.10.3 同時挿入</a></span></dt><dt><span class="section"><a href="optimization.html#metadata-locking">8.10.4 メタデータのロック</a></span></dt><dt><span class="section"><a href="optimization.html#external-locking">8.10.5 外部ロック</a></span></dt></dl></div><p>
      MySQL は<a class="link" href="glossary.html#glos_locking" title="ロック">ロック</a>を使用して、テーブルの内容の競合を管理します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          内部ロックは、複数スレッドによるテーブルの内容の競合を管理するために、MySQL サーバー自体の内部で実行されます。この種類のロックは、完全にサーバーによって実行され、ほかのプログラムは関与しないため、内部です。<a class="xref" href="optimization.html#internal-locking" title="8.10.1 内部ロック方法">セクション8.10.1「内部ロック方法」</a>を参照してください。
        </p></li><li class="listitem"><p>
          外部ロックは、サーバーとほかのプログラム間で、どのプログラムがいつテーブルにアクセスできるかを調整するために、<code class="literal">MyISAM</code> テーブルファイルをロックする場合に発生します。<a class="xref" href="optimization.html#external-locking" title="8.10.5 外部ロック">セクション8.10.5「外部ロック」</a>を参照してください。
        </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="internal-locking"></a>8.10.1 内部ロック方法</h3></div></div></div><a class="indexterm" name="idm139979111658480"></a><a class="indexterm" name="idm139979111657024"></a><a class="indexterm" name="idm139979111654992"></a><a class="indexterm" name="idm139979111653648"></a><a class="indexterm" name="idm139979111651616"></a><a class="indexterm" name="idm139979111650256"></a><a class="indexterm" name="idm139979111648880"></a><a class="indexterm" name="idm139979111646848"></a><a class="indexterm" name="idm139979111644816"></a><p>
        このセクションでは、内部ロック、つまり複数のセッションによるテーブル内容の競合を管理するために、MySQL サーバー自体の内部で実行されるロックについて説明します。この種類のロックは、完全にサーバーによって実行され、ほかのプログラムは関与しないため、内部です。ほかのプログラムによって MySQL ファイルに対して実行されるロックについては、<a class="xref" href="optimization.html#external-locking" title="8.10.5 外部ロック">セクション8.10.5「外部ロック」</a>を参照してください。
      </p><h4><a name="idm139979111641728"></a>行レベルロック</h4><p>
        MySQL は <code class="literal">InnoDB</code> テーブルに<a class="link" href="glossary.html#glos_row_lock" title="行ロック">行レベルロック</a>を使用して、複数のセッションによる同時書き込みアクセスをサポートし、それらを複数ユーザー、高度な並列性、および OLTP アプリケーションに適したものにします。
      </p><p>
        単一の <code class="literal">InnoDB</code> テーブルに対する複数の同時書き込み操作の実行時の<a class="link" href="glossary.html#glos_deadlock" title="デッドロック">デッドロック</a>を避けるには、トランザクションのあとの方に <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> ステートメントがある場合でも、変更が予想される行のグループごとに、<code class="literal">SELECT ... FOR UPDATE</code> ステートメントを発行して、トランザクションの開始時に必要なロックを獲得します。トランザクションで複数のテーブルを変更またはロックする場合、各トランザクション内で、該当するステートメントを同じ順序で発行します。<code class="literal">InnoDB</code> は自動的にデッドロック状況を<a class="link" href="glossary.html#glos_deadlock_detection" title="デッドロック検出">検出</a>し、影響のあるいずれかのトランザクションをロールバックするため、デッドロックは重大エラーを表すより、パフォーマンスに影響します。
      </p><p>
        行レベルロックの利点:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            異なるセッションが異なる行にアクセスする場合、ロックの競合は少なくなります。
          </p></li><li class="listitem"><p>
            ロールバックする変更が少なくなります。
          </p></li><li class="listitem"><p>
            1 つの行を長時間ロックできます。
          </p></li></ul></div><h4><a name="idm139979111628608"></a>テーブルレベルロック</h4><p>
        MySQL は、<code class="literal">MyISAM</code>、<code class="literal">MEMORY</code>、および <code class="literal">MERGE</code> テーブルに<a class="link" href="glossary.html#glos_table_lock" title="テーブルロック">テーブルレベルロック</a>を使用して、一度に 1 つだけのセッションがそれらのテーブルを更新できるようにし、それらを読み取り専用、読み取りが大部分、または単一ユーザーのアプリケーションに適したものにします。
      </p><p>
        これらのストレージエンジンは、常にクエリーの最初に 1 回だけ必要なすべてのロックをリクエストし、常に同じ順序でテーブルをロックすることによって、<a class="link" href="glossary.html#glos_deadlock" title="デッドロック">デッドロック</a>を回避します。このトレードオフは、この戦略では並列性が低くなることです。テーブルを変更したいほかのセッションは、現在の <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> ステートメントが終了するまで待機する必要があります。
      </p><p>
        MySQL はテーブル書き込みロックを次のように許可します。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            テーブルにロックがない場合、それを書き込みロックします。
          </p></li><li class="listitem"><p>
            そうでない場合、書き込みロックキューにロックリクエストを入れます。
          </p></li></ol></div><p>
        MySQL はテーブル読み取りロックを次のように許可します。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            テーブルに書き込みロックがない場合、それを読み取りロックします。
          </p></li><li class="listitem"><p>
            そうでない場合、読み取りロックキューにロックリクエストを入れます。
          </p></li></ol></div><p>
        テーブルの更新は、テーブルの取得よりも高い優先度が与えられます。そのため、ロックが解放されると、ロックは書き込みロックキュー内のリクエストに使用できるようになり、次に読み取りロックキュー内のリクエストに使用できるようになります。これにより、テーブルに対して重い <code class="literal">SELECT</code> アクティビティーがある場合でも、テーブルに対する更新が<span class="quote">「<span class="quote">不足</span>」</span>することはありません。ただし、テーブルに対して多くの更新がある場合、<code class="literal">SELECT</code> ステートメントは更新がなくなるまで待機します。
      </p><p>
        読み取りと書き込みの優先度を変更する方法については、<a class="xref" href="optimization.html#table-locking" title="8.10.2 テーブルロックの問題">セクション8.10.2「テーブルロックの問題」</a>を参照してください。
      </p><p>
        <code class="literal">Table_locks_immediate</code> および <code class="literal">Table_locks_waited</code> ステータス変数をチェックすることでシステム上のテーブルロック競合を分析できます。これらは、テーブルロックのリクエストがすぐに許可された回数と待機する必要があった回数を示します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW STATUS LIKE 'Table%';</code></strong>
+-----------------------+---------+
| Variable_name         | Value   |
+-----------------------+---------+
| Table_locks_immediate | 1151552 |
| Table_locks_waited    | 15324   |
+-----------------------+---------+
</pre><a class="indexterm" name="idm139979111604560"></a><a class="indexterm" name="idm139979111603088"></a><p>
        <code class="literal">MyISAM</code> ストレージエンジンでは、特定のテーブルのリーダーとライター間の競合を軽減するために、同時挿入をサポートしています。<code class="literal">MyISAM</code> テーブルでデータファイルの途中に空きブロックがない場合、行は常にデータファイルの末尾に挿入されます。この場合、ロックなしで <code class="literal">MyISAM</code> テーブルに対して同時 <code class="literal">INSERT</code> および <code class="literal">SELECT</code> ステートメントを自由に組み合わせることができます。つまり、ほかのクライアントが <code class="literal">MyISAM</code> テーブルから読み取ると同時に、それに行を挿入できます。テーブルの途中で行が削除されるか更新されると、隙間が発生します。隙間がある場合、同時挿入は無効にされますが、すべての隙間が新しいデータで埋められた場合は、自動的にふたたび有効にされます。この動作は <code class="literal">concurrent_insert</code> システム変数によって変更します。<a class="xref" href="optimization.html#concurrent-inserts" title="8.10.3 同時挿入">セクション8.10.3「同時挿入」</a>を参照してください。
      </p><p>
        <code class="literal">LOCK TABLES</code> で明示的にテーブルロックを獲得する場合、<code class="literal">READ</code> ロックではなく <code class="literal">READ LOCAL</code> ロックをリクエストして、テーブルをロックしている間に、ほかのセッションが同時挿入を実行できるようにできます。
      </p><p>
        同時挿入が可能でない場合に、テーブル <code class="literal">real_table</code> に対して多くの <code class="literal">INSERT</code> および <code class="literal">SELECT</code> 操作を実行するには、一時テーブル <code class="literal">temp_table</code> に行を挿入し、定期的に一時テーブルからの行で実際のテーブルを更新します。これは次のコードで実行できます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>LOCK TABLES real_table WRITE, temp_table WRITE;</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO real_table SELECT * FROM temp_table;</code></strong>
mysql&gt; <strong class="userinput"><code>DELETE FROM temp_table;</code></strong>
mysql&gt; <strong class="userinput"><code>UNLOCK TABLES;</code></strong>
</pre><p>
        テーブルレベルロックの利点:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            必要なメモリーが比較的少なくなります。
          </p></li><li class="listitem"><p>
            単一のロックだけが必要であるため、テーブルの大部分に対して使用する場合に高速です。
          </p></li><li class="listitem"><p>
            データの大部分に対して <code class="literal">GROUP BY</code> 操作を頻繁に実行する場合や、テーブル全体を頻繁にスキャンする必要がある場合に高速です。
          </p></li></ul></div><p>
        一般にテーブルロックは次の場合に適しています。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            テーブルに対するほとんどのステートメントが読み取りです。
          </p></li><li class="listitem"><p>
            テーブルに対するステートメントが読み取りと書き込みの組み合わせであり、そのうち書き込みは 1 つのキーの読み取りでフェッチできる単一の行に対する更新または削除です。
          </p><pre class="programlisting">
UPDATE <em class="replaceable"><code>tbl_name</code></em> SET <em class="replaceable"><code>column</code></em>=<em class="replaceable"><code>value</code></em> WHERE <em class="replaceable"><code>unique_key_col</code></em>=<em class="replaceable"><code>key_value</code></em>;
DELETE FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>unique_key_col</code></em>=<em class="replaceable"><code>key_value</code></em>;
</pre></li><li class="listitem"><p>
            同時 <code class="literal">INSERT</code> ステートメントとごく少数の <code class="literal">UPDATE</code> または <code class="literal">DELETE</code> ステートメントと組み合わされた <code class="literal">SELECT</code>。
          </p></li><li class="listitem"><p>
            ライターを使用しない、テーブル全体への多くのスキャンまたは <code class="literal">GROUP BY</code> 操作。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="table-locking"></a>8.10.2 テーブルロックの問題</h3></div></div></div><a class="indexterm" name="idm139979111561168"></a><p>
        <code class="literal">InnoDB</code> テーブルでは、複数のセッションとアプリケーションが互いに待機したり、不整合の結果を生成したりすることなく、同じテーブルに対して同時に読み取りや書き込みを実行できるように、行レベルロックを使用します。このストレージエンジンでは、<code class="literal">LOCK TABLES</code> ステートメントは特別な保護を提供せず、代わりに並列性が低くなるため、この使用を避けてください。自動の行レベルロックにより、これらのテーブルがもっとも重要なデータを格納するもっともビジーなデータベースに適合し、同時にテーブルのロックやロック解除が必要ないためアプリケーションロジックが簡単になります。その結果、<code class="literal">InnoDB</code> ストレージエンジンは MySQL 5.6 のデフォルトです。
      </p><p>
        MySQL は <code class="literal">InnoDB</code> を除く、すべてのストレージエンジンに対して、テーブルロック (ページ、行、またはカラムロックの代わりに) を使用します。ロック操作自体には、あまりオーバーヘッドがありません。ただし、一度に 1 つのセッションしかテーブルに書き込むことができないため、これらのほかのストレージエンジンでの最高のパフォーマンスのため、頻繁にクエリーされ、めったに挿入または更新されないテーブルに対して主にそれらを使用します。
      </p><h4><a name="idm139979111553168"></a>InnoDB を優先するパフォーマンスの考慮事項</h4><p>
        テーブルを作成するために、<code class="literal">InnoDB</code> を使用するか、別のストレージエンジンを使用するかを選択する場合、テーブルロックの次の短所を考慮してください。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            テーブルロックにより、多くのセッションを同時にテーブルから読み取ることができますが、セッションでテーブルに書き込む必要がある場合、まず排他的アクセスを取得する必要がありますが、これはまずほかのセッションがテーブルを処理し終わるのを待つ必要がある可能性があることを意味します。更新中、この特定のテーブルにアクセスしようとするほかのすべてのセッションは、更新が完了するまで待機する必要があります。
          </p></li><li class="listitem"><p>
            ディスクがいっぱいで、セッションを続行するには空き領域が使用できるようになる必要があるため、セッションが待機している場合にテーブルロックによって問題が発生します。この場合、問題のテーブルにアクセスしようとするすべてのセッションが、より多くのディスク領域が使用できるようになるまで待機状態になります。
          </p></li><li class="listitem"><p>
            実行に長時間かかる <code class="literal">SELECT</code> ステートメントにより、その間ほかのセッションのテーブルの更新が妨げられ、ほかのセッションが遅くなり、応答していないように見えます。セッションが更新のためにテーブルへの排他アクセスを取得するのを待機している間、<code class="literal">SELECT</code> ステートメントを発行するほかのセッションはそのあとに列をなし、読み取りセッションでも並列性が低くなります。
          </p></li></ul></div><h4><a name="idm139979111543840"></a>ロックパフォーマンスの問題の回避</h4><p>
        次の項目では、テーブルロックによって発生する競合を回避または軽減するいくつかの方法について説明します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            セットアップ時に <code class="literal">CREATE TABLE ... ENGINE=INNODB</code> を使用するか、既存のテーブルに対して <code class="literal">ALTER TABLE ... ENGINE=INNODB</code> を使用して、テーブルを <code class="literal">InnoDB</code> ストレージエンジンに切り替えることを考慮します。このストレージエンジンの詳細については、<a class="xref" href="innodb-storage-engine.html" title="第 14 章 InnoDB ストレージエンジン">第14章「<i>InnoDB ストレージエンジン</i>」</a>を参照してください。
          </p></li><li class="listitem"><p>
            テーブルをロックする時間が短くなるように、<code class="literal">SELECT</code> ステートメントを最適化して、実行を高速化します。これを実行するには、いくつかのサマリーテーブルを作成する必要がある場合があります。
          </p></li><li class="listitem"><p>
            <code class="option">--low-priority-updates</code> で <span class="command"><strong>mysqld</strong></span> を起動します。テーブルレベルロックのみを使用するストレージエンジン (<code class="literal">MyISAM</code>、<code class="literal">MEMORY</code>、および <code class="literal">MERGE</code> など) の場合、これにより、テーブルを更新 (変更) するすべてのステートメントに <code class="literal">SELECT</code> ステートメントより低い優先度を与えます。この場合、先述のシナリオの 2 つめの <code class="literal">SELECT</code> ステートメントは <code class="literal">UPDATE</code> ステートメントの前に実行され、最初の <code class="literal">SELECT</code> の終了を待機しません。
          </p></li><li class="listitem"><p>
            特定の接続で発行されたすべての更新を低い優先度で実行させるように指定するには、<code class="literal">low_priority_updates</code> サーバーシステム変数を 1 に等しく設定します。
          </p></li><li class="listitem"><p>
            特定の <code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、または <code class="literal">DELETE</code> ステートメントに低い優先度を与えるには、<code class="literal">LOW_PRIORITY</code> 属性を使用します。
          </p></li><li class="listitem"><p>
            特定の <code class="literal">SELECT</code> ステートメントに高い優先度を与えるには、<code class="literal">HIGH_PRIORITY</code> 属性を使用します。<a class="xref" href="sql-syntax.html#select" title="13.2.9 SELECT 構文">セクション13.2.9「SELECT 構文」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">max_write_lock_count</code> システム変数の値を低くして <span class="command"><strong>mysqld</strong></span> を開始し、テーブルに対する特定の数の挿入が行われたあとにテーブルを待機しているすべての <code class="literal">SELECT</code> ステートメントの優先度を一時的に強制的に高めます。これにより、特定の数の <code class="literal">WRITE</code> ロックのあとの <code class="literal">READ</code> ロックが許可されます。
          </p></li><li class="listitem"><p>
            

            <code class="literal">SELECT</code> と組み合わせた <code class="literal">INSERT</code> に問題がある場合は、同時 <code class="literal">SELECT</code> ステートメントと <code class="literal">INSERT</code> ステートメントをサポートする <code class="literal">MyISAM</code> テーブルに切り替えることを考慮します。(<a class="xref" href="optimization.html#concurrent-inserts" title="8.10.3 同時挿入">セクション8.10.3「同時挿入」</a>を参照してください。)
          </p></li><li class="listitem"><p>
            同じ非トランザクションテーブルに対して挿入と削除を組み合わせる場合、<code class="literal">INSERT DELAYED</code> が役立つことがあります。<a class="xref" href="sql-syntax.html#insert-delayed" title="13.2.5.2 INSERT DELAYED 構文">セクション13.2.5.2「INSERT DELAYED 構文」</a>を参照してください。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              MySQL 5.6.6 現在、<code class="literal">INSERT DELAYED</code> は非推奨であり、将来のリリースで削除されます。代わりに <code class="literal">INSERT</code> (<code class="literal">DELAYED</code> を付けない) を使用してください。
            </p></div></li><li class="listitem"><p>
            組み合わされた <code class="literal">SELECT</code> と <code class="literal">DELETE</code> ステートメントに問題がある場合、<code class="literal">DELETE</code> への <code class="literal">LIMIT</code> オプションが役立つことがあります。<a class="xref" href="sql-syntax.html#delete" title="13.2.2 DELETE 構文">セクション13.2.2「DELETE 構文」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">SELECT</code> ステートメントで <code class="literal">SQL_BUFFER_RESULT</code> を使用すると、テーブルロックの時間の短縮に役立つことがあります。<a class="xref" href="sql-syntax.html#select" title="13.2.9 SELECT 構文">セクション13.2.9「SELECT 構文」</a>を参照してください。
          </p></li><li class="listitem"><p>
            テーブルの内容を個別のテーブルに分割すると (クエリーを 1 つのテーブルのカラムに対して実行し、更新を別のテーブルのカラムに制限することによって)、役立つことがあります。
          </p></li><li class="listitem"><p>
            単一のキューを使用するように、<code class="filename">mysys/thr_lock.c</code> のロックコードを変更できます。この場合、書き込みロックと読み取りロックは同じ優先度を持ち、一部のアプリケーションに役立つことがあります。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="concurrent-inserts"></a>8.10.3 同時挿入</h3></div></div></div><a class="indexterm" name="idm139979111483552"></a><a class="indexterm" name="idm139979111482080"></a><p>
        <code class="literal">MyISAM</code> ストレージエンジンでは、特定のテーブルに対する読み取りと書き込みの競合を軽減するために、同時挿入をサポートしています。<code class="literal">MyISAM</code> テーブルのデータファイルに隙間 (途中の削除された行) がない場合、<code class="literal">SELECT</code> ステートメントがテーブルの行を読み取るのと同時に、<code class="literal">INSERT</code> ステートメントを実行してテーブルの末尾に行を追加できます。複数の <code class="literal">INSERT</code> ステートメントがある場合、それらはキューに入れられ、<code class="literal">SELECT</code> ステートメントと同時に順番に実行されます。同時 <code class="literal">INSERT</code> の結果はすぐに見られないことがあります。
      </p><p>
        <code class="literal">concurrent_insert</code> システム変数を設定して、同時挿入の処理を変更できます。デフォルトで、変数は <code class="literal">AUTO</code> (または 1) に設定され、同時挿入が先述のように処理されます。<code class="literal">concurrent_insert</code> が <code class="literal">NEVER</code> (または 0) に設定されている場合、同時挿入は無効にされます。変数が <code class="literal">ALWAYS</code> (または 2) に設定されている場合、行が削除されたテーブルに対してもテーブルの末尾での同時挿入が許可されます。<code class="literal">concurrent_insert</code> システム変数の説明も参照してください。
      </p><p>
        同時挿入を使用できる状況下では、<code class="literal">INSERT</code> ステートメントの <code class="literal">DELAYED</code> 修飾子を使用する必要はほとんどありません。<a class="xref" href="sql-syntax.html#insert-delayed" title="13.2.5.2 INSERT DELAYED 構文">セクション13.2.5.2「INSERT DELAYED 構文」</a>を参照してください。
      </p><p>
        バイナリログを使用している場合、同時挿入は <code class="literal">CREATE ... SELECT</code> または <code class="literal">INSERT ... SELECT</code> ステートメントの通常の挿入に変換されます。これは、バックアップ操作中にログを適用することでテーブルの正確なコピーを確実に再作成できるようにするために行われます。<a class="xref" href="server-administration.html#binary-log" title="5.2.4 バイナリログ">セクション5.2.4「バイナリログ」</a>を参照してください。また、これらのステートメントに対しては、選択元のテーブルへの挿入がブロックされるように、そのテーブルに読み取りロックが設定されます。その結果、そのテーブルに対する同時挿入も待機する必要があります。
      </p><p>
        <code class="literal">LOAD DATA INFILE</code> で同時挿入の条件 (つまり、途中に空きブロックを含まない) を満たす <code class="literal">MyISAM</code> テーブルを使用して <code class="literal">CONCURRENT</code> を指定する場合、ほかのセッションは <code class="literal">LOAD DATA</code> の実行中にテーブルからデータを取得できます。<code class="literal">CONCURRENT</code> オプションの使用は、同時にテーブルを使用しているほかのセッションがない場合でも、<code class="literal">LOAD DATA</code> のパフォーマンスに多少の影響があります。
      </p><p>
        <code class="literal">HIGH_PRIORITY</code> を指定すると、サーバーが <code class="option">--low-priority-updates</code> オプションで起動されている場合に、その効果がオーバーライドされます。また、同時挿入も使用されなくなります。
      </p><p>
        <code class="literal">LOCK TABLE</code> の場合、<code class="literal">READ LOCAL</code> と <code class="literal">READ</code> の違いは <code class="literal">READ LOCAL</code> が、ロックが保持されている間に、競合していない <code class="literal">INSERT</code> ステートメント (同時挿入) の実行を許可することです。ただし、ロックを保持している間にサーバーの外部のプロセスを使用してデータベースを操作する場合、これを使用することはできません。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="metadata-locking"></a>8.10.4 メタデータのロック</h3></div></div></div><a class="indexterm" name="idm139979111442768"></a><a class="indexterm" name="idm139979111440592"></a><p>
        MySQL はメタデータのロックを使用して、オブジェクト (テーブル、トリガーなど) へのアクセスを管理します。メタデータのロックは、データの一貫性を確保するために使用されますが、いくらかのオーバーヘッドがあり、クエリーボリュームが増えるとそれも大きくなります。複数のクエリーが同じオブジェクトにアクセスを試みることが多くなるほど、メタデータの競合が増加します。
      </p><p>
        メタデータのロックは、テーブル定義キャッシュの代替ではなく、その相互排他ロックとロックは、<code class="literal">LOCK_open</code> 相互排他ロックと異なります。次の説明では、メタデータのロックの仕組みに関する情報を提供します。
      </p><p>
        トランザクションのシリアライザビリティーを確保するため、サーバーは、別のセッションで、未完了の明示的または暗黙的に開始されたトランザクションで使用されているテーブルに対して、セッションがデータ定義言語 (DDL) ステートメントを実行することを許可してはいけません。サーバーは、トランザクション内で使用されているテーブルに対してメタデータロックを獲得し、トランザクションが終了するまでそれらのロックの解放を延期させることによって、これを実現します。テーブルへのメタデータロックは、テーブルの構造への変更を妨げます。このロックアプローチには、あるセッション内のトランザクションによって使用されているテーブルは、トランザクションが終了するまで、ほかのセッションによって DDL ステートメントで使用できないという問題があります。
      </p><p>
        この原則は、トランザクションテーブルだけでなく、非トランザクションテーブルにも適用されます。あるセッションがトランザクションテーブル <code class="literal">t</code> と非トランザクションテーブル <code class="literal">nt</code> を次のように使用するトランザクションを開始するとします。
      </p><pre class="programlisting">
START TRANSACTION;
SELECT * FROM t;
SELECT * FROM nt;
</pre><p>
        サーバーはトランザクションが終了するまで、<code class="literal">t</code> と <code class="literal">nt</code> の両方に対するメタデータロックを保持します。別のセッションがいずれかのテーブルに対して、DDL または書き込みロック操作を試みると、それはトランザクションの終了時にメタデータロックが解放されるまでブロックされます。たとえば、2 つめのセッションはこれらのいずれかの操作を試みるとブロックされます。
      </p><pre class="programlisting">
DROP TABLE t;
ALTER TABLE t ...;
DROP TABLE nt;
ALTER TABLE nt ...;
LOCK TABLE t ... WRITE;
</pre><p>
        サーバーが構文上有効であるが、実行中に失敗するステートメントのメタデータロックを獲得した場合、そのロックを早期に解放しません。失敗したステートメントがバイナリログに書き込まれ、ロックによってログの一貫性が保護されるため、ロックの解放はまだトランザクションの終了まで延期されます。
      </p><p>
        自動コミットモードでは、各ステートメントが事実上完全なトランザクションであるため、そのステートメントに対して獲得されたメタデータロックは、ステートメントの終了までしか保持されません。
      </p><p>
        <code class="literal">PREPARE</code> ステートメント中に獲得されたメタデータロックは、準備が複数ステートメントトランザクション内で行われる場合でも、ステートメントが準備されると解放されます。
      </p><p>
        MySQL 5.5 より前では、トランザクションがステートメント内で使用されているテーブルのメタデータロックと同等のロックを獲得した場合、ステートメントの終了時にロックを解放していました。このアプローチには、アクティブなトランザクションで別のセッションによって使用されているテーブルに対して、DDL ステートメントが実行された場合、ステートメントは誤った順序でバイナリログに書き込まれる可能性があるという欠点がありました。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="external-locking"></a>8.10.5 外部ロック</h3></div></div></div><a class="indexterm" name="idm139979111421024"></a><a class="indexterm" name="idm139979111419568"></a><p>
        外部ロックは、複数のプロセスによる <code class="literal">MyISAM</code> データベーステーブルの競合を管理するためのファイルシステムロックの使用です。外部ロックは、MySQL サーバーなどの単一のプロセスが、テーブルへのアクセスを必要とする唯一のプロセスであると想定できない状況で使用されます。次にいくつかの例を示します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            同じデータベースディレクトリを使用する複数のサーバーを実行する場合 (推奨されません)、各サーバーで外部ロックが有効になっている必要があります。
          </p></li><li class="listitem"><p>
            <span class="command"><strong>myisamchk</strong></span> を使用して <code class="literal">MyISAM</code> テーブルに対して保守操作を実行する場合、サーバーが実行中でないことを確認するか、サーバーが必要に応じてテーブルファイルをロックし、テーブルへのアクセスを <span class="command"><strong>myisamchk</strong></span> によって調整するように、サーバーで外部ロックが有効になっていることを確認する必要があります。同じことが、<code class="literal">MyISAM</code> テーブルをパックするために <span class="command"><strong>myisampack</strong></span> を使用する場合にも当てはまります。
          </p><p>
            外部ロックを有効にしてサーバーを実行する場合、テーブルのチェックなどの読み取り操作のために、いつでも <span class="command"><strong>myisamchk</strong></span> を使用できます。この場合に、サーバーが <span class="command"><strong>myisamchk</strong></span> で使用しているテーブルを更新しようとする場合、サーバーは <span class="command"><strong>myisamchk</strong></span> が終了するまで待ってから、続行します。
          </p><p>
            テーブルの修復や最適化などの書き込み操作のために <span class="command"><strong>myisamchk</strong></span> を使用する場合、または <span class="command"><strong>myisampack</strong></span> を使用してテーブルをパックする場合は、<span class="command"><strong>mysqld</strong></span> サーバーがそのテーブルを使用していないことを常に確認する<span class="emphasis"><em>必要があります</em></span>。<span class="command"><strong>mysqld</strong></span> を停止しない場合、<span class="command"><strong>myisamchk</strong></span> を実行する前に、少なくとも <span class="command"><strong>mysqladmin flush-tables</strong></span> を実行してください。サーバーと <span class="command"><strong>myisamchk</strong></span> が同時にテーブルにアクセスすると、テーブルが<span class="emphasis"><em>破損する可能性があります</em></span>。
          </p></li></ul></div><p>
        外部ロックが有効になっていると、テーブルへのアクセスを必要とする各プロセスは、テーブルへのアクセスに進む前にテーブルファイルに対するファイルシステムロックを獲得します。必要なすべてのロックを獲得できない場合、(現在ロックを保持しているプロセスがそれらを解放したあとに) ロックを取得できるまで、プロセスはテーブルへのアクセスをブロックされます。
      </p><p>
        サーバーは場合によってテーブルにアクセスできるまでほかのプロセスを待機する必要があるため、外部ロックはサーバーのパフォーマンスに影響します。
      </p><p>
        単一のサーバーを実行して特定のデータディレクトリにアクセスする場合 (これは通常のケースです) およびサーバーの実行中に <span class="command"><strong>myisamchk</strong></span> などのほかのプログラムでテーブルを変更する必要がない場合、外部ロックは不要です。ほかのプログラムでテーブルを<span class="emphasis"><em>読み取る</em></span>だけである場合、外部ロックは不要ですが、<span class="command"><strong>myisamchk</strong></span> がテーブルを読み取っている間にサーバーがテーブルを変更すると、<span class="command"><strong>myisamchk</strong></span> が警告をレポートすることがあります。
      </p><p>
        外部ロックが無効になっていて、<span class="command"><strong>myisamchk</strong></span> を使用するには、<span class="command"><strong>myisamchk</strong></span> の実行中にサーバーを停止するか、<span class="command"><strong>myisamchk</strong></span> を実行する前にテーブルをロックし、フラッシュする必要があります。(<a class="xref" href="optimization.html#system-optimization" title="8.11.1 システム要素およびスタートアップパラメータのチューニング">セクション8.11.1「システム要素およびスタートアップパラメータのチューニング」</a>を参照してください。)この要件を回避するには、<code class="literal">CHECK TABLE</code> および <code class="literal">REPAIR TABLE</code> ステートメントを使用して、<code class="literal">MyISAM</code> テーブルをチェックし、修復します。
      </p><p>
        <span class="command"><strong>mysqld</strong></span> の場合、外部ロックは <code class="literal">skip_external_locking</code> システム変数の値で制御されます。この変数が有効にされている場合、外部ロックは無効になり、その逆も同じです。MySQL 4.0 以降、外部ロックはデフォルトで無効にされます。
      </p><p>
        外部ロックの使用は、サーバーの起動時に <code class="option">--external-locking</code> または <code class="option">--skip-external-locking</code> オプションを使用して制御できます。
      </p><p>
        多数の MySQL プロセスから <code class="literal">MyISAM</code> テーブルを更新できるようにするために外部ロックオプションを使用する場合、次の条件を満たしていることを確認する必要があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            別のプロセスによって更新されるテーブルを使用するクエリーには、クエリーキャッシュを使用しないでください。
          </p></li><li class="listitem"><p>
            サーバーを <code class="option">--delay-key-write=ALL</code> オプションで起動したり、共有テーブルに対して <code class="literal">DELAY_KEY_WRITE=1</code> テーブルオプションを使用したりしないでください。そうでないと、インデックスが破損する可能性があります。
          </p></li></ul></div><p>
        これらの条件をもっとも簡単に満たす方法は、常に <code class="option">--external-locking</code> を <code class="option">--delay-key-write=OFF</code> および <code class="option">--query-cache-size=0</code> と一緒に使用することです。(これは、多くのセットアップで、前述のオプションを組み合わせることが有用であるため、デフォルトで実行されません。)
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="optimizing-the-server"></a>8.11 MySQL サーバーの最適化</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#system-optimization">8.11.1 システム要素およびスタートアップパラメータのチューニング</a></span></dt><dt><span class="section"><a href="optimization.html#server-parameters">8.11.2 サーバーパラメータのチューニング</a></span></dt><dt><span class="section"><a href="optimization.html#disk-issues">8.11.3 ディスク I/O の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-memory">8.11.4 メモリーの使用の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#optimizing-network">8.11.5 ネットワークの使用の最適化</a></span></dt><dt><span class="section"><a href="optimization.html#thread-pool-plugin">8.11.6 スレッドプールプラグイン</a></span></dt></dl></div><p>
      このセクションでは、主に SQL ステートメントのチューニングではなくシステム構成を扱うデータベースサーバーの最適化技法について説明します。このセクションの情報は、管理しているサーバー全体のパフォーマンスとスケーラビリティーを確保したい DBA、データベースのセットアップを含むインストールスクリプトを構築する開発者、および生産性を最大にしたいと考え、開発、テストなどのために自分自身で MySQL を実行しているユーザーに適しています。
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="system-optimization"></a>8.11.1 システム要素およびスタートアップパラメータのチューニング</h3></div></div></div><a class="indexterm" name="idm139979111366336"></a><a class="indexterm" name="idm139979111364224"></a><a class="indexterm" name="idm139979111362848"></a><p>
        大幅なパフォーマンスの向上を実現するためには、システムレベルの要素の一部を早急に決定する必要があるため、その要素から始めます。ほかの場合は、このセクションをざっと目を通すだけで十分かもしれません。ただし、このレベルで適用する要素を変更することで、どの程度改善できるかの感覚をつかんでおくことは常に望ましいと考えられます。
      </p><p>
        本番環境で MySQL を使用する前に、目的のプラットフォームでそれをテストすることをお勧めします。
      </p><a class="indexterm" name="idm139979111359056"></a><p>
        ほかのヒント: 
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            RAM が十分にある場合は、すべてのスワップデバイスを取り外すことができます。オペレーティングシステムによっては、空きメモリーがある場合でも、特定のコンテキストで、スワップデバイスが使用されることがあります。
          </p></li><li class="listitem"><p>
            <code class="literal">MyISAM</code> テーブルの外部ロックを避けます。MySQL 4.0 以降、すべてのシステムで外部ロックはデフォルトで無効にされています。<code class="option">--external-locking</code> と <code class="option">--skip-external-locking</code> オプションは外部ロックを明示的に有効および無効にします。
          </p><p>
            外部ロックを無効にしても、1 台のサーバーしか実行していないかぎり、MySQL の機能に影響しません。<span class="command"><strong>myisamchk</strong></span> を実行する前にサーバーを停止する (または関連するテーブルをロックしてフラッシュする) ことを忘れないでください。一部のシステムでは外部ロックが機能しないため、無効にする必要があります。
          </p><p>
            外部ロックを無効にできない唯一のケースは、同じデータに対して複数の MySQL <span class="emphasis"><em>サーバー</em></span> (クライアントではない) を実行している場合、またはサーバーにまずテーブルをフラッシュしてロックするように伝えずに、<span class="command"><strong>myisamchk</strong></span> を実行してテーブルをチェックする (修復しない) 場合です。MySQL Cluster を使用している場合を除き、複数の MySQL サーバーを使用して、同じデータに同時にアクセスすることは一般に推奨<span class="emphasis"><em>されません</em></span>。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              MySQL Cluster は現在 MySQL 5.6 でサポートされていません。MySQL Cluster のアップグレードを希望するユーザーは、代わりに MySQL Cluster NDB 7.3 に移行してください。これは MySQL 5.6 に基づいていますが、最新の <code class="literal">NDB</code> の改善と修正が含まれています。
            </p></div><p>
            <code class="literal">LOCK TABLES</code> および <code class="literal">UNLOCK TABLES</code> ステートメントは内部ロックを使用するため、外部ロックが無効にされている場合でもそれらを使用できます。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="server-parameters"></a>8.11.2 サーバーパラメータのチューニング</h3></div></div></div><a class="indexterm" name="idm139979111339968"></a><a class="indexterm" name="idm139979111337856"></a><a class="indexterm" name="idm139979111335776"></a><a class="indexterm" name="idm139979111333696"></a><p>
        次のコマンドを使用して、<span class="command"><strong>mysqld</strong></span> サーバーで使用されるデフォルトのバッファーサイズを判断できます。
      </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>mysqld --verbose --help</code></strong>
</pre><a class="indexterm" name="idm139979111329648"></a><a class="indexterm" name="idm139979111328160"></a><p>
        このコマンドによって、すべての <span class="command"><strong>mysqld</strong></span> オプションと構成可能なシステム変数のリストが生成されます。この出力には、デフォルトの変数値も含まれ、次のように見えます。
      </p><pre class="programlisting">
abort-slave-event-count                                    0
allow-suspicious-udfs                                      FALSE
archive                                                    ON
auto-increment-increment                                   1
auto-increment-offset                                      1
autocommit                                                 TRUE
automatic-sp-privileges                                    TRUE
back-log                                                   80
basedir                                                    /home/jon/bin/mysql-5.6/
big-tables                                                 FALSE
bind-address                                               *
binlog-cache-size                                          32768
binlog-checksum                                            CRC32
binlog-direct-non-transactional-updates                    FALSE
binlog-format                                              STATEMENT
binlog-max-flush-queue-time                                0
binlog-order-commits                                       TRUE
binlog-row-event-max-size                                  8192
binlog-row-image                                           FULL
binlog-rows-query-log-events                               FALSE
binlog-stmt-cache-size                                     32768
blackhole                                                  ON
bulk-insert-buffer-size                                    8388608
character-set-client-handshake                             TRUE
character-set-filesystem                                   binary
character-set-server                                       latin1
character-sets-dir                                         /home/jon/bin/mysql-5.6/share/charsets/
chroot                                                     (No default value)
collation-server                                           latin1_swedish_ci
completion-type                                            NO_CHAIN
concurrent-insert                                          AUTO
connect-timeout                                            10
console                                                    FALSE
datadir                                                    (No default value)
date-format                                                %Y-%m-%d
datetime-format                                            %Y-%m-%d %H:%i:%s
default-storage-engine                                     InnoDB
default-time-zone                                          (No default value)
default-tmp-storage-engine                                 InnoDB
default-week-format                                        0
delay-key-write                                            ON
delayed-insert-limit                                       100
delayed-insert-timeout                                     300
delayed-queue-size                                         1000
des-key-file                                               (No default value)
disconnect-on-expired-password                             TRUE
disconnect-slave-event-count                               0
div-precision-increment                                    4
end-markers-in-json                                        FALSE
enforce-gtid-consistency                                   FALSE
eq-range-index-dive-limit                                  10
event-scheduler                                            OFF
expire-logs-days                                           0
explicit-defaults-for-timestamp                            FALSE
external-locking                                           FALSE
flush                                                      FALSE
flush-time                                                 0
ft-boolean-syntax                                          + -&gt;&lt;()~*:""&amp;|
ft-max-word-len                                            84
ft-min-word-len                                            4
ft-query-expansion-limit                                   20
ft-stopword-file                                           (No default value)
gdb                                                        FALSE
general-log                                                FALSE
general-log-file                                           /home/jon/bin/mysql-5.6/data/havskatt.log
group-concat-max-len                                       1024
gtid-mode                                                  OFF
help                                                       TRUE
host-cache-size                                            279
ignore-builtin-innodb                                      FALSE
init-connect                                               
init-file                                                  (No default value)
init-slave                                                 
innodb                                                     ON
innodb-adaptive-flushing                                   TRUE
innodb-adaptive-flushing-lwm                               10
innodb-adaptive-hash-index                                 TRUE
innodb-adaptive-max-sleep-delay                            150000
innodb-additional-mem-pool-size                            8388608
innodb-api-bk-commit-interval                              5
innodb-api-disable-rowlock                                 FALSE
innodb-api-enable-binlog                                   FALSE
innodb-api-enable-mdl                                      FALSE
innodb-api-trx-level                                       0
innodb-autoextend-increment                                64
innodb-autoinc-lock-mode                                   1
innodb-buffer-page                                         ON
innodb-buffer-page-lru                                     ON
innodb-buffer-pool-dump-at-shutdown                        FALSE
innodb-buffer-pool-dump-now                                FALSE
innodb-buffer-pool-filename                                ib_buffer_pool
innodb-buffer-pool-instances                               0
innodb-buffer-pool-load-abort                              FALSE
innodb-buffer-pool-load-at-startup                         FALSE
innodb-buffer-pool-load-now                                FALSE
innodb-buffer-pool-size                                    134217728
innodb-buffer-pool-stats                                   ON
innodb-change-buffer-max-size                              25
innodb-change-buffering                                    all
innodb-checksum-algorithm                                  innodb
innodb-checksums                                           TRUE
innodb-cmp                                                 ON
innodb-cmp-per-index                                       ON
innodb-cmp-per-index-enabled                               FALSE
innodb-cmp-per-index-reset                                 ON
innodb-cmp-reset                                           ON
innodb-cmpmem                                              ON
innodb-cmpmem-reset                                        ON
innodb-commit-concurrency                                  0
innodb-compression-failure-threshold-pct                   5
innodb-compression-level                                   6
innodb-compression-pad-pct-max                             50
innodb-concurrency-tickets                                 5000
innodb-data-file-path                                      (No default value)
innodb-data-home-dir                                       (No default value)
innodb-disable-sort-file-cache                             FALSE
innodb-doublewrite                                         TRUE
innodb-fast-shutdown                                       1
innodb-file-format                                         Antelope
innodb-file-format-check                                   TRUE
innodb-file-format-max                                     Antelope
innodb-file-io-threads                                     4
innodb-file-per-table                                      TRUE
innodb-flush-log-at-timeout                                1
innodb-flush-log-at-trx-commit                             1
innodb-flush-method                                        (No default value)
innodb-flush-neighbors                                     1
innodb-flushing-avg-loops                                  30
innodb-force-load-corrupted                                FALSE
innodb-force-recovery                                      0
innodb-ft-aux-table                                        (No default value)
innodb-ft-being-deleted                                    ON
innodb-ft-cache-size                                       8000000
innodb-ft-config                                           ON
innodb-ft-default-stopword                                 ON
innodb-ft-deleted                                          ON
innodb-ft-enable-diag-print                                FALSE
innodb-ft-enable-stopword                                  TRUE
innodb-ft-index-cache                                      ON
innodb-ft-index-table                                      ON
innodb-ft-inserted                                         ON
innodb-ft-max-token-size                                   84
innodb-ft-min-token-size                                   3
innodb-ft-num-word-optimize                                2000
innodb-ft-server-stopword-table                            (No default value)
innodb-ft-sort-pll-degree                                  2
innodb-ft-user-stopword-table                              (No default value)
innodb-io-capacity                                         200
innodb-io-capacity-max                                     18446744073709551615
innodb-large-prefix                                        FALSE
innodb-lock-wait-timeout                                   50
innodb-lock-waits                                          ON
innodb-locks                                               ON
innodb-locks-unsafe-for-binlog                             FALSE
innodb-log-buffer-size                                     8388608
innodb-log-compressed-pages                                TRUE
innodb-log-file-size                                       50331648
innodb-log-files-in-group                                  2
innodb-log-group-home-dir                                  (No default value)
innodb-lru-scan-depth                                      1024
innodb-max-dirty-pages-pct                                 75
innodb-max-dirty-pages-pct-lwm                             0
innodb-max-purge-lag                                       0
innodb-max-purge-lag-delay                                 0
innodb-metrics                                             ON
innodb-mirrored-log-groups                                 1
innodb-monitor-disable                                     (No default value)
innodb-monitor-enable                                      (No default value)
innodb-monitor-reset                                       (No default value)
innodb-monitor-reset-all                                   (No default value)
innodb-old-blocks-pct                                      37
innodb-old-blocks-time                                     1000
innodb-online-alter-log-max-size                           134217728
innodb-open-files                                          0
innodb-optimize-fulltext-only                              FALSE
innodb-page-size                                           16384
innodb-print-all-deadlocks                                 FALSE
innodb-purge-batch-size                                    300
innodb-purge-threads                                       1
innodb-random-read-ahead                                   FALSE
innodb-read-ahead-threshold                                56
innodb-read-io-threads                                     4
innodb-read-only                                           FALSE
innodb-replication-delay                                   0
innodb-rollback-on-timeout                                 FALSE
innodb-rollback-segments                                   128
innodb-sort-buffer-size                                    1048576
innodb-spin-wait-delay                                     6
innodb-stats-auto-recalc                                   TRUE
innodb-stats-method                                        nulls_equal
innodb-stats-on-metadata                                   FALSE
innodb-stats-persistent                                    TRUE
innodb-stats-persistent-sample-pages                       20
innodb-stats-sample-pages                                  8
innodb-stats-transient-sample-pages                        8
innodb-status-file                                         FALSE
innodb-strict-mode                                         FALSE
innodb-support-xa                                          TRUE
innodb-sync-array-size                                     1
innodb-sync-spin-loops                                     30
innodb-sys-columns                                         ON
innodb-sys-datafiles                                       ON
innodb-sys-fields                                          ON
innodb-sys-foreign                                         ON
innodb-sys-foreign-cols                                    ON
innodb-sys-indexes                                         ON
innodb-sys-tables                                          ON
innodb-sys-tablespaces                                     ON
innodb-sys-tablestats                                      ON
innodb-table-locks                                         TRUE
innodb-thread-concurrency                                  0
innodb-thread-sleep-delay                                  10000
innodb-trx                                                 ON
innodb-undo-directory                                      .
innodb-undo-logs                                           128
innodb-undo-tablespaces                                    0
innodb-use-native-aio                                      TRUE
innodb-use-sys-malloc                                      TRUE
innodb-write-io-threads                                    4
interactive-timeout                                        28800
join-buffer-size                                           262144
keep-files-on-create                                       FALSE
key-buffer-size                                            8388608
key-cache-age-threshold                                    300
key-cache-block-size                                       1024
key-cache-division-limit                                   100
language                                                   /home/jon/bin/mysql-5.6/share/
large-pages                                                FALSE
lc-messages                                                en_US
lc-messages-dir                                            /home/jon/bin/mysql-5.6/share/
lc-time-names                                              en_US
local-infile                                               TRUE
lock-wait-timeout                                          31536000
log-bin                                                    (No default value)
log-bin-index                                              (No default value)
log-bin-trust-function-creators                            FALSE
log-bin-use-v1-row-events                                  FALSE
log-error                                                  
log-isam                                                   myisam.log
log-output                                                 FILE
log-queries-not-using-indexes                              FALSE
log-raw                                                    FALSE
log-short-format                                           FALSE
log-slave-updates                                          FALSE
log-slow-admin-statements                                  FALSE
log-slow-slave-statements                                  FALSE
log-tc                                                     tc.log
log-tc-size                                                24576
log-throttle-queries-not-using-indexes                     0
log-warnings                                               1
long-query-time                                            10
low-priority-updates                                       FALSE
lower-case-table-names                                     0
master-info-file                                           master.info
master-info-repository                                     FILE
master-retry-count                                         86400
master-verify-checksum                                     FALSE
max-allowed-packet                                         4194304
max-binlog-cache-size                                      18446744073709547520
max-binlog-dump-events                                     0
max-binlog-size                                            1073741824
max-binlog-stmt-cache-size                                 18446744073709547520
max-connect-errors                                         100
max-connections                                            151
max-delayed-threads                                        20
max-error-count                                            64
max-heap-table-size                                        16777216
max-join-size                                              18446744073709551615
max-length-for-sort-data                                   1024
max-prepared-stmt-count                                    16382
max-relay-log-size                                         0
max-seeks-for-key                                          18446744073709551615
max-sort-length                                            1024
max-sp-recursion-depth                                     0
max-tmp-tables                                             32
max-user-connections                                       0
max-write-lock-count                                       18446744073709551615
memlock                                                    FALSE
metadata-locks-cache-size                                  1024
metadata-locks-hash-instances                              8
min-examined-row-limit                                     0
multi-range-count                                          256
myisam-block-size                                          1024
myisam-data-pointer-size                                   6
myisam-max-sort-file-size                                  9223372036853727232
myisam-mmap-size                                           18446744073709551615
myisam-recover-options                                     OFF
myisam-repair-threads                                      1
myisam-sort-buffer-size                                    8388608
myisam-stats-method                                        nulls_unequal
myisam-use-mmap                                            FALSE
net-buffer-length                                          16384
net-read-timeout                                           30
net-retry-count                                            10
net-write-timeout                                          60
new                                                        FALSE
old                                                        FALSE
old-alter-table                                            FALSE
old-passwords                                              0
old-style-user-limits                                      FALSE
open-files-limit                                           1024
optimizer-prune-level                                      1
optimizer-search-depth                                     62
optimizer-switch                                           index_merge=on,index_merge_union=on,index_merge_sort_union=on,index_merge_intersection=on,engine_condition_pushdown=on,index_condition_pushdown=on,mrr=on,mrr_cost_based=on,block_nested_loop=on,batched_key_access=off,materialization=on,semijoin=on,loosescan=on,firstmatch=on,subquery_materialization_cost_based=on,use_index_extensions=on
optimizer-trace                                            
optimizer-trace-features                                   greedy_search=on,range_optimizer=on,dynamic_range=on,repeated_subselect=on
optimizer-trace-limit                                      1
optimizer-trace-max-mem-size                               16384
optimizer-trace-offset                                     -1
partition                                                  ON
performance-schema                                         TRUE
performance-schema-accounts-size                           -1
performance-schema-consumer-events-stages-current          FALSE
performance-schema-consumer-events-stages-history          FALSE
performance-schema-consumer-events-stages-history-long     FALSE
performance-schema-consumer-events-statements-current      TRUE
performance-schema-consumer-events-statements-history      FALSE
performance-schema-consumer-events-statements-history-long FALSE
performance-schema-consumer-events-waits-current           FALSE
performance-schema-consumer-events-waits-history           FALSE
performance-schema-consumer-events-waits-history-long      FALSE
performance-schema-consumer-global-instrumentation         TRUE
performance-schema-consumer-statements-digest              TRUE
performance-schema-consumer-thread-instrumentation         TRUE
performance-schema-digests-size                            -1
performance-schema-events-stages-history-long-size         -1
performance-schema-events-stages-history-size              -1
performance-schema-events-statements-history-long-size     -1
performance-schema-events-statements-history-size          -1
performance-schema-events-waits-history-long-size          -1
performance-schema-events-waits-history-size               -1
performance-schema-hosts-size                              -1
performance-schema-instrument                              
performance-schema-max-cond-classes                        80
performance-schema-max-cond-instances                      -1
performance-schema-max-file-classes                        50
performance-schema-max-file-handles                        32768
performance-schema-max-file-instances                      -1
performance-schema-max-mutex-classes                       200
performance-schema-max-mutex-instances                     -1
performance-schema-max-rwlock-classes                      30
performance-schema-max-rwlock-instances                    -1
performance-schema-max-socket-classes                      10
performance-schema-max-socket-instances                    -1
performance-schema-max-stage-classes                       150
performance-schema-max-statement-classes                   167
performance-schema-max-table-handles                       -1
performance-schema-max-table-instances                     -1
performance-schema-max-thread-classes                      50
performance-schema-max-thread-instances                    -1
performance-schema-session-connect-attrs-size              -1
performance-schema-setup-actors-size                       100
performance-schema-setup-objects-size                      100
performance-schema-users-size                              -1
pid-file                                                   /home/jon/bin/mysql-5.6/data/havskatt.pid
plugin-dir                                                 /home/jon/bin/mysql-5.6/lib/plugin/
port                                                       3306
port-open-timeout                                          0
preload-buffer-size                                        32768
profiling-history-size                                     15
query-alloc-block-size                                     8192
query-cache-limit                                          1048576
query-cache-min-res-unit                                   4096
query-cache-size                                           1048576
query-cache-type                                           OFF
query-cache-wlock-invalidate                               FALSE
query-prealloc-size                                        8192
range-alloc-block-size                                     4096
read-buffer-size                                           131072
read-only                                                  FALSE
read-rnd-buffer-size                                       262144
relay-log                                                  (No default value)
relay-log-index                                            (No default value)
relay-log-info-file                                        relay-log.info
relay-log-info-repository                                  FILE
relay-log-purge                                            TRUE
relay-log-recovery                                         FALSE
relay-log-space-limit                                      0
replicate-same-server-id                                   FALSE
report-host                                                (No default value)
report-password                                            (No default value)
report-port                                                0
report-user                                                (No default value)
safe-user-create                                           FALSE
secure-auth                                                TRUE
secure-file-priv                                           (No default value)
server-id                                                  0
server-id-bits                                             32
sha256-password-private-key-path                           private_key.pem
sha256-password-public-key-path                            public_key.pem
show-slave-auth-info                                       FALSE
skip-grant-tables                                          FALSE
skip-name-resolve                                          FALSE
skip-networking                                            FALSE
skip-show-database                                         FALSE
skip-slave-start                                           FALSE
slave-allow-batching                                       FALSE
slave-checkpoint-group                                     512
slave-checkpoint-period                                    300
slave-compressed-protocol                                  FALSE
slave-exec-mode                                            STRICT
slave-load-tmpdir                                          /tmp
slave-max-allowed-packet                                   1073741824
slave-net-timeout                                          3600
slave-parallel-workers                                     0
slave-pending-jobs-size-max                                16777216
slave-rows-search-algorithms                               TABLE_SCAN,INDEX_SCAN
slave-skip-errors                                          (No default value)
slave-sql-verify-checksum                                  TRUE
slave-transaction-retries                                  10
slave-type-conversions                                     
slow-launch-time                                           2
slow-query-log                                             FALSE
slow-query-log-file                                        /home/jon/bin/mysql-5.6/data/havskatt-slow.log
socket                                                     /tmp/mysql.sock
sort-buffer-size                                           262144
sporadic-binlog-dump-fail                                  FALSE
sql-mode                                                   NO_ENGINE_SUBSTITUTION
ssl                                                        FALSE
ssl-ca                                                     (No default value)
ssl-capath                                                 (No default value)
ssl-cert                                                   (No default value)
ssl-cipher                                                 (No default value)
ssl-crl                                                    (No default value)
ssl-crlpath                                                (No default value)
ssl-key                                                    (No default value)
stored-program-cache                                       256
super-large-pages                                          FALSE
symbolic-links                                             TRUE
sync-binlog                                                0
sync-frm                                                   TRUE
sync-master-info                                           10000
sync-relay-log                                             10000
sync-relay-log-info                                        10000
sysdate-is-now                                             FALSE
table-definition-cache                                     615
table-open-cache                                           431
table-open-cache-instances                                 1
tc-heuristic-recover                                       COMMIT
temp-pool                                                  TRUE
thread-cache-size                                          9
thread-concurrency                                         10
thread-handling                                            one-thread-per-connection
thread-stack                                               262144
time-format                                                %H:%i:%s
timed-mutexes                                              FALSE
tmp-table-size                                             16777216
tmpdir                                                     /tmp
transaction-alloc-block-size                               8192
transaction-isolation                                      REPEATABLE-READ
transaction-prealloc-size                                  4096
transaction-read-only                                      FALSE
updatable-views-with-limit                                 YES
verbose                                                    TRUE
wait-timeout
</pre><p>
        現在実行中の <span class="command"><strong>mysqld</strong></span> サーバーの場合、それに接続し、次のステートメントを発行することで、そのシステム変数の現在の値を確認できます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW VARIABLES;</code></strong>
</pre><p>
        また、次のステートメントを発行して、実行中のサーバーの統計やステータスインジケータの一部を表示することもできます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW STATUS;</code></strong>
</pre><p>
        システム変数とステータス情報は、<span class="command"><strong>mysqladmin</strong></span> を使用して取得することもできます。
      </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>mysqladmin variables</code></strong>
shell&gt; <strong class="userinput"><code>mysqladmin extended-status</code></strong>
</pre><p>
        すべてのシステムおよびステータス変数の完全な説明については、<a class="xref" href="server-administration.html#server-system-variables" title="5.1.4 サーバーシステム変数">セクション5.1.4「サーバーシステム変数」</a>および<a class="xref" href="server-administration.html#server-status-variables" title="5.1.6 サーバーステータス変数">セクション5.1.6「サーバーステータス変数」</a>を参照してください。
      </p><p>
        MySQL はきわめてスケーラブルなアルゴリズムを使用しているため、通常ごくわずかなメモリーで実行できます。ただし、通常 MySQL に多くのメモリーを割り当てることによって、パフォーマンスが向上します。
      </p><p>
        MySQL サーバーをチューニングする場合、構成するもっとも重要な 2 つの変数は <code class="literal">key_buffer_size</code> と <code class="literal">table_open_cache</code> です。ほかの変数の変更を試みる前に、まずこれらの変数が適切に設定されていることを確信しておくべきです。
      </p><p>
        次の例に、さまざまな実行時構成の一般的な変数値を示します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            少なくとも 256M バイトのメモリーと多くのテーブルがあり、中程度のクライアント数で最大のパフォーマンスを必要とする場合、次のようなものを使用します。
          </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>mysqld_safe --key_buffer_size=64M --table_open_cache=256 \</code></strong>
           <strong class="userinput"><code>--sort_buffer_size=4M --read_buffer_size=1M &amp;</code></strong>
</pre></li><li class="listitem"><p>
            メモリーが 128M バイトで、少数のテーブルしかないが、大量のソートを実行する場合、次のようなものを使用できます。
          </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>mysqld_safe --key_buffer_size=16M --sort_buffer_size=1M</code></strong>
</pre><p>
            著しく多くの同時接続がある場合、<span class="command"><strong>mysqld</strong></span> が接続ごとにごく少量のメモリーを使用するように構成されていないかぎり、スワップの問題が発生する可能性があります。すべての接続に十分なメモリーがある場合に、<span class="command"><strong>mysqld</strong></span> は効率的に実行します。
          </p></li><li class="listitem"><p>
            メモリーがほとんどなく大量の接続がある場合は、次のようなものを使用します。
          </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>mysqld_safe --key_buffer_size=512K --sort_buffer_size=100K \</code></strong>
           <strong class="userinput"><code>--read_buffer_size=100K &amp;</code></strong>
</pre><p>
            これでもかまいません。
          </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>mysqld_safe --key_buffer_size=512K --sort_buffer_size=16K \</code></strong>
           <strong class="userinput"><code>--table_open_cache=32 --read_buffer_size=8K \</code></strong>
           <strong class="userinput"><code>--net_buffer_length=1K &amp;</code></strong>
</pre></li></ul></div><p>
        使用可能なメモリーよりはるかに大きいテーブルに対して、<code class="literal">GROUP BY</code> または <code class="literal">ORDER BY</code> 操作を実行する場合、<code class="literal">read_rnd_buffer_size</code> の値を増やして、行の読み取りとそれに続くソート操作を高速化します。
      </p><p>
        MySQL 配布に付属するサンプルオプションファイルを使用できます。<a class="xref" href="server-administration.html#server-configuration-defaults" title="5.1.2 サーバー構成のデフォルト値">セクション5.1.2「サーバー構成のデフォルト値」</a>を参照してください。
      </p><p>
        コマンド行で <span class="command"><strong>mysqld</strong></span> または <span class="command"><strong>mysqld_safe</strong></span> のオプションを指定する場合、そのサーバーの呼び出しに対してのみ有効です。サーバーの実行のたびにオプションを使用するには、それをオプションファイルに入れます。
      </p><p>
        パラメータの変更の効果を確認するには、次のようなものを実行します。
      </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>mysqld --key_buffer_size=32M --verbose --help</code></strong>
</pre><p>
        変数値は出力の最後近くに一覧表示されます。<code class="option">--verbose</code> および <code class="option">--help</code> オプションが最後になるようにしてください。そうでないと、コマンド行でそれらのあとに挙げられているすべてのオプションの効果が出力に反映されません。
      </p><p>
        <code class="literal">InnoDB</code> ストレージエンジンのチューニングについては、<a class="xref" href="optimization.html#optimizing-innodb" title="8.5 InnoDB テーブルの最適化">セクション8.5「InnoDB テーブルの最適化」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="disk-issues"></a>8.11.3 ディスク I/O の最適化</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#symbolic-links">8.11.3.1 シンボリックリンクの使用</a></span></dt></dl></div><a class="indexterm" name="idm139979111223568"></a><a class="indexterm" name="idm139979111222112"></a><a class="indexterm" name="idm139979111220080"></a><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            ディスクシークはパフォーマンスの大きなボトルネックです。この問題は、データの量が、効果的なキャッシュが実行不能になるほど大きくなり始めると、明確になります。多かれ少なかれランダムにデータにアクセスする大きなデータベースの場合、読み取りには最低 1 回、書き込みには 2 回のディスクシークが確実に必要になります。この問題を最小にするには、少ないシーク回数でディスクを使用します。
          </p></li><li class="listitem"><p>
            さまざまなディスクにファイルをシンボリックリンクするか、ディスクストライピングを行なって、使用可能なディスクスピンドル数を増やします (およびそれによってシークのオーバーヘッドを軽減します)。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                シンボリックリンクの使用
              </p><p>
                これは、<code class="literal">MyISAM</code> テーブルの場合、データディレクトリ内の通常の場所から別のディスクへのインデックスファイルやデータファイルのシンボリックリンクを作成する (ストライピングされることもある) ことを意味します。ディスクがほかの目的にも使用されていないものとして、これによって、シークと読み取り時間がともに改善されます。<a class="xref" href="optimization.html#symbolic-links" title="8.11.3.1 シンボリックリンクの使用">セクション8.11.3.1「シンボリックリンクの使用」</a>を参照してください。
              </p></li><li class="listitem"><p>
                <a class="indexterm" name="idm139979111210912"></a> ストライピング
              </p><p>
                ストライピングは、多数のディスクがあり、最初のブロックを最初のディスクに、2 番目のブロックを 2 番目のディスクに、<em class="replaceable"><code>N</code></em> 番目のブロックを (<code class="literal"><em class="replaceable"><code>N</code></em> MOD <em class="replaceable"><code>number_of_disks</code></em></code>) 番目のディスクにというように配置することを意味します。つまり、通常のデータサイズがストライプサイズより小さい (または完全に一致している) 場合に、パフォーマンスが大幅に向上します。ストライピングはオペレーティングシステムとストライプサイズに大きく依存するため、さまざまなストライプサイズでアプリケーションのベンチマークを行なってください。<a class="xref" href="optimization.html#custom-benchmarks" title="8.12.3 独自のベンチマークの使用">セクション8.12.3「独自のベンチマークの使用」</a>を参照してください。
              </p><p>
                ストライピングの速度の違いは、パラメータに<span class="emphasis"><em>大きく</em></span>依存します。ストライピングパラメータの設定方法とディスク数によって、桁違いの差が測定されることがあります。ランダムアクセスに対する最適化か順次アクセスに対する最適化かを選択する必要があります。
              </p></li></ul></div></li><li class="listitem"><p>
            信頼性のため、RAID 0+1 (ストライピングとミラーリング) を使用したいと考える場合がありますが、この場合、<em class="replaceable"><code>N</code></em> 個のドライブのデータを保持するために 2 × <em class="replaceable"><code>N</code></em> 個のドライブが必要です。これは、そのための資金がある場合に最適なオプションである可能性があります。ただし、それを効率的に処理するために、何らかのボリューム管理ソフトウェアに投資する必要がある場合もあります。
          </p></li><li class="listitem"><p>
            適切なオプションは、ある種類のデータがどのくらい重要であるかに応じて RAID レベルを変えることです。たとえば、再生成が可能なやや重要なデータは RAID 0 ディスクに格納しますが、ホスト情報やログなどの本当に重要なデータは、RAID 0+1 または RAID <em class="replaceable"><code>N</code></em> ディスクに格納します。RAID <em class="replaceable"><code>N</code></em> は、パリティビットの更新に必要な時間のため、多くの書き込みがある場合に問題になる可能性があります。
          </p></li><li class="listitem"><p>
            Linux では、<code class="literal">hdparm</code> を使用して、ディスクのインタフェースを構成することによって、パフォーマンスを大幅に向上できます。(負荷時に最大 100% も珍しくありません。)次の <code class="literal">hdparm</code> オプションは、MySQL、およびおそらくその他の多くのアプリケーションに非常に適しているはずです。
          </p><pre class="programlisting">
hdparm -m 16 -d 1
</pre><p>
            このコマンドを使用したときのパフォーマンスと信頼性はハードウェアに依存するため、<code class="literal">hdparm</code> の使用後はシステムを徹底的にテストすることを強くお勧めします。詳細については、<code class="literal">hdparm</code> のマニュアルページを参照してください。<code class="literal">hdparm</code> を適切に使用しないと、ファイルシステムの破損が発生することがあるため、実験する前に、すべてをバックアップしてください。
          </p></li><li class="listitem"><p>
            データベースが使用するファイルシステムのパラメータを設定することもできます。
          </p><p>
            ファイルに最後にアクセスされたタイミングを知る必要がない (実際にデータベースサーバーで役立たない) 場合、<code class="option">-o noatime</code> オプションを使用してファイルシステムをマウントできます。それは、ファイルシステム上の i ノードの最終アクセス時間への更新をスキップするため、一部のディスクシークが避けられます。
          </p><p>
            多くのオペレーティングシステムで、<code class="option">-o async</code> オプションを使用してファイルシステムをマウントすることによって、ファイルシステムが非同期に更新されるように設定できます。コンピュータが適度に安定している場合、これにより、それほど信頼性を犠牲にすることなく、パフォーマンスが向上するはずです。(Linux ではこのフラグがデフォルトでオンにされています。)
          </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="symbolic-links"></a>8.11.3.1 シンボリックリンクの使用</h4></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#symbolic-links-to-databases">8.11.3.1.1 Unix 上のデータベースへのシンボリックリンクの使用</a></span></dt><dt><span class="section"><a href="optimization.html#symbolic-links-to-tables">8.11.3.1.2 Unix 上の MyISAM へのシンボリックリンクの使用</a></span></dt><dt><span class="section"><a href="optimization.html#windows-symbolic-links">8.11.3.1.3 Windows 上のデータベースへのシンボリックリンクの使用</a></span></dt></dl></div><a class="indexterm" name="idm139979111184880"></a><a class="indexterm" name="idm139979111183424"></a><p>
          データベースやテーブルをデータベースディレクトリからほかの場所に移動して、それらを新しい場所へのシンボリックリンクに置き換えることができます。これを実行したいと考える可能性があるのは、たとえば、データベースを空き領域の多いファイルシステムに移動する場合や、テーブルを別のディスクに分散させてシステムの速度を高める場合です。
        </p><p>
          <code class="literal">InnoDB</code> テーブルの場合、<a class="xref" href="innodb-storage-engine.html#tablespace-placing" title="14.5.4 テーブルスペースの位置の指定">セクション14.5.4「テーブルスペースの位置の指定」</a>に説明するように、シンボリックリンクの代わりに、<code class="literal">CREATE TABLE</code> ステートメントで <code class="literal">DATA DIRECTORY</code> 句を使用します。この新機能は、サポートされるクロスプラットフォーム技法です。
        </p><p>
          これを実行する推奨される方法は、データベースディレクトリ全体の別のディスクへのシンボリックリンクを作成することです。<code class="literal">MyISAM</code> テーブルのシンボルリンク作成は最後の手段として行います。
        </p><p>
          データディレクトリの場所を特定するには、次のステートメントを使用します。
        </p><pre class="programlisting">
SHOW VARIABLES LIKE 'datadir';
</pre><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="symbolic-links-to-databases"></a>8.11.3.1.1 Unix 上のデータベースへのシンボリックリンクの使用</h5></div></div></div><a class="indexterm" name="idm139979111172288"></a><p>
            Unix で、データベースのシンボリックリンクを作成する方法は、まず空き領域のあるディスクにディレクトリを作成してから、MySQL データディレクトリからそれへのソフトリンクを作成することです。
          </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>mkdir /dr1/databases/test</code></strong>
shell&gt; <strong class="userinput"><code>ln -s /dr1/databases/test <em class="replaceable"><code>/path/to/datadir</code></em></code></strong>
</pre><p>
            MySQL は、1 つのディレクトリから複数のデータベースへのリンクをサポートしていません。データベースディレクトリとシンボリックリンクの置換は、データベース間のシンボリックリンクを作成しないかぎり、機能します。MySQL データディレクトリにデータベース <code class="literal">db1</code> があり、<code class="literal">db1</code> を指すシンボリックリンク <code class="literal">db2</code> を作成するとします。
          </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>cd <em class="replaceable"><code>/path/to/datadir</code></em></code></strong>
shell&gt; <strong class="userinput"><code>ln -s db1 db2</code></strong>
</pre><p>
            その結果、<code class="literal">db1</code> のすべてのテーブル <code class="literal">tbl_a</code> は、<code class="literal">db2</code> にもテーブル <code class="literal">tbl_a</code> として表示されます。あるクライアントが <code class="literal">db1.tbl_a</code> を更新し、ほかのクライアントが <code class="literal">db2.tbl_a</code> を更新すると、問題が発生する可能性があります。
          </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="symbolic-links-to-tables"></a>8.11.3.1.2 Unix 上の MyISAM へのシンボリックリンクの使用</h5></div></div></div><a class="indexterm" name="idm139979111154720"></a><p>
            シンボリックリンクは、<code class="literal">MyISAM</code> テーブルに対してのみ完全にサポートされています。ほかのストレージエンジンのテーブルで使用されているファイルの場合、シンボリックリンクを使用しようとすると、未知の問題が発生することがあります。<code class="literal">InnoDB</code> テーブルの場合は、代わりに<a class="xref" href="innodb-storage-engine.html#tablespace-placing" title="14.5.4 テーブルスペースの位置の指定">セクション14.5.4「テーブルスペースの位置の指定」</a>に説明する代替の技法を使用します。
          </p><p>
            完全に動作する <code class="literal">realpath()</code> 呼び出しがないシステムでは、テーブルのシンボリックリンクを作成しないでください。(Linux と Solaris では <code class="literal">realpath()</code> をサポートしています)。システムでシンボリックリンクをサポートしているかどうかを判断するには、次のステートメントを使用して、<code class="literal">have_symlink</code> システム変数の値をチェックします。
          </p><pre class="programlisting">
SHOW VARIABLES LIKE 'have_symlink';
</pre><p>
            <code class="literal">MyISAM</code> テーブルのシンボリックリンクの処理は次のように機能します。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                データディレクトリには、常にテーブルフォーマット (<code class="filename">.frm</code>) ファイル、データ (<code class="filename">.MYD</code>) ファイル、およびインデックス (<code class="filename">.MYI</code>) ファイルがあります。データファイルとインデックスファイルは、ほかの場所に移動し、データディレクトリ内でシンボリックリンクによって置き換えることができます。フォーマットファイルはできません。
              </p></li><li class="listitem"><p>
                データファイルとインデックスファイルは、独立して別々のディレクトリへのシンボリックリンクを作成できます。
              </p></li><li class="listitem"><p>
                実行中の MySQL サーバーにシンボリックリンクの作成を実行するように指示するには、<code class="literal">CREATE TABLE</code> に <code class="literal">DATA DIRECTORY</code> および <code class="literal">INDEX DIRECTORY</code> オプションを使用します。<a class="xref" href="sql-syntax.html#create-table" title="13.1.17 CREATE TABLE 構文">セクション13.1.17「CREATE TABLE 構文」</a>を参照してください。または、<span class="command"><strong>mysqld</strong></span> が実行中でない場合は、コマンド行から <span class="command"><strong>ln -s</strong></span> を使用して、シンボリックリンクの作成を手動で実行できます。
              </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                  <code class="literal">DATA DIRECTORY</code> および <code class="literal">INDEX DIRECTORY</code> オプションのいずれか、または両方で使用されるパスには、MySQL <code class="literal">data</code> ディレクトリを含めることができません。(Bug #32167)
                </p></div></li><li class="listitem"><p>
                <span class="command"><strong>myisamchk</strong></span> が、シンボリックリンクをデータファイルやインデックスファイルに置き換えません。それは、シンボリックリンクが指しているファイルに対して直接作用します。一時ファイルはすべてデータファイルやインデックスファイルが配置されているディレクトリに作成されます。同じことが <code class="literal">ALTER TABLE</code>、<code class="literal">OPTIMIZE TABLE</code>、および <code class="literal">REPAIR TABLE</code> ステートメントにも当てはまります。
              </p></li><li class="listitem"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                  シンボリックリンクを使用しているテーブルを削除すると、<span class="emphasis"><em>シンボリックリンクとシンボリックリンクが指しているファイルの両方が削除されます</em></span>。これは、システム <code class="literal">root</code> として <span class="command"><strong>mysqld</strong></span> を実行したり、システムユーザーに MySQL データベースディレクトリへの書き込みアクセス権を許可したり<span class="emphasis"><em>しない</em></span>きわめて正当な理由です。
                </p></div></li><li class="listitem"><p>
                <code class="literal">ALTER TABLE ... RENAME</code> または <code class="literal">RENAME TABLE</code> を使用してテーブルの名前を変更し、テーブルを別のデータベースに移動しない場合、データベースディレクトリのシンボリックリンクの名前が新しい名前に変更され、データファイルとインデックスファイルもそれに従って名前が変更されます。
              </p></li><li class="listitem"><p>
                <code class="literal">ALTER TABLE ... RENAME</code> または <code class="literal">RENAME TABLE</code> を使用してテーブルを別のデータベースに移動すると、テーブルが別のデータベースディレクトリに移動されます。テーブル名が変更された場合、新しいデータベースディレクトリ内のシンボリックリンクの名前が新しい名前に変更され、データファイルとインデックスファイルもそれに従って名前が変更されます。
              </p></li><li class="listitem"><p>
                シンボリックリンクを使用していない場合、<code class="option">--skip-symbolic-links</code> オプションを付けて <span class="command"><strong>mysqld</strong></span> を起動し、だれも <span class="command"><strong>mysqld</strong></span> を使用して、データディレクトリ外のファイルを削除したり名前を変更したりできないようにします。
              </p></li></ul></div><p>
            これらのテーブルシンボリックリンクの操作はサポートされていません。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <code class="literal">ALTER TABLE</code> は <code class="literal">DATA DIRECTORY</code> および <code class="literal">INDEX DIRECTORY</code> テーブルオプションを無視します。
              </p></li><li class="listitem"><p>
                前に示したように、データファイルとインデックスファイルにのみシンボリックリンクにできます。<code class="filename">.frm</code> ファイルはシンボリックリンクに<span class="emphasis"><em>できません</em></span>。これを実行しようとすると (たとえば、1 つのテーブル名を別のテーブルのシノニムにするなど) 正しくない結果が生成されます。MySQL データディレクトリにデータベース <code class="literal">db1</code>、このデータベースにテーブル <code class="literal">tbl1</code> があり、<code class="literal">db1</code> ディレクトリに <code class="literal">tbl1</code> を指すシンボリックリンク <code class="literal">tbl2</code> を作成するとします。
              </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>cd <em class="replaceable"><code>/path/to/datadir</code></em>/db1</code></strong>
shell&gt; <strong class="userinput"><code>ln -s tbl1.frm tbl2.frm</code></strong>
shell&gt; <strong class="userinput"><code>ln -s tbl1.MYD tbl2.MYD</code></strong>
shell&gt; <strong class="userinput"><code>ln -s tbl1.MYI tbl2.MYI</code></strong>
</pre><p>
                あるスレッドが <code class="literal">db1.tbl1</code> を読み取り、別のスレッドで <code class="literal">db1.tbl2</code> を更新すると、問題が発生します。
              </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                    クエリーキャッシュが<span class="quote">「<span class="quote">だまされます</span>」</span> (<code class="literal">tbl1</code> が更新されていないことを知る方法がないため、古くなっている結果を返します)。
                  </p></li><li class="listitem"><p>
                    <code class="literal">tbl2</code> に対する <code class="literal">ALTER</code> ステートメントが失敗します。
                  </p></li></ul></div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="windows-symbolic-links"></a>8.11.3.1.3 Windows 上のデータベースへのシンボリックリンクの使用</h5></div></div></div><a class="indexterm" name="idm139979111085904"></a><a class="indexterm" name="idm139979111084448"></a><a class="indexterm" name="idm139979111083024"></a><p>
            Windows では、データベースディレクトリにシンボリックリンクを使用できます。これにより、データベースディレクトリへのシンボリックリンクを設定して、それを別の場所 (別のディスク上など) に置くことができます。Windows でのデータベースシンボリックリンクの使用は、Unix でのそれらの使用に似ていますが、リンクのセットアップの手順は異なります。
          </p><p>
            <code class="literal">mydb</code> というデータベースのデータベースディレクトリを <code class="filename">D:\data\mydb</code> に配置したいとします。これを実行するには、MySQL データディレクトリ内に <code class="filename">D:\data\mydb</code> を指すシンボリックリンクを作成します。ただし、シンボリックリンクを作成する前に、必要に応じて <code class="filename">D:\data\mydb</code> ディレクトリを作成して、それが存在することを確認します。データディレクトリ内に <code class="filename">mydb</code> というデータベースディレクトリがすでにある場合は、それを <code class="filename">D:\data</code> に移動します。そうしないと、シンボリックリンクは無効になります。問題を避けるために、データベースディレクトリの移動時にサーバーが実行していないことを確認してください。
          </p><p>
            データベースシンボリックリンクを作成するための手順は Windows のバージョンによって異なります。
          </p><p>
            Windows Vista、Windows Server 2008 以降には、ネイティブのシンボリックリンクのサポートがあるため、<span class="command"><strong>mklink</strong></span> コマンドを使用して、シンボリックリンクを作成できます。このコマンドには管理者権限が必要です。
          </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                場所をデータディレクトリ内に変更します。
              </p><pre class="programlisting">
C:\&gt; <strong class="userinput"><code>cd <em class="replaceable"><code>\path\to\datadir</code></em></code></strong>
</pre></li><li class="listitem"><p>
                データディレクトリで、データベースディレクトリの場所を指す <code class="filename">mydb</code> というシンボリックリンクを作成します。
              </p><pre class="programlisting">
C:\&gt; <strong class="userinput"><code>mklink /d mydb D:\data\mydb</code></strong>
</pre></li></ol></div><p>
            このあと、データベース <code class="literal">mydb</code> に作成されるすべてのテーブルが <code class="filename">D:\data\mydb</code> に作成されます。
          </p><p>
            または、MySQL でサポートされる任意のバージョンの Windows で、データディレクトリに宛先ディレクトリのパスを格納する <code class="filename">.sym</code> ファイルを作成して、MySQL データベースへのシンボリックリンクを作成できます。ファイルは、<code class="filename"><em class="replaceable"><code>db_name</code></em>.sym</code> という名前にしてください。ここで <em class="replaceable"><code>db_name</code></em> はデータベース名です。
          </p><p>
            Windows で、<code class="filename">.sym</code> ファイルを使用したデータベースシンボリックリンクのサポートは、デフォルトで有効にされています。<code class="filename">.sym</code> ファイルシンボリックリンクが必要でない場合は、<code class="option">--skip-symbolic-links</code> オプションで <span class="command"><strong>mysqld</strong></span> を起動して、それらのサポートを無効にできます。システムで <code class="filename">.sym</code> ファイルシンボリックリンクをサポートしているかどうかを判断するには、次のステートメントを使用して、<code class="literal">have_symlink</code> システム変数の値をチェックします。
          </p><pre class="programlisting">
SHOW VARIABLES LIKE 'have_symlink';
</pre><p>
            <code class="filename">.sym</code> ファイルシンボリックリンクを作成するには、次の手順を使用します。
          </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                場所をデータディレクトリ内に変更します。
              </p><pre class="programlisting">
C:\&gt; <strong class="userinput"><code>cd <em class="replaceable"><code>\path\to\datadir</code></em></code></strong>
</pre></li><li class="listitem"><p>
                データディレクトリ内に、パス名 <code class="literal">D:\data\mydb\</code> を含む <code class="filename">mydb.sym</code> というテキストファイルを作成します。
              </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                  新しいデータベースとテーブルのパス名は絶対パスにしてください。相対パスを指定する場合、場所は <code class="filename">mydb.sym</code> ファイルに相対的になります。
                </p></div></li></ol></div><p>
            このあと、データベース <code class="literal">mydb</code> に作成されるすべてのテーブルが <code class="filename">D:\data\mydb</code> に作成されます。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              <code class="filename">.sym</code> ファイルのサポートは、<span class="command"><strong>mklink</strong></span> を使用して使用可能なネイティブシンボリックリンクのサポートと重複しているため、<code class="filename">.sym</code> ファイルの使用は、MySQL 5.6.9 現在非推奨にされ、それらのサポートは将来の MySQL リリースで削除されます。
            </p></div><p>
            Windows でのデータベースシンボリックリンクへの <code class="filename">.sym</code> ファイルの使用には、次の制限が適用されます。これらの制限は <span class="command"><strong>mklink</strong></span> を使用して作成されるシンボリックリンクには適用されません。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                MySQL データディレクトリにデータベースと同じ名前のディレクトリが存在する場合、シンボリックリンクは使用されません。
              </p></li><li class="listitem"><p>
                <code class="option">--innodb_file_per_table</code> オプションは使用できません。
              </p></li><li class="listitem"><p>
                <span class="command"><strong>mysqld</strong></span> をサービスとして実行する場合、リモートサーバーにマップされたドライブをシンボリックリンクのリンク先として使用することはできません。回避方法として、フルパス (<code class="filename">\\servername\path\</code>) を使用できます。
              </p></li></ul></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="optimizing-memory"></a>8.11.4 メモリーの使用の最適化</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#memory-use">8.11.4.1 MySQL のメモリーの使用方法</a></span></dt><dt><span class="section"><a href="optimization.html#large-page-support">8.11.4.2 ラージページのサポートの有効化</a></span></dt></dl></div><a class="indexterm" name="idm139979111027616"></a><p></p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="memory-use"></a>8.11.4.1 MySQL のメモリーの使用方法</h4></div></div></div><a class="indexterm" name="idm139979111024144"></a><p>
          次のリストに、<span class="command"><strong>mysqld</strong></span> サーバーがメモリーを使用する方法のいくつかを示します。該当する場合、メモリー使用に関連するサーバー変数の名前も示しています。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              すべてのスレッドは <code class="literal">MyISAM</code> キーバッファーを共有し、そのサイズは <code class="literal">key_buffer_size</code> 変数によって決定されます。サーバーによって使用されるほかのバッファーは、必要に応じて割り当てられます。<a class="xref" href="optimization.html#server-parameters" title="8.11.2 サーバーパラメータのチューニング">セクション8.11.2「サーバーパラメータのチューニング」</a>を参照してください。
            </p></li><li class="listitem"><p>
              クライアント接続の管理に使用される各スレッドは、いくらかのスレッド固有の領域を使用します。次のリストに、これらとそれらのサイズを制御する変数を示します。
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  スタック (変数 <code class="literal">thread_stack</code>)
                </p></li><li class="listitem"><p>
                  接続バッファー (変数 <code class="literal">net_buffer_length</code>)
                </p></li><li class="listitem"><p>
                  結果バッファー (変数 <code class="literal">net_buffer_length</code>)
                </p></li></ul></div><p>
              接続バッファーと結果バッファーはそれぞれ <code class="literal">net_buffer_length</code> バイトに等しいサイズから開始されますが、必要に応じて <code class="literal">max_allowed_packet</code> バイトまで動的に拡大されます。結果バッファーは各 SQL ステートメントのあとに <code class="literal">net_buffer_length</code> バイトに縮小されます。ステートメントの実行中は現在のステートメント文字列のコピーも割り当てられます。
            </p></li><li class="listitem"><p>
              すべてのスレッドで同じベースメモリーを共有します。
            </p></li><li class="listitem"><p>
              スレッドが必要ない場合、それに割り当てられたメモリーが解放され、スレッドがスレッドキャッシュに戻らないかぎり、システムに返されます。その場合、メモリーは割り当てられた状態のままになります。
            </p></li><li class="listitem"><p>
              <code class="literal">myisam_use_mmap</code> システム変数を 1 に設定して、すべての <code class="literal">MyISAM</code> テーブルのメモリーマッピングを有効にできます。
            </p></li><li class="listitem"><p>
              テーブルの順次スキャンを実行する各リクエストは、<em class="firstterm">read buffer</em> (変数 <code class="literal">read_buffer_size</code>) を割り当てます。
            </p></li><li class="listitem"><p>
              行を任意の順序で読み取る場合 (たとえば、ソートに続いて)、<em class="firstterm">random-read buffer</em> (変数 <code class="literal">read_rnd_buffer_size</code>) を割り当てて、ディスクシークを避けることができます。
            </p></li><li class="listitem"><p>
              すべての結合は単一のパスで実行され、ほとんどの結合は一時テーブルも使用せずに実行できます。ほとんどの一時テーブルはメモリーベースのハッシュテーブルです。大きな行長 (すべてのカラム長の合計として算出される) を持つか <code class="literal">BLOB</code> カラムを含む一時テーブルはディスク上に格納されます。
            </p><p>
              内部インメモリー一時テーブルが大きくなりすぎると、MySQL は、テーブルをインメモリーから、<code class="literal">MyISAM</code> ストレージエンジンによって処理されるディスク上フォーマットに変更して、これを自動的に処理します。<a class="xref" href="optimization.html#internal-temporary-tables" title="8.4.4 MySQL が内部一時テーブルを使用する仕組み">セクション8.4.4「MySQL が内部一時テーブルを使用する仕組み」</a>に説明するように、許可される一時テーブルのサイズを増やすことができます。
            </p></li><li class="listitem"><p>
              ソートを実行するほとんどのリクエストは、ソートバッファーおよび結果セットサイズに応じた 0 から 2 つの一時ファイルを割り当てます。<a class="xref" href="error-handling.html#temporary-files" title="B.5.4.4 MySQL が一時ファイルを格納する場所">セクションB.5.4.4「MySQL が一時ファイルを格納する場所」</a>を参照してください。
            </p></li><li class="listitem"><p>
              ほとんどすべての解析と計算は、スレッドローカルの再利用可能なメモリープールで実行されます。小さい項目にはメモリーオーバーヘッドが不要であるため、通常の低速メモリーの割り当てと解放が回避されます。メモリーは、予測外に大きな文字列にのみ割り当てられます。
            </p></li><li class="listitem"><p>
              開かれる <code class="literal">MyISAM</code> テーブルごとにインデックスファイルが 1 回開かれ、データファイルは同時実行中のスレッドごとに 1 回開かれます。同時スレッドごとに、テーブル構造、各カラムのカラム構造、およびサイズ <code class="literal">3 * <em class="replaceable"><code>N</code></em></code> のバッファーが割り当てられます (ここで <em class="replaceable"><code>N</code></em> は最大行長で、<code class="literal">BLOB</code> カラムをカウントしていません)。<code class="literal">BLOB</code> カラムには、5 から 8 バイト+ <code class="literal">BLOB</code> データの長さが必要です。<code class="literal">MyISAM</code> ストレージエンジンは、内部使用のため 1 つ余分な行バッファーを保持します。
            </p></li><li class="listitem"><p>
              <code class="literal">BLOB</code> カラムがあるテーブルごとに、大きな <code class="literal">BLOB</code> 値を読み取るためにバッファーが動的に拡大されます。テーブルをスキャンする場合は、最大の <code class="literal">BLOB</code> 値と同じ大きさのバッファーが割り当てられます。
            </p></li><li class="listitem"><p>
              使用中のすべてのテーブルのハンドラ構造がキャッシュに保存され、FIFO として管理されます。初期キャッシュサイズは、<code class="literal">table_open_cache</code> システム変数の値から取得されます。テーブルが同時に 2 つの実行中のスレッドによって使用されている場合、キャッシュにはそのテーブルの 2 つのエントリが含まれます。<a class="xref" href="optimization.html#table-cache" title="8.4.3.1 MySQL でのテーブルのオープンとクローズの方法">セクション8.4.3.1「MySQL でのテーブルのオープンとクローズの方法」</a>を参照してください。
            </p></li><li class="listitem"><p>
              <code class="literal">FLUSH TABLES</code> ステートメントまたは <span class="command"><strong>mysqladmin flush-tables</strong></span> コマンドは、使用中でないすべてのテーブルを一度に閉じ、現在実行中のスレッドの終了時に閉じられるように使用中のすべてのテーブルをマークします。これにより、事実上ほとんどの使用中のメモリーが解放されます。<code class="literal">FLUSH TABLES</code> はすべてのテーブルが閉じられるまで戻りません。
            </p></li><li class="listitem"><p>
              <code class="literal">GRANT</code>、<code class="literal">CREATE USER</code>、<code class="literal">CREATE SERVER</code>、および <code class="literal">INSTALL PLUGIN</code> ステートメントの結果として、サーバーは情報をメモリーにキャッシュします。このメモリーは、対応する <code class="literal">REVOKE</code>、<code class="literal">DROP USER</code>、<code class="literal">DROP SERVER</code>、および <code class="literal">UNINSTALL PLUGIN</code> ステートメントによって解放されないため、キャッシュを発生させるステートメントの多数のインスタンスを実行するサーバーでは、メモリー使用量が増加します。このキャッシュされたメモリーは <code class="literal">FLUSH PRIVILEGES</code> で解放できます。
            </p></li></ul></div><p>
          <span class="command"><strong>ps</strong></span> およびその他のステータスプログラムが、<span class="command"><strong>mysqld</strong></span> が大量のメモリーを使用していることをレポートすることがあります。これは、さまざまなメモリーアドレス上のスレッドスタックによって発生する可能性があります。たとえば、Solaris バージョンの <span class="command"><strong>ps</strong></span> はスタック間の未使用のメモリーが使用されているメモリーとしてカウントされます。これを確認するには、<code class="literal">swap -s</code> で使用可能なスワップをチェックします。いくつかのメモリーリーク検出ツール (市販とオープンソースの両方の) で <span class="command"><strong>mysqld</strong></span> をテストしているため、メモリーリークはないはずです。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="large-page-support"></a>8.11.4.2 ラージページのサポートの有効化</h4></div></div></div><a class="indexterm" name="idm139979110949440"></a><p>
          ハードウェアまたはオペレーティングシステムのアーキテクチャーによっては、デフォルト (通常は 4K バイト) よりも大きいメモリーページをサポートしています。このサポートの実際の実装は、ベースとなるハードウェアやオペレーティングシステムに依存します。大量のメモリーアクセスがあるアプリケーションの場合、大きいページを使用して、トランスレーションルックアサイドバッファー (TLB; Translation Lookaside Buffer) のミスが減ることによってパフォーマンスが改善される可能性があります。
        </p><p>
          MySQL では、InnoDB でラージページを使用して、バッファープールと追加のメモリープールにメモリーを割り当てることができます。
        </p><p>
          MySQL での標準的な大規模ページの使用では、サポートされる最大サイズである 4M バイトまでの使用が試行されます。Solaris では<span class="quote">「<span class="quote">超大規模ページ</span>」</span>機能により 256M バイトまでのページの使用が可能です。この機能は最新の SPARC プラットフォームで使用できます。これは <code class="option">--super-large-pages</code> または <code class="option">--skip-super-large-pages</code> オプションを使用して有効または無効にできます。
        </p><p>
          MySQL は、ラージページのサポートの Linux 実装 (Linux では HugeTLB と呼ばれる) もサポートします。
        </p><p>
          Linux でラージページを使用する前に、カーネルで、それらをサポートできるようにする必要があり、HugeTLB メモリープールを構成する必要があります。参考のため、HugeTBL API は、Linux ソースの <code class="filename">Documentation/vm/hugetlbpage.txt</code> ファイルで説明されています。
        </p><p>
          Red Hat Enterprise Linux などの一部の最近のシステムのカーネルでは、ラージページ機能がデフォルトで有効にされているようです。使用しているカーネルにこれが当てはまるかどうかを確認するには、次のコマンドを使用し、<span class="quote">「<span class="quote">huge</span>」</span> を含む出力行を探します。
        </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>cat /proc/meminfo | grep -i huge</code></strong>
HugePages_Total:       0
HugePages_Free:        0
HugePages_Rsvd:        0
HugePages_Surp:        0
Hugepagesize:       4096 kB
</pre><p>
          空でないコマンド出力は、ラージページのサポートが存在することを示しますが、ゼロの値は、使用するように構成されたページがないことを示します。
        </p><p>
          ラージページをサポートするようにカーネルを再構成する必要がある場合、手順については <code class="filename">hugetlbpage.txt</code> ファイルを参照してください。
        </p><p>
          Linux カーネルでラージページのサポートが有効にされていると仮定し、それを次のコマンドを使用して、MySQL で使用するように構成します。通常、システムが起動するたびにコマンドが実行されるように、システムのブートシーケンス中に実行される <code class="filename">rc</code> ファイルまたは同等の起動ファイルにこれらを入れます。コマンドは、ブートシーケンスの早期の、MySQL サーバーが起動する前に実行されるべきです。システムに適切なように、割り当ての数値とグループ番号を変更してください。
        </p><pre class="programlisting">
# Set the number of pages to be used.
# Each page is normally 2MB, so a value of 20 = 40MB.
# This command actually allocates memory, so this much
# memory must be available.
echo 20 &gt; /proc/sys/vm/nr_hugepages

# Set the group number that is permitted to access this
# memory (102 in this case). The mysql user must be a
# member of this group.
echo 102 &gt; /proc/sys/vm/hugetlb_shm_group

# Increase the amount of shmem permitted per segment
# (12G in this case).
echo 1560281088 &gt; /proc/sys/kernel/shmmax

# Increase total amount of shared memory.  The value
# is the number of pages. At 4KB/page, 4194304 = 16GB.
echo 4194304 &gt; /proc/sys/kernel/shmall
</pre><p>
          MySQL で使用する場合、通常 <code class="literal">shmmax</code> の値を <code class="literal">shmall</code> の値に近くなるようにしたいと考えます。
        </p><p>
          ラージページの構成を確認するには、前述のとおりに再度 <code class="filename">/proc/meminfo</code> をチェックします。これで、0 以外の値が表示されるはずです。
        </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>cat /proc/meminfo | grep -i huge</code></strong>
HugePages_Total:      20
HugePages_Free:       20
HugePages_Rsvd:        0
HugePages_Surp:        0
Hugepagesize:       4096 kB
</pre><p>
          <code class="literal">hugetlb_shm_group</code> を使用するための最後の手順は、<code class="literal">mysql</code> ユーザーに、memlock 制限として <span class="quote">「<span class="quote">unlimited</span>」</span> 値を指定することです。これを実行するには、<code class="filename">/etc/security/limits.conf</code> を編集するか、<span class="command"><strong>mysqld_safe</strong></span> スクリプトに次のコマンドを追加します。
        </p><pre class="programlisting">
ulimit -l unlimited
</pre><p>
          <span class="command"><strong>ulimit</strong></span> コマンドを <span class="command"><strong>mysqld_safe</strong></span> に追加すると、<code class="literal">mysql</code> ユーザーに切り替える前に <code class="literal">root</code> ユーザーの memlock 制限が <code class="literal">unlimited</code> に設定されます。(これは、<span class="command"><strong>mysqld_safe</strong></span> が <code class="literal">root</code> によって起動されたものと仮定します。) 
        </p><p>
          MySQL のラージページのサポートはデフォルトで無効にされています。それを有効にするには、サーバーを <code class="option">--large-pages</code> オプションで起動します。たとえば、サーバーの <code class="filename">my.cnf</code> ファイルで次の行を使用できます。
        </p><pre class="programlisting">
[mysqld]
large-pages
</pre><p>
          このオプションを使用すると、<code class="literal">InnoDB</code> はそのバッファープールと追加のメモリープールに自動的にラージページを使用します。<code class="literal">InnoDB</code> がこれを実行できない場合、従来のメモリーの使用に戻り、エラーログに警告を書き込みます: <span class="errortext">Warning: Using conventional memory pool</span>
        </p><p>
          ラージページが使用されていることを確認するには、再度 <code class="literal">/proc/meminfo</code> をチェックします。
        </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>cat /proc/meminfo | grep -i huge</code></strong>
HugePages_Total:      20
HugePages_Free:       20
HugePages_Rsvd:        2
HugePages_Surp:        0
Hugepagesize:       4096 kB
</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="optimizing-network"></a>8.11.5 ネットワークの使用の最適化</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#connection-threads">8.11.5.1 MySQL のクライアント接続のためのスレッドの使用方法</a></span></dt><dt><span class="section"><a href="optimization.html#host-cache">8.11.5.2 DNS ルックアップの最適化とホストキャッシュ</a></span></dt></dl></div><a class="indexterm" name="idm139979110904480"></a><p></p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="connection-threads"></a>8.11.5.1 MySQL のクライアント接続のためのスレッドの使用方法</h4></div></div></div><a class="indexterm" name="idm139979110900880"></a><a class="indexterm" name="idm139979110899408"></a><a class="indexterm" name="idm139979110898032"></a><p>
          接続マネージャースレッドは、サーバーが待機しているネットワークインタフェース上でクライアントの接続要求を処理します。どのプラットフォームでも、1 つのマネージャースレッドが TCP/IP 接続要求を処理します。Unix では、このマネージャースレッドは Unix ソケットファイルの接続要求も処理します。Windows では、1 つのマネージャースレッドが共有メモリーの接続要求を処理し、別のマネージャースレッドが名前付きパイプの接続要求を処理します。サーバーは、待機していないインタフェースを処理するためのスレッドを作成しません。たとえば、Windows サーバーで名前付きパイプ接続のサポートが有効になっていない場合、これらの接続を処理するスレッドは作成されません。
        </p><p>
          接続マネージャースレッドは、各クライアント接続を、その接続の認証および要求を処理する専用スレッドに関連付けます。マネージャースレッドは、必要に応じて新しいスレッドを作成しますが、まずスレッドキャッシュを調べて接続に使用できるスレッドが含まれているかどうかを確認することによって、それを回避することを試みます。接続が終了すると、スレッドキャッシュが満杯でない場合は、そのスレッドがスレッドキャッシュに返されます。
        </p><p>
          この接続スレッドモデルでは、現在接続しているクライアントと同数のスレッドが存在し、多数の接続を処理するためにサーバーのワークロードを拡大する必要がある場合にはいくつか欠点があります。たとえば、スレッドの作成と破棄の負荷が大きくなります。また、各スレッドにスタック領域などのサーバーリソースとカーネルリソースが必要になります。多数の同時接続に対応するには、スレッドあたりのスタックサイズは小さく保つ必要があり、それが小さくなりすぎるか、またはサーバーで大量のメモリーを消費することになる状況につながります。ほかのリソースを使い果たす可能性もあり、スケジューリングのオーバーヘッドがかなり大きくなる可能性があります。
        </p><p>
          MySQL 5.6.10 現在、MySQL 5.6 の商用配布には、オーバーヘッドを軽減し、パフォーマンスを向上するように設計されている代替のスレッド処理モデルを提供するスレットプールプラグインが付属しています。これは、多数のクライアント接続のステートメント実行スレッドを効率的に管理して、サーバーのパフォーマンスを向上させるスレッドプールを実装します。<a class="xref" href="optimization.html#thread-pool-plugin" title="8.11.6 スレッドプールプラグイン">セクション8.11.6「スレッドプールプラグイン」</a>を参照してください。
        </p><p>
          クライアント接続を処理するスレッドをサーバーがどのように管理するかを制御し、モニターするには、いくつかのシステム変数とステータス変数が関連します。(<a class="xref" href="server-administration.html#server-system-variables" title="5.1.4 サーバーシステム変数">セクション5.1.4「サーバーシステム変数」</a>および<a class="xref" href="server-administration.html#server-status-variables" title="5.1.6 サーバーステータス変数">セクション5.1.6「サーバーステータス変数」</a>を参照してください。)
        </p><p>
          スレッドキャッシュは、<code class="literal">thread_cache_size</code> システム変数によって決定されるサイズを持ちます。デフォルト値は 0 (キャッシュなし) で、この場合、スレッドは新しい接続ごとにセットアップされ、接続の終了時に破棄されます。<code class="literal">thread_cache_size</code> を <em class="replaceable"><code>N</code></em> に設定し、<em class="replaceable"><code>N</code></em> 個の非アクティブ接続スレッドをキャッシュできるようにします。<code class="literal">thread_cache_size</code> はサーバーの起動時に設定するか、サーバーの実行中に変更できます。関連付けられていたクライアント接続が終了すると、接続スレッドは非アクティブになります。
        </p><p>
          キャッシュ内のスレッド数、およびスレッドをキャッシュから取得できなかったため作成されたスレッドの数をモニターするには、<code class="literal">Threads_cached</code> および <code class="literal">Threads_created</code> ステータス変数をモニターします。
        </p><p>
          サーバーの起動時または実行時に <code class="literal">max_connections</code> を設定して、同時に接続できるクライアントの最大数を制御できます。
        </p><p>
          スレッドスタックが小さすぎると、これによって、サーバーが処理できる SQL ステートメントの複雑さ、ストアドプロシージャーの再帰の深さ、およびその他のメモリーを大量に消費するアクションが制限されます。各スレッドに <em class="replaceable"><code>N</code></em> バイトのスタックサイズを設定するには、サーバーを <code class="option">--thread_stack=<em class="replaceable"><code>N</code></em></code> で起動します。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="host-cache"></a>8.11.5.2 DNS ルックアップの最適化とホストキャッシュ</h4></div></div></div><a class="indexterm" name="idm139979110872688"></a><a class="indexterm" name="idm139979110871392"></a><a class="indexterm" name="idm139979110869920"></a><p>
          MySQL サーバーはクライアントに関する情報 (IP アドレス、ホスト名、エラー情報) を格納するホストキャッシュをメモリーに保持します。サーバーはこのキャッシュを非ローカル TCP 接続に使用します。それは、ループバックインタフェースアドレス (<code class="literal">127.0.0.1</code> または <code class="literal">::1</code>) を使用して確立された TCP 接続、または Unix ソケットファイル、名前付きパイプ、または共有メモリーを使用して確立された接続には、キャッシュを使用しません。
        </p><p>
          新しいクライアント接続ごとに、サーバーはクライアント IP アドレスを使用して、クライアントホスト名がホストキャッシュ内にあるかどうかをチェックします。ない場合は、サーバーはホスト名の解決を試みます。まず、それは IP アドレスをホスト名に解決し、そのホスト名を再度 IP アドレスに解決します。次に、その結果と元の IP アドレスを比較して、それらが同じであることを確認します。サーバーはこの操作の結果に関する情報をホストキャッシュに格納します。キャッシュがいっぱいである場合、直近で使用されていないエントリが破棄されます。
        </p><p>
           <code class="literal">host_cache</code> パフォーマンススキーマテーブルは、<code class="literal">SELECT</code> ステートメントを使用して調査できるようにホストキャッシュの内容を公開します。これは、接続の問題の原因の診断に役立つことがあります。<a class="xref" href="performance-schema.html#host-cache-table" title="22.9.10.1 host_cache テーブル">セクション22.9.10.1「host_cache テーブル」</a>を参照してください。
        </p><p>
          サーバーは次のようにホストキャッシュ内のエントリを処理します。
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              最初の TCP クライアント接続が指定された IP アドレスからサーバーに到達すると、クライアント IP、ホスト名、およびクライアントルックアップ検証フラグを記録する新しいエントリが作成されます。最初に、ホスト名が <code class="literal">NULL</code> に設定され、フラグは false になります。このエントリは同じ発信元 IP からの後続のクライアント接続にも使用されます。
            </p></li><li class="listitem"><p>
              クライアント IP エントリの検証フラグが false の場合、サーバーは IP からホスト名への DNS の解決を試みます。それが成功した場合、ホスト名が解決されたホスト名で更新され、検証フラグが true に設定されます。解決が成功しない場合、とられるアクションは、エラーが永続的か一時的かによって異なります。永続的なエラーの場合、ホスト名は <code class="literal">NULL</code> のままになり、検証フラグは true に設定されます。一時的なエラーの場合、ホスト名と検証フラグは変更されないままになります。(次回にクライアントがこの IP から接続したときは、別の DNS 解決の試みが行われます。)
            </p></li><li class="listitem"><p>
              特定の IP アドレスからの着信クライアント接続の処理中にエラーが発生した場合、サーバーはその IP のエントリ内の対応するエラーカウンタを更新します。記録されたエラーの説明については、<a class="xref" href="performance-schema.html#host-cache-table" title="22.9.10.1 host_cache テーブル">セクション22.9.10.1「host_cache テーブル」</a>を参照してください。
            </p></li></ol></div><p>
          オペレーティングシステムでスレッドセーフな <code class="function">gethostbyaddr_r()</code> および <code class="function">gethostbyname_r()</code> 呼び出しをサポートしている場合、サーバーはそれらを使用してホスト名解決を実行します。そうでない場合、ルックアップを実行するスレッドは相互排他ロックを実行し、代わりに、<code class="function">gethostbyaddr()</code> および <code class="function">gethostbyname()</code> を呼び出します。この場合、相互排他ロックを保持するスレッドがそれを解放するまで、ほかのスレッドはホストキャッシュ内にないホスト名を解決できません。
        </p><p>
          サーバーはいくつかの目的でホストキャッシュを使用します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              IP からホスト名へのルックアップの結果をキャッシュすることによって、サーバーはクライアント接続ごとの DNS ルックアップの実行を回避します。代わりに、特定のホストに対して、そのホストからの最初の接続でのみルックアップを実行する必要があります。
            </p></li><li class="listitem"><p>
              キャッシュには、接続プロセス中に発生したエラーに関する情報が格納されます。一部のエラーは<span class="quote">「<span class="quote">ブロッキング</span>」</span>とみなされます。成功した接続がない特定のホストから、これらの多くが連続して発生している場合、サーバーはそのホストからのその後の接続をブロックします。<code class="literal">max_connect_errors</code> システム変数は、ブロックが行われるまで許可されるエラーの数を指定します。<a class="xref" href="error-handling.html#blocked-host" title="B.5.2.6 ホスト 'host_name' は拒否されました">セクションB.5.2.6「ホスト 'host_name' は拒否されました」</a>を参照してください。
            </p></li></ul></div><p>
          ブロックされたホストのブロックを解除するには、<code class="literal">FLUSH HOSTS</code> ステートメントを発行するか、<span class="command"><strong>mysqladmin flush-hosts</strong></span> コマンドを実行して、ホストキャッシュをフラッシュします。
        </p><p>
          ブロックされたホストからの最後の接続の試み以降に、ほかのホストからのアクティビティーが発生した場合、<code class="literal">FLUSH HOSTS</code> を使用しなくても、ブロックされたホストのブロックが解除される可能性があります。これは、キャッシュ内にないクライアント IP から接続が到着したときに、キャッシュがいっぱいである場合、サーバーが直近で使用されていないキャッシュエントリを破棄して、新しいエントリのための空きを作るために発生する可能性があります。破棄されたエントリがブロックされたホストのものである場合、そのホストのブロックが解除されます。
        </p><p>
          ホストキャッシュはデフォルトで有効になっています。それを無効にするには、サーバーの起動時や実行時に、<code class="literal">host_cache_size</code> システム変数を 0 に設定します。
        </p><p>
          DNSホスト名ルックアップを無効にするには、<code class="option">--skip-name-resolve</code> オプションでサーバーを起動します。この場合、サーバーは IP アドレスのみを使用し、ホスト名を使用しないで、接続しているホストを MySQL 付与テーブル内の行と照合します。IP アドレスを使用してそれらのテーブルに指定されたアカウントのみを使用できます。
        </p><p>
          著しく遅い DNS と多くのホストがある場合、<code class="option">--skip-name-resolve</code> で DNS ルックアップを無効にするか、または <code class="literal">host_cache_size</code> の値を増やしてホストキャッシュを大きくすることによって、パフォーマンスを向上できる可能性があります。
        </p><p>
          TCP/IP 接続を完全に禁止するには、<code class="option">--skip-networking</code> オプションでサーバーを起動します。
        </p><p>
          一部の接続エラーは TCP 接続に関連付けられないか、接続プロセスのきわめて早期に (IP アドレスも判明する前に) 発生するか、または特定の IP アドレスに固有でありません (メモリー不足の状況など)。これらのエラーについては、<code class="literal">Connection_errors_<em class="replaceable"><code>xxx</code></em></code> ステータス変数をチェックしてください (<a class="xref" href="server-administration.html#server-status-variables" title="5.1.6 サーバーステータス変数">セクション5.1.6「サーバーステータス変数」</a>を参照してください)。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="thread-pool-plugin"></a>8.11.6 スレッドプールプラグイン</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#thread-pool-installation">8.11.6.1 スレッドプールコンポーネントとインストール</a></span></dt><dt><span class="section"><a href="optimization.html#thread-pool-operation">8.11.6.2 スレッドプール操作</a></span></dt><dt><span class="section"><a href="optimization.html#thread-pool-tuning">8.11.6.3 スレッドプールのチューニング</a></span></dt></dl></div><a class="indexterm" name="idm139979110823376"></a><a class="indexterm" name="idm139979110821904"></a><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          MySQL スレッドプールは商用拡張機能です。商用製品 (MySQL Enterprise Edition) の詳細については、http://www.mysql.com/products/ を参照してください。
        </p></div><p>
        MySQL 5.6.10 現在、MySQL 5.6 の商用配布には、サーバープラグインを使用して実装される MySQL スレッドプールが付属しています。MySQL サーバーのデフォルトのスレッド処理モデルでは、クライアント接続ごとに 1 つのスレッドを使用してステートメントが実行されます。より多くのクライアントがサーバーに接続してステートメントを実行すると、全体的なパフォーマンスが低下します。スレットプールプラグインは、オーバーヘッドを軽減し、パフォーマンスを向上するように設計されている代替のスレッド処理モデルを提供します。このプラグインは、多数のクライアント接続に対してステートメント実行スレッドを効率的に管理することによってサーバーのパフォーマンスを向上させるスレッドプールを実装します。
      </p><p>
        スレッドプールは、接続モデルあたり 1 つのスレッドのいくつかの問題に対処します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            スレッドが多すぎると、高度な並列実行ワークロードで CPU キャッシュがほとんど役に立たなくなります。スレッドプールはスレッドスタックの再利用を促進し、CPU キャッシュのフットプリントを最小にします。
          </p></li><li class="listitem"><p>
            並列で実行しているスレッド数が多すぎると、コンテキストスイッチングのオーバーヘッドが高くなります。これは、オペレーティングシステムスケジューラにも困難なタスクを与えます。スレッドプールは、アクティブスレッドの数を制御して、それが処理可能で、MySQL を実行しているサーバーホストに適切なレベルで MySQL サーバー内の並列性を維持します。
          </p></li><li class="listitem"><p>
            並列で実行するトランザクションが多すぎると、リソースの競合が増加します。<code class="literal">InnoDB</code> では、これにより中央の相互排他ロックの保持に費やされる時間が多くなります。スレッドプールは、あまり多く並列で実行しないように、トランザクションが開始するタイミングを制御します。
          </p></li></ul></div><p>
        スレッドプールプラグインは商用機能です。MySQL コミュニティー配布には含まれていません。
      </p><p>
        Windows では、スレッドプールプラグインに Windows Vista 以降が必要です。Linux では、プラグインにカーネル 2.6.9 以降が必要です。
      </p><h4><a name="idm139979110808400"></a>追加のリソース</h4><p>
        <a class="xref" href="faqs.html#faqs-thread-pool" title="A.14 MySQL 5.6 FAQ: MySQL エンタープライズスケーラビリティースレッドプール">セクションA.14「MySQL 5.6 FAQ: MySQL エンタープライズスケーラビリティースレッドプール」</a>
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="thread-pool-installation"></a>8.11.6.1 スレッドプールコンポーネントとインストール</h4></div></div></div><p>
          スレッドプール機能は次のコンポーネントで構成されます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              プラグインライブラリオブジェクトファイルには、スレッドプールコード用のプラグインと、いくつかの <code class="literal">INFORMATION_SCHEMA</code> テーブル用のプラグインが含まれています。
            </p><p>
              スレッドプールの仕組みの詳細については、<a class="xref" href="optimization.html#thread-pool-operation" title="8.11.6.2 スレッドプール操作">セクション8.11.6.2「スレッドプール操作」</a>を参照してください。
            </p><p>
              <code class="literal">INFORMATION_SCHEMA</code> テーブルには、<code class="literal">TP_THREAD_STATE</code>、<code class="literal">TP_THREAD_GROUP_STATE</code>、および <code class="literal">TP_THREAD_GROUP_STATS</code> という名前が付けられています。これらのテーブルは、スレッドプール操作に関する情報を提供します。詳細については、<a class="xref" href="information-schema.html#thread-pool-i_s-tables" title="21.31 スレッドプールの INFORMATION_SCHEMA テーブル">セクション21.31「スレッドプールの INFORMATION_SCHEMA テーブル」</a>を参照してください。
            </p></li><li class="listitem"><p>
              いくつかのシステム変数がスレッドプールに関連しています。<code class="literal">thread_handling</code> システム変数は、サーバーがスレッドプールプラグインを正常にロードしたときに、<code class="literal">loaded-dynamically</code> の値になります。
            </p><p>
              ほかの関連の変数はスレッドプールプラグインによって実装されます。それが有効にされていない場合、それらは使用できません。
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  <code class="literal">thread_pool_algorithm</code>: スケジューリングに使用する並列性アルゴリズム。
                </p></li><li class="listitem"><p>
                  <code class="literal">thread_pool_high_priority_connection</code>: セッションのステートメント実行のスケジュール方法。
                </p></li><li class="listitem"><p>
                  <code class="literal">thread_pool_prio_kickup_timer</code>: スレッドプールが、実行を待機しているステートメントを低優先度キューから高優先度キューに移動するまでの時間。
                </p></li><li class="listitem"><p>
                  <code class="literal">thread_pool_max_unused_threads</code>: 許可するスリープ中のスレッド数。
                </p></li><li class="listitem"><p>
                  <code class="literal">thread_pool_size</code>: スレッドプール内のスレッドグループの数。これはスレッドプールのパフォーマンスを制御するもっとも重要なパラメータです。
                </p></li><li class="listitem"><p>
                  <code class="literal">thread_pool_stall_limit</code>: 実行中のステートメントが停滞しているとみなされるまでの時間。
                </p></li></ul></div><p>
              起動時に、プラグインによって実装されているいずれかの変数が不正な値に設定された場合、プラグインの初期化が失敗し、プラグインはロードされません。
            </p><p>
              スレッドプールパラメータの設定については、<a class="xref" href="optimization.html#thread-pool-tuning" title="8.11.6.3 スレッドプールのチューニング">セクション8.11.6.3「スレッドプールのチューニング」</a>を参照してください。
            </p></li><li class="listitem"><p>
              パフォーマンススキーマは、スレッドプールに関する情報を公開し、操作のパフォーマンスの調査に使用できます。詳細については、<a class="xref" href="performance-schema.html" title="第 22 章 MySQL パフォーマンススキーマ">第22章「<i>MySQL パフォーマンススキーマ</i>」</a>を参照してください。
            </p></li></ul></div><p>
          サーバーが使用できるように、スレッドプールライブラリオブジェクトファイルは MySQL プラグインディレクトリ (<code class="literal">plugin_dir</code> システム変数によって指定されたディレクトリ) に存在する必要があります。スレッドプール機能を有効にするには、<code class="option">--plugin-load</code> オプションでサーバーを起動することによって、使用されるプラグインをロードします。たとえば、プラグインオブジェクトファイルだけを指定した場合、サーバーはそれに含まれるすべてのプラグイン (つまり、スレッドプールプラグインとすべての <code class="literal">INFORMATION_SCHEMA</code> テーブル) をロードします。これを実行するには、これらの行を <code class="filename">my.cnf</code> ファイルに挿入します。
        </p><pre class="programlisting">
[mysqld]
plugin-load=thread_pool.so
</pre><p>
          それは、個別にスレッドプールプラグインを指定して、それらをすべてロードするのと同等です。
        </p><pre class="programlisting">
[mysqld]
plugin-load=thread_pool.so
plugin-load=thread_pool=thread_pool.so;tp_thread_state=thread_pool.so;tp_thread_group_state=thread_pool.so;tp_thread_group_stats=thread_pool.so
</pre><p>
          システム上のオブジェクトファイルのサフィクスが <code class="filename">.so</code> とは異なる場合、正しいサフィクスに置き換えてください (たとえば Windows の場合は <code class="filename">.dll</code>)。
        </p><p>
          必要に応じて、サーバーにプラグインディレクトリの場所を伝えるために、<code class="literal">plugin_dir</code> システム変数の値を設定します。
        </p><p>
          必要な場合、ライブラリファイルから個々のプラグインをロードできます。スレッドプールプラグインをロードするが、<code class="literal">INFORMATION_SCHEMA</code> テーブルはロードしない場合、次のようなオプションを使用します。
        </p><pre class="programlisting">
[mysqld]
plugin-load=thread_pool=thread_pool.so
</pre><p>
          スレッドプールプラグインと <code class="literal">TP_THREAD_STATE</code> <code class="literal">INFORMATION_SCHEMA</code> テーブルのみをロードするには、次のようなオプションを使用します。
        </p><pre class="programlisting">
[mysqld]
plugin-load=thread_pool=thread_pool.so;TP_THREAD_STATE=thread_pool.so
</pre><p>
          ただし、すべての <code class="literal">INFORMATION_SCHEMA</code> テーブルをロードしない場合、一部またはすべての MySQL Enterprise Monitor スレッドプールグラフが空になります。
        </p><p>
          プラグインのインストールを検証するには、<code class="literal">INFORMATION_SCHEMA.PLUGINS</code> テーブルを調査するか、<code class="literal">SHOW PLUGINS</code> ステートメントを使用します。<a class="xref" href="server-administration.html#obtaining-plugin-information" title="5.1.8.2 サーバープラグイン情報の取得">セクション5.1.8.2「サーバープラグイン情報の取得」</a>を参照してください。
        </p><p>
          サーバーはスレッドプラグインを正常にロードしたら、<code class="literal">thread_handling</code> システム変数を <code class="literal">dynamically-loaded</code> に設定します。プラグインのロードに失敗した場合、サーバーはエラーログにメッセージを書き込みます。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="thread-pool-operation"></a>8.11.6.2 スレッドプール操作</h4></div></div></div><p>
          スレッドプールは、それぞれクライアント接続のセットを管理するいくつかのスレッドグループから構成されます。接続が確立されると、スレッドプールはラウンドロビン方式でそれらをスレッドグループに割り当てます。
        </p><p>
          スレッドグループの数は、<code class="literal">thread_pool_size</code> システム変数を使用して構成できます。グループのデフォルトの数は 16 です。この変数の設定のガイドラインについては、<a class="xref" href="optimization.html#thread-pool-tuning" title="8.11.6.3 スレッドプールのチューニング">セクション8.11.6.3「スレッドプールのチューニング」</a>を参照してください。
        </p><p>
          グループあたりのスレッドの最大数は 4096 (または 1 つのスレッドが内部で使用される一部のシステムでは 4095) です。
        </p><p>
          スレッドプールは接続とスレッドを区別するため、接続と、それらの接続から受信したステートメントを実行するスレッド間に固定の関係はありません。これは、1 つのスレッドを 1 つの接続に関連付けて、そのスレッドがその接続からのすべてのステートメントを実行するようにするデフォルトのスレッド処理モデルとは異なります。
        </p><p>
          スレッドプールは、いつでも各グループで最大 1 つのスレッドが実行するように努めますが、ときによって、最高のパフォーマンスのため、一時的に多くのスレッドの実行を許可することがあります。このアルゴリズムは次のように機能します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              各スレッドグループには、グループに割り当てられた接続からの着信ステートメントを待機するリスナースレッドがあります。ステートメントが到着すると、スレッドグループはその実行をただちに開始するか、あとで実行するためにキューに入れます。
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  即時の実行は、ステートメントが受信した唯一のもので、キューに入れられていたり、現在実行していたりするステートメントがない場合に行われます。
                </p></li><li class="listitem"><p>
                  キューイングは、ステートメントの実行をすぐに開始できない場合に行われます。
                </p></li></ul></div></li><li class="listitem"><p>
              即時の実行が行われる場合、実行はリスナースレッドによって行われます。(つまり、グループ内に一時的に待機しているスレッドがなくなります。)ステートメントがすぐに終了すると、実行中のスレッドがステートメントの待機に戻ります。そうでない場合、スレッドプールはステートメントを停滞中とみなし、別のスレッド (必要に応じて作成して) をリスナースレッドとして開始します。スレッドグループが停滞中のステートメントによってブロックされないように、スレッドプールには、スレッドグループ状態を定期的にモニターするバックグラウンドスレッドがあります。
            </p><p>
              待機中のスレッドを使用して、ただちに開始できるステートメントを実行することによって、ステートメントがすぐに終了した場合、追加のスレッドを作成する必要はありません。これにより、同時スレッド数が少ない場合に、もっとも効率的な実行が可能になります。
            </p><p>
              スレッドプールプラグインが開始すると、それはグループあたり 1 つのスレッド (リスナースレッド) に加えてバックグラウンドスレッドを作成します。ステートメントを実行するための必要に応じて、追加のスレッドが作成されます。
            </p></li><li class="listitem"><p>
              <code class="literal">thread_pool_stall_limit</code> システム変数の値は、先述の項目の<span class="quote">「<span class="quote">すぐに終了する</span>」</span>の意味を決定します。スレッドが停滞中とみなされるまでのデフォルトの時間は 60 ミリ秒ですが、6 秒まで設定できます。このパラメータは、サーバーのワークロードに適切なバランスがとれるように構成できます。待機の値が短いと、スレッドはよりすみやかに開始できます。短い値はデッドロック状況を回避により適しています。長い待機の値は、長時間実行するステートメントを含むワークロードで有用で、現在のステートメントの実行時に多数の新しいステートメントが開始しないようにします。
            </p></li><li class="listitem"><p>
              スレッドプールは、同時の短時間実行ステートメントの数を制限することに焦点を合わせています。実行中のステートメントが停滞時間に達する前に、ほかのステートメントの実行の開始を妨げます。ステートメントが停滞時間を過ぎて実行している場合、それは続行が許可されますが、ほかのステートメントの開始は妨げられなくなります。このように、スレッドプールは、各スレッドグループに、複数の長時間実行ステートメントがあっても、複数の短時間実行ステートメントがないように努めます。必要な待機時間に対する制限がないため、長時間実行ステートメントによって、ほかのステートメントの実行が妨げられることは望ましくありません。たとえば、レプリケーションマスターで、バイナリログイベントをスレーブに送信するスレッドは、事実上永久に実行します。
            </p></li><li class="listitem"><p>
              ステートメントはディスク I/O 操作またはユーザーレベルロック (行ロックまたはテーブルロック) を検出するとブロックされます。ブロックによって、スレッドグループは使用されなくなることがあるため、スレッドプールがこのグループで新しいスレッドをただちに開始して、別のステートメントを実行できるようにするため、スレッドプールへのコールバックがあります。ブロックされたスレッドが返されると、スレッドプールはそれをすぐに再開することを許可します。
            </p></li><li class="listitem"><p>
              優先度が高いキューと優先度が低いキューの 2 つのキューがあります。トランザクションの最初のステートメントは優先度が低いキューに入ります。トランザクションの後続のステートメントは、トランザクションが進行中 (そのステートメントが実行を開始している) 場合、優先度が高いキューに入れられ、そうでない場合は優先度が低いキューに入れられます。キューの割り当ては、<code class="literal">thread_pool_high_priority_connection</code> システム変数を有効にすることによって影響を受けることがあります。これにより、セッションのすべてのキューに入れられているステートメントが優先度の高いキューに入れられます。
            </p><p>
              非トランザクションストレージエンジンまたは <code class="literal">autocommit</code> が有効にされている場合のトランザクションエンジンのステートメントは、この場合に各ステートメントがトランザクションであるため、優先度の低いステートメントとして扱われます。そのため、<code class="literal">InnoDB</code> テーブルと <code class="literal">MyISAM</code> テーブルに対するステートメントを組み合わせると、<code class="literal">autocommit</code> が有効にされていないかぎり、スレッドプールは <code class="literal">MyISAM</code> に対するステートメントより、<code class="literal">InnoDB</code> に対するステートメントを優先します。<code class="literal">autocommit</code> が有効にされていると、すべてのステートメントの優先度が低くなります。
            </p></li><li class="listitem"><p>
              スレッドグループが実行のためにキューに入れられているステートメントを選択する場合、まず優先度が高いキューを調べて、次に優先度が低いキューを調べます。ステートメントが見つかった場合、そのキューからそれが削除され、実行が開始されます。
            </p></li><li class="listitem"><p>
              ステートメントが優先度の低いキューに長くとどまりすぎた場合、スレッドプールは優先度の高いキューに移動します。<code class="literal">thread_pool_prio_kickup_timer</code> システム変数の値は、移動までの時間を制御します。スレッドグループごとに、最大 10 ms あたり 1 つのステートメントまたは 1 秒あたり 100 個のステートメントが優先度の低いキューから優先度の高いキューに移動されます。
            </p></li><li class="listitem"><p>
              スレッドプールは、CPU キャッシュの使用を大幅に効率化するために、もっともアクティブなスレッドを再利用します。これは、パフォーマンスに大きな影響を与える小さな調整です。
            </p></li><li class="listitem"><p>
              スレッドがユーザー接続からステートメントを実行している間、パフォーマンススキーマインストゥルメンテーションは、ユーザー接続にスレッドアクティビティーを報告します。それ以外の場合、パフォーマンススキーマはアクティビティーをスレッドプールに報告します。
            </p></li></ul></div><p>
          これは、スレッドグループがステートメントを実行するために複数のスレッドを開始している状況の例です。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              1 つのスレッドがステートメントの実行を開始しますが、長時間実行しているため、停滞中とみなされます。スレッドグループは、最初のスレッドがまだ実行中であっても、別のスレッドに別のステートメントの実行の開始を許可します。
            </p></li><li class="listitem"><p>
              1 つのスレッドがステートメントの実行を開始し、その後ブロックされ、このことをスレッドプールにレポートします。スレッドグループは、別のスレッドに別のステートメントの実行の開始を許可します。
            </p></li><li class="listitem"><p>
              1 つのスレッドがステートメントの実行を開始し、ブロックされましたが、スレッドプールのコールバックによってインストゥルメントされたコードでブロックが発生していないため、ブロックされたことをレポートしません。この場合、スレッドはスレッドグループにまだ実行中であるように見えます。ステートメントが停滞中とみなされるほどブロックが長く継続した場合、グループは、別のスレッドに別のステートメントの実行の開始を許可します。
            </p></li></ul></div><p>
          スレッドプールは、増加する接続全体に拡張できるように設計されています。さらに、アクティブに実行しているステートメントの数を制限することから発生する可能性のあるデッドロックを回避するようにも設計されています。スレッドプールにレポートしないスレッドは、ほかのステートメントの実行を妨げないため、スレッドプールのデッドロックを引き起こすことは重要です。そのようなステートメントの例を次に示します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              長時間実行ステートメント。これらによって、すべてのリソースがほんの少数のステートメントで使用されることになり、ほかのすべてのステートメントのサーバーへのアクセスを妨げる可能性があります。
            </p></li><li class="listitem"><p>
              バイナリログを読み取り、それをスレーブに送信するバイナリログダンプスレッド。これは、きわめて長い時間実行する長時間実行<span class="quote">「<span class="quote">ステートメント</span>」</span>の一種であり、ほかのステートメントの実行を妨げないはずです。
            </p></li><li class="listitem"><p>
              MySQL Server またはストレージエンジンによって、スレッドプールにレポートされていない、行ロック、テーブルロック、またはほかの何らかのブロックアクティビティーでブロックされたステートメント。
            </p></li></ul></div><p>
          どの場合も、デッドロックを避けるため、スレッドグループが別のステートメントの実行の開始を許可できるように、ステートメントがすぐに完了しない場合、停滞中カテゴリに移動されます。この設計により、スレッドが長時間実行するか、ブロックされた場合に、スレッドプールはスレッドを停滞中カテゴリに移動し、ステートメントの実行の残りの間、ほかのステートメントの実行を妨げません。
        </p><p>
          発生する可能性のあるスレッドの最大数は、<code class="literal">max_connections</code> と <code class="literal">thread_pool_size</code> の合計です。これは、すべての接続が実行モードにあり、グループあたりに追加のステートメントを待機する 1 つの追加スレッドが作成される状況で発生する可能性があります。これは必ずしも頻繁に発生する状態ではありませんが、理論的には可能性があります。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="thread-pool-tuning"></a>8.11.6.3 スレッドプールのチューニング</h4></div></div></div><p>
          このセクションでは、秒あたりのトランザクション数などのメトリックを使用して測定された、最高のパフォーマンスを得るためのスレッドプールシステム変数の設定に関するガイドラインを提供します。
        </p><p>
          <code class="literal">thread_pool_size</code> はスレッドプールのパフォーマンスを制御するもっとも重要なパラメータです。それはサーバーの起動時にのみ設定できます。スレッドプールのテストにおける経験では、次のように示されます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              プライマリストレージエンジンが <code class="literal">InnoDB</code> である場合、最適な <code class="literal">thread_pool_size</code> 設定は、16 から 36 の間になる可能性があり、もっとも一般的な最適な値は 24 から 36 になる傾向があります。36 を超える設定が最適であった状況はありませんでした。16 未満の値が最適である特殊なケースがある場合もあります。
            </p><p>
              DBT2 や Sysbench などのワークロードの場合、<code class="literal">InnoDB</code> の最適な値は通常 36 くらいであるようです。著しく書き込みの多いワークロードでは、最適な設定はもっと少ない可能性があります。
            </p></li><li class="listitem"><p>
              プライマリストレージエンジンが <code class="literal">MyISAM</code> である場合、<code class="literal">thread_pool_size</code> 設定はかなり小さくするべきです。4 から 8 の値で最適なパフォーマンスが得られる傾向があります。値を大きくすると、パフォーマンスにややマイナスでも劇的な影響を与える傾向はありません。
            </p></li></ul></div><p>
          もう 1 つのシステム変数 <code class="literal">thread_pool_stall_limit</code> はブロックされたステートメントと長時間実行ステートメントの処理に重要です。MySQL Server をブロックするすべての呼び出しがスレッドプールにレポートされる場合、実行スレッドがブロックされるといつでもわかります。ただし、これは常には当てはまらないことがあります。たとえば、ブロックはスレッドプールコールバックによってインストゥルメントされていないコードで発生する可能性があります。そのような場合、スレッドプールはブロックされているように見えるスレッドを識別できる必要があります。これは <code class="literal">thread_pool_stall_limit</code> システム変数を使用してチューニングできる長さであるタイムアウトを使用して実行されます。このパラメータにより、サーバーは完全にブロックされることはありません。<code class="literal">thread_pool_stall_limit</code> の値は、デッドロックされたサーバーのリスクを回避するため、6 秒の上限があります。
        </p><p>
          <code class="literal">thread_pool_stall_limit</code> により、スレッドプールは長時間実行ステートメントを処理することもできます。長期間実行するステートメントがスレッドグループをブロックすることを許可された場合、グループに割り当てられるその他のすべての接続はブロックされ、長期間実行するステートメントが完了するまで実行を開始できません。最悪の場合、これには数時間または数日かかることもあります。
        </p><p>
          <code class="literal">thread_pool_stall_limit</code> の値は、その値より長く実行するステートメントが停滞中とみなされるように選択するべきです。停滞中のステートメントは、追加のコンテキストスイッチと場合によっては追加のスレッド作成が必要であるため、大量の追加のオーバーヘッドを生成します。一方、<code class="literal">thread_pool_stall_limit</code> パラメータを高く設定しすぎることは、長時間実行ステートメントが必要以上に長い間、多数の短時間実行ステートメントをブロックすることを意味します。待機の値が短いと、スレッドはよりすみやかに開始できます。短い値はデッドロック状況を回避により適しています。長い待機の値は、長時間実行するステートメントを含むワークロードで有用で、現在のステートメントの実行時に多数の新しいステートメントが開始しないようにします。
        </p><p>
          サーバーに負荷がかかっている場合でも、サーバーはステートメントの 99.9% が 100 ミリ秒以内に完了するワークロードを実行しており、残りのステートメントが 100 ミリ秒から 2 時間の間でまったく均等に分散してかかるものとします。この場合、<code class="literal">thread_pool_stall_limit</code> を 10 (100 ミリ秒を示す) に設定すると有益であると考えられます。60 ミリ秒のデフォルト値は、主にきわめて簡単なステートメントを実行するサーバーには十分です。
        </p><p>
          <code class="literal">thread_pool_stall_limit</code> パラメータは、サーバーのワークロードに対して適切なバランスをとることができるように、実行時に変更できます。<code class="literal">TP_THREAD_GROUP_STATS</code> テーブルが有効にされているとすると、次のクエリーを使用して、実行されたステートメントの停滞した部分を特定できます。
        </p><pre class="programlisting">
SELECT SUM(STALLED_QUERIES_EXECUTED) / SUM(QUERIES_EXECUTED)
FROM information_schema.TP_THREAD_GROUP_STATS;
</pre><p>
          この数値は可能なかぎり小さくするべきです。ステートメントの停滞の可能性を削減するには、<code class="literal">thread_pool_stall_limit</code> の値を増やします。
        </p><p>
          ステートメントが到着したときに、それが実際に実行を開始するまで、遅延できる最大の時間はどれくらいですか。次の条件が当てはまるとします。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              優先度が低いキューに 200 ステートメントが入れられています。
            </p></li><li class="listitem"><p>
              優先度が高いキューに 10 ステートメントが入れられています。
            </p></li><li class="listitem"><p>
              <code class="literal">thread_pool_prio_kickup_timer</code> は 10000 (10 秒) に設定されています。
            </p></li><li class="listitem"><p>
              <code class="literal">thread_pool_stall_limit</code> は 100 (1 秒) に設定されています。
            </p></li></ul></div><p>
          最悪の場合、10 個の優先度の高いステートメントは長時間実行し続ける 10 個のトランザクションを表します。そのため、最悪の場合に、優先度の高いキューには常に実行を待機しているステートメントがすでに含まれるため、このキューにステートメントが移動されません。10 秒後、新しいステートメントは優先度の高いキューに移動される資格を得ます。ただし、それが移動される前に、その前のすべてのステートメントも移動される必要があります。優先度の高いキューに移動されるのは、1 秒あたり最大 100 ステートメントであるため、これはさらに 2 秒かかる可能性があります。ステートメントが優先度の高いキューに到達したときに、多くの長時間実行ステートメントがその前にある可能性があります。最悪の場合、それらのすべてが停滞中になり、次のステートメントが優先度の高いキューから取得されるまで、ステートメントごとに 1 秒かかります。そのため、このシナリオでは、新しいステートメントが実行を開始するまで 222 秒かかります。
        </p><p>
          この例では、アプリケーションの最悪のケースを示しています。その処理方法はアプリケーションに依存します。アプリケーションの応答時間に対する要件が高い場合、おそらくそれ自体で高いレベルでユーザーを制限するはずです。そうでない場合は、スレッドプール構成パラメータを使用して、何らかの最大待機時間を設定できます。
        </p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="optimize-benchmarking"></a>8.12 パフォーマンスの測定 (ベンチマーク)</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#select-benchmarking">8.12.1 式と関数の速度の測定</a></span></dt><dt><span class="section"><a href="optimization.html#mysql-benchmarks">8.12.2 MySQL ベンチマークスイート</a></span></dt><dt><span class="section"><a href="optimization.html#custom-benchmarks">8.12.3 独自のベンチマークの使用</a></span></dt><dt><span class="section"><a href="optimization.html#monitoring-performance-schema">8.12.4 performance_schema によるパフォーマンスの測定</a></span></dt><dt><span class="section"><a href="optimization.html#thread-information">8.12.5 スレッド情報の検査</a></span></dt></dl></div><a class="indexterm" name="idm139979110649280"></a><p>
      パフォーマンスを測定するには、次の要因を考慮します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ビジーでないシステムで単一の操作の速度を測定するかどうか、一連の操作 (<span class="quote">「<span class="quote">ワークロード</span>」</span>) が一定の期間でどの程度機能するか。単純なテストでは、通常 1 つの側面 (構成設定、テーブルのインデックスのセット、クエリー内の SQL 句) の変化がパフォーマンスにどのように影響するかをテストします。ベンチマークは一般に長時間実行の複雑なパフォーマンステストであり、結果によって、ハードウェアやストレージ構成などの高レベルの選択や新しい MySQL バージョンにあとどのくらいでアップグレードするかが決まります。
        </p></li><li class="listitem"><p>
          ベンチマークでは、正確な実態を得るために、重いデータベースワークロードをシミュレートする必要がある場合があります。
        </p></li><li class="listitem"><p>
          パフォーマンスはきわめて多くのさまざまな要因によって異なる可能性があり、数パーセントの違いが決定的勝利にならないことがあります。結果は、別の環境でテストした場合に、逆の方向に転換することもあります。
        </p></li><li class="listitem"><p>
          特定の MySQL 機能は、ワークロードに応じて、パフォーマンスに役立つ場合と役立たない場合があります。完全性のため、常にそれらの機能をオンにした状態とオフにした状態でパフォーマンスをテストします。各ワークロードで試すべきもっとも重要な 2 つの機能は、<a class="link" href="optimization.html#query-cache" title="8.9.3 MySQL クエリーキャッシュ">MySQL クエリーキャッシュ</a>と <code class="literal">InnoDB</code> テーブルの<a class="link" href="innodb-storage-engine.html#innodb-adaptive-hash" title="14.2.13.6 適応型ハッシュインデックス">アダプティブハッシュインデックス</a>です。
        </p></li></ul></div><p>
      このセクションでは、1 人の開発者が実行できる単純で直接的な測定技法から、実行と結果の解釈に追加の専門技術を必要とするもっと複雑な技法に進めていきます。
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="select-benchmarking"></a>8.12.1 式と関数の速度の測定</h3></div></div></div><p>
        特定の MySQL 式または関数の速度を測定するには、<span class="command"><strong>mysql</strong></span> クライアントプログラムを使用して、<code class="literal">BENCHMARK()</code> 関数を呼び出します。その構文は <code class="literal">BENCHMARK(<em class="replaceable"><code>loop_count</code></em>,<em class="replaceable"><code>expression</code></em>)</code> です。戻り値は常に 0 ですが、<span class="command"><strong>mysql</strong></span> はステートメントの実行にどのくらいの時間を要したかを表示する行を出力します。例:
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT BENCHMARK(1000000,1+1);</code></strong>
+------------------------+
| BENCHMARK(1000000,1+1) |
+------------------------+
|                      0 |
+------------------------+
1 row in set (0.32 sec)
</pre><p>
        この結果は Pentium II 400MHz システムで取得されました。これは、MySQL がそのシステムで 1,000,000 件の単純な加算式を 0.32 秒間で実行できることを示しています。
      </p><p>
        組み込みの MySQL 関数は一般に高度に最適化されますが、例外がある場合もあります。<code class="literal">BENCHMARK()</code> はクエリーで特定の関数が問題になっているかどうかを調べる場合に優れたツールです。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="mysql-benchmarks"></a>8.12.2 MySQL ベンチマークスイート</h3></div></div></div><a class="indexterm" name="idm139979110624928"></a><a class="indexterm" name="idm139979110623504"></a><p>
        このベンチマークスイートは、特定の SQL 実装のパフォーマンスが向上または低下する操作をユーザーに示すことを目的としています。MySQL ソース配布の <code class="filename">sql-bench</code> ディレクトリにあるコードと結果を確認することで、ベンチマークの動作について十分に理解できます。
      </p><p>
        このベンチマークはシングルスレッドであるため、実行される操作の最短時間を測定します。将来はこのベンチマークスイートにマルチスレッドのテストも追加する予定です。
      </p><p>
        ベンチマークスイートを使用するには、次の要件を満たす必要があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            ベンチマークスイートは、MySQL ソース配布によって提供されます。<a class="ulink" href="http://dev.mysql.com/downloads/" target="_top">http://dev.mysql.com/downloads/</a> からリリース済みの配布をダウンロードするか、現在の開発ソースツリーを使用します。(<a class="xref" href="installing.html#installing-development-tree" title="2.9.3 開発ソースツリーを使用して MySQL をインストールする">セクション2.9.3「開発ソースツリーを使用して MySQL をインストールする」</a>を参照してください。)
          </p></li><li class="listitem"><p>
            ベンチマークスクリプトは Perl で書かれ、データベースサーバーにアクセスするために Perl DBI モジュールを使用しているため、DBI をインストールする必要があります。さらに、テスト対象のサーバーのそれぞれにサーバー固有の DBD ドライバも必要です。たとえば、MySQL、PostgreSQL、および DB2 をテストするには、<code class="literal">DBD::mysql</code>、<code class="literal">DBD::Pg</code>、<code class="literal">DBD::DB2</code> のモジュールがインストールされている必要があります。<a class="xref" href="installing.html#perl-support" title="2.13 Perl のインストールに関する注釈">セクション2.13「Perl のインストールに関する注釈」</a> を参照してください。
          </p></li></ul></div><p>
        MySQL ソース配布の入手後、その <code class="filename">sql-bench</code> ディレクトリにあるベンチマークスイートを見つけることができます。ベンチマークテストを実行するには、MySQL を構築し、場所を <code class="filename">sql-bench</code> ディレクトリに変更し、<code class="literal">run-all-tests</code> スクリプトを実行します。
      </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>cd sql-bench</code></strong>
shell&gt; <strong class="userinput"><code>perl run-all-tests --server=<em class="replaceable"><code>server_name</code></em></code></strong>
</pre><p>
        <em class="replaceable"><code>server_name</code></em> はサポートされるいずれかのサーバーの名前にするべきです。すべてのオプションとサポート対象サーバーの一覧を取得するには、このコマンドを呼び出します。
      </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>perl run-all-tests --help</code></strong>
</pre><a class="indexterm" name="idm139979110603280"></a><p>
        <span class="command"><strong>crash-me</strong></span> スクリプトも <code class="filename">sql-bench</code> ディレクトリにあります。<span class="command"><strong>crash-me</strong></span> では、実際のクエリーを実行することによって、データベースシステムがサポートする機能と、その性能と制限を判断しようとします。たとえば、次を判断します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            サポートされるデータ型
          </p></li><li class="listitem"><p>
            サポートされるインデックス数
          </p></li><li class="listitem"><p>
            サポートされる関数
          </p></li><li class="listitem"><p>
            使用可能なクエリーの大きさ
          </p></li><li class="listitem"><p>
            使用可能な <code class="literal">VARCHAR</code> カラムの大きさ
          </p></li></ul></div><p>
        ベンチマーク結果の詳細については、http://www.mysql.com/why-mysql/benchmarks/ を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="custom-benchmarks"></a>8.12.3 独自のベンチマークの使用</h3></div></div></div><a class="indexterm" name="idm139979110591008"></a><a class="indexterm" name="idm139979110589584"></a><p>
        アプリケーションとデータベースのベンチマークを行い、ボトルネックのある場所を見つけます。1 つのボトルネックを修正 (または、それを<span class="quote">「<span class="quote">ダミー</span>」</span>モジュールで置換) することによって、次のボトルネックの識別に進むことができます。現在のアプリケーションの全体的なパフォーマンスが許容できるものであっても、いつか実際にパフォーマンスの強化が必要になった場合に、少なくとも各ボトルネックの計画を立て、解決方法を決定しておくべきです。
      </p><p>
        移植可能なベンチマークプログラムの例については、MySQL ベンチマークスイートのそれらを参照してください。<a class="xref" href="optimization.html#mysql-benchmarks" title="8.12.2 MySQL ベンチマークスイート">セクション8.12.2「MySQL ベンチマークスイート」</a>を参照してください。このスイートから任意のプログラムを選び、独自のニーズに合わせて変更できます。これを実行することによって、それぞれの問題に対してさまざまな解決方法を試してみて、実際にもっとも高速であるのはどれかをテストできます。
      </p><p>
        もう 1 つの無料のベンチマークスイートは Open Source Database Benchmark であり、<a class="ulink" href="http://osdb.sourceforge.net/" target="_top">http://osdb.sourceforge.net/</a> で入手できます。
      </p><p>
        システムの負荷が非常に高い場合にのみ問題が発生することはよくあることです。(テスト済みの) システムを本稼働させて、負荷の問題が発生したときに、問い合わせてくる顧客が多数いました。ほとんどの場合、パフォーマンスの問題は、高負荷時のテーブルスキャンの不良などデータベースの基本的な設計の問題か、オペレーティングシステムやライブラリの問題によると判明しています。ほとんどの場合、システムがまだ本稼働に入っていない場合の方がこれらの問題の修正がはるかに容易です。
      </p><p>
        このような問題を回避するには、可能性のある最悪の負荷でアプリケーション全体のベンチマークを行います。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            複数のクライアントが同時にクエリーを発行して生成される高い負荷をシミュレートするには、<span class="command"><strong>mysqlslap</strong></span> プログラムが役立つ可能性があります。<a class="xref" href="programs.html#mysqlslap" title="4.5.7 mysqlslap — 負荷エミュレーションクライアント">セクション4.5.7「<span class="command"><strong>mysqlslap</strong></span> — 負荷エミュレーションクライアント」</a>を参照してください。
          </p></li><li class="listitem"><p>
            SysBench および DBT2 などのベンチマークパッケージを試してみることもできます。これは、<a class="ulink" href="http://sourceforge.net/projects/sysbench/" target="_top">http://sourceforge.net/projects/sysbench/</a> および <a class="ulink" href="http://osdldbt.sourceforge.net/#dbt2" target="_top">http://osdldbt.sourceforge.net/#dbt2</a> で入手できます。
          </p></li></ul></div><p>
        これらのプログラムやパッケージはシステムを破損させる可能性があるため、それらは開発システムでのみ使用するようにしてください。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="monitoring-performance-schema"></a>8.12.4 performance_schema によるパフォーマンスの測定</h3></div></div></div><a class="indexterm" name="idm139979110572192"></a><p>
        <code class="literal">performance_schema</code> データベースのテーブルをクエリーし、それを実行しているサーバーとアプリケーションのパフォーマンス特性に関するリアルタイムの情報を確認できます。詳細は、<a class="xref" href="performance-schema.html" title="第 22 章 MySQL パフォーマンススキーマ">第22章「<i>MySQL パフォーマンススキーマ</i>」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="thread-information"></a>8.12.5 スレッド情報の検査</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="optimization.html#thread-commands">8.12.5.1 スレッドのコマンド値</a></span></dt><dt><span class="section"><a href="optimization.html#general-thread-states">8.12.5.2 一般的なスレッドの状態</a></span></dt><dt><span class="section"><a href="optimization.html#delayed-insert-thread-states">8.12.5.3 遅延挿入スレッドの状態</a></span></dt><dt><span class="section"><a href="optimization.html#query-cache-thread-states">8.12.5.4 クエリーキャッシュスレッドの状態</a></span></dt><dt><span class="section"><a href="optimization.html#master-thread-states">8.12.5.5 レプリケーションマスタースレッドの状態</a></span></dt><dt><span class="section"><a href="optimization.html#slave-io-thread-states">8.12.5.6 レプリケーションスレーブの I/O スレッド状態</a></span></dt><dt><span class="section"><a href="optimization.html#slave-sql-thread-states">8.12.5.7 レプリケーションスレーブ SQL スレッドの状態</a></span></dt><dt><span class="section"><a href="optimization.html#slave-connection-thread-states">8.12.5.8 レプリケーションスレーブ接続スレッドの状態</a></span></dt><dt><span class="section"><a href="optimization.html#mysql-cluster-thread-states">8.12.5.9 MySQL Cluster スレッドの状態</a></span></dt><dt><span class="section"><a href="optimization.html#event-scheduler-thread-states">8.12.5.10 イベントスケジューラスレッドの状態</a></span></dt></dl></div><a class="indexterm" name="idm139979110566656"></a><a class="indexterm" name="idm139979110564544"></a><a class="indexterm" name="idm139979110562512"></a><p>
        MySQL サーバーで何が実行されているかを確認しようとする場合、プロセスリストを調査すると役立つ場合があります。これは、サーバー内で現在実行されているスレッドのセットです。プロセスリストの情報はこれらのソースから入手できます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">SHOW [FULL] PROCESSLIST</code> ステートメント: <a class="xref" href="sql-syntax.html#show-processlist" title="13.7.5.30 SHOW PROCESSLIST 構文">セクション13.7.5.30「SHOW PROCESSLIST 構文」</a>
          </p></li><li class="listitem"><p>
            <code class="literal">SHOW PROFILE</code> ステートメント: <a class="xref" href="sql-syntax.html#show-profiles" title="13.7.5.32 SHOW PROFILES 構文">セクション13.7.5.32「SHOW PROFILES 構文」</a>
          </p></li><li class="listitem"><p>
            <code class="literal">INFORMATION_SCHEMA</code> <code class="literal">PROCESSLIST</code> テーブル: <a class="xref" href="information-schema.html#processlist-table" title="21.15 INFORMATION_SCHEMA PROCESSLIST テーブル">セクション21.15「INFORMATION_SCHEMA PROCESSLIST テーブル」</a>
          </p></li><li class="listitem"><p>
            <span class="command"><strong>mysqladmin processlist</strong></span> コマンド: <a class="xref" href="programs.html#mysqladmin" title="4.5.2 mysqladmin — MySQL サーバーの管理を行うクライアント">セクション4.5.2「<span class="command"><strong>mysqladmin</strong></span> — MySQL サーバーの管理を行うクライアント」</a>
          </p></li><li class="listitem"><p>
            <code class="literal">performance_schema.threads</code> テーブル: <a class="xref" href="performance-schema.html#performance-schema-miscellaneous-tables" title="22.9.10 パフォーマンススキーマのその他のテーブル">セクション22.9.10「パフォーマンススキーマのその他のテーブル」</a>
          </p></li></ul></div><p>
        <code class="literal">threads</code> へのアクセスには相互排他ロックは必要なく、サーバーパフォーマンスへの影響は最小です。<code class="literal">INFORMATION_SCHEMA.PROCESSLIST</code> および <code class="literal">SHOW PROCESSLIST</code> は、相互排他ロックを必要とするので、負のパフォーマンスの結果になります。<code class="literal">threads</code> はまた、バックグラウンドスレッドに関する情報も表示しますが、<code class="literal">INFORMATION_SCHEMA.PROCESSLIST</code> および <code class="literal">SHOW PROCESSLIST</code> は表示しません。これは、<code class="literal">threads</code> は、ほかのスレッド情報源では行えないアクティビティーのモニターに使用できることを意味します。
      </p><p>
        自分のスレッドに関する情報はいつでも表示できます。ほかのアカウントで実行されているスレッドに関する情報を表示するには、<code class="literal">PROCESS</code> 権限が必要です。
      </p><p>
        プロセスリストの各エントリには、いくつかの情報が含まれています。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Id</code> は、スレッドに関連付けられているクライアントの接続識別子です。
          </p></li><li class="listitem"><p>
            <code class="literal">User</code> と <code class="literal">Host</code> は、スレッドに関連付けられているアカウントを示します。
          </p></li><li class="listitem"><p>
            <code class="literal">db</code> は、スレッドのデフォルトのデータベースで、または何も選択されていない場合は <code class="literal">NULL</code> です。
          </p></li><li class="listitem"><p>
            <code class="literal">Command</code> と <code class="literal">State</code> は、スレッドが何を実行しているかを示します。
          </p><p>
            ほとんどの状態がきわめてすばやい操作に対応します。スレッドの状態が何秒間も特定の状態にとどまっている場合は、調査が必要な問題が発生している可能性があります。
          </p></li><li class="listitem"><p>
            <code class="literal">Time</code> は、スレッドの現在の状態がどれだけ続いているかを示します。特定の場合に、スレッドの現在の時間の概念が変わることがあります。スレッドは、<code class="literal">SET TIMESTAMP = <em class="replaceable"><code>value</code></em></code> によって時間を変更することがあります。マスターからのイベントを処理しているスレーブで実行しているスレッドの場合、スレッドの時間はイベント内に見つかった時間に設定されるため、スレーブではなくマスターの現在の時間を反映します。
          </p></li><li class="listitem"><p>
            <code class="literal">Info</code> には、スレッドで実行されているステートメントのテキストが含まれるか、または何も実行されていない場合は <code class="literal">NULL</code> です。デフォルトでは、この値にはステートメントの先頭の 100 文字だけが含まれます。完全なステートメントを表示するには、<code class="literal">SHOW FULL PROCESSLIST</code> を使用します。
          </p></li></ul></div><p>
        以下のセクションでは、<code class="literal">Command</code> の可能な値と、カテゴリ別にグループ化した <code class="literal">State</code> の値を説明します。これらの一部の値の意味は自明です。その他については追加の説明を提供しています。
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="thread-commands"></a>8.12.5.1 スレッドのコマンド値</h4></div></div></div><a class="indexterm" name="idm139979110514976"></a><p>
          スレッドの <code class="literal">Command</code> 値は次のいずれかになります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <a class="indexterm" name="idm139979110511600"></a> <a class="indexterm" name="idm139979110509424"></a> <code class="literal">Binlog Dump</code>
            </p><p>
              これは、バイナリログの内容をスレーブサーバーに送信するためのマスターサーバー上のスレッドです。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110505280"></a> <a class="indexterm" name="idm139979110503104"></a> <code class="literal">Change user</code>
            </p><p>
              スレッドはユーザー変更操作を実行しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110499104"></a> <a class="indexterm" name="idm139979110496928"></a> <code class="literal">Close stmt</code>
            </p><p>
              スレッドはプリペアドステートメントをクローズしています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110492896"></a> <a class="indexterm" name="idm139979110490720"></a> <code class="literal">Connect</code>
            </p><p>
              レプリケーションスレーブはそのマスターに接続されています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110486688"></a> <a class="indexterm" name="idm139979110484512"></a> <code class="literal">Connect Out</code>
            </p><p>
              レプリケーションスレーブはそのマスターに接続しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110480480"></a> <a class="indexterm" name="idm139979110478304"></a> <code class="literal">Create DB</code>
            </p><p>
              スレッドはデータベース作成操作を実行しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110474288"></a> <a class="indexterm" name="idm139979110472112"></a> <code class="literal">Daemon</code>
            </p><p>
              このスレッドはサーバーの内部で使用され、クライアント接続をホストするスレッドではありません。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110467968"></a> <a class="indexterm" name="idm139979110465792"></a> <code class="literal">Debug</code>
            </p><p>
              スレッドはデバッグ情報を生成しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110461808"></a> <a class="indexterm" name="idm139979110459632"></a> <code class="literal">Delayed insert</code>
            </p><p>
              スレッドは遅延挿入ハンドラです。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110455664"></a> <a class="indexterm" name="idm139979110453488"></a> <code class="literal">Drop DB</code>
            </p><p>
              スレッドはデータベース削除操作を実行しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110449472"></a> <a class="indexterm" name="idm139979110447296"></a> <code class="literal">Error</code>
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110443888"></a> <a class="indexterm" name="idm139979110441712"></a> <code class="literal">Execute</code>
            </p><p>
              スレッドはプリペアドステートメントを実行しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110437696"></a> <a class="indexterm" name="idm139979110435520"></a> <code class="literal">Fetch</code>
            </p><p>
              スレッドはプリペアドステートメントの実行から結果をフェッチしています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110431440"></a> <a class="indexterm" name="idm139979110429264"></a> <code class="literal">Field List</code>
            </p><p>
              スレッドはテーブルカラムの情報を取得しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110425248"></a> <a class="indexterm" name="idm139979110423072"></a> <code class="literal">Init DB</code>
            </p><p>
              スレッドはデフォルトのデータベースを選択しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110419056"></a> <a class="indexterm" name="idm139979110416880"></a> <code class="literal">Kill</code>
            </p><p>
              スレッドは別のスレッドを強制終了しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110412880"></a> <a class="indexterm" name="idm139979110410704"></a> <code class="literal">Long Data</code>
            </p><p>
              スレッドはプリペアドステートメントの実行の結果から長いデータを取得しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110406608"></a> <a class="indexterm" name="idm139979110404432"></a> <code class="literal">Ping</code>
            </p><p>
              スレッドはサーバー ping 要求を処理しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110400432"></a> <a class="indexterm" name="idm139979110398256"></a> <code class="literal">Prepare</code>
            </p><p>
              スレッドはプリペアドステートメントを準備しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110394240"></a> <a class="indexterm" name="idm139979110392064"></a> <code class="literal">Processlist</code>
            </p><p>
              スレッドはサーバースレッドに関する情報を生成しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110388032"></a> <a class="indexterm" name="idm139979110385856"></a> <code class="literal">Query</code>
            </p><p>
              スレッドはステートメントを実行しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110381872"></a> <a class="indexterm" name="idm139979110379696"></a> <code class="literal">Quit</code>
            </p><p>
              スレッドは終了しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110375760"></a> <a class="indexterm" name="idm139979110373584"></a> <code class="literal">Refresh</code>
            </p><p>
              スレッドは、テーブル、ログ、またはキャッシュをフラッシュしているか、ステータス変数またはレプリケーションサーバーの情報をリセットしています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110369296"></a> <a class="indexterm" name="idm139979110367120"></a> <code class="literal">Register Slave</code>
            </p><p>
              スレッドはスレーブサーバーを登録しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110363120"></a> <a class="indexterm" name="idm139979110360944"></a> <code class="literal">Reset stmt</code>
            </p><p>
              スレッドはプリペアドステートメントをリセットしています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110356912"></a> <a class="indexterm" name="idm139979110354784"></a> <code class="literal">Set option</code>
            </p><p>
              スレッドはクライアントのステートメント実行オプションを設定またはリセットしています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110350624"></a> <a class="indexterm" name="idm139979110348448"></a> <code class="literal">Shutdown</code>
            </p><p>
              スレッドはサーバーをシャットダウンしています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110344448"></a> <a class="indexterm" name="idm139979110342272"></a> <code class="literal">Sleep</code>
            </p><p>
              スレッドはクライアントが新しいステートメントをそれに送信するのを待機しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110338160"></a> <a class="indexterm" name="idm139979110335984"></a> <code class="literal">Statistics</code>
            </p><p>
              スレッドはサーバーステータス情報を生成しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110331968"></a> <a class="indexterm" name="idm139979110329792"></a> <code class="literal">Table Dump</code>
            </p><p>
              スレッドはテーブルの内容をスレーブサーバーに送信しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110325744"></a> <a class="indexterm" name="idm139979110323568"></a> <code class="literal">Time</code>
            </p><p>
              使用されません。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="general-thread-states"></a>8.12.5.2 一般的なスレッドの状態</h4></div></div></div><a class="indexterm" name="idm139979110318704"></a><p>
          次のリストは、レプリケーションなどの特殊なアクティビティーではなく、一般的なクエリーの処理に関連付けられた、スレッドの <code class="literal">State</code> 値を説明しています。これらの多くは、サーバーのバグを見つけるためにのみ役立ちます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <a class="indexterm" name="idm139979110314160"></a> <a class="indexterm" name="idm139979110312000"></a> <code class="literal">After create</code>
            </p><p>
              これは、スレッドがテーブル (内部一時テーブルも含む) を作成する際の、テーブルを作成する関数の最後に発生します。何らかのエラーのためテーブルを作成できなかった場合でも、この状態が使われます。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110307584"></a> <a class="indexterm" name="idm139979110305424"></a> <code class="literal">altering table</code>
            </p><p>
              サーバーはインプレース <code class="literal">ALTER TABLE</code> の実行中です。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110300496"></a> <a class="indexterm" name="idm139979110298336"></a> <code class="literal">Analyzing</code>
            </p><p>
              スレッドは <code class="literal">MyISAM</code> テーブルのキー分布を計算しています (<code class="literal">ANALYZE TABLE</code> などで)。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110292640"></a> <a class="indexterm" name="idm139979110290480"></a> <code class="literal">checking permissions</code>
            </p><p>
              スレッドは、サーバーがステートメントを実行するために必要な権限を持っているかどうかを確認しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110286336"></a> <a class="indexterm" name="idm139979110284176"></a> <code class="literal">Checking table</code>
            </p><p>
              スレッドはテーブルチェック操作を実行しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110280176"></a> <a class="indexterm" name="idm139979110278016"></a> <code class="literal">cleaning up</code>
            </p><p>
              スレッドは 1 つのコマンドを処理し、メモリーの解放と特定の状態変数のリセットを準備しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110273888"></a> <a class="indexterm" name="idm139979110271728"></a> <code class="literal">closing tables</code>
            </p><p>
              スレッドは、変更されたテーブルデータをディスクにフラッシュし、使用されたテーブルをクローズしています。これは高速の操作であるはずです。そうでない場合は、ディスクがいっぱいでないか、ディスクが著しく頻繁に使用されていないかを確認してください。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110267312"></a> <a class="indexterm" name="idm139979110265088"></a> <code class="literal">committing alter table to storage engine</code>
            </p><p>
              サーバーはインプレース <code class="literal">ALTER TABLE</code> を終了し、結果をコミットしています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110259984"></a> <a class="indexterm" name="idm139979110257792"></a> <code class="literal">converting HEAP to MyISAM</code>
            </p><p>
              スレッドは内部一時テーブルを <code class="literal">MEMORY</code> テーブルからディスク上の <code class="literal">MyISAM</code> テーブルに変換しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110252240"></a> <a class="indexterm" name="idm139979110250080"></a> <code class="literal">copy to tmp table</code>
            </p><p>
              スレッドは <code class="literal">ALTER TABLE</code> ステートメントを処理しています。この状態は、新しい構造でテーブルが作成されたあと、ただし、それに行がコピーされる前に発生します。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110244832"></a> <a class="indexterm" name="idm139979110242672"></a> <code class="literal">Copying to group table</code>
            </p><p>
              ステートメントの <code class="literal">ORDER BY</code> と <code class="literal">GROUP BY</code> の基準が異なる場合、行はグループによってソートされ、一時テーブルにコピーされます。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110237104"></a> <a class="indexterm" name="idm139979110234944"></a> <code class="literal">Copying to tmp table</code>
            </p><p>
              サーバーはメモリー内の一時テーブルにコピーしています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110230928"></a> <a class="indexterm" name="idm139979110228736"></a> <code class="literal">Copying to tmp table on disk</code>
            </p><p>
              サーバーはディスク上の一時テーブルにコピーしています。一時結果セットが大きくなりすぎました (<a class="xref" href="optimization.html#internal-temporary-tables" title="8.4.4 MySQL が内部一時テーブルを使用する仕組み">セクション8.4.4「MySQL が内部一時テーブルを使用する仕組み」</a>を参照してください)。その結果、スレッドは一時テーブルをインメモリーからディスクベースのフォーマットに変更して、メモリーを節約します。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110223648"></a> <a class="indexterm" name="idm139979110221536"></a> <code class="literal">Creating index</code>
            </p><p>
              スレッドは <code class="literal">MyISAM</code> テーブルに対する <code class="literal">ALTER TABLE ... ENABLE KEYS</code> を処理しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110216128"></a> <a class="indexterm" name="idm139979110213968"></a> <code class="literal">Creating sort index</code>
            </p><p>
              スレッドは内部一時テーブルを使用して解決される <code class="literal">SELECT</code> を処理しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110208944"></a> <a class="indexterm" name="idm139979110206784"></a> <code class="literal">creating table</code>
            </p><p>
              スレッドはテーブルを作成しています。これには一時テーブルの作成が含まれます。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110202704"></a> <a class="indexterm" name="idm139979110200544"></a> <code class="literal">Creating tmp table</code>
            </p><p>
              スレッドはメモリー内またはディスク上に一時テーブルを作成しています。メモリー内に作成されたテーブルがあとでディスク上のテーブルに変換される場合、その操作中の状態は <code class="literal">Copying to tmp table on disk</code> になります。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110195456"></a> <a class="indexterm" name="idm139979110193264"></a> <code class="literal">deleting from main table</code>
            </p><p>
              サーバーは複数テーブル削除の最初の部分を実行しています。最初のテーブルからのみ削除し、別の (参照) テーブルからの削除に使用されるカラムとオフセットを保存しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110188880"></a> <a class="indexterm" name="idm139979110186688"></a> <code class="literal">deleting from reference tables</code>
            </p><p>
              サーバーは複数テーブル削除の 2 番目の部分を実行しており、別のテーブルから一致した行を削除しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110182496"></a> <a class="indexterm" name="idm139979110180304"></a> <code class="literal">discard_or_import_tablespace</code>
            </p><p>
              スレッドは <code class="literal">ALTER TABLE ... DISCARD TABLESPACE</code> または <code class="literal">ALTER TABLE ... IMPORT TABLESPACE</code> ステートメントを処理しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110174816"></a> <a class="indexterm" name="idm139979110172720"></a> <code class="literal">end</code>
            </p><p>
              これは、<code class="literal">ALTER TABLE</code>、<code class="literal">CREATE VIEW</code>、<code class="literal">DELETE</code>、<code class="literal">INSERT</code>、<code class="literal">SELECT</code>、または <code class="literal">UPDATE</code> ステートメントの最後、ただしクリーンアップの前に発生します。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110162832"></a> <a class="indexterm" name="idm139979110160672"></a> <code class="literal">executing</code>
            </p><p>
              スレッドはステートメントの実行を開始しました。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110156688"></a> <a class="indexterm" name="idm139979110154496"></a> <code class="literal">Execution of init_command</code>
            </p><p>
              スレッドは <code class="literal">init_command</code> システム変数の値のステートメントを実行しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110149712"></a> <a class="indexterm" name="idm139979110147552"></a> <code class="literal">freeing items</code>
            </p><p>
              スレッドはコマンドを実行しました。この状態中に実行される項目の解放の一部には、クエリーキャッシュが含まれます。通常、この状態のあとは <code class="literal">cleaning up</code> になります。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110142560"></a> <a class="indexterm" name="idm139979110140400"></a> <code class="literal">Flushing tables</code>
            </p><p>
              スレッドは <code class="literal">FLUSH TABLES</code> を実行しており、すべてのスレッドがそれぞれのテーブルをクローズするのを待っています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110135008"></a> <a class="indexterm" name="idm139979110132848"></a> <code class="literal">FULLTEXT initialization</code>
            </p><p>
              サーバーは自然言語全文検索を実行する準備をしています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110128832"></a> <a class="indexterm" name="idm139979110126672"></a> <code class="literal">init</code>
            </p><p>
              これは、<code class="literal">ALTER TABLE</code>、<code class="literal">DELETE</code>、<code class="literal">INSERT</code>、<code class="literal">SELECT</code>、または <code class="literal">UPDATE</code> ステートメントの初期化の前に発生します。この状態のサーバーによってとられるアクションには、バイナリログ、<code class="literal">InnoDB</code> ログ、および一部のクエリーキャッシュクリーンアップ操作のフラッシュが含まれます。
            </p><p>
              <code class="literal">end</code> 状態では、次の操作が行われることがあります。
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  テーブルのデータが変更されたあとのクエリーキャッシュエントリの削除
                </p></li><li class="listitem"><p>
                  バイナリログへのイベントの書き込み
                </p></li><li class="listitem"><p>
                  BLOB 用を含むメモリーバッファーの解放
                </p></li></ul></div></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110112016"></a> <a class="indexterm" name="idm139979110109856"></a> <code class="literal">Killed</code>
            </p><p>
              だれかがスレッドに <code class="literal">KILL</code> ステートメントを送っており、スレッドは次に強制終了フラグをチェックしたときに中止するはずです。フラグは MySQL の各主要ループ内でチェックされますが、場合によってはスレッドが停止するまでに少し時間がかかる場合があります。スレッドがほかのスレッドにロックされている場合、強制終了はほかのスレッドがそのロックを解除するとすぐに有効になります。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110104400"></a> <a class="indexterm" name="idm139979110102240"></a> <code class="literal">logging slow query</code>
            </p><p>
              スレッドはステートメントを低速クエリーログに書き込んでいます。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110098208"></a> <a class="indexterm" name="idm139979110096048"></a> <code class="literal">NULL</code>
            </p><p>
              この状態は <code class="literal">SHOW PROCESSLIST</code> 状態に使用されます。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110091120"></a> <a class="indexterm" name="idm139979110088960"></a> <code class="literal">login</code>
            </p><p>
              クライアントが正常に認証されるまでの接続スレッドの初期状態です。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110084912"></a> <a class="indexterm" name="idm139979110082752"></a> <code class="literal">manage keys</code>
            </p><p>
              サーバーはテーブルインデックスを有効または無効にしています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110078720"></a> <a class="indexterm" name="idm139979110076560"></a> <a class="indexterm" name="idm139979110074624"></a> <a class="indexterm" name="idm139979110072464"></a> <code class="literal">Opening tables</code>、<code class="literal">Opening table</code>
            </p><p>
              スレッドはテーブルをオープンしようと試みています。これは、何かにオープンを妨げられないかぎり、きわめて高速な手順であるはずです。たとえば、<code class="literal">ALTER TABLE</code> または <code class="literal">LOCK TABLE</code> ステートメントは、そのステートメントが終了するまでテーブルのオープンを妨げることがあります。<code class="literal">table_open_cache</code> 値が十分に大きいことをチェックすることも価値があります。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110063824"></a> <a class="indexterm" name="idm139979110061664"></a> <code class="literal">optimizing</code>
            </p><p>
              サーバーはクエリーの初期最適化を実行しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110057664"></a> <a class="indexterm" name="idm139979110055504"></a> <code class="literal">preparing</code>
            </p><p>
              この状態はクエリーの最適化中に発生します。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110051536"></a> <a class="indexterm" name="idm139979110049344"></a> <code class="literal">preparing for alter table</code>
            </p><p>
              サーバーはインプレース <code class="literal">ALTER TABLE</code> の実行を準備しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110044336"></a> <a class="indexterm" name="idm139979110042176"></a> <code class="literal">Purging old relay logs</code>
            </p><p>
              スレッドは不要なリレーログファイルを削除しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110038176"></a> <a class="indexterm" name="idm139979110036016"></a> <code class="literal">query end</code>
            </p><p>
              この状態は、クエリーを処理したあと、ただし <code class="literal">freeing items</code> 状態の前に発生します。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110031264"></a> <a class="indexterm" name="idm139979110029104"></a> <code class="literal">Reading from net</code>
            </p><p>
              サーバーはネットワークからパケットを読み取っています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110025088"></a> <a class="indexterm" name="idm139979110022928"></a> <code class="literal">Removing duplicates</code>
            </p><p>
              クエリーは、MySQL が早い段階で個別の操作を最適化できなくなるような方法で <code class="literal">SELECT DISTINCT</code> を使用していました。このため、MySQL は結果をクライアントに送る前にすべての重複した行を削除するための追加の段階を必要とします。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110017248"></a> <a class="indexterm" name="idm139979110015088"></a> <code class="literal">removing tmp table</code>
            </p><p>
              スレッドは <code class="literal">SELECT</code> ステートメントを処理したあとに内部一時テーブルを削除しています。一時テーブルが作成されなかった場合、この状態は使用されません。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110009856"></a> <a class="indexterm" name="idm139979110007696"></a> <code class="literal">rename</code>
            </p><p>
              スレッドはテーブルの名前を変更しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979110003728"></a> <a class="indexterm" name="idm139979110001568"></a> <code class="literal">rename result table</code>
            </p><p>
              スレッドは <code class="literal">ALTER TABLE</code> ステートメントを処理しており、新しいテーブルを作成し、元のテーブルを置き換えるためにその名前を変更しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109996384"></a> <a class="indexterm" name="idm139979109994224"></a> <code class="literal">Reopen tables</code>
            </p><p>
              スレッドはテーブルのロックを取得しましたが、ロックの取得後、基盤となるテーブル構造が変更されたことを認識しました。それはロックを解除し、テーブルをクローズして、再度オープンしようとしています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109989808"></a> <a class="indexterm" name="idm139979109987648"></a> <code class="literal">Repair by sorting</code>
            </p><p>
              修復コードはインデックスを作成するためにソートを使用しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109983600"></a> <a class="indexterm" name="idm139979109981440"></a> <code class="literal">Repair done</code>
            </p><p>
              スレッドは <code class="literal">MyISAM</code> テーブルに対するマルチスレッドの修復を完了しました。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109976688"></a> <a class="indexterm" name="idm139979109974528"></a> <code class="literal">Repair with keycache</code>
            </p><p>
              修復コードはキーキャッシュ経由で、1 つずつキーの作成を使用しています。これは <code class="literal">Repair by sorting</code> よりはるかに遅くなります。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109969664"></a> <a class="indexterm" name="idm139979109967504"></a> <code class="literal">Rolling back</code>
            </p><p>
              スレッドはトランザクションをロールバックしています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109963504"></a> <a class="indexterm" name="idm139979109961344"></a> <code class="literal">Saving state</code>
            </p><p>
              <code class="literal">MyISAM</code> テーブルの修復や分析などの操作で、スレッドは新しいテーブルの状態を <code class="filename">.MYI</code> ファイルヘッダーに保存しています。状態には、行の数、<code class="literal">AUTO_INCREMENT</code> カウンタ、キー分布などの情報が含まれています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109954928"></a> <a class="indexterm" name="idm139979109952736"></a> <code class="literal">Searching rows for update</code>
            </p><p>
              スレッドは、すべての一致する行を更新する前に、それらを見つけるための第 1 フェーズを実行しています。これは、<code class="literal">UPDATE</code> が、関連する行を見つけるために使用されるインデックスを変更している場合に、実行される必要があります。
            </p></li><li class="listitem"><p>
              <code class="literal">Sending data</code>
            </p><p>
              スレッドは <code class="literal">SELECT</code> ステートメントの行を読み取り、処理して、データをクライアントに送信しています。この状態で行われる操作は、大量のディスクアクセス (読み取り) を実行する傾向があるため、特定のクエリーの存続期間にわたる最長時間実行状態になることがあります。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109943728"></a> <a class="indexterm" name="idm139979109941568"></a> <code class="literal">setup</code>
            </p><p>
              スレッドは <code class="literal">ALTER TABLE</code> 操作を開始しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109936640"></a> <a class="indexterm" name="idm139979109934480"></a> <code class="literal">Sorting for group</code>
            </p><p>
              スレッドは <code class="literal">GROUP BY</code> を満たすためにソートを実行しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109929776"></a> <a class="indexterm" name="idm139979109927616"></a> <code class="literal">Sorting for order</code>
            </p><p>
              スレッドは <code class="literal">ORDER BY</code> を満たすためにソートを実行しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109922912"></a> <a class="indexterm" name="idm139979109920752"></a> <code class="literal">Sorting index</code>
            </p><p>
              スレッドは <code class="literal">MyISAM</code> テーブルの最適化操作中に、より効率的なアクセスのためにインデックスページをソートしています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109915888"></a> <a class="indexterm" name="idm139979109913728"></a> <code class="literal">Sorting result</code>
            </p><p>
              <code class="literal">SELECT</code> ステートメントの場合、これは <code class="literal">Creating sort index</code> と似ていますが、非一時テーブルに対するものです。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109908000"></a> <a class="indexterm" name="idm139979109905840"></a> <code class="literal">statistics</code>
            </p><p>
              サーバーはクエリー実行プランを開発するための統計を計算しています。スレッドが長期間この状態にある場合、サーバーはディスクに依存してほかの作業を実行している可能性があります。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109901472"></a> <a class="indexterm" name="idm139979109900016"></a> <a class="indexterm" name="idm139979109897984"></a> <a class="indexterm" name="idm139979109895936"></a> <code class="literal">System lock</code>
            </p><p>
              スレッドは、テーブルの内部または外部システムロックをリクエストしようとしているか待機しています。この状態が外部ロックへのリクエストによって発生しており、同じ <code class="literal">MyISAM</code> テーブルにアクセスしている複数の <span class="command"><strong>mysqld</strong></span> サーバーを使用していない場合、<code class="option">--skip-external-locking</code> オプションによって外部システムロックを無効にできます。ただし、外部ロックはデフォルトで無効になるため、このオプションには効果がない可能性があります。<code class="literal">SHOW PROFILE</code> の場合、この状態はスレッドがロックをリクエストしている (待機しているのではなく) ことを意味します。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109887088"></a> <a class="indexterm" name="idm139979109884928"></a> <code class="literal">update</code>
            </p><p>
              スレッドはテーブルの更新を開始する準備ができています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109880912"></a> <a class="indexterm" name="idm139979109878752"></a> <code class="literal">Updating</code>
            </p><p>
              スレッドは更新する行を探していて、それらを更新しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109874736"></a> <a class="indexterm" name="idm139979109872576"></a> <code class="literal">updating main table</code>
            </p><p>
              サーバーは複数テーブル更新の最初の部分を実行しています。最初のテーブルのみを更新しており、別の (参照) テーブルの更新に利用されるカラムとオフセットを保存しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109868240"></a> <a class="indexterm" name="idm139979109866048"></a> <code class="literal">updating reference tables</code>
            </p><p>
              サーバーは複数テーブル更新の 2 番目の部分を実行しており、ほかのテーブルから一致した行を更新しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109861840"></a> <a class="indexterm" name="idm139979109859680"></a> <code class="literal">User lock</code>
            </p><p>
              スレッドは <code class="literal">GET_LOCK()</code> 呼び出しによってリクエストされたアドバイザリロックを、リクエストしようとしているか待機しています。<code class="literal">SHOW PROFILE</code> の場合、この状態はスレッドがロックをリクエストしている (待機しているのではなく) ことを意味します。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109853248"></a> <a class="indexterm" name="idm139979109851088"></a> <code class="literal">User sleep</code>
            </p><p>
              スレッドは <code class="literal">SLEEP()</code> 呼び出しを呼び出しました。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109846144"></a> <a class="indexterm" name="idm139979109843984"></a> <code class="literal">Waiting for commit lock</code>
            </p><p>
              <code class="literal">FLUSH TABLES WITH READ LOCK</code> はコミットロックを待機しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109838816"></a> <a class="indexterm" name="idm139979109836624"></a> <code class="literal">Waiting for global read lock</code>
            </p><p>
              <code class="literal">FLUSH TABLES WITH READ LOCK</code> はグローバル読み取りロックまたはグローバル <code class="literal">read_only</code> システム変数が設定されるのを待機しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109830272"></a> <a class="indexterm" name="idm139979109828112"></a> <a class="indexterm" name="idm139979109826176"></a> <a class="indexterm" name="idm139979109824016"></a> <code class="literal">Waiting for tables</code>, <code class="literal">Waiting for table flush</code>
            </p><p>
              スレッドは、テーブルの基盤となる構造が変更され、その新しい構造を得るためにテーブルを再度オープンする必要があるという通知を受け取りました。ただし、テーブルを再度オープンするには、ほかのすべてのスレッドが問題のテーブルをクローズするまで待機する必要があります。
            </p><p>
              この通知は、別のスレッドが <code class="literal">FLUSH TABLES</code> か、問題のテーブルに次のステートメントのいずれかを使用した場合に、この通知が行われます: <code class="literal">FLUSH TABLES <em class="replaceable"><code>tbl_name</code></em></code>、<code class="literal">ALTER TABLE</code>、<code class="literal">RENAME TABLE</code>、<code class="literal">REPAIR TABLE</code>、<code class="literal">ANALYZE TABLE</code>、または <code class="literal">OPTIMIZE TABLE</code>。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109810912"></a> <a class="indexterm" name="idm139979109808720"></a> <a class="indexterm" name="idm139979109806640"></a> <a class="indexterm" name="idm139979109804672"></a> <a class="indexterm" name="idm139979109802480"></a> <a class="indexterm" name="idm139979109800512"></a> <a class="indexterm" name="idm139979109798288"></a> <a class="indexterm" name="idm139979109796288"></a> <a class="indexterm" name="idm139979109794064"></a> <a class="indexterm" name="idm139979109792064"></a> <a class="indexterm" name="idm139979109789872"></a> <a class="indexterm" name="idm139979109787904"></a> <a class="indexterm" name="idm139979109785712"></a> <a class="indexterm" name="idm139979109783744"></a> <a class="indexterm" name="idm139979109781552"></a> <code class="literal">Waiting for <em class="replaceable"><code>lock_type</code></em> lock</code>
            </p><p>
              サーバーはロックの獲得を待機しています。ここで <em class="replaceable"><code>lock_type</code></em> はロックの種類を示しています。
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  <code class="literal">Waiting for event metadata lock</code>
                </p></li><li class="listitem"><p>
                  <code class="literal">Waiting for global read lock</code>
                </p></li><li class="listitem"><p>
                  <code class="literal">Waiting for schema metadata lock</code>
                </p></li><li class="listitem"><p>
                  <code class="literal">Waiting for stored function metadata lock</code>
                </p></li><li class="listitem"><p>
                  <code class="literal">Waiting for stored procedure metadata lock</code>
                </p></li><li class="listitem"><p>
                  <code class="literal">Waiting for table level lock</code>
                </p></li><li class="listitem"><p>
                  <code class="literal">Waiting for table metadata lock</code>
                </p></li><li class="listitem"><p>
                  <code class="literal">Waiting for trigger metadata lock</code>
                </p></li></ul></div></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109764368"></a> <a class="indexterm" name="idm139979109762208"></a> <code class="literal">Waiting on cond</code>
            </p><p>
              スレッドが条件が true になるのを待機している一般的な状態です。特定の状態情報は使用できません。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109758080"></a> <a class="indexterm" name="idm139979109755920"></a> <code class="literal">Writing to net</code>
            </p><p>
              サーバーはネットワークにパケットを書き込んでいます。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="delayed-insert-thread-states"></a>8.12.5.3 遅延挿入スレッドの状態</h4></div></div></div><a class="indexterm" name="idm139979109750976"></a><a class="indexterm" name="idm139979109748800"></a><p>
          これらのスレッドの状態は、<code class="literal">DELAYED</code> 挿入の処理に関連付けられています (<a class="xref" href="sql-syntax.html#insert-delayed" title="13.2.5.2 INSERT DELAYED 構文">セクション13.2.5.2「INSERT DELAYED 構文」</a>を参照してください)。一部の状態は、クライアントから <code class="literal">INSERT DELAYED</code> ステートメントを処理する接続スレッドに関連付けられています。ほかの状態は、行を挿入する遅延挿入ハンドラスレッドに関連付けられています。<code class="literal">INSERT DELAYED</code> ステートメントが発行された各テーブルに、遅延挿入ハンドラスレッドが存在します。
        </p><p>
          クライアントから <code class="literal">INSERT DELAYED</code> ステートメントを処理する接続スレッドに関連付けられているスレッド:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <a class="indexterm" name="idm139979109739776"></a> <a class="indexterm" name="idm139979109737616"></a> <code class="literal">allocating local table</code>
            </p><p>
              スレッドは遅延挿入ハンドラスレッドに行を提供する準備をしています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109733568"></a> <a class="indexterm" name="idm139979109731376"></a> <code class="literal">Creating delayed handler</code>
            </p><p>
              スレッドは <code class="literal">DELAYED</code> 挿入のハンドラを作成しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109726640"></a> <a class="indexterm" name="idm139979109724480"></a> <code class="literal">got handler lock</code>
            </p><p>
              これは、<code class="literal">allocating local table</code> 状態の前、かつ <code class="literal">waiting for handler lock</code> 状態のあとの、接続スレッドが遅延挿入ハンドラスレッドにアクセスするときに発生します。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109718880"></a> <a class="indexterm" name="idm139979109716720"></a> <code class="literal">got old table</code>
            </p><p>
              これは <code class="literal">waiting for handler open</code> 状態のあとに発生します。遅延挿入ハンドラスレッドは、初期化フェーズを終了したことを通知しました。これには、遅延挿入のためのテーブルのオープンが含まれます。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109711664"></a> <a class="indexterm" name="idm139979109709504"></a> <code class="literal">storing row into queue</code>
            </p><p>
              スレッドは、遅延挿入ハンドラスレッドで挿入する必要のある行のリストに、新しい行を追加しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109705360"></a> <a class="indexterm" name="idm139979109703184"></a> <code class="literal">waiting for delay_list</code>
            </p><p>
              これは、初期化フェーズ中、スレッドがテーブルの遅延挿入ハンドラスレッドを見つけようとしているときで、遅延挿入スレッドのリストにアクセスを試みる前に発生します。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109698848"></a> <a class="indexterm" name="idm139979109696656"></a> <code class="literal">waiting for handler insert</code>
            </p><p>
              <code class="literal">INSERT DELAYED</code> ハンドラはすべての未解決の挿入を処理し、新しい挿入を待機しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109691616"></a> <a class="indexterm" name="idm139979109689424"></a> <code class="literal">waiting for handler lock</code>
            </p><p>
              これは、接続スレッドが遅延挿入ハンドラスレッドへのアクセスを待機しているときの <code class="literal">allocating local table</code> 状態の前に発生します。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109684512"></a> <a class="indexterm" name="idm139979109682320"></a> <code class="literal">waiting for handler open</code>
            </p><p>
              これは <code class="literal">Creating delayed handler</code> 状態のあとで <code class="literal">got old table</code> 状態の前に発生します。遅延挿入ハンドラスレッドが開始したばかりで、接続スレッドはそれが初期化されるのを待機しています。
            </p></li></ul></div><p>
          行を挿入する遅延挿入ハンドラスレッドに関連付けられている状態:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <a class="indexterm" name="idm139979109675568"></a> <a class="indexterm" name="idm139979109673408"></a> <code class="literal">insert</code>
            </p><p>
              テーブルに行を挿入する直前に発生する状態。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109669440"></a> <a class="indexterm" name="idm139979109667280"></a> <code class="literal">reschedule</code>
            </p><p>
              いくつかの行の挿入後、遅延挿入スレッドはスリープし、ほかのスレッドが作業を実行できるようにします。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109663136"></a> <a class="indexterm" name="idm139979109660976"></a> <code class="literal">upgrading lock</code>
            </p><p>
              遅延挿入ハンドラは行を挿入するために、テーブルのロックを取得しようとしています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109656880"></a> <a class="indexterm" name="idm139979109654720"></a> <code class="literal">Waiting for INSERT</code>
            </p><p>
              遅延挿入ハンドラは、接続スレッドがキューに行を追加するのを待機しています (<code class="literal">storing row into queue</code> を参照してください)。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="query-cache-thread-states"></a>8.12.5.4 クエリーキャッシュスレッドの状態</h4></div></div></div><a class="indexterm" name="idm139979109648928"></a><a class="indexterm" name="idm139979109646784"></a><p>
          これらのスレッドの状態はクエリーキャッシュに関連付けられています (<a class="xref" href="optimization.html#query-cache" title="8.9.3 MySQL クエリーキャッシュ">セクション8.9.3「MySQL クエリーキャッシュ」</a>を参照してください)。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <a class="indexterm" name="idm139979109642688"></a> <a class="indexterm" name="idm139979109640528"></a> <code class="literal">checking privileges on cached query</code>
            </p><p>
              サーバーはユーザーがキャッシュされたクエリー結果にアクセスする権限を持っているかどうかをチェックしています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109636304"></a> <a class="indexterm" name="idm139979109634112"></a> <code class="literal">checking query cache for query</code>
            </p><p>
              サーバーは、現在のクエリーがクエリーキャッシュに存在するかどうかをチェックしています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109629952"></a> <a class="indexterm" name="idm139979109627760"></a> <code class="literal">invalidating query cache entries</code>
            </p><p>
              基盤となるテーブルが変更されているため、クエリーキャッシュエントリは無効とマークされています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109623584"></a> <a class="indexterm" name="idm139979109621392"></a> <code class="literal">sending cached result to client</code>
            </p><p>
              サーバーはクエリーキャッシュからクエリーの結果を取得し、それをクライアントに送信しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109617216"></a> <a class="indexterm" name="idm139979109615024"></a> <code class="literal">storing result in query cache</code>
            </p><p>
              サーバーはクエリーの結果をクエリーキャッシュに保存しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109610944"></a> <a class="indexterm" name="idm139979109608752"></a> <code class="literal">Waiting for query cache lock</code>
            </p><p>
              この状態は、セッションがクエリーキャッシュのロックを取得するのを待機している間に発生します。これは、クエリーキャッシュを無効にする <code class="literal">INSERT</code> や <code class="literal">DELETE</code>、キャッシュされたエントリを検索する <code class="literal">SELECT</code>、<code class="literal">RESET QUERY CACHE</code> などの一部のクエリーキャッシュ操作を実行するために必要なステートメントで発生する可能性があります。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="master-thread-states"></a>8.12.5.5 レプリケーションマスタースレッドの状態</h4></div></div></div><a class="indexterm" name="idm139979109599056"></a><a class="indexterm" name="idm139979109596896"></a><p>
          次のリストに、マスターの <code class="literal">Binlog Dump</code> スレッドの <code class="literal">State</code> カラムに示される可能性があるもっとも一般的な状態を示します。マスターサーバーで、<code class="literal">Binlog Dump</code> スレッドが見られない場合、これは、レプリケーションが実行中でない、つまりスレーブが現在接続されていないことを意味します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <a class="indexterm" name="idm139979109590896"></a> <a class="indexterm" name="idm139979109588704"></a> <code class="literal">Sending binlog event to slave</code>
            </p><p>
              バイナリログは<span class="emphasis"><em>イベント</em></span>で構成され、そこではイベントが通常更新と何らかのその他の情報が追加されたものになります。スレッドはバイナリログからイベントを読み取り、現在それをスレーブに送信しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109584080"></a> <a class="indexterm" name="idm139979109581856"></a> <code class="literal">Finished reading one binlog; switching to next binlog</code>
            </p><p>
              スレッドはバイナリログファイルの読み取りを完了し、スレーブに送信するために次のファイルをオープンしています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109577584"></a> <a class="indexterm" name="idm139979109575328"></a> <code class="literal">Master has sent all binlog to slave; waiting for binlog to be updated</code>
            </p><p>
              スレッドはバイナリログからすべての未処理の更新を読み取り、それらをスレーブに送信しました。スレッドは現在アイドルで、マスターで行われている新しい更新の結果として、新しいイベントがバイナリログに表示されるのを待機しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109570768"></a> <a class="indexterm" name="idm139979109568576"></a> <code class="literal">Waiting to finalize termination</code>
            </p><p>
              スレッド停止中に発生するきわめて短い状態。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="slave-io-thread-states"></a>8.12.5.6 レプリケーションスレーブの I/O スレッド状態</h4></div></div></div><a class="indexterm" name="idm139979109563584"></a><a class="indexterm" name="idm139979109561424"></a><p>
          次のリストに、スレーブサーバーの I/O スレッドの <code class="literal">State</code> カラムに表示されるもっとも一般的な状態を示します。この状態は、<code class="literal">SHOW SLAVE STATUS</code> によって表示される <code class="literal">Slave_IO_State</code> カラムにも表示されるため、そのステートメントを使用して、何が起こっているかを十分に把握できます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <a class="indexterm" name="idm139979109555184"></a> <a class="indexterm" name="idm139979109552992"></a> <code class="literal">Waiting for master update</code>
            </p><p>
              <code class="literal">Connecting to master</code> の前の初期状態。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109548384"></a> <a class="indexterm" name="idm139979109546224"></a> <code class="literal">Connecting to master</code>
            </p><p>
              スレッドはマスターへの接続を試みています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109542256"></a> <a class="indexterm" name="idm139979109540096"></a> <code class="literal">Checking master version</code>
            </p><p>
              マスターへの接続が確立されたあとに一時的に発生する状態。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109536080"></a> <a class="indexterm" name="idm139979109533888"></a> <code class="literal">Registering slave on master</code>
            </p><p>
              マスターへの接続が確立されたあとに一時的に発生する状態。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109529824"></a> <a class="indexterm" name="idm139979109527664"></a> <code class="literal">Requesting binlog dump</code>
            </p><p>
              マスターへの接続が確立されたあとに一時的に発生する状態。スレッドは、マスターにそのバイナリログの内容のリクエストを送信し、リクエストしたバイナリログファイル名と位置から開始します。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109523280"></a> <a class="indexterm" name="idm139979109521056"></a> <code class="literal">Waiting to reconnect after a failed binlog dump request</code>
            </p><p>
              切断のため、バイナリログダンプリクエストに失敗した場合、スレッドはスリープ中にこの状態になり、定期的に再接続を試みます。再試行の間隔は、<code class="literal">CHANGE MASTER TO</code> ステートメントを使用して指定できます。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109515616"></a> <a class="indexterm" name="idm139979109513392"></a> <code class="literal">Reconnecting after a failed binlog dump request</code>
            </p><p>
              スレッドはマスターへの再接続を試みています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109509312"></a> <a class="indexterm" name="idm139979109507120"></a> <code class="literal">Waiting for master to send event</code>
            </p><p>
              スレッドはマスターに接続し、バイナリログイベントの到着を待機しています。マスターがアイドル状態の場合、これは長時間続く可能性があります。待機が <code class="literal">slave_net_timeout</code> 秒継続した場合、タイムアウトになります。その時点で、スレッドは接続が切断されているとみなし、再接続を試みます。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109501488"></a> <a class="indexterm" name="idm139979109499296"></a> <code class="literal">Queueing master event to the relay log</code>
            </p><p>
              スレッドはイベントを読み取っており、SQL スレッドがそれを処理できるように、それをリレーログにコピーしています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109495072"></a> <a class="indexterm" name="idm139979109492848"></a> <code class="literal">Waiting to reconnect after a failed master event read</code>
            </p><p>
              切断のため、読み取り中にエラーが発生しました。スレッドは <code class="literal">CHANGE MASTER TO</code> ステートメントに設定された秒数 (デフォルト 60) の間スリープしてから、再接続を試みます。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109487488"></a> <a class="indexterm" name="idm139979109485264"></a> <code class="literal">Reconnecting after a failed master event read</code>
            </p><p>
              スレッドはマスターへの再接続を試みています。ふたたび接続が確立されると、状態は <code class="literal">Waiting for master to send event</code> になります。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109480320"></a> <a class="indexterm" name="idm139979109478064"></a> <code class="literal">Waiting for the slave SQL thread to free enough relay log space</code>
            </p><p>
              0 以外の <code class="literal">relay_log_space_limit</code> 値を使用しており、リレーログの組み合わせたサイズがこの値を超えるまで拡大しています。I/O スレッドは、一部のリレーログファイルを削除できるように、リレーログ内容を処理することによって SQL スレッドが十分な領域を解放するまで、待機しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109472496"></a> <a class="indexterm" name="idm139979109470304"></a> <code class="literal">Waiting for slave mutex on exit</code>
            </p><p>
              スレッドの停止中に一時的に発生する状態。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="slave-sql-thread-states"></a>8.12.5.7 レプリケーションスレーブ SQL スレッドの状態</h4></div></div></div><a class="indexterm" name="idm139979109465312"></a><a class="indexterm" name="idm139979109463152"></a><p>
          次のリストに、スレーブサーバー SQL スレッドの <code class="literal">State</code> カラムに表示される可能性のあるもっとも一般的な状態を示します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <a class="indexterm" name="idm139979109458944"></a> <a class="indexterm" name="idm139979109456752"></a> <code class="literal">Waiting for the next event in relay log</code>
            </p><p>
              <code class="literal">Reading event from the relay log</code> の前の初期状態です。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109452112"></a> <a class="indexterm" name="idm139979109449920"></a> <code class="literal">Reading event from the relay log</code>
            </p><p>
              スレッドはイベントを処理できるように、イベントをリレーログから読み取りました。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109445792"></a> <a class="indexterm" name="idm139979109443536"></a> <code class="literal">Making temporary file (append) before replaying LOAD DATA INFILE</code>
            </p><p>
              スレッドは <code class="literal">LOAD DATA INFILE</code> ステートメントを実行しており、スレーブが行を読み取る、データを格納している一時ファイルにデータを追加しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109437920"></a> <a class="indexterm" name="idm139979109435664"></a> <code class="literal">Making temporary file (create) before replaying LOAD DATA INFILE</code>
            </p><p>
              スレッドは <code class="literal">LOAD DATA INFILE</code> ステートメントを実行しており、スレーブが行を読み取る、データを格納している一時ファイルを作成しています。この状態は、元の <code class="literal">LOAD DATA INFILE</code> ステートメントが、バージョン 5.0.3 より前の MySQL のバージョンを実行しているマスターによって記録された場合にのみ検出される可能性があります。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109428368"></a> <a class="indexterm" name="idm139979109426144"></a> <code class="literal">Slave has read all relay log; waiting for more updates</code>
            </p><p>
              スレッドはリレーログファイル内のすべてのイベントを処理しており、現在 I/O スレッドが新しいイベントをリレーログに書き込むのを待機しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109421792"></a> <a class="indexterm" name="idm139979109419600"></a> <code class="literal">Waiting for slave mutex on exit</code>
            </p><p>
              スレッド停止中に発生するきわめて短い状態。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109415584"></a> <a class="indexterm" name="idm139979109413328"></a> <code class="literal">Waiting until MASTER_DELAY seconds after master executed event</code>
            </p><p>
              SQL スレッドはイベントを読み取りましたが、スレーブの遅延の満了を待機しています。この遅延は、<code class="literal">CHANGE MASTER TO</code> の <code class="literal">MASTER_DELAY</code> オプションによって設定されます。
            </p></li></ul></div><p>
          I/O スレッドの <code class="literal">Info</code> カラムには、ステートメントのテキストも表示されることがあります。これは、スレッドがリレーログからイベントを読み取り、それからステートメントを抽出して、それを実行している可能性があることを示しています。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="slave-connection-thread-states"></a>8.12.5.8 レプリケーションスレーブ接続スレッドの状態</h4></div></div></div><a class="indexterm" name="idm139979109404528"></a><a class="indexterm" name="idm139979109402384"></a><p>
          これらのスレッドの状態はレプリケーションスレーブで発生しますが、I/O スレッドや SQL スレッドではなく、接続スレッドに関連付けられています。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <a class="indexterm" name="idm139979109397936"></a> <a class="indexterm" name="idm139979109395776"></a> <code class="literal">Changing master</code>
            </p><p>
              スレッドは <code class="literal">CHANGE MASTER TO</code> ステートメントを処理しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109390816"></a> <a class="indexterm" name="idm139979109388656"></a> <code class="literal">Killing slave</code>
            </p><p>
              スレッドは <code class="literal">STOP SLAVE</code> ステートメントを処理しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109383968"></a> <a class="indexterm" name="idm139979109381776"></a> <code class="literal">Opening master dump table</code>
            </p><p>
              この状態は <code class="literal">Creating table from master dump</code> のあとに発生します。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109377056"></a> <a class="indexterm" name="idm139979109374864"></a> <code class="literal">Reading master dump table data</code>
            </p><p>
              この状態は <code class="literal">Opening master dump table</code> のあとに発生します。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109370144"></a> <a class="indexterm" name="idm139979109367920"></a> <code class="literal">Rebuilding the index on master dump table</code>
            </p><p>
              この状態は <code class="literal">Reading master dump table data</code> のあとに発生します。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-cluster-thread-states"></a>8.12.5.9 MySQL Cluster スレッドの状態</h4></div></div></div><a class="indexterm" name="idm139979109362192"></a><a class="indexterm" name="idm139979109360192"></a><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <a class="indexterm" name="idm139979109356560"></a> <a class="indexterm" name="idm139979109354368"></a> <code class="literal">Committing events to binlog</code>
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109350928"></a> <a class="indexterm" name="idm139979109348736"></a> <code class="literal">Opening mysql.ndb_apply_status</code>
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109345296"></a> <a class="indexterm" name="idm139979109343136"></a> <code class="literal">Processing events</code>
            </p><p>
              スレッドはバイナリロギングのイベントを処理しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109339120"></a> <a class="indexterm" name="idm139979109336928"></a> <code class="literal">Processing events from schema table</code>
            </p><p>
              スレッドはスキーマレプリケーションの作業を実行しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109332864"></a> <a class="indexterm" name="idm139979109330704"></a> <code class="literal">Shutting down</code>
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109327312"></a> <a class="indexterm" name="idm139979109325088"></a> <code class="literal">Syncing ndb table schema operation and binlog</code>
            </p><p>
              これは、NDB のスキーマ操作の正しいバイナリログを維持するために使用されます。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109320912"></a> <a class="indexterm" name="idm139979109318720"></a> <code class="literal">Waiting for event from ndbcluster</code>
            </p><p>
              サーバーは MySQL クラスタ内の SQL ノードとして機能しており、クラスタ管理ノードに接続されています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109314544"></a> <a class="indexterm" name="idm139979109312352"></a> <code class="literal">Waiting for first event from ndbcluster</code>
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109308912"></a> <a class="indexterm" name="idm139979109306656"></a> <code class="literal">Waiting for ndbcluster binlog update to reach current position</code>
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109303120"></a> <a class="indexterm" name="idm139979109300928"></a> <code class="literal">Waiting for ndbcluster to start</code>
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109297488"></a> <a class="indexterm" name="idm139979109295296"></a> <code class="literal">Waiting for schema epoch</code>
            </p><p>
              スレッドはスキーマエポック (つまり、グローバルチェックポイント) を待機しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109291152"></a> <a class="indexterm" name="idm139979109288896"></a> <code class="literal">Waiting for allowed to take ndbcluster global schema lock</code>
            </p><p>
              スレッドはグローバルスキーマロックを取得する権限を待機しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109284704"></a> <a class="indexterm" name="idm139979109282480"></a> <code class="literal">Waiting for ndbcluster global schema lock</code>
            </p><p>
              スレッドは、別のスレッドによって保持されているグローバルスキーマロックが解放されるのを待機しています。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="event-scheduler-thread-states"></a>8.12.5.10 イベントスケジューラスレッドの状態</h4></div></div></div><a class="indexterm" name="idm139979109277216"></a><a class="indexterm" name="idm139979109275072"></a><p>
          これらの状態は、イベントスケジューラスレッド、スケジュールされたイベントを実行するために作成されるスレッド、またはスケジューラを終了するスレッドで発生します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <a class="indexterm" name="idm139979109271312"></a> <a class="indexterm" name="idm139979109269264"></a> <code class="literal">Clearing</code>
            </p><p>
              スケジューラスレッドまたはイベントを実行していたスレッドは終了中で、まもなく終了します。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109265152"></a> <a class="indexterm" name="idm139979109262992"></a> <code class="literal">Initialized</code>
            </p><p>
              スケジューラスレッドまたはイベントを実行するスレッドが初期化されました。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109258928"></a> <a class="indexterm" name="idm139979109256736"></a> <code class="literal">Waiting for next activation</code>
            </p><p>
              スケジューラには空でないイベントキューがありますが、次のアクティブ化はあとで行われます。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109252576"></a> <a class="indexterm" name="idm139979109250384"></a> <code class="literal">Waiting for scheduler to stop</code>
            </p><p>
              スレッドは <code class="literal">SET GLOBAL event_scheduler=OFF</code> を発行し、スケジューラが停止するのを待機しています。
            </p></li><li class="listitem"><p>
              <a class="indexterm" name="idm139979109245568"></a> <a class="indexterm" name="idm139979109243408"></a> <code class="literal">Waiting on empty queue</code>
            </p><p>
              スケジューラのイベントキューは空で、スリープ中です。
            </p></li></ul></div></div></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="backup-and-recovery.html">前</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="language-structure.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第 7 章 バックアップとリカバリ </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 第 9 章 言語構造</td></tr></table></div><div class="copyright-footer"></div></body></html>
