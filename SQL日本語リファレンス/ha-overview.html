<html lang="ja"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>第 16 章 高可用性と拡張性</title><link rel="stylesheet" type="text/css" href="mvl.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="MySQL 5.6 リファレンスマニュアル"><link rel="up" href="index.html" title="MySQL 5.6 リファレンスマニュアル"><link rel="prev" href="storage-engines.html" title="第 15 章 代替ストレージエンジン"><link rel="next" href="replication.html" title="第 17 章 レプリケーション">
<script language="javascript" type="text/javascript">
  function addOnload(theFunc)
  {
    var previous = window.onload;
    if (typeof window.onload != 'function')
    {
      window.onload = theFunc;
    }
    else
    {
      window.onload = function()
      {
        previous();
        theFunc();
      }
    }
  }

  addOnload(function()
  {
    var base = new Date(1442918127*1000);
    var now = new Date();
    var diff = ((now-base)/1000)/(24*3600);

    if (diff > 90) {
      var nodes = document.getElementsByClassName('titlepage');
      nodes[0].innerHTML = '<p style="border: 5px #ff0000 solid; padding: 5px; margin 5px">' +
        'This copy of the manual is more than 90 days old. We encourage you to download a ' +
        'new version from <a href="http://dev.mysql.com">dev.mysql.com/doc</a>.</p>' + nodes[0].innerHTML;
    }
  });
</script>
<noscript></noscript>
</head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第 16 章 高可用性と拡張性</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="storage-engines.html">前</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="replication.html">次へ</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="ha-overview"></a>第 16 章 高可用性と拡張性</h1></div></div></div><div class="toc"><p><b>目次</b></p><dl class="toc"><dt><span class="section"><a href="ha-overview.html#ha-ovm-template">16.1 Oracle VM Template for MySQL Enterprise</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-drbd">16.2 DRBD/Pacemaker/Corosync/Oracle Linux を使用した MySQL の概要</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-wfc">16.3 Windows フェイルオーバークラスタリングを使用した MySQL の概要</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-vm">16.4 Amazon EC2 インスタンスでの MySQL の使用</a></span></dt><dd><dl><dt><span class="section"><a href="ha-overview.html#ha-vm-aws-setup">16.4.1 EC2 AMI での MySQL のセットアップ</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-vm-aws-instance">16.4.2 EC2 インスタンスの制限</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-vm-aws-deploy">16.4.3 EC2 を使用した MySQL データベースの配備</a></span></dt></dl></dd><dt><span class="section"><a href="ha-overview.html#ha-zfs-replication">16.5 ZFS レプリケーションの使用</a></span></dt><dd><dl><dt><span class="section"><a href="ha-overview.html#ha-zfs-config">16.5.1 ZFS を使用したファイルシステムレプリケーション</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-zfs-mysql">16.5.2 ZFS レプリケーションのための MySQL の構成</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-zfs-mysql-recovery">16.5.3 ZFS での MySQL リカバリーの扱い</a></span></dt></dl></dd><dt><span class="section"><a href="ha-overview.html#ha-memcached">16.6 MySQL と <span class="command"><strong>memcached</strong></span> の併用</a></span></dt><dd><dl><dt><span class="section"><a href="ha-overview.html#ha-memcached-install">16.6.1 <span class="command"><strong>memcached</strong></span> のインストール</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-memcached-using">16.6.2 <span class="command"><strong>memcached</strong></span> の使用</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-memcached-interfaces">16.6.3 <span class="command"><strong>memcached</strong></span> アプリケーションの開発</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-memcached-stats">16.6.4 <span class="command"><strong>memcached</strong></span> の統計の取得</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-memcached-faq">16.6.5 <span class="command"><strong>memcached</strong></span> の FAQ</a></span></dt></dl></dd></dl></div><p>
    データは、今日の Web、モバイル、ソーシャル、エンタープライズ、およびクラウドアプリケーションの通貨です。データが常に利用できることを確保することは、いずれの組織でも一番の優先事項です。分単位のダウンタイムでも、収益と評価が大きく損なわれる可能性があります。
  </p><p>
    高可用性 (HA) を実現するための<span class="quote">「<span class="quote">万能な</span>」</span>方法はありません。固有のアプリケーション属性、ビジネス要件、運用性能、およびレガシーインフラストラクチャーはすべて、HA テクノロジーの選択に影響を与える可能性があります。そして、HA を実現する上でテクノロジーは 1 つの要素でしかありません。テクノロジー自身と同じくらい人とプロセスが重要です。
  </p><p>
    MySQL は可用性と拡張性を求める多くのアプリケーションに配備されています。<span class="bold"><strong>可用性</strong></span>とは、ホストでの障害 (MySQL、オペレーティングシステム、ハードウェア、保守作業での障害を含む、対処しないとダウンタイムが発生する可能性がある) に対処し、必要に応じてリカバリさせる能力のことです。<a class="link" href="glossary.html#glos_scalability" title="スケーラビリティー">拡張性</a>とは、データベース、およびアプリケーションクエリーの負荷の両方を複数の MySQL サーバーに分散させる能力のことです。
  </p><p>
    アプリケーションごとに運用および可用性要件が異なるため、MySQL は認定およびサポートされるソリューションを幅広く提供し、サービスレベル要件を満たす適切なレベルの高可用性 (HA) と拡張性を実現しています。このようなソリューションは、レプリケーションから、仮想化、地理的冗長性、99.999% の稼働時間を実現するマルチデータセンターソリューションまで用意しています。
  </p><p>
    アプリケーションのために最適な高可用性ソリューションを選択することは、主に次のことに依存します。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        必要な可用性レベル。
      </p></li><li class="listitem"><p>
        配備されるアプリケーションのタイプ。
      </p></li><li class="listitem"><p>
        独自の環境で受け入れられるベストプラクティス。
      </p></li></ul></div><p>
    MySQL がサポートするプライマリソリューションは次のとおりです。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        MySQL レプリケーション。詳細: <a class="xref" href="replication.html" title="第 17 章 レプリケーション">第17章「<i>レプリケーション</i>」</a>。
      </p></li><li class="listitem"><p>
        MySQL Cluster。詳細: <a class="xref" href="mysql-cluster.html" title="第 18 章 MySQL Cluster NDB 7.3 および MySQL Cluster NDB 7.4">第18章「<i>MySQL Cluster NDB 7.3 および MySQL Cluster NDB 7.4</i>」</a>。
      </p></li><li class="listitem"><p>
        Oracle VM Template for MySQL。詳細: <a class="xref" href="ha-overview.html#ha-ovm-template" title="16.1 Oracle VM Template for MySQL Enterprise">セクション16.1「Oracle VM Template for MySQL Enterprise」</a>。
      </p></li><li class="listitem"><p>
        DRBD、Corosync、Pacemaker を実装する MySQL。詳細: <a class="xref" href="ha-overview.html#ha-drbd" title="16.2 DRBD/Pacemaker/Corosync/Oracle Linux を使用した MySQL の概要">セクション16.2「DRBD/Pacemaker/Corosync/Oracle Linux を使用した MySQL の概要」</a>。
      </p></li><li class="listitem"><p>
        Windows Failover Clustering を実装する MySQL。詳細: <a class="xref" href="ha-overview.html#ha-wfc" title="16.3 Windows フェイルオーバークラスタリングを使用した MySQL の概要">セクション16.3「Windows フェイルオーバークラスタリングを使用した MySQL の概要」</a>。
      </p></li><li class="listitem"><p>
        Solaris Cluster を実装する MySQL。<a class="ulink" href="http://www.oracle.com/technetwork/server-storage/solaris-cluster/overview/index.html" target="_top">Solaris Cluster の理解を深めてください。</a>
      </p></li></ul></div><p>
    追加オプションをサードパーティーソリューションで利用できます。
  </p><p>
    高可用性データベースサービスの実現に使用される各アーキテクチャーは、それが提供する稼働時間のレベルによって区別されます。これらのアーキテクチャーは、次の 3 つの主なカテゴリにグループ分けできます。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        データレプリケーション。
      </p></li><li class="listitem"><p>
        クラスター化および仮想化システム。
      </p></li><li class="listitem"><p>
        シェアードナッシング、地理的にレプリケートされたクラスタ。
      </p></li></ul></div><p>
    次の図で示すように、これらの各アーキテクチャーは段階的に稼働時間レベルが高くなるため、それらによってコストと複雑さのレベルが潜在的に大きくなる可能性があり、これらのバランスを取る必要があります。単に高可用性アーキテクチャーを配備するだけでは、実際に HA が実現されることの保証にはなりません。実際、シェアードナッシングクラスタの実装と保守が不十分であると、単純なデータレプリケーションソリューションよりも、可用性レベルがあっさりと低下する可能性があります。
  </p><div class="figure"><a name="figure_ha-cost-vs-nines"></a><p class="title"><b>図 16.1 トレードオフ: コストと複雑さ vs 可用性</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/ha-cost-vs-nines.png" width="555" height="467" alt="稼働時間パーセントの “9” の数が増えていくと、基本レプリケーションから、クラスタ化および仮想化された構成、地理的領域をまたがってレプリケートされたシェアードナッシングクラスタに進むにつれてコストと複雑さも増えていきます。組織の種類が異なると、“9” の数が異なる可用性が必要になります (インターネットサービスプロバイダや主力企業には 3 つの 9、オンラインサービスには 4 つの 9、電子商取引、通信、および軍事アプリケーションには 5 つの 9)。"></div></div></div><br class="figure-break"><p>
    次の表では、さまざまな MySQL ソリューションの HA および拡張性機能を比較しています。
  </p><div class="table"><a name="ha-availability-comparison"></a><p class="title"><b>表 16.1 MySQL HA ソリューションの機能比較</b></p><div class="table-contents"><table summary="MySQL HA ソリューションの機能比較" border="1"><colgroup><col><col><col><col><col></colgroup><thead><tr><th scope="col">要件</th><th scope="col">MySQL レプリケーション</th><th scope="col">DRBD</th><th scope="col">Oracle VM テンプレート</th><th scope="col">MySQL Cluster</th></tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>可用性</strong></span></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td scope="row">プラットフォームサポート</td><td>MySQL Server がサポートするすべて (<a class="ulink" href="http://www.mysql.com/support/supportedplatforms/database.html" target="_top">http://www.mysql.com/support/supportedplatforms/database.html</a>)</td><td>Linux</td><td>Oracle Linux</td><td>MySQL Cluster がサポートするすべて (<a class="ulink" href="http://www.mysql.com/support/supportedplatforms/cluster.html" target="_top">http://www.mysql.com/support/supportedplatforms/cluster.html</a>)</td></tr><tr><td scope="row">IP フェイルオーバーの自動化</td><td>いいえ</td><td>はい</td><td>はい</td><td>コネクタおよび構成に依存</td></tr><tr><td scope="row">データベースフェイルオーバーの自動化</td><td>いいえ</td><td>はい</td><td>はい</td><td>はい</td></tr><tr><td scope="row">データ再同期の自動化</td><td>いいえ</td><td>はい</td><td>N/A - 共有ストレージ</td><td>はい</td></tr><tr><td scope="row">代表的なフェイルオーバー時間</td><td>ユーザー/スクリプトに依存</td><td>構成に依存、60 秒以上</td><td>構成に依存、60 秒以上</td><td>1 秒以下</td></tr><tr><td scope="row">同期レプリケーション</td><td>いいえ、非同期および準同期</td><td>はい</td><td>N/A - 共有ストレージ</td><td>はい</td></tr><tr><td scope="row">共有ストレージ</td><td>いいえ、分散型</td><td>いいえ、分散型</td><td>はい</td><td>いいえ、分散型</td></tr><tr><td scope="row">地理的冗長性のサポート</td><td>はい</td><td>はい、MySQL レプリケーション</td><td>はい、MySQL レプリケーション</td><td>はい、MySQL レプリケーション</td></tr><tr><td scope="row">更新スキーマオンライン</td><td>いいえ</td><td>いいえ</td><td>いいえ</td><td>はい</td></tr><tr><td scope="row"><span class="bold"><strong>拡張性</strong></span></td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><td scope="row">ノード数</td><td>1 つのマスター、複数のスレーブ</td><td>1 つのアクティブ (プライマリ) ノード、1 つのパッシブ (セカンダリ) ノード</td><td>1 つのアクティブ (プライマリ) ノード、1 つのパッシブ (セカンダリ) ノード</td><td>255</td></tr><tr><td scope="row">組み込みロードバランス</td><td>読み取り、MySQL レプリケーション経由</td><td>読み取り、MySQL レプリケーション経由</td><td>読み取り、MySQL レプリケーション経由およびフェイルオーバー中</td><td>はい、読み取りおよび書き込み</td></tr><tr><td scope="row">読み取りの多いワークロードをサポート対応</td><td>はい</td><td>はい</td><td>はい</td><td>はい</td></tr><tr><td scope="row">書き込みの多いワークロードをサポート対応</td><td>はい、アプリケーションレベルシャーディングで</td><td>はい、アプリケーションレベルシャーディング - 複数のアクティブ/パッシブペアで</td><td>はい、アプリケーションレベルシャーディング - 複数のアクティブ/パッシブペアで</td><td>はい、自動シャーディングで</td></tr><tr><td scope="row">スケールオンライン (ノードの追加、再パーティション化など)</td><td>いいえ</td><td>いいえ</td><td>いいえ</td><td>はい</td></tr></tbody></table></div></div><br class="table-break"><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ha-ovm-template"></a>16.1 Oracle VM Template for MySQL Enterprise</h2></div></div></div><p>
      仮想化は、クラウドコンピューティングの基盤を提供しながらデータセンターの効率性と高可用性を実現できる重要な技術です。MySQL Enterprise Edition を Oracle Linux、Oracle VM テンプレートに統合することが、仮想化された MySQL インスタンスをプロビジョニングするためのもっとも高速かつ簡単で信頼性の高い方法であり、ユーザーは高可用性サービスに対する膨大の重要を満たすことができます。
    </p><p>
      Oracle VM テンプレートは迅速な配備が可能で、手動による構成作業をなくすことができます。Oracle Linux および Oracle VM で動作し、本番使用向けに認定された、インストール済みかつ事前構成済みの仮想化された MySQL 5.5 Enterprise Edition ソフトウェアイメージを提供します。MySQL ソフトウェアイメージは、広範な統合および品質保証テストを開発プロセスの一部として受けてきました。
    </p><p>
      迅速なプロビジョニングに加えて、MySQL ユーザーは、厳しい SLA (サービスレベル契約) の要求を以下と組み合わせて組織が実現するように設計された Oracle VM の統合された高可用性機能のメリットも受けることができます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <span class="bold"><strong>障害からの自動リカバリ</strong></span>。Oracle VM は、物理サーバー、VM、または MySQL データベースの停止後に、サーバープールの使用可能なサーバーで障害が起きたインスタンスを自動的に再起動します。
        </p></li><li class="listitem"><p>
          <span class="bold"><strong>ライブ移行</strong></span>。運用スタッフは、MySQL の動作中インスタンスを保守作業中にサーバープール内の代替ホストに移動できます。
        </p></li></ul></div><p>
      Oracle VM Template for MySQL Enterprise の作成、配備、および使用に関する説明は、次から入手できます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          Oracle VM Template for MySQL Enterprise のホワイトペーパー: <a class="ulink" href="http://www.mysql.com/why-mysql/white-papers/mysql_wp_oracle-vm-template-for-mee.php" target="_top">http://www.mysql.com/why-mysql/white-papers/mysql_wp_oracle-vm-template-for-mee.php</a>.
        </p></li><li class="listitem"><p>
          テンプレートのダウンロードに添付される README ファイル。
        </p></li></ul></div><p>
      Oracle VM Template for MySQL Enterprise をダウンロードするには、<a class="ulink" href="https://edelivery.oracle.com/oraclevm" target="_top">https://edelivery.oracle.com/oraclevm</a>に移動して次の指示に従ってください。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          登録情報 (氏名、会社名、電子メールアドレス、国名) を入力してダウンロードの承諾をクリックします。
        </p></li><li class="listitem"><p>
          「Select a Product Pack」プルダウンメニューから「Oracle VM Templates」を選択して、「Go」をクリックします。
        </p></li><li class="listitem"><p>
          Oracle VM Template のリストから MySQL Enterprise を選択します。
        </p></li><li class="listitem"><p>
          ファイルをダウンロードして解凍し、その後の指示について README を参照してください。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ha-drbd"></a>16.2 DRBD/Pacemaker/Corosync/Oracle Linux を使用した MySQL の概要</h2></div></div></div><p>
    DRBD (Distributed Replication Block Device) は MySQL HA (高可用性) の主要ソリューションの 1 つです。Pacemaker および Corosync を合わせて使用すると、ユーザーは次のことを実現できます。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        成熟した実証済みオープンソーステクノロジーのエンドツーエンド統合スタック、これを Oracle が完全にサポート (MySQL Enterprise Edition の一部として)。
      </p></li><li class="listitem"><p>
        自動フェイルオーバーおよびリカバリによるサービス継続性。
      </p></li><li class="listitem"><p>
        同期レプリケーションによるミラーリング、確定されたトランザクションを失うリスクなしにノード間フェイルオーバー。
      </p></li><li class="listitem"><p>
        コモディティーハードウェアから HA クラスタを構築、共有ストレージは不要。
      </p></li></ul></div><p>
    次の図では、MySQL サービスに高可用性レベルを実現するために使用できるスタックを示します。
  </p><p>
    もっとも低いレベル 2 では、物理的な冗長性を提供するために 2 つのホストが必要です。仮想環境を使用する場合、これらの 2 つのホストは別の物理マシン上に置くことをお勧めします。共有ストレージの必要がない点が重要な特徴です。いずれかの時点で、サービスは一方のホストではアクティブであり、もう一方のホストではスタンバイモードです。
  </p><p>
    Pacemaker および Corosync は、サービスと基盤となるホスト/オペレーティングシステムとの間に位置するクラスタリングレイヤーを提供するために結合されます。Pacemaker はサービスの起動と停止を担っており、それらが正確に 1 つのホスト上で動作することを保証することで、高可用性を実現してデータの破損を回避します。Corosync は、ノード間に Pacemaker がジョブを実行するための基盤となるメッセージングインフラストラクチャーを提供し、さらにクラスタ内のノードメンバーシップを処理し、変更を Pacemaker に通知します。
  </p><div class="figure"><a name="ha-drbd-overview"></a><p class="title"><b>図 16.2 MySQL、DRBD、Pacemaker、および Corosync スタック</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/drbd-main.png" width="564" height="592" alt="MySQL、DRBD、Pacemaker、および Corosync スタック"></div></div></div><br class="figure-break"><p>
    Pacemaker コアプロセスには、管理すべき特定サービスの知識は組み込まれていません。代わりに、サービス固有のアクションにラッパーを提供するエージェントを使用します。たとえば、このソリューションでは、仮想 IP アドレス、MySQL、および DRBD にエージェントを使用します。これらはすべて既存のエージェントであり、Pacemaker にパッケージされます。
  </p><p>
    この構成で Pacemaker が管理する必須のサービスは、DRBD、MySQL、およびアクティブな MySQL サービスに接続するためにアプリケーションが使用する仮想 IP アドレスです。
  </p><p>
    DRBD は、ブロック型デバイス (一般的に、スピニングディスクまたは半導体ディスク) のデータをアプリケーション、データベース、さらにファイルシステムに透過的に同期します。DRBD は、<code class="literal">ext3</code> や <code class="literal">ext4</code> などのジャーナリングファイルシステムを使用することを要求します。このソリューションのために、アクティブ-スタンバイモードで動作します。任意の時点で、DRBD が管理するディレクトリには、2 つのホストの正確に 1 つから読み書きのためにアクセスでき、もう一方には (読み取りであっても) アクセスできません。アクティブホストに行われた変更は、DRBD によって同期的にスタンバイホストに複製されます。
  </p><p>
    完全な MySQL および DRBD スタックをインストール、構成、プロビジョニング、およびテストするための詳細な説明については、次のガイドをダウンロードしてください。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        MySQL データベース。
      </p></li><li class="listitem"><p>
        DRBD カーネルモジュールおよびユーザーランドユーティリティー。
      </p></li><li class="listitem"><p>
        Pacemaker および Corosync クラスタメッセージングおよび管理プロセス。
      </p></li><li class="listitem"><p>
        Oracle Linux オペレーティングシステム。
      </p></li></ul></div><p>
    <a class="ulink" href="http://www.mysql.com/why-mysql/white-papers/mysql-high-availability-drbd-configuration-deployment-guide/" target="_top">http://www.mysql.com/why-mysql/white-papers/mysql-high-availability-drbd-configuration-deployment-guide/</a>からガイドをダウンロードしてください。
  </p><h3><a name="idm139979058219536"></a>DRBD のサポート</h3><p>
    MySQL 用の完全な DRBD スタックは Oracle によって認定されました。問題がオペレーティングシステム、DRBD、クラスタリングソフトウェア、または MySQL に関係するかどうかにかかわらず、スタック全体に対して 1 つの契約を提供する商用サポートは、<a class="ulink" href="http://www.mysql.com/products/enterprise/" target="_top">MySQL Enterprise Edition</a> および <a class="ulink" href="http://www.oracle.com/us/technologies/linux/support/overview/index.html" target="_top">Oracle Linux Premier Support</a> の両方の契約をしたユーザーが利用できます。
  </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ha-wfc"></a>16.3 Windows フェイルオーバークラスタリングを使用した MySQL の概要</h2></div></div></div><a class="indexterm" name="idm139979058214816"></a><a class="indexterm" name="idm139979058213264"></a><p>
    Microsoft Windows は、MySQL ユーザーコミュニティーの調査によると、常に MySQL の一番の開発環境としてランクされています。
  </p><p>
    MySQL Enterprise Edition は、Windows Server 2008 R2 フェイルオーバークラスタリング (WSFC) で認定され、サポートされているため、組織は Microsoft ネイティブの Windows クラスタリングサービスを使用して高いレベルの可用性を要求するビジネスクリティカルアプリケーションを安全に配備できます。
  </p><p>
    次の図は、高可用性サービスを提供するために MySQL と Windows Server フェイルオーバークラスタリングとの統合を示しています。
  </p><div class="figure"><a name="ha-wfc-overview"></a><p class="title"><b>図 16.3 Windows Server フェイルオーバークラスタリングを使用した代表的な MySQL HA 構成</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/wfc-architecture.jpg" width="522" height="744" alt="Windows フェイルオーバークラスタリングを使用した MySQL"></div></div></div><br class="figure-break"><p>
    このアーキテクチャーでは、MySQL はアクティブ/パッシブ構成で配備されています。MySQL または基盤となるサーバーのいずれかで発生した障害は、自動的に検出され、MySQL インスタンスはパッシブノードで再起動されます。データベースにアクセスするアプリケーションや MySQL レプリケーションスレーブは、MySQL のリカバリが完了し、接続の受け付けを開始したあとに、同じ仮想 IP アドレスを使用して新しい MySQL に自動的に再接続できます。
  </p><p>
    Windows フェイルオーバークラスタリングを使用する MySQL には、クラスタ内に少なくとも 2 つのサーバーと共有ストレージ (たとえば、FC-AL SAN または iSCSI ディスク) が必要です。
  </p><p>
    MySQL バイナリとデータファイルは共有ストレージに格納され、Windows フェイルオーバークラスタリングは任意の時点で 1 つのクラスタノードだけがこれらのファイルにアクセスすることを保証します。
  </p><p>
    クライアントは、仮想 IP アドレス (VIP) を介して MySQL サービスに接続します。フェイルオーバーが発生した場合、多少の接続ロスは生じますが、フェイルオーバーが発生したときにアクティブであったトランザクションの失敗に対処する以外に、フェイルオーバーの発生を意識する必要はありません。
  </p><p>
    Windows Server フェイルオーバークラスタリングを使用する MySQL の構成について詳しくは、<a class="ulink" href="http://www.mysql.com/why-mysql/white-papers/mysql_wp_windows_failover_clustering.php" target="_top">http://www.mysql.com/why-mysql/white-papers/mysql_wp_windows_failover_clustering.php</a>に投稿されたホワイトペーパーを参照できます。
  </p><p>
    Windows Server フェイルオーバークラスタリングの背景情報と使用情報については、Microsoft Technet サイトの該当ページを参照してください。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <a class="ulink" href="http://technet.microsoft.com/en-us/library/cc725923(v=ws.10).aspx" target="_top">フェイルオーバークラスタリング</a>
      </p></li><li class="listitem"><p>
        <a class="ulink" href="http://technet.microsoft.com/en-us/library/ff182338(v=ws.10).aspx" target="_top">Windows Server 2008 R2 のフェイルオーバークラスタリング</a>
      </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ha-vm"></a>16.4 Amazon EC2 インスタンスでの MySQL の使用</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="ha-overview.html#ha-vm-aws-setup">16.4.1 EC2 AMI での MySQL のセットアップ</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-vm-aws-instance">16.4.2 EC2 インスタンスの制限</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-vm-aws-deploy">16.4.3 EC2 を使用した MySQL データベースの配備</a></span></dt></dl></div><p>
    Amazon Elastic Compute Cloud (EC2) サービスは、MySQL を含むさまざまな異なるアプリケーションとサービスを実行するために構築および配備できる仮想サーバーを提供します。EC2 サービスは Xen フレームワークをベースにしており、Amazon Machine Image (AMI) と呼ばれる仮想マシンの個々のインスタンスを実装する x86 Linux ベースプラットフォームをサポートしています。作成した AMI インスタンスへの完全な (ルート) アクセス権限を持つため、選択する任意の方法で構成したりインストールしたりできます。
  </p><p>
    EC2 を使用するには、使用する予定の構成とアプリケーションに基づく AMI を作成し、Amazon Simple Storage Service (S3) に AMI をアップロードします。S3 リソースから、EC2 環境でインスタンスとして実行する AMI の 1 つまたは複数のコピーを配備できます。EC2 環境は、インスタンスの管理と制御、および動作中のインスタンスに関するコンテキスト情報を提供します。
  </p><p>
    AMI、構成、およびアプリケーションを作成して管理できるため、選択した任意の環境を配備して作成できます。これには、基本的な MySQL サーバーに加えて、EC2 環境の利点を引き出すための拡張性に優れたレプリケーション、HA および拡張性シナリオ、さらに MySQL サービスとアプリケーションの要求の成長に合わせてインスタンスを追加配備できる機能が含まれています。
  </p><p>
    作業の配備と配布を支援するため、Amazon EC2 では小 (<code class="literal">m1.small</code> で特定)、大 (<code class="literal">m1.large</code>)、特大 (<code class="literal">m1.xlarge</code>) の異なる 3 つのインスタンスを利用できます。これらの異なるタイプは、EC2 Computer Unit (ECU) で測定された異なるレベルの計算能力を提供します。異なるインスタンス構成のサマリーを次の表に示しています。
  </p><div class="informaltable"><table summary="この表では EC2 インスタンス属性の一覧を示し、小、大、特大 EC2 インスタンスの属性構成設定の概要を示します。" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th scope="col">EC2 属性</th><th scope="col">小</th><th scope="col">大</th><th scope="col">特大</th></tr></thead><tbody><tr><td scope="row">プラットフォーム</td><td>32 ビット</td><td>64 ビット</td><td>64 ビット</td></tr><tr><td scope="row">CPU コア</td><td>1</td><td>2</td><td>4</td></tr><tr><td scope="row">ECU</td><td>1</td><td>4</td><td>8</td></tr><tr><td scope="row">RAM</td><td>1.7G バイト</td><td>7.5G バイト</td><td>15G バイト</td></tr><tr><td scope="row">ストレージ</td><td>150G バイト</td><td>840G バイト</td><td>1680G バイト</td></tr><tr><td scope="row">I/O パフォーマンス</td><td>中</td><td>高</td><td>高</td></tr></tbody></table></div><p>
    EC2 環境で MySQL を配備して使用するための代表的なモデルは、データベースデータとアプリケーションを保持するために使用できる基本的な AMI を作成することです。データベースとアプリケーションの基本環境が作成されると、適切なインスタンスへの AMI の配備を選択できます。小から大または特大 EC2 インスタンスへ再配備できる AMI を所有することの柔軟性によって、アプリケーションまたはデータベーススタックを再構築しなくてもハードウェア環境を容易にアップグレードできます。
  </p><p>
    EC2 インストールで MySQL をセットアップおよびインストールする方法や、実行中のインスタンスにデータを移植および移行する方法など、EC2 で MySQL を始める際は、<a class="xref" href="ha-overview.html#ha-vm-aws-setup" title="16.4.1 EC2 AMI での MySQL のセットアップ">セクション16.4.1「EC2 AMI での MySQL のセットアップ」</a>を参照してください。
  </p><p>
    レプリケーションのセットアップに関するガイドを含む、拡張可能な EC2 環境の作成方法に関するヒントとアドバイスについては、<a class="xref" href="ha-overview.html#ha-vm-aws-deploy" title="16.4.3 EC2 を使用した MySQL データベースの配備">セクション16.4.3「EC2 を使用した MySQL データベースの配備」</a>を参照してください。
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="ha-vm-aws-setup"></a>16.4.1 EC2 AMI での MySQL のセットアップ</h3></div></div></div><p>
      MySQL を実装する EC2 AMI をセットアップするには、Amazon が提供する事前構成済み AMI を使用する方法を含め、さまざまな方法があります。
    </p><p>
      Amazon が提供するデフォルト <span class="emphasis"><em>Getting Started</em></span> AMI は Fedora Core 4 を使用し、<span class="command"><strong>yum</strong></span> を使用して MySQL をインストールできます。
    </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>yum install mysql</code></strong>
</pre><p>
      これは、MySQL サーバーと、Perl DBI API の Perl DBD::mysql ドライバの両方をインストールします。
    </p><p>
      代わりに、標準インストール内で MySQL をインクルードする AMI の 1 つを使用することもできます。
    </p><p>
      さらに、MySQL Web サイトからダウンロードされた標準版 MySQL をインストールすることもできます。インストールのプロセスと手順は、Linux での MySQL のほかのインストールと同じです。<a class="xref" href="installing.html" title="第 2 章 MySQL のインストールと更新">第2章「<i>MySQL のインストールと更新</i>」</a>を参照してください。
    </p><p>
      MySQL の標準構成では、データファイルはデフォルトの場所 <code class="filename">/var/lib/mysql</code> に置かれます。EC2 インスタンスのデフォルトデータディレクトリは <code class="filename">/mnt</code> です (大および特大のインスタンスでは、この構成を変更できます)。<code class="filename">/etc/my.cnf</code> を編集して、より大きなストレージ領域を指すように <code class="option">datadir</code> オプションを設定する必要があります。
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        EC2 インスタンスでメインの保管場所をはじめて使用するときには、初期化が必要です。初期化プロセスは、デバイスに最初に書き込んだときに自動的に開始されます。デバイスはすぐに使い始めることができますが、新しいデバイスの書き込みパフォーマンスは初期化プロセスが終了するまで初期の書き込みでかなり低下します。
      </p><p>
        新しいインスタンスをセットアップするときにこの問題を回避するには、MySQL データベースに入力する前に初期化プロセスを開始することをお勧めします。これを行う 1 つの方法は、<span class="command"><strong>dd</strong></span> を使用してファイルシステムに書き込むことです。
      </p><pre class="programlisting">
root-shell&gt; <strong class="userinput"><code>dd if=/dev/zero of=initialize bs=1024M count=50</code></strong>
</pre><p>
        上記では、ファイルシステムに 50G バイトを作成し、初期化プロセスを開始します。プロセスが終了したらファイルを削除します。
      </p><p>
        初期化プロセスは時間がかかる場合があります。小インスタンスで、初期化には 2 時間から 3 時間かかります。大および特大デバイスの場合、初期化にそれぞれ 10 時間または 20 時間かかる場合があります。
      </p></div><p>
      MySQL データファイルの正しい保管場所を構成することに加えて、配備のインスタンス構成を保存する前に、インスタンスに次のほかの設定をセットアップすることも検討してください。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          MySQL サーバー ID を設定します。これをレプリケーションに使用すると、ID 情報が正しく設定されます。
        </p></li><li class="listitem"><p>
          バイナリロギングを有効にします。サーバーの起動および停止なしでレプリケーションを初期化できます。
        </p></li><li class="listitem"><p>
          ストレージエンジンのキャッシュとメモリーのパラメータを設定します。EC2 環境で使用するストレージエンジンに制約または制限はありません。構成を選択してください (たぶん、配備する予定のインスタンスに適した MySQL で提供される標準構成の 1 つを使用して)。大および特大インスタンスには、キャッシュ専用の RAM が割り当てられます。アプリケーションスタックの一部としてサーバーに <span class="command"><strong>memcached</strong></span> をインストールすることを選択する場合は、MySQL と <span class="command"><strong>memcached</strong></span> の両方に十分なメモリーが存在している必要があります。
        </p></li></ul></div><p>
      MySQL を実装する AMI と残りのアプリケーションスタックを構成したあとに、インスタンスを配備して再利用できるように AMI を保存してください。
    </p><p>
      アプリケーションスタックが AMI に構成されたあと、<code class="literal">mysqldump</code> を使用してデータベースのダンプを作成し、ダンプを EC2 インスタンスに転送してから、EC2 インスタンスデータベースに情報を再ロードすることで、MySQL データベースへのデータ入力を実行するようにしてください。
    </p><p>
      本番環境のアプリケーションでインスタンスを使用する前に、EC2 インスタンス環境の制限を確認してください。<a class="xref" href="ha-overview.html#ha-vm-aws-instance" title="16.4.2 EC2 インスタンスの制限">セクション16.4.2「EC2 インスタンスの制限」</a>を参照してください。MySQL AMI を使い始める前に、配備に関する説明を参照してください。<a class="xref" href="ha-overview.html#ha-vm-aws-deploy" title="16.4.3 EC2 を使用した MySQL データベースの配備">セクション16.4.3「EC2 を使用した MySQL データベースの配備」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="ha-vm-aws-instance"></a>16.4.2 EC2 インスタンスの制限</h3></div></div></div><p>
      アプリケーションを配備する前に EC2 インスタンスの次の制限について確認してください。これらが Amazon EC2 環境内に配備できるかどうかに影響することはないはずですが、これらによってアプリケーションをサポートする環境をセットアップおよび構成する方法が変わる場合があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          インスタンス内に格納されたデータは永続的ではありません。インスタンスを作成してインスタンスにデータを移入すると、データはマシンの動作中のみ所定の場所にありますが、リブート後は失われます。インスタンスをシャットダウンすると、そこに含まれるデータは失われます。
        </p><p>
          情報を失わないようにするには、<span class="command"><strong>mysqldump</strong></span> を使用して定期的にバックアップを取ってください。格納されているデータが重要である場合、障害に備えてデータの<span class="quote">「<span class="quote">ライブ</span>」</span>バックアップを保持するために、レプリケーションの使用を検討してください。バックアップを作成するときは、オフサイトにデータをコピーするときに適用される転送課金を避けるため、データを Amazon S3 サービスに書き込んでください。
        </p></li><li class="listitem"><p>
          EC2 インスタンスは永続的ではありません。インスタンスが動作しているハードウェアで障害が発生した場合、そのインスタンスはシャットダウンされます。これにより、データまたはサービスの損失が生じる可能性があります。
        </p><p>
          ただし、EBS を使用する場合、EBS ストレージボリュームを EC2 インスタンスに接続できるので、その EBS ボリュームは永続的になります。ディスクと同じように、EBS ボリュームにも障害が発生することがありますが、ボリュームのポイントインタイムスナップショットを作成できます。スナップショットは Amazon S3 に永続的であり、ボリュームに障害が発生した場合のデータのリストアに使用できます。
        </p></li><li class="listitem"><p>
          EC2 インスタンスを非 EC2 環境に複製するときは、EC2 サービスに対する転送コストを確認してください。異なる EC2 インスタンス間のデータ転送は無料であるため、EC2 環境でレプリケーションを使用しても追加料金は発生しません。
        </p></li><li class="listitem"><p>
          一部の HA 機能は、直接サポートされていないか、またはその有用性を損なう可能性のある制限要因や問題点を抱えています。たとえば、DRBD または MySQL Cluster の使用が機能しない場合があります。デフォルトストレージ構成も冗長ではありません。ソフトウェアベースの RAID を使用して冗長性を改善できますが、これは追加のパフォーマンス負荷を伴います。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="ha-vm-aws-deploy"></a>16.4.3 EC2 を使用した MySQL データベースの配備</h3></div></div></div><p>
      EC2 インスタンスの稼働時間と可用性を保証することはできませんが、EC2 環境に MySQL を配備するときは、EC2 インスタンスに作業を簡単に配布できる方法を使用してください。これにはいくつかの方法があります。シャーディング技術 (複数のサーバーにアプリケーションを分割して、データセットとユーザーの特定のブロックを異なるサーバーに割り当てる) を使用することが、これを効果的に行う方法です。一般的なルールとして、インスタンスをより大きなマシンにアップグレードするよりも、より多くの EC2 インスタンスを作成してより多くのユーザーをサポートする方が簡単です。
    </p><p>
      EC2 アーキテクチャーは、EC2 インスタンスを長期間の高可用性ソリューションとしてではなく、一時的なキャッシュベースソリューションとして扱うときに最適に機能します。複数のマシンを使用することに加えて、<span class="command"><strong>memcached</strong></span> などのほかのサービスの利点を活用してアプリケーションに追加のキャッシュを提供することは MySQL サーバー上の負荷を低減し、書き込みに集中するのに役立ちます。EC2 内の大および特大インスタンスでは、使用可能な RAM がデータのために大きなメモリーキャッシュを提供できます。
    </p><p>
      独自のハードウェアで使用するほとんどのタイプのスケールアウトトポロジは EC2 環境内で使用および適用できます。ただし、すでに説明した制限とアドバイスを使用して、潜在的な障害によってデータが失われないようにしてください。また、各 EC2 インスタンスの相対能力が非常に低いため、シャーディングを使用するようにアプリケーションを変更したり、EC2 インスタンスを追加してアプリケーションのパフォーマンスを改善したりできるようにしてください。
    </p><p>
      たとえば、次に示す典型的なスケールアウト環境を見てください。ここでは、単一マスターが 1 つ以上のスレーブ (この例では 3 つ) に複製され、Web サーバーが各レプリケーションスレーブ上で動作しています。
    </p><div class="mediaobject"><img src="images/ec2fig1.png" width="493" height="167" alt="典型的な標準スケールアウト構造"></div><p>
      この構造は、マスター用に 1 つの EC2 インスタンス、Web および MySQL スレーブサーバーごとに 1 つのインスタンスを使用することで、EC2 環境に完全に再現できます。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        EC2 環境内では、EC2 インスタンスが使用する内部 (プライベート) IP アドレスは一定です。インスタンス間で通信するときは、常にこれらの内部アドレスと名前を使用します。パブリック IP アドレスを使用するのは、外部と通信する場合 (たとえば、アプリケーションを公開する場合) だけです。
      </p></div><p>
      データベースの信頼性を確保するには、アクティブなバックアップおよびストレージの割り当てるレプリケーションスレーブを 1 つ以上 Amazon S3 施設に追加します。次のトポロジでこれの例を見ることができます。
    </p><div class="mediaobject"><img src="images/ec2fig2.png" width="493" height="433" alt="EC2 を使用してバックアップする典型的な標準スケールアウト構造"></div><p>
      EC2 インスタンスで <span class="bold"><strong><span class="command"><strong>memcached</strong></span> を使用すると</strong></span>、パフォーマンスが向上するはずです。大および特大インスタンスには、非常に多くの RAM があります。アプリケーションで <span class="command"><strong>memcached</strong></span> を使用するには、データベースから情報をロードするときに、まず項目がキャッシュ内に存在するかどうかを確認します。探しているデータがキャッシュ内に存在する場合は、それを使用します。そうでない場合は、データベースからデータを再ロードしてキャッシュに移入します。
    </p><p>
      <span class="bold"><strong>シャーディング</strong></span> は、該当するグループに応じて一意のデータセットを提供するために、個々のマシンまたはマシングループに割り当てることでデータベース全体のデータを分割します。たとえば、名字が文字 A - D で終わるすべてのユーザーを単一サーバーに置きます。ユーザーがアプリケーションに接続して名字が既知の場合は、クエリーを該当する MySQL サーバーにリダイレクトできます。
    </p><p>
      EC2 でシャーディングを使用する場合、Web サーバーと MySQL サーバーを個別の EC2 インスタンスに分けてから、シャーディング決定ロジックをアプリケーションに適用します。データアクセスにどの MySQL サーバーを使用すべきかを知っていると、クエリーを該当するサーバーに分配してください。次の図でこれの例を見ることができます。
    </p><div class="mediaobject"><img src="images/ec2fig3.png" width="493" height="333" alt="負荷分散のために EC2 でシャーディングを使用する"></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
        シャーディングと EC2 を使用する場合、インスタンスの障害の潜在性がアプリケーションに影響しないようにしてください。特定のシャードに MySQL サーバーを提供する EC2 インスタンスが失敗した場合、そのシャード上のすべてのデータは使用できなくなります。
      </p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ha-zfs-replication"></a>16.5 ZFS レプリケーションの使用</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="ha-overview.html#ha-zfs-config">16.5.1 ZFS を使用したファイルシステムレプリケーション</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-zfs-mysql">16.5.2 ZFS レプリケーションのための MySQL の構成</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-zfs-mysql-recovery">16.5.3 ZFS での MySQL リカバリーの扱い</a></span></dt></dl></div><a class="indexterm" name="idm139979058088112"></a><a class="indexterm" name="idm139979058086864"></a><p>
    高可用性環境に対応するため、情報の即時コピーを現在アクティブなマシンとホットバックアップの両方に提供することは、HA ソリューションの重要な部分です。この問題には、<a class="xref" href="replication.html" title="第 17 章 レプリケーション">第17章「<i>レプリケーション</i>」</a>や<a class="xref" href="ha-overview.html#ha-drbd" title="16.2 DRBD/Pacemaker/Corosync/Oracle Linux を使用した MySQL の概要">セクション16.2「DRBD/Pacemaker/Corosync/Oracle Linux を使用した MySQL の概要」</a>を含めて多くのソリューションがあります。
  </p><p>
    ZFS ファイルシステムには、ファイルシステム内容のスナップショットを作成したり、スナップショットを別のマシンに転送したり、スナップショットを解凍してファイルシステムを再作成したりする機能が用意されています。スナップショットはいつでも作成でき、必要な数のスナップショットを作成できます。スナップショットを継続的に作成、転送、およびリストアすることで、DRBD に類似した方法で 1 つまたは複数のマシン間に同期を提供できます。
  </p><p>
    次の例では、<code class="literal">/scratchpool</code> にマウントされた、単一 ZFS プールで動作する単純な Solaris システムを示します。
  </p><pre class="programlisting">
Filesystem             size   used  avail capacity  Mounted on
/dev/dsk/c0d0s0        4.6G   3.7G   886M    82%    /
/devices                 0K     0K     0K     0%    /devices
ctfs                     0K     0K     0K     0%    /system/contract
proc                     0K     0K     0K     0%    /proc
mnttab                   0K     0K     0K     0%    /etc/mnttab
swap                   1.4G   892K   1.4G     1%    /etc/svc/volatile
objfs                    0K     0K     0K     0%    /system/object
/usr/lib/libc/libc_hwcap1.so.1
                       4.6G   3.7G   886M    82%    /lib/libc.so.1
fd                       0K     0K     0K     0%    /dev/fd
swap                   1.4G    40K   1.4G     1%    /tmp
swap                   1.4G    28K   1.4G     1%    /var/run
/dev/dsk/c0d0s7         26G   913M    25G     4%    /export/home
scratchpool             16G    24K    16G     1%    /scratchpool
</pre><p>
    MySQL データは <code class="literal">/scratchpool</code> 上のディレクトリに格納されます。いくつかの基本レプリケーション機能を説明するために、<code class="literal">/scratchpool</code> にはほかの項目も格納されています。
  </p><pre class="programlisting">
total 17
drwxr-xr-x  31 root     bin           50 Jul 21 07:32 DTT/
drwxr-xr-x   4 root     bin            5 Jul 21 07:32 SUNWmlib/
drwxr-xr-x  14 root     sys           16 Nov  5 09:56 SUNWspro/
drwxrwxrwx  19 1000     1000          40 Nov  6 19:16 emacs-22.1/
</pre><p>
    ファイルシステムのスナップショットを作成するには、プールおよびスナップショット名を指定して <code class="literal">zfs snapshot</code> を使用します。
  </p><pre class="programlisting">
root-shell&gt; zfs snapshot scratchpool@snap1
</pre><p>
    すでに作成されたスナップショットの一覧を示すには:
  </p><pre class="programlisting">
root-shell&gt; zfs list -t snapshot
NAME                USED  AVAIL  REFER  MOUNTPOINT
scratchpool@snap1      0      -  24.5K  -
scratchpool@snap2      0      -  24.5K  -
</pre><p>
    スナップショット自体はファイルシステムメタデータに格納され、それらを保持するために必要な容量は、スナップショットが作成される方法が理由で時間とともに変化します。スナップショットの初回の作成は、スナップショット全体を保持するために必要なデータとメタデータの全体コピーを作成する代わりに、ZFS はスナップショットが作成されたときのポイントインタイムのメタデータだけを記録するため、非常に高速です。
  </p><p>
    元のファイルシステムに加えられた変更が多くなるにつれ、古いブロックのレコードを保持するためにより多くの容量が必要になるため、スナップショットのサイズが増えます。多くのスナップショットを作成していて (たとえば 1 日に 1 つ)、週の早い時期に作成したスナップショットを削除する場合、新しい状態を構成する変更は、週を構成する 7 個のスナップショットに分散されるのではなく、より最近のスナップショットに含まれる必要があるため、新しい方のスナップショットのサイズが増える場合もあります。
  </p><p>
    スナップショットは、一般のファイルとしてではなくファイルシステムメタデータ内に存在するため、直接バックアップできません。スナップショットを別のファイルシステムやテープなどにコピーできる形式にするには、<code class="literal">zfs send</code> コマンドを使用してストリーム版スナップショットを作成します。
  </p><p>
    たとえば、スナップショットをファイルに書き出すには:
  </p><pre class="programlisting">
root-shell&gt; zfs send scratchpool@snap1 &gt;/backup/scratchpool-snap1
</pre><p>
    またはテープ:
  </p><pre class="programlisting">
root-shell&gt; zfs send scratchpool@snap1 &gt;/dev/rmt/0
</pre><p>
    <code class="literal">zfs send</code> を使用して、2 つのスナップショット間の増分変更を書き出すこともできます。
  </p><pre class="programlisting">
root-shell&gt; zfs send scratchpool@snap1 scratchpool@snap2 &gt;/backup/scratchpool-changes
</pre><p>
    スナップショットをリカバリするには、スナップショット情報を新しいファイルシステムまたは既存のものに適用する <code class="literal">zfs recv</code> を使用します。
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="ha-zfs-config"></a>16.5.1 ZFS を使用したファイルシステムレプリケーション</h3></div></div></div><p>
      <code class="literal">zfs send</code> および <code class="literal">zfs recv</code> はストリームを使用してデータを交換するため、これらを使用して <code class="literal">zfs send</code>、<code class="literal">ssh</code>、および <code class="literal">zfs recv</code> を結合することで、あるシステムから別のシステムに情報を複製できます。
    </p><p>
      たとえば、<code class="literal">scratchpool</code> ファイルシステムのスナップショットを、新しいサーバー上の <code class="literal">slavepool</code> と呼ばれる新しいファイルシステムにコピーするには、次のコマンドを使用します。このシーケンスは、<code class="literal">scratchpool</code> のスナップショット、スレーブマシンへの転送 (<span class="command"><strong>ssh</strong></span> とログイン資格証明を使用)、および <span class="command"><strong>zfs recv</strong></span> を使用したスレーブでのスナップショットのリカバリを結合します。
    </p><pre class="programlisting">
root-shell&gt; zfs send scratchpool@snap1 |ssh <em class="replaceable"><code>id</code></em>@<em class="replaceable"><code>host</code></em> pfexec zfs recv -F slavepool
</pre><p>
      パイプラインの最初の部分 <code class="literal">zfs send scratchpool@snap1</code> はスナップショットをストリームします。<code class="literal">ssh</code> コマンドと、他方のサーバーでそれが実行するコマンド <code class="literal">pfexec zfs recv -F slavepool</code> は、ストリームされたスナップショットデータを受け取り、slavepool に書き込みます。この例では <code class="literal">-F</code> オプションを指定しました (スナップショットデータが強制的に適用されるため破壊的)。複製されたファイルシステムの最初のバージョンを作成しているため、これで問題ありません。
    </p><p>
      スレーブマシンでは、複製されたファイルシステムに正確に同じ内容が含まれています。
    </p><pre class="programlisting">
root-shell&gt; ls -al /slavepool/
total 23
drwxr-xr-x   6 root     root           7 Nov  8 09:13 ./
drwxr-xr-x  29 root     root          34 Nov  9 07:06 ../
drwxr-xr-x  31 root     bin           50 Jul 21 07:32 DTT/
drwxr-xr-x   4 root     bin            5 Jul 21 07:32 SUNWmlib/
drwxr-xr-x  14 root     sys           16 Nov  5 09:56 SUNWspro/
drwxrwxrwx  19 1000     1000          40 Nov  6 19:16 emacs-22.1/
</pre><p>
      スナップショットが作成されたあとに、ファイルシステムを再度同期するには、新しいスナップショットを作成してから、<code class="literal">zfs send</code> の増分スナップショット機能を使用して 2 つのスナップショット間の変更をスレーブマシンに再度送ります。
    </p><pre class="programlisting">
root-shell&gt; zfs send -i scratchpool@snapshot1 scratchpool@snapshot2 |ssh <em class="replaceable"><code>id</code></em>@<em class="replaceable"><code>host</code></em> pfexec zfs recv slavepool
</pre><p>
      この操作は、スレーブマシン上のファイルシステムがまったく変更されなかった場合にのみ成功します。変更された宛先ファイルシステムには増分変更を適用できません。上記の例では、<code class="literal">ls</code> コマンドがファイルまたはディレクトリの最終アクセス時間などのメタデータを変更することで問題を引き起こします。
    </p><p>
      スレーブファイルシステムでの変更を防ぐには、スレーブ上のファイルシステムを読み取り専用に設定します。
    </p><pre class="programlisting">
root-shell&gt; zfs set readonly=on slavepool
</pre><p>
      <code class="literal">readonly</code> を設定することは、通常の方法ではスレーブ上のファイルシステムを変更できないことを意味します (ファイルシステムメタデータを含む)。一般的にメタデータを更新する操作 (<code class="literal">ls</code> のように) は、ファイルシステム状態の更新を試みることなく、サイレントにそれらの関数を実行します。
    </p><p>
      スレーブファイルシステムの本質は元のファイルシステムの静的コピーにすぎません。ただし、読み取り専用に構成されている場合でも、ファイルシステムはそれに適用されるスナップショットを持つことができます。読み取り専用に設定されているファイルシステムで、初期コピーを再実行します。
    </p><pre class="programlisting">
root-shell&gt; zfs send scratchpool@snap1 |ssh <em class="replaceable"><code>id</code></em>@<em class="replaceable"><code>host</code></em> pfexec zfs recv -F slavepool
</pre><p>
      これで、元のファイルシステムに変更を行い、それらをスレーブに複製できます。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="ha-zfs-mysql"></a>16.5.2 ZFS レプリケーションのための MySQL の構成</h3></div></div></div><p>
      ソースファイルシステムで MySQL を構成するのは、複製する予定のファイルシステムでデータを作成する場合です。次の例の構成ファイルは <code class="literal">/scratchpool/mysql-data</code> をデータディレクトリとして使用するように更新されたので、テーブルを初期化できます。
    </p><pre class="programlisting">
root-shell&gt; mysql_install_db --defaults-file=/etc/mysql/5.5/my.cnf --user=mysql
</pre><p>
      初期情報を同期するには、新しいスナップショットを実行してから、<code class="literal">zfs send</code> を使用して増分スナップショットをスレーブに送信します。
    </p><pre class="programlisting">
root-shell&gt; zfs snapshot scratchpool@snap2
root-shell&gt; zfs send -i scratchpool@snap1 scratchpool@snap2|ssh <em class="replaceable"><code>id</code></em>@<em class="replaceable"><code>host</code></em> pfexec zfs recv slavepool
</pre><p>
      <code class="literal">slavepool</code> の MySQL データディレクトリを調べることで、スレーブにデータがあることをダブルチェックします。
    </p><pre class="programlisting">
root-shell&gt; ls -al /slavepool/mysql-data/
</pre><p>
      これで、MySQL を起動し、何らかのデータを作成し、<code class="literal">zfs send</code>/<code class="literal"> zfs recv</code> を使用して変更をスレーブに複製して変更を同期できます。
    </p><p>
      同期を実行する頻度は、アプリケーションと環境によって異なります。制限は、スナップショットを実行してからネットワークに変更を送信するために必要な速度です。
    </p><p>
      プロセスを自動化するには、スナップショットを実行し、送信し、操作を受信するスクリプトを作成し、<code class="literal">cron</code> を使用して特定の時間または間隔で変更を同期します。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="ha-zfs-mysql-recovery"></a>16.5.3 ZFS での MySQL リカバリーの扱い</h3></div></div></div><p>
      ZFS レプリケーションを使用してデータの定期コピーを提供するときは、元のシステムで障害が発生した場合に、手動または自動でテーブルをリカバリできることを確認してください。
    </p><p>
      障害が発生した場合、この順番に従ってください。
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          マスター上のスクリプトが起動されて動作中の場合は停止します。
        </p></li><li class="listitem"><p>
          スレーブファイルシステムを読み取り/書き込みに設定します。

</p><pre class="programlisting">
root-shell&gt; zfs set readonly=off slavepool
</pre><p>
        </p></li><li class="listitem"><p>
          スレーブで <span class="command"><strong>mysqld</strong></span> を起動します。<code class="literal">InnoDB</code> を使用している場合、必要に応じて自動リカバリーを取得してテーブルのデータが正しいことを確認します (ここでは INSERT 途中のスナップショットから起動したことが示されています)。

</p><pre class="programlisting">
InnoDB: The log sequence number in ibdata files does not match
InnoDB: the log sequence number in the ib_logfiles!
081109 15:59:59  InnoDB: Database was not shut down normally!
InnoDB: Starting crash recovery.
InnoDB: Reading tablespace information from the .ibd files...
InnoDB: Restoring possible half-written data pages from the doublewrite
InnoDB: buffer...
081109 16:00:03  InnoDB: Started; log sequence number 0 1142807951
081109 16:00:03 [Note] /slavepool/mysql-5.0.67-solaris10-i386/bin/mysqld: ready for connections.
Version: '5.0.67'  socket: '/tmp/mysql.sock'  port: 3306  MySQL Community Server (GPL)
</pre><p>
        </p></li></ol></div><p>
      <code class="literal">InnoDB</code> テーブルと定期的な同期スケジュールを使用して、重大なデータ損失のリスクを低減してください。MyISAM テーブルでは、<code class="literal">REPAIR TABLE</code> の実行が必要な場合があり、一部の情報を失った可能性もあります。
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ha-memcached"></a>16.6 MySQL と <span class="command"><strong>memcached</strong></span> の併用</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="ha-overview.html#ha-memcached-install">16.6.1 <span class="command"><strong>memcached</strong></span> のインストール</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-memcached-using">16.6.2 <span class="command"><strong>memcached</strong></span> の使用</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-memcached-interfaces">16.6.3 <span class="command"><strong>memcached</strong></span> アプリケーションの開発</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-memcached-stats">16.6.4 <span class="command"><strong>memcached</strong></span> の統計の取得</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-memcached-faq">16.6.5 <span class="command"><strong>memcached</strong></span> の FAQ</a></span></dt></dl></div><p>
    <span class="command"><strong>memcached</strong></span> は、使用可能な専用または予備の RAM にデータとオブジェクトを格納して、アプリケーションが解析のレイヤーやディスク I/O を介さずに高速にアクセスできるようにする、単純でスケーラビリティーの高いキーベースのキャッシュです。使用するには、1 台以上のホストで <span class="command"><strong>memcached</strong></span> コマンドを実行し、共有キャッシュを使用してオブジェクトを格納します。スレッドサポートの詳細は、<a class="xref" href="ha-overview.html#ha-memcached-using" title="16.6.2 memcached の使用">セクション16.6.2「<span class="command"><strong>memcached</strong></span> の使用」</a>を参照してください。
  </p><p>
    <span class="command"><strong>memcached</strong></span> を使用すると、次のような利点があります。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        すべての情報が RAM に格納されるため、ディスクから毎回情報をロードするよりもアクセス速度が向上します。
      </p></li><li class="listitem"><p>
        キー/値ペアの<span class="quote">「<span class="quote">値</span>」</span>部分にデータ型の制約がないため、複雑な構造、ドキュメント、イメージ、またはそれらの組み合わせなどのデータをキャッシュできます。
      </p></li><li class="listitem"><p>
        このインメモリーキャッシュを、一時的な情報を保持するため、またはデータベースにも格納される情報の読み取り専用キャッシュとして使用する場合、<span class="command"><strong>memcached</strong></span> サーバーの障害は重要ではありません。永続的なデータについては、データベースクエリーを使用する代替のルックアップ方法にフォールバックして、別のサーバー上の RAM にデータを再ロードできます。
      </p></li></ul></div><p>
    一般的な使用環境では、<span class="command"><strong>memcached</strong></span> が提供するキャッシュから情報を読み取るようにアプリケーションを変更します。情報が <span class="command"><strong>memcached</strong></span> に存在しない場合は、MySQL データベースからデータがロードされ、キャッシュされたデータを利用して後続する同じオブジェクトの要求を処理できるように、キャッシュにデータが書き込まれます。
  </p><p>
    通常の配備レイアウトについては、<a class="xref" href="ha-overview.html#ha-memcached-fig-overview" title="図 16.4 memcached アーキテクチャーの概要">図16.4「<span class="command">memcached</span> アーキテクチャーの概要」</a>を参照してください。
  </p><div class="figure"><a name="ha-memcached-fig-overview"></a><p class="title"><b>図 16.4 <span class="command">memcached</span> アーキテクチャーの概要</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/memcached-overview.png" width="540" height="296" alt="memcached アーキテクチャーの概要"></div></div></div><br class="figure-break"><p>
    この構造例では、どのクライアントもいずれかの <span class="command"><strong>memcached</strong></span> サーバーに接続して特定のキーを要求できます。各クライアントは、図に示したすべてのサーバーと通信するように構成されます。クライアントの内部で情報を格納するよう要求されると、データ参照に使用されるキーがハッシュ化され、このハッシュを使用していずれかの <span class="command"><strong>memcached</strong></span> サーバーが選択されます。<span class="command"><strong>memcached</strong></span> サーバーの選択はサーバーに接続する前にクライアント上で行われるため、このプロセスは軽量のままです。
  </p><p>
    クライアントが同じキーを要求すると、同じアルゴリズムが再度使用されます。同じキーによって同じハッシュが生成され、同じ <span class="command"><strong>memcached</strong></span> サーバーがデータのソースとして選択されます。この方法を使用すると、キャッシュされたデータがすべての <span class="command"><strong>memcached</strong></span> サーバーに分散し、どのクライアントからもキャッシュされた情報にアクセスできるようになります。この結果、データベースからネイティブに情報を読み取る場合に比べてはるかに高速に情報 (特に複雑なデータや構造) を返すことができる分散型のメモリーベースのキャッシュが提供されます。
  </p><p>
    従来型の <span class="command"><strong>memcached</strong></span> サーバー内に保持されるデータはディスクには格納されず (RAM にのみ格納されます。つまり、データの永続性はありません)、RAM キャッシュは常にバッキングストア (MySQL データベース) から移入されます。<span class="command"><strong>memcached</strong></span> サーバーに障害が発生した場合は、常に MySQL データベースからデータをリカバリできます。
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="ha-memcached-install"></a>16.6.1 <span class="command"><strong>memcached</strong></span> のインストール</h3></div></div></div><p>
      ソースコードから直接 <span class="command"><strong>memcached</strong></span> をビルドしてインストールできます。または、既存のオペレーティングシステムパッケージやインストールを使用できます。
    </p><p>
      <span class="bold"><strong>バイナリ配布からの <span class="command"><strong>memcached</strong></span> のインストール</strong></span>
    </p><p>
      Red Hat または Fedora ホストに <span class="command"><strong>memcached</strong></span> をインストールするには、<span class="command"><strong>yum</strong></span> を使用します。
    </p><pre class="programlisting">
root-shell&gt; yum install memcached
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        CentOS では、別のソースから適切な RPM を入手できる場合があります。または、ソースの tarball を使用します。
      </p></div><p>
      Debian または Ubuntu ホストに <span class="command"><strong>memcached</strong></span> をインストールするには、<span class="command"><strong>apt-get</strong></span> を使用します。
    </p><pre class="programlisting">
root-shell&gt; apt-get install memcached
</pre><p>
      Gentoo ホストに <span class="command"><strong>memcached</strong></span> をインストールするには、<span class="command"><strong>emerge</strong></span> を使用します。
    </p><pre class="programlisting">
root-shell&gt; emerge install memcached
</pre><p>
      <span class="bold"><strong>ソースからの <span class="command"><strong>memcached</strong></span> のビルド</strong></span>
    </p><p>
      ほかの Unix ベースのプラットフォーム (Solaris、AIX、HP-UX、および OS X を含む) とまだ説明されていない Linux 配布では、ソースからインストールする必要があります。Linux では、改良された <code class="literal">epoll</code> インタフェースを含む 2.6 ベースのカーネルが使用されているか確認してください。すべてのプラットフォームで、<code class="literal">libevent</code> 1.1 以降がインストールされていることを確認してください。<code class="literal">libevent</code> は、<a class="ulink" href="http://www.monkey.org/~provos/libevent/" target="_top"><code class="literal">libevent</code> の Web ページ</a>から入手できます。
    </p><p>
      <span class="command"><strong>memcached</strong></span> のソースは、<a class="ulink" href="http://www.danga.com/memcached" target="_top"><span class="command"><strong>memcached</strong></span> の Web サイト</a>から入手できます。
    </p><p>
      <span class="command"><strong>memcached</strong></span> をビルドするには、次の手順に従います。
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          <span class="command"><strong>memcached</strong></span> ソースパッケージを抽出します。
        </p><pre class="programlisting">
shell&gt; gunzip -c memcached-<em class="replaceable"><code>1.2.5</code></em>.tar.gz | tar xf - 
</pre></li><li class="listitem"><p>
          <span class="command"><strong>memcached-<em class="replaceable"><code>1.2.5</code></em></strong></span> ディレクトリに移動します。
        </p><pre class="programlisting">
shell&gt; cd memcached-<em class="replaceable"><code>1.2.5</code></em>
</pre></li><li class="listitem"><p>
          <span class="command"><strong>configure</strong></span> を実行します
        </p><pre class="programlisting">
shell&gt; ./configure
</pre><p>
          <span class="command"><strong>configure</strong></span> に指定できる追加のオプション:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="option">--prefix</code>
            </p><p>
              別のインストールディレクトリを指定するには、<code class="option">--prefix</code> オプションを使用します。
            </p><pre class="programlisting">
shell&gt; ./configure --prefix=/opt
</pre><p>
              デフォルトでは <code class="filename">/usr/local</code> ディレクトリが使用されます。
            </p></li><li class="listitem"><p>
              <code class="option">--with-libevent</code>
            </p><p>
              <code class="filename">libevent</code> がインストールされていて、<span class="command"><strong>configure</strong></span> でこのライブラリが見つからない場合は、<code class="option">--with-libevent</code> オプションを使用してインストールされたライブラリの場所を指定します。
            </p></li><li class="listitem"><p>
              <code class="option">--enable-64bit</code>
            </p><p>
              <span class="command"><strong>memcached</strong></span> の 64 ビットバージョン (大量の RAM を割り当てた単一インスタンスを使用できます) をビルドするには、<code class="option">--enable-64bit</code> を使用します。
            </p></li><li class="listitem"><p>
              <code class="option">--enable-threads</code>
            </p><p>
              <span class="command"><strong>memcached</strong></span> のマルチスレッドサポート (負荷が高いサーバーで応答時間が向上します) を有効にするには、<code class="option">--enable-threads</code> を使用します。スレッドサポートを有効にするには、オペレーティングシステムの内部で POSIX スレッドがサポートされている必要があります。スレッドサポートの詳細は、<a class="xref" href="ha-overview.html#ha-memcached-using-threads" title="16.6.2.7 memcached のスレッドサポート">セクション16.6.2.7「<span class="command"><strong>memcached</strong></span> のスレッドサポート」</a>を参照してください。
            </p></li><li class="listitem"><p>
              <code class="option">--enable-dtrace</code>
            </p><p>
              <span class="command"><strong>memcached</strong></span> には、<span class="command"><strong>memcached</strong></span> インスタンスのモニターとベンチマークの実行に使用できる一連の DTrace スレッドが含まれています。詳細については、<a class="xref" href="ha-overview.html#ha-memcached-using-dtrace" title="16.6.2.5 memcached と DTrace の使用">セクション16.6.2.5「<span class="command"><strong>memcached</strong></span> と DTrace の使用」</a>を参照してください。
            </p></li></ul></div></li><li class="listitem"><p>
          <span class="command"><strong>make</strong></span> を実行して <span class="command"><strong>memcached</strong></span> をビルドします。
        </p><pre class="programlisting">
shell&gt; make
</pre></li><li class="listitem"><p>
          <span class="command"><strong>make install</strong></span> を実行して <span class="command"><strong>memcached</strong></span> をインストールします。
        </p><pre class="programlisting">
shell&gt; make install
</pre></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="ha-memcached-using"></a>16.6.2 <span class="command"><strong>memcached</strong></span> の使用</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="ha-overview.html#ha-memcached-using-deployment">16.6.2.1 <span class="command"><strong>memcached</strong></span> の配備</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-memcached-using-namespaces">16.6.2.2 名前空間の使用</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-memcached-using-expiry">16.6.2.3 データ失効</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-memcached-using-hashtypes">16.6.2.4 <span class="command"><strong>memcached</strong></span> のハッシュ化/分布タイプ</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-memcached-using-dtrace">16.6.2.5 <span class="command"><strong>memcached</strong></span> と DTrace の使用</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-memcached-using-memory">16.6.2.6 <span class="command"><strong>memcached</strong></span> 内でのメモリー割り当て</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-memcached-using-threads">16.6.2.7 <span class="command"><strong>memcached</strong></span> のスレッドサポート</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-memcached-using-logs">16.6.2.8 <span class="command"><strong>memcached</strong></span> ログ</a></span></dt></dl></div><p>
      <span class="command"><strong>memcached</strong></span> の使用を開始するには、1 台以上のサーバーで <span class="command"><strong>memcached</strong></span> サービスを起動します。<span class="command"><strong>memcached</strong></span> を実行すると、サーバーが設定され、メモリーが割り当てられ、クライアントからの接続の待機が開始されます。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <span class="command"><strong>memcached</strong></span> を実行する際は、いずれかの特権 TCP/IP ポート (1024 以下) で待機する場合を除き、権限を持つユーザー (<code class="literal">root</code>) である必要はありません。ただし、<span class="command"><strong>setrlimit</strong></span> または同様の機能を使用してメモリー制限が設定されていないユーザーを使用する必要があります。
      </p></div><p>
      サーバーを起動するには、権限を持たない (つまり、<code class="literal">root</code> 以外の) ユーザーとして <span class="command"><strong>memcached</strong></span> を実行します。
    </p><pre class="programlisting">
shell&gt; memcached
</pre><p>
      デフォルトでは、<span class="command"><strong>memcached</strong></span> は次の設定を使用します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          64M バイトのメモリー割り当て
        </p></li><li class="listitem"><p>
          すべてのネットワークインタフェースでポート 11211 を使用して接続を待機します
        </p></li><li class="listitem"><p>
          最大で 1024 個の同時接続をサポートします
        </p></li></ul></div><p>
      一般に、<span class="command"><strong>memcached</strong></span> の起動時に必要なオプションの完全な組み合わせを指定し、通常は <span class="command"><strong>memcached</strong></span> の初期化を処理する起動スクリプトを提供します。たとえば、次の行はキャッシュ用に最大 1024M バイトの RAM を割り当て、IP アドレス 192.168.0.110 のポート 11211 で待機し、バックグラウンドデーモンとして動作するように <span class="command"><strong>memcached</strong></span> を起動します。
    </p><pre class="programlisting">
shell&gt; memcached -d -m 1024 -p 11211 -l 192.168.0.110
</pre><p>
      <span class="command"><strong>memcached</strong></span> がブート時に起動されるようにするには、init スクリプトと構成パラメータを確認してください。
    </p><p>
      <span class="command"><strong>memcached</strong></span> は次のオプションをサポートします。
    </p><div class="itemizedlist"><a name="ha-memcached-cmdline-options"></a><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="option">-u user</code>
        </p><p>
          <code class="literal">root</code> として <span class="command"><strong>memcached</strong></span> を起動する場合は、<code class="option">-u</code> オプションを使用して <span class="command"><strong>memcached</strong></span> の実行用のユーザーを指定します。
        </p><pre class="programlisting">
shell&gt; memcached -u memcache
</pre></li><li class="listitem"><p>
          <code class="option">-m memory</code>
        </p><p>
          オブジェクトを格納するために <span class="command"><strong>memcached</strong></span> に割り当てるメモリーの量を設定します。デフォルトは 64M バイトです。
        </p><p>
          キャッシュ用に割り当てるメモリーの量を増やすには、<code class="option">-m</code> オプションを使用して割り当てる RAM の量 (メガバイト単位) を指定します。割り当てる RAM の量が多いほど、格納できるデータの量も多くなり、キャッシュの効率も向上します。
        </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
            使用可能な RAM より大きいメモリー割り当てを指定しないでください。指定した値が大きすぎると、<span class="command"><strong>memcached</strong></span> に割り当てられた RAM の一部に対して物理 RAM ではなくスワップ領域が使用されます。これにより、データが RAM に直接格納されず、ディスクにスワップされるため、値を格納および取得するときに遅延が発生する可能性があります。
          </p><p>
            <span class="command"><strong>vmstat</strong></span> コマンドの出力を使用すると、次の <code class="literal">free</code> カラムに示されるように、空きメモリーを取得できます。
          </p><pre class="programlisting">
shell&gt; vmstat
kthr      memory            page            disk          faults      cpu
r b w   swap  free  re  mf pi po fr de sr s1 s2 -- --   in   sy   cs us sy id
0 0 0 5170504 3450392 2  7  2  0  0  0  4  0  0  0  0  296   54  199  0  0 100
</pre></div><p>
          たとえば、3G バイトの RAM を取得するには:
        </p><pre class="programlisting">
shell&gt; memcached -m 3072
</pre><p>
          4G バイトの制限を超えるメモリーにアクセスするために PAE を使用する 32 ビット x86 システムでは、最大プロセスサイズを超える RAM を割り当てることはできません。これを回避するには、<span class="command"><strong>memcached</strong></span> の複数のインスタンスを実行し、それぞれ異なるポートで待機します。
        </p><pre class="programlisting">
shell&gt; memcached -m 1024 -p11211
shell&gt; memcached -m 1024 -p11212
shell&gt; memcached -m 1024 -p11213
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            すべてのシステム (特に 32 ビット) で、<span class="command"><strong>memcached</strong></span> アプリケーションとメモリー設定の両方に関して十分な余裕を確保してください。たとえば、4G バイトの RAM を搭載した専用の <span class="command"><strong>memcached</strong></span> ホストがある場合は、3500M バイトを超えるメモリーサイズを設定しないでください。これができなかった場合は、クラッシュや深刻なパフォーマンスの問題が発生する可能性があります。
          </p></div></li><li class="listitem"><p>
          <code class="option">-l interface</code>
        </p><p>
          接続を待機するネットワークインタフェース/アドレスを指定します。デフォルトでは、使用可能なすべてのアドレス (<code class="literal">INADDR_ANY</code>) で待機します。
        </p><pre class="programlisting">
shell&gt; memcached -l 192.168.0.110
</pre><p>
          IPv6 アドレスのサポートは <span class="command"><strong>memcached</strong></span> 1.2.5 で追加されました。
        </p></li><li class="listitem"><p>
          <code class="option">-p port</code>
        </p><p>
          接続に使用する TCP ポートを指定します。デフォルトは 18080 です。
        </p><pre class="programlisting">
shell&gt; memcached -p 18080
</pre></li><li class="listitem"><p>
          <code class="option">-U port</code>
        </p><p>
          接続に使用する UDP ポートを指定します。デフォルトは 11211 です。0 を指定すると UDP が無効になります。
        </p><pre class="programlisting">
shell&gt; memcached -U 18080
</pre></li><li class="listitem"><p>
          <code class="option">-s socket</code>
        </p><p>
          待機に使用する Unix ソケットを指定します。
        </p><p>
          クライアントと同じサーバーで <span class="command"><strong>memcached</strong></span> を実行する場合は、<code class="option">-s</code> オプションを使用すると、ネットワークインタフェースが無効になり、ローカルの Unix ソケットを使用できます。
        </p><pre class="programlisting">
shell&gt; memcached -s /tmp/memcached
</pre><p>
          Unix ソケットを使用すると、ネットワークサポートが自動的に無効になり、ネットワークポートが節約されます (Web サーバーやその他のプロセスでより多くのポートを使用できます)。
        </p></li><li class="listitem"><p>
          <code class="option">-a mask</code>
        </p><p>
          Unix ソケットで使用するアクセスマスク (8 進数) を指定します。デフォルトは 0700 です。
        </p></li><li class="listitem"><p>
          <code class="option">-c connections</code>
        </p><p>
          <span class="command"><strong>memcached</strong></span> サービスに対する同時接続の最大数を指定します。デフォルトは 1024 です。
        </p><pre class="programlisting">
shell&gt; memcached -c 2048
</pre><p>
          このオプションは、(<span class="command"><strong>memcached</strong></span> サービスへの過負荷を避けるために) 接続数を減らすか、または接続数を増やして <span class="command"><strong>memcached</strong></span> サーバーを実行しているサーバーをより効果的に利用するために使用します。
        </p></li><li class="listitem"><p>
          <code class="option">-t threads</code>
        </p><p>
          受信した要求を処理するときに使用するスレッドの数を指定します。
        </p><p>
          デフォルトでは、<span class="command"><strong>memcached</strong></span> は 4 つの並列スレッドを使用するように構成されます。スレッドは、ロックシステムを使用して異なるスレッドによる同じ値の上書きや更新を防止することにより、キャッシュ内のデータの格納と取得のパフォーマンスを向上させます。スレッドの数を増減するには、<code class="literal">-t</code> オプションを使用します。
        </p><pre class="programlisting">
shell&gt; memcached -t 8
</pre></li><li class="listitem"><p>
          <code class="option">-d</code>
        </p><p>
          <span class="command"><strong>memcached</strong></span> をデーモン (バックグラウンド) プロセスとして実行します。
        </p><pre class="programlisting">
shell&gt; memcached -d
</pre></li><li class="listitem"><p>
          <code class="option">-r</code>
        </p><p>
          コアファイルの上限サイズを最大化します。これにより、障害が発生したときにメモリー領域全体が <span class="command"><strong>setrlimit</strong></span> で設定された上限までコアファイルとしてディスクにダンプされます。
        </p></li><li class="listitem"><p>
          <code class="option">-M</code>
        </p><p>
          メモリーが使い果たされたときに、クライアントにエラーを返します。これは、キャッシュから古い項目を削除して新しい項目が入るようにする通常の動作に代わって適用されます。
        </p></li><li class="listitem"><p>
          <code class="option">-k</code>
        </p><p>
          ページングされたすべてのメモリーをロックダウンします。これにより、新しい項目がキャッシュに格納されたときにメモリーの新しいスラブを割り当てるのではなく、使用前にメモリーが確保されます。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            ロックできるメモリーの量には、ユーザーレベルの制限があります。使用可能なメモリー量を超えて割り当てようとすると、失敗します。(<code class="option">-u user</code> のユーザーではなく) デーモンを起動するときに使用したユーザーに対して制限を設定するには、シェル内で <span class="command"><strong>ulimit -S -l NUM_KB</strong></span> を使用します
          </p></div></li><li class="listitem"><p>
          <code class="option">-v</code>
        </p><p>
          冗長モード。メインイベントループの実行中にエラーおよび警告を出力します。
        </p></li><li class="listitem"><p>
          <code class="option">-vv</code>
        </p><p>
          高冗長モード。<code class="option">-v</code> で出力される情報に加えて、個々のクライアントコマンドと応答も出力されます。
        </p></li><li class="listitem"><p>
          <code class="option">-vvv</code>
        </p><p>
          超冗長モード。<code class="option">-vv</code> で出力される情報に加えて、内部の状態遷移も表示されます。
        </p></li><li class="listitem"><p>
          <code class="option">-h</code>
        </p><p>
          ヘルプメッセージを出力して終了します。
        </p></li><li class="listitem"><p>
          <code class="option">-i</code>
        </p><p>
          <span class="command"><strong>memcached</strong></span> と <code class="literal">libevent</code> のライセンスを出力します。
        </p></li><li class="listitem"><p>
          <code class="option">-I mem</code>
        </p><p>
          <span class="command"><strong>memcached</strong></span> インスタンスに格納できるオブジェクトの最大サイズを指定します。このサイズは、単位の接尾辞 (キロバイトを表す <code class="literal">k</code>、メガバイトを表す <code class="literal">m</code>) をサポートします。たとえば、サポートされる最大オブジェクトサイズを 32M バイトに増やすには:
        </p><pre class="programlisting">
shell&gt; memcached -I 32m
</pre><p>
          指定できる最大オブジェクトサイズは 128M バイト、デフォルトは 1M バイトです。
        </p><p>
          このオプションは 1.4.2 で追加されました。
        </p></li><li class="listitem"><p>
          <code class="option">-b</code>
        </p><p>
          バックログキューの制限を設定します。バックログキューによって、<span class="command"><strong>memcached</strong></span> による処理を待機できるネットワーク接続の数が構成されます。この制限を増やすと、クライアントが <span class="command"><strong>memcached</strong></span> インスタンスに接続できないエラーを受信する回数が減る可能性がありますが、サーバーのパフォーマンスは向上しません。デフォルトは 1024 です。
        </p></li><li class="listitem"><p>
          <code class="option">-P pidfile</code>
        </p><p>
          <span class="command"><strong>memcached</strong></span> インスタンスのプロセス ID を <code class="literal">file</code> に保存します。
        </p></li><li class="listitem"><p>
          <code class="option">-f</code>
        </p><p>
          チャンクサイズの増大係数を設定します。新しいメモリーチャンクを割り当てる場合、新しいチャンクの割り当てサイズはデフォルトのスラブサイズにこの係数を掛けて決定されます。
        </p><p>
          大規模なテストを行わずにこのオプションの効果を確認するには、<code class="option">-vv</code> コマンド行オプションを使用して、計算されたスラブサイズを表示します。詳細については、<a class="xref" href="ha-overview.html#ha-memcached-using-logs" title="16.6.2.8 memcached ログ">セクション16.6.2.8「<span class="command"><strong>memcached</strong></span> ログ」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="option">-n bytes</code>
        </p><p>
          キー + 値 + フラグ情報に割り当てられる最小領域。デフォルトは 48 バイトです。
        </p></li><li class="listitem"><p>
          <code class="option">-L</code>
        </p><p>
          大規模メモリーページをサポートするシステムで、大規模メモリーページの使用を有効にします。大規模メモリーページを使用すると、<span class="command"><strong>memcached</strong></span> は 1 つの大きなチャンクに項目キャッシュを割り当てることができるようになり、メモリーへのアクセス時にミスの数が減ってパフォーマンスが向上する可能性があります。
        </p></li><li class="listitem"><p>
          <code class="option">-C</code>
        </p><p>
          コンペアアンドスワップ (CAS) 操作の使用を無効にします。
        </p><p>
          このオプションは <span class="command"><strong>memcached</strong></span> 1.3.x で追加されました。
        </p></li><li class="listitem"><p>
          <code class="option">-D char</code>
        </p><p>
          デフォルトの文字をキープリフィクスと ID の区切りとして使用するように設定します。これは、プリフィクス単位の統計レポートで使用されます (<a class="xref" href="ha-overview.html#ha-memcached-stats" title="16.6.4 memcached の統計の取得">セクション16.6.4「<span class="command"><strong>memcached</strong></span> の統計の取得」</a>を参照してください)。デフォルトはコロン (<code class="literal">:</code>) です。このオプションを使用すると、統計収集が自動的にオンになります。使用しなかった場合は、<code class="literal">stats detail on</code> コマンドをサーバーに送信して統計収集を有効にできます。
        </p><p>
          このオプションは <span class="command"><strong>memcached</strong></span> 1.3.x で追加されました。
        </p></li><li class="listitem"><p>
          <code class="option">-R num</code>
        </p><p>
          イベントプロセスあたりの最大要求数を設定します。デフォルトは 20 です。
        </p></li><li class="listitem"><p>
          <code class="option">-B protocol</code>
        </p><p>
          バインディングプロトコル (つまり、クライアント接続に対するデフォルトの <span class="command"><strong>memcached</strong></span> プロトコルサポート) を設定します。オプションは、<code class="literal">ascii</code>、<code class="literal">binary</code>、または <code class="literal">auto</code> です。自動 (<code class="literal">auto</code>) がデフォルトです。
        </p><p>
          このオプションは、<span class="command"><strong>memcached</strong></span> 1.4.0 で追加されました。
        </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ha-memcached-using-deployment"></a>16.6.2.1 <span class="command"><strong>memcached</strong></span> の配備</h4></div></div></div><p>
        <span class="command"><strong>memcached</strong></span> を使用するときは、いくつかの異なる可能な配備戦略とトポロジを使用できます。使用する正確な戦略は、アプリケーションと環境によって異なります。システム内に <span class="command"><strong>memcached</strong></span> を配備するためのシステムを開発するときは、次の点に留意してください。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <span class="command"><strong>memcached</strong></span> はキャッシュメカニズムに過ぎません。消失したり、別の場所からロードしたりできない情報の格納に使用しないでください。
          </p></li><li class="listitem"><p>
            <span class="command"><strong>memcached</strong></span> プロトコルにはセキュリティーが組み込まれていません。最低でも、<span class="command"><strong>memcached</strong></span> を実行しているサーバーがネットワークの内部からのみアクセス可能であり、使用されるネットワークポートが (ファイアウォールなどを使用して) ブロックされることを確認してください。<span class="command"><strong>memcached</strong></span> サーバーに格納されている情報の機密性が高い場合は、その情報を <span class="command"><strong>memcached</strong></span> に格納する前に暗号化してください。
          </p></li><li class="listitem"><p>
            <span class="command"><strong>memcached</strong></span> には、どのようなフェイルオーバーも用意されていません。これは、異なる <span class="command"><strong>memcached</strong></span> インスタンス間で通信が行われないためです。あるインスタンスに障害が発生した場合、アプリケーションはそのインスタンスをリストから削除し、データを再ロードして、別の <span class="command"><strong>memcached</strong></span> インスタンスにデータを書き込む必要があります。
          </p></li><li class="listitem"><p>
            これらのタスクに異なる複数の物理マシンを使用すると、クライアントと <span class="command"><strong>memcached</strong></span> 間の待機時間に問題が発生する可能性があります。待機時間に問題が発生した場合は、<span class="command"><strong>memcached</strong></span> インスタンスをクライアントに移動してください。
          </p></li><li class="listitem"><p>
            キーの長さは <span class="command"><strong>memcached</strong></span> サーバーによって決定されます。デフォルトの最大キーサイズは 250 バイトです。
          </p></li><li class="listitem"><p>
            特にクライアントが複数ある場合は、単一障害点を回避するため、少なくとも 2 つの <span class="command"><strong>memcached</strong></span> インスタンスを使用してください。できるかぎり多くの <span class="command"><strong>memcached</strong></span> ノードを作成するのが理想的です。<span class="command"><strong>memcached</strong></span> インスタンスをプールに追加したり、プールから削除したりすると、キー/値ペアのハッシュ化と分布に影響する可能性があります。問題を回避する方法については、<a class="xref" href="ha-overview.html#ha-memcached-using-hashtypes" title="16.6.2.4 memcached のハッシュ化/分布タイプ">セクション16.6.2.4「<span class="command"><strong>memcached</strong></span> のハッシュ化/分布タイプ」</a>を参照してください。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ha-memcached-using-namespaces"></a>16.6.2.2 名前空間の使用</h4></div></div></div><p>
        <span class="command"><strong>memcached</strong></span> キャッシュは非常に単純かつ大規模なキー/値ストレージシステムであるため、データを異なるセクションに区分化する手段がありません。たとえば、MySQL データベースから返される一意の ID によって情報を格納する場合、2 つの異なるテーブルからデータを格納すると、同じ ID が両方のテーブルで有効になるため、問題が発生する可能性があります。
      </p><p>
        一部のインタフェースには、情報をキャッシュに格納するときに<span class="emphasis"><em>名前空間</em></span>を作成するための自動メカニズムが用意されています。これらの名前空間は、実際には、値がキャッシュに格納されるたび、または値がキャッシュから取得されるたびに特定の ID の前に付けられる単なるプリフィクスです。
      </p><p>
        オブジェクトを記述するキーと、オブジェクトの格納時にキーの内部に指定する一意の識別子を使用することで、この同じ基本原則を実装できます。たとえば、ユーザーデータを格納するときは、ユーザーの ID に <code class="literal">user:</code> や <code class="literal">user-</code> のようなプリフィクスを付けます。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          名前空間やプリフィクスを使用して制御されるのは、格納または取得されるキーだけです。<span class="command"><strong>memcached</strong></span> 内にはセキュリティーがないため、特定のクライアントのみが特定の名前空間を持つキーにアクセスできるようにする方法はありません。名前空間は、データを識別し、キー/値ペアの破損を防止する手段としてのみ有効です。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ha-memcached-using-expiry"></a>16.6.2.3 データ失効</h4></div></div></div><p>
        <span class="command"><strong>memcached</strong></span> インスタンス内には、2 つのタイプのデータ失効があります。1 つ目のタイプは、新しいキー/値ペアが <span class="command"><strong>memcached</strong></span> インスタンスに格納された時点で適用されます。適切なスラブ内に値を格納する十分な領域がない場合は、既存のもっとも長い間使われていない (LRU) オブジェクトがキャッシュから削除 (消去) され、新しい項目用の領域が確保されます。
      </p><p>
        LRU アルゴリズムにより、アクティブに使用されなくなったオブジェクトや、データが古いかほとんど無価値である可能性がある長期間使用されていないオブジェクトが削除されます。ただし、<span class="command"><strong>memcached</strong></span> に割り当てられたメモリーがキャッシュ内で定期的に使用される必須オブジェクトの数より小さいシステムでは、多くの項目がアクティブに使用されているにもかかわらず、失効してキャッシュから削除される可能性があります。消去 (失効するオブジェクト) のレベルをより適切に把握するには、統計メカニズムを使用します。詳細については、<a class="xref" href="ha-overview.html#ha-memcached-stats" title="16.6.4 memcached の統計の取得">セクション16.6.4「<span class="command"><strong>memcached</strong></span> の統計の取得」</a>を参照してください。
      </p><p>
        この消去動作を変更するには、<span class="command"><strong>memcached</strong></span> の起動時に <code class="literal">-M</code> コマンド行オプションを設定します。このオプションを使用すると、メモリーが使い果たされたときに、古いデータが自動的に消去されず、エラーが返されるようになります。
      </p><p>
        2 つ目のタイプの失効システムは、キャッシュにキー/値ペアが挿入されたとき、またはキャッシュから項目を削除するときに設定できる明示的なメカニズムです。失効時間を使用することで、キャッシュ内のデータが最新であり、アプリケーションのニーズと要件に合っていることを効果的に確認できます。
      </p><p>
        失効時間を明示的に設定する一般的なシナリオとして、ユーザーが Web サイトにアクセスしたときのセッションデータのキャッシュなどが考えられます。<span class="command"><strong>memcached</strong></span> は、設定された明示的な失効時間をオブジェクトが要求された現在の時間と比較する遅延失効メカニズムを使用します。失効していないオブジェクトだけが返されます。
      </p><p>
        キャッシュからオブジェクトを明示的に削除するときに失効時間を設定することもできます。この場合、失効時間は実際にはタイムアウトであり、特定のキーの値を設定しようとして拒否される期間を示します。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ha-memcached-using-hashtypes"></a>16.6.2.4 <span class="command"><strong>memcached</strong></span> のハッシュ化/分布タイプ</h4></div></div></div><p>
        <span class="command"><strong>memcached</strong></span> クライアントインタフェースは、特定の <span class="command"><strong>memcached</strong></span> インスタンスのデータを設定または取得するときにどのホストを使用すべきかを決定するため、マルチサーバー構成で使用される異なる分布アルゴリズムをサポートします。値を取得または設定すると、指定されたキーからハッシュが作成され、構成済みサーバーのリストからホストを選択するために使用されます。ハッシュ化メカニズムは指定されたキーをハッシュのベースとして使用するため、設定操作と取得操作の両方で同じサーバーが選択されます。
      </p><p>
        このプロセスは次のように考えることができます。一連のサーバー (a、b、および c) があり、クライアントは格納または取得されるキーに基づく整数を返すハッシュ化アルゴリズムを使用します。生成された値を使用して、クライアントに構成されたサーバーリストからサーバーが選択されます。<span class="command"><strong>memcache</strong></span> クライアント内のもっとも標準的なクライアントハッシュ化では、構成された <span class="command"><strong>memcached</strong></span> サーバーの数で値を割る簡単なモジュラス計算が使用されます。このプロセスは、擬似コードで次のように要約できます。
      </p><pre class="programlisting">
@memcservers = ['a.memc','b.memc','c.memc'];
$value = hash($key);
$chosen = $value % length(@memcservers);
</pre><p>
        上記を値で置き換えると:
      </p><pre class="programlisting">
@memcservers = ['a.memc','b.memc','c.memc'];
$value = hash('myid');
$chosen = 7009 % 3;
</pre><p>
        上の例では、クライアントのハッシュ化アルゴリズムによってインデックス 1 (<code class="literal">7009 % 3 = 1</code>) のサーバーが選択され、そのサーバーでキーと値が格納または取得されます。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          この選択とハッシュ化のプロセスは、使用している <span class="command"><strong>memcached</strong></span> クライアントによって自動的に処理されます。ユーザーは使用する <span class="command"><strong>memcached</strong></span> サーバーのリストを提供するだけで済みます。
        </p></div><p>
        次の<a class="xref" href="ha-overview.html#ha-memcached-using-hashtypes-fig-selection" title="図 16.5 memcached のハッシュ選択">図16.5「<span class="command">memcached</span> のハッシュ選択」</a>は、これをグラフィカルに表現したものです。
      </p><div class="figure"><a name="ha-memcached-using-hashtypes-fig-selection"></a><p class="title"><b>図 16.5 <span class="command">memcached</span> のハッシュ選択</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/memcached-selection.png" width="513" height="228" alt="memcached のハッシュ選択"></div></div></div><br class="figure-break"><p>
        同じハッシュと選択のプロセスは、<span class="command"><strong>memcached</strong></span> クライアント内の指定されたキーの操作で実行されます。
      </p><p>
        この方法を使用することで、いくつかのメリットが得られます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            接続するサーバーのハッシュ化と選択がクライアントの内部で完全に処理されます。これにより、接続する正しいマシンを決定するためにネットワーク通信を行う必要がなくなります。
          </p></li><li class="listitem"><p>
            <span class="command"><strong>memcached</strong></span> サーバーの決定がクライアントの内部で完全に行われるため、実行される操作 (設定、取得、増分など) に関係なくサーバーを自動的に選択できます。
          </p></li><li class="listitem"><p>
            この決定はクライアント内で処理されるため、ハッシュ化アルゴリズムは特定のキーに対して同じ値を返します。サーバー環境の違いによって値が影響を受けたり、リセットされたりすることはありません。
          </p></li><li class="listitem"><p>
            選択は非常に高速です。キー値に対するハッシュ化アルゴリズムは高速であり、その結果、使用可能なマシンの単純な配列からサーバーが選択されます。
          </p></li><li class="listitem"><p>
            クライアント側のハッシュ化を使用することで、各 <span class="command"><strong>memcached</strong></span> サーバー間のデータの分布が簡略化されます。ハッシュ化アルゴリズムによって返される値の自然な分布では、使用可能なサーバー間でキーが自動的に分散されます。
          </p></li></ul></div><p>
        クライアント内で構成されているサーバーリストが同じままであれば、格納されている同じキーによって同じ値が返されるため、同じサーバーが選択されます。
      </p><p>
        ただし、同じハッシュ化メカニズムを使用しないと、同じデータが別のインタフェースによって別のサーバーに記録され、<span class="command"><strong>memcached</strong></span> の領域が無駄になるだけでなく、情報の相違につながる可能性があります。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          マルチインタフェース互換のハッシュ化メカニズムを使用する 1 つの方法は、<code class="literal">libmemcached</code> ライブラリと関連インタフェースを使用することです。異なる言語 (C、Ruby、Perl、および Python を含む) のインタフェースが同じクライアントライブラリインタフェースを使用するため、ID から常に同じハッシュコードが生成されます。
        </p></div><p>
        クライアント側でサーバーを選択する場合の問題は、<span class="command"><strong>memcached</strong></span> サーバーを使用する各クライアントでサーバーリスト (それらの順番を含む) の整合性を維持し、それらのサーバーを使用可能にしておく<span class="emphasis"><em>必要がある</em></span>ことです。次のときに、キーに対して操作を実行しようとする場合:

        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              使用可能なインスタンスのリストに新しい <span class="command"><strong>memcached</strong></span> インスタンスを追加した
            </p></li><li class="listitem"><p>
              使用可能なインスタンスのリストから <span class="command"><strong>memcached</strong></span> インスタンスを削除した
            </p></li><li class="listitem"><p>
              <span class="command"><strong>memcached</strong></span> インスタンスの順序が変更された
            </p></li></ul></div><p>

        特定のキーに対してハッシュ化アルゴリズムが使用されるときにサーバーリストが異なる場合は、ハッシュ計算によってリストから別のサーバーが選択される可能性があります。
      </p><p>
        次の例の <code class="literal">new.memc</code> のように、サーバーリストに新しい <span class="command"><strong>memcached</strong></span> インスタンスが追加された場合は、同じキー (<code class="literal">myid</code>) を使用する GET 操作によってキャッシュミスが発生します。これは、このキーから同じ値が算出され、サーバーの配列から同じインデックスが選択されるが、インデックス 2 はデータが本来格納されているサーバー <code class="literal">c.memc</code> ではなく新しいサーバーを指すようになったためです。このため、別の <span class="command"><strong>memcached</strong></span> インスタンスのキャッシュにそのキーが存在するにもかかわらず、キャッシュミスが発生します。
      </p><div class="figure"><a name="ha-memcached-using-hashtypes-fig-addselect"></a><p class="title"><b>図 16.6 新しい <span class="command">memcached</span> インスタンスを含む <span class="command">memcached</span> のハッシュ選択</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/memcached-addselect.png" width="626" height="228" alt="新しい memcached インスタンスを含む memcached のハッシュ選択"></div></div></div><br class="figure-break"><p>
        これは、<code class="literal">c.memc</code> と <code class="literal">new.memc</code> の両方にキー <code class="literal">myid</code> の情報が含まれることを意味しますが、このキーに対して各サーバーに格納される情報は各インスタンスで異なる可能性があります。より重要な問題は、新しいサーバーによってキーの分布が変わるにつれて、データ取得時のキャッシュミスの数が大幅に増加することです。さらに、この結果として <span class="command"><strong>memcached</strong></span> インスタンスにキャッシュされているデータを再構築する必要があるため、データベースの読み取り回数が増加します。
      </p><p>
        クライアントに構成されているサーバーリストをアクティブに管理し、構成済みの <span class="command"><strong>memcached</strong></span> インスタンスが使用可能として識別されたときに各インスタンスを追加および削除する場合も、同じ結果になる可能性があります。たとえば、ある <span class="command"><strong>memcached</strong></span> インスタンスが接続できなくなったことをクライアントが検出したときにそのインスタンスを削除すると、ここに示したようにサーバーの選択が失敗する可能性があります。
      </p><p>
        これによって重大な問題が発生してキャッシュが無効になることを防ぐため、サーバーの選択に使用するハッシュ化アルゴリズムを選択できます。ハッシュ化アルゴリズムには、<span class="emphasis"><em>整合</em></span>と<span class="emphasis"><em>モジュラ</em></span>の 2 つの一般的なタイプがあります。
      </p><p>
        <span class="emphasis"><em>整合</em></span>ハッシュ化アルゴリズムでは、構成済みサーバーのリストが変更された場合でも、同じキーをサーバーリストに適用すると、同じサーバーを使用してキーが格納または取得されます。これは、構成リストのサーバーを追加および削除しながら、特定のキーに対して常に同じサーバーを使用できることを意味します。使用可能な整合ハッシュ化アルゴリズムには、Ketama と Wheel の 2 つのタイプがあります。どちらのタイプも <code class="literal">libmemcached</code> によってサポートされ、PHP および Java 用の実装が入手可能です。
      </p><p>
        整合ハッシュ化アルゴリズムにはいくつかの制限があります。既存の構成済みサーバーのリストにサーバーを追加すると、通常の分布の一部として新しいサーバーにキーが分配されます。リストからサーバーを削除すると、そのキーはリスト内の別のサーバーに再割り当てされるため、キャッシュに情報を再度移入する必要があります。また、整合ハッシュ化アルゴリズムでは、複数のクライアント間でサーバーを一貫して選択する必要があるにもかかわらず、各クライアントに異なるサーバーリストが含まれているという問題は解決されません。整合性が適用されるのは、1 つのクライアントの内部だけです。
      </p><p>
        <span class="emphasis"><em>モジュラ</em></span>ハッシュ化アルゴリズムでは、クライアントはハッシュを計算して構成済みサーバーリストからサーバーを選択することにより、サーバーを選択します。サーバーリストが変わると、モジュラハッシュ化アルゴリズムを使用して選択されるサーバーも変わります。この結果、前述の動作が発生します。サーバーリストの変更は、データの取得時に別のサーバーが選択されることを意味し、キャッシュに情報が再移入されるため、キャッシュミスとデータベース負荷の増大につながります。
      </p><p>
        各クライアントで <span class="command"><strong>memcached</strong></span> インスタンスを 1 つだけ使用する場合や、クライアントに構成された <span class="command"><strong>memcached</strong></span> サーバーのリストが一度も変更されていない場合は、ハッシュ化アルゴリズムの選択による大きな効果もないため、重要ではありません。
      </p><p>
        サーバーを定期的に変更する場合や、多数のクライアントで共有される共通のサーバーセットを使用する場合は、整合ハッシュ化アルゴリズムを使用することで、確実にキャッシュデータの重複を防ぎ、データを均等に分配しやすくなります。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ha-memcached-using-dtrace"></a>16.6.2.5 <span class="command"><strong>memcached</strong></span> と DTrace の使用</h4></div></div></div><a class="indexterm" name="idm139979057638512"></a><p>
        <span class="command"><strong>memcached</strong></span> には、サーバー動作のモニターに使用できるいくつかの異なる DTrace プローブが含まれています。含まれているプローブは、キー/値ペアの追加、更新、または削除時の個々の接続、スラブ割り当て、およびハッシュテーブルの変更をモニターできます。
      </p><p>
        DTrace および DTrace スクリプトの作成の詳細は、『<a class="ulink" href="http://docs.oracle.com/cd/E19253-01/819-5488/" target="_top">DTrace ユーザーガイド</a>』をお読みください。
      </p><p>
        <span class="command"><strong>memcached</strong></span> 1.2.6 で追加された DTrace プローブのサポートには、アプリケーションをモニターしやすくするいくつかの DTrace プローブが含まれています。DTrace は、Solaris 10、OpenSolaris、OS X 10.5、および FreeBSD でサポートされます。<span class="command"><strong>memcached</strong></span> で DTrace プローブを有効にするには、ソースからビルドし、<code class="option">--enable-dtrace</code> オプションを使用します。詳細については、<a class="xref" href="ha-overview.html#ha-memcached-install" title="16.6.1 memcached のインストール">セクション16.6.1「<span class="command"><strong>memcached</strong></span> のインストール」</a>を参照してください。
      </p><p>
        <span class="command"><strong>memcached</strong></span> でサポートされるプローブは次のとおりです。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">conn-allocate(connid)</code>
          </p><p>
            接続プールから接続オブジェクトが割り当てられたときに起動します。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">connid</code>: 接続 ID。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">conn-release(connid)</code>
          </p><p>
            接続オブジェクトが接続プールに解放されたときに起動します。
          </p><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">connid</code>: 接続 ID。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">conn-create(ptr)</code>
          </p><p>
            新しい接続オブジェクトが作成される (つまり、接続プールに空き接続オブジェクトがない) ときに起動します。
          </p><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">ptr</code>: 接続オブジェクトへのポインタ
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">conn-destroy(ptr)</code>
          </p><p>
            接続オブジェクトが破壊されるときに起動します。
          </p><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">ptr</code>: 接続オブジェクトへのポインタ。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">conn-dispatch(connid, threadid)</code>
          </p><p>
            メインまたは接続管理スレッドからワーカースレッドに接続がディスパッチされるときに起動します。
          </p><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">connid</code>: 接続 ID。
              </p></li><li class="listitem"><p>
                <code class="literal">threadid</code>: スレッド ID。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">slabs-allocate(size, slabclass, slabsize, ptr)</code>
          </p><p>
            スラブアロケータからメモリーを割り当てます。
          </p><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">size</code>: 要求されたサイズ。
              </p></li><li class="listitem"><p>
                <code class="literal">slabclass</code>: 割り当てはこのクラスで行われます。
              </p></li><li class="listitem"><p>
                <code class="literal">slabsize</code>: このクラスの各項目のサイズ。
              </p></li><li class="listitem"><p>
                <code class="literal">ptr</code>: 割り当てたメモリーへのポインタ。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">slabs-allocate-failed(size, slabclass)</code>
          </p><p>
            メモリーの割り当てに失敗しました (メモリー不足)。
          </p><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">size</code>: 要求されたサイズ。
              </p></li><li class="listitem"><p>
                <code class="literal">slabclass</code>: 要求を満たすことができなかったクラス。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">slabs-slabclass-allocate(slabclass)</code>
          </p><p>
            スラブクラスに追加の領域が必要なときに起動します。
          </p><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">slabclass</code>: 追加のメモリーを必要とするクラス。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">slabs-slabclass-allocate-failed(slabclass)</code>
          </p><p>
            メモリーの割り当てに失敗しました (メモリー不足)。
          </p><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">slabclass</code>: 追加のメモリーを取得できなかったクラス。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">slabs-free(size, slabclass, ptr)</code>
          </p><p>
            メモリーを解放します。
          </p><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">size</code>: 解放するメモリーの量 (バイト単位)。
              </p></li><li class="listitem"><p>
                <code class="literal">slabclass</code>: メモリーが属しているクラス。
              </p></li><li class="listitem"><p>
                <code class="literal">ptr</code>: 解放するメモリーへのポインタ。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">assoc-find(key, depth)</code>
          </p><p>
            ハッシュテーブルで指定されたキーが検索されたときに起動します。これら 2 つの要素によって、ハッシュ関数がどの程度適切に機能しているかを把握できます。トラバーサルは、関数があまり最適ではなく、CPU の処理能力が浪費されていることを示します。
          </p><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">key</code>: 検索されたキー。
              </p></li><li class="listitem"><p>
                <code class="literal">depth</code>: ハッシュテーブルのリストの深さ。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">assoc-insert(key, nokeys)</code>
          </p><p>
            新しい項目が挿入されたときに起動します。
          </p><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">key</code>: 挿入されたキー。
              </p></li><li class="listitem"><p>
                <code class="literal">nokeys</code>: 現在格納されているキーの総数 (挿入が要求されたキーを含む)。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">assoc-delete(key, nokeys)</code>
          </p><p>
            新しい項目が削除されたときに起動します。
          </p><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">key</code>: 削除されたキー。
              </p></li><li class="listitem"><p>
                <code class="literal">nokeys</code>: 現在格納されているキーの総数 (削除が要求されたキーを除く)。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">item-link(key, size)</code>
          </p><p>
            キャッシュ内で項目がリンクされるときに起動します。
          </p><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">key</code>: 項目のキー。
              </p></li><li class="listitem"><p>
                <code class="literal">size</code>: データのサイズ。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">item-unlink(key, size)</code>
          </p><p>
            項目が削除されるときに起動します。
          </p><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">key</code>: 項目のキー。
              </p></li><li class="listitem"><p>
                <code class="literal">size</code>: データのサイズ。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">item-remove(key, size)</code>
          </p><p>
            項目の参照カウントが減ったときに起動します。
          </p><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">key</code>: 項目のキー。
              </p></li><li class="listitem"><p>
                <code class="literal">size</code>: データのサイズ。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">item-update(key, size)</code>
          </p><p>
            「最終参照」時間が更新されたときに起動します。
          </p><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">key</code>: 項目のキー。
              </p></li><li class="listitem"><p>
                <code class="literal">size</code>: データのサイズ。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">item-replace(oldkey, oldsize, newkey, newsize)</code>
          </p><p>
            項目が別の項目に置き換えられるときに起動します。
          </p><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">oldkey</code>: 置き換えられる項目のキー。
              </p></li><li class="listitem"><p>
                <code class="literal">oldsize</code>: 古い項目のサイズ。
              </p></li><li class="listitem"><p>
                <code class="literal">newkey</code>: 新しい項目のキー。
              </p></li><li class="listitem"><p>
                <code class="literal">newsize</code>: 新しい項目のサイズ。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">process-command-start(connid, request, size)</code>
          </p><p>
            コマンドの処理が開始したときに起動します。
          </p><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">connid</code>: 接続 ID。
              </p></li><li class="listitem"><p>
                <code class="literal">request</code>: 受信された要求。
              </p></li><li class="listitem"><p>
                <code class="literal">size</code>: 要求のサイズ。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">process-command-end(connid, response, size)</code>
          </p><p>
            コマンドの処理が終了したときに起動します。
          </p><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">connid</code>: 接続 ID。
              </p></li><li class="listitem"><p>
                <code class="literal">response</code>: クライアントに返信される応答。
              </p></li><li class="listitem"><p>
                <code class="literal">size</code>: 応答のサイズ。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">command-get(connid, key, size)</code>
          </p><p>
            <code class="literal">get</code> コマンドに対して起動します。
          </p><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">connid</code>: 接続 ID。
              </p></li><li class="listitem"><p>
                <code class="literal">key</code>: 要求されたキー。
              </p></li><li class="listitem"><p>
                <code class="literal">size</code>: このキーのデータのサイズ (見つからない場合は -1)。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">command-gets(connid, key, size, casid)</code>
          </p><p>
            <code class="literal">gets</code> コマンドに対して起動します。
          </p><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">connid</code>: 接続 ID。
              </p></li><li class="listitem"><p>
                <code class="literal">key</code>: 要求されたキー。
              </p></li><li class="listitem"><p>
                <code class="literal">size</code>: このキーのデータのサイズ (見つからない場合は -1)。
              </p></li><li class="listitem"><p>
                <code class="literal">casid</code>: 項目の CAS ID。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">command-add(connid, key, size)</code>
          </p><p>
            <code class="literal">add</code> コマンドに対して起動します。
          </p><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">connid</code>: 接続 ID。
              </p></li><li class="listitem"><p>
                <code class="literal">key</code>: 要求されたキー。
              </p></li><li class="listitem"><p>
                <code class="literal">size</code>: このキーのデータの新しいサイズ (見つからない場合は -1)。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">command-set(connid, key, size)</code>
          </p><p>
            <code class="literal">set</code> コマンドに対して起動します。
          </p><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">connid</code>: 接続 ID。
              </p></li><li class="listitem"><p>
                <code class="literal">key</code>: 要求されたキー。
              </p></li><li class="listitem"><p>
                <code class="literal">size</code>: このキーのデータの新しいサイズ (見つからない場合は -1)。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">command-replace(connid, key, size)</code>
          </p><p>
            <code class="literal">replace</code> コマンドに対して起動します。
          </p><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">connid</code>: 接続 ID。
              </p></li><li class="listitem"><p>
                <code class="literal">key</code>: 要求されたキー。
              </p></li><li class="listitem"><p>
                <code class="literal">size</code>: このキーのデータの新しいサイズ (見つからない場合は -1)。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">command-prepend(connid, key, size)</code>
          </p><p>
            <code class="literal">prepend</code> コマンドに対して起動します。
          </p><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">connid</code>: 接続 ID。
              </p></li><li class="listitem"><p>
                <code class="literal">key</code>: 要求されたキー。
              </p></li><li class="listitem"><p>
                <code class="literal">size</code>: このキーのデータの新しいサイズ (見つからない場合は -1)。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">command-append(connid, key, size)</code>
          </p><p>
            <code class="literal">append</code> コマンドに対して起動します。
          </p><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">connid</code>: 接続 ID。
              </p></li><li class="listitem"><p>
                <code class="literal">key</code>: 要求されたキー。
              </p></li><li class="listitem"><p>
                <code class="literal">size</code>: このキーのデータの新しいサイズ (見つからない場合は -1)。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">command-cas(connid, key, size, casid)</code>
          </p><p>
            <code class="literal">cas</code> コマンドに対して起動します。
          </p><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">connid</code>: 接続 ID。
              </p></li><li class="listitem"><p>
                <code class="literal">key</code>: 要求されたキー。
              </p></li><li class="listitem"><p>
                <code class="literal">size</code>: このキーのデータのサイズ (見つからない場合は -1)。
              </p></li><li class="listitem"><p>
                <code class="literal">casid</code>: 要求された CAS ID。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">command-incr(connid, key, val)</code>
          </p><p>
            <code class="literal">incr</code> コマンドに対して起動します。
          </p><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">connid</code>: 接続 ID。
              </p></li><li class="listitem"><p>
                <code class="literal">key</code>: 要求されたキー。
              </p></li><li class="listitem"><p>
                <code class="literal">val</code>: 新しい値。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">command-decr(connid, key, val)</code>
          </p><p>
            <code class="literal">decr</code> コマンドに対して起動します。
          </p><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">connid</code>: 接続 ID。
              </p></li><li class="listitem"><p>
                <code class="literal">key</code>: 要求されたキー。
              </p></li><li class="listitem"><p>
                <code class="literal">val</code>: 新しい値。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">command-delete(connid, key, exptime)</code>
          </p><p>
            <code class="literal">delete</code> コマンドに対して起動します。
          </p><p>
            引数:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">connid</code>: 接続 ID。
              </p></li><li class="listitem"><p>
                <code class="literal">key</code>: 要求されたキー。
              </p></li><li class="listitem"><p>
                <code class="literal">exptime</code>: 失効時間。
              </p></li></ul></div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ha-memcached-using-memory"></a>16.6.2.6 <span class="command"><strong>memcached</strong></span> 内でのメモリー割り当て</h4></div></div></div><p>
        <span class="command"><strong>memcached</strong></span> を最初に起動したときは、構成したメモリーが自動的に割り当てられません。代わりに、<span class="command"><strong>memcached</strong></span> はキャッシュへの情報保存が開始されたあとで、はじめて物理メモリーの割り当てと確保を開始します。
      </p><p>
        キャッシュにデータを格納し始めたときに、<span class="command"><strong>memcached</strong></span> は項目上のデータのメモリーを項目単位では割り当てません。代わりに、スラブ割り当てを使用して、メモリーの使用量を最適化し、キャッシュの情報が失効したときのメモリーの断片化を防止します。
      </p><p>
        スラブ割り当てを使用すると、メモリーが 1M バイトのブロック単位で確保されます。スラブは、同じサイズのいくつかのブロックに分割されます。キャッシュに値を格納しようとすると、<span class="command"><strong>memcached</strong></span> はキャッシュに追加される値のサイズをチェックし、その項目に適したサイズの割り当てを含むスラブを特定します。項目のサイズに合うスラブがすでに存在する場合は、そのスラブ内のブロックに項目が書き込まれます。
      </p><p>
        新しい項目が既存のどのブロックのサイズよりも大きい場合は、新しいスラブが作成され、適切なサイズのブロックに分割されます。適切なブロックサイズを持つスラブがすでに存在するが、空きブロックがない場合は、新しいスラブが作成されます。既存の項目を、そのキーに対する既存のブロック割り当てより大きいデータで更新すると、そのキーは適切なスラブに再割り当てされます。
      </p><p>
        たとえば、最小ブロックのデフォルトのサイズは 88 バイト (値の 40 バイトと、キーおよびフラグデータに対するデフォルトの 48 バイト) です。キャッシュに最初に格納する項目のサイズが 40 バイト未満である場合は、88 バイトのブロックサイズを持つスラブが作成され、値が格納されます。
      </p><p>
        格納予定のデータサイズがこの値より大きい場合は、ブロックサイズをチャンクサイズ係数の単位で増加させ、値を保持できる大きさのブロックサイズが特定されます。ブロックサイズは常にスケール係数の関数であり、チャンクサイズにちょうど分割できるブロックサイズに丸められます。
      </p><p>
        この構造の例については、<a class="xref" href="ha-overview.html#ha-memcached-fig-slabs" title="図 16.7 memcached でのメモリー割り当て">図16.7「<span class="command">memcached</span> でのメモリー割り当て」</a>を参照してください。
      </p><div class="figure"><a name="ha-memcached-fig-slabs"></a><p class="title"><b>図 16.7 <span class="command">memcached</span> でのメモリー割り当て</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/memcached-memalloc.png" width="406" height="232" alt="memcached でのメモリー割り当て"></div></div></div><br class="figure-break"><p>
        この結果、<span class="command"><strong>memcached</strong></span> に割り当てられたメモリーの範囲内に複数のページが割り当てられます。各ページは、(デフォルトで) 1M バイトのサイズを持ち、キー/値ペアを格納するのに必要なチャンクサイズに従って異なる数のチャンクに分割されます。各インスタンスには複数のページが割り当てられ、特定のサイズのチャンクを必要とする新しい項目を作成する必要があるときは、常にページが作成されます。スラブは複数のページで構成される場合があり、スラブ内の各ページには同じ数のチャンクが含まれています。
      </p><p>
        新しいスラブのチャンクサイズは、ベースとなるチャンクサイズとチャンクサイズ増大係数の組み合わせによって決まります。たとえば、初期のチャンクサイズが 104 バイトで、デフォルトのチャンクサイズ増大係数 (1.25) が使用される場合、次に割り当てられるチャンクサイズは 104*1.25 にもっとも適合する 2 の累乗 (136 バイト) になります。
      </p><p>
        このようにしてページを割り当てることで、メモリーの断片化が回避されます。ただし、格納するオブジェクトの分布によっては、項目のサイズが大幅に異なる場合に、スラブとチャンクが効果的に分布しなくなる可能性があります。たとえば、各チャンクサイズ内の項目数が比較的少ない場合は、割り当てられた各ページにごく少数のチャンクしか存在しないため、多くのメモリーが無駄になる可能性があります。
      </p><p>
        <code class="literal">-f</code> コマンド行オプションを使用して増大係数を調整すると、この影響を軽減できます。このオプションは、割り当てられたチャンクとスラブをより効果的に利用できるように、適用される増大係数を調整します。現在のスラブ割り当ての統計を確認する方法については、<a class="xref" href="ha-overview.html#ha-memcached-stats-slabs" title="16.6.4.2 memcached のスラブ統計">セクション16.6.4.2「<span class="command"><strong>memcached</strong></span> のスラブ統計」</a>を参照してください。
      </p><p>
        オペレーティングシステムでサポートされる場合は、<code class="literal">-L</code> コマンド行オプションを指定して <span class="command"><strong>memcached</strong></span> を起動することもできます。このオプションは、起動中に大規模メモリーページを使用してすべてのメモリーを事前に割り当てます。これにより、CPU メモリーキャッシュ内のミスの数が減ってパフォーマンスが向上する可能性があります。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ha-memcached-using-threads"></a>16.6.2.7 <span class="command"><strong>memcached</strong></span> のスレッドサポート</h4></div></div></div><p>
        <span class="command"><strong>memcached</strong></span> をソースからビルドするときに内部のスレッド実装を有効にすると、<span class="command"><strong>memcached</strong></span> は <code class="literal">libevent</code> システムに加えて複数のスレッドを使用して要求を処理します。
      </p><p>
        有効にすると、スレッド実装は次のように動作します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            スレッド化は、コード内の関数をラップして、同じグローバル構造の同時更新から保護する基本的な機能を提供することによって処理されます。
          </p></li><li class="listitem"><p>
            各スレッドは、独自の <code class="literal">libevent</code> インスタンスを使用してパフォーマンスを向上させます。
          </p></li><li class="listitem"><p>
            TCP/IP 接続は、TCP/IP ソケットで待機する単独のスレッドによって処理されます。その後、各接続は単純なラウンドロビン方式でいずれかのアクティブスレッドに分配されます。その後、接続が開いている間は、各接続はこのスレッド内でのみ動作します。
          </p></li><li class="listitem"><p>
            UDP 接続については、すべてのスレッドが 1 つの UDP ソケットで受信要求を待機します。現在別の要求を処理していないスレッドは、受信パケットを無視します。残りの (ビジーではない) スレッドのいずれかが要求を読み取り、応答を送信します。この実装では、要求を処理する可能性があるスレッドがスリープから復帰するため、CPU 負荷が増加する可能性があります。
          </p></li></ul></div><p>
        スレッドを使用すると、ハッシュテーブルを更新する要求を個々のスレッド間で分散できるため、複数の CPU コアが使用可能なサーバーではパフォーマンスが向上する可能性があります。使用されるロックメカニズムのオーバーヘッドを最小限に抑えるには、さまざまなスレッド値を試して、特定のワークロード内の要求数とタイプに基づく最適なパフォーマンスを実現してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ha-memcached-using-logs"></a>16.6.2.8 <span class="command"><strong>memcached</strong></span> ログ</h4></div></div></div><p>
        <code class="option">-v</code>、<code class="option">-vv</code>、または <code class="option">-vvv</code> オプションを使用して冗長モードを有効にすると、<span class="command"><strong>memcached</strong></span> が出力する情報に実行中の操作の詳細が追加されます。
      </p><p>
        冗長オプションを指定しないと、通常は <span class="command"><strong>memcached</strong></span> の正常な動作中に出力が生成されません。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <span class="bold"><strong><code class="literal">-v</code> 使用時の出力</strong></span>
          </p><p>
            もっとも低い冗長レベルでは、次が表示されます。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                エラーおよび警告
              </p></li><li class="listitem"><p>
                一時的なエラー
              </p></li><li class="listitem"><p>
                プロトコルおよびソケットのエラー (使用可能な接続の使い果たしなど)
              </p></li><li class="listitem"><p>
                登録された個々のクライアント接続 (使用されているソケットディスクリプタ番号とプロトコルを含む)。
              </p><p>
                例:
              </p><pre class="programlisting">
32: Client using the ascii protocol
33: Client using the ascii protocol
</pre><p>
                ソケットディスクリプタはクライアントが接続されている間だけ有効になります。永続的ではない接続は表示されない場合があります。
              </p></li></ul></div><p>
            このレベルで出力されるエラーメッセージの例を次に示します。
          </p><pre class="programlisting">
&lt;%d send buffer was %d, now %d
Can't listen for events on fd %d
Can't read from libevent pipe
Catastrophic: event fd doesn't match conn fd!
Couldn't build response
Couldn't realloc input buffer
Couldn't update event
Failed to build UDP headers
Failed to read, and not due to blocking
Too many open connections
Unexpected state %d
</pre></li><li class="listitem"><p>
            <span class="bold"><strong><code class="literal">-vv</code> 使用時の出力</strong></span>
          </p><p>
            2 番目の冗長レベルを使用すると、プロトコルの動作、更新されたキー、チャンクとネットワークの動作および詳細に関するより詳しい情報が提供されます。
          </p><p>
            この冗長レベルで <span class="command"><strong>memcached</strong></span> を起動すると、最初に個々のスラブクラスのサイズ、チャンクサイズ、およびスラブあたりのエントリ数が表示されます。これらは、スラブが割り当てられたことを示すのではなく、データが追加されたときに作成されるスラブを示します。情報を送信するために使用される待機キューおよびバッファーに関する情報も表示されます。デフォルトのメモリーおよび増大係数を含む TCP/IP ベースシステムに関して生成された出力の例を次に示します。
          </p><pre class="programlisting">
shell&gt; memcached -vv
slab class   1: chunk size     80 perslab 13107
slab class   2: chunk size    104 perslab 10082
slab class   3: chunk size    136 perslab  7710
slab class   4: chunk size    176 perslab  5957
slab class   5: chunk size    224 perslab  4681
slab class   6: chunk size    280 perslab  3744
slab class   7: chunk size    352 perslab  2978
slab class   8: chunk size    440 perslab  2383
slab class   9: chunk size    552 perslab  1899
slab class  10: chunk size    696 perslab  1506
slab class  11: chunk size    872 perslab  1202
slab class  12: chunk size   1096 perslab   956
slab class  13: chunk size   1376 perslab   762
slab class  14: chunk size   1720 perslab   609
slab class  15: chunk size   2152 perslab   487
slab class  16: chunk size   2696 perslab   388
slab class  17: chunk size   3376 perslab   310
slab class  18: chunk size   4224 perslab   248
slab class  19: chunk size   5280 perslab   198
slab class  20: chunk size   6600 perslab   158
slab class  21: chunk size   8256 perslab   127
slab class  22: chunk size  10320 perslab   101
slab class  23: chunk size  12904 perslab    81
slab class  24: chunk size  16136 perslab    64
slab class  25: chunk size  20176 perslab    51
slab class  26: chunk size  25224 perslab    41
slab class  27: chunk size  31536 perslab    33
slab class  28: chunk size  39424 perslab    26
slab class  29: chunk size  49280 perslab    21
slab class  30: chunk size  61600 perslab    17
slab class  31: chunk size  77000 perslab    13
slab class  32: chunk size  96256 perslab    10
slab class  33: chunk size 120320 perslab     8
slab class  34: chunk size 150400 perslab     6
slab class  35: chunk size 188000 perslab     5
slab class  36: chunk size 235000 perslab     4
slab class  37: chunk size 293752 perslab     3
slab class  38: chunk size 367192 perslab     2
slab class  39: chunk size 458992 perslab     2
&lt;26 server listening (auto-negotiate)
&lt;29 server listening (auto-negotiate)
&lt;30 send buffer was 57344, now 2097152
&lt;31 send buffer was 57344, now 2097152
&lt;30 server listening (udp)
&lt;30 server listening (udp)
&lt;31 server listening (udp)
&lt;30 server listening (udp)
&lt;30 server listening (udp)
&lt;31 server listening (udp)
&lt;31 server listening (udp)
&lt;31 server listening (udp)
</pre><p>
            この冗長レベルを使用すると、異なるメモリー割り当てを含むスラブに対して使用される増大係数の効果を効果的にチェックできます。また、その結果を使用して、キャッシュに格納するデータに合わせて増大係数を調整できます。たとえば、増大係数を 4 に設定した (各スラブのサイズが 4 倍になった) 場合:
          </p><pre class="programlisting">
shell&gt; memcached -f 4 -m 1g -vv
slab class   1: chunk size     80 perslab 13107
slab class   2: chunk size    320 perslab  3276
slab class   3: chunk size   1280 perslab   819
slab class   4: chunk size   5120 perslab   204
slab class   5: chunk size  20480 perslab    51
slab class   6: chunk size  81920 perslab    12
slab class   7: chunk size 327680 perslab     3
...
</pre><p>
            この冗長レベルでは、キャッシュの使用中に、キーおよびその他の情報の格納とリカバリに関する詳細情報も出力されます。一般的な設定/取得および増分/減分操作中の出力の例を次に示します。
          </p><pre class="programlisting">
32: Client using the ascii protocol
&lt;32 set my_key 0 0 10
&gt;32 STORED
&lt;32 set object_key 1 0 36
&gt;32 STORED
&lt;32 get my_key 
&gt;32 sending key my_key
&gt;32 END
&lt;32 get object_key 
&gt;32 sending key object_key
&gt;32 END
&lt;32 set key 0 0 6
&gt;32 STORED
&lt;32 incr key 1
&gt;32 789544
&lt;32 decr key 1
&gt;32 789543
&lt;32 incr key 2
&gt;32 789545
&lt;32 set my_key 0 0 10
&gt;32 STORED
&lt;32 set object_key 1 0 36
&gt;32 STORED
&lt;32 get my_key 
&gt;32 sending key my_key
&gt;32 END
&lt;32 get object_key 
&gt;32 sending key object_key1 1 36

&gt;32 END
&lt;32 set key 0 0 6
&gt;32 STORED
&lt;32 incr key 1
&gt;32 789544
&lt;32 decr key 1
&gt;32 789543
&lt;32 incr key 2
&gt;32 789545
</pre><p>
            クライアント通信中は、各行の最初の文字は情報の流れの方向を示しています。&lt; はクライアントから <span class="command"><strong>memcached</strong></span> サーバーへの通信、&gt; はクライアントへの通信をそれぞれ示します。数字は、この接続のソケットディスクリプタを表す数値です。
          </p></li><li class="listitem"><p>
            <span class="bold"><strong><code class="literal">-vvv</code> 使用時の出力</strong></span>
          </p><p>
            この冗長レベルには、クライアントとの間でコンテンツの読み取りおよび書き込みを行なっている間の、イベントライブラリのさまざまな接続状態の遷移が含まれます。これは、クライアント通信の問題を診断して識別するために使用します。たとえば、この情報を使用して、クライアント操作の読み取り中または操作が返されて完了する前に <span class="command"><strong>memcached</strong></span> がクライアントに情報を返すのに長い時間がかかっているかどうかを判定できます。設定操作の一般的なシーケンスの例を次に示します。
          </p><pre class="programlisting">
&lt;32 new auto-negotiating client connection
32: going from conn_new_cmd to conn_waiting
32: going from conn_waiting to conn_read
32: going from conn_read to conn_parse_cmd
32: Client using the ascii protocol
&lt;32 set my_key 0 0 10
32: going from conn_parse_cmd to conn_nread
&gt; NOT FOUND my_key
&gt;32 STORED
32: going from conn_nread to conn_write
32: going from conn_write to conn_new_cmd
32: going from conn_new_cmd to conn_waiting
32: going from conn_waiting to conn_read
32: going from conn_read to conn_closing
&lt;32 connection closed.
</pre></li></ul></div><p>
        <span class="command"><strong>memcached</strong></span> のすべての冗長レベルは、問題のデバッグ中または調査中に使用するために設計されています。生成される情報 (特に <code class="option">-vvv</code> を使用したとき) の量は、(特に負荷の高いサーバーでは) 重要です。エラー情報を (特にディスクに) 書き出すと、<span class="command"><strong>memcached</strong></span> を使用することで達成したパフォーマンス向上の一部が打ち消される可能性があります。そのため、本番環境や配備環境での使用は推奨されません。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="ha-memcached-interfaces"></a>16.6.3 <span class="command"><strong>memcached</strong></span> アプリケーションの開発</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="ha-overview.html#ha-memcached-operations">16.6.3.1 <span class="command"><strong>memcached</strong></span> の基本操作</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-memcached-mysql-frontend">16.6.3.2 MySQL キャッシュレイヤーとしての <span class="command"><strong>memcached</strong></span> の使用</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-memcached-interfaces-libmemcached">16.6.3.3 C および C++ での <code class="literal">libmemcached</code> の使用</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-memcached-interfaces-perl">16.6.3.4 Perl での MySQL と <span class="command"><strong>memcached</strong></span> の使用</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-memcached-interfaces-python">16.6.3.5 Python での MySQL と <span class="command"><strong>memcached</strong></span> の使用</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-memcached-interfaces-php">16.6.3.6 PHP での MySQL と <span class="command"><strong>memcached</strong></span> の使用</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-memcached-interfaces-ruby">16.6.3.7 Ruby での MySQL と <span class="command"><strong>memcached</strong></span> の使用</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-memcached-interfaces-java">16.6.3.8 Java での MySQL と <span class="command"><strong>memcached</strong></span> の使用</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-memcached-interfaces-protocol">16.6.3.9 <span class="command"><strong>memcached</strong></span> の TCP テキストプロトコルの使用</a></span></dt></dl></div><p>
      いくつかの言語インタフェースを使用すると、アプリケーションから <span class="command"><strong>memcached</strong></span> サーバーを使用して情報を格納および取得できます。<span class="command"><strong>memcached</strong></span> アプリケーションは、Perl、PHP、Python、Ruby、C、Java などの広く使用されている言語で記述できます。
    </p><p>
      <span class="command"><strong>memcached</strong></span> サーバーに格納されたデータは 1 つの文字列 (キー) で参照され、キャッシュへの格納時とキャッシュからの取得時にはそのキーが参照として使用されます。したがって、このキャッシュは大規模な連想配列またはハッシュテーブルのように動作します。キャッシュに格納された情報を構造化またはその他の方法で整理できません。複数テーブルや複合キー値などのデータベースの概念をエミュレートするには、キーとして使用する文字列に追加の情報をエンコードする必要があります。たとえば、特定の緯度と経度に対応する住所を格納または検索するには、これら 2 つの数値を 1 つのカンマ区切り文字列に変換し、それをキーとして使用します。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ha-memcached-operations"></a>16.6.3.1 <span class="command"><strong>memcached</strong></span> の基本操作</h4></div></div></div><p>
        <span class="command"><strong>memcached</strong></span> のインタフェースは、キャッシュ内の情報を格納および取得するために次のメソッドをサポートします。これらは、言語固有のしくみが異なる可能性がありますが、異なるすべての API 間で一貫しています。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="function">get(<em class="replaceable"><code>key</code></em>)</code>: キャッシュから情報を取得します。指定されたキーが存在する場合は、そのキーに関連付けられた値を返します。指定されたキーが存在しない場合は、<code class="literal">NULL</code>、<code class="literal">nil</code>、<code class="literal">undefined</code>、または対応する言語のもっとも近い等価要素を返します。
          </p></li><li class="listitem"><p>
            <code class="function">set(<em class="replaceable"><code>key</code></em>, <em class="replaceable"><code>value</code></em> [, <em class="replaceable"><code>expiry</code></em>])</code>: キャッシュ内のキーに関連付けられた項目を指定された値に設定します。これは、キーがすでに存在する場合は既存の項目を更新し、キーが存在しない場合は新しいキー/値ペアを追加します。失効時間が指定されている場合は、失効時間に達したときにその項目が失効します (そして削除されます)。この時間は秒単位で指定され、値が 30 日未満 (30*24*60*60) の場合は相対時間とみなされ、この値より大きい場合は絶対時間 (エポック) とみなされます。
          </p></li><li class="listitem"><p>
            <code class="function">add(<em class="replaceable"><code>key</code></em>, <em class="replaceable"><code>value</code></em> [, <em class="replaceable"><code>expiry</code></em>])</code>: 指定されたキーがまだ存在しない場合に、そのキーとそれに関連する値をキャッシュに追加します。
          </p></li><li class="listitem"><p>
            <code class="function">replace(<em class="replaceable"><code>key</code></em>, <em class="replaceable"><code>value</code></em> [, <em class="replaceable"><code>expiry</code></em>])</code>: 指定された <code class="literal">key</code> が存在する場合にのみ、そのキーに関連付けられた項目を置き換えます。新しい値は <code class="literal">value</code> パラメータで指定されます。
          </p></li><li class="listitem"><p>
            <code class="function">delete(<em class="replaceable"><code>key</code></em> [, <em class="replaceable"><code>time</code></em>])</code>: <code class="literal">key</code> とそれに関連する項目をキャッシュから削除します。<code class="literal">time</code> を指定すると、指定した <code class="literal">key</code> による別の項目の追加が指定した期間だけブロックされます。
          </p></li><li class="listitem"><p>
            <code class="function">incr(<em class="replaceable"><code>key</code></em> , <em class="replaceable"><code>value</code></em>)</code>: <code class="literal">key</code> に関連付けられた項目を指定された <code class="literal">value</code> だけ増分します。
          </p></li><li class="listitem"><p>
            <code class="function">decr(<em class="replaceable"><code>key</code></em> , <em class="replaceable"><code>value</code></em>)</code>: <code class="literal">key</code> に関連付けられた項目を指定された <code class="literal">value</code> だけ減分します。
          </p></li><li class="listitem"><p>
            <code class="function">flush_all</code>: キャッシュ内の現在の値をすべて無効化 (または失効化) します。これらは技術的にはまだ存在します (削除されません) が、次にアクセスしようとしたときに警告が表示されず破壊されます。
          </p></li></ul></div><p>
        どの実装でも、これらの関数のほとんどまたはすべてが対応するネイティブ言語インタフェースによって複製されています。
      </p><p>
        可能な場合は、データベースの 1 つのカラム値をキャッシュするのではなく、<span class="command"><strong>memcached</strong></span> を使用してすべての項目を格納してください。たとえば、オブジェクト (請求書、ユーザー履歴、またはブログ投稿) に関するレコードを表示するときは、データベースから関連するエントリデータをロードし、それをアプリケーションが通常必要とする内部構造にまとめます。この完成されたオブジェクトをキャッシュに保存します。
      </p><p>
        複雑なデータ構造は直接格納できません。ほとんどのインタフェースは、データを自動的に直列化 (つまり、元のポインタとネストを再構築できるテキスト形式に変換) します。Perl では <code class="literal">Storable</code>、PHP では <code class="literal">serialize</code>、Python では <code class="literal">cPickle</code> (または <code class="literal">Pickle</code>)、Java では <code class="literal">Serializable</code> インタフェースがそれぞれ使用されます。ほとんどの場合、使用される直列化インタフェースはカスタマイズ可能です。<span class="command"><strong>memcached</strong></span> インスタンスに格納されたデータを異なる言語インタフェース間で共有するには、JSON (Javascript Object Notation) などの共通の直列化ソリューションの使用を検討してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ha-memcached-mysql-frontend"></a>16.6.3.2 MySQL キャッシュレイヤーとしての <span class="command"><strong>memcached</strong></span> の使用</h4></div></div></div><p>
        <span class="command"><strong>memcached</strong></span> を使用して MySQL のデータをキャッシュする場合、アプリケーションはデータベースからデータを取得し、適切なキー/値ペアをキャッシュにロードする必要があります。その後の検索は、キャッシュから直接実行できます。
      </p><p>
        MySQL にはクエリーされたデータ用に独自のインメモリーキャッシュメカニズム (<code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>や MySQL クエリーキャッシュなど) が用意されているので、個々のカラム値や行のキャッシュへのロード以外の機能も使用できます。結合クエリーによって複数のテーブルから取得された値や複数の行から集められた結果セットなどの複合値のキャッシュにより適しています。
      </p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注意</div><p>
          <span class="command"><strong>memcached</strong></span> インスタンス内の情報へのアクセスや情報の更新に必要なセキュリティーはないため、キャッシュ内の情報は機密扱い以外のデータに限定してください。マシンにアクセスできるすべてのユーザーが、情報を読み取り、表示し、場合によっては更新できます。データをセキュアな状態に保つには、情報をキャッシュする前に暗号化します。サーバーに接続できるユーザーを制限するには、ネットワークアクセスを無効にするか、IPTables または同様の手法を使用して <span class="command"><strong>memcached</strong></span> ポートへのアクセスを選択したホストのセットに制限します。
        </p></div><p>
        <code class="literal">memcached</code> は、キャッシュが元の設計に組み込まれていなかった場合でも、既存のアプリケーションに導入できます。多くの言語および環境では、アプリケーションの変更はほんの数行です。最初にデータをロードするときにキャッシュからの読み取りを試行し、情報がキャッシュされていなかった場合は古い方法にフォールバックし、データを読み取ったらその情報でキャッシュを更新します。
      </p><p>
        どの言語でも、MySQL のキャッシュソリューションとして <span class="command"><strong>memcached</strong></span> を使用する一般的な手順は次のとおりです。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            キャッシュから項目を要求します。
          </p></li><li class="listitem"><p>
            項目が存在する場合は、その項目データを使用します。
          </p></li><li class="listitem"><p>
            項目が存在しない場合は、MySQL からデータをロードし、その値をキャッシュに格納します。つまり、その値はキャッシュからそれを要求する次のクライアントで使用可能になります。
          </p></li></ol></div><p>
        この手順のフローチャートについては、<a class="xref" href="ha-overview.html#ha-memcached-fig-basicflow" title="図 16.8 一般的な memcached アプリケーションのフローチャート">図16.8「一般的な <span class="command">memcached</span> アプリケーションのフローチャート」</a>を参照してください。
      </p><div class="figure"><a name="ha-memcached-fig-basicflow"></a><p class="title"><b>図 16.8 一般的な <span class="command">memcached</span> アプリケーションのフローチャート</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/memcached-flow.png" width="288" height="437" alt="一般的な memcached アプリケーションのフローチャート"></div></div></div><br class="figure-break"><h5><a name="idm139979057248768"></a><span class="command"><strong>memcached</strong></span> アプリケーションへのデータベースのベストプラクティスの適用</h5><p>
        MySQL のデータをキャッシュするもっとも直接的な方法は、2 カラムのテーブルを使用して、1 つ目のカラムを<a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a>にすることです。<span class="command"><strong>memcached</strong></span> キーの一意性要件のため、データベーススキーマで主キーと<a class="link" href="glossary.html#glos_unique_constraint" title="一意制約">一意制約</a>が適切に使用されていることを確認してください。
      </p><p>
        複数のカラム値を結合して 1 つの <span class="command"><strong>memcached</strong></span> 項目値にする場合は、値をそのコンポーネントに簡単に解析できるようなデータ型を選択してください (たとえば、数値間に区切り文字を使用するなど)。
      </p><p>
        <span class="command"><strong>memcached</strong></span> の検索にもっとも簡単にマップできるクエリーは、<code class="literal">WHERE</code> 句が 1 つで、<code class="literal">=</code> または <code class="literal">IN</code> 演算子を使用するクエリーです。複雑な <code class="literal">WHERE</code> 句や、<code class="literal">&lt;</code>、<code class="literal">&gt;</code>、<code class="literal">BETWEEN</code>、<code class="literal">LIKE</code> などの演算子を使用するものの場合、<span class="command"><strong>memcached</strong></span> ではキーや関連する値を簡単または効率的にスキャンまたはフィルタする方法がないため、通常はこれらの操作をベースとなるデータベースに対する SQL クエリーとして実行します。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ha-memcached-interfaces-libmemcached"></a>16.6.3.3 C および C++ での <code class="literal">libmemcached</code> の使用</h4></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="ha-overview.html#ha-memcached-interfaces-libmemcached-base">16.6.3.3.1 <code class="literal">libmemcached</code> のベース関数</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-memcached-interfaces-libmemcached-servers">16.6.3.3.2 <code class="literal">libmemcached</code> のサーバー関数</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-memcached-interfaces-libmemcached-set">16.6.3.3.3 <code class="literal">libmemcached</code> の設定関数</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-memcached-interfaces-libmemcached-get">16.6.3.3.4 <code class="literal">libmemcached</code> の取得関数</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-memcached-interfaces-libmemcached-behaviors">16.6.3.3.5 <code class="literal">libmemcached</code> の動作の制御</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-memcached-interfaces-libmemcached-utilities">16.6.3.3.6 <span class="command"><strong>libmemcached</strong></span> のコマンド行ユーティリティー</a></span></dt></dl></div><p>
        <code class="literal">libmemcached</code> ライブラリは、<span class="command"><strong>memcached</strong></span> に対する C および C++ インタフェースを提供し、いくつかの異なる追加 API 実装 (Perl、Python、および Ruby を含む) の基盤にもなります。<code class="literal">libmemcached</code> のコア関数を理解することは、こうしたほかのインタフェースを使用するときにも役立ちます。
      </p><p>
        C ライブラリは、<span class="command"><strong>memcached</strong></span> のもっとも包括的なインタフェースライブラリであり、<code class="literal">libmemcached</code> ライブラリをベースとしないインタフェースでは常時公開されていない関数と操作システムを提供します。
      </p><p>
        さまざまな関数を、その基本操作に応じて分類できます。コア API へのインタフェースとなる関数に加えて、いくつかのユーティリティー関数によって拡張機能 (データの末尾への追加や先頭への追加など) が提供されます。
      </p><p>
        <code class="literal">libmemcached</code> をビルドしてインストールするには、<code class="literal">libmemcached</code> パッケージをダウンロードし、<span class="command"><strong>configure</strong></span> を実行してから、ビルドおよびインストールします。
      </p><pre class="programlisting">
shell&gt; tar xjf libmemcached-0.21.tar.gz
shell&gt; cd libmemcached-0.21
shell&gt; ./configure
shell&gt; make
shell&gt; make install
</pre><p>
        多くの Linux オペレーティングシステムでは、通常の <span class="command"><strong>yum</strong></span>、<span class="command"><strong>apt-get</strong></span>、または同様のコマンドを使用すると、対応する <code class="literal">libmemcached</code> パッケージをインストールできます。
      </p><p>
        このライブラリを使用するアプリケーションをビルドするには、最初にサーバーリストを設定します。<code class="literal">memcached_st</code> メイン構造体の内部に構成されたサーバーを直接操作したり、サーバーリストを別個に移入したりして、そのリストを <code class="literal">memcached_st</code> 構造体に追加します。次の例では、後者の方法を使用しています。サーバーリストを設定したあとは、関数を呼び出してデータを格納または取得できます。事前設定値を <code class="literal">localhost</code> に設定する簡単なアプリケーションをここに示します。
      </p><pre class="programlisting">
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;libmemcached/memcached.h&gt;

int main(int argc, char *argv[])
{
  memcached_server_st *servers = NULL;
  memcached_st *memc;
  memcached_return rc;
  char *key= "keystring";
  char *value= "keyvalue";

  memcached_server_st *memcached_servers_parse (char *server_strings);
  memc= memcached_create(NULL);

  servers= memcached_server_list_append(servers, "localhost", 11211, &amp;rc);
  rc= memcached_server_push(memc, servers);

  if (rc == MEMCACHED_SUCCESS)
    fprintf(stderr,"Added server successfully\n");
  else
    fprintf(stderr,"Couldn't add server: %s\n",memcached_strerror(memc, rc));

  rc= memcached_set(memc, key, strlen(key), value, strlen(value), (time_t)0, (uint32_t)0);

  if (rc == MEMCACHED_SUCCESS)
    fprintf(stderr,"Key stored successfully\n");
  else
    fprintf(stderr,"Couldn't store key: %s\n",memcached_strerror(memc, rc));

  return 0;
}
</pre><p>
        操作が成功したかどうかをテストするには、特定の関数の戻り値 (または移入された結果コード) を使用します。操作が成功した場合、この値は常に <code class="literal">MEMCACHED_SUCCESS</code> に設定されます。エラーが発生した場合は、<code class="literal">memcached_strerror()</code> 関数を使用して、結果コードを出力可能な文字列に変換します。
      </p><p>
        アプリケーションをビルドするには、<code class="literal">memcached</code> ライブラリを指定します。
      </p><pre class="programlisting">
shell&gt; gcc -o memc_basic memc_basic.c -lmemcached
</pre><p>
        <span class="command"><strong>memcached</strong></span> サーバーを起動したあとで上記のサンプルアプリケーションを実行すると、成功メッセージが返されます。
      </p><pre class="programlisting">
shell&gt; memc_basic
Added server successfully
Key stored successfully
</pre><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ha-memcached-interfaces-libmemcached-base"></a>16.6.3.3.1 <code class="literal">libmemcached</code> のベース関数</h5></div></div></div><p>
          <code class="literal">libmemcached</code> のベース関数を使用すると、<code class="literal">memcached</code> サーバーとのインタフェースとして使用される <code class="literal">memcached_st</code> メイン構造体を作成、破壊、およびクローニングできます。主な関数の定義を次に示します。
        </p><pre class="programlisting">
memcached_st *memcached_create (memcached_st *ptr);
</pre><p>
          ほかの <code class="literal">libmemcached</code> API 関数で使用する新しい <code class="literal">memcached_st</code> 構造体を作成します。既存の静的な <code class="literal">memcached_st</code> 構造体を指定することも、<code class="literal">NULL</code> を指定して新しい構造体を割り当てることもできます。作成された構造体へのポインタを返します。失敗時は <code class="literal">NULL</code> を返します。
        </p><pre class="programlisting">
void memcached_free (memcached_st *ptr);
</pre><p>
          以前に作成された <code class="literal">memcached_st</code> 構造体に割り当てられていた構造体とメモリーを解放します。
        </p><pre class="programlisting">
memcached_st *memcached_clone(memcached_st *clone, memcached_st *source);
</pre><p>
          指定された <code class="literal">source</code> から既存の <code class="literal">memcached</code> 構造体をクローニングし、その構造体に定義されているデフォルトとサーバーリストをコピーします。
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ha-memcached-interfaces-libmemcached-servers"></a>16.6.3.3.2 <code class="literal">libmemcached</code> のサーバー関数</h5></div></div></div><p>
          <code class="literal">libmemcached</code> API は、<code class="literal">memcached_server_st</code> 構造体に格納されているサーバーリストを使用して、残りの関数で使用されるサーバーリストとして機能します。<code class="literal">memcached</code> を使用するには、最初にサーバーリストを作成し、次にそのサーバーリストを有効な <code class="literal">libmemcached</code> オブジェクトに適用します。
        </p><p>
          このサーバーリストとアクティブな <code class="literal">libmemcached</code> オブジェクト内のサーバーリストは別個に操作できるため、アクティブな <code class="literal">libmemcached</code> インタフェースの実行中にサーバーリストを更新および管理できます。
        </p><p>
          <code class="literal">memcached_st</code> 構造体内のサーバーリストを操作する関数は、次のとおりです。
        </p><pre class="programlisting">
memcached_return
   memcached_server_add (memcached_st *ptr,
                         char *hostname,
                         unsigned int port);
</pre><p>
          指定された <code class="literal">hostname</code> および <code class="literal">port</code> を使用して、<code class="literal">ptr</code> で指定された <code class="literal">memcached_st</code> 構造体にサーバーを追加します。
        </p><pre class="programlisting">
memcached_return
   memcached_server_add_unix_socket (memcached_st *ptr,
                                     char *socket);
</pre><p>
          <code class="literal">memcached_st</code> 構造体に構成されたサーバーリストに Unix ソケットを追加します。
        </p><pre class="programlisting">
unsigned int memcached_server_count (memcached_st *ptr);
</pre><p>
          <code class="literal">memcached_st</code> 構造体に含まれている構成済みサーバー数のカウントを返します。
        </p><pre class="programlisting">
memcached_server_st *
   memcached_server_list (memcached_st *ptr);
</pre><p>
          <code class="literal">memcached_st</code> 構造体に含まれる定義済みホストの配列を返します。
        </p><pre class="programlisting">
memcached_return
   memcached_server_push (memcached_st *ptr,
                          memcached_server_st *list);
</pre><p>
          現在の <code class="literal">memcached_st</code> 構造体に構成されているサーバーリストに対して既存のサーバーリストをプッシュします。これにより、既存のリストの末尾にサーバーが追加されますが、重複はチェックされません。
        </p><p>
          <code class="literal">memcached_server_st</code> 構造体を使用して <code class="literal">memcached</code> サーバーのリストを作成し、それらを <code class="literal">memcached_st</code> 構造体に個別に適用できます。
        </p><pre class="programlisting">
memcached_server_st *
   memcached_server_list_append (memcached_server_st *ptr,
                                 char *hostname,
                                 unsigned int port,
                                 memcached_return *error);
</pre><p>
          <code class="literal">hostname</code> および <code class="literal">port</code> を使用して、<code class="literal">ptr</code> のサーバーリストにサーバーを追加します。結果コードは <code class="literal">error</code> 引数によって処理されます。この引数は既存の <code class="literal">memcached_return</code> 変数を指します。この関数は返されたリストへのポインタを返します。
        </p><pre class="programlisting">
unsigned int memcached_server_list_count (memcached_server_st *ptr);
</pre><p>
          サーバーリスト内のサーバー数を返します。
        </p><pre class="programlisting">
void memcached_server_list_free (memcached_server_st *ptr);
</pre><p>
          サーバーリストに関連付けられたメモリーを解放します。
        </p><pre class="programlisting">
memcached_server_st *memcached_servers_parse (char *server_strings);
</pre><p>
          サーバーリストを含む文字列を解析します。個々のサーバーはカンマ、空白、またはその両方で区切られ、個々のサーバーは <code class="literal"><em class="replaceable"><code>server</code></em>[:<em class="replaceable"><code>port</code></em>]</code> という形式になっています。戻り値はサーバーリスト構造体です。
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ha-memcached-interfaces-libmemcached-set"></a>16.6.3.3.3 <code class="literal">libmemcached</code> の設定関数</h5></div></div></div><p>
          <code class="literal">libmemcached</code> 内の設定関連関数は、<code class="literal">memcached</code> プロトコルでサポートされるコア関数と同じ機能を備えています。各種関数の完全な定義は、すべてのベース関数 (<code class="literal">add</code>、<code class="literal">replace</code>、<code class="literal">prepend</code>、<code class="literal">append</code>) と同じです。たとえば、<code class="literal">memcached_set()</code> の関数定義は次のとおりです。
        </p><pre class="programlisting">
memcached_return
   memcached_set (memcached_st *ptr,
                  const char *key,
                  size_t key_length,
                  const char *value,
                  size_t value_length,
                  time_t expiration,
                  uint32_t flags);
</pre><p>
          <code class="literal">ptr</code> は <code class="literal">memcached_st</code> 構造体です。<code class="literal">key</code> と <code class="literal">key_length</code> はキーの名前と長さを定義し、<code class="literal">value</code> と <code class="literal">value_length</code> は対応する値と長さを定義します。失効およびオプションフラグを設定することもできます。詳細については、<a class="xref" href="ha-overview.html#ha-memcached-interfaces-libmemcached-behaviors" title="16.6.3.3.5 libmemcached の動作の制御">セクション16.6.3.3.5「<code class="literal">libmemcached</code> の動作の制御」</a>を参照してください。
        </p><p>
          この表に、<code class="literal">libmemcached</code> の残りの設定関連関数と、<span class="command"><strong>memcached</strong></span> プロトコルでサポートされる同等のコア関数の概要を示します。
        </p><div class="informaltable"><table summary="この表は、libmemcached の残りの設定関連関数と、memcached プロトコルでサポートされる同等のコア関数の概要を示しています。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col"><code class="literal">libmemcached</code> の関数</th><th scope="col">同等のコア関数</th></tr></thead><tbody><tr><td scope="row"><code class="literal">memcached_set(memc, key, key_length, value, value_length, expiration, flags)</code></td><td>汎用の <code class="literal">set()</code> 操作。</td></tr><tr><td scope="row"><code class="literal">memcached_add(memc, key, key_length, value, value_length, expiration, flags)</code></td><td>汎用の <code class="literal">add()</code> 関数。</td></tr><tr><td scope="row"><code class="literal">memcached_replace(memc, key, key_length, value, value_length, expiration, flags)</code></td><td>汎用の <code class="literal">replace()</code>。</td></tr><tr><td scope="row"><code class="literal">memcached_prepend(memc, key, key_length, value, value_length, expiration, flags)</code></td><td>指定された <code class="literal">value</code> を指定された <code class="literal">key</code> の現在の値の前に追加します。</td></tr><tr><td scope="row"><code class="literal">memcached_append(memc, key, key_length, value, value_length, expiration, flags)</code></td><td>指定された <code class="literal">value</code> を指定された <code class="literal">key</code> の現在の値のあとに追加します。</td></tr><tr><td scope="row"><code class="literal">memcached_cas(memc, key, key_length, value, value_length, expiration, flags, cas)</code></td><td>サーバー内の対応する <code class="literal">cas</code> 値が同じ場合は、特定のキーのデータを上書きします。</td></tr><tr><td scope="row"><code class="literal">memcached_set_by_key(memc, master_key, master_key_length, key, key_length, value, value_length, expiration, flags)</code></td><td>汎用の <code class="literal">set()</code> とほぼ同じですが、個々のサーバーの識別に使用できる追加のマスターキーオプションを備えています。</td></tr><tr><td scope="row"><code class="literal">memcached_add_by_key(memc, master_key, master_key_length, key, key_length, value, value_length, expiration, flags)</code></td><td>汎用の <code class="literal">add()</code> とほぼ同じですが、個々のサーバーの識別に使用できる追加のマスターキーオプションを備えています。</td></tr><tr><td scope="row"><code class="literal">memcached_replace_by_key(memc, master_key, master_key_length, key, key_length, value, value_length, expiration, flags)</code></td><td>汎用の <code class="literal">replace()</code> とほぼ同じですが、個々のサーバーの識別に使用できる追加のマスターキーオプションを備えています。</td></tr><tr><td scope="row"><code class="literal">memcached_prepend_by_key(memc, master_key, master_key_length, key, key_length, value, value_length, expiration, flags)</code></td><td><code class="literal">memcached_prepend()</code> とほぼ同じですが、個々のサーバーの識別に使用できる追加のマスターキーオプションを備えています。</td></tr><tr><td scope="row"><code class="literal">memcached_append_by_key(memc, master_key, master_key_length, key, key_length, value, value_length, expiration, flags)</code></td><td><code class="literal">memcached_append()</code> とほぼ同じですが、個々のサーバーの識別に使用できる追加のマスターキーオプションを備えています。</td></tr><tr><td scope="row"><code class="literal">memcached_cas_by_key(memc, master_key, master_key_length, key, key_length, value, value_length, expiration, flags)</code></td><td><code class="literal">memcached_cas()</code> とほぼ同じですが、個々のサーバーの識別に使用できる追加のマスターキーオプションを備えています。</td></tr></tbody></table></div><p>
          <code class="literal">by_key</code> メソッドには、サーバー選択のハッシュ化段階で使用および適用されるマスターキーを定義する 2 つの引数が追加されています。これは、次の定義で確認できます。
        </p><pre class="programlisting">
memcached_return
   memcached_set_by_key(memcached_st *ptr,
                        const char *master_key,
                        size_t master_key_length,
                        const char *key,
                        size_t key_length,
                        const char *value,
                        size_t value_length,
                        time_t expiration,
                        uint32_t flags);
</pre><p>
          すべての関数が <code class="literal">MEMCACHED_SUCCESS</code> 定数と比較できる <code class="literal">memcached_return</code> 型の値を返します。
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ha-memcached-interfaces-libmemcached-get"></a>16.6.3.3.4 <code class="literal">libmemcached</code> の取得関数</h5></div></div></div><p>
          <code class="literal">libmemcached</code> の関数は、1 つの項目への直接アクセスと、多数のキーを同時にフェッチするときの応答が非常に高速な複数キーの要求メカニズムを提供します。
        </p><p>
          汎用の <code class="literal">get()</code> と同等である主要な get スタイルの関数は、<code class="literal">memcached_get()</code> です。この関数は、指定されたキーに関連付けられた値を指す文字列ポインタを返します。
        </p><pre class="programlisting">
char *memcached_get (memcached_st *ptr,
                     const char *key, size_t key_length,
                     size_t *value_length,
                     uint32_t *flags,
                     memcached_return *error);
</pre><p>
          複数キーの get である <code class="literal">memcached_mget()</code> も使用可能です。複数キーの取得操作を使用すると、<code class="literal">memcached_get()</code> を個々に呼び出してキー値を取得するよりも、1 ブロックの操作を非常に高速に実行できます。複数キー取得を開始するには、<code class="literal">memcached_mget()</code> を呼び出します。
        </p><pre class="programlisting">
memcached_return
    memcached_mget (memcached_st *ptr,
                    char **keys, size_t *key_length,
                    unsigned int number_of_keys);
</pre><p>
          戻り値は操作の成功です。<code class="literal">keys</code> パラメータはキーを含む文字列の配列、<code class="literal">key_length</code> は対応する各キーの長さを含む配列です。<code class="literal">number_of_keys</code> は配列に設定したキーの数です。
        </p><p>
          個々の値をフェッチするには、<code class="literal">memcached_fetch()</code> を使用して対応する各値を取得します。
        </p><pre class="programlisting">
char *memcached_fetch (memcached_st *ptr,
                       const char *key, size_t *key_length,
                       size_t *value_length,
                       uint32_t *flags,
                       memcached_return *error);
</pre><p>
          この関数はキー値を返し、<code class="literal">key</code>、<code class="literal">key_length</code>、および <code class="literal">value_length</code> パラメータに対応するキーと長さの情報を移入します。この関数は、返す値がなくなったときに <code class="literal">NULL</code> を返します。キーデータの移入と情報の戻りを含む完全な例をここに示します。
        </p><pre class="programlisting">
#include &lt;stdio.h&gt;
#include &lt;sstring.h&gt;
#include &lt;unistd.h&gt;
#include &lt;libmemcached/memcached.h&gt;

int main(int argc, char *argv[])
{
  memcached_server_st *servers = NULL;
  memcached_st *memc;
  memcached_return rc;
  char *keys[]= {"huey", "dewey", "louie"};
  size_t key_length[3];
  char *values[]= {"red", "blue", "green"};
  size_t value_length[3];
  unsigned int x;
  uint32_t flags;

  char return_key[MEMCACHED_MAX_KEY];
  size_t return_key_length;
  char *return_value;
  size_t return_value_length;

  memc= memcached_create(NULL);

  servers= memcached_server_list_append(servers, "localhost", 11211, &amp;rc);
  rc= memcached_server_push(memc, servers);

  if (rc == MEMCACHED_SUCCESS)
    fprintf(stderr,"Added server successfully\n");
  else
    fprintf(stderr,"Couldn't add server: %s\n",memcached_strerror(memc, rc));

  for(x= 0; x &lt; 3; x++)
    {
      key_length[x] = strlen(keys[x]);
      value_length[x] = strlen(values[x]);

      rc= memcached_set(memc, keys[x], key_length[x], values[x],
                        value_length[x], (time_t)0, (uint32_t)0);
      if (rc == MEMCACHED_SUCCESS)
        fprintf(stderr,"Key %s stored successfully\n",keys[x]);
      else
        fprintf(stderr,"Couldn't store key: %s\n",memcached_strerror(memc, rc));
    }

  rc= memcached_mget(memc, keys, key_length, 3);

  if (rc == MEMCACHED_SUCCESS)
    {
      while ((return_value= memcached_fetch(memc, return_key, &amp;return_key_length,
                                            &amp;return_value_length, &amp;flags, &amp;rc)) != NULL)
        {
          if (rc == MEMCACHED_SUCCESS)
            {
              fprintf(stderr,"Key %s returned %s\n",return_key, return_value);
            }
        }
    }

  return 0;
}
</pre><p>
          上記のアプリケーションを実行すると、次の出力が生成されます。
        </p><pre class="programlisting">
shell&gt; memc_multi_fetch
Added server successfully
Key huey stored successfully
Key dewey stored successfully
Key louie stored successfully
Key huey returned red
Key dewey returned blue
Key louie returned green
</pre></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ha-memcached-interfaces-libmemcached-behaviors"></a>16.6.3.3.5 <code class="literal">libmemcached</code> の動作の制御</h5></div></div></div><p>
          <code class="literal">libmemcached</code> の動作は、1 つ以上の動作フラグを設定することで変更できます。これらは、グローバルに設定するか、個々の関数の呼び出し中に適用できます。サーバーの選択時に使用されるハッシュ化メカニズムなど、追加の設定を受け入れる動作もあります。
        </p><p>
          グローバルな動作を設定するには:
        </p><pre class="programlisting">
memcached_return
   memcached_behavior_set (memcached_st *ptr,
                           memcached_behavior flag,
                           uint64_t data);
</pre><p>
          現在の動作設定を取得するには:
        </p><pre class="programlisting">
uint64_t
   memcached_behavior_get (memcached_st *ptr,
                           memcached_behavior flag);
</pre><p>
          <code class="literal">libmemcached</code> の動作フラグを次の表に示します。
        </p><div class="informaltable"><table summary="この表は、libmemcached の動作フラグのリストであり、各フラグの説明を示しています。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">動作</th><th scope="col">説明</th></tr></thead><tbody><tr><td scope="row"><code class="literal">MEMCACHED_BEHAVIOR_NO_BLOCK</code></td><td><code class="literal">libmemcached</code> で非同期 I/O を使用します。</td></tr><tr><td scope="row"><code class="literal">MEMCACHED_BEHAVIOR_TCP_NODELAY</code></td><td>ネットワークソケットの NODELAY をオンにします。</td></tr><tr><td scope="row"><code class="literal">MEMCACHED_BEHAVIOR_HASH</code></td><td>値がない場合は、MD5 を使用してキー用のデフォルトのハッシュ化アルゴリズムを設定します。ほかの有効な値として、<code class="literal">MEMCACHED_HASH_DEFAULT</code>、<code class="literal">MEMCACHED_HASH_MD5</code>、<code class="literal">MEMCACHED_HASH_CRC</code>、<code class="literal">MEMCACHED_HASH_FNV1_64</code>、<code class="literal">MEMCACHED_HASH_FNV1A_64</code>、<code class="literal">MEMCACHED_HASH_FNV1_32</code>、および <code class="literal">MEMCACHED_HASH_FNV1A_32</code> があります。</td></tr><tr><td scope="row"><code class="literal">MEMCACHED_BEHAVIOR_DISTRIBUTION</code></td><td>特定の値を格納するために使用されるサーバーの選択方法を変更します。デフォルトの方法は <code class="literal">MEMCACHED_DISTRIBUTION_MODULA</code> です。整合ハッシュ化を有効にするには、<code class="literal">MEMCACHED_DISTRIBUTION_CONSISTENT</code> を設定します。<code class="literal">MEMCACHED_DISTRIBUTION_CONSISTENT</code> は、値 <code class="literal">MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA</code> のエイリアスです。</td></tr><tr><td scope="row"><code class="literal">MEMCACHED_BEHAVIOR_CACHE_LOOKUPS</code></td><td>DNS サービスに対して行われたルックアップをキャッシュします。個々のホストに IP アドレスではなく名前を使用している場合は、これによってパフォーマンスが向上することがあります。</td></tr><tr><td scope="row"><code class="literal">MEMCACHED_BEHAVIOR_SUPPORT_CAS</code></td><td>CAS 操作をサポートします。パフォーマンスが低下するため、デフォルトではこれは無効になっています。</td></tr><tr><td scope="row"><code class="literal">MEMCACHED_BEHAVIOR_KETAMA</code></td><td>デフォルトの分布を <code class="literal">MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA</code> に設定し、ハッシュを <code class="literal">MEMCACHED_HASH_MD5</code> に設定します。</td></tr><tr><td scope="row"><code class="literal">MEMCACHED_BEHAVIOR_POLL_TIMEOUT</code></td><td><code class="literal">poll()</code> で使用されるタイムアウト値を変更します。タイムアウト値には <code class="literal">signed int</code> ポインタを指定します。</td></tr><tr><td scope="row"><code class="literal">MEMCACHED_BEHAVIOR_BUFFER_REQUESTS</code></td><td>I/O 要求を送信せずにバッファリングします。このデータは、取得操作または接続のクローズによってフラッシュされます。</td></tr><tr><td scope="row"><code class="literal">MEMCACHED_BEHAVIOR_VERIFY_KEY</code></td><td>指定されたキーが有効かどうかを <code class="literal">libmemcached</code> が強制的に検証します。</td></tr><tr><td scope="row"><code class="literal">MEMCACHED_BEHAVIOR_SORT_HOSTS</code></td><td>設定すると、<code class="literal">memcached_st</code> 構造体の構成済みホストのリストに追加されたホストが、ソートされた順序でホストリストに配置されます。これにより、整合ハッシュ化が有効になっている場合は、その動作が破棄されます。</td></tr><tr><td scope="row"><code class="literal">MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT</code></td><td>非ブロックモードでは、これによってソケット接続中のタイムアウトの値が変更されます。</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ha-memcached-interfaces-libmemcached-utilities"></a>16.6.3.3.6 <span class="command"><strong>libmemcached</strong></span> のコマンド行ユーティリティー</h5></div></div></div><p>
          <code class="literal">libmemcached</code> には、主要な C ライブラリインタフェースに加えて、<span class="command"><strong>memcached</strong></span> アプリケーションの操作やデバッグに役立ついくつかのコマンド行ユーティリティーも含まれています。
        </p><p>
          すべてのコマンド行ツールはいくつかの引数を受け入れますが、その中でもっとも重要なものは、情報を返すときに接続するサーバーのリストを指定する <code class="literal">servers</code> です。
        </p><p>
          主要なツールは次のとおりです。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <span class="command"><strong>memcat</strong></span>: 指定された各 ID の値をコマンド行に表示します。
            </p><pre class="programlisting">
shell&gt; memcat --servers=localhost hwkey
Hello world
</pre></li><li class="listitem"><p>
              <span class="command"><strong>memcp</strong></span>: ファイル名をキーとして使用して、ファイルの内容をキャッシュにコピーします。
            </p><pre class="programlisting">
shell&gt; echo "Hello World" &gt; hwkey
shell&gt; memcp --servers=localhost hwkey
shell&gt; memcat --servers=localhost hwkey
Hello world
</pre></li><li class="listitem"><p>
              <span class="command"><strong>memrm</strong></span>: キャッシュから項目を削除します。
            </p><pre class="programlisting">
shell&gt; memcat --servers=localhost hwkey
Hello world
shell&gt; memrm --servers=localhost hwkey
shell&gt; memcat --servers=localhost hwkey
</pre></li><li class="listitem"><p>
              <span class="command"><strong>memslap</strong></span>: 取得/設定および複数クライアントの操作をシミュレートして、1 つ以上の <span class="command"><strong>memcached</strong></span> サーバーに対する負荷をテストします。たとえば、取得操作を実行する 100 台のクライアントの負荷をシミュレートできます。
            </p><pre class="programlisting">
shell&gt; memslap --servers=localhost --concurrency=100 --flush --test=get
memslap --servers=localhost --concurrency=100 --flush --test=get	Threads connecting to servers 100
	Took 13.571 seconds to read data
</pre></li><li class="listitem"><p>
              <span class="command"><strong>memflush</strong></span>: <span class="command"><strong>memcached</strong></span> キャッシュの内容をフラッシュ (空に) します。
            </p><pre class="programlisting">
shell&gt; memflush --servers=localhost
</pre></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ha-memcached-interfaces-perl"></a>16.6.3.4 Perl での MySQL と <span class="command"><strong>memcached</strong></span> の使用</h4></div></div></div><p>
        <code class="literal">Cache::Memcached</code> モジュールは、Memcache プロトコルへのネイティブインタフェースを提供し、<span class="command"><strong>memcached</strong></span> に用意されているコア関数をサポートします。このモジュールは、オペレーティングシステムのパッケージ管理システムまたは <code class="literal">CPAN</code> を使用してインストールします。
      </p><pre class="programlisting">
root-shell&gt; perl -MCPAN -e 'install Cache::Memcached'
</pre><p>
        Perl から <code class="literal">Cache::Memcached</code> モジュールを介して <span class="command"><strong>memcached</strong></span> を使用するには、最初に接続用のサーバーリストとその他のパラメータを定義する新しい <code class="literal">Cache::Memcached</code> オブジェクトを作成します。唯一の引数は、キャッシュインタフェース用のオプションを含むハッシュです。たとえば、3 台の <span class="command"><strong>memcached</strong></span> サーバーを使用する新しいインスタンスを作成するには:
      </p><pre class="programlisting">
use Cache::Memcached;

my $cache = new Cache::Memcached {
    'servers' =&gt; [
        '192.168.0.100:11211',
        '192.168.0.101:11211',
        '192.168.0.102:11211',
	],
};
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          複数のサーバーとともに <code class="literal">Cache::Memcached</code> インタフェースを使用すると、この API はグループ内のすべてのサーバーに対して特定の操作を自動的に実行します。たとえば、<code class="literal">Cache::Memcached</code> を介して統計情報を取得すると、ホスト単位のデータを含むハッシュとともに、グループ内のすべてのサーバーに関して一般化された統計が返されます。
        </p></div><p>
        キャッシュオブジェクトインスタンスの作成時にインスタンスに対して追加のプロパティーを設定するには、オプションのハッシュの一部としてそのオプションを指定します。または、インスタンスに対して対応するメソッドを使用することもできます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">servers</code> または <code class="literal">set_servers()</code> メソッド: 使用されるサーバーのリストを指定します。このサーバーリストは、各要素がアドレスとポート番号の (コロンで区切られた) 組み合わせであるサーバー配列への参照です。Unix ソケットによるローカル接続を指定することもできます (たとえば、<code class="filename">/tmp/sock/memcached</code>)。(ハッシュ化時にどの程度の頻度でそのサーバーを使用すべきかを示す) 重み付きでサーバーを指定するには、<span class="command"><strong>memcached</strong></span> サーバーインスタンスと重み値を含む配列参照を指定します。数値が大きいほど、優先度が高くなります。
          </p></li><li class="listitem"><p>
            <code class="literal">compress_threshold</code> または <code class="literal">set_compress_threshold()</code> メソッド: 値を圧縮するときのしきい値を指定します。指定した数値より大きい値は、格納時および取得時に (<code class="literal">zlib</code> を使用して) 自動的に圧縮されます。
          </p></li><li class="listitem"><p>
            <code class="literal">no_rehash</code> または <code class="literal">set_norehash()</code> メソッド: 最初に選択したサーバーが使用できなかった場合に、新しいサーバーの検索を無効にします。
          </p></li><li class="listitem"><p>
            <code class="literal">readonly</code> または <code class="literal">set_readonly()</code> メソッド: <span class="command"><strong>memcached</strong></span> サーバーへの書き込みを無効にします。
          </p></li></ul></div><p>
        <code class="literal">Cache::Memcached</code> オブジェクトインスタンスを構成したあとは、<code class="literal">set()</code> および <code class="literal">get()</code> メソッドを使用すると <span class="command"><strong>memcached</strong></span> サーバーの情報を格納および取得できます。キャッシュに格納されているオブジェクトは、<code class="literal">Storable</code> モジュールを使用して自動的に直列化および直列化解除されます。
      </p><p>
        <code class="literal">Cache::Memcached</code> インタフェースは、データを格納/取得するために次のメソッドをサポートします。これらは、表に示すように汎用のメソッドと関連しています。
      </p><div class="informaltable"><table summary="この表は、Perl で使用される memcached 関数と memcached インタフェース仕様に含まれる同等の汎用メソッドのリストです。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col"><code class="literal">Cache::Memcached</code> の関数</th><th scope="col">同等の汎用メソッド</th></tr></thead><tbody><tr><td scope="row"><code class="literal">get()</code></td><td>汎用の <code class="literal">get()</code>。</td></tr><tr><td scope="row"><code class="literal">get_multi(keys)</code></td><td>1 つのクエリーのみを使用して memcache から複数の <code class="literal">keys</code> を取得します。キー/値ペアのハッシュ参照を返します。</td></tr><tr><td scope="row"><code class="literal">set()</code></td><td>汎用の <code class="literal">set()</code>。</td></tr><tr><td scope="row"><code class="literal">add()</code></td><td>汎用の <code class="literal">add()</code>。</td></tr><tr><td scope="row"><code class="literal">replace()</code></td><td>汎用の <code class="literal">replace()</code>。</td></tr><tr><td scope="row"><code class="literal">delete()</code></td><td>汎用の <code class="literal">delete()</code>。</td></tr><tr><td scope="row"><code class="literal">incr()</code></td><td>汎用の <code class="literal">incr()</code>。</td></tr><tr><td scope="row"><code class="literal">decr()</code></td><td>汎用の <code class="literal">decr()</code>。</td></tr></tbody></table></div><p>
        Perl および <code class="literal">Cache::Memcached</code> モジュールで <span class="command"><strong>memcached</strong></span> を使用する完全な例を次に示します。
      </p><pre class="programlisting">
#!/usr/bin/perl

use Cache::Memcached;
use DBI;
use Data::Dumper;

# Configure the memcached server

my $cache = new Cache::Memcached {
    'servers' =&gt; [
                   'localhost:11211',
                   ],
    };

# Get the film name from the command line
# memcached keys must not contain spaces, so create
# a key name by replacing spaces with underscores

my $filmname = shift or die "Must specify the film name\n";
my $filmkey = $filmname;
$filmkey =~ s/ /_/;

# Load the data from the cache

my $filmdata = $cache-&gt;get($filmkey);

# If the data wasn't in the cache, then we load it from the database

if (!defined($filmdata))
{
    $filmdata = load_filmdata($filmname);

    if (defined($filmdata))
    {

# Set the data into the cache, using the key

	if ($cache-&gt;set($filmkey,$filmdata))
        {
            print STDERR "Film data loaded from database and cached\n";
        }
        else
        {
            print STDERR "Couldn't store to cache\n";
	}
    }
    else
    {
     	die "Couldn't find $filmname\n";
    }
}
else
{
    print STDERR "Film data loaded from Memcached\n";
}

sub load_filmdata
{
    my ($filmname) = @_;

    my $dsn = "DBI:mysql:database=sakila;host=localhost;port=3306";

    $dbh = DBI-&gt;connect($dsn, 'sakila','password');

    my ($filmbase) = $dbh-&gt;selectrow_hashref(sprintf('select * from film where title = %s',
                                                     $dbh-&gt;quote($filmname)));

    if (!defined($filmname))
    {
     	return (undef);
    }

    $filmbase-&gt;{stars} =
	$dbh-&gt;selectall_arrayref(sprintf('select concat(first_name," ",last_name) ' .
                                         'from film_actor left join (actor) ' .
                                         'on (film_actor.actor_id = actor.actor_id) ' .
                                         ' where film_id=%s',
                                         $dbh-&gt;quote($filmbase-&gt;{film_id})));

    return($filmbase);
}
</pre><p>
        この例では、Sakila データベースを使用して、データベースから映画のデータを取得し、映画と俳優の複合レコードを <span class="command"><strong>memcached</strong></span> に書き込みます。ある映画を要求したときに、それが存在しなかった場合は、この結果が得られます。
      </p><pre class="programlisting">
shell&gt; memcached-sakila.pl "ROCK INSTINCT"
Film data loaded from database and cached
</pre><p>
        キャッシュにすでに追加されている映画にアクセスするとき:
      </p><pre class="programlisting">
shell&gt; memcached-sakila.pl "ROCK INSTINCT"
Film data loaded from Memcached
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ha-memcached-interfaces-python"></a>16.6.3.5 Python での MySQL と <span class="command"><strong>memcached</strong></span> の使用</h4></div></div></div><p>
        Python の <span class="command"><strong>memcache</strong></span> モジュールは、<span class="command"><strong>memcached</strong></span> サーバーへのインタフェースであり、純粋に Python で (つまり、いずれかの C API を使用せずに) 記述されています。<a class="ulink" href="http://www.tummy.com/Community/software/python-memcached/" target="_top">Python Memcached</a> からコピーをダウンロードしてインストールできます。
      </p><p>
        インストールするには、パッケージをダウンロードして、Python インストーラを実行します。
      </p><pre class="programlisting">
python setup.py install
running install
running bdist_egg
running egg_info
creating python_memcached.egg-info
...
removing 'build/bdist.linux-x86_64/egg' (and everything under it)
Processing python_memcached-1.43-py2.4.egg
creating /usr/lib64/python2.4/site-packages/python_memcached-1.43-py2.4.egg
Extracting python_memcached-1.43-py2.4.egg to /usr/lib64/python2.4/site-packages
Adding python-memcached 1.43 to easy-install.pth file

Installed /usr/lib64/python2.4/site-packages/python_memcached-1.43-py2.4.egg
Processing dependencies for python-memcached==1.43
Finished processing dependencies for python-memcached==1.43
</pre><p>
        インストールが完了すると、<code class="literal">memcache</code> モジュールは <span class="command"><strong>memcached</strong></span> サーバーに対するクラスベースのインタフェースを提供します。Python のデータ構造体を <span class="command"><strong>memcached</strong></span> の項目として格納すると、それらは Python の <code class="literal">cPickle</code> または <code class="literal">pickle</code> モジュールを使用して自動的に直列化 (文字列値に変換) されます。
      </p><p>
        新しい <code class="literal">memcache</code> インタフェースを作成するには、<code class="literal">memcache</code> モジュールをインポートし、<code class="literal">memcache.Client</code> クラスの新しいインスタンスを作成します。たとえば、<span class="command"><strong>memcached</strong></span> デーモンが localhost 上でデフォルトポートを使用して実行されている場合:
      </p><pre class="programlisting">
import memcache
memc = memcache.Client(['127.0.0.1:11211'])
</pre><p>
        1 つ目の引数は、使用する各 <span class="command"><strong>memcached</strong></span> インスタンスのサーバーとポート番号を含む文字列の配列です。デバッグを有効にするには、オプションの <code class="literal">debug</code> パラメータを 1 に設定します。
      </p><p>
        デフォルトでは、項目を複数のサーバー間で分配するために使用されるハッシュ化メカニズムは <code class="literal">crc32</code> です。使用する関数を変更するには、<code class="literal">memcache.serverHashFunction</code> の値を、代わりに使用する関数に設定します。例:
      </p><pre class="programlisting">
from zlib import adler32
memcache.serverHashFunction = adler32
</pre><p>
        <code class="literal">memcache</code> インスタンス内で使用するサーバーを定義すると、コア関数によって汎用のインタフェース仕様と同じ機能が提供されます。次の表に、サポートされる関数のサマリーを示します。
      </p><div class="informaltable"><table summary="この表は、Python の memcached 関数と memcached インタフェース仕様に含まれる同等の汎用関数のリストです。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">Python の <code class="literal">memcache</code> 関数</th><th scope="col">同等の汎用関数</th></tr></thead><tbody><tr><td scope="row"><code class="literal">get()</code></td><td>汎用の <code class="literal">get()</code>。</td></tr><tr><td scope="row"><code class="literal">get_multi(keys)</code></td><td>指定された <code class="literal">keys</code> の配列から複数の値を取得します。キー/値ペアのハッシュ参照を返します。</td></tr><tr><td scope="row"><code class="literal">set()</code></td><td>汎用の <code class="literal">set()</code>。</td></tr><tr><td scope="row"><code class="literal">set_multi(dict [, expiry [, key_prefix]])</code></td><td>指定された <code class="literal">dict</code> から複数のキー/値ペアを設定します。</td></tr><tr><td scope="row"><code class="literal">add()</code></td><td>汎用の <code class="literal">add()</code>。</td></tr><tr><td scope="row"><code class="literal">replace()</code></td><td>汎用の <code class="literal">replace()</code>。</td></tr><tr><td scope="row"><code class="literal">prepend(key, value [, expiry])</code></td><td>指定された <code class="literal">value</code> を既存の <code class="literal">key</code> の値の前に追加します。</td></tr><tr><td scope="row"><code class="literal">append(key, value [, expiry[)</code></td><td>指定された <code class="literal">value</code> を既存の <code class="literal">key</code> の値のあとに追加します。</td></tr><tr><td scope="row"><code class="literal">delete()</code></td><td>汎用の <code class="literal">delete()</code>。</td></tr><tr><td scope="row"><code class="literal">delete_multi(keys [, expiry [, key_prefix]] )</code></td><td><code class="literal">keys</code> 配列内の各文字列と一致するハッシュからすべてのキーを削除します。</td></tr><tr><td scope="row"><code class="literal">incr()</code></td><td>汎用の <code class="literal">incr()</code>。</td></tr><tr><td scope="row"><code class="literal">decr()</code></td><td>汎用の <code class="literal">decr()</code>。</td></tr></tbody></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          Python の <code class="literal">memcache</code> モジュール内では、すべての <code class="literal">*_multi()</code> 関数でオプションの <code class="literal">key_prefix</code> パラメータをサポートします。この文字列は、指定すると、すべてのキールックアップに対するプリフィクスとして使用されます。たとえば、次を呼び出す場合:
        </p><pre class="programlisting">
memc.get_multi(['a','b'], key_prefix='users:')
</pre><p>
          この関数は、サーバーからキー <code class="literal">users:a</code> および <code class="literal">users:b</code> を取得します。
        </p></div><p>
        MySQL から生データをロードして、<code class="literal">memcache</code> インスタンスの情報を格納および取得する例をここに示します。
      </p><pre class="programlisting">
import sys
import MySQLdb
import memcache

memc = memcache.Client(['127.0.0.1:11211'], debug=1);

try:
    conn = MySQLdb.connect (host = "localhost",
                            user = "sakila",
                            passwd = "password",
                            db = "sakila")
except MySQLdb.Error, e:
     print "Error %d: %s" % (e.args[0], e.args[1])
     sys.exit (1)

popularfilms = memc.get('top5films')

if not popularfilms:
    cursor = conn.cursor()
    cursor.execute('select film_id,title from film order by rental_rate desc limit 5')
    rows = cursor.fetchall()
    memc.set('top5films',rows,60)
    print "Updated memcached with MySQL data"
else:
    print "Loaded data from memcached"
    for row in popularfilms:
        print "%s, %s" % (row[0], row[1])
</pre><p>
        はじめて実行すると、データが MySQL データベースからロードされ、<span class="command"><strong>memcached</strong></span> サーバーに格納されます。
      </p><pre class="programlisting">
shell&gt; python memc_python.py
Updated memcached with MySQL data
</pre><p>
        データは <code class="literal">cPickle</code>/<code class="literal">pickle</code> を使用して自動的に直列化されるため、データを <span class="command"><strong>memcached</strong></span> からロードしたときは、そのオブジェクトを直接使用できます。上の例では、<code class="literal">memcached</code> に格納された情報が Python DB のカーソルから取得した行の形式になっています。(60 秒の失効時間内に) 情報にアクセスすると、データが <code class="literal">memcached</code> からロードされ、ダンプされます。
      </p><pre class="programlisting">
shell&gt; python memc_python.py
Loaded data from memcached
2, ACE GOLDFINGER
7, AIRPLANE SIERRA
8, AIRPORT POLLOCK
10, ALADDIN CALENDAR
13, ALI FOREVER
</pre><p>
        直列化と直列化解除は自動的に行われます。Python データの直列化はほかのインタフェースや言語と互換性がない可能性があるため、初期化時に使用される直列化モジュールを変更できます。たとえば、ある言語で記述されたスクリプトを使用して複雑なデータ構造を格納し、別の言語で記述されたスクリプトでそれらにアクセスするときは、JSON フォーマットを使用できます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ha-memcached-interfaces-php"></a>16.6.3.6 PHP での MySQL と <span class="command"><strong>memcached</strong></span> の使用</h4></div></div></div><p>
        PHP は、PECL 拡張によって Memcache 関数のサポートを提供します。PHP の <code class="literal">memcache</code> 拡張を有効にするには、PHP をソースからビルドするときに <span class="command"><strong>configure</strong></span> に <code class="option">--enable-memcache</code> オプションを指定してビルドします。
      </p><p>
        Red Hat ベースのサーバーをインストールする場合は、<code class="literal">php-pecl-memcache</code> RPM をインストールできます。
      </p><pre class="programlisting">
root-shell&gt; yum --install php-pecl-memcache
</pre><p>
        Debian ベースの配布では、<code class="literal">php-memcache</code> パッケージを使用します。
      </p><p>
        グローバル実行時構成オプションを設定するには、<code class="filename">php.ini</code> ファイル内に構成オプションの値を指定します。次の表に、個々のグローバル実行時構成オプションの名前、デフォルト値、および説明を示します。
      </p><div class="informaltable"><table summary="この表は、PECL Memcache 拡張のグローバル実行時構成オプションのリストです。この表は、構成オプションの名前、デフォルト値、および説明を示しています。" border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">構成オプション</th><th scope="col">デフォルト</th><th scope="col">説明</th></tr></thead><tbody><tr><td scope="row"><code class="literal">memcache.allow_failover</code></td><td>1</td><td>最初に選択したサーバーに障害が発生した場合にリスト内の別のサーバーをクエリーするかどうか指定します。</td></tr><tr><td scope="row"><code class="literal">memcache.max_failover_attempts</code></td><td>20</td><td>失敗を返す前に試行するサーバーの数を指定します。</td></tr><tr><td scope="row"><code class="literal">memcache.chunk_size</code></td><td>8192</td><td><span class="command"><strong>memcached</strong></span> サーバーとのデータ交換に使用するネットワークチャンクのサイズを定義します。</td></tr><tr><td scope="row"><code class="literal">memcache.default_port</code></td><td>11211</td><td><span class="command"><strong>memcached</strong></span> サーバーとの通信時に使用するデフォルトポートを定義します。</td></tr><tr><td scope="row"><code class="literal">memcache.hash_strategy</code></td><td>standard</td><td>使用するハッシュ方式を指定します。<code class="literal">consistent</code> に設定すると、キーをほかのサーバーに再マップしないで、サーバーをプールに追加したりプールから削除したりできるようになります。<code class="literal">standard</code> に設定すると、格納時に別のサーバーを使用する可能性がある古い (モジュラ) 方式が使用されます。</td></tr><tr><td scope="row"><code class="literal">memcache.hash_function</code></td><td>crc32</td><td>キーをサーバーにマップするときに使用する関数を指定します。<code class="literal">crc32</code> にすると、標準の CRC32 ハッシュが使用されます。<code class="literal">fnv</code> にすると、FNV-1a ハッシュ化アルゴリズムが使用されます。</td></tr></tbody></table></div><p>
        <span class="command"><strong>memcached</strong></span> サーバーへの接続を作成するには、新しい <code class="literal">Memcache</code> オブジェクトを作成してから、接続オプションを指定します。例:
      </p><pre class="programlisting">
&lt;?php

$cache = new Memcache;
$cache-&gt;connect('localhost',11211);
?&gt;
</pre><p>
        これにより、指定したサーバーへの接続がただちに開きます。
      </p><p>
        複数の <span class="command"><strong>memcached</strong></span> サーバーを使用するには、<code class="literal">addServer()</code> を使用して memcache オブジェクトにサーバーを追加する必要があります。
      </p><pre class="programlisting">
bool Memcache::addServer ( string $host [, int $port [, bool $persistent
                 [, int $weight [, int $timeout [, int $retry_interval
                 [, bool $status [, callback $failure_callback
                 ]]]]]]] )
</pre><p>
        <code class="literal">php-memcache</code> モジュール内のサーバー管理メカニズムは、このインタフェースの重要な部分であり、<span class="command"><strong>memcached</strong></span> インスタンスへのメインインタフェースとハッシュ化メカニズムによるインスタンスの選択方法を制御します。
      </p><p>
        2 つの <span class="command"><strong>memcached</strong></span> インスタンスへの単純な接続を作成するには:
      </p><pre class="programlisting">
&lt;?php

$cache = new Memcache;
$cache-&gt;addServer('192.168.0.100',11211);
$cache-&gt;addServer('192.168.0.101',11211);
?&gt;
</pre><p>
        このシナリオでは、インスタンス接続は明示的に開かれず、値を格納または取得しようとしたときにのみ開かれます。<span class="command"><strong>memcached</strong></span> インスタンスへの永続的な接続を有効にするには、<code class="literal">$persistent</code> 引数を true に設定します。これはデフォルト設定であり、これによって接続が開いたままになります。
      </p><p>
        別のインスタンスへのキー分布を制御するには、<code class="literal">memcache.hash_strategy</code> グローバル設定を使用します。これは、選択に使用されるハッシュ化メカニズムを設定します。各サーバーに別の重みを追加することもできます。この重みは、インスタンスエントリがインスタンスリストに現れる回数を効果的に増やすことによって、ほかのインスタンスよりもそのインスタンスが選択される可能性を増やします。この重みを設定するには、<code class="literal">$weight</code> 引数を 1 より大きい値に設定します。
      </p><p>
        情報を設定および取得する関数は、このテーブルに示すように、<code class="literal">memcached</code> に用意されている汎用関数インタフェースと同等です。
      </p><div class="informaltable"><table summary="この表は、PECL の memcached 関数と memcached インタフェース仕様に含まれる同等の汎用関数のリストです。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">PECL の <code class="literal">memcache</code> 関数</th><th scope="col">汎用関数</th></tr></thead><tbody><tr><td scope="row"><code class="literal">get()</code></td><td>汎用の <code class="literal">get()</code>。</td></tr><tr><td scope="row"><code class="literal">set()</code></td><td>汎用の <code class="literal">set()</code>。</td></tr><tr><td scope="row"><code class="literal">add()</code></td><td>汎用の <code class="literal">add()</code>。</td></tr><tr><td scope="row"><code class="literal">replace()</code></td><td>汎用の <code class="literal">replace()</code>。</td></tr><tr><td scope="row"><code class="literal">delete()</code></td><td>汎用の <code class="literal">delete()</code>。</td></tr><tr><td scope="row"><code class="literal">increment()</code></td><td>汎用の <code class="literal">incr()</code>。</td></tr><tr><td scope="row"><code class="literal">decrement()</code></td><td>汎用の <code class="literal">decr()</code>。</td></tr></tbody></table></div><p>
        PECL の <code class="literal">memcache</code> インタフェースの完全な例を次に示します。このコードは、ユーザーが映画名を指定したときに、Sakila データベースから映画のデータをロードします。<code class="literal">memcached</code> インスタンスに格納されているデータは <code class="literal">mysqli</code> の結果行として記録され、この情報は API によって自動的に直列化されます。
      </p><pre class="programlisting">

&lt;?php

$memc = new Memcache;
$memc-&gt;addServer('localhost','11211');

if(empty($_POST['film'])) {
?&gt;
  &lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;
    &lt;head&gt;
      &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
      &lt;title&gt;Simple Memcache Lookup&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;form method="post"&gt;
        &lt;p&gt;&lt;b&gt;Film&lt;/b&gt;: &lt;input type="text" size="20" name="film"&gt;&lt;/p&gt;
        &lt;input type="submit"&gt;
      &lt;/form&gt;
      &lt;hr/&gt;
&lt;?php

} else {
    
    echo "Loading data...\n";
    
    $film   = htmlspecialchars($_POST['film'], ENT_QUOTES, 'UTF-8');
    $mfilms = $memc-&gt;get($film);

    if ($mfilms) {

        printf("&lt;p&gt;Film data for %s loaded from memcache&lt;/p&gt;", $mfilms['title']);

        foreach (array_keys($mfilms) as $key) {
            printf("&lt;p&gt;&lt;b&gt;%s&lt;/b&gt;: %s&lt;/p&gt;", $key, $mfilms[$key]);
        }

    } else {

        $mysqli = mysqli('localhost','sakila','password','sakila');
    
        if (mysqli_connect_error()) {
            sprintf("Database error: (%d) %s", mysqli_connect_errno(), mysqli_connect_error());
            exit;
        }
    
        $sql = sprintf('SELECT * FROM film WHERE title="%s"', $mysqli-&gt;real_escape_string($film));

        $result = $mysqli-&gt;query($sql);

        if (!$result) {
            sprintf("Database error: (%d) %s", $mysqli-&gt;errno, $mysqli-&gt;error);
            exit;
        }

        $row = $result-&gt;fetch_assoc();

        $memc-&gt;set($row['title'], $row);

        printf("&lt;p&gt;Loaded (%s) from MySQL&lt;/p&gt;", htmlspecialchars($row['title'], ENT_QUOTES, 'UTF-8');
    }
}
?&gt;
  &lt;/body&gt;
&lt;/html&gt;

</pre><p>
        PHP では、PHP と関連する Apache インスタンスの実行が継続するかぎり、<span class="command"><strong>memcached</strong></span> インスタンスへの接続は開いたまま維持されます。実行中のインスタンスでサーバーをリストに追加したり、リストから削除したりすると (たとえば、追加のサーバーが指定された別のスクリプトを起動したときなど)、接続は共有されますが、スクリプト内で明示的に構成されたインスタンスのみが選択されます。
      </p><p>
        スクリプト内でサーバーリストに変更を加えることによって問題が発生しないようにするには、必ず整合ハッシュ化メカニズムを使用してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ha-memcached-interfaces-ruby"></a>16.6.3.7 Ruby での MySQL と <span class="command"><strong>memcached</strong></span> の使用</h4></div></div></div><p>
        Ruby には、<span class="command"><strong>memcached</strong></span> へのインタフェースとなる異なるモジュールがあります。<code class="literal">Ruby-MemCache</code> クライアントライブラリは、<code class="literal">libmemcached</code> などの外部ライブラリを必要としない <span class="command"><strong>memcached</strong></span> へのネイティブインタフェースを提供します。インストーラパッケージは、<a class="ulink" href="http://www.deveiate.org/projects/RMemCache" target="_top">http://www.deveiate.org/projects/RMemCache</a> から入手できます。
      </p><p>
        インストールするには、パッケージを抽出して <span class="command"><strong>install.rb</strong></span> を実行します。
      </p><pre class="programlisting">
shell&gt; install.rb
</pre><p>
        RubyGems がある場合は、<code class="literal">Ruby-MemCache</code> gem をインストールできます。
      </p><pre class="programlisting">
shell&gt; gem install Ruby-MemCache
Bulk updating Gem source index for: http://gems.rubyforge.org
Install required dependency io-reactor? [Yn]  y
Successfully installed Ruby-MemCache-0.0.1
Successfully installed io-reactor-0.05
Installing ri documentation for io-reactor-0.05...
Installing RDoc documentation for io-reactor-0.05...
</pre><p>
        Ruby の内部から <span class="command"><strong>memcached</strong></span> インスタンスを使用するには、<code class="literal">MemCache</code> オブジェクトの新しいインスタンスを作成します。
      </p><pre class="programlisting">
require 'memcache'
memc = MemCache::new '192.168.0.100:11211'
</pre><p>
        ハッシュ化時にサーバーが選択される可能性を増やすため、各サーバーに重みを追加するには、サーバーのホスト名/ポート文字列の末尾に重みカウントを追加します。
      </p><pre class="programlisting">
require 'memcache'
memc = MemCache::new '192.168.0.100:11211:3'
</pre><p>
        既存のリストにサーバーを追加するには、それらを <code class="literal">MemCache</code> オブジェクトの末尾に直接追加します。
      </p><pre class="programlisting">
memc += ["192.168.0.101:11211"]
</pre><p>
        データをキャッシュに設定するには、標準の Ruby ハッシュオブジェクトとまったく同じように機能する新しいキャッシュオブジェクト内で、キーに値を割り当てます。
      </p><pre class="programlisting">
memc["key"] = "value"
</pre><p>
        または、値を取得するには:
      </p><pre class="programlisting">
print memc["key"]
</pre><p>
        より明示的なアクションとして、次の表に要約したように、<span class="command"><strong>memcached</strong></span> の主要な API 関数を模倣するメソッドインタフェースを使用できます。
      </p><div class="informaltable"><table summary="この表は、Ruby の memcached メソッドと、同等の memcached API 関数のリストです。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">Ruby の <code class="literal">MemCache</code> メソッド</th><th scope="col">同等の <span class="command"><strong>memcached</strong></span> API 関数</th></tr></thead><tbody><tr><td scope="row"><code class="literal">get()</code></td><td>汎用の <code class="literal">get()</code>。</td></tr><tr><td scope="row"><code class="literal">get_hash(keys)</code></td><td>複数の <code class="literal">keys</code> の値を取得し、キーとその値のハッシュとして情報を返します。</td></tr><tr><td scope="row"><code class="literal">set()</code></td><td>汎用の <code class="literal">set()</code>。</td></tr><tr><td scope="row"><code class="literal">set_many(pairs)</code></td><td>ハッシュ <code class="literal">pairs</code> 内のキーおよび値の値を設定します。</td></tr><tr><td scope="row"><code class="literal">add()</code></td><td>汎用の <code class="literal">add()</code>。</td></tr><tr><td scope="row"><code class="literal">replace()</code></td><td>汎用の <code class="literal">replace()</code>。</td></tr><tr><td scope="row"><code class="literal">delete()</code></td><td>汎用の <code class="literal">delete()</code>。</td></tr><tr><td scope="row"><code class="literal">incr()</code></td><td>汎用の <code class="literal">incr()</code>。</td></tr><tr><td scope="row"><code class="literal">decr()</code></td><td>汎用の <code class="literal">decr()</code>。</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ha-memcached-interfaces-java"></a>16.6.3.8 Java での MySQL と <span class="command"><strong>memcached</strong></span> の使用</h4></div></div></div><p>
        Java に含まれる <code class="literal">com.danga.MemCached</code> クラスは、<span class="command"><strong>memcached</strong></span> インスタンスへのネイティブインタフェースを提供します。このクライアントは、<a class="ulink" href="https://github.com/gwhalin/Memcached-Java-Client/downloads" target="_top">https://github.com/gwhalin/Memcached-Java-Client/downloads</a> から入手できます。この Java クラスは <code class="literal">libmemcached</code> と互換性があるハッシュを使用するため、同じ <span class="command"><strong>memcached</strong></span> インスタンスにアクセスする Java と <code class="literal">libmemcached</code> のアプリケーションを混在および調和できます。Java とその他のインタフェース間の直列化には互換性がありません。これが問題になる場合は、JSON または同様の非バイナリ直列化フォーマットを使用してください。
      </p><p>
        ほとんどのシステムでは、パッケージをダウンロードして <code class="filename">jar</code> を直接使用できます。
      </p><p>
        <code class="literal">com.danga.MemCached</code> インタフェースを使用するには、<code class="literal">MemCachedClient</code> インスタンスを作成し、<code class="literal">SockIOPool</code> を構成してサーバーリストを構成します。このプールを指定することで、サーバーリスト、重み、および接続パラメータを設定し、クライアントと構成した <span class="command"><strong>memcached</strong></span> インスタンス間の接続を最適化します。
      </p><p>
        一般に、1 つのクラス内で <span class="command"><strong>memcached</strong></span> インタフェースを一度構成すれば、あとはこのインタフェースを残りのアプリケーション全体で使用できます。
      </p><p>
        たとえば、基本的なインタフェースを作成するには、最初に <code class="literal">MemCachedClient</code> とベースの <code class="literal">SockIOPool</code> 設定を構成します。
      </p><pre class="programlisting">
public class MyClass {

    protected static MemCachedClient mcc = new MemCachedClient();

    static {
	
        String[] servers =
            {
                "localhost:11211",
            };
	
        Integer[] weights = { 1 };
	
        SockIOPool pool = SockIOPool.getInstance();
	
        pool.setServers( servers );
        pool.setWeights( weights );

</pre><p>
        上の例では、使用する <span class="command"><strong>memcached</strong></span> インスタンスの配列を作成することによってサーバーリストが構成されています。次に、各サーバーに対する個別の重みを構成します。
      </p><p>
        接続に関する残りのプロパティーはオプションですが、プールのパラメータを設定することによって接続の数値 (初期接続数、最小接続数、最大接続数、およびアイドルタイムアウト) を設定できます。
      </p><pre class="programlisting">
pool.setInitConn( 5 );
pool.setMinConn( 5 );
pool.setMaxConn( 250 );
pool.setMaxIdle( 1000 * 60 * 60 * 6 
</pre><p>
        パラメータを構成したあとは、接続プールを初期化します。
      </p><pre class="programlisting">
pool.initialize();
</pre><p>
        これで、プールと <span class="command"><strong>memcached</strong></span> インスタンスへの接続を使用できます。
      </p><p>
        特定のキーの格納時に使用されるサーバーの選択に使用するハッシュ化アルゴリズムを設定するには、<code class="literal">pool.setHashingAlg()</code> を使用します。
      </p><pre class="programlisting">
pool.setHashingAlg( SockIOPool.NEW_COMPAT_HASH );
</pre><p>
        有効な値は、基本的なモジュラハッシュ化アルゴリズムでもある <code class="literal">NEW_COMPAT_HASH</code>、<code class="literal">OLD_COMPAT_HASH</code>、および <code class="literal">NATIVE_HASH</code> です。整合ハッシュ化アルゴリズムの場合は、<code class="literal">CONSISTENT_HASH</code> を使用します。これらの定数は、<code class="literal">libmemcached</code> 内の対応するハッシュ設定と同等です。
      </p><p>
        次の表に、Java の <code class="literal">com.danga.MemCached</code> メソッドと <span class="command"><strong>memcached</strong></span> インタフェース仕様に含まれる同等の汎用メソッドの概要を示します。
      </p><div class="informaltable"><table summary="この表は、Java の com.danga.MemCached メソッドと memcached インタフェース仕様に含まれる同等の汎用メソッドのリストです。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">Java の <code class="literal">com.danga.MemCached</code> メソッド</th><th scope="col">同等の汎用メソッド</th></tr></thead><tbody><tr><td scope="row"><code class="literal">get()</code></td><td>汎用の <code class="literal">get()</code>。</td></tr><tr><td scope="row"><code class="literal">getMulti(keys)</code></td><td>複数の <code class="literal">keys</code> の値を取得し、キーに <code class="literal">java.lang.String</code>、対応する値に <code class="literal">java.lang.Object</code> をそれぞれ使用して、ハッシュマップとして情報を返します。</td></tr><tr><td scope="row"><code class="literal">set()</code></td><td>汎用の <code class="literal">set()</code>。</td></tr><tr><td scope="row"><code class="literal">add()</code></td><td>汎用の <code class="literal">add()</code>。</td></tr><tr><td scope="row"><code class="literal">replace()</code></td><td>汎用の <code class="literal">replace()</code>。</td></tr><tr><td scope="row"><code class="literal">delete()</code></td><td>汎用の <code class="literal">delete()</code>。</td></tr><tr><td scope="row"><code class="literal">incr()</code></td><td>汎用の <code class="literal">incr()</code>。</td></tr><tr><td scope="row"><code class="literal">decr()</code></td><td>汎用の <code class="literal">decr()</code>。</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ha-memcached-interfaces-protocol"></a>16.6.3.9 <span class="command"><strong>memcached</strong></span> の TCP テキストプロトコルの使用</h4></div></div></div><p>
        <span class="command"><strong>memcached</strong></span> サーバーとの通信は、TCP または UDP プロトコルを介して実現されます。TCP プロトコルを使用すると、単純なテキストベースのインタフェースを使用して情報を交換できます。
      </p><p>
        <span class="command"><strong>memcached</strong></span> と通信するときは、サーバー用に構成されたポートを使用するとサーバーに接続できます。サーバーとの接続を開くときに、認証やログインは必要ありません。接続した直後から、サーバーへのコマンド送信を開始できます。完了したときは、特別な切断コマンドを送信せずに接続を終了できます。クライアントは、待機時間を短縮し、パフォーマンスを向上させるため、接続を開いたままにすることが推奨されます。
      </p><p>
        データは 2 つの形式で <code class="literal">memcached</code> サーバーに送信されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            サーバーにコマンドを送信し、サーバーから応答を受信するために使用されるテキスト行。
          </p></li><li class="listitem"><p>
            特定のキーに対する値の情報を送受信するために使用される非構造化データ。データは受信したときと同じフォーマットでクライアントに返されます。
          </p></li></ul></div><p>
        テキスト行 (コマンドと応答) および非構造化データは、どちらも常に文字列 <code class="literal">\r\n</code> で終了します。格納されるデータにこのシーケンスが含まれている可能性があるため、(非構造化データが送信される前にクライアントから返される) データの長さを使用してデータの末尾が特定されるはずです。
      </p><p>
        サーバーに対するコマンドは、操作に応じて構造化されています。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <span class="bold"><strong>ストレージコマンド</strong></span>: <code class="literal">set</code>、<code class="literal">add</code>、<code class="literal">replace</code>、<code class="literal">append</code>、<code class="literal">prepend</code>、<code class="literal">cas</code>
          </p><p>
            サーバーに対するストレージコマンドは、次の形式を取ります。
          </p><pre class="programlisting">
command key [flags] [exptime] length [noreply]
</pre><p>
            または、コンペアアンドスワップ (CAS) を使用する場合:
          </p><pre class="programlisting">
cas key [flags] [exptime] length [casunique] [noreply]
</pre><p>
            ここでは:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">command</code>: コマンド名。
              </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                    <code class="literal">set</code>: キーに対する値を格納します
                  </p></li><li class="listitem"><p>
                    <code class="literal">add</code>: キーがまだ存在しない場合に、そのキーに対してこの値を格納します
                  </p></li><li class="listitem"><p>
                    <code class="literal">replace</code>: キーがすでに存在する場合に、そのキーに対してこのキーを格納します
                  </p></li><li class="listitem"><p>
                    <code class="literal">append</code>: 指定されたキー値の末尾に指定された値を追加します。<code class="literal">flags</code> および <code class="literal">exptime</code> 引数は使用しないでください。
                  </p></li><li class="listitem"><p>
                    <code class="literal">prepend</code>: 指定されたキーの指定された値の末尾にキャッシュ内の現在の値を追加します。<code class="literal">flags</code> および <code class="literal">exptime</code> 引数は使用しないでください。
                  </p></li><li class="listitem"><p>
                    <code class="literal">cas</code>: 指定された <code class="literal">casunique</code> が一致する場合にのみ、指定されたキーを指定された値に設定します。これは、自分が情報を最後にフェッチして以降どのユーザーもその情報を更新していない場合に、その情報を変更するのと実質的に同等です。
                  </p></li></ul></div></li><li class="listitem"><p>
                <code class="literal">key</code>: キー。すべてのデータは特定のキーを使用して格納されます。キーに制御文字および空白文字を含めることはできません。キーの最大サイズは 250 文字です。
              </p></li><li class="listitem"><p>
                <code class="literal">flags</code>: 操作のフラグ (整数)。<span class="command"><strong>memcached</strong></span> のフラグは透過的です。<span class="command"><strong>memcached</strong></span> サーバーはフラグの内容を無視します。これらは、クライアントが情報のタイプを示すために使用します。<span class="command"><strong>memcached</strong></span> 1.2.0 以前では、この値は 16 ビット整数値です。<span class="command"><strong>memcached</strong></span> 1.2.1 以降では、この値は 32 ビット整数です。
              </p></li><li class="listitem"><p>
                <code class="literal">exptime</code>: 失効時間 (失効がない場合は 0)。
              </p></li><li class="listitem"><p>
                <code class="literal">length</code>: 指定された値ブロックの長さ (バイト単位、終端の <code class="literal">\r\n</code> 文字を除く)。
              </p></li><li class="listitem"><p>
                <code class="literal">casunique</code>: 既存エントリの一意の 64 ビット値。これは、既存の値と比較するために使用されます。<code class="literal">cas</code> 更新を発行するときに、<code class="literal">gets</code> コマンドから返された値を使用します。
              </p></li><li class="listitem"><p>
                <code class="literal">noreply</code>: コマンドに応答しないようにサーバーに指示します。
              </p></li></ul></div><p>
            たとえば、値 <code class="literal">abcdef</code> をキー <code class="literal">xyzkey</code> に格納するには、次を使用します。
          </p><pre class="programlisting">
set xyzkey 0 0 6\r\nabcdef\r\n
</pre><p>
            サーバーからの戻り値は、ステータスまたはエラー情報を示す 1 行です。詳細については、<a class="xref" href="ha-overview.html#ha-memcached-interfaces-protocol-responses" title="表 16.3 memcached プロトコルの応答">表16.3「<span class="command">memcached</span> プロトコルの応答」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <span class="bold"><strong>取得コマンド</strong></span>: <code class="literal">get</code>、<code class="literal">gets</code>
          </p><p>
            取得コマンドは次の形式を取ります。
          </p><pre class="programlisting">
get key1 [key2 .... keyn]
gets key1 [key2 ... keyn]
</pre><p>
            要求する各キーを空白文字で区切って、複数のキーをコマンドに指定できます。
          </p><p>
            サーバーは、次の形式の情報行で応答します。
          </p><pre class="programlisting">
VALUE key flags bytes [casunique]
</pre><p>
            ここでは:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">key</code>: キー名。
              </p></li><li class="listitem"><p>
                <code class="literal">flags</code>: 値を格納したときに <span class="command"><strong>memcached</strong></span> サーバーに提供されたフラグ整数の値。
              </p></li><li class="listitem"><p>
                <code class="literal">bytes</code>: 格納されている値のサイズ (終端の <code class="literal">\r\n</code> 文字シーケンスを除く)。
              </p></li><li class="listitem"><p>
                <code class="literal">casunique</code>: 項目を識別する一意の 64 ビット整数。
              </p></li></ul></div><p>
            情報行の直後に値のデータブロックが続きます。例:
          </p><pre class="programlisting">
get xyzkey\r\n
VALUE xyzkey 0 6\r\n
abcdef\r\n
</pre><p>
            複数のキーを要求した場合は、見つかったキーごとに情報行とデータブロックが返されます。要求されたキーがキャッシュに存在しない場合、情報は返されません。
          </p></li><li class="listitem"><p>
            <span class="bold"><strong>削除コマンド</strong></span>: <code class="literal">delete</code>
          </p><p>
            削除コマンドは次の形式を取ります。
          </p><pre class="programlisting">
delete key [time] [noreply]
</pre><p>
            ここでは:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">key</code>: キー名。
              </p></li><li class="listitem"><p>
                <code class="literal">time</code>: クライアントがサーバーにこのキーの <code class="literal">add</code> または <code class="literal">replace</code> コマンドを拒否するように求める秒単位の時間 (または特定の Unix 時間)。この期間中は、すべての <code class="literal">add</code>、<code class="literal">replace</code>、<code class="literal">get</code>、および <code class="literal">gets</code> コマンドが失敗します。<code class="literal">set</code> 操作は成功します。この期間が過ぎると、そのキーは永続的に削除され、すべてのコマンドが許可されます。
              </p><p>
                指定しなかった場合、この値は 0 (ただちに削除) とみなされます。
              </p></li><li class="listitem"><p>
                <code class="literal">noreply</code>: コマンドに応答しないようにサーバーに指示します。
              </p></li></ul></div><p>
            このコマンドに対する応答は、キーが正常に削除されたことを示す <code class="literal">DELETED</code> か、指定されたキーが見つからなかったことを示す <code class="literal">NOT_FOUND</code> のいずれかです。
          </p></li><li class="listitem"><p>
            <span class="bold"><strong>増分/減分</strong></span>: <code class="literal">incr</code>、<code class="literal">decr</code>
          </p><p>
            増分および減分コマンドは、個別の取得/設定シーケンスを実行せずにサーバー内のキーの値を変更します。これらの操作は、現在格納されている値が 64 ビット整数であることを前提としています。格納されている値が 64 ビット整数でない場合は、増分または減分操作を適用する前にその値が 0 とみなされます。
          </p><p>
            増分および減分コマンドは次の形式を取ります。
          </p><pre class="programlisting">
incr key value [noreply]
decr key value [noreply]
</pre><p>
            ここでは:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">key</code>: キー名。
              </p></li><li class="listitem"><p>
                <code class="literal">value</code>: 増分または減分値として使用される整数。
              </p></li><li class="listitem"><p>
                <code class="literal">noreply</code>: コマンドに応答しないようにサーバーに指示します。
              </p></li></ul></div><p>
            応答は次のとおりです。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">NOT_FOUND</code>: 指定されたキーが見つかりませんでした。
              </p></li><li class="listitem"><p>
                <code class="literal">value</code>: 指定されたキーに関連付けられた新しい値。
              </p></li></ul></div><p>
            値は符号なしとみなされます。<code class="literal">decr</code> 操作では、値が 0 未満に減分されることはありません。<code class="literal">incr</code> 操作では、64 ビットの最大値で値が折り返します。
          </p></li><li class="listitem"><p>
            <span class="bold"><strong>統計コマンド</strong></span>: <code class="literal">stats</code>
          </p><p>
            <code class="literal">stats</code> コマンドは、<span class="command"><strong>memcached</strong></span> インスタンスの現在のステータスとそこに格納されているデータに関する詳細な統計情報を提供します。
          </p><p>
            統計コマンドは次の形式を取ります。
          </p><pre class="programlisting">
STAT [name] [value]
</pre><p>
            ここでは:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">name</code>: 返される統計の名前 (オプション)。指定しなかった場合は、一般統計が返されます。
              </p></li><li class="listitem"><p>
                <code class="literal">value</code>: 特定の統計操作を実行するときに使用される特定の値。
              </p></li></ul></div><p>
            戻り値は、次のようにフォーマットされた統計データのリストです。
          </p><pre class="programlisting">
STAT name value
</pre><p>
            統計は <code class="literal">END</code> という 1 行で終了します。
          </p><p>
            詳細については、<a class="xref" href="ha-overview.html#ha-memcached-stats" title="16.6.4 memcached の統計の取得">セクション16.6.4「<span class="command"><strong>memcached</strong></span> の統計の取得」</a>を参照してください。
          </p></li></ul></div><p>
        参考のため、サポートされる各種のコマンドとその形式のリストを次に示します。
      </p><div class="table"><a name="idm139979056529296"></a><p class="title"><b>表 16.2 <span class="command">memcached</span> コマンドのリファレンス</b></p><div class="table-contents"><table summary="memcached コマンドのリファレンス" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">コマンド</th><th scope="col">コマンド形式</th></tr></thead><tbody><tr><td scope="row"><code class="literal">set</code></td><td><code class="literal">set key flags exptime length</code>、<code class="literal">set key flags exptime length noreply</code></td></tr><tr><td scope="row"><code class="literal">add</code></td><td><code class="literal">add key flags exptime length</code>、<code class="literal">add key flags exptime length noreply</code></td></tr><tr><td scope="row"><code class="literal">replace</code></td><td><code class="literal">replace key flags exptime length</code>、<code class="literal">replace key flags exptime length noreply</code></td></tr><tr><td scope="row"><code class="literal">append</code></td><td><code class="literal">append key length</code>、<code class="literal">append key length noreply</code></td></tr><tr><td scope="row"><code class="literal">prepend</code></td><td><code class="literal">prepend key length</code>、<code class="literal">prepend key length noreply</code></td></tr><tr><td scope="row"><code class="literal">cas</code></td><td><code class="literal">cas key flags exptime length casunique</code>、<code class="literal">cas key flags exptime length casunique noreply</code></td></tr><tr><td scope="row"><code class="literal">get</code></td><td><code class="literal">get key1 [key2 ... keyn]</code></td></tr><tr><td scope="row"><code class="literal">gets</code></td><td><code class="literal"></code></td></tr><tr><td scope="row"><code class="literal">delete</code></td><td><code class="literal">delete key</code>、<code class="literal">delete key noreply</code>、<code class="literal">delete key expiry</code>、<code class="literal">delete key expiry noreply</code></td></tr><tr><td scope="row"><code class="literal">incr</code></td><td><code class="literal">incr key</code>、<code class="literal">incr key noreply</code>、<code class="literal">incr key value</code>、<code class="literal">incr key value noreply</code></td></tr><tr><td scope="row"><code class="literal">decr</code></td><td><code class="literal">decr key</code>、<code class="literal">decr key noreply</code>、<code class="literal">decr key value</code>、<code class="literal">decr key value noreply</code></td></tr><tr><td scope="row"><code class="literal">stat</code></td><td><code class="literal">stat</code>、<code class="literal">stat name</code>、<code class="literal">stat name value</code></td></tr></tbody></table></div></div><br class="table-break"><p>
        サーバーにコマンドを送信すると、サーバーからの応答は次の表に示すいずれかの設定になります。サーバーからの応答値はすべて <code class="literal">\r\n</code> で終了します。
      </p><div class="table"><a name="ha-memcached-interfaces-protocol-responses"></a><p class="title"><b>表 16.3 <span class="command">memcached</span> プロトコルの応答</b></p><div class="table-contents"><table summary="memcached プロトコルの応答" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">文字列</th><th scope="col">説明</th></tr></thead><tbody><tr><td scope="row"><code class="literal">STORED</code></td><td>値が正常に格納されました。</td></tr><tr><td scope="row"><code class="literal">NOT_STORED</code></td><td>値が格納されませんでしたが、エラーが原因ではありません。値を追加または (存在する場合に) 更新するコマンド (<code class="literal">add</code> や <code class="literal">replace</code> など)、または項目がすでに削除するように設定されているときのコマンドに対応します。</td></tr><tr><td scope="row"><code class="literal">EXISTS</code></td><td><code class="literal">cas</code> コマンドを使用したときに、格納しようとしている項目がすでに存在し、最後のチェック以降に変更されています。</td></tr><tr><td scope="row"><code class="literal">NOT_FOUND</code></td><td>格納、更新、または削除しようとしている項目が存在しないか、すでに削除されています。</td></tr><tr><td scope="row"><code class="literal">ERROR</code></td><td>存在しないコマンド名を送信しました。</td></tr><tr><td scope="row"><code class="literal">CLIENT_ERROR errorstring</code></td><td>入力行にエラーがありました。詳細は <code class="literal">errorstring</code> に含まれています。</td></tr><tr><td scope="row"><code class="literal">SERVER_ERROR errorstring</code></td><td>サーバーにエラーがあったため、情報を返すことができません。極端な場合には、このエラーの発生後にサーバーがクライアントから切断されることがあります。</td></tr><tr><td scope="row"><code class="literal">VALUE keys flags length</code></td><td>要求されたキーが見つかり、格納されている <code class="literal">key</code>、<code class="literal">flags</code>、およびデータブロックが指定された <code class="literal">length</code> で返されます。</td></tr><tr><td scope="row"><code class="literal">DELETED</code></td><td>要求されたキーがサーバーから削除されました。</td></tr><tr><td scope="row"><code class="literal">STAT name value</code></td><td>統計データの行。</td></tr><tr><td scope="row"><code class="literal">END</code></td><td>統計データの終わり。</td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="ha-memcached-stats"></a>16.6.4 <span class="command"><strong>memcached</strong></span> の統計の取得</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="ha-overview.html#ha-memcached-stats-general">16.6.4.1 <span class="command"><strong>memcached</strong></span> の一般統計</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-memcached-stats-slabs">16.6.4.2 <span class="command"><strong>memcached</strong></span> のスラブ統計</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-memcached-stats-items">16.6.4.3 <span class="command"><strong>memcached</strong></span> の項目統計</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-memcached-stats-sizes">16.6.4.4 <span class="command"><strong>memcached</strong></span> のサイズ統計</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-memcached-stats-detail">16.6.4.5 <code class="literal">memcached</code> の詳細統計</a></span></dt><dt><span class="section"><a href="ha-overview.html#ha-memcached-stats-memcached-tool">16.6.4.6 <span class="command"><strong>memcached-tool</strong></span> の使用</a></span></dt></dl></div><p>
      <span class="command"><strong>memcached</strong></span> システムには、キャッシュに格納されるデータに関する情報、キャッシュヒット率、および個々の項目を格納するために使用されるスラブ割り当てを介したメモリーの使用状況と情報の分布に関する詳細情報を収集する統計システムが組み込まれています。統計は、主要な統計を提供する基本レベルと、<span class="command"><strong>memcached</strong></span> サーバーの特定の分野に関するより具体的な統計の両方が提供されます。
    </p><p>
      これらの情報は、キャッシュとメモリーの使用状況を正しいレベルで取得し、スラブ割り当てと構成プロパティーが最適なレベルで設定されていることを確認するのに役立ちます。
    </p><p>
      統計インタフェースは標準の <span class="command"><strong>memcached</strong></span> プロトコルを介して使用できるため、<span class="command"><strong>telnet</strong></span> を使用して <span class="command"><strong>memcached</strong></span> に接続してレポートにアクセスできます。付属の <span class="command"><strong>memcached-tool</strong></span> には、<a class="xref" href="ha-overview.html#ha-memcached-stats-slabs" title="16.6.4.2 memcached のスラブ統計">セクション16.6.4.2「<span class="command"><strong>memcached</strong></span> のスラブ統計」</a>および<a class="xref" href="ha-overview.html#ha-memcached-stats-general" title="16.6.4.1 memcached の一般統計">セクション16.6.4.1「<span class="command"><strong>memcached</strong></span> の一般統計」</a>の情報を取得するためのサポートが含まれています。詳細については、<a class="xref" href="ha-overview.html#ha-memcached-stats-memcached-tool" title="16.6.4.6 memcached-tool の使用">セクション16.6.4.6「<span class="command"><strong>memcached-tool</strong></span> の使用」</a>を参照してください。
    </p><p>
      また、ほとんどの言語 API インタフェースに、サーバーから統計を取得するための関数が用意されています。
    </p><p>
      たとえば、<span class="command"><strong>telnet</strong></span> を使用して基本統計を取得するには:
    </p><pre class="programlisting">
shell&gt; telnet localhost 11211
Trying ::1...
Connected to localhost.
Escape character is '^]'.
stats
STAT pid 23599
STAT uptime 675
STAT time 1211439587
STAT version 1.2.5
STAT pointer_size 32
STAT rusage_user 1.404992
STAT rusage_system 4.694685
STAT curr_items 32
STAT total_items 56361
STAT bytes 2642
STAT curr_connections 53
STAT total_connections 438
STAT connection_structures 55
STAT cmd_get 113482
STAT cmd_set 80519
STAT get_hits 78926
STAT get_misses 34556
STAT evictions 0
STAT bytes_read 6379783
STAT bytes_written 4860179
STAT limit_maxbytes 67108864
STAT threads 1
END
</pre><p>
      Perl と <code class="literal">Cache::Memcached</code> モジュールを使用するときは、<code class="literal">stats()</code> 関数によって、接続オブジェクト内に現在構成されているサーバーに関する情報と <span class="command"><strong>memcached</strong></span> サーバーの全体的な統計が返されます。
    </p><p>
      たとえば、次の Perl スクリプトは統計を取得し、返されたハッシュ参照をダンプします。
    </p><pre class="programlisting">
use Cache::Memcached;
use Data::Dumper;

my $memc = new Cache::Memcached;
$memc-&gt;set_servers(\@ARGV);

print Dumper($memc-&gt;stats());
</pre><p>
      前の <span class="command"><strong>Telnet</strong></span> の例で使用したのと同じ <span class="command"><strong>memcached</strong></span> に対して実行すると、ホスト単位の統計と全体的な統計を含むハッシュ参照が得られます。
    </p><pre class="programlisting">
$VAR1 = {
    'hosts' =&gt; {
           'localhost:11211' =&gt; {
                      'misc' =&gt; {
                            'bytes' =&gt; '2421',
                            'curr_connections' =&gt; '3',
                            'connection_structures' =&gt; '56',
                            'pointer_size' =&gt; '32',
                            'time' =&gt; '1211440166',
                            'total_items' =&gt; '410956',
                            'cmd_set' =&gt; '588167',
                            'bytes_written' =&gt; '35715151',
                            'evictions' =&gt; '0',
                            'curr_items' =&gt; '31',
                            'pid' =&gt; '23599',
                            'limit_maxbytes' =&gt; '67108864',
                            'uptime' =&gt; '1254',
                            'rusage_user' =&gt; '9.857805',
                            'cmd_get' =&gt; '838451',
                            'rusage_system' =&gt; '34.096988',
                            'version' =&gt; '1.2.5',
                            'get_hits' =&gt; '581511',
                            'bytes_read' =&gt; '46665716',
                            'threads' =&gt; '1',
                            'total_connections' =&gt; '3104',
                            'get_misses' =&gt; '256940'
                          },
                      'sizes' =&gt; {
                             '128' =&gt; '16',
                             '64' =&gt; '15'
                           }
                    }
         },
    'self' =&gt; {},
    'total' =&gt; {
           'cmd_get' =&gt; 838451,
           'bytes' =&gt; 2421,
           'get_hits' =&gt; 581511,
           'connection_structures' =&gt; 56,
           'bytes_read' =&gt; 46665716,
           'total_items' =&gt; 410956,
           'total_connections' =&gt; 3104,
           'cmd_set' =&gt; 588167,
           'bytes_written' =&gt; 35715151,
           'curr_items' =&gt; 31,
           'get_misses' =&gt; 256940
         }
        };
</pre><p>
      統計はいくつかの異なるセクションに分かれており、<code class="literal">stats</code> コマンドにタイプを追加して要求できます。個々の統計出力については、次のセクションで詳しく説明します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          一般統計については、<a class="xref" href="ha-overview.html#ha-memcached-stats-general" title="16.6.4.1 memcached の一般統計">セクション16.6.4.1「<span class="command"><strong>memcached</strong></span> の一般統計」</a>を参照してください。
        </p></li><li class="listitem"><p>
          スラブ統計 (<code class="literal">slabs</code>) については、<a class="xref" href="ha-overview.html#ha-memcached-stats-slabs" title="16.6.4.2 memcached のスラブ統計">セクション16.6.4.2「<span class="command"><strong>memcached</strong></span> のスラブ統計」</a>を参照してください。
        </p></li><li class="listitem"><p>
          項目統計 (<code class="literal">items</code>) については、<a class="xref" href="ha-overview.html#ha-memcached-stats-items" title="16.6.4.3 memcached の項目統計">セクション16.6.4.3「<span class="command"><strong>memcached</strong></span> の項目統計」</a>を参照してください。
        </p></li><li class="listitem"><p>
          サイズ統計 (<code class="literal">sizes</code>) については、<a class="xref" href="ha-overview.html#ha-memcached-stats-sizes" title="16.6.4.4 memcached のサイズ統計">セクション16.6.4.4「<span class="command"><strong>memcached</strong></span> のサイズ統計」</a>を参照してください。
        </p></li><li class="listitem"><p>
          詳細ステータス (<code class="literal">detail</code>) については、<a class="xref" href="ha-overview.html#ha-memcached-stats-detail" title="16.6.4.5 memcached の詳細統計">セクション16.6.4.5「<code class="literal">memcached</code> の詳細統計」</a>を参照してください。
        </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ha-memcached-stats-general"></a>16.6.4.1 <span class="command"><strong>memcached</strong></span> の一般統計</h4></div></div></div><p>
        一般統計の出力には、<span class="command"><strong>memcached</strong></span> インスタンスのパフォーマンスと使用の概要が示されます。コマンドによって返される統計とそれらの意味を、次の表に示します。
      </p><p>
        各統計値の値の型を定義するために、次の用語が使用されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">32u</code>: 32 ビット符号なし整数
          </p></li><li class="listitem"><p>
            <code class="literal">64u</code>: 64 ビット符号なし整数
          </p></li><li class="listitem"><p>
            <code class="literal">32u:32u</code>: コロンで区切られた 2 つの 32 ビット符号なし整数
          </p></li><li class="listitem"><p>
            <code class="literal">String</code>: 文字列
          </p></li></ul></div><div class="informaltable"><table summary="この表は、memcached の一般統計のリストであり、各統計のデータ型と説明を示しています。" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th scope="col">統計</th><th scope="col">データ型</th><th scope="col">説明</th><th scope="col">バージョン</th></tr></thead><tbody><tr><td scope="row"><code class="literal">pid</code></td><td>32u</td><td><span class="command"><strong>memcached</strong></span> インスタンスのプロセス ID。</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">uptime</code></td><td>32u</td><td>この <span class="command"><strong>memcached</strong></span> インスタンスの稼働時間 (秒単位)。</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">time</code></td><td>32u</td><td>現在の時間 (エポックとして)。</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">version</code></td><td>string</td><td>このインスタンスのバージョン文字列。</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">pointer_size</code></td><td>string</td><td>ビット単位で指定されたこのホストのポインタのサイズ (32 または 64)。</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">rusage_user</code></td><td>32u:32u</td><td>このインスタンスの合計ユーザー時間 (秒:ミリ秒)。</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">rusage_system</code></td><td>32u:32u</td><td>このインスタンスの合計システム時間 (秒:ミリ秒)。</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">curr_items</code></td><td>32u</td><td>このインスタンスによって格納された項目の現在数。</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">total_items</code></td><td>32u</td><td>このインスタンスの存続期間中に格納された項目の合計数。</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">bytes</code></td><td>64u</td><td>このサーバーが項目を格納するために使用した現在のバイト数。</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">curr_connections</code></td><td>32u</td><td>現在開いている接続の数。</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">total_connections</code></td><td>32u</td><td>サーバーが実行を開始してから開かれた接続の合計数。</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">connection_structures</code></td><td>32u</td><td>サーバーが割り当てた接続構造の数。</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">cmd_get</code></td><td>64u</td><td>取得要求 (<code class="literal">get</code> 操作) の合計数。</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">cmd_set</code></td><td>64u</td><td>ストレージ要求 (<code class="literal">set</code> 操作) の合計数。</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">get_hits</code></td><td>64u</td><td>要求され、存在することがわかったキーの数。</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">get_misses</code></td><td>64u</td><td>要求され、見つからなかった項目の数。</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">delete_hits</code></td><td>64u</td><td>削除され、存在することがわかったキーの数。</td><td>1.3.x</td></tr><tr><td scope="row"><code class="literal">delete_misses</code></td><td>64u</td><td>削除され、見つからなかった項目の数。</td><td>1.3.x</td></tr><tr><td scope="row"><code class="literal">incr_hits</code></td><td>64u</td><td>増分され、存在することがわかったキーの数。</td><td>1.3.x</td></tr><tr><td scope="row"><code class="literal">incr_misses</code></td><td>64u</td><td>増分され、見つからなかった項目の数。</td><td>1.3.x</td></tr><tr><td scope="row"><code class="literal">decr_hits</code></td><td>64u</td><td>減分され、存在することがわかったキーの数。</td><td>1.3.x</td></tr><tr><td scope="row"><code class="literal">decr_misses</code></td><td>64u</td><td>減分され、見つからなかった項目の数。</td><td>1.3.x</td></tr><tr><td scope="row"><code class="literal">cas_hits</code></td><td>64u</td><td>コンペアアンドスワップが行われ、存在することがわかったキーの数。</td><td>1.3.x</td></tr><tr><td scope="row"><code class="literal">cas_misses</code></td><td>64u</td><td>コンペアアンドスワップが行われ、見つからなかった項目の数。</td><td>1.3.x</td></tr><tr><td scope="row"><code class="literal">cas_badvalue</code></td><td>64u</td><td>コンペアアンドスワップが行われたが、比較対象の (元の) 値が指定された値と一致しなかったキーの数。</td><td>1.3.x</td></tr><tr><td scope="row"><code class="literal">evictions</code></td><td>64u</td><td>新しい項目用のメモリーを解放するためにキャッシュから削除された有効な項目数。</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">bytes_read</code></td><td>64u</td><td>このサーバーがネットワークから読み取った合計バイト数。</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">bytes_written</code></td><td>64u</td><td>このサーバーがネットワークに送信した合計バイト数。</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">limit_maxbytes</code></td><td>32u</td><td>このサーバーで格納への使用が許可されたバイト数。</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">threads</code></td><td>32u</td><td>要求されたワーカースレッドの数。</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">conn_yields</code></td><td>64u</td><td>接続の生成数 (<code class="option">-R</code> オプションに関連します)。</td><td>1.4.0</td></tr></tbody></table></div><p>
        ここに示した統計の中でもっとも有用なものは、キャッシュヒット、キャッシュミス、および削除の数です。
      </p><p>
        <code class="literal">get_misses</code> の数が大きい場合は、キャッシュへの情報移入がまだ完了していないことを示している可能性があります。この数は、時間の経過とともにキャッシュの <code class="literal">get_hits</code> の数に比べて減少します。ただし、長時間の実行後にキャッシュミスの数がキャッシュヒットより多い場合は、キャッシュのサイズが小さすぎるため、メモリーの合計サイズまたは <span class="command"><strong>memcached</strong></span> インスタンスの数を増やしてヒット率を向上させる必要があることを示す可能性があります。
      </p><p>
        キャッシュの <code class="literal">evictions</code> の数が (特に格納されている項目の数に比べて) 多い場合は、キャッシュが小さすぎて、定期的にキャッシュし続ける必要がある情報量を保持できないことを示します。キャッシュ内に項目を保持する代わりに、新しい項目が入るように項目が削除されるため、キャッシュ内の項目の回転率は常に高くなりますが、キャッシュの効率は下がります。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ha-memcached-stats-slabs"></a>16.6.4.2 <span class="command"><strong>memcached</strong></span> のスラブ統計</h4></div></div></div><p>
        <code class="literal">slabs</code> 統計を取得するには、<code class="literal">stats slabs</code> コマンドまたは同等の API を使用します。
      </p><p>
        スラブ統計には、キャッシュ内に情報を格納するために作成され、割り当てられたスラブに関する情報が示されます。個々のスラブクラスに関する情報とスラブの全体的な統計の両方を取得します。
      </p><pre class="programlisting">
STAT 1:chunk_size 104
STAT 1:chunks_per_page 10082
STAT 1:total_pages 1
STAT 1:total_chunks 10082
STAT 1:used_chunks 10081
STAT 1:free_chunks 1
STAT 1:free_chunks_end 10079
STAT 9:chunk_size 696
STAT 9:chunks_per_page 1506
STAT 9:total_pages 63
STAT 9:total_chunks 94878
STAT 9:used_chunks 94878
STAT 9:free_chunks 0
STAT 9:free_chunks_end 0
STAT active_slabs 2
STAT total_malloced 67083616
END
</pre><p>
        各スラブクラスの個々の統計には、プリフィクスとしてスラブ ID が付いています。割り当てられた各スラブには、サイズのもっとも小さいものから大きいものまで順に、一意の ID が付けられます。このプリフィクス番号は、指定された増大係数から計算されたチャンクに基づくスラブクラス番号を示しています。したがって、この例では 1 が最初のチャンクサイズであり、9 が 9 番目に割り当てられたチャンクサイズです。
      </p><p>
        各チャンクサイズに対して返されるパラメータと各パラメータの説明を、次の表に示します。
      </p><div class="informaltable"><table summary="この表は、各チャンクサイズに対して返される memcached のスラブ統計パラメータのリストです。この表は、統計名、説明、およびその統計が導入された memcached のバージョン (該当する場合) を示しています。" border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">統計</th><th scope="col">説明</th><th scope="col">バージョン</th></tr></thead><tbody><tr><td scope="row"><code class="literal">chunk_size</code></td><td>このスラブクラス内の各チャンクに割り当てられたスペース。</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">chunks_per_page</code></td><td>このスラブクラスの 1 つのページに含まれるチャンクの数。</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">total_pages</code></td><td>このスラブクラスに割り当てられたページの数。</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">total_chunks</code></td><td>このスラブクラスに割り当てられたチャンクの数。</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">used_chunks</code></td><td>項目に割り当てられたチャンクの数。</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">free_chunks</code></td><td>項目にまだ割り当てられていないチャンクの数。</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">free_chunks_end</code></td><td>最後に割り当てられたページの最後にある空きチャンクの数。</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">get_hits</code></td><td>このチャンクの取得ヒットの数</td><td>1.3.x</td></tr><tr><td scope="row"><code class="literal">cmd_set</code></td><td>このチャンクに対する設定コマンドの数</td><td>1.3.x</td></tr><tr><td scope="row"><code class="literal">delete_hits</code></td><td>このチャンクの削除ヒットの数</td><td>1.3.x</td></tr><tr><td scope="row"><code class="literal">incr_hits</code></td><td>このチャンクの増分ヒットの数</td><td>1.3.x</td></tr><tr><td scope="row"><code class="literal">decr_hits</code></td><td>このチャンクの減分ヒットの数</td><td>1.3.x</td></tr><tr><td scope="row"><code class="literal">cas_hits</code></td><td>このチャンクの CAS ヒットの数</td><td>1.3.x</td></tr><tr><td scope="row"><code class="literal">cas_badval</code></td><td>このチャンクで既存の値が一致しなかった CAS ヒットの数</td><td>1.3.x</td></tr><tr><td scope="row"><code class="literal">mem_requested</code></td><td>このチャンク内の要求メモリーの実際のメモリー量</td><td>1.4.1</td></tr></tbody></table></div><p>
        次に示す追加の統計は、チャンク単位ではなく、サーバー全体の情報を対象としています。
      </p><div class="informaltable"><table summary="この表は、1 つのチャンクではなく、サーバー全体の情報を提供する memcached のスラブ統計のリストです。この表は、統計名、説明、およびバージョン (該当する場合) を示しています。" border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">統計</th><th scope="col">説明</th><th scope="col">バージョン</th></tr></thead><tbody><tr><td scope="row"><code class="literal">active_slabs</code></td><td>割り当てられたスラブクラスの合計数。</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">total_malloced</code></td><td>スラブのページに割り当てられたメモリーの合計量。</td><td class="auto-generated"> </td></tr></tbody></table></div><p>
        スラブ統計のキー値は、<code class="literal">chunk_size</code> と、対応する <code class="literal">total_chunks</code> および <code class="literal">used_chunks</code> パラメータです。これらは、システム内のチャンクのサイズ使用状況の目安になります。1 つのキー/値ペアが適切なサイズのチャンクに配置されます。
      </p><p>
        これらの統計から、サイズとチャンクの割り当ておよび分布を把握できます。多くの項目をいくつかの大幅に異なるサイズで格納する場合は、チャンクとメモリーの浪費を防ぐため、チャンクサイズの増大係数をより大きなステップで増加するように調整してください。増大係数が不適切であることを示すわかりやすい兆候は、スラブクラスの数が多いのに、各スラブ内で実際に使用されているチャンクの数が比較的少ないことです。増大係数を増やすと、作成されるスラブクラスの数が減るため、割り当てられたページをより有効に利用できます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ha-memcached-stats-items"></a>16.6.4.3 <span class="command"><strong>memcached</strong></span> の項目統計</h4></div></div></div><p>
        <code class="literal">items</code> 統計を取得するには、<code class="literal">stats items</code> コマンドまたは同等の API を使用します。
      </p><p>
        <code class="literal">items</code> 統計には、特定のスラブクラス内に割り当てられた個々の項目に関する情報が示されます。
      </p><pre class="programlisting">
STAT items:2:number 1
STAT items:2:age 452
STAT items:2:evicted 0
STAT items:2:evicted_nonzero 0
STAT items:2:evicted_time 2
STAT items:2:outofmemory 0
STAT items:2:tailrepairs 0
...
STAT items:27:number 1
STAT items:27:age 452
STAT items:27:evicted 0
STAT items:27:evicted_nonzero 0
STAT items:27:evicted_time 2
STAT items:27:outofmemory 0
STAT items:27:tailrepairs 0
</pre><p>
        各統計に付けられたプリフィクス番号は、<code class="literal">stats slabs</code> 統計によって返される対応するチャンクサイズに関連しています。結果として表示されるのは、各スラブサイズ内の各チャンクに格納された項目数と、それらの存続期間、削除カウント、およびメモリー不足カウントです。この統計のサマリーを次の表に示します。
      </p><div class="informaltable"><table summary="この表は、memcached の項目統計のリストであり、それぞれに関する説明を示しています。" border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">統計</th><th scope="col">説明</th><td class="auto-generated"> </td></tr></thead><tbody><tr><td scope="row"><code class="literal">number</code></td><td>このスラブクラスに現在格納されている項目の数。</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">age</code></td><td>このスラブクラス内でもっとも古い項目の存続期間 (秒単位)。</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">evicted</code></td><td>新しいエントリを入れるために削除された項目の数。</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">evicted_time</code></td><td>エントリが最後に削除された時間</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">evicted_nonzero</code></td><td>0 以外のエントリが最後に削除された時間</td><td>1.4.0</td></tr><tr><td scope="row"><code class="literal">outofmemory</code></td><td>このスラブクラスの、メモリー不足エラーが発生した項目の数 (<code class="literal">-M</code> コマンド行オプションが有効な場合のみの値)。</td><td class="auto-generated"> </td></tr><tr><td scope="row"><code class="literal">tailrepairs</code></td><td>特定の ID のエントリを修復する必要が生じた回数</td><td class="auto-generated"> </td></tr></tbody></table></div><p>
        項目レベルの統計は、特定のスラブ内に格納されている項目の数、およびそれらの更新と再利用のレベルの特定に使用できます。これは、ほかと比べて削除の回数が非常に多いスラブクラスがあるかどうかを識別するのに役立ちます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ha-memcached-stats-sizes"></a>16.6.4.4 <span class="command"><strong>memcached</strong></span> のサイズ統計</h4></div></div></div><p>
        サイズ統計を取得するには、<code class="literal">stats sizes</code> コマンドまたは同等の API を使用します。
      </p><p>
        サイズ統計には、キャッシュ内の各サイズの項目のサイズと数に関する情報が示されます。これらの情報は 2 つのカラムで返されます。1 つ目のカラムは項目のサイズ (もっとも近い 32 バイト境界に丸められます) で、2 つ目のカラムはキャッシュに含まれるそのサイズの項目の数です。
      </p><pre class="programlisting">
96 35
128 38
160 807
192 804
224 410
256 222
288 83
320 39
352 53
384 33
416 64
448 51
480 30
512 54
544 39
576 10065
</pre><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注意</div><p>
          この統計を実行すると、キャッシュから各項目が読み取られ、そのサイズが計算されるたびにキャッシュがロックアップします。大規模なキャッシュでは、これに時間がかかり、プロセスが完了するまで設定または取得操作を実行できない場合があります。
        </p></div><p>
        項目サイズの統計は、格納しているオブジェクトのサイズを特定する場合にのみ役立ちます。実際のメモリー割り当てはチャンクサイズとページサイズにのみ関連しているため、これらの情報は綿密なデバッグまたは診断セッションでのみ役立ちます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ha-memcached-stats-detail"></a>16.6.4.5 <code class="literal">memcached</code> の詳細統計</h4></div></div></div><p>
        <span class="command"><strong>memcached</strong></span> 1.3.x 以降では、キャッシュに格納された個々のキーに対する取得、設定、および削除操作に関する詳細統計を有効にして取得し、それらの試行によって特定のキーがヒットした (見つかった) かどうかを特定できます。これらの操作は、詳細統計分析がオンになっている間だけ記録されます。
      </p><p>
        詳細統計を有効にするには、<span class="command"><strong>memcached</strong></span> サーバーに <code class="literal">stats detail on</code> コマンドを送信する必要があります。
      </p><pre class="programlisting">
$ telnet localhost 11211
Trying 127.0.0.1...
Connected to tiger.
Escape character is '^]'.
<strong class="userinput"><code>stats detail on</code></strong>
OK
</pre><p>
        個々の統計は、キー (サーバーに現在格納されていないキーを含む) に対する <code class="literal">get</code>、<code class="literal">set</code>、および <code class="literal">del</code> 操作のたびに記録されます。たとえば、キー <code class="literal">abckey</code> の値を取得しようとして存在しなかった場合、詳細統計が有効になっている間は、指定されたキーが現在格納されていなくても、そのキーに対して行われた <code class="literal">get</code> 操作が記録されます。<code class="literal">hits</code> (つまり、サーバーに存在するキーに対する <code class="literal">get</code> または <code class="literal">del</code> 操作の数) もカウントされます。
      </p><p>
        詳細統計をオフにするには、<span class="command"><strong>memcached</strong></span> サーバーに対して <code class="literal">stats detail off</code> コマンドを送信します。
      </p><pre class="programlisting">
$ telnet localhost 11211
Trying 127.0.0.1...
Connected to tiger.
Escape character is '^]'.
<strong class="userinput"><code>stats detail on</code></strong>
OK
</pre><p>
        プロセス中に記録された詳細統計を取得するには、<span class="command"><strong>memcached</strong></span> サーバーに対して <code class="literal">stats detail dump</code> コマンドを送信します。
      </p><pre class="programlisting">
stats detail dump
PREFIX hykkey get 0 hit 0 set 1 del 0
PREFIX xyzkey get 0 hit 0 set 1 del 0
PREFIX yukkey get 1 hit 0 set 0 del 0
PREFIX abckey get 3 hit 3 set 1 del 0
END
</pre><p>
        詳細統計の情報を使用して <code class="literal">hit</code> と <code class="literal">get</code> または <code class="literal">del</code> のカウントを比較すると、<span class="command"><strong>memcached</strong></span> クライアントがサーバーに存在しないキーを数多く使用しているかどうかを特定できます。これらの情報はキーごとに記録されるため、失敗や操作が特定のキーに集中しているかどうかも特定できます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ha-memcached-stats-memcached-tool"></a>16.6.4.6 <span class="command"><strong>memcached-tool</strong></span> の使用</h4></div></div></div><p>
        <span class="command"><strong>memcached-tool</strong></span> は、<span class="command"><strong>memcached</strong></span> ソースディレクトリの <code class="filename">scripts</code> ディレクトリ内にあります。このツールを使用すると、<span class="command"><strong>memcached</strong></span> インスタンスから一部のレポートおよび統計に簡単にアクセスできます。
      </p><p>
        このコマンドの基本形式は次のとおりです。
      </p><pre class="programlisting">
shell&gt; ./memcached-tool hostname:port [command]
</pre><p>
        デフォルトの出力では、スラブの割り当てと使用状況のリストが生成されます。例:
      </p><pre class="programlisting">
shell&gt; memcached-tool localhost:11211 display
  #  Item_Size  Max_age   Pages   Count   Full?  Evicted Evict_Time OOM
  1      80B        93s       1      20      no        0        0    0
  2     104B        93s       1      16      no        0        0    0
  3     136B      1335s       1      28      no        0        0    0
  4     176B      1335s       1      24      no        0        0    0
  5     224B      1335s       1      32      no        0        0    0
  6     280B      1335s       1      34      no        0        0    0
  7     352B      1335s       1      36      no        0        0    0
  8     440B      1335s       1      46      no        0        0    0
  9     552B      1335s       1      58      no        0        0    0
 10     696B      1335s       1      66      no        0        0    0
 11     872B      1335s       1      89      no        0        0    0
 12     1.1K      1335s       1     112      no        0        0    0
 13     1.3K      1335s       1     145      no        0        0    0
 14     1.7K      1335s       1     123      no        0        0    0
 15     2.1K      1335s       1     198      no        0        0    0
 16     2.6K      1335s       1     199      no        0        0    0
 17     3.3K      1335s       1     229      no        0        0    0
 18     4.1K      1335s       1     248     yes       36        2    0
 19     5.2K      1335s       2     328      no        0        0    0
 20     6.4K      1335s       2     316     yes      387        1    0
 21     8.1K      1335s       3     381     yes      492        1    0
 22    10.1K      1335s       3     303     yes      598        2    0
 23    12.6K      1335s       5     405     yes      605        1    0
 24    15.8K      1335s       6     384     yes      766        2    0
 25    19.7K      1335s       7     357     yes      908      170    0
 26    24.6K      1336s       7     287     yes     1012        1    0
 27    30.8K      1336s       7     231     yes     1193      169    0
 28    38.5K      1336s       4     104     yes     1323      169    0
 29    48.1K      1336s       1      21     yes     1287        1    0
 30    60.2K      1336s       1      17     yes     1093      169    0
 31    75.2K      1337s       1      13     yes      713      168    0
 32    94.0K      1337s       1      10     yes      278      168    0
 33   117.5K      1336s       1       3      no        0        0    0

</pre><p>
        この出力は、<code class="literal">command</code> に <code class="literal">display</code> を指定した場合と同じです。
      </p><pre class="programlisting">
shell&gt; memcached-tool localhost:11211 display
  #  Item_Size  Max_age   Pages   Count   Full?  Evicted Evict_Time OOM
  1      80B        93s       1      20      no        0        0    0
  2     104B        93s       1      16      no        0        0    0
...
</pre><p>
        この出力には、<code class="literal">slabs</code> 統計の出力を要約したものが表示されます。出力に表示されるカラムを次に示します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">#</code>: スラブ番号
          </p></li><li class="listitem"><p>
            <code class="literal">Item_Size</code>: スラブのサイズ
          </p></li><li class="listitem"><p>
            <code class="literal">Max_age</code>: スラブ内のもっとも古い項目の存続期間
          </p></li><li class="listitem"><p>
            <code class="literal">Pages</code>: スラブに割り当てられたページの数
          </p></li><li class="listitem"><p>
            <code class="literal">Count</code>: このスラブ内の項目の数
          </p></li><li class="listitem"><p>
            <code class="literal">Full?</code>: スラブが完全に移入されているかどうか
          </p></li><li class="listitem"><p>
            <code class="literal">Evicted</code>: このスラブから削除されたオブジェクトの数
          </p></li><li class="listitem"><p>
            <code class="literal">Evict_Time</code>: 最後の削除から経過した時間 (秒単位)
          </p></li><li class="listitem"><p>
            <code class="literal">OOM</code>: メモリー不足エラーが発生した項目の数
          </p></li></ul></div><p>
        <code class="literal">stats</code> コマンドを使用してサーバーの一般統計のダンプを取得することもできます。
      </p><pre class="programlisting">
shell&gt; memcached-tool localhost:11211 stats  
#localhost:11211   Field       Value
         accepting_conns           1
                   bytes         162
              bytes_read         485
           bytes_written        6820
              cas_badval           0
                cas_hits           0
              cas_misses           0
               cmd_flush           0
                 cmd_get           4
                 cmd_set           2
             conn_yields           0
   connection_structures          11
        curr_connections          10
              curr_items           2
               decr_hits           0
             decr_misses           1
             delete_hits           0
           delete_misses           0
               evictions           0
                get_hits           4
              get_misses           0
               incr_hits           0
             incr_misses           2
          limit_maxbytes    67108864
     listen_disabled_num           0
                     pid       12981
            pointer_size          32
           rusage_system    0.013911
             rusage_user    0.011876
                 threads           4
                    time  1255518565
       total_connections          20
             total_items           2
                  uptime         880
                 version       1.4.2
</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="ha-memcached-faq"></a>16.6.5 <span class="command"><strong>memcached</strong></span> の FAQ</h3></div></div></div><div class="qandaset"><a name="idm139979056163616"></a><dl><dt>16.6.5.1. <a href="ha-overview.html#idm139979056163488">
        memcached は Windows 環境で実行できますか。
      </a></dt><dt>16.6.5.2. <a href="ha-overview.html#idm139979056160224">
        memcached に格納できるオブジェクトの最大サイズはどれくらいですか。それは構成可能ですか。
      </a></dt><dt>16.6.5.3. <a href="ha-overview.html#idm139979056149056">
        memcached はデータベースへの書き込みの多いアプリケーションよりデータベースの読み取りの多いアプリケーションでより効果的であるというのは本当ですか。
      </a></dt><dt>16.6.5.4. <a href="ha-overview.html#idm139979056145392">
        永続的な接続を使用しないことのオーバーヘッドはありますか。永続的な接続が常に推奨される場合、そのデメリットは何ですか (たとえば、ロックの問題)。
      </a></dt><dt>16.6.5.5. <a href="ha-overview.html#idm139979056140560">
        memcached クライアントによって操作されている memcached サーバーのいずれかがクラッシュした場合はどうなりますか。
      </a></dt><dt>16.6.5.6. <a href="ha-overview.html#idm139979056132400">
        memcached サーバーの推奨されるハードウェア構成はどのようなものですか。
      </a></dt><dt>16.6.5.7. <a href="ha-overview.html#idm139979056126352">
        memcached は、テキストの読み取り/書き込みよりもビデオおよび音声に効果がありますか。
      </a></dt><dt>16.6.5.8. <a href="ha-overview.html#idm139979056118336">
        memcached は ASPX で動作しますか。
      </a></dt><dt>16.6.5.9. <a href="ha-overview.html#idm139979056114192">
        memcache の接続を確立するにはどのくらいコストがかかりますか。それらの接続はプールするべきですか。
      </a></dt><dt>16.6.5.10. <a href="ha-overview.html#idm139979056110528">
        memcached サーバーが停止した場合、データはどのように処理されますか。
      </a></dt><dt>16.6.5.11. <a href="ha-overview.html#idm139979056104880">
        MySQL データベースの自動インクリメントカラムは、複数の memcached インスタンスでどのように調整されますか。
      </a></dt><dt>16.6.5.12. <a href="ha-overview.html#idm139979056097776">
        圧縮を使用できますか。
      </a></dt><dt>16.6.5.13. <a href="ha-overview.html#idm139979056095760">
        異なるタイプの memcached を同じサーバーで別々のノードとして実装し、同じサーバーで決定性のあるものと決定性のないものを持つことはできますか。
      </a></dt><dt>16.6.5.14. <a href="ha-overview.html#idm139979056092112">
        パフォーマンスが向上することを確認するため、および memcached への構成変更の影響を判断するために、実装をテストするベストプラクティスはどのようなものですか。開始時の構成を単純にすることを推奨しますか。
      </a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%"><col></colgroup><tbody><tr class="question"><td align="left" valign="top"><a name="idm139979056163488"></a><a name="idm139979056163360"></a><p><b>16.6.5.1.</b></p></td><td align="left" valign="top"><p>
        memcached は Windows 環境で実行できますか。
      </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
        いいえ。現在、<span class="command"><strong>memcached</strong></span> は Unix/Linux プラットフォームでのみ使用できます。使用可能な非公式の移植版については、<a class="ulink" href="http://www.codeplex.com/memcachedproviders" target="_top">http://www.codeplex.com/memcachedproviders</a> を参照してください。
      </p></td></tr><tr class="question"><td align="left" valign="top"><a name="idm139979056160224"></a><a name="idm139979056160096"></a><p><b>16.6.5.2.</b></p></td><td align="left" valign="top"><p>
        memcached に格納できるオブジェクトの最大サイズはどれくらいですか。それは構成可能ですか。
      </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
        デフォルトの最大オブジェクトサイズは 1M バイトです。<span class="command"><strong>memcached</strong></span> 1.4.2 以降では、<code class="option">-I</code> コマンド行オプションを使用してオブジェクトの最大サイズを変更できます。
      </p><p>
        これより前のバージョンの場合、このサイズを増やすには <span class="command"><strong>memcached</strong></span> を再コンパイルする必要があります。ソース内の <code class="filename">slabs.c</code> ファイルの <code class="literal">POWER_BLOCK</code> の値を変更できます。
      </p><p>
        <span class="command"><strong>memcached</strong></span> 1.4.2 以降では、<code class="literal">-I</code> コマンド行オプションを使用して、サポートされる最大のオブジェクトサイズを構成できます。たとえば、最大のオブジェクトサイズを 5M バイトに増やすには、次のように実行します。
      </p><pre class="programlisting">
$ memcached -I 5m
</pre><p>
        オブジェクトが最大のオブジェクトサイズより大きい場合は、それを手動で分割する必要があります。<span class="command"><strong>memcached</strong></span> は非常に簡単であり、キーとデータを渡すと、それを RAM にキャッシュすることが試みられます。デフォルトの最大サイズを超えて格納しようとすると、速度を保つために値が切り捨てられます。
      </p></td></tr><tr class="question"><td align="left" valign="top"><a name="idm139979056149056"></a><a name="idm139979056148928"></a><p><b>16.6.5.3.</b></p></td><td align="left" valign="top"><p>
        <code class="literal">memcached</code> はデータベースへの書き込みの多いアプリケーションよりデータベースの読み取りの多いアプリケーションでより効果的であるというのは本当ですか。
      </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
        はい。<span class="command"><strong>memcached</strong></span> は、データベースへの書き込みに関与することはなく、データベースからすでに読み取ったデータを RAM にキャッシュする方法です。
      </p></td></tr><tr class="question"><td align="left" valign="top"><a name="idm139979056145392"></a><a name="idm139979056145264"></a><p><b>16.6.5.4.</b></p></td><td align="left" valign="top"><p>
        永続的な接続を使用しないことのオーバーヘッドはありますか。永続的な接続が常に推奨される場合、そのデメリットは何ですか (たとえば、ロックの問題)。
      </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
        <span class="command"><strong>memcached</strong></span> と通信するときに永続的な接続を使用しない場合、毎回接続を開くときに待機時間が少し長くなります。その影響は、MySQL に永続的ではない接続を使用する場合と同等です。
      </p><p>
        一般に、<span class="command"><strong>memcached</strong></span> 内でロックが使用されることは非常に少ないため、永続的な接続でロックまたはその他の問題が発生する可能性はごくわずかです。問題がある場合は、要求がタイムアウトして結果が返されないため、アプリケーションが MySQL からふたたびロードする必要があります。
      </p></td></tr><tr class="question"><td align="left" valign="top"><a name="idm139979056140560"></a><a name="idm139979056140432"></a><p><b>16.6.5.5.</b></p></td><td align="left" valign="top"><p>
        <span class="command"><strong>memcached</strong></span> クライアントによって操作されている <span class="command"><strong>memcached</strong></span> サーバーのいずれかがクラッシュした場合はどうなりますか。
      </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
        これは自動的に処理されません。クライアントがサーバーから応答を取得できない場合、MySQL データベースからデータをロードするためのフォールバックメカニズムをコーディングしてください。
      </p><p>
        すべてのクライアント API は、<span class="command"><strong>memcached</strong></span> インスタンスを実行中に追加および削除する機能を提供しています。アプリケーションで <span class="command"><strong>memcached</strong></span> サーバーが応答しなくなったことが認識された場合は、そのサーバーをサーバーのリストから削除すると、キーがリスト内の別の <span class="command"><strong>memcached</strong></span> サーバーに自動的に再配分されます。すべてのサーバーでキャッシュの内容を維持することが重要である場合は、一貫性のあるハッシュアルゴリズムをサポートする API を使用してください。詳細は、<a class="xref" href="ha-overview.html#ha-memcached-using-hashtypes" title="16.6.2.4 memcached のハッシュ化/分布タイプ">セクション16.6.2.4「<span class="command"><strong>memcached</strong></span> のハッシュ化/分布タイプ」</a>を参照してください。
      </p></td></tr><tr class="question"><td align="left" valign="top"><a name="idm139979056132400"></a><a name="idm139979056132272"></a><p><b>16.6.5.6.</b></p></td><td align="left" valign="top"><p>
        memcached サーバーの推奨されるハードウェア構成はどのようなものですか。
      </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
        <span class="command"><strong>memcached</strong></span> の処理オーバーヘッドはごくわずかです。必要なのは余剰の物理 RAM 容量のみです。<span class="command"><strong>memcached</strong></span> サーバーには専用のマシンは必要ありません。余剰の RAM 容量がある Web サーバー、アプリケーションサーバー、またはデータベースサーバーがある場合は、それらを <span class="command"><strong>memcached</strong></span> に使用します。
      </p><p>
        専用の <span class="command"><strong>memcached</strong></span> サーバーを構築および配備する場合は、比較的性能の低い CPU、大量の RAM、および 1 つ以上のギガビット Ethernet インタフェースを使用します。
      </p></td></tr><tr class="question"><td align="left" valign="top"><a name="idm139979056126352"></a><a name="idm139979056126224"></a><p><b>16.6.5.7.</b></p></td><td align="left" valign="top"><p>
        memcached は、テキストの読み取り/書き込みよりもビデオおよび音声に効果がありますか。
      </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
        <span class="command"><strong>memcached</strong></span> はすべての種類のデータに対して同様に動作します。<span class="command"><strong>memcached</strong></span> を実行した場合、格納される値はデータのストリームです。ただし、<span class="command"><strong>memcached</strong></span> に格納できるオブジェクトの最大サイズは 1M バイトですが、<span class="command"><strong>memcached</strong></span> 1.4.2 以降では <code class="option">-I</code> オプションを使用することによって、またはバージョン 1.4.2 より前はソースを変更することによって、それより大きく構成できます。音声およびビデオのコンテンツに <span class="command"><strong>memcached</strong></span> を使用することを計画している場合は、最大のオブジェクトサイズを増やすことがほとんどです。また、<span class="command"><strong>memcached</strong></span> は読み取りのために情報をキャッシュするソリューションです。キャッシュの情報を更新するときを除いて、書き込みに使用しないでください。
      </p></td></tr><tr class="question"><td align="left" valign="top"><a name="idm139979056118336"></a><a name="idm139979056118208"></a><p><b>16.6.5.8.</b></p></td><td align="left" valign="top"><p>
        <span class="command"><strong>memcached</strong></span> は ASPX で動作しますか。
      </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
        多数の言語および環境のための移植版およびインタフェースがあります。ASPX はベースとなる言語 (C#、VisualBasic など) に依存しています。ASP.NET を使用している場合は、C# の <span class="command"><strong>memcached</strong></span> ライブラリがあります。詳細は、<a class="ulink" href="https://sourceforge.net/projects/memcacheddotnet/" target="_top">https://sourceforge.net/projects/memcacheddotnet/</a> を参照してください。
      </p></td></tr><tr class="question"><td align="left" valign="top"><a name="idm139979056114192"></a><a name="idm139979056114064"></a><p><b>16.6.5.9.</b></p></td><td align="left" valign="top"><p>
        memcache の接続を確立するにはどのくらいコストがかかりますか。それらの接続はプールするべきですか。
      </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
        リクエストの送信および結果の取得を開始する前に、セキュリティー、認証、またはその他のハンドシェイクは行われないため、接続のオープンには比較的コストはかかりません。ほとんどの API は、待機時間を減らすために、<span class="command"><strong>memcached</strong></span> インスタンスへの永続的な接続をサポートしています。接続プールは、使用している API によって異なりますが、TCP/IP を介して直接通信している場合は、接続プールのパフォーマンスが若干よくなります。
      </p></td></tr><tr class="question"><td align="left" valign="top"><a name="idm139979056110528"></a><a name="idm139979056110400"></a><p><b>16.6.5.10.</b></p></td><td align="left" valign="top"><p>
        <span class="command"><strong>memcached</strong></span> サーバーが停止した場合、データはどのように処理されますか。
      </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
        その動作はアプリケーションによってまったく異なります。ほとんどのアプリケーションは、データベースからデータをロードすることにフォールバックします (<span class="command"><strong>memcached</strong></span> の情報を更新するときのように)。複数の <span class="command"><strong>memcached</strong></span> サーバーを使用している場合は、停止したサーバーをリストから削除して、パフォーマンスに影響しないようにできます。そうしないと、クライアントはロードしようとしているキーと対応している <span class="command"><strong>memcached</strong></span> サーバーと通信することを試みます。
      </p></td></tr><tr class="question"><td align="left" valign="top"><a name="idm139979056104880"></a><a name="idm139979056104752"></a><p><b>16.6.5.11.</b></p></td><td align="left" valign="top"><p>
        MySQL データベースの自動インクリメントカラムは、複数の memcached インスタンスでどのように調整されますか。
      </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
        調整されません。MySQL と <span class="command"><strong>memcached</strong></span> に関連はありません (アプリケーションにそのような関連を作成した場合 (または、<span class="command"><strong>memcached</strong></span> およびデータベース定義に MySQL UDF を使用している場合) を除きます)。
      </p><p>
        <span class="command"><strong>memcached</strong></span> の複数インスタンスに自動インクリメントキーに基づいて情報を格納している場合、情報はいずれかの <span class="command"><strong>memcached</strong></span> インスタンスに格納されるのみです。クライアントは、キー値を使用して、情報が格納されている <span class="command"><strong>memcached</strong></span> インスタンスを判別します。同じ情報は、キャッシュメモリーが無駄になるため、すべてのインスタンスに格納されません。
      </p></td></tr><tr class="question"><td align="left" valign="top"><a name="idm139979056097776"></a><a name="idm139979056097648"></a><p><b>16.6.5.12.</b></p></td><td align="left" valign="top"><p>
        圧縮を使用できますか。
      </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
        はい。ほとんどのクライアント API は何らかの圧縮をサポートしており、格納中に値が圧縮に適しているかどうかを判断するしきい値を指定できるものもあります。
      </p></td></tr><tr class="question"><td align="left" valign="top"><a name="idm139979056095760"></a><a name="idm139979056095632"></a><p><b>16.6.5.13.</b></p></td><td align="left" valign="top"><p>
        異なるタイプの <span class="command"><strong>memcached</strong></span> を同じサーバーで別々のノードとして実装し、同じサーバーで決定性のあるものと決定性のないものを持つことはできますか。
      </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
        はい。単一のサーバー上で <span class="command"><strong>memcached</strong></span> の複数のインスタンスを実行し、使用するサーバーのリストをクライアントの構成で選択できます。
      </p></td></tr><tr class="question"><td align="left" valign="top"><a name="idm139979056092112"></a><a name="idm139979056091984"></a><p><b>16.6.5.14.</b></p></td><td align="left" valign="top"><p>
        パフォーマンスが向上することを確認するため、および <span class="command"><strong>memcached</strong></span> への構成変更の影響を判断するために、実装をテストするベストプラクティスはどのようなものですか。開始時の構成を単純にすることを推奨しますか。
      </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
        パフォーマンスをテストする最適な方法は、<span class="command"><strong>memcached</strong></span> インスタンスを起動する方法です。最初に、データが使用または表示される直前にデータを <span class="command"><strong>memcached</strong></span> に格納するようにアプリケーションを変更します。API によってデータが直列化されるため、コードを 1 行変更すればよいだけです。そして、通常は MySQL から情報をロードするプロセスの開始を、<span class="command"><strong>memcached</strong></span> にデータをリクエストするコードに変更します。<span class="command"><strong>memcached</strong></span> からデータをロードできない場合は、デフォルトで MySQL プロセスからロードされます。
      </p><p>
        変更する必要があるのはおそらく数行のコードのみです。利点を最大に活用するには、<span class="command"><strong>memcached</strong></span> を MySQL テーブルの個別の行の単純なキャッシュとして使用するのではなく、オブジェクト全体 (たとえば、Web ページ、ブログの投稿、ディスカッションスレッドなどのすべてのコンポーネント) をキャッシュしてください。
      </p><p>
        <span class="command"><strong>memcached</strong></span> では、開始時の構成を単純にすること、または長期間にわたってそれを維持することは簡単です。基本的な構造を作成して実行したら、多くの場合、使用中に変更することは、アプリケーションによって使用されるサーバーのリストにサーバーを追加することのみです。<span class="command"><strong>memcached</strong></span> サーバーを管理する必要はなく、複雑な構成はありません。リストにサーバーを追加したら、クライアント API および <span class="command"><strong>memcached</strong></span> サーバーに判断を任せます。
      </p></td></tr></tbody></table></div></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="storage-engines.html">前</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="replication.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第 15 章 代替ストレージエンジン </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 第 17 章 レプリケーション</td></tr></table></div><div class="copyright-footer"></div></body></html>
