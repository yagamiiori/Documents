<html lang="ja"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>付録 D 制約と制限</title><link rel="stylesheet" type="text/css" href="mvl.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="MySQL 5.6 リファレンスマニュアル"><link rel="up" href="index.html" title="MySQL 5.6 リファレンスマニュアル"><link rel="prev" href="news.html" title="付録 C MySQL リリースノート"><link rel="next" href="glossary.html" title="MySQL 用語集">
<script language="javascript" type="text/javascript">
  function addOnload(theFunc)
  {
    var previous = window.onload;
    if (typeof window.onload != 'function')
    {
      window.onload = theFunc;
    }
    else
    {
      window.onload = function()
      {
        previous();
        theFunc();
      }
    }
  }

  addOnload(function()
  {
    var base = new Date(1442918127*1000);
    var now = new Date();
    var diff = ((now-base)/1000)/(24*3600);

    if (diff > 90) {
      var nodes = document.getElementsByClassName('titlepage');
      nodes[0].innerHTML = '<p style="border: 5px #ff0000 solid; padding: 5px; margin 5px">' +
        'This copy of the manual is more than 90 days old. We encourage you to download a ' +
        'new version from <a href="http://dev.mysql.com">dev.mysql.com/doc</a>.</p>' + nodes[0].innerHTML;
    }
  });
</script>
<noscript></noscript>
</head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">付録 D 制約と制限</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="news.html">前</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="glossary.html">次へ</a></td></tr></table><hr></div><div class="appendix"><div class="titlepage"><div><div><h1 class="title"><a name="restrictions"></a>付録 D 制約と制限</h1></div></div></div><div class="toc"><p><b>目次</b></p><dl class="toc"><dt><span class="section"><a href="restrictions.html#stored-program-restrictions">D.1 ストアドプログラムの制約</a></span></dt><dt><span class="section"><a href="restrictions.html#condition-handling-restrictions">D.2 条件処理の制約</a></span></dt><dt><span class="section"><a href="restrictions.html#cursor-restrictions">D.3 サーバー側のカーソルの制約</a></span></dt><dt><span class="section"><a href="restrictions.html#subquery-restrictions">D.4 サブクエリーの制約</a></span></dt><dt><span class="section"><a href="restrictions.html#view-restrictions">D.5 ビューの制約</a></span></dt><dt><span class="section"><a href="restrictions.html#xa-restrictions">D.6 XA トランザクションの制約</a></span></dt><dt><span class="section"><a href="restrictions.html#charset-restrictions">D.7 文字セットの制約</a></span></dt><dt><span class="section"><a href="restrictions.html#performance-schema-restrictions">D.8 パフォーマンススキーマの制約</a></span></dt><dt><span class="section"><a href="restrictions.html#pluggable-authentication-restrictions">D.9 プラガブルな認証の制約</a></span></dt><dt><span class="section"><a href="restrictions.html#limits">D.10 MySQL での制限</a></span></dt><dd><dl><dt><span class="section"><a href="restrictions.html#joins-limits">D.10.1 結合の制限</a></span></dt><dt><span class="section"><a href="restrictions.html#database-count-limit">D.10.2 データベースおよびテーブルの数に対する制限</a></span></dt><dt><span class="section"><a href="restrictions.html#table-size-limit">D.10.3 テーブルサイズの制限</a></span></dt><dt><span class="section"><a href="restrictions.html#column-count-limit">D.10.4 テーブルカラム数と行サイズの制限</a></span></dt><dt><span class="section"><a href="restrictions.html#limits-frm-file">D.10.5 .frm ファイル構造により課せられる制限</a></span></dt><dt><span class="section"><a href="restrictions.html#limits-windows">D.10.6 Windows プラットフォームの制限</a></span></dt></dl></dd></dl></div><p>
    ここでは、サブクエリーやビューなどの MySQL 機能の使用に適用される制約について説明します。
  </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="stored-program-restrictions"></a>D.1 ストアドプログラムの制約</h2></div></div></div><a class="indexterm" name="idm139978988598496"></a><a class="indexterm" name="idm139978988596320"></a><a class="indexterm" name="idm139978988594256"></a><a class="indexterm" name="idm139978988592224"></a><a class="indexterm" name="idm139978988590192"></a><a class="indexterm" name="idm139978988588160"></a><p>
      これらの制約は、<a class="xref" href="stored-programs-views.html" title="第 20 章 ストアドプログラムおよびビュー">第20章「<i>ストアドプログラムおよびビュー</i>」</a>で説明している機能に適用されます。
    </p><p>
      ここに記載されている制約の中には、すべてのストアドルーチン、つまりストアドプロシージャーとストアドファンクションの両方に適用されるものがあります。また、ストアドプロシージャーには適用されず、<a class="link" href="restrictions.html#stored-routines-function-restrictions" title="ストアドファンクションの制約">ストアドファンクションに固有の制約</a>もいくつか存在します。
    </p><p>
      ストアドファンクションの制約は、トリガーにも適用されます。<a class="link" href="restrictions.html#stored-routines-trigger-restrictions" title="トリガーの制約">トリガーに固有の制約</a>もいくつかあります。
    </p><p>
      ストアドプロシージャーの制約は、イベントスケジューラのイベント定義の <code class="literal">DO</code> 句にも適用されます。<a class="link" href="restrictions.html#stored-routines-event-restrictions" title="イベントスケジューラの制約">イベントに固有の制約</a>もいくつかあります。
    </p><h3><a name="stored-routine-sql-restrictions"></a>ストアドルーチンでは許可されていない SQL ステートメント</h3><p>
      ストアドルーチンには自由に SQL ステートメントを含めることはできません。次のステートメントは許可されていません。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">LOCK TABLES</code> および <code class="literal">UNLOCK TABLES</code> のロックステートメント。
        </p></li><li class="listitem"><p>
          <code class="literal">ALTER VIEW</code>。
        </p></li><li class="listitem"><p>
          <code class="literal">LOAD DATA</code> および <code class="literal">LOAD TABLE</code>。
        </p></li><li class="listitem"><p>
          SQL 準備済みステートメント (<code class="literal">PREPARE</code>、<code class="literal">EXECUTE</code>、<code class="literal">DEALLOCATE PREPARE</code>) は、ストアドプロシージャーで使用できますが、ストアドファンクションやトリガーでは使用できません。そのため、ストアドファンクションとトリガーは動的 SQL (この場合はステートメントを文字列として構築してから実行します) を使用できません。
        </p></li><li class="listitem"><p>
          通常、SQL 準備済みステートメントで許可されていないステートメントは、ストアドプログラムでも許可されません。準備済みステートメントとしてサポートされているステートメントのリストについては、<a class="xref" href="sql-syntax.html#sql-syntax-prepared-statements" title="13.5 準備済みステートメントのための SQL 構文">セクション13.5「準備済みステートメントのための SQL 構文」</a>を参照してください。例外は <code class="literal">SIGNAL</code>、<code class="literal">RESIGNAL</code>、および <code class="literal">GET DIAGNOSTICS</code> であり、これらは準備済みステートメントとして許可されていませんが、ストアドプログラムで許可されます。
        </p></li><li class="listitem"><p>
          ローカル変数はストアドプログラムの実行中にのみスコープ内にあるので、これらの参照は、ストアドプログラム内で作成された準備済みステートメントでは許可されていません。準備済みステートメントのスコープは現在のセッションであり、ストアドプログラムではないので、ステートメントはプログラムの終了後に実行でき、この時点で変数はスコープ内に存在しなくなります。たとえば、<code class="literal">SELECT ... INTO <em class="replaceable"><code>local_var</code></em></code> は準備済みステートメントとして使用できません。この制約は、ストアドプロシージャーおよびストアドファンクションのパラメータにも適用されます。<a class="xref" href="sql-syntax.html#prepare" title="13.5.1 PREPARE 構文">セクション13.5.1「PREPARE 構文」</a>を参照してください。
        </p></li><li class="listitem"><p>
          挿入は遅延されません。<code class="literal">INSERT DELAYED</code> 構文は受け入れられますが、ステートメントは通常の <code class="literal">INSERT</code> として扱われます。
        </p></li><li class="listitem"><p>
          すべてのストアドプログラム (ストアドプロシージャーとストアドファンクション、トリガー、およびイベント) 内で、パーサーは、<code class="literal">BEGIN [WORK]</code> を <code class="literal">BEGIN ... END</code> ブロックの開始として扱います。このコンテキストでトランザクションを開始するには、代わりに <code class="literal">START TRANSACTION</code> を使用します。
        </p></li></ul></div><h3><a name="stored-routines-function-restrictions"></a>ストアドファンクションの制約</h3><p>
      次の追加ステートメントまたは操作は、ストアドファンクション内で許可されていません。これらはストアドプロシージャーで許可されていますが、ストアドファンクションまたはトリガー内から呼び出されるストアドプロシージャーを除きます。たとえば、ストアドプロシージャーで <code class="literal">FLUSH</code> を使用する場合、ストアドファンクションまたはトリガーからそのストアドプロシージャーを呼び出すことはできません。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          明示的または暗黙的なコミットまたはロールバックを実行するステートメント。これらのステートメントのサポートは、SQL 標準では必要ありません。SQL 標準では、各 DBMS ベンダーがこれらのステートメントを許可するかどうかを決められると定めています。
        </p></li><li class="listitem"><p>
          結果セットを返すステートメント。これには、<code class="literal">INTO <em class="replaceable"><code>var_list</code></em></code> 句を含まない <code class="literal">SELECT</code> ステートメントや、<code class="literal">SHOW</code>、<code class="literal">EXPLAIN</code>、および <code class="literal">CHECK TABLE</code> などのほかのステートメントも含まれます。関数は、<code class="literal">SELECT ... INTO <em class="replaceable"><code>var_list</code></em></code> を使用するか、カーソルと <code class="literal">FETCH</code> ステートメントを使用すると、結果セットを処理できます。<a class="xref" href="sql-syntax.html#select-into" title="13.2.9.1 SELECT ... INTO 構文">セクション13.2.9.1「SELECT ... INTO 構文」</a>および<a class="xref" href="sql-syntax.html#cursors" title="13.6.6 カーソル">セクション13.6.6「カーソル」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">FLUSH</code> ステートメント。
        </p></li><li class="listitem"><p>
          ストアドファンクションは再帰的に使用できません。
        </p></li><li class="listitem"><p>
          ストアドファンクションまたはトリガーは、そのストアドファンクションまたはトリガーを呼び出したステートメントによって (読み取りまたは書き込みに) すでに使用されているテーブルを変更できません。
        </p></li><li class="listitem"><p>
          ストアドファンクションで、一時テーブルを異なるエイリアスで複数回参照する場合、ストアドファンクション内の別々のステートメントで参照を行う場合でも、<code class="literal">「表を再オープンできません: '<em class="replaceable"><code>tbl_name</code></em><code class="literal"></code>'」</code> というエラーが発生します。
        </p></li><li class="listitem"><p>
          ストアドファンクションを呼び出す <code class="literal">HANDLER ... READ</code> ステートメントは、レプリケーションエラーを引き起こす可能性があり、許可されません。
        </p></li></ul></div><h3><a name="stored-routines-trigger-restrictions"></a>トリガーの制約</h3><p>
      トリガーの場合、さらに次の制約が適用されます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          トリガーは外部キーアクションでアクティブ化されません。
        </p></li><li class="listitem"><p>
          行ベースのレプリケーションを使用する場合、スレーブのトリガーは、マスターから発行されたステートメントでアクティブ化されません。スレーブのトリガーは、ステートメントベースのレプリケーションを使用するときにアクティブ化されます。詳細は、<a class="xref" href="replication.html#replication-features-triggers" title="17.4.1.32 レプリケーションとトリガー">セクション17.4.1.32「レプリケーションとトリガー」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">RETURN</code> ステートメントはトリガーでは許可されていません。トリガーは値を返すことができません。すぐにトリガーを終了するには、<code class="literal">LEAVE</code> ステートメントを使用します。
        </p></li><li class="listitem"><p>
          トリガーは、<code class="literal">mysql</code> データベース内のテーブルでは許可されていません。
        </p></li><li class="listitem"><p>
          トリガーキャッシュは、ベースとなるオブジェクトのメタデータが変更された場合は検出しません。トリガーがテーブルを使用し、トリガーがキャッシュにロードされたあとにそのテーブルに変更があった場合、トリガーは古いメタデータを使用して動作します。
        </p></li></ul></div><h3><a name="stored-routine-name-conflicts"></a>ストアドルーチン内の名前競合</h3><p>
      ルーチンパラメータ、ローカル変数、およびテーブルカラムに同じ識別子が使用される場合があります。また、同じローカル変数名を、ネスト化されたブロックで使用することもできます。例:
    </p><pre class="programlisting">
CREATE PROCEDURE p (i INT)
BEGIN
  DECLARE i INT DEFAULT 0;
  SELECT i FROM t;
  BEGIN
    DECLARE i INT DEFAULT 1;
    SELECT i FROM t;
  END;
END;
</pre><p>
      このような場合、識別子はあいまいになり、次の優先順位ルールが適用されます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ローカル変数では、ルーチンパラメータやテーブルカラムが優先されます。
        </p></li><li class="listitem"><p>
          ルーチンパラメータでは、テーブルカラムが優先されます。
        </p></li><li class="listitem"><p>
          内部ブロック内のローカル変数では、外部ブロック内のローカル変数が優先されます。
        </p></li></ul></div><p>
      変数でテーブルカラムが優先される動作は、非標準です。
    </p><h3><a name="stored-routines-replication-restrictions"></a>レプリケーションに関する考慮事項</h3><p>
      ストアドルーチンを使用すると、レプリケーションの問題が生じることがあります。この問題については、<a class="xref" href="stored-programs-views.html#stored-programs-logging" title="20.7 ストアドプログラムのバイナリロギング">セクション20.7「ストアドプログラムのバイナリロギング」</a>で詳しく述べられています。
    </p><p>
      <code class="option">--replicate-wild-do-table=<em class="replaceable"><code>db_name.tbl_name</code></em></code> オプションはテーブル、ビュー、およびトリガーに適用されます。ストアドプロシージャーと関数、またはイベントには適用されません。後者のオブジェクトで作用するステートメントをフィルタするには、1 つまたは複数の <code class="option">--replicate-*-db</code> オプションを使用します。
    </p><h3><a name="stored-routines-debugging-restrictions"></a>デバッグに関する考慮事項</h3><p>
      ストアドルーチンのデバッグ機能は存在しません。
    </p><h3><a name="stored-routines-standard-restrictions"></a>SQL:2003 標準のサポート外の構文</h3><p>
      MySQL ストアドルーチン構文は SQL:2003 標準に基づきます。この標準の次の項目は現在サポートされていません。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">UNDO</code> ハンドラ
        </p></li><li class="listitem"><p>
          <code class="literal">FOR</code> ループ
        </p></li></ul></div><h3><a name="idm139978988490864"></a>並列性に関する考慮事項</h3><p>
      セッション間のやり取りの問題を防止するために、クライアントのステートメント発行時、サーバーではステートメントの実行に利用できるルーチンとトリガーのスナップショットが使用されます。つまり、サーバーは、ステートメントの実行中に使用される可能性のあるプロシージャー、関数、およびトリガーのリストを算出してロードし、ステートメントの実行に進みます。ステートメントの実行時は、ほかのセッションが実行するルーチンへの変更は認識されません。
    </p><p>
      並列性を最大にするために、ストアドファンクションでは、その副作用を最小限に抑える必要があります。特に、ストアドファンクション内のテーブルを更新することにより、そのテーブルでの並列操作が減少することがあります。ストアドファンクションは、実行前にテーブルロックを取得して、ステートメントが実行する順序とログに表示されるときの順序の不一致によるバイナリログの不整合を回避します。ステートメントベースのバイナリロギングが使用される場合、関数内で実行されるステートメントではなく、関数を呼び出すステートメントが記録されます。その結果、ベースとなる同じテーブルを更新するストアドファンクションは、並列で実行しません。対照的に、ストアドプロシージャーはテーブルレベルのロックを取得しません。ストアドプロシージャー内で実行されたすべてのステートメントは、ステートメントベースのバイナリロギングの場合でも、バイナリログに書き込まれます。<a class="xref" href="stored-programs-views.html#stored-programs-logging" title="20.7 ストアドプログラムのバイナリロギング">セクション20.7「ストアドプログラムのバイナリロギング」</a>を参照してください。
    </p><h3><a name="stored-routines-event-restrictions"></a>イベントスケジューラの制約</h3><p>
      次の制限は、イベントスケジューラに固有のものです。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          イベント名は大文字と小文字を区別せずに処理されます。たとえば、<code class="literal">anEvent</code> と <code class="literal">AnEvent</code> という名前の 2 つのイベントを同じデータベース内に含めることはできません。
        </p></li><li class="listitem"><p>
          イベントは、ストアドルーチン、トリガー、または別のイベントによって、作成、変更、削除できません。イベントは、ストアドルーチンやトリガーを作成、変更、削除することもできません。(Bug #16409、Bug #18896)
        </p></li><li class="listitem"><p>
          <code class="literal">LOCK TABLES</code> ステートメントの有効時は、イベントでの DDL ステートメントは禁止されています。
        </p></li><li class="listitem"><p>
          <code class="literal">YEAR</code>、<code class="literal">QUARTER</code>、<code class="literal">MONTH</code>、および <code class="literal">YEAR_MONTH</code> の間隔を使用したイベントのタイミングは、月で解決されます。ほかの間隔を使用したタイミングは秒で解決されます。同時に行われるようにスケジュール設定されたイベントは、指定の順序で実行できません。さらに、丸め、スレッドアプリケーションの特性、およびイベントを作成しその実行を信号で伝えるためにゼロ以外の時間長が必要になるため、イベントが 1、2 秒ほど遅れる場合があります。ただし、<code class="literal">INFORMATION_SCHEMA.EVENTS</code> テーブルの <code class="literal">LAST_EXECUTED</code> カラム、または <code class="literal">mysql.event</code> テーブルの <code class="literal">last_executed</code> カラムに示された時間は、常に実際のイベント実行時間の 1 秒以内の精度になります。(Bug #16522 も参照してください。)
        </p></li><li class="listitem"><p>
          イベントの本体に含まれるステートメントはそれぞれ新しい接続で実行されるため、これらのステートメントは特定のユーザーセッションで、<code class="literal">SHOW STATUS</code> によって表示される <code class="literal">Com_select</code> や <code class="literal">Com_insert</code> などのサーバーのステートメント数に影響しません。ただし、このような数はグローバルスコープで更新<span class="emphasis"><em>されます</em></span>。(Bug #16422)
        </p></li><li class="listitem"><p>
          イベントは、Unix エポックの最後の時間以降をサポートしません。この時間は 2038 年の年頭あたりになります。このような日付はイベントスケジューラで特に許可されません。(Bug #16396)
        </p></li><li class="listitem"><p>
          <code class="literal">CREATE EVENT</code> および <code class="literal">ALTER EVENT</code> ステートメントの <code class="literal">ON SCHEDULE</code> 句でのストアドファンクション、ユーザー定義関数、およびテーブルの参照はサポートされていません。このような種類の参照は許可されていません。(詳細は Bug #22830 を参照してください。)
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="condition-handling-restrictions"></a>D.2 条件処理の制約</h2></div></div></div><a class="indexterm" name="idm139978988458704"></a><a class="indexterm" name="idm139978988456560"></a><p>
      <code class="literal">SIGNAL</code>、<code class="literal">RESIGNAL</code>、および <code class="literal">GET DIAGNOSTICS</code> は準備済みのステートメントとして許可されていません。たとえば、次のステートメントは無効です。
    </p><pre class="programlisting">
PREPARE stmt1 FROM 'SIGNAL SQLSTATE "02000"';
</pre><p>
      クラス <code class="literal">'04'</code> の <code class="literal">SQLSTATE</code> 値は特別扱いされません。ほかの例外と同じように扱われます。
    </p><p>
      標準 SQL には、ネスト化された実行のコンテキストごとの診断領域を含んだ、診断領域スタックがあります。標準 SQL 構文には、スタック領域を参照するための <code class="literal">GET STACKED DIAGNOSTICS</code> が含まれます。MySQL では、もっとも新しく書き込んだステートメントの情報を含む単一の診断領域があるため、<code class="literal">STACKED</code> キーワードをサポートしません。<a class="xref" href="sql-syntax.html#diagnostics-area" title="13.6.7.7 MySQL の診断領域">セクション13.6.7.7「MySQL の診断領域」</a>も参照してください。
    </p><p>
      標準 SQL では、最初の条件は、以前の SQL ステートメントに対して返される <code class="literal">SQLSTATE</code> 値に関連します。MySQL ではこれは保証されていないので、メインエラーを取得するために、次のようにはできません。
    </p><pre class="programlisting">
GET DIAGNOSTICS CONDITION 1 @errno = MYSQL_ERRNO;
</pre><p>
      代わりに次のようにします。
    </p><pre class="programlisting">
GET DIAGNOSTICS @cno = NUMBER;
GET DIAGNOSTICS CONDITION @cno @errno = MYSQL_ERRNO;
</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cursor-restrictions"></a>D.3 サーバー側のカーソルの制約</h2></div></div></div><a class="indexterm" name="idm139978988439984"></a><a class="indexterm" name="idm139978988437840"></a><p>
      サーバー側のカーソルは、<code class="literal">mysql_stmt_attr_set()</code> 関数を使用して C API に実装されます。ストアドルーチンのカーソルにも同じ実装が使用されます。サーバー側のカーソルによって、サーバー側で結果セットを生成できるようになりますが、クライアントが要求する行を除いてクライアントに転送することはできません。たとえば、クライアントがクエリーを実行するが、最初の行のみが必要な場合、残りの行は転送されません。
    </p><p>
      MySQL では、サーバー側のカーソルは内部一時テーブルに実体化されます。最初これは <code class="literal">MEMORY</code> テーブルですが、そのサイズが <code class="literal">max_heap_table_size</code> および <code class="literal">tmp_table_size</code> システム変数の最小値を超えると、<code class="literal">MyISAM</code> テーブルに変換されます。カーソルの結果セットを保持するために作成された内部一時テーブルには、内部一時テーブルをほかに使用する場合と同じ制約が適用されます。<a class="xref" href="optimization.html#internal-temporary-tables" title="8.4.4 MySQL が内部一時テーブルを使用する仕組み">セクション8.4.4「MySQL が内部一時テーブルを使用する仕組み」</a>を参照してください。この実装の制限の 1 つには、大きな結果セットの場合に、カーソルによる行の取得に時間がかかることがあるというものがあります。
    </p><p>
      カーソルは読み取り専用です。カーソルを使用して行を更新できません。
    </p><p>
      <code class="literal">UPDATE WHERE CURRENT OF</code> および <code class="literal">DELETE WHERE CURRENT OF</code> は、更新可能なカーソルがサポートされていないため実装されません。
    </p><p>
      カーソルは保持不可能です (コミット後、開いたままにはできません)。
    </p><p>
      カーソルは非センシティブです。
    </p><p>
      カーソルはスクロール不可です。
    </p><p>
      カーソルには名前が付けられません。ステートメントハンドラがカーソル ID として機能します。
    </p><p>
      準備済みステートメントごとに、カーソルを 1 つだけ開いておくことができます。複数のカーソルが必要な場合は、複数のステートメントを準備する必要があります。
    </p><p>
      結果セットを生成するステートメントで、準備モードでサポートされていないものにはカーソルを使用できません。このようなステートメントには、<code class="literal">CHECK TABLE</code>、<code class="literal">HANDLER READ</code>、<code class="literal">SHOW BINLOG EVENTS</code> などがあります。
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="subquery-restrictions"></a>D.4 サブクエリーの制約</h2></div></div></div><a class="indexterm" name="idm139978988417616"></a><a class="indexterm" name="idm139978988415504"></a><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">IN</code> に対するサブクエリーの最適化は、<code class="literal">=</code> 演算子または <code class="literal">IN(<em class="replaceable"><code>value_list</code></em>)</code> 演算子の場合のようには効果的ではありません。
        </p><p>
          <code class="literal">IN</code> サブクエリーのパフォーマンスが不十分である一般的な例では、サブクエリーが少数の行を返すのに対し、外部クエリーがサブクエリーの結果と比較して多数の行を返す場合があります。
        </p><p>
          この問題は、<code class="literal">IN</code> サブクエリーを使用するステートメントでは、オプティマイザが相関サブクエリーに書き換えることにあります。非相関サブクエリーを使用する次のステートメントについて説明します。
        </p><pre class="programlisting">
SELECT ... FROM t1 WHERE t1.a IN (SELECT b FROM t2);
</pre><p>
          オプティマイザがステートメントを相関サブクエリーに書き換えます。
        </p><pre class="programlisting">
SELECT ... FROM t1 WHERE EXISTS (SELECT 1 FROM t2 WHERE t2.b = t1.a);
</pre><p>
          内部クエリーと外部クエリーがそれぞれ <em class="replaceable"><code>M</code></em> 行と <em class="replaceable"><code>N</code></em> 行を返す場合、実行時間は、非相関サブクエリーの場合の O(<em class="replaceable"><code>M</code></em>+<em class="replaceable"><code>N</code></em>) ではなく、O(<em class="replaceable"><code>M</code></em>×<em class="replaceable"><code>N</code></em>) になります。
        </p><p>
          つまり、<code class="literal">IN</code> サブクエリーは、このサブクエリーが返す値と同じ値をリストする <code class="literal">IN(<em class="replaceable"><code>value_list</code></em>)</code> 演算子を使用して作成されたクエリーよりもかなり遅くなる場合があります。
        </p></li><li class="listitem"><p>
          一般に、テーブルを変更することも、サブクエリーの同じテーブルから選択することもできません。たとえば、この制限は次の形式のステートメントに適用されます。
        </p><pre class="programlisting">
DELETE FROM t WHERE ... (SELECT ... FROM t ...);
UPDATE t ... WHERE col = (SELECT ... FROM t ...);
{INSERT|REPLACE} INTO t (SELECT ... FROM t ...);
</pre><p>
          例外: <code class="literal">FROM</code> 句内の変更されたテーブルでサブクエリーを使用している場合、前述の禁止事項は適用されません。例:
        </p><pre class="programlisting">
UPDATE t ... WHERE col = (SELECT * FROM (SELECT ... FROM t...) AS _t ...);
</pre><p>
          ここでは、<code class="literal">FROM</code> 句内のサブクエリーの結果が一時テーブルとして格納されるので、<code class="literal">t</code> 内の対応する行は、<code class="literal">t</code> に対する更新が行われる前にすでに選択されています。
        </p></li><li class="listitem"><p>
          行比較演算は一部のみサポートされています。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal"><em class="replaceable"><code>expr</code></em> [NOT] IN <em class="replaceable"><code>subquery</code></em></code> の場合、<em class="replaceable"><code>expr</code></em> は <em class="replaceable"><code>n</code></em> タプル (行コンストラクタ構文を使用して指定します) にでき、サブクエリーは <em class="replaceable"><code>n</code></em> タプルの行を返すことができます。したがって、許可されている構文は、具体的には <code class="literal"><em class="replaceable"><code>row_constructor</code></em> [NOT] IN <em class="replaceable"><code>table_subquery</code></em></code> と表されます
            </p></li><li class="listitem"><p>
              <code class="literal"><em class="replaceable"><code>expr</code></em> <em class="replaceable"><code>op</code></em> {ALL|ANY|SOME} <em class="replaceable"><code>subquery</code></em></code> の場合、<em class="replaceable"><code>expr</code></em> はスカラー値にする必要があり、サブクエリーはカラムサブクエリーにする必要があります。複合カラム行を返すことはできません。
            </p></li></ul></div><p>
          つまり、<em class="replaceable"><code>n</code></em> タプルの行を返すサブクエリーの場合、次のものはサポートされています。
        </p><pre class="programlisting">
(<em class="replaceable"><code>expr_1</code></em>, ..., <em class="replaceable"><code>expr_n</code></em>) [NOT] IN <em class="replaceable"><code>table_subquery</code></em>
</pre><p>
          ただし、次のものはサポートされていません。
        </p><pre class="programlisting">
(<em class="replaceable"><code>expr_1</code></em>, ..., <em class="replaceable"><code>expr_n</code></em>) <em class="replaceable"><code>op</code></em> {ALL|ANY|SOME} <em class="replaceable"><code>subquery</code></em>
</pre><p>
          <code class="literal">IN</code> の行比較がサポートされているのに、他はサポートされていない理由は、<code class="literal">IN</code> が、<code class="literal">=</code> 比較および <code class="literal">AND</code> 演算のシーケンスに、これを書き換えることによって実装されているためです。この方法は、<code class="literal">ALL</code> 、<code class="literal">ANY</code>、<code class="literal">SOME</code> には使用できません。
        </p></li><li class="listitem"><p>
          <code class="literal">FROM</code> 句のサブクエリーは相関サブクエリーにはできません。これらは、クエリー実行中にすべて実体化 (結果セットを生成するように評価) されるので、外部クエリーの行ごとに評価できません。MySQL 5.6.3 より前では、実体化は外部クエリーの評価の前に行われます。5.6.3 以降では、オプティマイザは、結果が必要になるまで実体化を遅らせ、これにより実体化を回避できます。<a class="xref" href="optimization.html#from-clause-subquery-optimization" title="8.2.1.18.3 FROM 句内のサブクエリー (派生テーブル) の最適化">セクション8.2.1.18.3「FROM 句内のサブクエリー (派生テーブル) の最適化」</a>を参照してください。
        </p></li><li class="listitem"><p>
          MySQL は特定のサブクエリー演算子にサブクエリーの <code class="literal">LIMIT</code> をサポートしていません。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT * FROM t1</code></strong>
    -&gt;   <strong class="userinput"><code>WHERE s1 IN (SELECT s2 FROM t2 ORDER BY s1 LIMIT 1);</code></strong>
ERROR 1235 (42000): This version of MySQL doesn't yet support
 'LIMIT &amp; IN/ALL/ANY/SOME subquery'
</pre></li><li class="listitem"><p>
          オプティマイザは、サブクエリーに対してよりも結合に対するほうが完成度が高いので、多くの場合、サブクエリーを使用するステートメントは、結合として書き換えた場合のほうが効率的に実行できます。
        </p><p>
          <code class="literal">IN</code> サブクエリーを <code class="literal">SELECT DISTINCT</code> 結合として書き換えることができる場合には、例外が生じます。例:
        </p><pre class="programlisting">
SELECT col FROM t1 WHERE id_col IN (SELECT id_col2 FROM t2 WHERE <em class="replaceable"><code>condition</code></em>);
</pre><p>
          このステートメントは次のように書き換えることができます。
        </p><pre class="programlisting">
SELECT DISTINCT col FROM t1, t2 WHERE t1.id_col = t2.id_col AND <em class="replaceable"><code>condition</code></em>;
</pre></li><li class="listitem"><p>
          MySQL では、サブクエリーで行をテーブルに挿入するなどのデータ変更の副作用があるストアドファンクションを参照できます。たとえば、<code class="literal">f()</code> が行を挿入する場合、次のクエリーはデータを変更できます。
        </p><pre class="programlisting">
SELECT ... WHERE x IN (SELECT f() ...);
</pre><p>
          この動作は、SQL 標準に対する拡張です。MySQL では、オプティマイザでの処理方法の選択に応じて、特定のクエリーの実行ごとに <code class="literal">f()</code> が異なる回数実行される場合があるため、これにより不確定な結果が生成される可能性があります。
        </p><p>
          ステートメントベースまたは混合形式のレプリケーションの場合、この不確定性には、このようなクエリーが、マスターとそのスレーブで異なる結果を生成することがあります。
        </p></li><li class="listitem"><p>
          MySQL 5.6.3 より前では、<code class="literal">FROM</code> 句のサブクエリーは、結果を一時テーブルに実体化することにより評価され、このテーブルではインデックスが使用されません。5.6.3 以降では、クエリー実行がさらに高速になる場合は、オプティマイザは実体化されたテーブルにインデックスを作成します。<a class="xref" href="optimization.html#from-clause-subquery-optimization" title="8.2.1.18.3 FROM 句内のサブクエリー (派生テーブル) の最適化">セクション8.2.1.18.3「FROM 句内のサブクエリー (派生テーブル) の最適化」</a>を参照してください。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="view-restrictions"></a>D.5 ビューの制約</h2></div></div></div><a class="indexterm" name="idm139978988345376"></a><a class="indexterm" name="idm139978988343232"></a><p>
      ビューの処理は最適化されていません。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ビューにはインデックスを作成できません。
        </p></li><li class="listitem"><p>
          マージアルゴリズムを使用して処理されたビューに、インデックスを使用することは可能です。ただし、TEMPTABLE アルゴリズムで処理されたビューは、そのベースとなるテーブルのインデックスを利用できません (ただし、一時テーブルの作成中にはインデックスを使用できます)。
        </p></li></ul></div><p>
      ビューの <code class="literal">FROM</code> 句ではサブクエリーは使用できません。
    </p><p>
      一般的な原則では、テーブルを変更することも、サブクエリーの同じテーブルから選択することもできません。<a class="xref" href="restrictions.html#subquery-restrictions" title="D.4 サブクエリーの制約">セクションD.4「サブクエリーの制約」</a>を参照してください。
    </p><p>
      テーブルから選択するビューを選ぶ場合、ビューがサブクエリーのテーブルから選択される場合や、ビューがマージアルゴリズムを使用して評価される場合にも、同じ原則が適用されます。例:
    </p><pre class="programlisting">
CREATE VIEW v1 AS
SELECT * FROM t2 WHERE EXISTS (SELECT 1 FROM t1 WHERE t1.a = t2.a);

UPDATE t1, v2 SET t1.a = 1 WHERE t1.b = v2.b;
</pre><p>
      一時テーブルを使用してビューが評価される場合、ビューサブクエリーのテーブルから選択し、さらに外部クエリーでそのテーブルを変更することが<span class="emphasis"><em>可能</em></span>です。この場合、ビューは一時テーブルに格納されるため、実際にはビューをサブクエリーのテーブルから選択して<span class="quote">「<span class="quote">同時に</span>」</span>変更しているのではありません。(これは、ビュー定義で <code class="literal">ALGORITHM = TEMPTABLE</code> を指定することによって、MySQL で TEMPTABLE アルゴリズムを強制的に使用させる 1 つの理由です。)
    </p><p>
      <code class="literal">DROP TABLE</code> または <code class="literal">ALTER TABLE</code> を使用すると、ビュー定義で使用されているテーブルを削除または変更できます。ビューを無効化する場合でも、<code class="literal">DROP</code> または <code class="literal">ALTER</code> 操作によって警告が発せられることはありません。代わりに、あとからビューを使用するときにエラーが発生します。<code class="literal">CHECK TABLE</code> は、<code class="literal">DROP</code> または <code class="literal">ALTER</code> 操作で無効化されたビューのチェックに使用できます。
    </p><p>
      MySQL 5.6.5 より前では、ビュー定義は特定のステートメントによって<span class="quote">「<span class="quote">固定</span>」</span>されます。<code class="literal">PREPARE</code> で準備されたステートメントがビューを参照する場合、あとでステートメントが実行されるたびに確認されるビュー定義は、準備された時点のビュー定義になります。これは、ステートメントが準備されたあと、実行される前に、ビュー定義が変更されても同じことです。次の例で、<code class="literal">EXECUTE</code> ステートメントで返される結果は、現在の日時ではなく、ランダムな数値になります。
    </p><pre class="programlisting">
CREATE VIEW v AS SELECT RAND();
PREPARE s FROM 'SELECT * FROM v';
ALTER VIEW v AS SELECT NOW();
EXECUTE s;
</pre><p>
      ビューの更新可能性に関しては、どのビューでも理論的に更新可能であれば、実際に更新可能である必要があるというのがビューの全体的な目的です。これには、定義に <code class="literal">UNION</code> が記されているビューも含まれています。現時点では、理論的に更新可能なすべてのビューが、実際に更新可能というわけではありません。最初のビュー実装は、使用可能で更新可能なビューをできるだけ迅速に MySQL に提供するため、故意にこのように書かれていました。現在、理論的に更新可能なビューの多くは更新できますが、制限はまだ存在します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">WHERE</code> 句以外の場所にサブクエリーがある更新可能なビュー。<code class="literal">SELECT</code> リストにサブクエリーがあるビューの中には、更新可能な場合があります。
        </p></li><li class="listitem"><p>
          <code class="literal">UPDATE</code> を使用して、結合として定義されたビューの複数のベースとなるテーブルは更新できません。
        </p></li><li class="listitem"><p>
          <code class="literal">DELETE</code> を使用して、結合として定義されたビューは更新できません。
        </p></li></ul></div><a class="indexterm" name="idm139978988309488"></a><a class="indexterm" name="idm139978988307344"></a><a class="indexterm" name="idm139978988305312"></a><a class="indexterm" name="idm139978988303280"></a><a class="indexterm" name="idm139978988301248"></a><a class="indexterm" name="idm139978988299216"></a><p>
      ビューの現在の実装には欠点があります。ビューの作成に必要な基本権限 (<code class="literal">CREATE VIEW</code> 権限と <code class="literal">SELECT</code> 権限) がユーザーに付与されていても、<code class="literal">SHOW VIEW</code> 権限も付与されていない場合、オブジェクトで <code class="literal">SHOW CREATE VIEW</code> を呼び出すことはできません。
    </p><p>
      権限の不足のために <span class="command"><strong>mysqldump</strong></span> が失敗する可能性があるという欠点によって、このコマンドを使用したデータベースのバックアップで問題が発生する場合があります。この問題については Bug #22062 で説明しています。
    </p><p>
      問題の回避策として、ビューが作成されたときに MySQL が暗黙的に <code class="literal">SHOW VIEW</code> 権限を与えないため、<code class="literal">CREATE VIEW</code> を認められているユーザーに、管理者が手動でこの権限を付与します。
    </p><p>
      ビューにはインデックスがないので、インデックスのヒントは適用されません。ビューからの選択時のインデックスヒントの使用は許可されていません。
    </p><p>
      <code class="literal">SHOW CREATE VIEW</code> は、カラムごとに <code class="literal">AS <em class="replaceable"><code>alias_name</code></em></code> 句を使用してビュー定義を表示します。式からカラムを作成する場合、デフォルトのエイリアスは式テキストになり、かなり長くなることがあります。<code class="literal">CREATE VIEW</code> ステートメント内のカラム名に対するエイリアスは、(256 文字の最大のエイリアス長ではなく) 64 文字の最大のカラム長に対してチェックされます。その結果、いずれかのカラムエイリアスが 64 文字を超えた場合、<code class="literal">SHOW CREATE VIEW</code> の出力から作成されたビューは失敗します。これによって、長すぎるエイリアスを持つビューに対し、次の環境で問題が起きる可能性があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ビュー定義は、カラム長の制約を強制する新しいスレーブに複製できません。
        </p></li><li class="listitem"><p>
          <span class="command"><strong>mysqldump</strong></span> で作成されたダンプファイルは、カラム長の制約を強制するサーバーにロードできません。
        </p></li></ul></div><p>
      これらの問題を回避するには、短いカラム名を提供するエイリアスを使用するように、問題のある各ビュー定義を変更します。この場合、ビューは正しく複製され、エラーを生成しないでダンプおよびリロードできます。定義を変更するには、<code class="literal">DROP VIEW</code> および <code class="literal">CREATE VIEW</code> でビューを削除してから再度作成するか、<code class="literal">CREATE OR REPLACE VIEW</code> を使用して定義を置き換えます。
    </p><p>
      ダンプファイルのビュー定義リロード時に問題が発生する場合は、<code class="literal">CREATE VIEW</code> ステートメントを変更するようにダンプファイルを編集するとこの問題を回避できます。ただし、これは元のビュー定義を変更しないので、その後のダンプ操作の問題を引き起こす可能性があります。
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xa-restrictions"></a>D.6 XA トランザクションの制約</h2></div></div></div><a class="indexterm" name="idm139978988270368"></a><a class="indexterm" name="idm139978988268208"></a><p>
      XA トランザクションのサポートは、<code class="literal">InnoDB</code> ストレージエンジンに限られています。
    </p><p>
      <span class="quote">「<span class="quote">外部 XA</span>」</span> の場合、MySQL Server がリソースマネージャーとして機能し、クライアントプログラムがトランザクションマネージャーとして機能します。<span class="quote">「<span class="quote">内部 XA</span>」</span> の場合、MySQL サーバー内のストレージエンジンがリソースマネージャーとして機能し、サーバー自体がトランザクションマネージャーとして機能します。内部 XA サポートは、個々のストレージエンジンの機能によって制限されています。内部 XA は、複数のストレージエンジンが関与する XA トランザクションを処理するために必要になります。内部 XA の実装では、ストレージエンジンがテーブルハンドラレベルでの 2 フェーズコミットをサポートしている必要であり、現在これは <code class="literal">InnoDB</code> にのみ当てはまります。
    </p><p>
      <code class="literal">XA START</code> では、<code class="literal">JOIN</code> および <code class="literal">RESUME</code> 句はサポートされていません。
    </p><p>
      <code class="literal">XA END</code> では、<code class="literal">SUSPEND [FOR MIGRATE]</code> 句はサポートされていません。
    </p><p>
      <em class="replaceable"><code>xid</code></em> 値の <em class="replaceable"><code>bqual</code></em> 部分が、グローバルトランザクション内の XA トランザクションごとに異なる必要があるという要件が、現在の MySQL XA 実装の制限です。これは XA の仕様によるものではありません。
    </p><p>
      XA トランザクションが <code class="literal">PREPARED</code> 状態に達していれば、MySQL サーバーが (たとえば、Unix の <span class="command"><strong>kill -9</strong></span> で) 強制終了されたり、異常にシャットダウンしたりした場合でも、サーバーが再起動したあとでトランザクションを継続できます。ただし、クライアントが再接続し、トランザクションをコミットした場合、そのトランザクションは、コミットされていてもバイナリログには記録されません。これは、データとバイナリログの同期性がなくなったことを意味します。XA はレプリケーションとともに安全に使用できません。
    </p><p>
      <code class="literal">PREPARED</code> 状態に達しているものも含めた保留中の XA トランザクションを、サーバーがロールバックする可能性があります。これは、クライアントの接続が終了して、サーバーが起動を続ける場合、またはクライアントが接続していて、サーバーが正常にシャットダウンする場合に起こります。(後者の場合、サーバーは、各接続に終了というマークを付けから、関連付けられた <code class="literal">PREPARED</code> XA トランザクションをロールバックします。)<code class="literal">PREPARED</code> XA トランザクションをコミットまたはロールバック可能である必要がありますが、これはバイナリロギングメカニズムに変更を加えずに行うことはできません。
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="charset-restrictions"></a>D.7 文字セットの制約</h2></div></div></div><a class="indexterm" name="idm139978988246192"></a><a class="indexterm" name="idm139978988244080"></a><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          識別子は、<code class="literal">utf8</code> を使用して <code class="literal">mysql</code> データベーステーブル (<code class="literal">user</code>、<code class="literal">db</code> など) に格納されますが、識別子には Basic Multilingual Plane (BMP) の文字だけを含めることができます。識別子では補助文字は許可されません。
        </p></li><li class="listitem"><p>
          <code class="literal">ucs2</code>、<code class="literal">utf16</code>、<code class="literal">utf16le</code>、および <code class="literal">utf32</code> 文字セットには次の制約があります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              これらはクライアント文字セットとして使用できません。つまり、<code class="literal">SET NAMES</code> または <code class="literal">SET CHARACTER SET</code> では機能しません。(<a class="xref" href="globalization.html#charset-connection" title="10.1.4 接続文字セットおよび照合順序">セクション10.1.4「接続文字セットおよび照合順序」</a>を参照してください。)
            </p></li><li class="listitem"><p>
              現在、<code class="literal">LOAD DATA INFILE</code> を使用して、これらの文字セットを使用するデータファイルをロードできません。
            </p></li><li class="listitem"><p>
              <code class="literal">FULLTEXT</code> インデックスは、これらのいずれかの文字セットを使用するカラムでは作成できません。ただし、インデックスのないカラムでは <code class="literal">IN BOOLEAN MODE</code> 検索を実行できます。
            </p></li><li class="listitem"><p>
              ベースとなるシステム呼び出しではゼロバイトで終了する文字列が要求されるため、これらの文字セットを含む <code class="literal">ENCRYPT()</code> の使用はお勧めしません。
            </p></li></ul></div></li><li class="listitem"><p>
          <code class="literal">REGEXP</code> および <code class="literal">RLIKE</code> 演算子はバイト単位で機能するため、マルチバイトセーフではなく、マルチバイト文字セットを使用すると想定外の結果が生成される可能性があります。さらに、これらの演算子ではそのバイト値に基づいて文字が比較されるため、アクセント記号付き文字は、指定された照合順序では等しいとみなされた場合でも、等しいとして比較されない可能性があります。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-schema-restrictions"></a>D.8 パフォーマンススキーマの制約</h2></div></div></div><a class="indexterm" name="idm139978988218272"></a><a class="indexterm" name="idm139978988216096"></a><a class="indexterm" name="idm139978988213984"></a><a class="indexterm" name="idm139978988211984"></a><p>
      パフォーマンススキーマでは、データの収集または生成に相互排他ロックを使用できないので、一貫性は保証されず、適切な結果にならないことがあります。<code class="literal">performance_schema</code> テーブルのイベント値は、非決定的であり、反復不可です。
    </p><p>
      別のテーブルにイベント情報を保存した場合、元のイベントはあとから利用できません。たとえば、<code class="literal">performance_schema</code> テーブルから一時テーブルにイベントを選択し、あとからそのテーブルと元のテーブルを結合させる場合、一致するものがない可能性があります。
    </p><p>
      <span class="command"><strong>mysqldump</strong></span> と <code class="literal">BACKUP DATABASE</code> は、<code class="literal">performance_schema</code> データベース内のテーブルを無視します。
    </p><p>
      <code class="literal">performance_schema</code> データベース内のテーブルは、<code class="literal">LOCK TABLES</code> でロックできませんが、<code class="literal">setup_<em class="replaceable"><code>xxx</code></em></code> テーブルは除きます。
    </p><p>
      <code class="literal">performance_schema</code> データベース内のテーブルにインデックスを設定できません。
    </p><p>
      <code class="literal">performance_schema</code> データベース内のテーブルを参照するクエリーの結果は、クエリーキャッシュに保存されません。
    </p><p>
      <code class="literal">performance_schema</code> データベース内のテーブルは複製されません。
    </p><p>
      パフォーマンススキーマは、<code class="literal">libmysqld</code> 組み込みサーバーでは利用できません。
    </p><p>
      タイマーの種類は、プラットフォームごとに異なります。<code class="literal">performance_timers</code> テーブルは使用可能なイベントタイマーを示します。特定のタイマー名に対するこのテーブルでの値が <code class="literal">NULL</code> の場合、そのタイマーはプラットフォームでサポートされていません。
    </p><p>
      ストレージエンジンに適用されるインストゥルメントは、すべてのストレージエンジンに実装されていないことがあります。各サードパーティーエンジンのインストゥルメンテーションはエンジン管理者の責任です。
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="pluggable-authentication-restrictions"></a>D.9 プラガブルな認証の制約</h2></div></div></div><a class="indexterm" name="idm139978988190576"></a><a class="indexterm" name="idm139978988188400"></a><p>
      このセクションの最初の部分では、<a class="xref" href="security.html#pluggable-authentication" title="6.3.7 プラガブル認証">セクション6.3.7「プラガブル認証」</a>で説明しているプラガブルな認証フレームワークの適用基準に関する一般的な制約について説明します。2 番目の部分では、サードパーティーコネクタ開発者が、コネクタがプラガブルな認証機能を利用できる範囲と、対応性を高めるために行うステップについて判断する方法について説明します。
    </p><p>
      ここで使用する<span class="quote">「<span class="quote">ネイティブ認証</span>」</span>という語は、<code class="literal">mysql.user</code> テーブルの <code class="literal">Password</code> カラムに格納されたパスワードに対する認証を指します。これは、プラガブルな認証が実装される前に古い MySQL Server で提供されていたものと同じ認証方法です。これが引き続きデフォルトの方法ですが、現在はプラグインを使用して実装されます。<span class="quote">「<span class="quote">Windows ネイティブ認証</span>」</span>とは、Windows ネイティブ認証プラグイン (<span class="quote">「<span class="quote">Windows プラグイン</span>」</span>と略します) で実装された、すでに Windows にログインしているユーザーの資格証明を使用した認証を示します。
    </p><h3><a name="idm139978988180160"></a>一般的なプラガブルな認証の制約</h3><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <span class="bold"><strong>Connector/C、Connector/C++:</strong></span> これらのコネクタを使用するクライアントは、ネイティブ認証を使用するアカウントを通じてのみ、サーバーに接続できます。
        </p><p>
          例外: コネクタは、<code class="literal">libmysqlclient</code> に (静的ではなく) 動的にリンクするように構築された場合にプラガブルな認証をサポートし、最新バージョンの <code class="literal">libmysqlclient</code> がインストールされている場合、またはコネクタが最新の <code class="literal">libmysqlclient</code> に対してリンクするようにソースから再コンパイルされている場合にそのバージョンをロードします。
        </p></li><li class="listitem"><p>
          <span class="bold"><strong>Connector/J:</strong></span> このコネクタを使用するクライアントは、ネイティブ認証を使用するアカウントを通じてのみサーバーに接続できます。
        </p></li><li class="listitem"><p>
          <span class="bold"><strong>Connector/Net:</strong></span> Connector/Net 6.4.4 より前では、このコネクタを使用するクライアントは、ネイティブ認証を使用するアカウントを通じてのみサーバーに接続できます。6.4.4 以降では、クライアントは、Windows プラグインを使用するアカウントを通じてサーバーに接続することもできます。
        </p></li><li class="listitem"><p>
          <span class="bold"><strong>Connector/ODBC:</strong></span> Connector/ODBC 3.51.29 および 5.1.9 より前では、このコネクタを使用するクライアントは、ネイティブ認証を使用するアカウントを通じてのみサーバーに接続できます。3.51.29 および 5.1.9 以降では、Windows 用のこのコネクタのバイナリリリースを使用するクライアントは、PAM または Windows プラグインを使用するアカウントを通じてサーバーに接続することもできます。(これらの機能は、以前に使用されていた MySQL 5.1 <code class="literal">libmysqlclient</code> ではなく MySQL 5.5.16 <code class="literal">libmysqlclient</code> に対して Connector/ODBC バイナリをリンクした結果得られます。新しい <code class="literal">libmysqlclient</code> には、サーバー側の PAM および Windows 認証プラグインに必要なクライアント側のサポートが含まれます。)
        </p></li><li class="listitem"><p>
          <span class="bold"><strong>Connector/PHP:</strong></span> このコネクタを使用するクライアントは、PHP 用の MySQL ネイティブドライバ (<code class="literal">mysqlnd</code>) を使用してコンパイルされている場合、ネイティブ認証を使用するアカウントを通じてのみサーバーに接続できます。
        </p></li><li class="listitem"><p>
          <span class="bold"><strong>MySQL Proxy:</strong></span> MySQL Proxy 0.8.2 より前では、クライアントは、ネイティブ認証を使用するアカウントを通じてのみサーバーに接続できます。0.8.2 以降では、クライアントは、PAM プラグインを使用するアカウントを通じてサーバーに接続することもできます。0.8.3 以降では、クライアントは、Windows プラグインを使用するアカウントを通じてサーバーに接続することもできます。
        </p></li><li class="listitem"><p>
          <span class="bold"><strong>MySQL Enterprise Backup:</strong></span> バージョン 3.6.1 より前の MySQL Enterprise Backup は、ネイティブ認証を使用するアカウントを通じてのみサーバーへの接続をサポートします。3.6.1 以降では、MySQL Enterprise Backup は、ネイティブ以外の認証を使用するアカウントを通じてサーバーに接続できます。
        </p></li><li class="listitem"><p>
          <span class="bold"><strong>Windows ネイティブ認証:</strong></span> Windows プラグインを使用するアカウントを通じた接続は、Windows Domain セットアップを必要とします。これがない場合、NTLM 認証が使用され、ローカル接続だけが可能になります。つまり、クライアントとサーバーを同じコンピュータ上で実行する必要があります。
        </p></li><li class="listitem"><p>
          <span class="bold"><strong>プロキシユーザー:</strong></span> プロキシユーザーサポートは、プロキシユーザー機能を実装するプラグイン (つまり、接続しているユーザーの名前と異なるユーザー名を返す場合があるプラグイン) で認証されたアカウントを通じて、クライアントが接続できる範囲まで利用できます。たとえば、ネイティブ認証プラグインは、プロキシユーザーをサポートしませんが、PAM および Windows プラグインはサポートします。
        </p></li><li class="listitem"><p>
          <span class="bold"><strong>レプリケーション:</strong></span> MySQL 5.6.4 より前では、レプリケーションスレーブは、ネイティブ認証を使用するマスターアカウントを通じてのみマスターサーバーに接続できます。5.6.4 以降では、レプリケーションスレーブは、必要なクライアント側のプラグインが利用できる場合、ネイティブ以外の認証を使用するマスターアカウントを通じて接続することもできます。プラグインは、<code class="literal">libmysqlclient</code> に組み込まれている場合、デフォルトで利用できます。それ以外の場合、プラグインは、スレーブ <code class="literal">plugin_dir</code> システム変数によって指名された、スレーブ側のディレクトリにインストールする必要があります。
        </p></li><li class="listitem"><p>
          <span class="bold"><strong><code class="literal">FEDERATED</code> テーブル:</strong></span> <code class="literal">FEDERATED</code> テーブルは、ネイティブ認証を使用するリモートサーバー上のアカウントを通じてのみリモートテーブルにアクセスできます。
        </p></li></ul></div><h3><a name="idm139978988146000"></a>プラガブルな認証とサードパーティーコネクタ</h3><p>
      サードパーティーコネクタ開発者は、次のガイドラインを使用して、プラガブルな認証機能を利用するためのコネクタの準備と、対応性を高めるために行うステップについて判断できます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          変更が行われていない既存のコネクタは、ネイティブ認証を使用し、このコネクタを使用するクライアントは、ネイティブ認証を使用するアカウントを通じてのみサーバーに接続できます。<span class="emphasis"><em>ただし、最新バージョンのサーバーに対してコネクタをテストして、このような接続が引き続き問題なく機能することを検証する必要があります。</em></span>
        </p><p>
          例外: コネクタは、(静的ではなく) 動的に <code class="literal">libmysqlclient</code> にリンクしている場合に、変更せずにプラガブルな認証を処理でき、最新バージョンの <code class="literal">libmysqlclient</code> がインストールされている場合に、このバージョンをロードします。
        </p></li><li class="listitem"><p>
          プラガブルな認証機能を利用するには、<code class="literal">libmysqlclient</code> ベースのコネクタを、最新バージョンの <code class="literal">libmysqlclient</code> に対して再リンクする必要があります。これにより、コネクタは、現在 <code class="literal">libmysqlclient</code> に組み込まれているクライアント側のプラグイン (PAM 認証に必要な平文プラグインや Windows ネイティブ認証に必要な Windows プラグインなど) を必要とするアカウントを通じた接続をサポートできるようになります。現在の <code class="literal">libmysqlclient</code> とのリンクによっても、コネクタは、デフォルトの MySQL プラグインディレクトリ (通常、ローカルサーバーの <code class="literal">plugin_dir</code> システム変数のデフォルト値で指名されたディレクトリ) にインストールされたクライアント側にアクセスできるようになります。
        </p><p>
          コネクタが動的に <code class="literal">libmysqlclient</code> にリンクする場合、より新しいバージョンの <code class="literal">libmysqlclient</code> がクライアントホストにインストールされていることと、コネクタが実行時にそれをロードすることを確認する必要があります。
        </p></li><li class="listitem"><p>
          コネクタが特定の認証方式をサポートするには、直接クライアント/サーバープロトコルにその方式を実装します。Connector/Net はこのアプローチを使用して、Windows ネイティブ認証のサポートを提供します。
        </p></li><li class="listitem"><p>
          コネクタが、デフォルトのプラグインディレクトリとは異なるディレクトリから、クライアント側のプラグインをロードできる必要がある場合、クライアントユーザーがそのディレクトリを指定するための手段を実装する必要があります。この候補としては、コネクタがディレクトリ名を取得できるコマンド行オプションまたは環境変数などがあります。<span class="command"><strong>mysql</strong></span> や <span class="command"><strong>mysqladmin</strong></span> などの標準 MySQL クライアントプログラムは、<code class="option">--plugin-dir</code> オプションを実装します。<a class="xref" href="connectors-apis.html#c-api-plugin-functions" title="23.8.14 C API クライアントプラグイン関数">セクション23.8.14「C API クライアントプラグイン関数」</a>も参照してください。
        </p></li><li class="listitem"><p>
          コネクタでのプロキシユーザーのサポートは、このセクションで前述したように、コネクタがサポートする認証方式がプロキシユーザーを許可するかどうかによって異なります。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="limits"></a>D.10 MySQL での制限</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="restrictions.html#joins-limits">D.10.1 結合の制限</a></span></dt><dt><span class="section"><a href="restrictions.html#database-count-limit">D.10.2 データベースおよびテーブルの数に対する制限</a></span></dt><dt><span class="section"><a href="restrictions.html#table-size-limit">D.10.3 テーブルサイズの制限</a></span></dt><dt><span class="section"><a href="restrictions.html#column-count-limit">D.10.4 テーブルカラム数と行サイズの制限</a></span></dt><dt><span class="section"><a href="restrictions.html#limits-frm-file">D.10.5 .frm ファイル構造により課せられる制限</a></span></dt><dt><span class="section"><a href="restrictions.html#limits-windows">D.10.6 Windows プラットフォームの制限</a></span></dt></dl></div><a class="indexterm" name="idm139978988122880"></a><a class="indexterm" name="idm139978988120752"></a><p>
      このセクションでは、MySQL 5.6 での現在の制限を示します。
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="joins-limits"></a>D.10.1 結合の制限</h3></div></div></div><a class="indexterm" name="idm139978988117072"></a><p>
        1 つの結合で参照できるテーブルの最大数は 61 です。これはビューの定義で参照できるテーブルの数にも適用されます。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="database-count-limit"></a>D.10.2 データベースおよびテーブルの数に対する制限</h3></div></div></div><a class="indexterm" name="idm139978988112944"></a><a class="indexterm" name="idm139978988110800"></a><p>
        MySQL にはデータベース数の制限はありません。ベースとなるファイルシステムによっては、ディレクトリ数に制限がある場合があります。
      </p><p>
        MySQL にはテーブル数の制限はありません。ベースとなるファイルシステムによっては、テーブルを表すファイル数に制限がある場合があります。個々のストレージエンジンには、エンジン固有の制約が課される場合があります。<code class="literal">InnoDB</code> では、最大 40 億個のテーブルを使用できます。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="table-size-limit"></a>D.10.3 テーブルサイズの制限</h3></div></div></div><a class="indexterm" name="idm139978988104960"></a><a class="indexterm" name="idm139978988102848"></a><a class="indexterm" name="idm139978988100816"></a><a class="indexterm" name="idm139978988099440"></a><a class="indexterm" name="idm139978988097344"></a><a class="indexterm" name="idm139978988095312"></a><p>
        MySQL データベースの事実上の最大テーブルサイズは、通常、MySQL の内部制限ではなくオペレーティングシステムのファイルサイズに関する制約によって判断します。次の表に、オペレーティングシステムのファイルサイズの制限に関するいくつかの例を示します。これは、大まかなガイドに過ぎず、確実なものではありません。もっとも新しい情報については、使用しているオペレーティングシステムに固有のドキュメントを必ず確認してください。
      </p><div class="informaltable"><table summary="次の表は、オペレーティングシステムのファイルサイズ制限の例を示します。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">オペレーティングシステム</th><th scope="col">ファイルサイズの制限</th></tr></thead><tbody><tr><td scope="row">Win32 (FAT/FAT32)</td><td>2G バイト/4G バイト</td></tr><tr><td scope="row">Win32 (NTFS)</td><td>2T バイト (これを超える可能性あり)</td></tr><tr><td scope="row">Linux 2.2-Intel 32 ビット</td><td>2G バイト (LFS: 4G バイト)</td></tr><tr><td scope="row">Linux 2.4+</td><td>(ext3 ファイルシステムを使用) 4T バイト</td></tr><tr><td scope="row">Solaris 9/10</td><td>16T バイト</td></tr><tr><td scope="row">OS X (HFS+)</td><td>2T バイト</td></tr></tbody></table></div><p>
        Windows ユーザーの場合、FAT および VFAT (FAT32) は、MySQL で本番使用に適しているとは見なされ<span class="emphasis"><em>ません</em></span>。代わりに NTFS を使用してください。
      </p><p>
        Linux 2.2 では、ext2 ファイルシステム用の Large File Support (LFS) パッチを使用すると、サイズが 2G バイトより大きな <code class="literal">MyISAM</code> テーブルを取得できます。ほとんどの最近の Linux 配布は、カーネル 2.4 以上に基づいており、必要な LFS パッチはすべて含まれています。Linux 2.4 では、大きなファイル (最大 2T バイト) をサポートするための ReiserFS 用のパッチも存在しています。JFS および XFS では、Linux でペタバイト以上のファイルが可能です。
      </p><p>
        Linux における LFS に関する詳細な概要については、<a class="ulink" href="http://www.suse.de/~aj/linux_lfs.html" target="_top">http://www.suse.de/~aj/linux_lfs.html</a> にある Andreas Jaeger 氏の「<em class="citetitle">Large File Support in Linux</em>」のページを参照してください。
      </p><p>
        フルテーブルエラーが発生した場合、その理由はいくつかあります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            ディスクがいっぱいになっている可能性がある。
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> ストレージエンジンが、複数のファイルから作成できるテーブルスペース内に <code class="literal">InnoDB</code> テーブルを保持している。このため、テーブルが個々のファイルの最大サイズを超えることが可能です。テーブルスペースには、生のディスクパーティションを含めることができ、非常に大きなテーブルが許可されます。最大のテーブルスペースサイズは 64T バイトです。
          </p><p>
            <code class="literal">InnoDB</code> テーブルを使用している場合、<code class="literal">InnoDB</code> テーブルスペース内のスペースが不足します。この場合、解決策は <code class="literal">InnoDB</code> テーブルスペースを拡張することです。<a class="xref" href="innodb-storage-engine.html#innodb-data-log-reconfiguration" title="14.5.7 InnoDB ログファイルの数またはサイズの変更、および InnoDB テーブルスペースのサイズの変更">セクション14.5.7「InnoDB ログファイルの数またはサイズの変更、および InnoDB テーブルスペースのサイズの変更」</a>を参照してください。
          </p></li><li class="listitem"><p>
            サポートするファイルサイズが最大 2G バイトのオペレーティングシステムで <code class="literal">MyISAM</code> テーブルを使用しており、データファイルまたはインデックスファイルでこの制限に達している。
          </p></li><li class="listitem"><p>
            <code class="literal">MyISAM</code> テーブルを使用していて、テーブルに必要な領域が内部ポインタサイズによって許可されているサイズを超えている。<code class="literal">MyISAM</code> では、データファイルとインデックスファイルのサイズはデフォルトで最大 256T バイトですが、この制限は、65,536T バイト (256<sup>7</sup> − 1 バイト) の最大許容サイズまで変更できます。
          </p><p>
            デフォルトの制限より大きな <code class="literal">MyISAM</code> テーブルが必要であり、オペレーティングシステムが大きなファイルをサポートしている場合は、<code class="literal">CREATE TABLE</code> ステートメントは <code class="literal">AVG_ROW_LENGTH</code> オプションと <code class="literal">MAX_ROWS</code> オプションをサポートします。<a class="xref" href="sql-syntax.html#create-table" title="13.1.17 CREATE TABLE 構文">セクション13.1.17「CREATE TABLE 構文」</a>を参照してください。サーバーはこれらのオプションを使用して、許可するテーブルのサイズを決定します。
          </p><p>
            ポインタサイズが既存のテーブルには小さすぎる場合、テーブルの最大許容サイズを増やすように <code class="literal">ALTER TABLE</code> でオプションを変更できます。<a class="xref" href="sql-syntax.html#alter-table" title="13.1.7 ALTER TABLE 構文">セクション13.1.7「ALTER TABLE 構文」</a>を参照してください。
          </p><pre class="programlisting">
ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> MAX_ROWS=1000000000 AVG_ROW_LENGTH=<em class="replaceable"><code>nnn</code></em>;
</pre><p>
            <code class="literal">BLOB</code> または <code class="literal">TEXT</code> カラムを含むテーブルにのみ、<code class="literal">AVG_ROW_LENGTH</code> を指定する必要があります。この場合、MySQL は、行数だけに基づいて必要な領域を最適化できません。
          </p><p>
            <code class="literal">MyISAM</code> テーブルのデフォルトのサイズ制限を変更するには、内部行ポインタに使用されるバイト数を設定する <code class="literal">myisam_data_pointer_size</code> を設定します。<code class="literal">MAX_ROWS</code> オプションを指定しない場合、新しいテーブルのポインタサイズを設定するためにこの値が使用されます。<code class="literal">myisam_data_pointer_size</code> の値は 2 から 7 で指定できます。4 の値は 4G バイトまでのテーブルを許可し、6 の値は 256T バイトまでのテーブルを許可します。
          </p><p>
            次のステートメントを使用すると、データファイルおよびインデックスファイルの最大サイズを確認できます。
          </p><pre class="programlisting">
SHOW TABLE STATUS FROM <em class="replaceable"><code>db_name</code></em> LIKE '<em class="replaceable"><code>tbl_name</code></em>';
</pre><p>
            <span class="command"><strong>myisamchk -dv /path/to/table-index-file</strong></span> も使用できます。<a class="xref" href="sql-syntax.html#show" title="13.7.5 SHOW 構文">セクション13.7.5「SHOW 構文」</a>または<a class="xref" href="programs.html#myisamchk" title="4.6.3 myisamchk — MyISAM テーブルメンテナンスユーティリティー">セクション4.6.3「<span class="command"><strong>myisamchk</strong></span> — MyISAM テーブルメンテナンスユーティリティー」</a>を参照してください。
          </p><p>
            <code class="literal">MyISAM</code> テーブルのファイルサイズ制限に対処するその他の方法は次のとおりです。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                大きなテーブルが読み取り専用である場合、<span class="command"><strong>myisampack</strong></span> を使用してこのテーブルを圧縮できます。<span class="command"><strong>myisampack</strong></span> は通常、少なくとも 50% 圧縮するので、実質上、さらに大きなテーブルを保有できます。<span class="command"><strong>myisampack</strong></span> で複数のテーブルを単一のテーブルにマージすることもできます。<a class="xref" href="programs.html#myisampack" title="4.6.5 myisampack — 圧縮された読み取り専用の MyISAM テーブルの生成">セクション4.6.5「<span class="command"><strong>myisampack</strong></span> — 圧縮された読み取り専用の MyISAM テーブルの生成」</a>を参照してください。
              </p></li><li class="listitem"><p>
                MySQL には、単一の <code class="literal">MERGE</code> テーブルと同一の構造を持つ <code class="literal">MyISAM</code> テーブルの集まりを処理できるようにする <code class="literal">MERGE</code> ライブラリが含まれます。<a class="xref" href="storage-engines.html#merge-storage-engine" title="15.7 MERGE ストレージエンジン">セクション15.7「MERGE ストレージエンジン」</a>を参照してください。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">MEMORY</code> (<code class="literal">HEAP</code>) ストレージエンジンを使用している場合は、<code class="literal">max_heap_table_size</code> システム変数の値を増やす必要があります。<a class="xref" href="server-administration.html#server-system-variables" title="5.1.4 サーバーシステム変数">セクション5.1.4「サーバーシステム変数」</a>を参照してください。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="column-count-limit"></a>D.10.4 テーブルカラム数と行サイズの制限</h3></div></div></div><a class="indexterm" name="idm139978988023792"></a><a class="indexterm" name="idm139978988021616"></a><a class="indexterm" name="idm139978988019552"></a><a class="indexterm" name="idm139978988017504"></a><p>
        テーブルあたり 4096 カラムというハード制限がありますが、特定のテーブルでは有効な最大数がこれより少なくなる可能性があります。正確な制限は、相互作用する複数の要因によって異なります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            すべてのテーブル (ストレージエンジンには無関係) の最大行サイズは 65,535 バイトです。ストレージエンジンではこの制限に対してさらなる制約を加えられる場合があり、有効な最大行サイズは少なくなります。
          </p><p>
            すべてのカラムの合計長は最大行サイズを超えられないので、このサイズはカラム数 (およびサイズの可能性もあり) を制約します。たとえば、<code class="literal">utf8</code> 文字では、文字あたり最大 3 バイトが必要になるので、<code class="literal">CHAR(255) CHARACTER SET utf8</code> カラムの場合、サーバーは値ごとに 255 × 3 = 765 バイトを割り当てる必要があります。この結果、テーブルにはこのようなカラムを 65,535 / 765 = 85 以上は含められません。
          </p><p>
            可変長カラムのストレージには長さバイトが含まれ、これには行サイズに対して評価されます。たとえば、<code class="literal">VARCHAR(255) CHARACTER SET utf8</code> カラムは、値の長さを格納するために 2 バイトを使用するので、それぞれの値は最大 767 バイトを使用できます。
          </p><p>
            <code class="literal">BLOB</code> カラムと <code class="literal">TEXT</code> カラムは、その内容が行の残りとは別に格納されるので、行サイズに対してそれぞれ 9 から 12 (1から4+8) バイトになります。
          </p><p>
            カラムを <code class="literal">NULL</code> と宣言すると、使用できるカラムの最大数を減らすことができます。<code class="literal">MyISAM</code> テーブルの場合、<code class="literal">NULL</code> カラムは、値が <code class="literal">NULL</code> であるかどうかを記録するための追加領域を行内に必要とします。各 <code class="literal">NULL</code> カラムは 1 ビット余分に占め、もっとも近いバイトまで丸められます。バイトでの最大の行長は次のように計算できます。
          </p><pre class="programlisting">
row length = 1
             + (<em class="replaceable"><code>sum of column lengths</code></em>)
             + (<em class="replaceable"><code>number of NULL columns</code></em> + <em class="replaceable"><code>delete_flag</code></em> + 7)/8
             + (<em class="replaceable"><code>number of variable-length columns</code></em>)
</pre><p>
            <em class="replaceable"><code>delete_flag</code></em> は静的行フォーマットのテーブルに対しては 1 です。静的テーブルは、行が削除されているかどうかを示すフラグとして、行レコード内の 1 ビットを使用します。このフラグは動的行ヘッダーに格納されるので、動的テーブルの場合、<em class="replaceable"><code>delete_flag</code></em> は 0 です。<code class="literal">MyISAM</code> テーブル形式の詳細は、<a class="xref" href="storage-engines.html#myisam-table-formats" title="15.2.3 MyISAM テーブルのストレージフォーマット">セクション15.2.3「MyISAM テーブルのストレージフォーマット」</a>を参照してください。
          </p><p>
            <code class="literal">InnoDB</code> テーブルの場合、ストレージサイズは、<code class="literal">NULL</code> カラムおよび <code class="literal">NOT NULL</code> カラムの場合と同じなので、前述の計算は適用されません。
          </p><p>
            カラムが必要とするサイズが 32,765 + 2 バイトと 32,766 + 2 バイトであり、65,535 バイトの最大行サイズ以内に収まるので、テーブル <code class="literal">t1</code> を作成する次のステートメントは成功します。
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE t1</code></strong>
    -&gt; <strong class="userinput"><code>(c1 VARCHAR(32765) NOT NULL, c2 VARCHAR(32766) NOT NULL)</code></strong>
    -&gt; <strong class="userinput"><code>ENGINE = MyISAM CHARACTER SET latin1;</code></strong>
Query OK, 0 rows affected (0.02 sec)
</pre><p>
            カラムは <code class="literal">NULL</code> であり、<code class="literal">MyISAM</code> が必要とする追加領域によって行サイズが 65,535 バイトを超えるので、テーブル <code class="literal">t2</code> を作成する次のステートメントは失敗します。
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE t2</code></strong>
    -&gt; <strong class="userinput"><code>(c1 VARCHAR(32765) NULL, c2 VARCHAR(32766) NULL)</code></strong>
    -&gt; <strong class="userinput"><code>ENGINE = MyISAM CHARACTER SET latin1;</code></strong>
ERROR 1118 (42000): Row size too large. The maximum row size for the
used table type, not counting BLOBs, is 65535. You have to change some
columns to TEXT or BLOBs
</pre><p>
            カラム長は 65,535 バイトの最大長内に収まっていますが、長さを記録するために 2 つの追加バイトが必要になり、このため行サイズが 65,535 バイトを超えるので、テーブル <code class="literal">t3</code> を作成する次のステートメントは失敗します。
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE t3</code></strong>
    -&gt; <strong class="userinput"><code>(c1 VARCHAR(65535) NOT NULL)</code></strong>
    -&gt; <strong class="userinput"><code>ENGINE = MyISAM CHARACTER SET latin1;</code></strong>
ERROR 1118 (42000): Row size too large. The maximum row size for the
used table type, not counting BLOBs, is 65535. You have to change some
columns to TEXT or BLOBs
</pre><p>
            カラム長を 65,533 以下に減らすと、ステートメントは成功します。
          </p></li><li class="listitem"><p>
            個々のストレージエンジンで、テーブルカラム数を制限するその他の制約が適用される場合があります。例:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">InnoDB</code> が許可するカラム数は最大 1000 です。
              </p></li><li class="listitem"><p>
                <code class="literal">InnoDB</code> は、データベースページ (約 8,000 バイト) の半分以下に行サイズを制限し、<code class="literal">VARBINARY</code>、<code class="literal">VARCHAR</code>、<code class="literal">BLOB</code>、または <code class="literal">TEXT</code> カラムを含みません。
              </p></li><li class="listitem"><p>
                異なる <code class="literal">InnoDB</code> ストレージフォーマット (<code class="literal">COMPRESSED</code>、<code class="literal">REDUNDANT</code>) では、使用するページヘッダーおよびトレーラデータの量が違うため、行に使用できるストレージ量に影響がおよびます。
              </p></li></ul></div></li><li class="listitem"><p>
            それぞれのテーブルにはテーブル定義を含む <code class="filename">.frm</code> ファイルがあります。この定義は、テーブルで許可されるカラム数に影響する方法でこのファイルの内容に影響を与えます。詳細は、<a class="xref" href="restrictions.html#limits-frm-file" title="D.10.5 .frm ファイル構造により課せられる制限">セクションD.10.5「.frm ファイル構造により課せられる制限」</a>を参照してください。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="limits-frm-file"></a>D.10.5 .frm ファイル構造により課せられる制限</h3></div></div></div><a class="indexterm" name="idm139978987957088"></a><p>
        それぞれのテーブルにはテーブル定義を含む <code class="filename">.frm</code> ファイルがあります。サーバーは次の式を使用して、64K バイトの上限に対して、ファイルに格納されたいくつかのテーブル情報をチェックします。
      </p><pre class="programlisting">
if (info_length+(ulong) create_fields.elements*FCOMP+288+
    n_length+int_length+com_length &gt; 65535L || int_count &gt; 255)
</pre><p>
        <code class="filename">.frm</code> ファイルに格納された情報のうち式に対してチェックされる部分は 64K バイトの制限を超えることはできません。したがって、テーブル定義がこのサイズに達した場合、これ以上カラムを追加できません。
      </p><p>
        式の関連因子は次のとおりです。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">info_length</code> は、<span class="quote">「<span class="quote">画面</span>」</span>に必要な領域です。これは MySQL の Unireg から継承したものです。
          </p></li><li class="listitem"><p>
            <code class="literal">create_fields.elements</code> はカラム数です。
          </p></li><li class="listitem"><p>
            <code class="literal">FCOMP</code> は 17 です。
          </p></li><li class="listitem"><p>
            <code class="literal">n_length</code> は、名前あたり 1 バイトの区切り文字を含む、すべてのカラム名の合計長です。
          </p></li><li class="listitem"><p>
            <code class="literal">int_length</code> は、<code class="literal">ENUM</code> および <code class="literal">SET</code> カラムの値のリストに関連します。このコンテキストでは、<span class="quote">「<span class="quote">int</span>」</span> は<span class="quote">「<span class="quote">整数</span>」</span>の意味ではありません。これは<span class="quote">「<span class="quote">間隔</span>」</span>を意味し、<code class="literal">ENUM</code> および <code class="literal">SET</code> カラムの総称です。
          </p></li><li class="listitem"><p>
            <code class="literal">int_count</code> は、一意の <code class="literal">ENUM</code> および <code class="literal">SET</code> 定義の数です。
          </p></li><li class="listitem"><p>
            <code class="literal">com_length</code> はカラムコメントの合計長です。
          </p></li></ul></div><p>
        前述の式には、許可されるテーブル定義に対し複数の意味があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            長いカラム名を使用すると、<code class="literal">ENUM</code> または <code class="literal">SET</code> カラムを含めたり、カラムコメントを使用したりした場合と同様に、カラムの最大数が減ることがあります。
          </p></li><li class="listitem"><p>
            テーブルに保持できる一意の <code class="literal">ENUM</code> および <code class="literal">SET</code> 定義は 255 以下です。同一要素リストを持つカラムは、この制限に対して同じと見なされます。たとえば、次の 2 つのカラムがテーブルに含まれる場合、これらは定義が同一なので、この制限に対して (2 つではなく) 1 つと見なされます。
          </p><pre class="programlisting">
e1 ENUM('a','b','c')
e2 ENUM('a','b','c')
</pre></li><li class="listitem"><p>
            一意の <code class="literal">ENUM</code> および <code class="literal">SET</code> 定義内の要素名の合計長は、64K バイトの制限に対して加えられるので、特定の <code class="literal">ENUM</code> カラムの要素の数に対する理論的な制限は 65,535 ですが、実際の限度は 3000 未満です。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="limits-windows"></a>D.10.6 Windows プラットフォームの制限</h3></div></div></div><a class="indexterm" name="idm139978987917328"></a><p>
        次の制限が、Windows プラットフォームで MySQL を使用する場合に適用されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <span class="bold"><strong>プロセスメモリー</strong></span>
          </p><p>
            Windows 32 ビットプラットフォームでは、デフォルトで、MySQL などの単一プロセス内で 2G バイトを超える RAM を使用できません。これは、Windows 32 ビットでの物理アドレスの制限が 4G バイトであり、Windows 内のデフォルト設定では、カーネル (2G バイト) とユーザー/アプリケーション (2G バイト) とに仮想アドレス空間を分割するためです。
          </p><p>
            Windows の一部のバージョンには、カーネルアプリケーションを減らすことによってより大きなアプリケーションに対応するブート時設定があります。または、2G バイト以上を使用するには、64 ビットバージョンの Windows を使用します。
          </p></li><li class="listitem"><p>
            <span class="bold"><strong>ファイルシステムエイリアス</strong></span>
          </p><p>
            <code class="literal">MyISAM</code> テーブルの使用時には、Windows でエイリアスを使用して、別のボリューム上のデータファイルにリンクしててからメインの MySQL <code class="option">datadir</code> の場所に戻るようにはリンクできません。
          </p><p>
            この機能は、多くの場合、<code class="option">datadir</code> オプションで構成されたデフォルトのデータディレクトリにメインの <code class="filename">.frm</code> ファイルを保持しながら、データファイルおよびインデックスファイルを RAID またはその他の高速ソリューションに移動させるために使用されます。
          </p></li><li class="listitem"><p>
            <span class="bold"><strong>ポート数の制限</strong></span>
          </p><p>
            Windows システムにはクライアント接続のポートがおよそ 4,000 あり、1 つのポート接続が閉じるとそのポートを再度利用できるようになるまで 2 から 4 分かかります。クライアントがサーバーとの接続と切断を高い頻度で繰り返す環境では、閉じたポートが再度利用できるようになる前に、利用できるポートがすべて使用されてしまうことがあります。このようになると、MySQL Server は動作中であっても反応していないように見えます。ポートはマシンで実行されているほかのアプリケーションでも使用されている場合があり、このときには、MySQL に利用できるポート数は少なくなります。
          </p><p>
            この問題の詳細は、<a class="ulink" href="http://support.microsoft.com/default.aspx?scid=kb;en-us;196271" target="_top">http://support.microsoft.com/default.aspx?scid=kb;en-us;196271</a> を参照してください。
          </p></li><li class="listitem"><p>
            <span class="bold"><strong><code class="literal">DATA DIRECTORY</code> および <code class="literal">INDEX DIRECTORY</code></strong></span>
          </p><p>
            <code class="literal">CREATE TABLE</code> の <code class="literal">DATA DIRECTORY</code> オプションは、<a class="xref" href="innodb-storage-engine.html#tablespace-placing" title="14.5.4 テーブルスペースの位置の指定">セクション14.5.4「テーブルスペースの位置の指定」</a>で説明するように、Windows では <code class="literal">InnoDB</code> テーブルに対してのみサポートされます。<code class="literal">MyISAM</code> およびその他のストレージエンジンの場合、<code class="literal">CREATE TABLE</code> の <code class="literal">DATA DIRECTORY</code> および <code class="literal">INDEX DIRECTORY</code> オプションは、Windows と、非機能的 <code class="literal">realpath()</code> 呼び出しを使用するほかのプラットフォームでは無視されます。
          </p></li><li class="listitem"><p>
            <span class="bold"><strong><code class="literal">DROP DATABASE</code></strong></span>
          </p><p>
            別のセッションで使用されているデータベースは削除できません。
          </p></li><li class="listitem"><p>
            <span class="bold"><strong>大文字と小文字を区別しない名前</strong></span>
          </p><p>
            Windows ではファイル名の大文字と小文字は区別されないため、MySQL のデータベース名とテーブル名も Windows では大文字と小文字は区別されません。唯一の制約は、特定のステートメント全体で大文字と小文字を変更せずに、データベース名とテーブル名を指定する必要があるということだけです。<a class="xref" href="language-structure.html#identifier-case-sensitivity" title="9.2.2 識別子の大文字と小文字の区別">セクション9.2.2「識別子の大文字と小文字の区別」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <span class="bold"><strong>ディレクトリ名とファイル名</strong></span>
          </p><p>
            Windows では、MySQL Server は現行の ANSI コードページと互換性のあるディレクトリ名とファイル名のみをサポートします。たとえば、次の日本語のディレクトリ名は欧米のロケール (コードページ 1252) では機能しません。
          </p><pre class="programlisting">
datadir="C:/私たちのプロジェクトのデータ"
</pre><p>
            同じ制限は、<code class="literal">LOAD DATA INFILE</code> のデータファイルパス名など、SQL ステートメントで参照されるディレクトリ名とファイル名にも適用されます。
          </p></li><li class="listitem"><p>
            <span class="bold"><strong><span class="quote">「<span class="quote"><code class="literal">\</code></span>」</span> (パス名の区切り文字)</strong></span>
          </p><p>
            Windows でのパス名のコンポーネントは、<span class="quote">「<span class="quote"><code class="literal">\</code></span>」</span>文字で区切られますが、これは MySQL のエスケープ文字でもあります。<code class="literal">LOAD DATA INFILE</code> または <code class="literal">SELECT ... INTO OUTFILE</code> を使用している場合は、Unix スタイルのファイル名と<span class="quote">「<span class="quote"><code class="literal">/</code></span>」</span>文字を一緒に使用します。
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>LOAD DATA INFILE 'C:/tmp/skr.txt' INTO TABLE skr;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT * INTO OUTFILE 'C:/tmp/skr.txt' FROM skr;</code></strong>
</pre><p>
            または、<span class="quote">「<span class="quote"><code class="literal">\</code></span>」</span>文字を 2 重にする必要があります。
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>LOAD DATA INFILE 'C:\\tmp\\skr.txt' INTO TABLE skr;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT * INTO OUTFILE 'C:\\tmp\\skr.txt' FROM skr;</code></strong>
</pre></li><li class="listitem"><p>
            <span class="bold"><strong>パイプに関する問題</strong></span>
          </p><p>
            パイプは Windows のコマンド行プロンプトからでは確実には機能しません。パイプに <code class="literal">^Z</code> / <code class="literal">CHAR(24)</code> が含まれている場合、Windows はファイルの最後だと勘違いしてプログラムを中止します。
          </p><p>
            これは主に、次のようにバイナリログを適用するときに問題になります。
          </p><pre class="programlisting">
C:\&gt; <strong class="userinput"><code>mysqlbinlog <em class="replaceable"><code>binary_log_file</code></em> | mysql --user=root</code></strong>
</pre><p>
            ログを適用するときに問題が発生し、その原因が <code class="literal">^Z</code> / <code class="literal">CHAR(24)</code> 文字によるものだと考えられる場合は、次の回避法を使用できます。
          </p><pre class="programlisting">
C:\&gt; <strong class="userinput"><code>mysqlbinlog <em class="replaceable"><code>binary_log_file</code></em> --result-file=/tmp/bin.sql</code></strong>
C:\&gt; <strong class="userinput"><code>mysql --user=root --execute "source /tmp/bin.sql"</code></strong>
</pre><p>
            後者のコマンドは、バイナリデータを含む SQL ファイルを確実に読み取るために使用することもできます。
          </p></li></ul></div></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="news.html">前</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="glossary.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">付録 C MySQL リリースノート </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> MySQL 用語集</td></tr></table></div><div class="copyright-footer"></div></body></html>
