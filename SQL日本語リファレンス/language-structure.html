<html lang="ja"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>第 9 章 言語構造</title><link rel="stylesheet" type="text/css" href="mvl.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="MySQL 5.6 リファレンスマニュアル"><link rel="up" href="index.html" title="MySQL 5.6 リファレンスマニュアル"><link rel="prev" href="optimization.html" title="第 8 章 最適化"><link rel="next" href="globalization.html" title="第 10 章 グローバリゼーション">
<script language="javascript" type="text/javascript">
  function addOnload(theFunc)
  {
    var previous = window.onload;
    if (typeof window.onload != 'function')
    {
      window.onload = theFunc;
    }
    else
    {
      window.onload = function()
      {
        previous();
        theFunc();
      }
    }
  }

  addOnload(function()
  {
    var base = new Date(1442918127*1000);
    var now = new Date();
    var diff = ((now-base)/1000)/(24*3600);

    if (diff > 90) {
      var nodes = document.getElementsByClassName('titlepage');
      nodes[0].innerHTML = '<p style="border: 5px #ff0000 solid; padding: 5px; margin 5px">' +
        'This copy of the manual is more than 90 days old. We encourage you to download a ' +
        'new version from <a href="http://dev.mysql.com">dev.mysql.com/doc</a>.</p>' + nodes[0].innerHTML;
    }
  });
</script>
<noscript></noscript>
</head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第 9 章 言語構造</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="optimization.html">前</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="globalization.html">次へ</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="language-structure"></a>第 9 章 言語構造</h1></div></div></div><div class="toc"><p><b>目次</b></p><dl class="toc"><dt><span class="section"><a href="language-structure.html#literals">9.1 リテラル値</a></span></dt><dd><dl><dt><span class="section"><a href="language-structure.html#string-literals">9.1.1 文字列リテラル</a></span></dt><dt><span class="section"><a href="language-structure.html#number-literals">9.1.2 数値リテラル</a></span></dt><dt><span class="section"><a href="language-structure.html#date-and-time-literals">9.1.3 日付リテラルと時間リテラル</a></span></dt><dt><span class="section"><a href="language-structure.html#hexadecimal-literals">9.1.4 16 進数リテラル</a></span></dt><dt><span class="section"><a href="language-structure.html#boolean-literals">9.1.5 boolean リテラル</a></span></dt><dt><span class="section"><a href="language-structure.html#bit-field-literals">9.1.6 ビットフィールドリテラル</a></span></dt><dt><span class="section"><a href="language-structure.html#null-values">9.1.7 NULL 値</a></span></dt></dl></dd><dt><span class="section"><a href="language-structure.html#identifiers">9.2 スキーマオブジェクト名</a></span></dt><dd><dl><dt><span class="section"><a href="language-structure.html#identifier-qualifiers">9.2.1 識別子の修飾子</a></span></dt><dt><span class="section"><a href="language-structure.html#identifier-case-sensitivity">9.2.2 識別子の大文字と小文字の区別</a></span></dt><dt><span class="section"><a href="language-structure.html#identifier-mapping">9.2.3 識別子とファイル名のマッピング</a></span></dt><dt><span class="section"><a href="language-structure.html#function-resolution">9.2.4 関数名の構文解析と解決</a></span></dt></dl></dd><dt><span class="section"><a href="language-structure.html#reserved-words">9.3 予約語</a></span></dt><dt><span class="section"><a href="language-structure.html#user-variables">9.4 ユーザー定義変数</a></span></dt><dt><span class="section"><a href="language-structure.html#expressions">9.5 式の構文</a></span></dt><dt><span class="section"><a href="language-structure.html#comments">9.6 コメントの構文</a></span></dt></dl></div><p>
    この章では、MySQL を使用するときに、<a class="link" href="glossary.html#glos_sql" title="SQL">SQL</a> ステートメントの次の要素を書き込むためのルールについて説明します。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        リテラル値: 文字列や数値など
      </p></li><li class="listitem"><p>
        識別子: データベース名、テーブル名、カラム名など
      </p></li><li class="listitem"><p>
        予約語
      </p></li><li class="listitem"><p>
        ユーザー定義変数とシステム変数
      </p></li><li class="listitem"><p>
        コメント
      </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="literals"></a>9.1 リテラル値</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="language-structure.html#string-literals">9.1.1 文字列リテラル</a></span></dt><dt><span class="section"><a href="language-structure.html#number-literals">9.1.2 数値リテラル</a></span></dt><dt><span class="section"><a href="language-structure.html#date-and-time-literals">9.1.3 日付リテラルと時間リテラル</a></span></dt><dt><span class="section"><a href="language-structure.html#hexadecimal-literals">9.1.4 16 進数リテラル</a></span></dt><dt><span class="section"><a href="language-structure.html#boolean-literals">9.1.5 boolean リテラル</a></span></dt><dt><span class="section"><a href="language-structure.html#bit-field-literals">9.1.6 ビットフィールドリテラル</a></span></dt><dt><span class="section"><a href="language-structure.html#null-values">9.1.7 NULL 値</a></span></dt></dl></div><a class="indexterm" name="idm139979109229728"></a><p>
      このセクションでは、MySQL でリテラル値を記述する方法について説明します。これらには、文字列、数値、16 進値、ブール値、および <code class="literal">NULL</code> が含まれます。また、このセクションでは、MySQL におけるこれらの基本データ型の処理で経験する可能性のある、微妙な違いや<span class="quote">「<span class="quote">なるほど</span>」</span>についても扱います。
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="string-literals"></a>9.1.1 文字列リテラル</h3></div></div></div><a class="indexterm" name="idm139979109224976"></a><a class="indexterm" name="idm139979109222832"></a><a class="indexterm" name="idm139979109220768"></a><a class="indexterm" name="idm139979109218704"></a><p>
        文字列は、単一引用符 (<span class="quote">「<span class="quote"><code class="literal">'</code></span>」</span>) または二重引用符 (<span class="quote">「<span class="quote"><code class="literal">"</code></span>」</span>) で囲まれたバイトまたは文字のシーケンスです。例:
      </p><pre class="programlisting">
'a string'
"another string"
</pre><a class="indexterm" name="idm139979109213744"></a><a class="indexterm" name="idm139979109212272"></a><p>
        隣同士にある引用符付きの文字列は、1 つの文字列に連結されます。次の行は同等です。
      </p><pre class="programlisting">
'a string'
'a' ' ' 'string'
</pre><p>
        <code class="literal">ANSI_QUOTES</code> SQLモードを有効にしている場合は、二重引用符で囲んだ文字列は識別子として解釈されるため、文字列リテラルを囲む引用符には単一引用符だけを使用できます。
      </p><p>
        <em class="firstterm">バイナリ文字列</em>とは、文字セットや照合順序を持たないバイト文字列のことです。<em class="firstterm">非バイナリ文字列</em>とは、文字セットや照合順序を持つ文字列のことです。これらの両方の文字列タイプは、文字列単位の数値に基づいて比較されます。バイナリ文字列の場合、単位はバイトです。非バイナリ文字列の場合、単位は文字であり、マルチバイト文字をサポートする文字セットもあります。文字値の順序は、文字列照合順序の関数です。
      </p><p>
        文字列リテラルでは、オプションとして文字セットイントロデューサと <code class="literal">COLLATE</code> 句を指定できます。
      </p><a class="indexterm" name="idm139979109203536"></a><a class="indexterm" name="idm139979109201344"></a><pre class="programlisting">
[_<em class="replaceable"><code>charset_name</code></em>]'<em class="replaceable"><code>string</code></em>' [COLLATE <em class="replaceable"><code>collation_name</code></em>]
</pre><p>
        例:
      </p><pre class="programlisting">
SELECT _latin1'<em class="replaceable"><code>string</code></em>';
SELECT _latin1'<em class="replaceable"><code>string</code></em>' COLLATE latin1_danish_ci;
</pre><p>
        <code class="literal">N'<em class="replaceable"><code>literal</code></em>'</code> (または <code class="literal">n'<em class="replaceable"><code>literal</code></em>'</code>) を使用すると、各国文字セットの文字列を作成できます。次のステートメントは同等です。
      </p><pre class="programlisting">
SELECT N'some text';
SELECT n'some text';
SELECT _utf8'some text';
</pre><p>
        これらの文字列構文の形式の詳細は、<a class="xref" href="globalization.html#charset-literal" title="10.1.3.5 文字列リテラルの文字セットおよび照合順序">セクション10.1.3.5「文字列リテラルの文字セットおよび照合順序」</a>および<a class="xref" href="globalization.html#charset-national" title="10.1.3.6 各国文字セット">セクション10.1.3.6「各国文字セット」</a>を参照してください。
      </p><p>
        <code class="literal">NO_BACKSLASH_ESCAPES</code> SQL モードが有効になっている場合を除いて、一部のシーケンスが文字列内で特別な意味を持ちます。これらのシーケンスはいずれも、<span class="emphasis"><em>エスケープ文字</em></span>として知られるバックスラッシュ (<span class="quote">「<span class="quote"><code class="literal">\</code></span>」</span>) で始まります。MySQL は、<a class="xref" href="language-structure.html#character-escape-sequences" title="表 9.1 特殊文字エスケープシーケンス">表9.1「特殊文字エスケープシーケンス」</a>に示すエスケープシーケンスを認識します。ほかのすべてのエスケープシーケンスでは、バックスラッシュは無視されます。つまり、エスケープされた文字がエスケープされていないと解釈されます。たとえば、<span class="quote">「<span class="quote"><code class="literal">\x</code></span>」</span>は単なる<span class="quote">「<span class="quote"><code class="literal">x</code></span>」</span>です。これらのシーケンスでは大文字と小文字が区別されます。たとえば、<span class="quote">「<span class="quote"><code class="literal">\b</code></span>」</span>はバックスペースと解釈されますが、<span class="quote">「<span class="quote"><code class="literal">\B</code></span>」</span>は<span class="quote">「<span class="quote"><code class="literal">B</code></span>」</span>と解釈されます。エスケープ処理は <code class="literal">character_set_connection</code> システム変数で指定された文字セットに応じて実行されます。<a class="xref" href="globalization.html#charset-literal" title="10.1.3.5 文字列リテラルの文字セットおよび照合順序">セクション10.1.3.5「文字列リテラルの文字セットおよび照合順序」</a>で説明するとおり、ほかの文字セットを示すイントロデューサが前に置かれている文字列についても同じことがいえます。
      </p><div class="table"><a name="character-escape-sequences"></a><p class="title"><b>表 9.1 特殊文字エスケープシーケンス</b></p><div class="table-contents"><table summary="特殊文字エスケープシーケンス" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">エスケープシーケンス</th><th scope="col">シーケンスが表す文字</th></tr></thead><tbody><tr><td scope="row"><code class="literal">\0</code> <a class="indexterm" name="idm139979109174080"></a> <a class="indexterm" name="idm139979109172736"></a></td><td>ASCII NUL (<code class="literal">0x00</code>) 文字。</td></tr><tr><td scope="row"><code class="literal">\'</code> <a class="indexterm" name="idm139979109169152"></a> <a class="indexterm" name="idm139979109167648"></a></td><td>単一引用符 (<span class="quote">「<span class="quote"><code class="literal">'</code></span>」</span>) 文字。</td></tr><tr><td scope="row"><code class="literal">\"</code> <a class="indexterm" name="idm139979109164000"></a> <a class="indexterm" name="idm139979109162496"></a></td><td>二重引用符 (<span class="quote">「<span class="quote"><code class="literal">"</code></span>」</span>) 文字。</td></tr><tr><td scope="row"><code class="literal">\b</code> <a class="indexterm" name="idm139979109158848"></a> <a class="indexterm" name="idm139979109157344"></a></td><td>バックスペース文字。</td></tr><tr><td scope="row"><code class="literal">\n</code> <a class="indexterm" name="idm139979109154480"></a> <a class="indexterm" name="idm139979109153024"></a> <a class="indexterm" name="idm139979109151680"></a> <a class="indexterm" name="idm139979109150288"></a></td><td>改行 (ラインフィード) 文字。</td></tr><tr><td scope="row"><code class="literal">\r</code> <a class="indexterm" name="idm139979109147408"></a> <a class="indexterm" name="idm139979109145920"></a> <a class="indexterm" name="idm139979109144576"></a></td><td>復帰改行文字。</td></tr><tr><td scope="row"><code class="literal">\t</code> <a class="indexterm" name="idm139979109141744"></a> <a class="indexterm" name="idm139979109140288"></a></td><td>タブ文字。</td></tr><tr><td scope="row"><code class="literal">\Z</code> <a class="indexterm" name="idm139979109137424"></a> <a class="indexterm" name="idm139979109136080"></a></td><td>ASCII 26 (Ctrl+Z)。表に続いて記されている注釈を参照してください。</td></tr><tr><td scope="row"><code class="literal">\\</code> <a class="indexterm" name="idm139979109132992"></a> <a class="indexterm" name="idm139979109131504"></a></td><td>バックスラッシュ (<span class="quote">「<span class="quote"><code class="literal">\</code></span>」</span>) 文字。</td></tr><tr><td scope="row"><code class="literal">\%</code> <a class="indexterm" name="idm139979109127856"></a> <a class="indexterm" name="idm139979109126336"></a></td><td><span class="quote">「<span class="quote"><code class="literal">%</code></span>」</span>文字。表に続いて記されている注釈を参照してください。</td></tr><tr><td scope="row"><code class="literal">\_</code> <a class="indexterm" name="idm139979109122768"></a> <a class="indexterm" name="idm139979109121248"></a></td><td><span class="quote">「<span class="quote"><code class="literal">_</code></span>」</span>文字。表に続いて記されている注釈を参照してください。</td></tr></tbody></table></div></div><br class="table-break"><p>
        ASCII 26 文字を<span class="quote">「<span class="quote"><code class="literal">\Z</code></span>」</span>としてエンコードすると、Windows で ASCII 26 が END-OF-FILE を表すという問題を回避できます。<code class="literal">mysql <em class="replaceable"><code>db_name</code></em> &lt; <em class="replaceable"><code>file_name</code></em></code> を使用しようとすると、ファイル内の ASCII 26 が問題を引き起こします。
      </p><p>
        <span class="quote">「<span class="quote"><code class="literal">\%</code></span>」</span>および<span class="quote">「<span class="quote"><code class="literal">\_</code></span>」</span>シーケンスは、パターンマッチングコンテキストでリテラルインスタンス <span class="quote">「<span class="quote"><code class="literal">%</code></span>」</span> および <span class="quote">「<span class="quote"><code class="literal">_</code></span>」</span> を検索するために使用されます (パターンマッチングコンテキスト以外ではワイルドカード文字として解釈される)。<a class="xref" href="functions.html#string-comparison-functions" title="12.5.1 文字列比較関数">セクション12.5.1「文字列比較関数」</a>内の <code class="literal">LIKE</code> 演算子に関する記述を参照してください。パターンマッチングコンテキスト以外で<span class="quote">「<span class="quote"><code class="literal">\%</code></span>」</span>または<span class="quote">「<span class="quote"><code class="literal">\_</code></span>」</span>を使用すると、<span class="quote">「<span class="quote"><code class="literal">%</code></span>」</span>、<span class="quote">「<span class="quote"><code class="literal">_</code></span>」</span>ではなく、文字列<span class="quote">「<span class="quote"><code class="literal">\%</code></span>」</span>、<span class="quote">「<span class="quote"><code class="literal">\_</code></span>」</span>として評価されます。
      </p><a class="indexterm" name="idm139979109104480"></a><p>
        文字列に引用符を含める方法は、いくつかあります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <span class="quote">「<span class="quote"><code class="literal">'</code></span>」</span>で囲んだ文字列内で<span class="quote">「<span class="quote"><code class="literal">'</code></span>」</span>を使用する場合は、<span class="quote">「<span class="quote"><code class="literal">''</code></span>」</span>と記述します。
          </p></li><li class="listitem"><p>
            <span class="quote">「<span class="quote"><code class="literal">"</code></span>」</span>で囲んだ文字列内で<span class="quote">「<span class="quote"><code class="literal">"</code></span>」</span>を使用する場合は、<span class="quote">「<span class="quote"><code class="literal">""</code></span>」</span>と記述します。
          </p></li><li class="listitem"><p>
            引用符文字の直前にエスケープ文字 (<span class="quote">「<span class="quote"><code class="literal">\</code></span>」</span>) を指定します。
          </p></li><li class="listitem"><p>
            <span class="quote">「<span class="quote"><code class="literal">"</code></span>」</span>で囲んだ文字列内で<span class="quote">「<span class="quote"><code class="literal">'</code></span>」</span>を使用する場合、引用符を 2 つ続けて入力したり、エスケープしたりなどの特別な処理は必要はありません。同様に、<span class="quote">「<span class="quote"><code class="literal">'</code></span>」</span>で囲んだ文字列内で<span class="quote">「<span class="quote"><code class="literal">"</code></span>」</span>を使用する場合も、特別な処理は必要ありません。
          </p></li></ul></div><p>
        次の <code class="literal">SELECT</code> ステートメントは、引用符を使用した場合とエスケープを使用した場合にどのような効果があるかを示しています。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT 'hello', '"hello"', '""hello""', 'hel''lo', '\'hello';</code></strong>
+-------+---------+-----------+--------+--------+
| hello | "hello" | ""hello"" | hel'lo | 'hello |
+-------+---------+-----------+--------+--------+

mysql&gt; <strong class="userinput"><code>SELECT "hello", "'hello'", "''hello''", "hel""lo", "\"hello";</code></strong>
+-------+---------+-----------+--------+--------+
| hello | 'hello' | ''hello'' | hel"lo | "hello |
+-------+---------+-----------+--------+--------+

mysql&gt; <strong class="userinput"><code>SELECT 'This\nIs\nFour\nLines';</code></strong>
+--------------------+
| This
Is
Four
Lines |
+--------------------+

mysql&gt; <strong class="userinput"><code>SELECT 'disappearing\ backslash';</code></strong>
+------------------------+
| disappearing backslash |
+------------------------+
</pre><a class="indexterm" name="idm139979109082656"></a><p>
        文字列カラム (<code class="literal">BLOB</code> カラムなど) にバイナリデータを挿入する場合、ある種の文字はエスケープシーケンスで表現してください。バックスラッシュ (<span class="quote">「<span class="quote"><code class="literal">\</code></span>」</span>) と、文字列を囲む引用符は、エスケープする必要があります。ある種のクライアント環境では、<code class="literal">NUL</code> や Ctrl+Z もエスケープする必要があります。<span class="command"><strong>mysql</strong></span> クライアントは、<code class="literal">NUL</code> 文字がエスケープされていない場合、これを含む引用符付きの文字列を切り捨てます。Ctrl+Z は、エスケープされていない場合、Windows で END-OF-FILE を表すと見なされる可能性があります。これらのそれぞれの文字を表すエスケープシーケンスについては、<a class="xref" href="language-structure.html#character-escape-sequences" title="表 9.1 特殊文字エスケープシーケンス">表9.1「特殊文字エスケープシーケンス」</a>を参照してください。
      </p><a class="indexterm" name="idm139979109074848"></a><a class="indexterm" name="idm139979109073376"></a><a class="indexterm" name="idm139979109071296"></a><a class="indexterm" name="idm139979109070032"></a><a class="indexterm" name="idm139979109068688"></a><p>
        アプリケーションプログラムを書く場合、MySQL Server に送信される SQL ステートメント内で文字列がデータ値として使用される前に、これらの特殊文字を含む可能性のある文字列は適切にエスケープする必要があります。これには次の 2 つの方法があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            特殊文字をエスケープする関数を使用して文字列を処理します。C プログラムでは、C API 関数 <code class="literal">mysql_real_escape_string()</code> を使用して、文字をエスケープできます。<a class="xref" href="connectors-apis.html#mysql-real-escape-string" title="23.8.7.54 mysql_real_escape_string()">セクション23.8.7.54「mysql_real_escape_string()」</a>を参照してください。ほかの SQL ステートメントを構成する SQL ステートメント内では、<code class="literal">QUOTE()</code> 関数を使用できます。Perl DBI インタフェースでは、<code class="literal">quote</code> メソッドを使用して特殊文字を適切なエスケープシーケンスに変換できます。<a class="xref" href="connectors-apis.html#apis-perl" title="23.10 MySQL Perl API">セクション23.10「MySQL Perl API」</a>を参照してください。ほかの言語インタフェースでも同様の機能を利用できることがあります。
          </p></li><li class="listitem"><p>
            特殊文字を明示的にエスケープする方法以外に、多くの MySQL API には、ステートメント文字列に特殊なマーカーを挿入し、ステートメントの発行時にデータ値をそれらのマーカーにバインドできるプレースホルダー機能が備わっています。この場合、値内の特殊文字のエスケープ処理は API によって自動で行われます。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="number-literals"></a>9.1.2 数値リテラル</h3></div></div></div><a class="indexterm" name="idm139979109057344"></a><a class="indexterm" name="idm139979109055872"></a><a class="indexterm" name="idm139979109054512"></a><a class="indexterm" name="idm139979109053168"></a><a class="indexterm" name="idm139979109051136"></a><a class="indexterm" name="idm139979109049792"></a><a class="indexterm" name="idm139979109048448"></a><a class="indexterm" name="idm139979109047104"></a><a class="indexterm" name="idm139979109045872"></a><p>
        数値リテラルには、正確値 (整数と <code class="literal">DECIMAL</code>) リテラルと近似値 (浮動小数点) リテラルが含まれます。
      </p><p>
        整数は数字の列として表現されます。数値には小数点として<span class="quote">「<span class="quote"><code class="literal">.</code></span>」</span>が含まれる場合があります。数値には、負の値または正の値を示すためにそれぞれ<span class="quote">「<span class="quote"><code class="literal">-</code></span>」</span>または<span class="quote">「<span class="quote"><code class="literal">+</code></span>」</span>が直前に付けられる場合があります。仮数と指数による指数表現で表される数値は、近似値の数値です。
      </p><p>
        正確値の数値リテラルには、整数部または小数部、あるいはその両方が含まれています。これらには符号を付けることができます。例: <code class="literal">1</code>、<code class="literal">.2</code>、<code class="literal">3.4</code>、<code class="literal">-5</code>、<code class="literal">-6.78</code>、<code class="literal">+9.10</code>。
      </p><p>
        近似値の数値リテラルは仮数と指数による指数表現で表されます。一方または両方の部分に符号を付けることができます。例: <code class="literal">1.2E3</code>、<code class="literal">1.2E-3</code>、<code class="literal">-1.2E3</code>、<code class="literal">-1.2E-3</code>。
      </p><p>
        2 つの数値が同じように見えても、別々に扱われることがあります。たとえば、<code class="literal">2.34</code> は (固定小数点の) 正確値ですが、<code class="literal">2.34E0</code> は (浮動小数点の) 近似値です。
      </p><p>
        <code class="literal">DECIMAL</code> データ型は固定小数点型で、計算は正確です。MySQL では、<code class="literal">DECIMAL</code> 型には、<code class="literal">NUMERIC</code>、<code class="literal">DEC</code>、<code class="literal">FIXED</code> という複数のシノニムがあります。整数型も正確値型です。正確値計算の詳細は、<a class="xref" href="functions.html#precision-math" title="12.20 高精度計算">セクション12.20「高精度計算」</a>を参照してください。
      </p><p>
        <code class="literal">FLOAT</code> データ型および <code class="literal">DOUBLE</code> データ型は浮動小数点型で、計算によって近似値が得られます。MySQL では、<code class="literal">FLOAT</code> または <code class="literal">DOUBLE</code> のシノニムである型は <code class="literal">DOUBLE PRECISION</code> および <code class="literal">REAL</code> です。
      </p><p>
        浮動小数点のコンテキストで整数を使用することもできます。この場合、整数は同等の浮動小数点数として解釈されます。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="date-and-time-literals"></a>9.1.3 日付リテラルと時間リテラル</h3></div></div></div><a class="indexterm" name="idm139979109012720"></a><a class="indexterm" name="idm139979109011296"></a><p>
        日付値と時間値は、値の正確型とほかの要因に応じて、引用符付きの文字列や数値など、複数の形式で表現できます。たとえば、MySQL が日付を予想するコンテキストでは、<code class="literal">'2015-07-21'</code>、<code class="literal">'20150721'</code>、<code class="literal">20150721</code> のいずれも日付と解釈します。
      </p><p>
        このセクションでは日付リテラルと時間リテラルの許容される形式について説明します。許可されている値の範囲など、時間データ型の詳細は、次のセクションを参照してください。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <a class="xref" href="data-types.html#date-and-time-type-overview" title="11.1.2 日付と時間型の概要">セクション11.1.2「日付と時間型の概要」</a>
          </p></li><li class="listitem"><p>
            <a class="xref" href="data-types.html#date-and-time-types" title="11.3 日付と時間型">セクション11.3「日付と時間型」</a>
          </p></li></ul></div><p><a name="date-and-time-standard-sql-literals"></a><b>標準 SQL と ODBC の日付および時間リテラル </b>
          標準 SQL では、型キーワードおよび文字列を使用して、時間リテラルを指定できます。キーワードと文字列の間の空白はオプションです。
        </p><pre class="programlisting">
DATE '<em class="replaceable"><code>str</code></em>'
TIME '<em class="replaceable"><code>str</code></em>'
TIMESTAMP '<em class="replaceable"><code>str</code></em>'
</pre><p>
        MySQL は、これらの構造と、対応する ODBC 構文も認識します。
      </p><pre class="programlisting">
{ d '<em class="replaceable"><code>str</code></em>' }
{ t '<em class="replaceable"><code>str</code></em>' }
{ ts '<em class="replaceable"><code>str</code></em>' }
</pre><p>
        MySQL 5.6.4 より前では、MySQL は型キーワードを無視し、前述の各構造は、型が <code class="literal">VARCHAR</code> の文字列値 <code class="literal">'<em class="replaceable"><code>str</code></em>'</code> を生成します。
      </p><p>
        5.6.4 以降、MySQL は型キーワードを使用し、これらの構造はそれぞれ、後続の小数秒部分が指定されている場合はこの部分を含む <code class="literal">DATE</code>、<code class="literal">TIME</code>、および <code class="literal">DATETIME</code> の値を生成します。<code class="literal">DATETIME</code> には、標準 SQL の <code class="literal">TIMESTAMP</code> 型により密接に対応する範囲があり、ここには <code class="literal">0001</code> から <code class="literal">9999</code> の年範囲が含まれるので、<code class="literal">TIMESTAMP</code> 構文は、MySQL で <code class="literal">DATETIME</code> 値を生成します。(MySQL の <code class="literal">TIMESTAMP</code> 年範囲は <code class="literal">1970</code> から <code class="literal">2038</code> です。)
      </p><p><a name="date-and-time-string-numeric-literals"></a><b>日時コンテキストでの文字列リテラルと数値リテラル </b>
          MySQL は次の形式で <code class="literal">DATE</code> 値を認識します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">'YYYY-MM-DD'</code> または <code class="literal">'YY-MM-DD'</code> 形式の文字列として。<span class="quote">「<span class="quote">緩やかな</span>」</span>構文が許可されます。どの句読点文字でも、日付部分間の区切り文字として使用できます。たとえば、<code class="literal">'2012-12-31'</code>、<code class="literal">'2012/12/31'</code>、<code class="literal">'2012^12^31'</code>、および <code class="literal">'2012@12@31'</code> は同等です。
          </p></li><li class="listitem"><p>
            <code class="literal">'YYYYMMDD'</code> または <code class="literal">'YYMMDD'</code> 形式の、区切り文字がない文字列 (日付として適切なもの) として。たとえば、<code class="literal">'20070523'</code> と <code class="literal">'070523'</code> は <code class="literal">'2007-05-23'</code> として解釈されますが、<code class="literal">'071332'</code> は正しくないため (月と日の部分が不適切)、<code class="literal">'0000-00-00'</code> になります。
          </p></li><li class="listitem"><p>
            <code class="literal">YYYYMMDD</code> または <code class="literal">YYMMDD</code> 形式の数値 (日付として適切なもの) として。たとえば、<code class="literal">19830905</code> と <code class="literal">830905</code> は <code class="literal">'1983-09-05'</code> として解釈されます。
          </p></li></ul></div><p>
        MySQL は次の形式で <code class="literal">DATETIME</code> および <code class="literal">TIMESTAMP</code> 値を認識します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">'YYYY-MM-DD HH:MM:SS'</code> または <code class="literal">'YY-MM-DD HH:MM:SS'</code> 形式の文字列として。<span class="quote">「<span class="quote">緩やかな</span>」</span>構文はここでも許可されます。どの句読点文字でも、日付部分または時間部分の間の区切り文字として使用できます。たとえば、<code class="literal">'2012-12-31 11:30:45'</code>、<code class="literal">'2012^12^31 11+30+45'</code>、<code class="literal">'2012/12/31 11*30*45'</code>、および <code class="literal">'2012@12@31 11^30^45'</code> は同等です。
          </p><p>
            日付および時間の部分と小数秒部分との間の区切り文字として認識される唯一の文字が小数点です。
          </p><p>
            日付部分と時間部分は、空白ではなく <code class="literal">T</code> で区切ることもできます。たとえば、<code class="literal">'2012-12-31 11:30:45'</code> と <code class="literal">'2012-12-31T11:30:45'</code> は同等です。
          </p></li><li class="listitem"><p>
            <code class="literal">'YYYYMMDDHHMMSS'</code> または <code class="literal">'YYMMDDHHMMSS'</code> 形式の、区切り文字がない文字列 (日付として適切なもの) として。たとえば、<code class="literal">'20070523091528'</code> と <code class="literal">'070523091528'</code> は <code class="literal">'2007-05-23 09:15:28'</code> として解釈されますが、<code class="literal">'071122129015'</code> は正しくないため (分の部分が不適切)、<code class="literal">'0000-00-00 00:00:00'</code> になります。
          </p></li><li class="listitem"><p>
            <code class="literal">YYYYMMDDHHMMSS</code> または <code class="literal">YYMMDDHHMMSS</code> 形式の数値 (日付として適切なもの) として。たとえば、<code class="literal">19830905132800</code> と <code class="literal">830905132800</code> は <code class="literal">'1983-09-05 13:28:00'</code> として解釈されます。
          </p></li></ul></div><p>
        <code class="literal">DATETIME</code> または <code class="literal">TIMESTAMP</code> 値には、マイクロ秒 (6 桁) までの精度の後続の小数秒部分を含めることができます。小数部は、常に時間の残りの部分から小数点で区分する必要があります。これ以外の小数秒区切り文字は認識されません。MySQL の小数秒のサポートの詳細は、<a class="xref" href="data-types.html#fractional-seconds" title="11.3.6 時間値での小数秒">セクション11.3.6「時間値での小数秒」</a>を参照してください。
      </p><p>
        2 桁の年を含む日付の値は、世紀が不明なためあいまいです。MySQL は次のルールを使用して 2 桁の年の値を解釈します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">70-99</code> の範囲の値は <code class="literal">1970-1999</code> に変換されます。
          </p></li><li class="listitem"><p>
            <code class="literal">00-69</code> の範囲の値は <code class="literal">2000-2069</code> に変換されます。
          </p></li></ul></div><p>
        <a class="xref" href="data-types.html#two-digit-years" title="11.3.8 日付での 2 桁の年">セクション11.3.8「日付での 2 桁の年」</a>も参照してください。
      </p><p>
        日付部分の区切り文字を含む文字列として指定される値の場合、<code class="literal">10</code> 未満の月または日の値に 2 桁を指定する必要はありません。<code class="literal">'2015-6-9'</code> は <code class="literal">'2015-06-09'</code> と同じです。同様に、時間部分の区切り文字を含む文字列として指定される値の場合、<code class="literal">10</code> 未満の時、分、または秒の値に 2 桁を指定する必要はありません。<code class="literal">'2015-10-30 1:2:3'</code> は <code class="literal">'2015-10-30 01:02:03'</code> と同じです。
      </p><p>
        数値として指定する値は、6、8、12、14 のいずれかの桁数にするようにしてください。数値を 8 桁または 14 桁の長さにすると、<code class="literal">YYYYMMDD</code> または <code class="literal">YYYYMMDDHHMMSS</code> 形式であり、最初の 4 桁が年であると想定されます。数値を 6 桁または 12 桁の長さにすると、<code class="literal">YYMMDD</code> または <code class="literal">YYMMDDHHMMSS</code> 形式であり、最初の 2 桁が年であると想定されます。これらの長さではない数字は、いちばん近い長さまで先行ゼロで埋められているかのように解釈されます。
      </p><a class="indexterm" name="idm139979108918128"></a><a class="indexterm" name="idm139979108916640"></a><p>
        区切り文字がない文字列として指定された値は、その長さに従って解釈されます。8 または 14 文字の長さの文字列の場合、年は最初の 4 文字で表されていると見なされます。そうでなければ、年は最初の 2 文字で表されていると見なされます。文字列は、その文字列に存在するだけの部分について、左から右に順番に、年、月、日、時、分、秒として解釈されます。これは、6 文字より少ない文字列は利用してはいけないということを意味します。たとえば、1999 年 3 月を表すと考えて <code class="literal">'9903'</code> を指定しても、MySQL は<span class="quote">「<span class="quote">ゼロ</span>」</span>日付値に変換します。これは、年および月の値は <code class="literal">99</code> と <code class="literal">03</code> であるけれども、日の部分が完全に欠落しているために起こります。ただし、明示的に値ゼロを指定することによって、欠落している月や日の部分を表すことができます。たとえば、<code class="literal">'1999-03-00'</code> の値を挿入するには、<code class="literal">'990300'</code> を使用します。
      </p><p>
        MySQL は次の形式で <code class="literal">TIME</code> 値を認識します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">'D HH:MM:SS'</code> 形式の文字列として。<code class="literal">'HH:MM:SS'</code>、<code class="literal">'HH:MM'</code>、<code class="literal">'D HH:MM'</code>、<code class="literal">'D HH'</code>、<code class="literal">'SS'</code> のいずれかの<span class="quote">「<span class="quote">緩やかな</span>」</span>構文も使用できます。この場合、<code class="literal">D</code> は日を表し、0 から 34 の値を指定できます。
          </p></li><li class="listitem"><p>
            <code class="literal">'HHMMSS'</code> 形式の区切り文字がない文字列 (時間として適切なもの) として。たとえば、<code class="literal">'101112'</code> は <code class="literal">'10:11:12'</code> として認識されますが、<code class="literal">'109712'</code> は正しくないため (分の部分が不適切)、<code class="literal">'00:00:00'</code> になります。
          </p></li><li class="listitem"><p>
            <code class="literal">HHMMSS</code> 形式の数値 (時間として適切なもの) として。たとえば、<code class="literal">101112</code> は <code class="literal">'10:11:12'</code> として認識されます。<code class="literal">SS</code>、<code class="literal">MMSS</code>、<code class="literal">HHMMSS</code> の代替形式も認識されます。
          </p></li></ul></div><p>
        後続の小数秒部分は、<code class="literal">'D HH:MM:SS.fraction'</code>、<code class="literal">'HH:MM:SS.fraction'</code>、<code class="literal">'HHMMSS.fraction'</code>、および <code class="literal">HHMMSS.fraction</code> の時間形式で認識されます。ここで、<code class="literal">fraction</code> はマイクロ秒 (6 桁) までの精度で表される小数部分です。小数部は、常に時間の残りの部分から小数点で区分する必要があります。これ以外の小数秒区切り文字は認識されません。MySQL の小数秒のサポートの詳細は、<a class="xref" href="data-types.html#fractional-seconds" title="11.3.6 時間値での小数秒">セクション11.3.6「時間値での小数秒」</a>を参照してください。
      </p><p>
        時間部分の区切り文字を含む文字列として指定される <code class="literal">TIME</code> 値の場合、<code class="literal">10</code> 未満の時、分、秒の値に 2 桁を指定する必要はありません。<code class="literal">'8:3:2'</code> は <code class="literal">'08:03:02'</code> と同じです。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="hexadecimal-literals"></a>9.1.4 16 進数リテラル</h3></div></div></div><a class="indexterm" name="idm139979108879232"></a><p>
        MySQL では、<code class="literal">X'<em class="replaceable"><code>val</code></em>'</code>、<code class="literal">x'<em class="replaceable"><code>val</code></em>'</code>、または <code class="literal">0x<em class="replaceable"><code>val</code></em></code> 形式を使って記述された 16 進値をサポートしています。この場合、<em class="replaceable"><code>val</code></em> には 16 進数字 (<code class="literal">0..9</code>、<code class="literal">A..F</code>) を指定します。数字の大文字と小文字は区別されません。<code class="literal">X'<em class="replaceable"><code>val</code></em>'</code> または <code class="literal">x'<em class="replaceable"><code>val</code></em>'</code> 形式で値を記述する場合、<em class="replaceable"><code>val</code></em> には偶数の桁を入れる必要があります。<code class="literal">0x<em class="replaceable"><code>val</code></em></code> 構文を使用して値を記述する場合、奇数の桁が含まれる値は、追加の先行 <code class="literal">0</code> が付いているものとして扱われます。たとえば、<code class="literal">0x0a</code> と <code class="literal">0xaaa</code> は、<code class="literal">0x0a</code> と <code class="literal">0x0aaa</code> として解釈されます。
      </p><p>
        数値のコンテキストでは、16 進値は整数 (64 ビット精度) のように機能します。文字列のコンテキストでは、16 進値はバイナリ文字列のように機能します。この場合、16 進数の各ペアが 1 文字に変換されます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT X'4D7953514C';</code></strong>
        -&gt; 'MySQL'
mysql&gt; <strong class="userinput"><code>SELECT 0x0a+0;</code></strong>
        -&gt; 10
mysql&gt; <strong class="userinput"><code>SELECT 0x5061756c;</code></strong>
        -&gt; 'Paul'
</pre><p>
        16 進値のデフォルトのデータ型は文字列です。この値が数値として扱われるようにしたい場合は、<code class="literal">CAST(... AS UNSIGNED)</code> を使用できます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT 0x41, CAST(0x41 AS UNSIGNED);</code></strong>
        -&gt; 'A', 65
</pre><p>
        <code class="literal">X'<em class="replaceable"><code>hexstring</code></em>'</code> 構文は標準 SQL に基づいています。<code class="literal">0x</code> 構文は ODBC に基づいています。16 進文字列は、<code class="literal">BLOB</code> カラムの値を提供するために、ODBC によって使用されることがよくあります。
      </p><p>
        文字列または数値を 16 進形式の文字列に変換するには、<code class="literal">HEX()</code> 関数を使用できます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT HEX('cat');</code></strong>
        -&gt; '636174'
mysql&gt; <strong class="userinput"><code>SELECT 0x636174;</code></strong>
        -&gt; 'cat'
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="boolean-literals"></a>9.1.5 boolean リテラル</h3></div></div></div><a class="indexterm" name="idm139979108848656"></a><a class="indexterm" name="idm139979108847344"></a><p>
        <code class="literal">TRUE</code> および <code class="literal">FALSE</code> 定数はそれぞれ <code class="literal">1</code> と <code class="literal">0</code> として評価されます。定数名は大文字でも小文字でも記述できます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT TRUE, true, FALSE, false;</code></strong>
        -&gt; 1, 1, 0, 0
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="bit-field-literals"></a>9.1.6 ビットフィールドリテラル</h3></div></div></div><p>
        ビットフィールド値は、<code class="literal">b'<em class="replaceable"><code>value</code></em>'</code> または <code class="literal">0b<em class="replaceable"><code>value</code></em></code> 表記を使用して記述できます。<em class="replaceable"><code>value</code></em> は、0 と 1 で書かれた 2 進値です。
      </p><p>
        ビットフィールド表記は <code class="literal">BIT</code> カラムに割り当てる値を指定するのに便利です。
      </p><pre class="programlisting">

mysql&gt; <strong class="userinput"><code>CREATE TABLE t (b BIT(8));</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t SET b = b'11111111';</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t SET b = b'1010';</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t SET b = b'0101';</code></strong>
</pre><p>
        ビット値は 2 進値として返されます。それらを出力可能な形式で表示するには、0 を追加するか、<code class="literal">BIN()</code> などの変換関数を使用します。変換された値には上位の 0 ビットは表示されません。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT b+0, BIN(b+0), OCT(b+0), HEX(b+0) FROM t;</code></strong>
+------+----------+----------+----------+
| b+0  | BIN(b+0) | OCT(b+0) | HEX(b+0) |
+------+----------+----------+----------+
|  255 | 11111111 | 377      | FF       |
|   10 | 1010     | 12       | A        |
|    5 | 101      | 5        | 5        |
+------+----------+----------+----------+
</pre><p>
        ユーザー変数に割り当てられたビット値は、バイナリ文字列として扱われます。ビット値を数値としてユーザー変数に割り当てるには、<code class="literal">CAST()</code> または <code class="literal">+0</code> を使用します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET @v1 = 0b1000001;</code></strong>
mysql&gt; <strong class="userinput"><code>SET @v2 = CAST(0b1000001 AS UNSIGNED), @v3 = 0b1000001+0;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT @v1, @v2, @v3;</code></strong>
+------+------+------+
| @v1  | @v2  | @v3  |
+------+------+------+
| A    |   65 |   65 |
+------+------+------+
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="null-values"></a>9.1.7 NULL 値</h3></div></div></div><a class="indexterm" name="idm139979108818560"></a><p>
        <code class="literal">NULL</code> 値は<span class="quote">「<span class="quote">データなし</span>」</span>を意味します。<code class="literal">NULL</code> は大文字と小文字のどちらでも記述できます。シノニムは <code class="literal">\N</code> (大文字と小文字を区別) です。
      </p><p>
        <code class="literal">LOAD DATA INFILE</code> または <code class="literal">SELECT ... INTO OUTFILE</code> で実行されるテキストファイルのインポートまたはエクスポート操作の場合、<code class="literal">NULL</code> は <code class="literal">\N</code> シーケンスで表現されます。<a class="xref" href="sql-syntax.html#load-data" title="13.2.6 LOAD DATA INFILE 構文">セクション13.2.6「LOAD DATA INFILE 構文」</a>を参照してください。
      </p><p>
        <code class="literal">NULL</code> 値は、数値型での <code class="literal">0</code> や文字列型での空文字列などの値とは異なります。詳細は、<a class="xref" href="error-handling.html#problems-with-null" title="B.5.5.3 NULL 値に関する問題">セクションB.5.5.3「NULL 値に関する問題」</a>を参照してください。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="identifiers"></a>9.2 スキーマオブジェクト名</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="language-structure.html#identifier-qualifiers">9.2.1 識別子の修飾子</a></span></dt><dt><span class="section"><a href="language-structure.html#identifier-case-sensitivity">9.2.2 識別子の大文字と小文字の区別</a></span></dt><dt><span class="section"><a href="language-structure.html#identifier-mapping">9.2.3 識別子とファイル名のマッピング</a></span></dt><dt><span class="section"><a href="language-structure.html#function-resolution">9.2.4 関数名の構文解析と解決</a></span></dt></dl></div><a class="indexterm" name="idm139979108804704"></a><a class="indexterm" name="idm139979108803280"></a><a class="indexterm" name="idm139979108801936"></a><a class="indexterm" name="idm139979108800592"></a><a class="indexterm" name="idm139979108798560"></a><a class="indexterm" name="idm139979108796528"></a><a class="indexterm" name="idm139979108794496"></a><a class="indexterm" name="idm139979108792464"></a><p>
      データベース、テーブル、インデックス、カラム、エイリアス、ビュー、ストアドプロシージャー、パーティション、テーブルスペース、その他のオブジェクト名など、MySQL 内のある種のオブジェクトは、識別子として知られています。このセクションでは、MySQL で識別子について許可されている構文について説明します。<a class="xref" href="language-structure.html#identifier-case-sensitivity" title="9.2.2 識別子の大文字と小文字の区別">セクション9.2.2「識別子の大文字と小文字の区別」</a>では、どのタイプの識別子がどの条件下で大文字と小文字を区別するかについて説明します。
    </p><a class="indexterm" name="idm139979108788672"></a><a class="indexterm" name="idm139979108786528"></a><a class="indexterm" name="idm139979108785200"></a><a class="indexterm" name="idm139979108784032"></a><p>
      識別子は引用符で囲むことも囲まないこともあります。識別子に特殊文字が含まれている場合、または識別子が予約語である場合、その識別子を参照するときは<span class="emphasis"><em>必ず</em></span>引用符で囲む必要があります。(例外: 修飾名内でピリオドのあとに続く予約語は識別子である必要があるため、引用符で囲む必要はありません。)予約語は<a class="xref" href="language-structure.html#reserved-words" title="9.3 予約語">セクション9.3「予約語」</a>に記載されています。
    </p><p>
      識別子は内部で Unicode に変換されます。以下の文字を含めることができます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          引用符で囲まれていない識別子で許可される文字。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              ASCII: [0-9,a-z,A-Z$_] (基本的なラテン文字、0-9 の数字、ドル、下線)
            </p></li><li class="listitem"><p>
              拡張: U+0080 ..U+FFFF
            </p></li></ul></div></li><li class="listitem"><p>
          引用符で囲まれている識別子で許可される文字には、U+0000 を除き、完全な Unicode Basic Multilingual Plane (BMP) が含まれます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              ASCII: U+0001 ..U+007F
            </p></li><li class="listitem"><p>
              拡張: U+0080 ..U+FFFF
            </p></li></ul></div></li><li class="listitem"><p>
          ASCII NUL (U+0000) と補助文字 (U+10000 以上) は、引用符で囲まれた識別子または引用符で囲まれていない識別子では許可されません。
        </p></li><li class="listitem"><p>
          識別子は数字で始めることができますが、引用符で囲まれていないかぎり、数字のみで構成することはできません。
        </p></li><li class="listitem"><p>
          データベース名、テーブル名、およびカラム名は、空白文字で終えることはできません。
        </p></li></ul></div><p>
      識別子引用符文字は逆引用符 (<span class="quote">「<span class="quote"><code class="literal">`</code></span>」</span>) です。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT * FROM `select` WHERE `select`.id &gt; 100;</code></strong>
</pre><p>
      <code class="literal">ANSI_QUOTES</code> SQL モードが有効になっている場合、二重引用符内で識別子を引用符で囲むことも許可されています。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE "test" (col INT);</code></strong>
ERROR 1064: You have an error in your SQL syntax...
mysql&gt; <strong class="userinput"><code>SET sql_mode='ANSI_QUOTES';</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE TABLE "test" (col INT);</code></strong>
Query OK, 0 rows affected (0.00 sec)
</pre><p>
      <code class="literal">ANSI_QUOTES</code> モードでは、サーバーは二重引用符で囲まれた文字列を識別子として解釈します。この結果、このモードが有効になっているときには、文字列リテラルは単一引用符で囲む必要があります。二重引用符で囲むことはできません。サーバー SQL モードは、<a class="xref" href="server-administration.html#sql-mode" title="5.1.7 サーバー SQL モード">セクション5.1.7「サーバー SQL モード」</a>で説明しているように制御されます。
    </p><p>
      識別子が引用符で囲まれていれば、識別子引用符文字を識別子内に含めることができます。識別子内に含める文字が識別子自体を囲むのに使用している引用符と同じ場合、文字を二重にする必要があります。次のステートメントは、<code class="literal">c"d</code> という名前のカラムを含んだ <code class="literal">a`b</code> という名前のテーブルを作成します。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE `a``b` (`c"d` INT);</code></strong>
</pre><a class="indexterm" name="idm139979108755552"></a><a class="indexterm" name="idm139979108753360"></a><p>
      クエリーの選択リストで、引用したカラムエイリアスを指定するには、識別子または文字列引用文字を使用します。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT 1 AS `one`, 2 AS 'two';</code></strong>
+-----+-----+
| one | two |
+-----+-----+
|   1 |   2 |
+-----+-----+
</pre><p>
      ステートメント内のどこに指定する場合でも、エイリアスへの引用した参照には、識別子引用符を使用する必要があります。そうしないと、参照は文字列リテラルとして扱われます。
    </p><p>
      <code class="literal"><em class="replaceable"><code>M</code></em>e</code> や <code class="literal"><em class="replaceable"><code>M</code></em>e<em class="replaceable"><code>N</code></em></code> (この場合の <em class="replaceable"><code>M</code></em> と <em class="replaceable"><code>N</code></em> は整数) で始まる名前を使用しないことが推奨されています。たとえば、<code class="literal">1e</code> を識別子として使用しないでください。これは、<code class="literal">1e+3</code> などの式があいまいになるためです。コンテキストに応じて、式 <code class="literal">1e + 3</code> として、または数値 <code class="literal">1e+3</code> として解釈される場合があります。
    </p><p>
      テーブルネーム名を作成するのに <code class="literal">MD5()</code> を使用する場合は注意が必要です。なぜなら、これは、前述のような不正な形式やあいまいな形式で名前を生成する可能性があるからです。
    </p><p>
      ユーザー変数は、識別子または識別子の一部として SQL ステートメントの中で直接使用することはできません。回避策の詳細と例については、<a class="xref" href="language-structure.html#user-variables" title="9.4 ユーザー定義変数">セクション9.4「ユーザー定義変数」</a>を参照してください。
    </p><a class="indexterm" name="idm139979108737968"></a><p>
      <a class="xref" href="language-structure.html#identifier-mapping" title="9.2.3 識別子とファイル名のマッピング">セクション9.2.3「識別子とファイル名のマッピング」</a>で説明しているように、データベース名とテーブル名内の特殊文字は、対応するファイルシステム名でエンコードされます。特殊文字を含む古いバージョンの MySQL のデータベースまたはテーブルがあり、それの基になるディレクトリ名またはファイル名が新しいエンコーディングを使用するように更新されていない場合、サーバーはそれらの名前に <code class="literal">#mysql50#</code> というプリフィクスを付けて表示します。このような名前の参照、または新しいエンコーディングへの変換の詳細は、そのセクションを参照してください。
    </p><p>
      次の表には、識別子のタイプごとの最大の長さが示されています。
    </p><div class="informaltable"><table summary="次の表には、MySQL オブジェクト識別子のタイプごとの最大の長さが示されています。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">識別子</th><th scope="col">最大の長さ (文字)</th></tr></thead><tbody><tr><td scope="row">Database</td><td>64 (<code class="literal">NDB</code> ストレージエンジン: 63)</td></tr><tr><td scope="row">テーブル</td><td>64 (<code class="literal">NDB</code> ストレージエンジン: 63)</td></tr><tr><td scope="row">カラム</td><td>64</td></tr><tr><td scope="row">インデックス</td><td>64</td></tr><tr><td scope="row">制約</td><td>64</td></tr><tr><td scope="row">ストアドプログラム</td><td>64</td></tr><tr><td scope="row">ビュー</td><td>64</td></tr><tr><td scope="row">テーブルスペース</td><td>64</td></tr><tr><td scope="row">サーバー</td><td>64</td></tr><tr><td scope="row">ログファイルグループ</td><td>64</td></tr><tr><td scope="row">エイリアス</td><td>256 (表のあとの例外を参照してください)</td></tr><tr><td scope="row">複合ステートメントラベル</td><td>16</td></tr></tbody></table></div><p>
      <code class="literal">CREATE VIEW</code> ステートメント内のカラム名に対するエイリアスは、(256 文字の最大のエイリアス長ではなく) 64 文字の最大のカラム長に対してチェックされます。
    </p><p>
      識別子は Unicode (UTF-8) を使用して格納されます。これは、<code class="filename">.frm</code> ファイル内に格納されたテーブル定義の識別子と、<code class="literal">mysql</code> データベース内の付与テーブルに格納された識別子に適用されます。付与テーブル内の識別子文字列カラムのサイズは文字数で測定されます。これらのカラムに格納されている値に許可されている文字数を減らすことなく、マルチバイト文字を使用できます。これは MySQL 4.1 より前には当てはまりません。前述のように、許容されている Unicode 文字は、Basic Multilingual Plane (BMP) の文字です。補助文字は許可されません。
    </p><p>
      MySQL Cluster では、データベースおよびテーブルの名前に 63 文字の最大長を課します。<a class="xref" href="mysql-cluster.html#mysql-cluster-limitations-database-objects" title="18.1.6.5 MySQL Cluster 内のデータベースオブジェクトに関する制限">セクション18.1.6.5「MySQL Cluster 内のデータベースオブジェクトに関する制限」</a>を参照してください。
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="identifier-qualifiers"></a>9.2.1 識別子の修飾子</h3></div></div></div><p>
        MySQL では、単一の識別子または複数の識別子から構成される名前を使用できます。複数部分名のコンポーネントは、ピリオド (<span class="quote">「<span class="quote"><code class="literal">.</code></span>」</span>) 文字で区切る必要があります。複数部分名の最初の部分は、最後の識別子が解釈されるコンテキストに影響を与える修飾子として機能します。
      </p><p>
        MySQL では、次の形式を使用してテーブル内のカラムを参照できます。
      </p><div class="informaltable"><table summary="この表には、テーブル内のカラムを参照するために使用できる形式 (カラム参照) が一覧表示されています。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">カラム参照</th><th scope="col">意味</th></tr></thead><tbody><tr><td scope="row"><em class="replaceable"><code>col_name</code></em></td><td>ステートメントで使用されるテーブルのカラム <em class="replaceable"><code>col_name</code></em> には、その名前のカラムが含まれています。</td></tr><tr><td scope="row"><em class="replaceable"><code>tbl_name.col_name</code></em></td><td>デフォルトデータベースのテーブル <em class="replaceable"><code>tbl_name</code></em> 内のカラム <em class="replaceable"><code>col_name</code></em>。</td></tr><tr><td scope="row"><em class="replaceable"><code>db_name.tbl_name.col_name</code></em></td><td>データベース <em class="replaceable"><code>db_name</code></em> のテーブル <em class="replaceable"><code>tbl_name</code></em> 内のカラム <em class="replaceable"><code>col_name</code></em>。</td></tr></tbody></table></div><p>
        修飾子文字は別個のトークンであり、関連付けられた識別子と隣接する必要はありません。たとえば、<em class="replaceable"><code>tbl_name.col_name</code></em> と <em class="replaceable"><code>tbl_name . col_name</code></em> は同等です。
      </p><p>
        複数部分名のコンポーネントを引用符で囲む必要がある場合、名前全体を引用符で囲むのではなく、各コンポーネントを個別に引用符で囲んでください。たとえば、<code class="literal">`my-table.my-column`</code> ではなく、<code class="literal">`my-table`.`my-column`</code> と記述します。
      </p><p>
        修飾名内でピリオドのあとに続く予約語は識別子である必要があるため、そのコンテキストでは引用符で囲む必要はありません。
      </p><p>
        参照があいまいでないかぎり、ステートメント内のカラム参照の前に <em class="replaceable"><code>tbl_name</code></em> や <em class="replaceable"><code>db_name.tbl_name</code></em> プリフィクスを付ける必要はありません。たとえば、テーブル <code class="literal">t1</code> と <code class="literal">t2</code> のそれぞれにカラム <code class="literal">c</code> があり、<code class="literal">t1</code> と <code class="literal">t2</code> の両方を使用する <code class="literal">SELECT</code> ステートメントで <code class="literal">c</code> を取得するとします。この場合、<code class="literal">c</code> はステートメント内で使用されるテーブルの中で一意でないため、あいまいになります。これを <code class="literal">t1.c</code> または <code class="literal">t2.c</code> としてテーブル名で修飾し、どちらのテーブルを指しているかを示す必要があります。同様に、同じステートメント内のデータベース <code class="literal">db1</code> のテーブル <code class="literal">t</code> とデータベース <code class="literal">db2</code> のテーブル <code class="literal">t</code> から取得するには、それぞれのテーブルのカラムを <code class="literal">db1.t.<em class="replaceable"><code>col_name</code></em></code> と <code class="literal">db2.t.<em class="replaceable"><code>col_name</code></em></code> として参照する必要があります。
      </p><a class="indexterm" name="idm139979108670224"></a><a class="indexterm" name="idm139979108668752"></a><p>
        構文 <code class="literal"><em class="replaceable"><code>.tbl_name</code></em></code> は、デフォルトデータベースのテーブル <em class="replaceable"><code>tbl_name</code></em> を意味します。一部の ODBC プログラムではテーブル名の先頭に<span class="quote">「<span class="quote"><code class="literal">.</code></span>」</span>文字が付けられるため、ODBC 互換性を確保するためにこの構文が認められています。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="identifier-case-sensitivity"></a>9.2.2 識別子の大文字と小文字の区別</h3></div></div></div><a class="indexterm" name="idm139979108662576"></a><a class="indexterm" name="idm139979108660448"></a><a class="indexterm" name="idm139979108658384"></a><a class="indexterm" name="idm139979108656320"></a><a class="indexterm" name="idm139979108654256"></a><a class="indexterm" name="idm139979108652176"></a><a class="indexterm" name="idm139979108650112"></a><a class="indexterm" name="idm139979108648048"></a><p>
        MySQL において、データベースはデータディレクトリ内のディレクトリに対応しています。データベース内の各テーブルも、データベースディレクトリ内の少なくとも 1 つ (ストレージエンジンによってはそれ以上) のファイルに対応しています。トリガーもファイルに対応しています。この結果、基になるオペレーティングシステムで大文字と小文字が区別されるかどうかが、データベース名、テーブル名、およびトリガー名で大文字と小文字が区別されるかどうかに影響します。これは、Windows ではこれらの名前は大文字と小文字が区別されませんが、多くの Unix では大文字と小文字が区別されることを意味します。ただし、注意が必要な例外の 1 つに OS X があります。OS X は Unix をベースにしますが、大文字と小文字が区別されないデフォルトのファイルシステムタイプ (HFS+) を使用します。ただし、OS X は UFS ボリュームもサポートしています。UFS ボリュームでは Unix の場合と同じように大文字と小文字が区別されます。<a class="xref" href="introduction.html#extensions-to-ansi" title="1.8.1 標準 SQL に対する MySQL 拡張機能">セクション1.8.1「標準 SQL に対する MySQL 拡張機能」</a>を参照してください。このセクションで後述するように、<code class="literal">lower_case_table_names</code> システム変数も、サーバーが識別子の大文字と小文字をどのように扱うかに影響を与えます。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          一部のプラットフォームでは、データベース名、テーブル名、およびトリガー名で大文字と小文字が区別されませんが、これらの名前の 1 つを参照するのに、同じステートメント内で大文字と小文字が異なる名前を使用しないでください。次のステートメントは、同じテーブルを <code class="literal">my_table</code> および <code class="literal">MY_TABLE</code> として参照するため、機能しません。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT * FROM my_table WHERE MY_TABLE.col=1;</code></strong>
</pre></div><p>
        カラム名、インデックス名、ストアドルーチン名、およびイベント名は、どのプラットフォームでも大文字と小文字が区別されません。カラムのエイリアスも同様です。
      </p><p>
        ただし、ログファイルグループの名前では大文字と小文字が区別されます。これは標準 SQL とは異なります。
      </p><p>
        デフォルトで、Unix ではテーブルのエイリアスは大文字と小文字が区別されますが、Windows または OS X では区別されません。Unix では、次のステートメントは、エイリアスを <code class="literal">a</code> と <code class="literal">A</code> の両方で参照しているので機能しません。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT <em class="replaceable"><code>col_name</code></em> FROM <em class="replaceable"><code>tbl_name</code></em> AS a</code></strong>
    -&gt; <strong class="userinput"><code>WHERE a.<em class="replaceable"><code>col_name</code></em> = 1 OR A.<em class="replaceable"><code>col_name</code></em> = 2;</code></strong>
</pre><p>
        ただし、Windows ではこの同じステートメントは許可されます。このような違いで生じる問題を回避するために、データベースとテーブルの作成および参照では常に小文字の名前を使用するなどの一貫した規則を設けることをお勧めします。この規則は移植性と使いやすさを最大限にするために推奨されています。
      </p><p>
        テーブル名やデータベース名がどのようにディスクに格納され、MySQL で使用されるかは、<code class="literal">lower_case_table_names</code> システム変数の影響を受けます。このシステム変数は、<span class="command"><strong>mysqld</strong></span> の起動時に設定できます。<code class="literal">lower_case_table_names</code> には、次の表に示す値を設定できます。この変数は、トリガー識別子の大文字と小文字の区別には影響を<span class="emphasis"><em>及ぼしません</em></span>。Unix では、<code class="literal">lower_case_table_names</code> のデフォルト値は 0 です。Windows では、デフォルト値は 1 です。OS X では、デフォルト値は 2 です。
      </p><div class="informaltable"><table summary="この表には、lower_case_table_names システム変数の値が示されています。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">値</th><th scope="col">意味</th></tr></thead><tbody><tr><td scope="row"><code class="literal">0</code></td><td>テーブル名とデータベース名は、<code class="literal">CREATE TABLE</code> または <code class="literal">CREATE DATABASE</code> ステートメントで指定された大文字または小文字を使用してディスク上に格納されます。名前比較では大文字と小文字が区別されます。大文字小文字を区別しないファイル名を持つシステム (Windows や OS X など) で MySQL を実行する場合、この変数を 0 に設定<span class="emphasis"><em>しないで</em></span>ください。大文字と小文字を区別しないファイルシステムで <code class="option">--lower-case-table-names=0</code> を使用して強制的にこの変数を 0 に設定し、大文字と小文字を変えて <code class="literal">MyISAM</code> テーブル名にアクセスした場合、インデックスが破損することがあります。</td></tr><tr><td scope="row"><code class="literal">1</code></td><td>テーブル名はディスク上に小文字で格納され、名前比較では大文字と小文字は区別されません。MySQL では、保存およびルックアップ時にすべてのテーブル名が小文字に変換されます。この動作はデータベース名やテーブルエイリアスにも適用されます。</td></tr><tr><td scope="row"><code class="literal">2</code></td><td>テーブル名とデータベース名は、<code class="literal">CREATE TABLE</code> または <code class="literal">CREATE DATABASE</code> ステートメントで指定された大文字または小文字を使用してディスク上に格納されますが、MySQL ではルックアップ時に小文字に変換されます。名前比較では大文字と小文字が区別されません。これは大文字と小文字が区別されないファイルシステムで<span class="emphasis"><em>のみ</em></span>機能します。<code class="literal">InnoDB</code> テーブル名は <code class="literal">lower_case_table_names=1</code> のように、小文字で格納されます。</td></tr></tbody></table></div><p>
        MySQL を 1 つのプラットフォームでのみ使用している場合は通常、<code class="literal">lower_case_table_names</code> 変数をデフォルト値から変更する必要はありません。ただし、ファイルシステム上の大文字と小文字の区別が異なるプラットフォーム間でテーブルを転送する場合は、問題が生じる可能性があります。たとえば、Unix 上では <code class="literal">my_table</code> と <code class="literal">MY_TABLE</code> という名前の異なる 2 つのテーブルを使用できますが、Windows 上ではこれらは同一のものとして扱われます。データベース名やテーブル名の大文字と小文字の区別が原因で発生するデータ転送の問題を回避するには、次の 2 つのオプションがあります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">lower_case_table_names=1</code> を全システムで使用してください。これの主な欠点は、<code class="literal">SHOW TABLES</code> または <code class="literal">SHOW DATABASES</code> を使用したときに、元の大文字または小文字で名前が表示されないことです。
          </p></li><li class="listitem"><p>
            Unix 上では <code class="literal">lower_case_table_names=0</code> を、Windows 上では <code class="literal">lower_case_table_names=2</code> を使用してください。これでデータベース名とテーブル名の大文字と小文字の区別が保持されます。この欠点は、ユーザーのステートメントが、Windows 上で正しい大文字または小文字でデータベース名およびテーブル名を常に参照していることを確認する必要があることです。大文字と小文字が区別される Unix にステートメントを転送する場合、大文字と小文字が正しくなければこのステートメントは機能しません。
          </p><p>
            <span class="bold"><strong>例外</strong></span>: <code class="literal">InnoDB</code> テーブルを使用している場合、データ転送に関するこのような問題を避けるには、すべてのプラットフォーム上で <code class="literal">lower_case_table_names</code> を 1 に設定して、強制的に名前が小文字に変換されるようにしてください。
          </p></li></ul></div><p>
        Unix 上で <code class="literal">lower_case_table_names</code> システム変数を 1 に設定する場合は、最初に古いデータベース名とテーブル名を小文字に変換してから、<span class="command"><strong>mysqld</strong></span> を停止し、新しい変数設定で再起動する必要があります。個々のテーブルに対してこれを行うには、<code class="literal">RENAME TABLE</code> を使用します。
      </p><pre class="programlisting">
RENAME TABLE T1 TO t1;
</pre><p>
        1 つ以上のデータベース全体を変換するには、<code class="literal">lower_case_table_names</code> の設定前にこれらをダンプし、続いてデータベースを削除して、<code class="literal">lower_case_table_names</code> の設定後にこれらをリロードします。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            <span class="command"><strong>mysqldump</strong></span> を使用して各データベースをダンプします。
          </p><pre class="programlisting">
mysqldump --databases db1 &gt; db1.sql
mysqldump --databases db2 &gt; db2.sql
...
</pre><p>
            再作成する必要のあるデータベースごとにこれを行います。
          </p></li><li class="listitem"><p>
            <code class="literal">DROP DATABASE</code> を使用して各データベースを削除します。
          </p></li><li class="listitem"><p>
            サーバーを停止し、<code class="literal">lower_case_table_names</code> を設定して、サーバーを再起動します。
          </p></li><li class="listitem"><p>
            データベースごとにダンプファイルをリロードします。<code class="literal">lower_case_table_names</code> が設定されているので、それぞれのデータベース名とテーブル名は、再作成されるときに小文字に変換されます。
          </p><pre class="programlisting">
mysql &lt; db1.sql
mysql &lt; db2.sql
...
</pre></li></ol></div><p>
        バイナリ照合順序に応じて大文字形式が同等である場合、オブジェクト名は複製と見なされる場合があります。これは、カーソル、条件、プロシージャー、関数、セーブポイント、ストアドルーチンパラメータ、ストアドプログラムローカル変数、およびプラグインの名前にも当てはまります。カラム、制約、データベース、パーティション、<code class="literal">PREPARE</code> を使用して準備されたステートメント、テーブル、トリガー、ユーザー、およびユーザー定義変数の名前には当てはまりません。
      </p><p>
        ファイルシステムの大文字と小文字の区別は、<code class="literal">INFORMATION_SCHEMA</code> テーブルの文字列カラムでの検索に影響する場合があります。詳細は、<a class="xref" href="globalization.html#charset-collation-information-schema" title="10.1.7.9 照合順序と INFORMATION_SCHEMA 検索">セクション10.1.7.9「照合順序と INFORMATION_SCHEMA 検索」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="identifier-mapping"></a>9.2.3 識別子とファイル名のマッピング</h3></div></div></div><p>
        データベース識別子やテーブル識別子とファイルシステム内の名前との間には対応があります。基本構造では、MySQL は各データベースをデータディレクトリ内のディレクトリとして表現し、各テーブルを適切なデータベースディレクトリ内の 1 つ以上のファイルで表現します。テーブル形式のファイル (<code class="filename">.FRM</code>) の場合、データは常にこの構造と場所に格納されます。
      </p><p>
        データファイルとインデックスファイルの場合、ディスク上の正確な表現はストレージエンジンによって異なります。これらのファイルを <code class="filename">FRM</code> ファイルと同じ場所に格納することも、情報を別のファイルに格納することもできます。<code class="literal">InnoDB</code> データは InnoDB データファイルに格納されます。<code class="literal">InnoDB</code> でテーブルスペースを使用する場合は、新たに作成した特定のテーブルスペースファイルが代わりに使用されます。
      </p><p>
        データベース識別子またはテーブル識別子では、ASCII NUL (<code class="literal">0x00</code>) を除いたすべての文字が正当です。MySQL では、データベースディレクトリやテーブルファイルを作成するとき、対応するファイルシステムオブジェクト内で問題のある文字をすべてエンコードします。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            基本的なラテン文字 (<code class="literal">a..zA..Z</code>)、数字 (<code class="literal">0..9</code>)、および下線 (<code class="literal">_</code>) はそのままエンコードされます。このため、それらが大文字と小文字を区別するかどうかは、ファイルシステムの特性に直接依存します。
          </p></li><li class="listitem"><p>
            大文字と小文字のマッピングを持つアルファベット起源のほかの国の文字はすべて、次の表に示すようにエンコードされます。コード範囲カラムの値は UCS-2 値です。
          </p><div class="informaltable"><table summary="この表には、そのままエンコードされる基本的なラテン文字 (a..zA..Z)、数字 (0..9)、および下線 (_) を除き、大文字と小文字のマッピングを持つアルファベット起源の国の文字に対するエンコードを示します。" border="1"><colgroup><col><col><col><col><col><col></colgroup><thead><tr><th scope="col">コード範囲</th><th scope="col">パターン</th><th scope="col">番号</th><th scope="col">使用</th><th scope="col">未使用</th><th scope="col">ブロック</th></tr></thead><tbody><tr><td scope="row">00C0..017F</td><td>[@][0..4][g..z]</td><td>5*20= 100</td><td>97</td><td>3</td><td>補足ラテン語-1 + 拡張ラテン語-A</td></tr><tr><td scope="row">0370..03FF</td><td>[@][5..9][g..z]</td><td>5*20= 100</td><td>88</td><td>12</td><td>ギリシア語およびコプト語</td></tr><tr><td scope="row">0400..052F</td><td>[@][g..z][0..6]</td><td>20*7= 140</td><td>137</td><td>3</td><td>キリル文字 + 補足キリル文字</td></tr><tr><td scope="row">0530..058F</td><td>[@][g..z][7..8]</td><td>20*2= 40</td><td>38</td><td>2</td><td>米語</td></tr><tr><td scope="row">2160..217F</td><td>[@][g..z][9]</td><td>20*1= 20</td><td>16</td><td>4</td><td>数の形式</td></tr><tr><td scope="row">0180..02AF</td><td>[@][g..z][a..k]</td><td>20*11=220</td><td>203</td><td>17</td><td>拡張ラテン語-B + 拡張 IPA</td></tr><tr><td scope="row">1E00..1EFF</td><td>[@][g..z][l..r]</td><td>20*7= 140</td><td>136</td><td>4</td><td>拡張ラテン語追加</td></tr><tr><td scope="row">1F00..1FFF</td><td>[@][g..z][s..z]</td><td>20*8= 160</td><td>144</td><td>16</td><td>拡張ギリシャ語</td></tr><tr><td scope="row">.... ....</td><td>[@][a..f][g..z]</td><td>6*20= 120</td><td>0</td><td>120</td><td>RESERVED</td></tr><tr><td scope="row">24B6..24E9</td><td>[@][@][a..z]</td><td>26</td><td>26</td><td>0</td><td>囲み文字</td></tr><tr><td scope="row">FF21..FF5A</td><td>[@][a..z][@]</td><td>26</td><td>26</td><td>0</td><td>全角と半角</td></tr></tbody></table></div><p>
            シーケンス内の 1 バイトが大文字と小文字の区別をエンコードします。例: <code class="literal">LATIN CAPITAL LETTER A WITH GRAVE</code> は <code class="literal">@0G</code> としてエンコードされ、<code class="literal">LATIN SMALL LETTER A WITH GRAVE</code> は <code class="literal">@0g</code> としてエンコードされます。ここでは、3 番目のバイト (<code class="literal">G</code> または <code class="literal">g</code>) が大文字と小文字の区別を示します。(大文字と小文字を区別しないファイルシステムでは、両文字は同じ文字として扱われます。)
          </p><p>
            言語ブロックの中にはキリル文字のように、2 番目のバイトが大文字と小文字の区別を決定することもあります。補足ラテン語 1 などのほかの言語ブロックでは、3 番目のバイトが大文字と小文字の区別を決定します。シーケンス内の 2 バイトが文字の場合は (拡張ギリシャ語など)、いちばん左の文字が大文字と小文字の区別を表します。ほかの文字バイトはすべて、小文字である必要があります。
          </p></li><li class="listitem"><p>
            下線 (<code class="literal">_</code>) を除くすべての文字以外のキャラクタは、大文字と小文字のマッピングのないアルファベット起源の文字 (ヘブライ語など) とともに、<code class="literal">a..f</code> の 16 進値に小文字を使用した 16 進表現を使用してエンコードされます。
          </p><pre class="programlisting">
0x003F -&gt; @003f
0xFFFF -&gt; @ffff
</pre><p>
            16 進値は、<code class="literal">ucs2</code> ダブルバイト文字セット内のキャラクタ値に対応します。
          </p></li></ul></div><p>
        Windows では、<code class="literal">nul</code>、<code class="literal">prn</code>、<code class="literal">aux</code> などの一部の名前は、サーバーが対応するファイルまたはディレクトリを作成するときに、<code class="literal">@@@</code> を名前に付加することによってエンコードされます。これは、対応するデータベースオブジェクトのプラットフォーム間での移植性のためにすべてのプラットフォームで行われます。
      </p><a class="indexterm" name="idm139979108493504"></a><p>
        MySQL 5.1.6 より前のバージョンのデータベースやテーブル内で特殊文字を使用し、その下位のディレクトリ名やファイル名が、その特殊文字に新しいエンコーディングを使用するように更新されていない場合、サーバーは <code class="literal">INFORMATION_SCHEMA</code> テーブルや <code class="literal">SHOW</code> ステートメントの出力内でそれらの名前に <code class="literal">#mysql50#</code> というプリフィクスを付けて表示します。たとえば、<code class="literal">a@b</code> という名前のテーブルがあり、その名前エンコーディングが更新されていない場合、<code class="literal">SHOW TABLES</code> で次のように表示されます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW TABLES;</code></strong>
+----------------+
| Tables_in_test |
+----------------+
| #mysql50#a@b   |
+----------------+
</pre><p>
        エンコーディングが更新されてないこのような名前を参照するには、<code class="literal">#mysql50#</code> プリフィクスを付加する必要があります。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW COLUMNS FROM `a@b`;</code></strong>
ERROR 1146 (42S02): Table 'test.a@b' doesn't exist

mysql&gt; <strong class="userinput"><code>SHOW COLUMNS FROM `#mysql50#a@b`;</code></strong>
+-------+---------+------+-----+---------+-------+
| Field | Type    | Null | Key | Default | Extra |
+-------+---------+------+-----+---------+-------+
| i     | int(11) | YES  |     | NULL    |       |
+-------+---------+------+-----+---------+-------+
</pre><p>
        特殊なプリフィクスを使用する必要をなくすために旧名を更新するには、<span class="command"><strong>mysqlcheck</strong></span> で再エンコードしてください。次のコマンドは、すべての名前を新しいエンコーディングに更新します。
      </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>mysqlcheck --check-upgrade --all-databases</code></strong>
shell&gt; <strong class="userinput"><code>mysqlcheck --fix-db-names --fix-table-names --all-databases</code></strong>

</pre><p>
        特定のデータベースまたはテーブルのみを確認するには、<code class="option">--all-databases</code> を削除し、適切なデータベースやテーブル引数を付け加えてください。<span class="command"><strong>mysqlcheck</strong></span> 呼び出し構文については、<a class="xref" href="programs.html#mysqlcheck" title="4.5.3 mysqlcheck — テーブル保守プログラム">セクション4.5.3「<span class="command"><strong>mysqlcheck</strong></span> — テーブル保守プログラム」</a>を参照してください。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">#mysql50#</code> プリフィクスは、サーバーが内部的に使用するためだけのものです。このプリフィクスを使用する名前でデータベースやテーブルを作成しないようにしてください。
        </p><p>
          また、<span class="command"><strong>mysqlcheck</strong></span> は、特殊文字をエンコードするために使用する <code class="literal">@</code> 文字のリテラルインスタンスが含まれる名前を修正できません。この文字が含まれるデータベースやテーブルを使用している場合は、<span class="command"><strong>mysqldump</strong></span> でそれらをダンプしてから MySQL 5.1.6 以降にアップグレードし、アップグレード後にダンプファイルをリロードします。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="function-resolution"></a>9.2.4 関数名の構文解析と解決</h3></div></div></div><a class="indexterm" name="idm139979108467616"></a><a class="indexterm" name="idm139979108465488"></a><p>
        MySQL 5.6 は、組み込み (ネイティブ) 関数、ユーザー定義関数 (UDF)、およびストアドファンクションをサポートします。このセクションでは、組み込み関数名が関数呼び出しとして使用されているか、識別子として使用されているかをサーバーで認識する方法と、指定された名前で異なる型の関数が存在する場合に使用する関数をサーバーが特定する方法について説明します。
      </p><p>
        <span class="bold"><strong>組み込み関数名の構文解析</strong></span>
      </p><p>
        パーサーは組み込み関数名を構文解析するためのデフォルトのルールを使用します。これらのルールは <code class="literal">IGNORE_SPACE</code> SQL モードを有効にすることで変更できます。
      </p><p>
        パーサーは、組み込み関数の名前である単語を検出すると、その名前が関数呼び出しを示しているのか、それともテーブル名やカラム名などの識別子の式以外の参照であるのかを判別する必要があります。たとえば、次のステートメントでは <code class="literal">count</code> に対する最初の参照は関数呼び出しですが、2 番目の参照はテーブル名です。
      </p><pre class="programlisting">
SELECT COUNT(*) FROM mytable;
CREATE TABLE count (i INT);
</pre><p>
        パーサーは、式であると予想される対象を解析しているときにのみ、組み込み関数の名前を、関数呼び出しを示している名前として認識する必要があります。つまり、式以外のコンテキストでは、関数名は識別子として許可されます。
      </p><p>
        ただし、組み込み関数の中には構文解析や実装に関する特別な考慮事項を含んでいるものがあるため、パーサーはデフォルトで次のルールに従って、その名前が関数呼び出しとして使用されているのか、それとも式以外のコンテキストで識別子として使用されているのかを判別します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            式の中で関数呼び出しとして名前を使用するには、名前とそれに続く括弧文字<span class="quote">「<span class="quote"><code class="literal">(</code></span>」</span>の間に空白が存在しないことが必要です。
          </p></li><li class="listitem"><p>
            反対に、関数名を識別子として使用するには、括弧文字を直後に続けないでください。
          </p></li></ul></div><p>
        名前と括弧の間に空白を入れずに関数呼び出しを記述するという要件は、特別な考慮事項を持つ組み込み関数にのみ適用されます。<code class="literal">COUNT</code> がこのような名前の 1 つです。後続の空白によって解釈が決まる関数名の正確な一覧は、<code class="filename">sql/lex.h</code> ソースファイルの <code class="literal">sql_functions[]</code> 配列に表示されます。MySQL 5.1 よりも前のバージョンでは、このような関数名が多数 (約 200) あるため、空白なしという要件をすべての関数呼び出しに適用させる方法がもっとも簡単であると考えられます。MySQL 5.1 以降では、パーサーの改善によって、影響を受ける関数名の数は約 30 にまで減少しています。
      </p><p>
        <code class="literal">sql_functions[]</code> 配列に一覧表示されていない関数には、空白は関係ありません。それらは式のコンテキストで使用されるときにのみ関数呼び出しとして解釈され、それ以外では識別子として自由に使用できます。<code class="literal">ASCII</code> がこのような名前の 1 つです。ただし、このような影響を受けない関数名に対する解釈は、式のコンテキストによって変わることがあります。つまり、<code class="literal"><em class="replaceable"><code>func_name</code></em> ()</code> は、指定の名前が単独で使用される場合は組み込み関数として解釈されますが、単独ではない場合、<code class="literal"><em class="replaceable"><code>func_name</code></em> ()</code> はユーザー定義関数またはストアドファンクション (その名前の関数が存在する場合) として解釈されます。
      </p><p>
        <code class="literal">IGNORE_SPACE</code> SQL モードは、空白の有無で区別される関数名をパーサーで扱う方法を変更するために使用できます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">IGNORE_SPACE</code> が無効になっていると、名前と後続の括弧の間に空白がない場合、パーサーはその名前を関数呼び出しと解釈します。これは、関数名が式以外のコンテキストで使用されているときにも行われます。
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE count(i INT);</code></strong>
ERROR 1064 (42000): You have an error in your SQL syntax ...
near 'count(i INT)'
</pre><p>
            エラーを取り除き、名前が識別子として扱われるようにするには、名前のあとに続く空白を使うか、引用符で囲んだ識別子として記述してください (あるいはこの両方)。
          </p><pre class="programlisting">
CREATE TABLE count (i INT);
CREATE TABLE `count`(i INT);
CREATE TABLE `count` (i INT);
</pre></li><li class="listitem"><p>
            <code class="literal">IGNORE_SPACE</code> が有効になっていると、パーサーは関数名と後続の括弧の間に空白は存在しないという要件を緩和します。このことで、関数呼び出しの記述がより自由に行えるようになります。たとえば、次のどちらの関数呼び出しも有効です。
          </p><pre class="programlisting">
SELECT COUNT(*) FROM mytable;
SELECT COUNT (*) FROM mytable;
</pre><p>
            ただし、<code class="literal">IGNORE_SPACE</code> を有効にした場合、影響を受ける関数名をパーサーが予約語として扱うという副作用も生じます (<a class="xref" href="language-structure.html#reserved-words" title="9.3 予約語">セクション9.3「予約語」</a>を参照してください)。つまり、名前のあとに続く空白は、それが識別子として使用されることを示すものではなくなります。後続の空白の有無を問わず、名前は関数呼び出しとして使用できますが、引用符で囲まれていないかぎり、式以外のコンテキストでは構文エラーが発生します。たとえば、<code class="literal">IGNORE_SPACE</code> が有効になっていると、パーサーが <code class="literal">count</code> を予約語として解釈するため、次のステートメントはどちらも構文エラーが表示されて失敗します。
          </p><pre class="programlisting">
CREATE TABLE count(i INT);
CREATE TABLE count (i INT);
</pre><p>
            式以外のコンテキストで関数名を使用するには、これを引用符で囲まれた識別子として記述します。
          </p><pre class="programlisting">
CREATE TABLE `count`(i INT);
CREATE TABLE `count` (i INT);
</pre></li></ul></div><p>
        <code class="literal">IGNORE_SPACE</code> SQL モードを有効にするには、次のステートメントを使用します。
      </p><pre class="programlisting">
SET sql_mode = 'IGNORE_SPACE';
</pre><p>
        <code class="literal">IGNORE_SPACE</code> は、<code class="literal">ANSI</code> などのほかの特定のコンポジットモードの値に含められている場合にも有効になります。
      </p><pre class="programlisting">
SET sql_mode = 'ANSI';
</pre><p>
        どのコンポジットモードが <code class="literal">IGNORE_SPACE</code> を有効にするかを調べるには、<a class="xref" href="server-administration.html#sql-mode" title="5.1.7 サーバー SQL モード">セクション5.1.7「サーバー SQL モード」</a>を参照してください。
      </p><p>
        <code class="literal">IGNORE_SPACE</code> 設定における SQL コードの依存関係を最小にするには、以下のガイドラインを使用してください。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            組み込み関数と同じ名前の UDF またはストアドファンクションは作成しないでください。
          </p></li><li class="listitem"><p>
            式以外のコンテキストでは関数名を使用しないでください。たとえば、これらのステートメントは、<code class="literal">count</code> (<code class="literal">IGNORE_SPACE</code> の影響を受ける関数名の 1 つ) を使用するため、<code class="literal">IGNORE_SPACE</code> が有効であれば、名前に続く空白の有無によらずこれらのステートメントは失敗します。
          </p><pre class="programlisting">
CREATE TABLE count(i INT);
CREATE TABLE count (i INT);
</pre><p>
            式以外のコンテキストで関数名を使用する必要がある場合は、これを引用符で囲まれた識別子として記述します。
          </p><pre class="programlisting">
CREATE TABLE `count`(i INT);
CREATE TABLE `count` (i INT);
</pre></li></ul></div><p>
        MySQL 5.1.13 では、<code class="literal">IGNORE_SPACE</code> の影響を受ける関数名の数がおよそ 200 から 30 に大幅に減少しました。MySQL 5.1.13 以降、<code class="literal">IGNORE_SPACE</code> 設定の影響を引き続き受けるのは、次の関数だけです。
      </p><div class="informaltable"><table summary="次の表には、MySQL 5.1.13 以降に、IGNORE_SPACE 設定の影響を引き続き受ける関数が示されています。" border="1"><colgroup><col><col><col><col></colgroup><tbody><tr><td scope="row"><code class="literal">ADDDATE</code></td><td><code class="literal">BIT_AND</code></td><td><code class="literal">BIT_OR</code></td><td><code class="literal">BIT_XOR</code></td></tr><tr><td scope="row"><code class="literal">CAST</code></td><td><code class="literal">COUNT</code></td><td><code class="literal">CURDATE</code></td><td><code class="literal">CURTIME</code></td></tr><tr><td scope="row"><code class="literal">DATE_ADD</code></td><td><code class="literal">DATE_SUB</code></td><td><code class="literal">EXTRACT</code></td><td><code class="literal">GROUP_CONCAT</code></td></tr><tr><td scope="row"><code class="literal">MAX</code></td><td><code class="literal">MID</code></td><td><code class="literal">MIN</code></td><td><code class="literal">NOW</code></td></tr><tr><td scope="row"><code class="literal">POSITION</code></td><td><code class="literal">SESSION_USER</code></td><td><code class="literal">STD</code></td><td><code class="literal">STDDEV</code></td></tr><tr><td scope="row"><code class="literal">STDDEV_POP</code></td><td><code class="literal">STDDEV_SAMP</code></td><td><code class="literal">SUBDATE</code></td><td><code class="literal">SUBSTR</code></td></tr><tr><td scope="row"><code class="literal">SUBSTRING</code></td><td><code class="literal">SUM</code></td><td><code class="literal">SYSDATE</code></td><td><code class="literal">SYSTEM_USER</code></td></tr><tr><td scope="row"><code class="literal">TRIM</code></td><td><code class="literal">VARIANCE</code></td><td><code class="literal">VAR_POP</code></td><td><code class="literal">VAR_SAMP</code></td></tr></tbody></table></div><p>
        MySQL の以前のバージョンでは、<code class="filename">sql/lex.h</code> ソースファイルの <code class="literal">sql_functions[]</code> 配列の内容を確認して、どの関数が <code class="literal">IGNORE_SPACE</code> に影響を受けるかを確認してください。
      </p><p>
        <span class="bold"><strong>非互換性に関する警告</strong></span>: MySQL 5.1.13 では <code class="literal">IGNORE_SPACE</code> の影響を受ける関数名の数を抑えることでパーサー操作に一貫性をもたらしました。ただし、次の条件に依存する旧 SQL コードの非互換性の可能性も生じます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">IGNORE_SPACE</code> は無効になっています。
          </p></li><li class="listitem"><p>
            関数名に続く空白の有無は、同じ名前を持つ組み込み関数とストアドファンクション (たとえば、<code class="literal">PI()</code> と <code class="literal">PI ()</code> など) を区別するために使用されます。
          </p></li></ul></div><p>
        MySQL 5.1.13 以降に <code class="literal">IGNORE_SPACE</code> の影響を受けなくなった関数に対しては、その方法は機能しません。前述の非互換性の影響を受けるコードがある場合は、次のどちらのアプローチも使用できます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            ストアドファンクションに組み込み関数と競合する名前が存在する場合、空白の有無にかかわらず、スキーマ名修飾子を持つストアドファンクションを参照してください。たとえば、<code class="literal"><em class="replaceable"><code>schema_name</code></em>.PI()</code> または <code class="literal"><em class="replaceable"><code>schema_name</code></em>.PI ()</code> と記述します。
          </p></li><li class="listitem"><p>
            または、競合しない名前を使用するようにストアドファンクションの名前を変更し、新しい名前を使用するように関数の呼び出しを変更します。
          </p></li></ul></div><p>
        <span class="bold"><strong>関数名の解決</strong></span>
      </p><p>
        次のルールは、関数の作成と呼び出しのために、サーバーで関数名の参照を解決する方法について記述します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            組み込み関数とユーザー定義関数
          </p><p>
            組み込み関数と同じ名前で UDF を作成しようとした場合、エラーが発生します。
          </p></li><li class="listitem"><p>
            組み込み関数とストアドファンクション
          </p><p>
            組み込み関数と同名のストアドファンクションを作成することは可能ですが、このストアドファンクションを呼び出すにはスキーマ名で修飾する必要があります。たとえば、<code class="literal">test</code> スキーマ内で <code class="literal">PI</code> という名のストアドファンクションを作成する場合、サーバーが <code class="literal">PI()</code> を組み込み関数の参照として解決するため、<code class="literal">test.PI()</code> として呼び出します。サーバーは、ストアドファンクション名が組み込み関数名と一致しない場合、警告を作成します。この警告は <code class="literal">SHOW WARNINGS</code> で表示できます。
          </p></li><li class="listitem"><p>
            ユーザー定義関数とストアドファンクション
          </p><p>
            ユーザー定義関数とストアドファンクションは同じ名前空間を共有します。したがって、同名の UDF とストアドファンクションを作成することはできません。
          </p></li></ul></div><p>
        前述の関数名の解決ルールは、新しい組み込み関数を実装する MySQL のバージョンへのアップグレードに影響を及ぼします。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            指定の名前のユーザー定義関数がすでに作成されており、同じ名前で新しい組み込み関数を実装するバージョンに MySQL をアップグレードすると、この UDF にはアクセスできなくなります。これを修正するには、<code class="literal">DROP FUNCTION</code> を使用して UDF を削除してから、<code class="literal">CREATE FUNCTION</code> を使用して競合しない別の名前で UDF を再作成します。
          </p></li><li class="listitem"><p>
            新しいバージョンの MySQL で、既存のストアドファンクションと同じ名前で組み込み関数を実装する場合、ストアドファンクションの名前を競合しない名前に変更するか、スキーマ修飾子を使用するように関数の呼び出しを変更する (つまり、<code class="literal"><em class="replaceable"><code>schema_name</code></em>.<em class="replaceable"><code>func_name</code></em>()</code> 構文を使用する) という 2 つの選択肢があります。
          </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="reserved-words"></a>9.3 予約語</h2></div></div></div><a class="indexterm" name="idm139979108330640"></a><a class="indexterm" name="idm139979108329184"></a><p>
      <code class="literal">SELECT</code>、<code class="literal">DELETE</code>、または <code class="literal">BIGINT</code> などの特定の語は、テーブル名やカラム名などの識別子として使用するために予約されており、特別な取り扱いが必要になります。これは、組み込み関数の名前にも当てはまる場合があります。
    </p><p>
      <a class="xref" href="language-structure.html#identifiers" title="9.2 スキーマオブジェクト名">セクション9.2「スキーマオブジェクト名」</a>で説明しているように、予約語は、引用符で囲まれている場合、識別子として許可されます。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE interval (begin INT, end INT);</code></strong>
ERROR 1064 (42000): You have an error in your SQL syntax ...
near 'interval (begin INT, end INT)'

mysql&gt; <strong class="userinput"><code>CREATE TABLE `interval` (begin INT, end INT);</code></strong>
Query OK, 0 rows affected (0.01 sec)
</pre><p>
      例外: 修飾名でピリオドに続く語は識別子のため、予約されていても引用符で囲む必要はありません。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE mydb.interval (begin INT, end INT);</code></strong>
Query OK, 0 rows affected (0.01 sec)
</pre><p>
      組み込み関数名は識別子として許可されますが、識別子として使用する場合は注意してください。たとえば、<code class="literal">COUNT</code> はカラム名として許容されます。ただし、デフォルトでは、関数呼び出しにおいて、関数名と後続の<span class="quote">「<span class="quote"><code class="literal">(</code></span>」</span>文字の間に空白を入れないことが許可されています。この要件によって、パーサーはその名前が関数の呼び出しで使用されるのか、それとも関数でないコンテキストで使用されるのかを判別できます。関数名の識別についての詳細は、<a class="xref" href="language-structure.html#function-resolution" title="9.2.4 関数名の構文解析と解決">セクション9.2.4「関数名の構文解析と解決」</a>を参照してください。
    </p><p>
      次の表の語は、MySQL 5.6 で明示的に予約されています。さらに、<code class="literal">_FILENAME</code> も予約されています。今後バージョンアップするときのことを考慮に入れて、使用予定のある予約語を確認しておくことをお勧めします。新しいバージョンの MySQL を扱ったマニュアルでもこれらを確認できます。表内のほとんどの語は、カラム名やテーブル名として標準 SQL で許可されていません (<code class="literal">GROUP</code> など)。いくつかは、MySQL が必要とし、<span class="command"><strong>yacc</strong></span> パーサーを使用するので予約されています。予約語は、引用符で囲んだ場合、識別子として使用できます。
    </p><p>
      バージョン間の違いも含めた予約語の詳細なリストについては、<a class="ulink" href="http://dev.mysql.com/doc/mysqld-version-reference/en/mysqld-version-reference-keywords-5-6.html" target="_top">Keywords and Reserved Words in MySQL 5.6</a>を参照してください。
    </p><div class="table"><a name="table-reserved-words-5.6"></a><p class="title"><b>表 9.2 MySQL 5.6 での予約語</b></p><div class="table-contents"><table summary="MySQL 5.6 での予約語" id="table-reserved-words-5.6"><col width="33%"><col width="33%"><col width="33%"><tbody><tr><td><code class="literal">ACCESSIBLE</code></td>
<td><code class="literal">ADD</code></td>
<td><code class="literal">ALL</code></td>
</tr><tr><td><code class="literal">ALTER</code></td>
<td><code class="literal">ANALYZE</code></td>
<td><code class="literal">AND</code></td>
</tr><tr><td><code class="literal">AS</code></td>
<td><code class="literal">ASC</code></td>
<td><code class="literal">ASENSITIVE</code></td>
</tr><tr><td><code class="literal">BEFORE</code></td>
<td><code class="literal">BETWEEN</code></td>
<td><code class="literal">BIGINT</code></td>
</tr><tr><td><code class="literal">BINARY</code></td>
<td><code class="literal">BLOB</code></td>
<td><code class="literal">BOTH</code></td>
</tr><tr><td><code class="literal">BY</code></td>
<td><code class="literal">CALL</code></td>
<td><code class="literal">CASCADE</code></td>
</tr><tr><td><code class="literal">CASE</code></td>
<td><code class="literal">CHANGE</code></td>
<td><code class="literal">CHAR</code></td>
</tr><tr><td><code class="literal">CHARACTER</code></td>
<td><code class="literal">CHECK</code></td>
<td><code class="literal">COLLATE</code></td>
</tr><tr><td><code class="literal">COLUMN</code></td>
<td><code class="literal">CONDITION</code></td>
<td><code class="literal">CONSTRAINT</code></td>
</tr><tr><td><code class="literal">CONTINUE</code></td>
<td><code class="literal">CONVERT</code></td>
<td><code class="literal">CREATE</code></td>
</tr><tr><td><code class="literal">CROSS</code></td>
<td><code class="literal">CURRENT_DATE</code></td>
<td><code class="literal">CURRENT_TIME</code></td>
</tr><tr><td><code class="literal">CURRENT_TIMESTAMP</code></td>
<td><code class="literal">CURRENT_USER</code></td>
<td><code class="literal">CURSOR</code></td>
</tr><tr><td><code class="literal">DATABASE</code></td>
<td><code class="literal">DATABASES</code></td>
<td><code class="literal">DAY_HOUR</code></td>
</tr><tr><td><code class="literal">DAY_MICROSECOND</code></td>
<td><code class="literal">DAY_MINUTE</code></td>
<td><code class="literal">DAY_SECOND</code></td>
</tr><tr><td><code class="literal">DEC</code></td>
<td><code class="literal">DECIMAL</code></td>
<td><code class="literal">DECLARE</code></td>
</tr><tr><td><code class="literal">DEFAULT</code></td>
<td><code class="literal">DELAYED</code></td>
<td><code class="literal">DELETE</code></td>
</tr><tr><td><code class="literal">DESC</code></td>
<td><code class="literal">DESCRIBE</code></td>
<td><code class="literal">DETERMINISTIC</code></td>
</tr><tr><td><code class="literal">DISTINCT</code></td>
<td><code class="literal">DISTINCTROW</code></td>
<td><code class="literal">DIV</code></td>
</tr><tr><td><code class="literal">DOUBLE</code></td>
<td><code class="literal">DROP</code></td>
<td><code class="literal">DUAL</code></td>
</tr><tr><td><code class="literal">EACH</code></td>
<td><code class="literal">ELSE</code></td>
<td><code class="literal">ELSEIF</code></td>
</tr><tr><td><code class="literal">ENCLOSED</code></td>
<td><code class="literal">ESCAPED</code></td>
<td><code class="literal">EXISTS</code></td>
</tr><tr><td><code class="literal">EXIT</code></td>
<td><code class="literal">EXPLAIN</code></td>
<td><code class="literal">FALSE</code></td>
</tr><tr><td><code class="literal">FETCH</code></td>
<td><code class="literal">FLOAT</code></td>
<td><code class="literal">FLOAT4</code></td>
</tr><tr><td><code class="literal">FLOAT8</code></td>
<td><code class="literal">FOR</code></td>
<td><code class="literal">FORCE</code></td>
</tr><tr><td><code class="literal">FOREIGN</code></td>
<td><code class="literal">FROM</code></td>
<td><code class="literal">FULLTEXT</code></td>
</tr><tr><td><code class="literal">GET</code></td>
<td><code class="literal">GRANT</code></td>
<td><code class="literal">GROUP</code></td>
</tr><tr><td><code class="literal">HAVING</code></td>
<td><code class="literal">HIGH_PRIORITY</code></td>
<td><code class="literal">HOUR_MICROSECOND</code></td>
</tr><tr><td><code class="literal">HOUR_MINUTE</code></td>
<td><code class="literal">HOUR_SECOND</code></td>
<td><code class="literal">IF</code></td>
</tr><tr><td><code class="literal">IGNORE</code></td>
<td><code class="literal">IN</code></td>
<td><code class="literal">INDEX</code></td>
</tr><tr><td><code class="literal">INFILE</code></td>
<td><code class="literal">INNER</code></td>
<td><code class="literal">INOUT</code></td>
</tr><tr><td><code class="literal">INSENSITIVE</code></td>
<td><code class="literal">INSERT</code></td>
<td><code class="literal">INT</code></td>
</tr><tr><td><code class="literal">INT1</code></td>
<td><code class="literal">INT2</code></td>
<td><code class="literal">INT3</code></td>
</tr><tr><td><code class="literal">INT4</code></td>
<td><code class="literal">INT8</code></td>
<td><code class="literal">INTEGER</code></td>
</tr><tr><td><code class="literal">INTERVAL</code></td>
<td><code class="literal">INTO</code></td>
<td><code class="literal">IO_AFTER_GTIDS</code></td>
</tr><tr><td><code class="literal">IO_BEFORE_GTIDS</code></td>
<td><code class="literal">IS</code></td>
<td><code class="literal">ITERATE</code></td>
</tr><tr><td><code class="literal">JOIN</code></td>
<td><code class="literal">KEY</code></td>
<td><code class="literal">KEYS</code></td>
</tr><tr><td><code class="literal">KILL</code></td>
<td><code class="literal">LEADING</code></td>
<td><code class="literal">LEAVE</code></td>
</tr><tr><td><code class="literal">LEFT</code></td>
<td><code class="literal">LIKE</code></td>
<td><code class="literal">LIMIT</code></td>
</tr><tr><td><code class="literal">LINEAR</code></td>
<td><code class="literal">LINES</code></td>
<td><code class="literal">LOAD</code></td>
</tr><tr><td><code class="literal">LOCALTIME</code></td>
<td><code class="literal">LOCALTIMESTAMP</code></td>
<td><code class="literal">LOCK</code></td>
</tr><tr><td><code class="literal">LONG</code></td>
<td><code class="literal">LONGBLOB</code></td>
<td><code class="literal">LONGTEXT</code></td>
</tr><tr><td><code class="literal">LOOP</code></td>
<td><code class="literal">LOW_PRIORITY</code></td>
<td><code class="literal">MASTER_BIND</code></td>
</tr><tr><td><code class="literal">MASTER_SSL_VERIFY_SERVER_CERT</code></td>
<td><code class="literal">MATCH</code></td>
<td><code class="literal">MAXVALUE</code></td>
</tr><tr><td><code class="literal">MEDIUMBLOB</code></td>
<td><code class="literal">MEDIUMINT</code></td>
<td><code class="literal">MEDIUMTEXT</code></td>
</tr><tr><td><code class="literal">MIDDLEINT</code></td>
<td><code class="literal">MINUTE_MICROSECOND</code></td>
<td><code class="literal">MINUTE_SECOND</code></td>
</tr><tr><td><code class="literal">MOD</code></td>
<td><code class="literal">MODIFIES</code></td>
<td><code class="literal">NATURAL</code></td>
</tr><tr><td><code class="literal">NOT</code></td>
<td><code class="literal">NO_WRITE_TO_BINLOG</code></td>
<td><code class="literal">NULL</code></td>
</tr><tr><td><code class="literal">NUMERIC</code></td>
<td><code class="literal">ON</code></td>
<td><code class="literal">OPTIMIZE</code></td>
</tr><tr><td><code class="literal">OPTION</code></td>
<td><code class="literal">OPTIONALLY</code></td>
<td><code class="literal">OR</code></td>
</tr><tr><td><code class="literal">ORDER</code></td>
<td><code class="literal">OUT</code></td>
<td><code class="literal">OUTER</code></td>
</tr><tr><td><code class="literal">OUTFILE</code></td>
<td><code class="literal">PARTITION</code></td>
<td><code class="literal">PRECISION</code></td>
</tr><tr><td><code class="literal">PRIMARY</code></td>
<td><code class="literal">PROCEDURE</code></td>
<td><code class="literal">PURGE</code></td>
</tr><tr><td><code class="literal">RANGE</code></td>
<td><code class="literal">READ</code></td>
<td><code class="literal">READS</code></td>
</tr><tr><td><code class="literal">READ_WRITE</code></td>
<td><code class="literal">REAL</code></td>
<td><code class="literal">REFERENCES</code></td>
</tr><tr><td><code class="literal">REGEXP</code></td>
<td><code class="literal">RELEASE</code></td>
<td><code class="literal">RENAME</code></td>
</tr><tr><td><code class="literal">REPEAT</code></td>
<td><code class="literal">REPLACE</code></td>
<td><code class="literal">REQUIRE</code></td>
</tr><tr><td><code class="literal">RESIGNAL</code></td>
<td><code class="literal">RESTRICT</code></td>
<td><code class="literal">RETURN</code></td>
</tr><tr><td><code class="literal">REVOKE</code></td>
<td><code class="literal">RIGHT</code></td>
<td><code class="literal">RLIKE</code></td>
</tr><tr><td><code class="literal">SCHEMA</code></td>
<td><code class="literal">SCHEMAS</code></td>
<td><code class="literal">SECOND_MICROSECOND</code></td>
</tr><tr><td><code class="literal">SELECT</code></td>
<td><code class="literal">SENSITIVE</code></td>
<td><code class="literal">SEPARATOR</code></td>
</tr><tr><td><code class="literal">SET</code></td>
<td><code class="literal">SHOW</code></td>
<td><code class="literal">SIGNAL</code></td>
</tr><tr><td><code class="literal">SMALLINT</code></td>
<td><code class="literal">SPATIAL</code></td>
<td><code class="literal">SPECIFIC</code></td>
</tr><tr><td><code class="literal">SQL</code></td>
<td><code class="literal">SQLEXCEPTION</code></td>
<td><code class="literal">SQLSTATE</code></td>
</tr><tr><td><code class="literal">SQLWARNING</code></td>
<td><code class="literal">SQL_BIG_RESULT</code></td>
<td><code class="literal">SQL_CALC_FOUND_ROWS</code></td>
</tr><tr><td><code class="literal">SQL_SMALL_RESULT</code></td>
<td><code class="literal">SSL</code></td>
<td><code class="literal">STARTING</code></td>
</tr><tr><td><code class="literal">STRAIGHT_JOIN</code></td>
<td><code class="literal">TABLE</code></td>
<td><code class="literal">TERMINATED</code></td>
</tr><tr><td><code class="literal">THEN</code></td>
<td><code class="literal">TINYBLOB</code></td>
<td><code class="literal">TINYINT</code></td>
</tr><tr><td><code class="literal">TINYTEXT</code></td>
<td><code class="literal">TO</code></td>
<td><code class="literal">TRAILING</code></td>
</tr><tr><td><code class="literal">TRIGGER</code></td>
<td><code class="literal">TRUE</code></td>
<td><code class="literal">UNDO</code></td>
</tr><tr><td><code class="literal">UNION</code></td>
<td><code class="literal">UNIQUE</code></td>
<td><code class="literal">UNLOCK</code></td>
</tr><tr><td><code class="literal">UNSIGNED</code></td>
<td><code class="literal">UPDATE</code></td>
<td><code class="literal">USAGE</code></td>
</tr><tr><td><code class="literal">USE</code></td>
<td><code class="literal">USING</code></td>
<td><code class="literal">UTC_DATE</code></td>
</tr><tr><td><code class="literal">UTC_TIME</code></td>
<td><code class="literal">UTC_TIMESTAMP</code></td>
<td><code class="literal">VALUES</code></td>
</tr><tr><td><code class="literal">VARBINARY</code></td>
<td><code class="literal">VARCHAR</code></td>
<td><code class="literal">VARCHARACTER</code></td>
</tr><tr><td><code class="literal">VARYING</code></td>
<td><code class="literal">WHEN</code></td>
<td><code class="literal">WHERE</code></td>
</tr><tr><td><code class="literal">WHILE</code></td>
<td><code class="literal">WITH</code></td>
<td><code class="literal">WRITE</code></td>
</tr><tr><td><code class="literal">XOR</code></td>
<td><code class="literal">YEAR_MONTH</code></td>
<td><code class="literal">ZEROFILL</code></td>
</tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="table-reserved-words-new-5.6"></a><p class="title"><b>表 9.3 MySQL 5.5 と比較した MySQL 5.6 の新しい予約語</b></p><div class="table-contents"><table summary="MySQL 5.5 と比較した MySQL 5.6 の新しい予約語" id="table-reserved-words-new-5.6"><col width="33%"><col width="33%"><col width="33%"><tbody><tr><td><code class="literal">GET</code></td>
<td><code class="literal">IO_AFTER_GTIDS</code></td>
<td><code class="literal">IO_BEFORE_GTIDS</code></td>
</tr><tr><td><code class="literal">MASTER_BIND</code></td>
<td><code class="literal">PARTITION</code></td>
<td> </td>
</tr></tbody></table></div></div><br class="table-break"><p>
      MySQL では、以前に多くの人々が使用していたので、一部のキーワードを引用符で囲まない識別子として使用することを許可しています。次の一覧に例を示します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">ACTION</code>
        </p></li><li class="listitem"><p>
          <code class="literal">BIT</code>
        </p></li><li class="listitem"><p>
          <code class="literal">DATE</code>
        </p></li><li class="listitem"><p>
          <code class="literal">ENUM</code>
        </p></li><li class="listitem"><p>
          <code class="literal">NO</code>
        </p></li><li class="listitem"><p>
          <code class="literal">TEXT</code>
        </p></li><li class="listitem"><p>
          <code class="literal">TIME</code>
        </p></li><li class="listitem"><p>
          <code class="literal">TIMESTAMP</code>
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="user-variables"></a>9.4 ユーザー定義変数</h2></div></div></div><a class="indexterm" name="idm139979107959504"></a><a class="indexterm" name="idm139979107957392"></a><a class="indexterm" name="idm139979107956032"></a><a class="indexterm" name="idm139979107954000"></a><a class="indexterm" name="idm139979107952640"></a><a class="indexterm" name="idm139979107951280"></a><p>
      あるステートメント内のユーザー定義変数に値を格納し、あとから別のステートメントでこれを参照できます。これにより、あるステートメントから別のステートメントに値を渡すことができます。<span class="emphasis"><em>ユーザー定義変数はセッション固有です</em></span>。つまり、あるクライアントが定義したユーザー変数を、ほかのクライアントが表示したり、使用したりすることはできません。所定のクライアントセッションのすべての変数は、クライアントが終了すると自動的に解放されます。
    </p><p>
      ユーザー変数は <code class="literal">@<em class="replaceable"><code>var_name</code></em></code> と記述されます。ここで変数名 <em class="replaceable"><code>var_name</code></em> は、英数字文字、<span class="quote">「<span class="quote"><code class="literal">.</code></span>」</span>、<span class="quote">「<span class="quote"><code class="literal">_</code></span>」</span>、および<span class="quote">「<span class="quote"><code class="literal">$</code></span>」</span>から構成されます。ユーザー変数名を文字列や識別子として引用符で囲めば、ほかの文字も含めることができます (<code class="literal">@'my-var'</code>、<code class="literal">@"my-var"</code>、<code class="literal">@`my-var`</code> など)。
    </p><p>
      ユーザー変数名では大文字と小文字を区別しません。
    </p><p>
      ユーザー定義変数を設定する方法の 1 つに、<code class="literal">SET</code> ステートメントを発行する方法が挙げられます。
    </p><pre class="programlisting">
SET @<em class="replaceable"><code>var_name</code></em> = <em class="replaceable"><code>expr</code></em> [, @<em class="replaceable"><code>var_name</code></em> = <em class="replaceable"><code>expr</code></em>] ...
</pre><p>
      <code class="literal">SET</code> では、<code class="literal">=</code> または <code class="literal">:=</code> のどちらかを割り当て演算子として使用できます。
    </p><p>
      <code class="literal">SET</code> 以外のステートメントで、ユーザー変数に値を割り当てることもできます。この場合、<code class="literal">=</code> は <code class="literal">SET</code> 以外のステートメントでは比較演算子 <code class="literal">=</code> として扱われるので、割り当て演算子にはこちらではなく、<code class="literal">:=</code> を使用する必要があります。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET @t1=1, @t2=2, @t3:=4;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT @t1, @t2, @t3, @t4 := @t1+@t2+@t3;</code></strong>
+------+------+------+--------------------+
| @t1  | @t2  | @t3  | @t4 := @t1+@t2+@t3 |
+------+------+------+--------------------+
|    1 |    2 |    4 |                  7 | 
+------+------+------+--------------------+
</pre><p>
      ユーザー変数には、限定された一連のデータ型の値 (整数、小数、浮動小数点、バイナリ文字列、非バイナリ文字列、または <code class="literal">NULL</code> 値) を割り当てることができます。10 進値と実数値の割り当てでは、値の精度やスケールは維持されません。許可されている型以外の型の値は、許可されている型に変換されます。たとえば、時間を表すデータ型や空間データ型の値は、バイナリ文字列に変換されます。
    </p><p>
      ユーザー変数に非バイナリ (文字) 文字列値を割り当てた場合、その変数には文字列と同じ文字セットと照合順序が含まれます。ユーザー変数の強制性は暗黙的です。(これはテーブルカラム値と同等の強制性です。)
    </p><p>
      ユーザー変数に割り当てられたビット値は、バイナリ文字列として扱われます。ビット値を数値としてユーザー変数に割り当てるには、<code class="literal">CAST()</code> または <code class="literal">+0</code> を使用します。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET @v1 = b'1000001';</code></strong>
mysql&gt; <strong class="userinput"><code>SET @v2 = CAST(b'1000001' AS UNSIGNED), @v3 = b'1000001'+0;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT @v1, @v2, @v3;</code></strong>
+------+------+------+
| @v1  | @v2  | @v3  |
+------+------+------+
| A    |   65 |   65 |
+------+------+------+
</pre><p>
      結果セットでユーザー変数の値が選択された場合、それは文字列としてクライアントに返されます。
    </p><p>
      初期化されていない変数を参照する場合、その値は <code class="literal">NULL</code> で、型は文字列です。
    </p><p>
      ユーザー変数は、式が許可されているほとんどのコンテキストで使用できます。これには現在、<code class="literal">SELECT</code> ステートメントの <code class="literal">LIMIT</code> 句の中や、<code class="literal">LOAD DATA</code> ステートメントの <code class="literal">IGNORE <em class="replaceable"><code>N</code></em> LINES</code> 句の中など、リテラル値を明示的に要求するコンテキストは含まれません。
    </p><p>
      一般的なルールとして、<code class="literal">SET</code> ステートメント以外では、同じステートメント内で、ユーザー変数に値を割り当ててその値を読み取ることは決してしないでください。たとえば、変数を増分する場合、次のようにしても問題ありません。
    </p><pre class="programlisting">
SET @a = @a + 1;
</pre><p>
      <code class="literal">SELECT</code> などのほかのステートメントでは、予想した結果が得られることもありますが、これは保証されません。次のステートメントでは、MySQL が最初に <code class="literal">@a</code> を評価し、続いて 2 番目の割り当てを行います。
    </p><pre class="programlisting">
SELECT @a, @a:=@a+1, ...;
</pre><p>
      ただし、ユーザー変数を含む式の評価の順序は、定義されていません。
    </p><p>
      <code class="literal">SET</code> 以外の同じステートメント内で変数に値を割り当てて、その値を読み取る場合に生じるもう 1 つの問題は、変数のデフォルトの結果型がステートメントの開始時の型に基づくということです。次の例でこれについて説明します。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET @a='test';</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT @a,(@a:=20) FROM <em class="replaceable"><code>tbl_name</code></em>;</code></strong>
</pre><p>
      この <code class="literal">SELECT</code> ステートメントの場合、MySQL は、カラム 1 が文字列であり、<code class="literal">@a</code> が 2 行目の数値に設定されていても、@a のすべてのアクセスを文字列に変換すると、クライアントにレポートします。<code class="literal">SELECT</code> ステートメントの実行後、<code class="literal">@a</code> は次のステートメントの数値と見なされます。
    </p><p>
      この動作による問題を回避するには、単一のステートメント内で同じ変数に値を割り当ててその値を読み取ることを行わないか、使用する前に変数を <code class="literal">0</code>、<code class="literal">0.0</code>、または <code class="literal">''</code> に設定して、その型を定義してください。
    </p><p>
      <code class="literal">SELECT</code> ステートメントでは、それぞれの選択式は、クライアントに送信されるときにのみ評価されます。つまり、<code class="literal">HAVING</code>、<code class="literal">GROUP BY</code>、または <code class="literal">ORDER BY</code> 句では、選択式リストで値を割り当てられた変数を参照しても、予想どおりには機能し<span class="emphasis"><em>ない</em></span>ということです。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT (@aa:=id) AS a, (@aa+3) AS b FROM <em class="replaceable"><code>tbl_name</code></em> HAVING b=5;</code></strong>
</pre><p>
      <code class="literal">HAVING</code> 句での <code class="literal">b</code> の参照は、<code class="literal">@aa</code> を使用する選択リスト内の式のエイリアスを参照します。これは予想どおりには機能しません。<code class="literal">@aa</code> には、現在の行ではなく、以前に選択した行の <code class="literal">id</code> の値が含まれます。
    </p><p>
      ユーザー変数は、データ値を提供するためのものです。これらは、テーブル名やデータベース名が想定されるコンテキストなどでの識別子または識別子の一部として、または <code class="literal">SELECT</code> などの予約語として、SQL ステートメントの中で直接使用することはできません。これは、次の例に示すように、変数が引用符で囲まれている場合でも同じです。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT c1 FROM t;</code></strong>
+----+
| c1 |
+----+
|  0 |
+----+
|  1 |
+----+
2 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SET @col = "c1";</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT @col FROM t;</code></strong>
+------+
| @col |
+------+
| c1   |
+------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT `@col` FROM t;</code></strong>
<span class="errortext">ERROR 1054 (42S22): Unknown column '@col' in 'field list'</span>

mysql&gt; SET @col = "`c1`";
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT @col FROM t;</code></strong>
+------+
| @col |
+------+
| `c1` |
+------+
1 row in set (0.00 sec)
</pre><p>
      識別子を提供するためにユーザー変数を使用できないというこの原則の例外が、あとから実行する準備されたステートメントとして使用するために文字列を構築している場合です。この場合、ユーザー変数はステートメントの一部を提供するために使用できます。次の例は、その方法を示しています。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET @c = "c1";</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SET @s = CONCAT("SELECT ", @c, " FROM t");</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>PREPARE stmt FROM @s;</code></strong>
Query OK, 0 rows affected (0.04 sec)
Statement prepared

mysql&gt; <strong class="userinput"><code>EXECUTE stmt;</code></strong>
+----+
| c1 |
+----+
|  0 |
+----+
|  1 |
+----+
2 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>DEALLOCATE PREPARE stmt;</code></strong>
Query OK, 0 rows affected (0.00 sec)
</pre><p>
      詳細は、<a class="xref" href="sql-syntax.html#sql-syntax-prepared-statements" title="13.5 準備済みステートメントのための SQL 構文">セクション13.5「準備済みステートメントのための SQL 構文」</a>を参照してください。
    </p><p>
      PHP 5 を使用して次に示すように、同じような手法をアプリケーションプログラムの中で使用することによって、プログラム変数を使用する SQL ステートメントを作成できます。
    </p><pre class="programlisting">
&lt;?php
  $mysqli = new mysqli("localhost", "user", "pass", "test");

  if( mysqli_connect_errno() )
    die("Connection failed: %s\n", mysqli_connect_error());

  $col = "c1";

  $query = "SELECT $col FROM t";

  $result = $mysqli-&gt;query($query);

  while($row = $result-&gt;fetch_assoc())
  {
    echo "&lt;p&gt;" . $row["$col"] . "&lt;/p&gt;\n";
  }

  $result-&gt;close();

  $mysqli-&gt;close();
?&gt;
</pre><p>
      この方法で SQL ステートメントを作成することを<span class="quote">「<span class="quote">ダイナミック SQL</span>」</span>と呼ぶことがあります。
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="expressions"></a>9.5 式の構文</h2></div></div></div><a class="indexterm" name="idm139979107858160"></a><p>
      次のルールによって、MySQL での式の構文が定義されます。ここで示す文法は、MySQL ソース配布の <code class="filename">sql/sql_yacc.yy</code> ファイルで与えられた文法に基づいています。一部の条件に関する追加情報については、文法のあとに表示される注意事項を参照してください。
    </p><pre class="programlisting">
<em class="replaceable"><code>expr</code></em>:
    <em class="replaceable"><code>expr</code></em> OR <em class="replaceable"><code>expr</code></em>
  | <em class="replaceable"><code>expr</code></em> || <em class="replaceable"><code>expr</code></em>
  | <em class="replaceable"><code>expr</code></em> XOR <em class="replaceable"><code>expr</code></em>
  | <em class="replaceable"><code>expr</code></em> AND <em class="replaceable"><code>expr</code></em>
  | <em class="replaceable"><code>expr</code></em> &amp;&amp; <em class="replaceable"><code>expr</code></em>
  | NOT <em class="replaceable"><code>expr</code></em>
  | ! <em class="replaceable"><code>expr</code></em>
  | <em class="replaceable"><code>boolean_primary</code></em> IS [NOT] {TRUE | FALSE | UNKNOWN}
  | <em class="replaceable"><code>boolean_primary</code></em>

<em class="replaceable"><code>boolean_primary</code></em>:
    <em class="replaceable"><code>boolean_primary</code></em> IS [NOT] NULL
  | <em class="replaceable"><code>boolean_primary</code></em> &lt;=&gt; <em class="replaceable"><code>predicate</code></em>
  | <em class="replaceable"><code>boolean_primary</code></em> <em class="replaceable"><code>comparison_operator</code></em> <em class="replaceable"><code>predicate</code></em>
  | <em class="replaceable"><code>boolean_primary</code></em> <em class="replaceable"><code>comparison_operator</code></em> {ALL | ANY} (<em class="replaceable"><code>subquery</code></em>)
  | <em class="replaceable"><code>predicate</code></em>

<em class="replaceable"><code>comparison_operator</code></em>: = | &gt;= | &gt; | &lt;= | &lt; | &lt;&gt; | !=

<em class="replaceable"><code>predicate</code></em>:
    <em class="replaceable"><code>bit_expr</code></em> [NOT] IN (<em class="replaceable"><code>subquery</code></em>)
  | <em class="replaceable"><code>bit_expr</code></em> [NOT] IN (<em class="replaceable"><code>expr</code></em> [, <em class="replaceable"><code>expr</code></em>] ...)
  | <em class="replaceable"><code>bit_expr</code></em> [NOT] BETWEEN <em class="replaceable"><code>bit_expr</code></em> AND <em class="replaceable"><code>predicate</code></em>
  | <em class="replaceable"><code>bit_expr</code></em> SOUNDS LIKE <em class="replaceable"><code>bit_expr</code></em>
  | <em class="replaceable"><code>bit_expr</code></em> [NOT] LIKE <em class="replaceable"><code>simple_expr</code></em> [ESCAPE <em class="replaceable"><code>simple_expr</code></em>]
  | <em class="replaceable"><code>bit_expr</code></em> [NOT] REGEXP <em class="replaceable"><code>bit_expr</code></em>
  | <em class="replaceable"><code>bit_expr</code></em>

<em class="replaceable"><code>bit_expr</code></em>:
    <em class="replaceable"><code>bit_expr</code></em> | <em class="replaceable"><code>bit_expr</code></em>
  | <em class="replaceable"><code>bit_expr</code></em> &amp; <em class="replaceable"><code>bit_expr</code></em>
  | <em class="replaceable"><code>bit_expr</code></em> &lt;&lt; <em class="replaceable"><code>bit_expr</code></em>
  | <em class="replaceable"><code>bit_expr</code></em> &gt;&gt; <em class="replaceable"><code>bit_expr</code></em>
  | <em class="replaceable"><code>bit_expr</code></em> + <em class="replaceable"><code>bit_expr</code></em>
  | <em class="replaceable"><code>bit_expr</code></em> - <em class="replaceable"><code>bit_expr</code></em>
  | <em class="replaceable"><code>bit_expr</code></em> * <em class="replaceable"><code>bit_expr</code></em>
  | <em class="replaceable"><code>bit_expr</code></em> / <em class="replaceable"><code>bit_expr</code></em>
  | <em class="replaceable"><code>bit_expr</code></em> DIV <em class="replaceable"><code>bit_expr</code></em>
  | <em class="replaceable"><code>bit_expr</code></em> MOD <em class="replaceable"><code>bit_expr</code></em>
  | <em class="replaceable"><code>bit_expr</code></em> % <em class="replaceable"><code>bit_expr</code></em>
  | <em class="replaceable"><code>bit_expr</code></em> ^ <em class="replaceable"><code>bit_expr</code></em>
  | <em class="replaceable"><code>bit_expr</code></em> + <em class="replaceable"><code>interval_expr</code></em>
  | <em class="replaceable"><code>bit_expr</code></em> - <em class="replaceable"><code>interval_expr</code></em>
  | <em class="replaceable"><code>simple_expr</code></em>

<em class="replaceable"><code>simple_expr</code></em>:
    <em class="replaceable"><code>literal</code></em>
  | <em class="replaceable"><code>identifier</code></em>
  | <em class="replaceable"><code>function_call</code></em>
  | <em class="replaceable"><code>simple_expr</code></em> COLLATE <em class="replaceable"><code>collation_name</code></em>
  | <em class="replaceable"><code>param_marker</code></em>
  | <em class="replaceable"><code>variable</code></em>
  | <em class="replaceable"><code>simple_expr</code></em> || <em class="replaceable"><code>simple_expr</code></em>
  | + <em class="replaceable"><code>simple_expr</code></em>
  | - <em class="replaceable"><code>simple_expr</code></em>
  | ~ <em class="replaceable"><code>simple_expr</code></em>
  | ! <em class="replaceable"><code>simple_expr</code></em>
  | BINARY <em class="replaceable"><code>simple_expr</code></em>
  | (<em class="replaceable"><code>expr</code></em> [, <em class="replaceable"><code>expr</code></em>] ...)
  | ROW (<em class="replaceable"><code>expr</code></em>, <em class="replaceable"><code>expr</code></em> [, <em class="replaceable"><code>expr</code></em>] ...)
  | (<em class="replaceable"><code>subquery</code></em>)
  | EXISTS (<em class="replaceable"><code>subquery</code></em>)
  | {<em class="replaceable"><code>identifier</code></em> <em class="replaceable"><code>expr</code></em>}
  | <em class="replaceable"><code>match_expr</code></em>
  | <em class="replaceable"><code>case_expr</code></em>
  | <em class="replaceable"><code>interval_expr</code></em>
</pre><p>
      注:
    </p><p>
      演算子の優先順位については、<a class="xref" href="functions.html#operator-precedence" title="12.3.1 演算子の優先順位">セクション12.3.1「演算子の優先順位」</a>を参照してください。
    </p><p>
      リテラル値の構文については、<a class="xref" href="language-structure.html#literals" title="9.1 リテラル値">セクション9.1「リテラル値」</a>を参照してください。
    </p><p>
      識別子の構文については、<a class="xref" href="language-structure.html#identifiers" title="9.2 スキーマオブジェクト名">セクション9.2「スキーマオブジェクト名」</a>を参照してください。
    </p><p>
      変数には、ユーザー変数、システム変数、ストアドプログラムのローカル変数またはパラメータがあります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ユーザー変数: <a class="xref" href="language-structure.html#user-variables" title="9.4 ユーザー定義変数">セクション9.4「ユーザー定義変数」</a>
        </p></li><li class="listitem"><p>
          システム変数: <a class="xref" href="server-administration.html#using-system-variables" title="5.1.5 システム変数の使用">セクション5.1.5「システム変数の使用」</a>
        </p></li><li class="listitem"><p>
          ローカル変数: <a class="xref" href="sql-syntax.html#declare-local-variable" title="13.6.4.1 ローカル変数の DECLARE 構文">セクション13.6.4.1「ローカル変数の DECLARE 構文」</a>
        </p></li><li class="listitem"><p>
          パラメータ: <a class="xref" href="sql-syntax.html#create-procedure" title="13.1.15 CREATE PROCEDURE および CREATE FUNCTION 構文">セクション13.1.15「CREATE PROCEDURE および CREATE FUNCTION 構文」</a>
        </p></li></ul></div><p>
      <em class="replaceable"><code>param_marker</code></em> は、準備されたステートメントでプレースホルダーに使用されているように <code class="literal">?</code> です。<a class="xref" href="sql-syntax.html#prepare" title="13.5.1 PREPARE 構文">セクション13.5.1「PREPARE 構文」</a>を参照してください。
    </p><p>
      <code class="literal">(<em class="replaceable"><code>subquery</code></em>)</code> は、単一の値を返すサブクエリー、つまりスカラーサブクエリーを示します。<a class="xref" href="sql-syntax.html#scalar-subqueries" title="13.2.10.1 スカラーオペランドとしてのサブクエリー">セクション13.2.10.1「スカラーオペランドとしてのサブクエリー」</a>を参照してください。
    </p><p>
      <code class="literal">{<em class="replaceable"><code>identifier</code></em> <em class="replaceable"><code>expr</code></em>}</code> は、ODBC エスケープ構文であり、ODBC との互換性のために認められています。値は <em class="replaceable"><code>expr</code></em> です。構文内のカールした中括弧は文字どおりに書き込まれる必要があります。それらは構文説明の別の部分で利用されているようなメタ構文ではありません。
    </p><p>
      <em class="replaceable"><code>match_expr</code></em> は <code class="literal">MATCH</code> 式を示します。<a class="xref" href="functions.html#fulltext-search" title="12.9 全文検索関数">セクション12.9「全文検索関数」</a>を参照してください。
    </p><p>
      <em class="replaceable"><code>case_expr</code></em> は <code class="literal">CASE</code> 式を示します。<a class="xref" href="functions.html#control-flow-functions" title="12.4 制御フロー関数">セクション12.4「制御フロー関数」</a>を参照してください。
    </p><p>
      <em class="replaceable"><code>interval_expr</code></em> は時間間隔を表します。構文は <code class="literal">INTERVAL <em class="replaceable"><code>expr</code></em> <em class="replaceable"><code>unit</code></em></code> です。ここで <em class="replaceable"><code>unit</code></em> は <code class="literal">HOUR</code>、<code class="literal">DAY</code>、<code class="literal">WEEK</code> などの指定子です。<em class="replaceable"><code>unit</code></em> 指定子の完全なリストについては、<a class="xref" href="functions.html#date-and-time-functions" title="12.7 日付および時間関数">セクション12.7「日付および時間関数」</a>の <code class="literal">DATE_ADD()</code> 関数の説明を参照してください。
    </p><p>
      一部の演算子の意味は、SQL モードによって異なります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          デフォルトでは、<code class="literal">||</code> は論理 <code class="literal">OR</code> 演算子です。<code class="literal">PIPES_AS_CONCAT</code> が有効になっている場合は、<code class="literal">||</code> は <code class="literal">^</code> と単項演算子間の優先順位を持つ文字列連結です。
        </p></li><li class="listitem"><p>
          デフォルトでは、<code class="literal">!</code> は <code class="literal">NOT</code> よりも高い優先順位です。<code class="literal">HIGH_NOT_PRECEDENCE</code> が有効になっている場合は、<code class="literal">!</code> と <code class="literal">NOT</code> の優先順位は同じです。
        </p></li></ul></div><p>
      <a class="xref" href="server-administration.html#sql-mode" title="5.1.7 サーバー SQL モード">セクション5.1.7「サーバー SQL モード」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="comments"></a>9.6 コメントの構文</h2></div></div></div><a class="indexterm" name="idm139979107762064"></a><a class="indexterm" name="idm139979107760592"></a><p>
      MySQL Server では、次の 3 つのコメントスタイルをサポートしています。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <span class="quote">「<span class="quote"><code class="literal">#</code></span>」</span>文字から行末まで。
        </p></li><li class="listitem"><p>
          <span class="quote">「<span class="quote"><code class="literal">-- </code></span>」</span>シーケンスから行末まで。MySQL では、<span class="quote">「<span class="quote"><code class="literal">-- </code></span>」</span> (二重ダッシュ) のコメントスタイルは、2 番目のダッシュに少なくとも 1 つの空白または制御文字 (空白、タブ、改行など) を続ける必要があります。<a class="xref" href="introduction.html#ansi-diff-comments" title="1.8.2.5 コメントの先頭としての「--」">セクション1.8.2.5「コメントの先頭としての「--」」</a>で述べているように、この構文は標準 SQL のコメントの構文とは少し異なります。
        </p></li><li class="listitem"><p>
          C プログラミング言語のように、<code class="literal">/*</code> シーケンスから次の <code class="literal">*/</code> シーケンスまで。この構文では、開始と終了のシーケンスは同じ行にある必要はないので、複数の行にわたってコメントを記すことができます。
        </p></li></ul></div><p>
      次の例には、3 つのコメントスタイルがすべて示されています。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT 1+1;     # This comment continues to the end of line</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT 1+1;     -- This comment continues to the end of line</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT 1 /* this is an in-line comment */ + 1;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT 1+</code></strong>
<strong class="userinput"><code>/*</code></strong>
<strong class="userinput"><code>this is a</code></strong>
<strong class="userinput"><code>multiple-line comment</code></strong>
<strong class="userinput"><code>*/</code></strong>
<strong class="userinput"><code>1;</code></strong>
</pre><p>
      ネストされたコメントはサポートされていません。(一部の条件下では、ネストされたコメントが可能な場合がありますが、通常は可能ではなく、ユーザーはネストされたコメントを使用しないでください。)
    </p><p>
      MySQL Server では C-スタイルコメントのバリアントがいくつかサポートされています。これらでは、次の形式のコメントを使用することにより、MySQL 拡張を含んでいるが、移植性を維持しているコードを記述できます。
    </p><pre class="programlisting">
/*! <em class="replaceable"><code>MySQL-specific code</code></em> */
</pre><p>
      この場合、MySQL Server は、ほかの SQL ステートメントのようにコメント内のコードを構文解析して実行しますが、ほかの SQL サーバーはその拡張機能を認識しません。たとえば、MySQL Server は次のステートメント内の <code class="literal">STRAIGHT_JOIN</code> キーワードを認識しますが、ほかのサーバーは認識しません。
    </p><pre class="programlisting">
SELECT /*! STRAIGHT_JOIN */ col1 FROM table1,table2 WHERE ...
</pre><p>
      <span class="quote">「<span class="quote"><code class="literal">!</code></span>」</span>文字のあとにバージョン番号を追加すると、コメント内の構文は、MySQL のバージョンが指定されたバージョン番号以上の場合にだけ実行されます。次のコメント内の <code class="literal">TEMPORARY</code> キーワードは MySQL 3.23.02 以降のサーバーでのみ実行されます。
    </p><pre class="programlisting">
CREATE /*!32302 TEMPORARY */ TABLE t (a INT);
</pre><p>
      前述のコメントの構文は、<span class="command"><strong>mysqld</strong></span> サーバーによる SQL ステートメントの構文解析に適用されます。<span class="command"><strong>mysql</strong></span> クライアントプログラムは、ステートメントをサーバーに送信する前に、その一部の構文解析も実行します。(これは複数ステートメント入力行で、ステートメント境界を決定するために行われます。)
    </p><p>
      この形式のコメント (<code class="literal">/*!12345 ... */</code>) はサーバーに格納されません。ストアドルーチンのコメントにこの形式が使用されている場合、このコメントはサーバーで保持されません。
    </p><p>
      複数行にわたる <code class="literal">/* ... */</code> コメント内で、<code class="literal">\C</code> などの短い形式の <span class="command"><strong>mysql</strong></span> コマンドを使用することはサポートされていません。
    </p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="optimization.html">前</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="globalization.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第 8 章 最適化 </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 第 10 章 グローバリゼーション</td></tr></table></div><div class="copyright-footer"></div></body></html>
