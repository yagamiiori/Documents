<html lang="ja"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>第 17 章 レプリケーション</title><link rel="stylesheet" type="text/css" href="mvl.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="MySQL 5.6 リファレンスマニュアル"><link rel="up" href="index.html" title="MySQL 5.6 リファレンスマニュアル"><link rel="prev" href="ha-overview.html" title="第 16 章 高可用性と拡張性"><link rel="next" href="mysql-cluster.html" title="第 18 章 MySQL Cluster NDB 7.3 および MySQL Cluster NDB 7.4">
<script language="javascript" type="text/javascript">
  function addOnload(theFunc)
  {
    var previous = window.onload;
    if (typeof window.onload != 'function')
    {
      window.onload = theFunc;
    }
    else
    {
      window.onload = function()
      {
        previous();
        theFunc();
      }
    }
  }

  addOnload(function()
  {
    var base = new Date(1442918127*1000);
    var now = new Date();
    var diff = ((now-base)/1000)/(24*3600);

    if (diff > 90) {
      var nodes = document.getElementsByClassName('titlepage');
      nodes[0].innerHTML = '<p style="border: 5px #ff0000 solid; padding: 5px; margin 5px">' +
        'This copy of the manual is more than 90 days old. We encourage you to download a ' +
        'new version from <a href="http://dev.mysql.com">dev.mysql.com/doc</a>.</p>' + nodes[0].innerHTML;
    }
  });
</script>
<noscript></noscript>
</head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第 17 章 レプリケーション</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ha-overview.html">前</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="mysql-cluster.html">次へ</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="replication"></a>第 17 章 レプリケーション</h1></div></div></div><div class="toc"><p><b>目次</b></p><dl class="toc"><dt><span class="section"><a href="replication.html#replication-configuration">17.1 レプリケーション構成</a></span></dt><dd><dl><dt><span class="section"><a href="replication.html#replication-howto">17.1.1 レプリケーションのセットアップ方法</a></span></dt><dt><span class="section"><a href="replication.html#replication-formats">17.1.2 レプリケーション形式</a></span></dt><dt><span class="section"><a href="replication.html#replication-gtids">17.1.3 グローバルトランザクション識別子を使用したレプリケーション</a></span></dt><dt><span class="section"><a href="replication.html#replication-options">17.1.4 レプリケーションおよびバイナリロギングのオプションと変数</a></span></dt><dt><span class="section"><a href="replication.html#replication-administration">17.1.5 一般的なレプリケーション管理タスク</a></span></dt></dl></dd><dt><span class="section"><a href="replication.html#replication-implementation">17.2 レプリケーションの実装</a></span></dt><dd><dl><dt><span class="section"><a href="replication.html#replication-implementation-details">17.2.1 レプリケーション実装の詳細</a></span></dt><dt><span class="section"><a href="replication.html#slave-logs">17.2.2 レプリケーションリレーおよびステータスログ</a></span></dt><dt><span class="section"><a href="replication.html#replication-rules">17.2.3 サーバーがレプリケーションフィルタリングルールをどのように評価するか</a></span></dt></dl></dd><dt><span class="section"><a href="replication.html#replication-solutions">17.3 レプリケーションソリューション</a></span></dt><dd><dl><dt><span class="section"><a href="replication.html#replication-solutions-backups">17.3.1 バックアップ用にレプリケーションを使用する</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-diffengines">17.3.2 異なるマスターおよびスレーブストレージエンジンでレプリケーションを使用する</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-scaleout">17.3.3 スケールアウトのためにレプリケーションを使用する</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-partitioning">17.3.4 異なるデータベースを異なるスレーブに複製する</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-performance">17.3.5 レプリケーションパフォーマンスを改善する</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-switch">17.3.6 フェイルオーバー中にマスターを切り替える</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-ssl">17.3.7 SSL を使用してレプリケーションをセットアップする</a></span></dt><dt><span class="section"><a href="replication.html#replication-semisync">17.3.8 準同期レプリケーション</a></span></dt><dt><span class="section"><a href="replication.html#replication-delayed">17.3.9 遅延レプリケーション</a></span></dt></dl></dd><dt><span class="section"><a href="replication.html#replication-notes">17.4 レプリケーションの注釈とヒント</a></span></dt><dd><dl><dt><span class="section"><a href="replication.html#replication-features">17.4.1 レプリケーションの機能と問題</a></span></dt><dt><span class="section"><a href="replication.html#replication-compatibility">17.4.2 MySQL バージョン間のレプリケーション互換性</a></span></dt><dt><span class="section"><a href="replication.html#replication-upgrade">17.4.3 レプリケーションセットアップをアップグレードする</a></span></dt><dt><span class="section"><a href="replication.html#replication-problems">17.4.4 レプリケーションのトラブルシューティング</a></span></dt><dt><span class="section"><a href="replication.html#replication-bugs">17.4.5 レプリケーションバグまたは問題を報告する方法</a></span></dt></dl></dd></dl></div><a class="indexterm" name="idm139979056078080"></a><a class="indexterm" name="idm139979056076624"></a><a class="indexterm" name="idm139979056074592"></a><a class="indexterm" name="idm139979056072528"></a><p>
    レプリケーションによって、1 つの MySQL データベースサーバー (マスター) のデータを、1 つまたは複数の MySQL データベースサーバー (スレーブ) に複製できます。レプリケーションはデフォルトで非同期であるため、スレーブはマスターから更新を受け取るために永続的に接続されている必要はありません。これは、長距離間接続でも、さらにダイアルアップサービスのような一時的または断続的接続上でも更新が可能であることを意味しています。構成に応じて、すべてのデータベース、選択したデータベース、さらにデータベース内の選択したテーブルを複製できます。
  </p><p>
    MySQL Replication をはじめて使用する人がよくする質問の回答については、<a class="xref" href="faqs.html#faqs-replication" title="A.13 MySQL 5.6 FAQ: レプリケーション">セクションA.13「MySQL 5.6 FAQ: レプリケーション」</a>を参照してください。
  </p><p>
    MySQL のレプリケーションの長所は次のとおりです。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        スケールアウトソリューション - パフォーマンスの向上のために複数のスレーブに負荷を分散します。この環境では、すべての書き込みと更新をマスターサーバーで実行する必要があります。ただし、読み取りの場合は、1 つ以上のスレーブで実行してもかまいません。このモデルでは、書き込みのパフォーマンスを向上させながら (マスターが更新専用であるため)、スレーブ数が増加しても読み取り速度を劇的に速めることができます。
      </p></li><li class="listitem"><p>
        データセキュリティー - データはスレーブに複製され、スレーブはレプリケーションプロセスを一時停止できるため、対応するマスターデータを壊すことなくスレーブでバックアップサービスを実行できます。
      </p></li><li class="listitem"><p>
        分析 - マスターでライブデータを作成しながら、スレーブで情報の分析を実行できるため、マスターのパフォーマンスに影響しません。
      </p></li><li class="listitem"><p>
        長距離データ配布 - 支店でメインデータのコピーを使用して作業する場合に、レプリケーションを使用してデータのローカルコピーを作成してそれらを使用できます (マスターへの永続的なアクセスは不要)。
      </p></li></ul></div><p>
    MySQL のレプリケーションの特徴は、一方向の非同期レプリケーションをサポートしていることであり、1 つのサーバーがマスターとして機能し、1 つまたは複数のサーバーがスレーブとして機能します。これは、MySQL クラスタの特徴である<span class="emphasis"><em>同期</em></span>レプリケーションとは対照的です (<a class="xref" href="mysql-cluster.html" title="第 18 章 MySQL Cluster NDB 7.3 および MySQL Cluster NDB 7.4">第18章「<i>MySQL Cluster NDB 7.3 および MySQL Cluster NDB 7.4</i>」</a>を参照してください)。MySQL 5.6 では、組み込みの非同期レプリケーションに加えて、準同期レプリケーションへのインタフェースがサポートされています。準同期レプリケーションでは、マスター側で実行されたコミットは、トランザクションを実行したセッションに戻る前に、少なくとも 1 つのスレーブがトランザクションのイベントを受け取ってログに記録したことを通知するまでブロックされます。<a class="xref" href="replication.html#replication-semisync" title="17.3.8 準同期レプリケーション">セクション17.3.8「準同期レプリケーション」</a>を参照してください。MySQL 5.6 は、スレーブサーバーが、少なくとも指定した時間だけ意図的にマスターより遅れるような遅延レプリケーションもサポートしています。<a class="xref" href="replication.html#replication-delayed" title="17.3.9 遅延レプリケーション">セクション17.3.9「遅延レプリケーション」</a>を参照してください。
  </p><p>
    2 つのサーバー間でレプリケーションをセットアップするために使用できるソリューションはいくつかありますが、最善の使用方法はデータの存在や使用しているエンジンタイプによって異なります。利用可能なオプションの詳細については、<a class="xref" href="replication.html#replication-howto" title="17.1.1 レプリケーションのセットアップ方法">セクション17.1.1「レプリケーションのセットアップ方法」</a>を参照してください。
  </p><p>
    レプリケーション形式の主要なタイプは 2 つあり、1 つは、SQL ステートメント全体を複製する Statement Based Replication (SBR: ステートメントベースレプリケーション)、もう 1 つは変更があった行だけを複製する Row Based Replication (RBR: 行ベースレプリケーション) です。3 つ目の Mixed Based Replication (MBR: ミックスベースレプリケーション) を使用することもできます。さまざまなレプリケーション形式の詳細については、<a class="xref" href="replication.html#replication-formats" title="17.1.2 レプリケーション形式">セクション17.1.2「レプリケーション形式」</a>を参照してください。MySQL 5.6 では、ステートメントベースの形式がデフォルトです。
  </p><p>
    MySQL 5.6.5 以降では、<em class="firstterm">グローバルトランザクション ID</em> (GTID) に基づくトランザクションレプリケーションをサポートしています。このタイプのレプリケーションを使用するときは、ログファイルまたはこれらのファイル内の位置と直接連携する必要がないため、共通する多くのレプリケーションタスクが大幅に単純化されます。GTID を使用するレプリケーションは完全にトランザクション対応であるため、マスターで確定されたすべてのトランザクションがスレーブでも適用されるかぎり、マスターとスレーブとの一貫性は保証されます。GTID および GTID ベースのレプリケーションの詳細については、<a class="xref" href="replication.html#replication-gtids" title="17.1.3 グローバルトランザクション識別子を使用したレプリケーション">セクション17.1.3「グローバルトランザクション識別子を使用したレプリケーション」</a>を参照してください。
  </p><p>
    レプリケーションは、いくつかのオプションと変数によって制御されます。これらは、レプリケーション、タイムアウト、データベース、およびデータベースとテーブルに適用できるフィルターのコア操作を制御します。利用可能なオプションの詳細については、<a class="xref" href="replication.html#replication-options" title="17.1.4 レプリケーションおよびバイナリロギングのオプションと変数">セクション17.1.4「レプリケーションおよびバイナリロギングのオプションと変数」</a>を参照してください。
  </p><p>
    レプリケーションを使用することで、いくつかの異なる問題を解決できます (パフォーマンスの問題、異なるデータベースのバックアップのサポート、より大きなソリューションの一部としてシステム障害を軽減する、など)。これらの問題の対処方法については、<a class="xref" href="replication.html#replication-solutions" title="17.3 レプリケーションソリューション">セクション17.3「レプリケーションソリューション」</a>を参照してください。
  </p><p>
    レプリケーション機能の詳細、バージョン互換性、アップグレード、および問題とその解決 (FAQ を含む) など、さまざまなデータ型とステートメントがレプリケーション中にどのように処理されるかに関する説明とヒントについては、<a class="xref" href="replication.html#replication-notes" title="17.4 レプリケーションの注釈とヒント">セクション17.4「レプリケーションの注釈とヒント」</a>を参照してください。
  </p><p>
    レプリケーションの実装、レプリケーションの仕組み、バイナリログのプロセスと内容、バックアップスレッド、およびステートメントの記録とレプリケーションの方法を決めるために使用されるルールの詳細については、<a class="xref" href="replication.html#replication-implementation" title="17.2 レプリケーションの実装">セクション17.2「レプリケーションの実装」</a>を参照してください。
  </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="replication-configuration"></a>17.1 レプリケーション構成</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-howto">17.1.1 レプリケーションのセットアップ方法</a></span></dt><dt><span class="section"><a href="replication.html#replication-formats">17.1.2 レプリケーション形式</a></span></dt><dt><span class="section"><a href="replication.html#replication-gtids">17.1.3 グローバルトランザクション識別子を使用したレプリケーション</a></span></dt><dt><span class="section"><a href="replication.html#replication-options">17.1.4 レプリケーションおよびバイナリロギングのオプションと変数</a></span></dt><dt><span class="section"><a href="replication.html#replication-administration">17.1.5 一般的なレプリケーション管理タスク</a></span></dt></dl></div><p>
    MySQL 内のサーバー間のレプリケーションはバイナリロギングのメカニズムに基づいています。マスター (データベースの変更元) として動作する MySQL インスタンスは、更新および変更を<span class="quote">「<span class="quote">イベント</span>」</span>としてバイナリログに書き込みます。バイナリログ内の情報は、記録されているデータベース変更に応じて異なるロギング形式で格納されます。スレーブは、マスターからバイナリログを読み取って、スレーブのローカルデータベースにあるバイナリログのイベントを実行するように構成されます。
  </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
      特定のイベントのログのみを記録するようにマスターを構成することはできません。
    </p></div><p>
    マスターはこのシナリオでは「<span class="quote">「<span class="quote">ダム</span>」</span>」です。いったんバイナリロギングが有効になると、すべてのステートメントはバイナリログに記録されます。各スレーブはバイナリログの内容全体のコピーを受け取ります。バイナリログのどのステートメントを実行するべきかを決めるのはスレーブの役割で、特定のイベントのログのみを記録するようにマスターを構成することはできません。特に指定しない場合は、マスターバイナリログのすべてのイベントがスレーブで実行されます。必要な場合、特定のデータベースまたはテーブルに適用するイベントだけを処理するようにスレーブを構成できます。
  </p><p>
    各スレーブはバイナリログ座標 (マスターから読み取って処理したファイル名とファイル内での位置) のレコードを保持します。これは、複数のスレーブがマスターに接続して同じバイナリログの別の部分を実行できることを意味します。スレーブはこのプロセスを制御するため、マスターの操作に影響を与えることなく、サーバーから個々のスレーブに接続したり接続解除したりできます。また、各スレーブはバイナリログ内の現在の位置を記録しているため、スレーブを接続解除し、再接続してから処理を再開できます。
  </p><p>
    マスターと各スレーブは一意 ID を使用して構成する必要があります (<code class="option">server-id</code> オプションを使用)。また、各スレーブは、マスターホスト名、ログファイル名、およびそのファイル内の位置に関する情報を使用して構成する必要があります。これらの詳細は、スレーブで <code class="literal">CHANGE MASTER TO</code> ステートメントを使用して MySQL セッション内から制御できます。詳細はスレーブのマスター情報リポジトリ  (ファイルまたはテーブル) に格納されます (<a class="xref" href="replication.html#slave-logs" title="17.2.2 レプリケーションリレーおよびステータスログ">セクション17.2.2「レプリケーションリレーおよびステータスログ」</a>を参照してください)。
  </p><p>
    このセクションでは、レプリケーション環境に必要なセットアップと構成について説明します。新しいレプリケーション環境を作成するための手順を追った説明を含みます。このセクションの主な内容は次のとおりです。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        レプリケーション用に 2 つ以上のサーバーをセットアップするためのガイドについては、<a class="xref" href="replication.html#replication-howto" title="17.1.1 レプリケーションのセットアップ方法">セクション17.1.1「レプリケーションのセットアップ方法」</a>で、システムの構成について扱い、マスターとスレーブ間でデータをコピーする方法について説明します。
      </p></li><li class="listitem"><p>
        バイナリログ内のイベントはいくつかの形式で記録されます。これらは、ステートメントベースレプリケーション (SBR) または行ベースレプリケーション (RBR) と呼ばれます。3 つ目のタイプ、混合形式レプリケーション (MIXED) は、SBR または RBR レプリケーションを自動的に使用し、必要に応じて SBR と RBR の両方の形式の利点を活用します。さまざまな形式については、<a class="xref" href="replication.html#replication-formats" title="17.1.2 レプリケーション形式">セクション17.1.2「レプリケーション形式」</a>を参照してください。
      </p></li><li class="listitem"><p>
        レプリケーションに適用するさまざまな構成のオプションと変数に関する詳細は、<a class="xref" href="replication.html#replication-options" title="17.1.4 レプリケーションおよびバイナリロギングのオプションと変数">セクション17.1.4「レプリケーションおよびバイナリロギングのオプションと変数」</a>を参照してください。
      </p></li><li class="listitem"><p>
        レプリケーションプロセスが開始されると、管理または監視はほとんど必要ありません。ただし、実行することが望ましい一般的なタスクに関するアドバイスについては、<a class="xref" href="replication.html#replication-administration" title="17.1.5 一般的なレプリケーション管理タスク">セクション17.1.5「一般的なレプリケーション管理タスク」</a>を参照してください。
      </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-howto"></a>17.1.1 レプリケーションのセットアップ方法</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-howto-masterbaseconfig">17.1.1.1 レプリケーションマスター構成の設定</a></span></dt><dt><span class="section"><a href="replication.html#replication-howto-slavebaseconfig">17.1.1.2 レプリケーションスレーブ構成の設定</a></span></dt><dt><span class="section"><a href="replication.html#replication-howto-repuser">17.1.1.3 レプリケーション用ユーザーの作成</a></span></dt><dt><span class="section"><a href="replication.html#replication-howto-masterstatus">17.1.1.4 レプリケーションマスターバイナリログ座標の取得</a></span></dt><dt><span class="section"><a href="replication.html#replication-howto-mysqldump">17.1.1.5 mysqldump を使用したデータスナップショットの作成</a></span></dt><dt><span class="section"><a href="replication.html#replication-howto-rawdata">17.1.1.6 ローデータファイルを使用したデータスナップショットの作成</a></span></dt><dt><span class="section"><a href="replication.html#replication-howto-newservers">17.1.1.7 新しいマスターとスレーブを使用したレプリケーションのセットアップ</a></span></dt><dt><span class="section"><a href="replication.html#replication-howto-existingdata">17.1.1.8 既存のデータによるレプリケーションのセットアップ</a></span></dt><dt><span class="section"><a href="replication.html#replication-howto-additionalslaves">17.1.1.9 既存のレプリケーション環境への追加スレーブの導入</a></span></dt><dt><span class="section"><a href="replication.html#replication-howto-slaveinit">17.1.1.10 スレーブでのマスター構成の設定</a></span></dt></dl></div><p>
      このセクションでは、MySQL サーバーの完全レプリケーションのセットアップ方法について説明します。レプリケーションのセットアップにはいくつかの異なる方法があり、使用する方法はレプリケーションをどのようにセットアップするか、およびマスターデータベース内にすでにデータがあるかどうかによって異なります。
    </p><p>
      すべてのレプリケーションセットアップに共通する汎用タスクがいくつかあります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          マスターでは、バイナリロギングを有効にして、一意サーバー ID を構成する必要があります。これには、サーバーの再起動が必要となる場合があります。<a class="xref" href="replication.html#replication-howto-masterbaseconfig" title="17.1.1.1 レプリケーションマスター構成の設定">セクション17.1.1.1「レプリケーションマスター構成の設定」</a>を参照してください。
        </p></li><li class="listitem"><p>
          マスターに接続する各スレーブでは、一意サーバー ID を構成する必要があります。これには、サーバーの再起動が必要となる場合があります。<a class="xref" href="replication.html#replication-howto-slavebaseconfig" title="17.1.1.2 レプリケーションスレーブ構成の設定">セクション17.1.1.2「レプリケーションスレーブ構成の設定」</a>を参照してください。
        </p></li><li class="listitem"><p>
          必要に応じて、スレーブ用に別のユーザーを作成し、レプリケーションのためにバイナリログを読み取る際のマスターでの認証に使用します。<a class="xref" href="replication.html#replication-howto-repuser" title="17.1.1.3 レプリケーション用ユーザーの作成">セクション17.1.1.3「レプリケーション用ユーザーの作成」</a>を参照してください。
        </p></li><li class="listitem"><p>
          データスナップショットを作成する前、またはレプリケーションプロセスを開始する前に、マスター上のバイナリログの位置を記録してください。この情報はスレーブを構成するときに必要になり、これによりスレーブはバイナリログ内のどこからイベントの実行を開始するかがわかります。<a class="xref" href="replication.html#replication-howto-masterstatus" title="17.1.1.4 レプリケーションマスターバイナリログ座標の取得">セクション17.1.1.4「レプリケーションマスターバイナリログ座標の取得」</a>を参照してください。
        </p></li><li class="listitem"><p>
          マスター上にすでにデータがあり、それを使用してスレーブと同期する場合は、データスナップショットを作成する必要があります。データベーススナップショットを作成するには、データベースのサイズとファイルの位置によって、さまざまな方法があります。

          


          スナップショットは、<span class="command"><strong>mysqldump</strong></span> (<a class="xref" href="replication.html#replication-howto-mysqldump" title="17.1.1.5 mysqldump を使用したデータスナップショットの作成">セクション17.1.1.5「mysqldump を使用したデータスナップショットの作成」</a>を参照してください) を使用するかデータファイルを直接コピーすることで (<a class="xref" href="replication.html#replication-howto-rawdata" title="17.1.1.6 ローデータファイルを使用したデータスナップショットの作成">セクション17.1.1.6「ローデータファイルを使用したデータスナップショットの作成」</a>を参照してください) 作成します。
        </p></li><li class="listitem"><p>
          ホスト名、ログイン資格証明、バイナリログファイルの名前と位置など、マスターに接続するための設定を使用してスレーブを構成します。<a class="xref" href="replication.html#replication-howto-slaveinit" title="17.1.1.10 スレーブでのマスター構成の設定">セクション17.1.1.10「スレーブでのマスター構成の設定」</a>を参照してください。
        </p></li></ul></div><p>
      基本オプションを構成したあとは、次のシナリオを選択します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          データを含まないマスターとスレーブのフレッシュインストールでレプリケーションをセットアップするには、<a class="xref" href="replication.html#replication-howto-newservers" title="17.1.1.7 新しいマスターとスレーブを使用したレプリケーションのセットアップ">セクション17.1.1.7「新しいマスターとスレーブを使用したレプリケーションのセットアップ」</a>を参照してください。
        </p></li><li class="listitem"><p>
          既存の MySQL サーバーのデータを使用して新しいマスターのレプリケーションをセットアップするには、<a class="xref" href="replication.html#replication-howto-existingdata" title="17.1.1.8 既存のデータによるレプリケーションのセットアップ">セクション17.1.1.8「既存のデータによるレプリケーションのセットアップ」</a>を参照してください。
        </p></li><li class="listitem"><p>
          既存のレプリケーション環境にレプリケーションのスレーブを追加するには、<a class="xref" href="replication.html#replication-howto-additionalslaves" title="17.1.1.9 既存のレプリケーション環境への追加スレーブの導入">セクション17.1.1.9「既存のレプリケーション環境への追加スレーブの導入」</a>を参照してください。
        </p></li></ul></div><p>
      MySQL レプリケーションサーバーを管理する前に、この章全体を読み、<a class="xref" href="sql-syntax.html#replication-master-sql" title="13.4.1 マスターサーバーを制御するための SQL ステートメント">セクション13.4.1「マスターサーバーを制御するための SQL ステートメント」</a>と<a class="xref" href="sql-syntax.html#replication-slave-sql" title="13.4.2 スレーブサーバーを制御するための SQL ステートメント">セクション13.4.2「スレーブサーバーを制御するための SQL ステートメント」</a>で説明したすべてのステートメントを試みてください。また、<a class="xref" href="replication.html#replication-options" title="17.1.4 レプリケーションおよびバイナリロギングのオプションと変数">セクション17.1.4「レプリケーションおよびバイナリロギングのオプションと変数」</a>で説明されたレプリケーションの起動オプションについても習得してください。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        セットアッププロセスのあるステップでは、<code class="literal">SUPER</code> 権限が必要です。この権限がないと、レプリケーションを有効にできない可能性があります。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-howto-masterbaseconfig"></a>17.1.1.1 レプリケーションマスター構成の設定</h4></div></div></div><p>
        レプリケーションマスターでは、バイナリロギングを有効にして、一意サーバー ID を作成する必要があります。これがまだ行われていなかった場合、サーバーの再起動が必要です。
      </p><p>
        バイナリログがマスターからスレーブへ変更を複製するための基盤であるため、バイナリロギングがマスターで有効である<span class="emphasis"><em>必要</em></span>があります。バイナリロギングが <code class="literal">log-bin</code> オプションを使用して有効化されていないと、レプリケーションはできません。
      </p><p>
        レプリケーショングループ内の各サーバーは、一意サーバー ID を使用して構成する必要があります。この ID はグループ内の個々のサーバーを特定するために使用され、1 から (2<sup>32</sup>) - 1 の間の正の整数でなければいけません。番号をどのように編成および選択するかは任意です。
      </p><p>
        バイナリログとサーバー ID のオプションを構成するには、MySQL サーバーをシャットダウンして、<code class="filename">my.cnf</code> または <code class="filename">my.ini</code> ファイルを編集します。構成ファイルの <code class="literal">[mysqld]</code> セクションに、<code class="literal">log-bin</code> および <code class="literal">server-id</code> オプションを追加します。これらのオプションはすでに存在しているが、コメントアウトされている場合、そのオプションのコメントを解除して必要に応じて変更します。たとえば、<code class="literal">mysql-bin</code> のログファイル名プリフィクスを使用してバイナリロギングを有効にし、ID が 1 のサーバーを構成するには、次の行を使用します。
      </p><pre class="programlisting">
[mysqld]
log-bin=mysql-bin
server-id=1
</pre><p>
        変更したあとに、サーバーを再起動します。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="option">server-id</code> を省略すると (または明示的にデフォルト値の 0 に設定すると)、マスターはスレーブからのどのような接続も拒否します。
        </p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          トランザクション対応 <code class="literal">InnoDB</code> を使用するレプリケーションセットアップで持続性と一貫性をできるだけ高くするため、<code class="filename">my.cnf</code> ファイルで <code class="literal">innodb_flush_log_at_trx_commit=1</code> および <code class="literal">sync_binlog=1</code> を使用してください。
        </p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="option">skip-networking</code> オプションがレプリケーションマスターで有効になっていないことを確認します。ネットワーキングが無効化されていると、スレーブはマスターと通信できず、レプリケーションは失敗します。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-howto-slavebaseconfig"></a>17.1.1.2 レプリケーションスレーブ構成の設定</h4></div></div></div><p>
        レプリケーションスレーブでは、一意サーバー ID を作成する必要があります。これがまだ行われていなかった場合、この部分のスレーブセットアップにはサーバーの再起動が必要です。
      </p><p>
        スレーブサーバー ID がまだ設定されていない場合、または現在の値がマスターサーバーに選択した値と競合する場合は、スレーブサーバーをシャットダウンし、構成ファイルの <code class="literal">[mysqld]</code> セクションを編集して、一意サーバー ID を指定します。例:
      </p><pre class="programlisting">
[mysqld]
server-id=2
</pre><p>
        変更したあとに、サーバーを再起動します。
      </p><p>
        複数のスレーブをセットアップしている場合、それぞれのスレーブでは、一意 <code class="option">server-id</code> 値がマスターのものおよびほかのすべてのスレーブのものと異なる必要があります。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="option">server-id</code> を省略すると (または明示的にデフォルト値の 0 に設定すると)、スレーブはマスターへの接続を拒否します。
        </p></div><p>
        レプリケーションをセットアップするために、スレーブでバイナリロギングを有効にする必要はありません。ただし、スレーブでバイナリロギングを有効にすると、データバックアップとクラッシュリカバリにスレーブのバイナリログを使用でき、より複雑なレプリケーショントポロジの一部としてスレーブを使用することもできます。たとえばこの場合、このスレーブはほかのスレーブへのマスターとして動作します。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-howto-repuser"></a>17.1.1.3 レプリケーション用ユーザーの作成</h4></div></div></div><p>
        それぞれのスレーブは MySQL のユーザー名とパスワードを使用してマスターに接続するため、スレーブが接続に使用できるユーザーアカウントがマスター上になければいけません。この操作には、<code class="literal">REPLICATION SLAVE</code> 権限が付与されているすべてのアカウントを使用できます。スレーブごとに異なるアカウントを作成したり、各スレーブに同じアカウントを使用してマスターに接続したりすることを選択できます。
      </p><p>
        レプリケーション用に特別にアカウントを作成する必要はありませんが、レプリケーションのユーザー名とパスワードはマスターの情報リポジトリファイルまたはテーブルにプレーンテキストで格納されていることを確認してください (<a class="xref" href="replication.html#slave-logs-status" title="17.2.2.2 スレーブステータスログ">セクション17.2.2.2「スレーブステータスログ」</a>を参照してください)。このため、ほかのアカウントのセキュリティーを損なう可能性を最小限に抑えるため、レプリケーションプロセスにのみ権限を持つ別のアカウントを作成することをお勧めします。
      </p><p>
        新しいアカウントを作成するには、<code class="literal">CREATE USER</code> を使用します。レプリケーションに必要な権限をこのアカウントに付与するには、<code class="literal">GRANT</code> ステートメントを使用します。レプリケーションの目的にだけアカウントを作成する場合、そのアカウントには <code class="literal">REPLICATION SLAVE</code> 権限だけが必要です。たとえば、<code class="literal">mydomain.com</code> ドメイン内のホストからレプリケーションのために接続できる新しいユーザー <code class="literal">repl</code> をセットアップするには、マスター上で次のステートメントを発行します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE USER 'repl'@'%.mydomain.com' IDENTIFIED BY 'slavepass';</code></strong>
mysql&gt; <strong class="userinput"><code>GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%.mydomain.com';</code></strong>
</pre><p>
        ユーザーアカウントを操作するためのステートメントの詳細については、<a class="xref" href="sql-syntax.html#account-management-sql" title="13.7.1 アカウント管理ステートメント">セクション13.7.1「アカウント管理ステートメント」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-howto-masterstatus"></a>17.1.1.4 レプリケーションマスターバイナリログ座標の取得</h4></div></div></div><p>
        マスターバイナリログ内のマスターの現在座標を注目してください。この情報は、現在のポイントでレプリケーションプロセスを起動するようにスレーブを構成するために必要です。
      </p><p>
        レプリケーションプロセスを起動する前に、スレーブ上で同期する既存のデータがマスター上にある場合、マスターがステートメントの実行を継続するのを許可する前に、マスターでのステートメントの処理を停止してから、現在のバイナリログ座標を取得してそのデータをダンプする必要があります。ステートメントの実行を停止しない場合は、使用するデータダンプとマスターステータス情報が一致せず、スレーブ上でデータベースが一貫性を失ったり破損したりします。
      </p><p>
        マスターバイナリログ座標を取得するには、次の手順に従ってください。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            コマンド行クライアントでマスターに接続することでマスター上でセッションを起動し、<code class="literal">FLUSH TABLES WITH READ LOCK</code> ステートメントを実行することですべてのテーブルをフラッシュして書き込みステートメントをブロックします。
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>FLUSH TABLES WITH READ LOCK;</code></strong>
</pre><p>
            <code class="literal">InnoDB</code> テーブルの場合、<code class="literal">FLUSH TABLES WITH READ LOCK</code> は <code class="literal">COMMIT</code> 操作もブロックします。
          </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
              読み取りロックを有効のままにするため、<code class="literal">FLUSH TABLES</code> ステートメントを発行したクライアントを実行中のままにしてください。クライアントを終了すると、ロックは解除されます。
            </p></div></li><li class="listitem"><p>
            マスターの別のセッションで、<code class="literal">SHOW MASTER STATUS</code> ステートメントを使用して現在のバイナリログファイルの名前と位置を調べます。
          </p><pre class="programlisting">
mysql &gt; <strong class="userinput"><code>SHOW MASTER STATUS;</code></strong>
+------------------+----------+--------------+------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |
+------------------+----------+--------------+------------------+
| mysql-bin.000003 | 73       | test         | manual,mysql     |
+------------------+----------+--------------+------------------+
</pre><p>
            <code class="literal">File</code> カラムはログファイルの名前を表し、<code class="literal">Position</code> はファイル内の位置を表します。この例では、バイナリログファイルは <code class="literal">mysql-bin.000003</code> で、位置は 73 です。これらの値を記録します。これらは、あとでスレーブをセットアップするときに必要です。それらは、スレーブがマスターからの新しい更新の処理を始めるべきレプリケーション座標を表します。
          </p><p>
            バイナリロギングを有効にしないでマスターがすでに動作していた場合、<code class="literal">SHOW MASTER STATUS</code> または <span class="command"><strong>mysqldump --master-data</strong></span> が表示するログファイルの名前と位置の値は空になります。この場合、あとでスレーブのログファイルと位置を指定するときに使用する必要がある値は、空の文字列 (<code class="literal">''</code>) と <code class="literal">4</code> です。
          </p></li></ol></div><p>
        これで、スレーブがレプリケーションを開始する適切な位置でバイナリログから読み取りを開始するために必要な情報を入手しました。
      </p><p>
        レプリケーションを開始する前にスレーブと同期する必要がある既存のデータがある場合は、ロックが適切に維持されるようにクライアントを実行したままにしてから、<a class="xref" href="replication.html#replication-howto-mysqldump" title="17.1.1.5 mysqldump を使用したデータスナップショットの作成">セクション17.1.1.5「mysqldump を使用したデータスナップショットの作成」</a>または<a class="xref" href="replication.html#replication-howto-rawdata" title="17.1.1.6 ローデータファイルを使用したデータスナップショットの作成">セクション17.1.1.6「ローデータファイルを使用したデータスナップショットの作成」</a>に進んでください。ここでの意図は、スレーブにコピーされたデータがマスターと同期された状態であるように、これ以上の変更を避けることです。
      </p><p>
        まったく新しいマスターとスレーブのレプリケーショングループをセットアップしている場合、最初のセッションを終了して読み取りロックを解除できます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-howto-mysqldump"></a>17.1.1.5 mysqldump を使用したデータスナップショットの作成</h4></div></div></div><p>
        既存のマスターデータベースでデータのスナップショットを作成する 1 つの方法は、<span class="command"><strong>mysqldump</strong></span> ツールを使用して、複製するすべてのデータベースのダンプを作成することです。データダンプが完了したら、レプリケーションプロセスを開始する前に、このデータをスレーブにインポートします。
      </p><p>
        ここで示した例では、<code class="filename">dbdump.db</code> という名前のファイルにすべてのデータベースをダンプし、レプリケーションプロセスを開始するためにスレーブ側で必要な <code class="literal">CHANGE MASTER TO</code> ステートメントを自動的に加える <code class="option">--master-data</code> オプションを追加しています。
      </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>mysqldump --all-databases --master-data &gt; dbdump.db</code></strong>
</pre><p>
        <code class="option">--master-data</code> を使用しない場合は、個々のセッションですべてのテーブルを手動でロックしてから (<code class="literal">FLUSH TABLES WITH READ LOCK</code> を使用)、<span class="command"><strong>mysqldump</strong></span> を実行し、2 番目のセッションから終了するか UNLOCK TABLES を実行するかしてロックを解除する必要があります。また、<code class="literal">SHOW MASTER STATUS</code> を使用してスナップショットに一致するバイナリログ位置情報を取得し、これを使用してスレーブ起動時に対応する <code class="literal">CHANGE MASTER TO</code> ステートメントを発行する必要があります。
      </p><p>
        ダンプに含めるデータベースを選択するときに、各スレーブでレプリケーションプロセスに含めないデータベースを除外する必要があることを覚えておいてください。
      </p><p>
        データをインポートするには、ダンプファイルをスレーブにコピーするか、スレーブにリモートで接続したときにマスターからファイルにアクセスします。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-howto-rawdata"></a>17.1.1.6 ローデータファイルを使用したデータスナップショットの作成</h4></div></div></div><p>
        データベースが大きい場合、ローデータファイルをコピーする方が、<span class="command"><strong>mysqldump</strong></span> を使用して各スレーブでファイルをインポートするよりも、効率が高くなる場合があります。この方法では、<code class="literal">INSERT</code> ステートメントが繰り返されたときのインデックス更新のオーバーヘッドが省かれます。
      </p><p>
        複雑なキャッシュまたはロギングアルゴリズムを持つストレージエンジンのテーブルでこの方法を使用すると、完全な<span class="quote">「<span class="quote">ポイントインタイム</span>」</span>スナップショットを作成するための追加手順が必要となります。グローバル読み取りロックを獲得した場合、最初のコピーコマンドはキャッシュ情報とロギング更新が除外する場合があります。ストレージエンジンがこれにどのように反応するかは、そのクラッシュリカバリ能力によります。
      </p><p>
        

        マスターとスレーブで <code class="literal">ft_stopword_file</code>、<code class="literal">ft_min_word_len</code>、または <code class="literal">ft_max_word_len</code> の値が異なり、全文インデックスを持つテーブルをコピーする場合も、この方法が確実に機能するとはかぎりません。
      </p><p>
        <code class="literal">InnoDB</code> テーブルを使用する場合、MySQL Enterprise Backup コンポーネントから <span class="command"><strong>mysqlbackup</strong></span> コマンドを使用して、一貫性のあるスナップショットを作成できます。このコマンドは、あとでスレーブで使用するために、スナップショットに対応するログ名とオフセットを記録します。MySQL Enterprise Backup は MySQL Enterprise サブスクリプションの一部として同梱される製品です。詳細は、<a class="xref" href="mysql-enterprise.html#mysql-enterprise-backup" title="25.2 MySQL Enterprise Backup">セクション25.2「MySQL Enterprise Backup」</a>を参照してください。
      </p><p>
        または、<a class="link" href="glossary.html#glos_cold_backup" title="コールドバックアップ">コールドバックアップ</a>技術を使用して <code class="literal">InnoDB</code> テーブルの信頼できるバイナリスナップショットを取得します。MySQL Server の<a class="link" href="glossary.html#glos_slow_shutdown" title="低速シャットダウン">スローシャットダウン</a> を実行したあとにすべてのデータファイルをコピーします。
      </p><p>
        <code class="literal">MyISAM</code> テーブルのローデータスナップショットを作成するには、MySQL データファイルが単一ファイルシステム上に存在するという条件で、<span class="command"><strong>cp</strong></span>、<span class="command"><strong>copy</strong></span> などの標準コピーツール、<span class="command"><strong>scp</strong></span>、<span class="command"><strong>rsync</strong></span> などのリモートコピーツール、<span class="command"><strong>zip</strong></span>、<span class="command"><strong>tar</strong></span> などのアーカイブツール、<span class="command"><strong>dump</strong></span> などのファイルシステムスナップショットツールを使用できます。特定のデータベースだけを複製する場合、それらのテーブルに関係するファイルだけをコピーします。(<code class="literal">InnoDB</code> の場合、すべてのデータベースのすべてのテーブルは、<code class="option">innodb_file_per_table</code> オプションを有効にしている場合を除いて、<a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">system tablespace</a> ファイルに格納されます。)
      </p><p>
        次のファイルは明確にアーカイブから除外することをお勧めします。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">mysql</code> データベースに関連するファイル。
          </p></li><li class="listitem"><p>
            (使用する場合) マスター情報リポジトリファイル (<a class="xref" href="replication.html#slave-logs" title="17.2.2 レプリケーションリレーおよびステータスログ">セクション17.2.2「レプリケーションリレーおよびステータスログ」</a>を参照してください)。
          </p></li><li class="listitem"><p>
            マスターのバイナリログファイル。
          </p></li><li class="listitem"><p>
            リレーログファイル。
          </p></li></ul></div><p>
        ローデータスナップショットでもっとも一貫性のある結果を得るには、次のように、プロセス中にマスターサーバーをシャットダウンします。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            読み取りロックを獲得してマスターのステータスを取得します。<a class="xref" href="replication.html#replication-howto-masterstatus" title="17.1.1.4 レプリケーションマスターバイナリログ座標の取得">セクション17.1.1.4「レプリケーションマスターバイナリログ座標の取得」</a>を参照してください。
          </p></li><li class="listitem"><p>
            個別のセッションで、マスターサーバーをシャットダウンします。
          </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>mysqladmin shutdown</code></strong>
</pre></li><li class="listitem"><p>
            MySQL データファイルのコピーを作成します。次の例では、これを行うための一般的な方法を示します。この中の 1 つだけを選択する必要があります。
          </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>tar cf <em class="replaceable"><code>/tmp/db.tar</code></em> <em class="replaceable"><code>./data</code></em></code></strong>
shell&gt; <strong class="userinput"><code>zip -r <em class="replaceable"><code>/tmp/db.zip</code></em> <em class="replaceable"><code>./data</code></em></code></strong>
shell&gt; <strong class="userinput"><code>rsync --recursive <em class="replaceable"><code>./data</code></em> <em class="replaceable"><code>/tmp/dbdata</code></em></code></strong>
</pre></li><li class="listitem"><p>
            マスターサーバーを再起動します。
          </p></li></ol></div><p>
        <code class="literal">InnoDB</code> テーブルを使用しない場合、次の手順で説明するとおり、サーバーをシャットダウンしないでマスターからシステムのスナップショットを取得できます。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            読み取りロックを獲得してマスターのステータスを取得します。<a class="xref" href="replication.html#replication-howto-masterstatus" title="17.1.1.4 レプリケーションマスターバイナリログ座標の取得">セクション17.1.1.4「レプリケーションマスターバイナリログ座標の取得」</a>を参照してください。
          </p></li><li class="listitem"><p>
            MySQL データファイルのコピーを作成します。次の例では、これを行うための一般的な方法を示します。この中の 1 つだけを選択する必要があります。
          </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>tar cf <em class="replaceable"><code>/tmp/db.tar</code></em> <em class="replaceable"><code>./data</code></em></code></strong>
shell&gt; <strong class="userinput"><code>zip -r <em class="replaceable"><code>/tmp/db.zip</code></em> <em class="replaceable"><code>./data</code></em></code></strong>
shell&gt; <strong class="userinput"><code>rsync --recursive <em class="replaceable"><code>./data</code></em> <em class="replaceable"><code>/tmp/dbdata</code></em></code></strong>
</pre></li><li class="listitem"><p>
            読み取りロックを獲得したクライアントでは、ロックを解除します。
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>UNLOCK TABLES;</code></strong>
</pre></li></ol></div><p>
        データベースのアーカイブまたはコピーを作成したあと、スレーブレプリケーションプロセスを開始する前に、各スレーブにファイルをコピーします。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-howto-newservers"></a>17.1.1.7 新しいマスターとスレーブを使用したレプリケーションのセットアップ</h4></div></div></div><p>
        レプリケーションをセットアップするもっとも簡単で容易な方法は、新しいマスターおよびスレーブサーバーを使用することです。
      </p><p>
        新しいサーバーをセットアップしているけれども、レプリケーション構成にロードする、別のサーバーからのデータベースの既存のダンプがある場合、この方法も使用できます。データを新しいマスターにロードすることで、データはスレーブに自動的に複製されます。
      </p><p>
        新しいマスターとスレーブの間でレプリケーションをセットアップするには、次のようにします。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            必要な構成プロパティーで MySQL マスターを構成します。<a class="xref" href="replication.html#replication-howto-masterbaseconfig" title="17.1.1.1 レプリケーションマスター構成の設定">セクション17.1.1.1「レプリケーションマスター構成の設定」</a>を参照してください。
          </p></li><li class="listitem"><p>
            MySQL マスターをセットアップします。
          </p></li><li class="listitem"><p>
            ユーザーをセットアップします。<a class="xref" href="replication.html#replication-howto-repuser" title="17.1.1.3 レプリケーション用ユーザーの作成">セクション17.1.1.3「レプリケーション用ユーザーの作成」</a>を参照してください。
          </p></li><li class="listitem"><p>
            マスターステータス情報を取得します。<a class="xref" href="replication.html#replication-howto-masterstatus" title="17.1.1.4 レプリケーションマスターバイナリログ座標の取得">セクション17.1.1.4「レプリケーションマスターバイナリログ座標の取得」</a>を参照してください。
          </p></li><li class="listitem"><p>
            マスターで、読み取りロックを解除します。
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>UNLOCK TABLES;</code></strong>
</pre></li><li class="listitem"><p>
            スレーブで、MySQL 構成を編集します。<a class="xref" href="replication.html#replication-howto-slavebaseconfig" title="17.1.1.2 レプリケーションスレーブ構成の設定">セクション17.1.1.2「レプリケーションスレーブ構成の設定」</a>を参照してください。
          </p></li><li class="listitem"><p>
            MySQL スレーブを起動します。
          </p></li><li class="listitem"><p>
            <code class="literal">CHANGE MASTER TO</code> ステートメントを実行して、マスターレプリケーションサーバー構成を設定します。<a class="xref" href="replication.html#replication-howto-slaveinit" title="17.1.1.10 スレーブでのマスター構成の設定">セクション17.1.1.10「スレーブでのマスター構成の設定」</a>を参照してください。
          </p></li></ol></div><p>
        各スレーブでスレーブセットアップ手順を実行します。
      </p><p>
        新しいサーバー構成にはロードまたは交換するデータがないため、情報をコピーしたりインポートしたりする必要はありません。
      </p><p>
        別の既存データベースサーバーのデータを使用して新しいレプリケーション環境をセットアップする場合、そのサーバーから生成されたダンプファイルを新しいマスターで実行する必要があります。データベース更新は自動的にスレーブへ伝達されます。
      </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>mysql -h master &lt; fulldb.dump</code></strong>
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-howto-existingdata"></a>17.1.1.8 既存のデータによるレプリケーションのセットアップ</h4></div></div></div><p>
        既存データでレプリケーションをセットアップする場合、レプリケーションサービスを開始する前に、マスターからのデータをスレーブに取得するための最善の方法を決める必要があります。
      </p><p>
        既存のデータでレプリケーションをセットアップするための基本プロセスは次のとおりです。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            MySQL マスターが動作している状態で、レプリケーション中にマスターに接続するときにスレーブが使用するユーザーを作成します。<a class="xref" href="replication.html#replication-howto-repuser" title="17.1.1.3 レプリケーション用ユーザーの作成">セクション17.1.1.3「レプリケーション用ユーザーの作成」</a>を参照してください。
          </p></li><li class="listitem"><p>
            まだ <code class="option">server-id</code> を構成していなくて、マスターサーバーでバイナリロギングを有効にしていない場合は、これらのオプションを構成するためにサーバーをシャットダウンする必要があります。<a class="xref" href="replication.html#replication-howto-masterbaseconfig" title="17.1.1.1 レプリケーションマスター構成の設定">セクション17.1.1.1「レプリケーションマスター構成の設定」</a>を参照してください。
          </p><p>
            マスターサーバーをシャットダウンする必要がある場合は、そのデータベースのスナップショットを作成するための良い機会です。マスターを停止し、構成を更新し、スナップショットを作成する前に、マスターのステータスを取得してください (<a class="xref" href="replication.html#replication-howto-masterstatus" title="17.1.1.4 レプリケーションマスターバイナリログ座標の取得">セクション17.1.1.4「レプリケーションマスターバイナリログ座標の取得」</a>を参照してください)。ローデータファイルを使用してスナップショットを作成する方法については、<a class="xref" href="replication.html#replication-howto-rawdata" title="17.1.1.6 ローデータファイルを使用したデータスナップショットの作成">セクション17.1.1.6「ローデータファイルを使用したデータスナップショットの作成」</a>を参照してください。
          </p></li><li class="listitem"><p>
            マスターサーバーがすでに正しく構成されている場合、そのステータスを取得してから (<a class="xref" href="replication.html#replication-howto-masterstatus" title="17.1.1.4 レプリケーションマスターバイナリログ座標の取得">セクション17.1.1.4「レプリケーションマスターバイナリログ座標の取得」</a>を参照してください) <span class="command"><strong>mysqldump</strong></span> を使用してスナップショットを作成するか (<a class="xref" href="replication.html#replication-howto-mysqldump" title="17.1.1.5 mysqldump を使用したデータスナップショットの作成">セクション17.1.1.5「mysqldump を使用したデータスナップショットの作成」</a>を参照してください)、<a class="xref" href="replication.html#replication-howto-rawdata" title="17.1.1.6 ローデータファイルを使用したデータスナップショットの作成">セクション17.1.1.6「ローデータファイルを使用したデータスナップショットの作成」</a>のガイドを使用してライブサーバーのロースナップショットを作成します。
          </p></li><li class="listitem"><p>
            スレーブの構成を更新します。<a class="xref" href="replication.html#replication-howto-slavebaseconfig" title="17.1.1.2 レプリケーションスレーブ構成の設定">セクション17.1.1.2「レプリケーションスレーブ構成の設定」</a>を参照してください。
          </p></li><li class="listitem"><p>
            データのスナップショットをマスター上にどのように作成したかによって、次の手順は異なります。
          </p><p>
            <span class="command"><strong>mysqldump</strong></span> を使用した場合:
          </p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>
                レプリケーションが起動しないように、<code class="option">--skip-slave-start</code> オプションを使用してスレーブを起動します。
              </p></li><li class="listitem"><p>
                ダンプファイルをインポートします。
              </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>mysql &lt; fulldb.dump</code></strong>
</pre></li></ol></div><p>
            ローデータファイルでスナップショットを作成した場合:
          </p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>
                スレーブデータディレクトリにデータファイルを抽出します。例:
              </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>tar xvf dbdump.tar</code></strong>
</pre><p>
                スレーブサーバーがファイルにアクセスして変更できるように、それらへの許可と所有権を設定する必要がある場合があります。
              </p></li><li class="listitem"><p>
                レプリケーションが起動しないように、<code class="option">--skip-slave-start</code> オプションを使用してスレーブを起動します。
              </p></li></ol></div></li><li class="listitem"><p>
            マスターからのレプリケーション座標を使用してスレーブを構成します。これは、バイナリログファイルと、ファイル内でレプリケーションを開始する必要がある位置をスレーブに伝えます。また、マスターのログイン資格証明とホスト名を使用してスレーブを構成します。必要な <code class="literal">CHANGE MASTER TO</code> ステートメントの詳細は、<a class="xref" href="replication.html#replication-howto-slaveinit" title="17.1.1.10 スレーブでのマスター構成の設定">セクション17.1.1.10「スレーブでのマスター構成の設定」</a>を参照してください。
          </p></li><li class="listitem"><p>
            スレーブスレッドを起動します。
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>START SLAVE;</code></strong>
</pre></li></ol></div><p>
        この手順を行なったあと、スレーブはマスターに接続し、スナップショット作成後に発生した更新を反映するはずです。
      </p><p>
        マスターに <code class="option">server-id</code> オプションを設定するのを忘れた場合、スレーブはそれに接続できません。
      </p><p>
        スレーブに <code class="option">server-id</code> オプションを設定するのを忘れた場合、スレーブのエラーログに次にようなエラーを取得します。
      </p><pre class="programlisting">
Warning: You should set server-id to a non-0 value if master_host
is set; we will force server id to 2, but this MySQL server will
not act as a slave.
</pre><p>
        何らかの理由で複製できない場合も、スレーブのエラーログにエラーメッセージを取得します。
      </p><p>
        スレーブはそのマスター情報リポジトリに格納された情報を使用して、マスターのバイナリログがどの程度処理されたかを追跡します。リポジトリはファイルまたはテーブルの形式で、<code class="option">--master-info-repository</code> の値セットによって決定されます。スレーブが <code class="option">--master-info-repository=FILE</code> で動作している場合、データディレクトリの中に、名前が <code class="filename">master.info</code> と <code class="filename">relay-log.info</code> の 2 つのファイルが見つかります。代わりに <code class="option">--master-info-repository=TABLE</code> である場合、この情報は <code class="literal">mysql</code> データベースのテーブル <code class="literal">master_slave_info</code> に格納されます。いずれの場合も、何を実行しているかが正確にわかり、その影響を十分に理解している場合を除いて、ファイルまたはテーブルを削除したり編集したり<span class="emphasis"><em>しないで</em></span>ください。その場合でも、<code class="literal">CHANGE MASTER TO</code> ステートメントを使用してレプリケーションパラメータを変更することをお勧めします。スレーブはステートメントで指定した値を使用して、ステータスファイルを自動的に更新できます。詳細については、<a class="xref" href="replication.html#slave-logs" title="17.2.2 レプリケーションリレーおよびステータスログ">セクション17.2.2「レプリケーションリレーおよびステータスログ」</a>を参照してください。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          マスター情報リポジトリの内容は、コマンド行または <code class="filename">my.cnf</code> で指定されたいくつかのサーバーオプションをオーバーライドします。詳細については、<a class="xref" href="replication.html#replication-options" title="17.1.4 レプリケーションおよびバイナリロギングのオプションと変数">セクション17.1.4「レプリケーションおよびバイナリロギングのオプションと変数」</a>を参照してください。
        </p></div><p>
        複数のスレーブでも、マスターの単一スナップショットで十分です。追加のスレーブをセットアップする場合は、同じマスタースナップショットを使用して、先述の手順のスレーブ部分に従ってください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-howto-additionalslaves"></a>17.1.1.9 既存のレプリケーション環境への追加スレーブの導入</h4></div></div></div><p>
        既存のレプリケーション構成に別のスレーブを追加する場合は、マスターを停止することなく実行できます。代わりに、既存のスレーブのコピーを作成することで新しいスレーブをセットアップしますが、新しいスレーブは別の <code class="option">server-id</code> 値で構成します。
      </p><p>
        既存のスレーブを複製するには、次のようにします。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            既存のスレーブをシャットダウンします。
          </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>mysqladmin shutdown</code></strong>
</pre></li><li class="listitem"><p>
            既存のスレーブから新しいスレーブにデータディレクトリをコピーします。これを行うには、<span class="command"><strong>tar</strong></span> または <code class="literal">WinZip</code> を使用してアーカイブを作成するか、<span class="command"><strong>cp</strong></span>、<span class="command"><strong>rsync</strong></span> などのツールを使用して直接コピーを実行します。ログファイルとリレーログファイルを確実にコピーしてください。
          </p><p>
            新しいレプリケーションスレーブを追加するときに直面するよくある問題は、次のような一連の警告またはエラーメッセージで新しいスレーブが失敗することです。
          </p><pre class="programlisting">
071118 16:44:10 [Warning] Neither --relay-log nor --relay-log-index were used; so
replication may break when this MySQL server acts as a slave and has his hostname
changed!! Please use '--relay-log=<em class="replaceable"><code>new_slave_hostname</code></em>-relay-bin' to avoid this problem.
<span class="errortext">071118 16:44:10 [ERROR] Failed to open the relay log './<em class="replaceable"><code>old_slave_hostname</code></em>-relay-bin.003525'
(relay_log_pos 22940879)</span>
071118 16:44:10 <span class="errortext">[ERROR] Could not find target log during relay log initialization</span>
071118 16:44:10 <span class="errortext">[ERROR] Failed to initialize the master info structure</span>
</pre><p>
            これは、<code class="option">--relay-log</code> オプションが指定されていない場合、リレーログファイルにそれらのファイル名の一部としてホスト名が含まれているためです。(これは、<code class="option">--relay-log-index</code> オプションが使用されていない場合のリレーログインデックスファイルにも当てはまります。これらのオプションの詳細については、<a class="xref" href="replication.html#replication-options" title="17.1.4 レプリケーションおよびバイナリロギングのオプションと変数">セクション17.1.4「レプリケーションおよびバイナリロギングのオプションと変数」</a>を参照してください。
          </p><p>
            この問題を回避するには、新しいスレーブの <code class="option">--relay-log</code> に対して、既存のスレーブで使用されたものと同じ値を使用します。(このオプションが既存のスレーブで明示的に設定されなかった場合は、<code class="literal"><em class="replaceable"><code>existing_slave_hostname</code></em>-relay-bin</code> を使用します。)これができない場合、既存のスレーブのリレーログインデックスファイルを新しいスレーブにコピーし、新しいスレーブの <code class="option">--relay-log-index</code> オプションを既存のスレーブで使用されていたものに設定します。(このオプションが既存のスレーブで明示的に設定されなかった場合は、<code class="literal"><em class="replaceable"><code>existing_slave_hostname</code></em>-relay-bin.index</code>を使用します。)また、すでに新しいスレーブを起動しようとして (このセクションの残りの手順に従ったあとに)、前に説明したものと同じようなエラーが発生した場合は、次の手順を実行します。
          </p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>
                まだそのようにしていなかった場合は、新しいスレーブで <code class="literal">STOP SLAVE</code> を発行します。
              </p><p>
                すでに既存のスレーブを再度起動した場合は、既存のスレーブでも <code class="literal">STOP SLAVE</code> を発行します。
              </p></li><li class="listitem"><p>
                既存のスレーブのリレーログインデックスファイルの内容を新しいスレーブのリレーログインデックスファイルにコピーして、確実にファイルの既存の内容を上書きします。
              </p></li><li class="listitem"><p>
                このセクションの残りの手順に進みます。
              </p></li></ol></div></li><li class="listitem"><p>
            マスター情報およびリレーログ情報リポジトリを既存のスレーブから新しいスレーブにコピーします (<a class="xref" href="replication.html#slave-logs" title="17.2.2 レプリケーションリレーおよびステータスログ">セクション17.2.2「レプリケーションリレーおよびステータスログ」</a>を参照してください)。これらは、マスターのバイナリログとスレーブのリレーログの現在のログ座標を保持しています。
          </p></li><li class="listitem"><p>
            既存のスレーブを起動します。
          </p></li><li class="listitem"><p>
            新しいスレーブで構成を編集し、マスターまたは既存のスレーブのいずれかで使用されていない一意 <code class="option">server-id</code> を新しいスレーブに割り当てます。
          </p></li><li class="listitem"><p>
            新しいスレーブを起動します。スレーブは、そのマスター情報リポジトリ内の情報を使用して、レプリケーションプロセスを開始します。
          </p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-howto-slaveinit"></a>17.1.1.10 スレーブでのマスター構成の設定</h4></div></div></div><p>
        レプリケーションのためにマスターと通信するようにスレーブを設定するには、必要な接続情報をスレーブに伝える必要があります。これを行うには、次のステートメントをスレーブで実行して、オプション値をシステムに関係する実際の値と置き換えます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CHANGE MASTER TO</code></strong>
    -&gt;     <strong class="userinput"><code>MASTER_HOST='<em class="replaceable"><code>master_host_name</code></em>',</code></strong>
    -&gt;     <strong class="userinput"><code>MASTER_USER='<em class="replaceable"><code>replication_user_name</code></em>',</code></strong>
    -&gt;     <strong class="userinput"><code>MASTER_PASSWORD='<em class="replaceable"><code>replication_password</code></em>',</code></strong>
    -&gt;     <strong class="userinput"><code>MASTER_LOG_FILE='<em class="replaceable"><code>recorded_log_file_name</code></em>',</code></strong>
    -&gt;     <strong class="userinput"><code>MASTER_LOG_POS=<em class="replaceable"><code>recorded_log_position</code></em>;</code></strong>
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          レプリケーションでは、Unix ソケットファイルを使用できません。また、TCP/IP を使用してマスター MySQL サーバーに接続できる必要があります。
        </p></div><p>
        <code class="literal">CHANGE MASTER TO</code> ステートメントには、ほかのオプションもあります。たとえば、SSL を使用してセキュアなレプリケーションをセットアップできます。オプションの完全なリスト、および文字列値オプションに許可された最大長に関する情報については、<a class="xref" href="sql-syntax.html#change-master-to" title="13.4.2.1 CHANGE MASTER TO 構文">セクション13.4.2.1「CHANGE MASTER TO 構文」</a>を参照してください。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-formats"></a>17.1.2 レプリケーション形式</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-sbr-rbr">17.1.2.1 ステートメントベースおよび行ベースレプリケーションのメリットとデメリット</a></span></dt><dt><span class="section"><a href="replication.html#replication-rbr-usage">17.1.2.2 行ベースロギングおよびレプリケーションの使用</a></span></dt><dt><span class="section"><a href="replication.html#replication-rbr-safe-unsafe">17.1.2.3 バイナリロギングでの安全および安全でないステートメントの判断</a></span></dt></dl></div><p>
      レプリケーションが機能するのは、バイナリログに書き込まれたイベントがマスターから読み取られ、スレーブで処理されるためです。イベントは、イベントタイプに従ってさまざまな形式でバイナリログに記録されます。使用されるさまざまなレプリケーション形式は、イベントがマスターのバイナリログに記録されたときに使用されたバイナリロギング形式に対応しています。バイナリロギング形式とレプリケーションで使用される用語との関係は次のとおりです。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ステートメントベースのバイナリロギングを使用する場合、マスターは SQL ステートメントをバイナリログに書き込みます。マスターからスレーブへのレプリケーションは、スレーブで SQL ステートメントを実行することによって機能します。これは<em class="firstterm">ステートメントベースのレプリケーション</em> (<em class="firstterm">SBR</em> と短縮されることが多い) と呼ばれ、標準 MySQL ステートメントベースのバイナリロギング形式に対応します。MySQL バージョン 5.1.4 以前のレプリケーション機能では、この形式だけが使用されました。
        </p></li><li class="listitem"><p>
          行ベースのロギングを使用する場合、マスターは、各テーブル行がどのように変更されたかを表す<em class="firstterm">イベント</em>をバイナリログに書き込みます。マスターからスレーブへのレプリケーションは、テーブル行が変更されたことを表すイベントをスレーブにコピーすることによって機能します。これは<em class="firstterm">行ベースのレプリケーション</em> (<em class="firstterm">RBR</em>と短縮されることが多い) と呼ばれます。行ベースのレプリケーションでは、マスターは、各テーブル行がどのように変更されたかを表す<em class="firstterm">イベント</em>をバイナリログに書き込みます。
        </p></li><li class="listitem"><p>
          変更ログが記録されるときにステートメントベースと行ベースのどちらが適しているかによって、これらのロギングの組み合わせを使用するように MySQL を構成することもできます。これは<em class="firstterm">混合形式のロギング</em>と呼ばれます。混合形式のロギングを使用する場合、デフォルトでステートメントベースのログが使用されます。ステートメントに応じて、また使用されるストレージエンジンに応じて、ログは特定のケースで行ベースに自動的に切りかえられます。混合形式を使用するレプリケーションは多くの場合、<em class="firstterm">混合ベースのレプリケーション</em>または<em class="firstterm">混合形式のレプリケーション</em>と呼ばれます。詳細については、<a class="xref" href="server-administration.html#binary-log-mixed" title="5.2.4.3 混合形式のバイナリロギング形式">セクション5.2.4.3「混合形式のバイナリロギング形式」</a>を参照してください。
        </p></li></ul></div><p>
      MySQL 5.6 では、ステートメントベースの形式がデフォルトです。
    </p><p><b>MySQL Cluster </b>
        すべての MySQL Cluster NDB 7.3 および MySQL Cluster NDB 7.4 リリースのデフォルトバイナリロギング形式は <code class="literal">混合</code> です。MySQL Cluster Replication は常に行ベースのレプリケーションを使用し、<code class="literal">NDB</code> ストレージエンジンはステートメントベースのレプリケーションを使用できません。詳細については、<a class="xref" href="mysql-cluster.html#mysql-cluster-replication-general" title="18.6.2 MySQL Cluster レプリケーションの一般要件">セクション18.6.2「MySQL Cluster レプリケーションの一般要件」</a>を参照してください。
      </p><p>
      <code class="literal">混合</code>形式を使用する場合、バイナリロギング形式は、使用されているストレージエンジンと実行されているステートメントによってある程度決定されます。混合形式のロギング、および異なるロギング形式のサポートを管理するルールの詳細は、<a class="xref" href="server-administration.html#binary-log-mixed" title="5.2.4.3 混合形式のバイナリロギング形式">セクション5.2.4.3「混合形式のバイナリロギング形式」</a>を参照してください。
    </p><p>
      実行中 MySQL サーバーのロギング形式は、<code class="literal">binlog_format</code> サーバーシステム変数を設定することで制御されます。この変数はセッションまたはグローバルスコープで設定できます。新しい設定が有効になるタイミングと方法を管理するルールは、ほかの MySQL サーバーシステム変数と同じです。現在のセッションの変数を設定すると、そのセッションが終わるまで持続し、変更はほかのセッションに可視でなく、変数をグローバルに設定した場合、有効にするにはサーバーの再起動が必要です。詳細については、<a class="xref" href="sql-syntax.html#set-statement" title="13.7.4 SET 構文">セクション13.7.4「SET 構文」</a>を参照してください。
    </p><p>
      実行時にバイナリロギング形式を変更できない、つまりそのようにするとレプリケーションが失敗する状況があります。<a class="xref" href="server-administration.html#binary-log-setting" title="5.2.4.2 バイナリログ形式の設定">セクション5.2.4.2「バイナリログ形式の設定」</a>を参照してください。
    </p><p>
      グローバルまたはセッション <code class="literal">binlog_format</code> 値を設定するには、<code class="literal">SUPER</code> 権限が必要です。
    </p><p>
      ステートメントベースと行ベースのレプリケーション形式には、異なる問題と制限があります。関連するメリットとデメリットの比較は、<a class="xref" href="replication.html#replication-sbr-rbr" title="17.1.2.1 ステートメントベースおよび行ベースレプリケーションのメリットとデメリット">セクション17.1.2.1「ステートメントベースおよび行ベースレプリケーションのメリットとデメリット」</a>を参照してください。
    </p><p>
      ステートメントベースのレプリケーションでは、ストアドルーチンまたはトリガーの複製で問題が発生する場合があります。代わりに行ベースのレプリケーションを使用することで、これらの問題を回避できます。詳細については、<a class="xref" href="stored-programs-views.html#stored-programs-logging" title="20.7 ストアドプログラムのバイナリロギング">セクション20.7「ストアドプログラムのバイナリロギング」</a>を参照してください。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-sbr-rbr"></a>17.1.2.1 ステートメントベースおよび行ベースレプリケーションのメリットとデメリット</h4></div></div></div><a class="indexterm" name="idm139979055675808"></a><a class="indexterm" name="idm139979055673664"></a><p>
        それぞれのバイナリロギングの形式にメリットとデメリットがあります。ほとんどのユーザーにとって、データの完全性とパフォーマンスの最善の組み合わせが得られるのは、混合レプリケーション形式であるはずです。ただし、特定のタスクを実行するときにステートメントベースまたは行ベースレプリケーション形式固有の機能を利用する場合、関連するメリットとデメリットのサマリーを記述したこのセクションの情報を使用して、どちらがニーズに最適であるかを決めることができます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <a class="link" href="replication.html#replication-sbr-rbr-sbr-advantages" title="ステートメントベースレプリケーションのメリット">ステートメントベースレプリケーションのメリット</a>
          </p></li><li class="listitem"><p>
            <a class="link" href="replication.html#replication-sbr-rbr-sbr-disadvantages" title="ステートメントベースレプリケーションのデメリット">ステートメントベースレプリケーションのデメリット</a>
          </p></li><li class="listitem"><p>
            <a class="link" href="replication.html#replication-sbr-rbr-rbr-advantages" title="行ベースレプリケーションのメリット">行ベースレプリケーションのメリット</a>
          </p></li><li class="listitem"><p>
            <a class="link" href="replication.html#replication-sbr-rbr-rbr-disadvantages" title="行ベースレプリケーションのデメリット">行ベースレプリケーションのデメリット</a>
          </p></li></ul></div><h5><a name="replication-sbr-rbr-sbr-advantages"></a>ステートメントベースレプリケーションのメリット</h5><a class="indexterm" name="idm139979055660960"></a><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            バージョン 3.23 以来、MySQL に存在する実証済みのテクノロジーです。
          </p></li><li class="listitem"><p>
            ログファイルに書き込まれるデータが少ないです。更新または削除が多くの行に影響を与える場合、これによってログファイルに必要なストレージ容量が<span class="emphasis"><em>かなり</em></span>少なくなります。つまり、バックアップの取得とリストアをより短時間で達成できます。
          </p></li><li class="listitem"><p>
            ログファイルには変更があったすべてのステートメントが含まれるため、データベースの監査に使用できます。
          </p></li></ul></div><h5><a name="replication-sbr-rbr-sbr-disadvantages"></a>ステートメントベースレプリケーションのデメリット</h5><a class="indexterm" name="idm139979055653248"></a><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>SBR にとって安全でないステートメント </b><a class="indexterm" name="idm139979055649872"></a><a class="indexterm" name="idm139979055647712"></a>
              データを変更するすべてのステートメント (<code class="literal">INSERT</code> <code class="literal">DELETE</code>、<code class="literal">UPDATE</code>、<code class="literal">REPLACE</code> ステートメントなど) を、ステートメントベースレプリケーションを使用して複製できるわけではありません。ステートメントベースレプリケーションを使用する場合、非決定的動作は複製が困難です。そのような DML (データ変更言語) ステートメントの例には次が含まれます。
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                非決定的な UDF またはストアドプログラムに依存するステートメント。そのような UDF またはストアドプログラムによって返される値は、それに提供されるパラメータ以外の要因に依存するため。(ただし、行ベースレプリケーションは、UDF またはストアドプログラムによって返される値を単純に置き換えるため、テーブル行およびデータに対するその影響はマスターとスレーブの両方で同じです。)詳細は、<a class="xref" href="replication.html#replication-features-invoked" title="17.4.1.11 呼び出される機能のレプリケーション">セクション17.4.1.11「呼び出される機能のレプリケーション」</a>を参照してください。
              </p></li><li class="listitem"><p>
                <code class="literal">ORDER BY</code> なしで <code class="literal">LIMIT</code> 句を使用する <code class="literal">DELETE</code> および <code class="literal">UPDATE</code> ステートメントは非決定的です。<a class="xref" href="replication.html#replication-features-limit" title="17.4.1.16 レプリケーションと LIMIT">セクション17.4.1.16「レプリケーションと LIMIT」</a>を参照してください。
              </p></li><li class="listitem"><p>
                次のいずれかの関数を使用するステートメントは、ステートメントベースレプリケーションでは適切に複製できません。
              </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                    <code class="literal">LOAD_FILE()</code>
                  </p></li><li class="listitem"><p>
                    <code class="literal">UUID()</code>、<code class="literal">UUID_SHORT()</code>
                  </p></li><li class="listitem"><p>
                    <code class="literal">USER()</code>
                  </p></li><li class="listitem"><p>
                    <code class="literal">FOUND_ROWS()</code>
                  </p></li><li class="listitem"><p>
                    <code class="literal">SYSDATE()</code> (マスターとスレーブの両方が <code class="option">--sysdate-is-now</code> オプションで起動される場合を除きます)
                  </p></li><li class="listitem"><p>
                    <code class="literal">GET_LOCK()</code>
                  </p></li><li class="listitem"><p>
                    <code class="literal">IS_FREE_LOCK()</code>
                  </p></li><li class="listitem"><p>
                    <code class="literal">IS_USED_LOCK()</code>
                  </p></li><li class="listitem"><p>
                    <code class="literal">MASTER_POS_WAIT()</code>
                  </p></li><li class="listitem"><p>
                    <code class="literal">RAND()</code>
                  </p></li><li class="listitem"><p>
                    <code class="literal">RELEASE_LOCK()</code>
                  </p></li><li class="listitem"><p>
                    <code class="literal">SLEEP()</code>
                  </p></li><li class="listitem"><p>
                    <code class="literal">VERSION()</code>
                  </p></li></ul></div><p>
                ただし、<code class="literal">NOW()</code> などを含めてほかのすべての関数はステートメントベースレプリケーションで正しく複製されます。
              </p><p>
                詳細については、<a class="xref" href="replication.html#replication-features-functions" title="17.4.1.15 レプリケーションとシステム関数">セクション17.4.1.15「レプリケーションとシステム関数」</a>を参照してください。
              </p></li></ul></div><p>
            ステートメントベースレプリケーションで正しく複製できないステートメントは、ここに示すもののような警告でログが記録されます。
          </p><pre class="programlisting">
[Warning] Statement is not safe to log in statement format.
</pre><p>
            このような場合、類似の警告がクライアントにも発行されます。クライアントは <code class="literal">SHOW WARNINGS</code> を使用してそれを表示できます。
          </p></li><li class="listitem"><p>
            <code class="literal">INSERT ... SELECT</code> は、行ベースレプリケーションよりも多くの行レベルロックが必要です。
          </p></li><li class="listitem"><p>
            <code class="literal">WHERE</code> 句でインデックスが使用されていないためにテーブルスキャンを必要とする <code class="literal">UPDATE</code> ステートメントは、行ベースレプリケーションの場合より多くの行をロックする必要があります。
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> の場合: <code class="literal">AUTO_INCREMENT</code> を使用する <code class="literal">INSERT</code> ステートメントは、競合しないほかの <code class="literal">INSERT</code> ステートメントをブロックします。
          </p></li><li class="listitem"><p>
            複雑なステートメントの場合、行が更新または挿入される前に、スレーブでステートメントを評価して実行する必要があります。行ベースレプリケーションの場合、スレーブはステートメント全体を実行するのではなく、影響を受ける行だけを変更する必要があります。
          </p></li><li class="listitem"><p>
            スレーブでの評価でエラーがあった場合、特に複雑なステートメントを実行するときに、ステートメントベースレプリケーションでは、影響を受ける行全体でエラーのマージンが時間とともに徐々に増える場合があります。<a class="xref" href="replication.html#replication-features-slaveerrors" title="17.4.1.26 レプリケーション中のスレーブエラー">セクション17.4.1.26「レプリケーション中のスレーブエラー」</a>を参照してください。
          </p></li><li class="listitem"><p>
            ストアドファンクションは、呼び出し元のステートメントと同じ <code class="literal">NOW()</code> 値で実行します。ただし、これはストアドプロシージャーには当てはまりません。
          </p></li><li class="listitem"><p>
            決定的な UDF はスレーブで適用される必要があります。
          </p></li><li class="listitem"><p>
            テーブル定義は、マスターとスレーブで (ほぼ) 同じでなければいけません。詳細については、<a class="xref" href="replication.html#replication-features-differing-tables" title="17.4.1.9 テーブル定義が異なるマスターとスレーブでのレプリケーション">セクション17.4.1.9「テーブル定義が異なるマスターとスレーブでのレプリケーション」</a>を参照してください。
          </p></li></ul></div><h5><a name="replication-sbr-rbr-rbr-advantages"></a>行ベースレプリケーションのメリット</h5><a class="indexterm" name="idm139979055580320"></a><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            すべての変更を複製できます。これはもっとも安全な形式のレプリケーションです。
          </p><p>
            <code class="literal">mysql</code> データベースは複製されません。代わりに、<code class="literal">mysql</code> データベースはノード固有データベースとして見られます。行ベースレプリケーションは、このデータベース内のテーブルでサポートされません。代わりに、<code class="literal">GRANT</code>、<code class="literal">REVOKE</code>、およびトリガー、ストアドルーチン (ストアドプロシージャーを含む)、およびビューの操作など、通常この情報を更新するステートメントは、ステートメントベースレプリケーションでスレーブにすべて複製されます。
          </p><p>
            <code class="literal">CREATE TABLE ... SELECT</code> などのステートメントの場合、<code class="literal">CREATE</code> ステートメントはテーブル定義から生成されてステートメントベース形式を使用して複製される一方、行挿入は行ベース形式を使用して複製されます。
          </p></li><li class="listitem"><p>
            このテクノロジーはほかのほとんどのデータベース管理システムと同じです。ほかのシステムについての知識は MySQL で通用します。
          </p></li><li class="listitem"><p>
            マスターで必要な行ロックは少ないため、次の種類のステートメントでは並列性が高くなります。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">INSERT ... SELECT</code>
              </p></li><li class="listitem"><p>
                <code class="literal">AUTO_INCREMENT</code> 付きの <code class="literal">INSERT</code> ステートメント
              </p></li><li class="listitem"><p>
                キーを使用しないまたは検査された行のほとんどを変更しない <code class="literal">WHERE</code> 句付きの <code class="literal">UPDATE</code> または <code class="literal">DELETE</code> ステートメント。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、または <code class="literal">DELETE</code> ステートメントの場合、スレーブで必要な行ロックが少ないです。
          </p></li></ul></div><h5><a name="replication-sbr-rbr-rbr-disadvantages"></a>行ベースレプリケーションのデメリット</h5><a class="indexterm" name="idm139979055552864"></a><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            RBR では、ログに書き込む必要があるデータが増える可能性があります。ステートメントベースレプリケーションでは、DML ステートメント (<code class="literal">UPDATE</code>、<code class="literal">DELETE</code> ステートメントなど) を複製するためにステートメントだけをバイナリログに書き込みます。一方、行ベースレプリケーションでは変更されたすべての行をバイナリログに書き込みます。ステートメントが多くの行を変更する場合、行ベースレプリケーションは非常に多くのデータをバイナリログに書き込む可能性があります。このことはロールバックされるステートメントにも当てはまります。すなわち、バックアップの取得とリストアにも、より多くの時間がかかる可能性があります。また、データを書き込むためにバイナリログがロックされる時間が長くなるため、並列性の問題が発生する場合があります。
          </p></li><li class="listitem"><p>
            大きな <code class="literal">BLOB</code> 値を生成する決定的 UDF の場合は、ステートメントベースレプリケーションより行ベースレプリケーションの方が複製に時間がかかります。これは、データを生成するステートメントではなく、<code class="literal">BLOB</code> カラム値がログに書き込まれるためです。
          </p></li><li class="listitem"><p>
            ログを検査してもどのステートメントが実行されたかを確認できず、マスターからどのステートメントが到着して実行されたかをスレーブで確認することもできません。
          </p><p>
            ただし、オプション <code class="option">--base64-output=DECODE-ROWS</code> および <code class="option">--verbose</code> を付けて <span class="command"><strong>mysqlbinlog</strong></span> を使用すると、何のデータが変更されたかがわかります。
          </p></li><li class="listitem"><p>
            <code class="literal">MyISAM</code> ストレージエンジンを使用するテーブルの場合、<code class="literal">INSERT</code> ステートメントを行ベースイベントとしてバイナリログに適用するときの方が、ステートメントとして適用するときよりも、スレーブでより強いロックが必要です。これは、<code class="literal">MyISAM</code> テーブルでの同時挿入が、行ベースレプリケーションを使用するときにサポートされないことを意味します。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-rbr-usage"></a>17.1.2.2 行ベースロギングおよびレプリケーションの使用</h4></div></div></div><p>
        MySQL はステートメントベースロギング (SBL)、行ベースロギング (RBL)、または混合形式ロギングを使用します。使用されるバイナリログの種類は、ロギングのサイズと効率に影響します。このため、行ベースレプリケーション (RBR) またはステートメントベースレプリケーション (SBR) の選択は、アプリケーションと環境に依存します。

        

        このセクションでは、行ベース形式ログを使用するときの既知の問題について説明し、これをレプリケーションで使用する際のベストプラクティスをいくつか紹介します。
      </p><p>
        詳細については、<a class="xref" href="replication.html#replication-formats" title="17.1.2 レプリケーション形式">セクション17.1.2「レプリケーション形式」</a>および<a class="xref" href="replication.html#replication-sbr-rbr" title="17.1.2.1 ステートメントベースおよび行ベースレプリケーションのメリットとデメリット">セクション17.1.2.1「ステートメントベースおよび行ベースレプリケーションのメリットとデメリット」</a>を参照してください。
      </p><p>
        MySQL Cluster レプリケーションに固有の問題について詳しくは (行ベースレプリケーションに依存します)、<a class="xref" href="mysql-cluster.html#mysql-cluster-replication-issues" title="18.6.3 MySQL Cluster レプリケーションの既知の問題">セクション18.6.3「MySQL Cluster レプリケーションの既知の問題」</a>を参照してください。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="replication-rbr-usage-temptables"></a><b>一時テーブルの行ベースロギング </b>
              <a class="xref" href="replication.html#replication-features-temptables" title="17.4.1.22 レプリケーションと一時テーブル">セクション17.4.1.22「レプリケーションと一時テーブル」</a>で説明したように、行ベース形式を使用する場合、一時テーブルは複製されません。混合形式ロギングを使用する場合、一時テーブルを使用する<span class="quote">「<span class="quote">安全な</span>」</span>ステートメントは、ステートメントベース形式を使用してログが記録されます。詳細については、<a class="xref" href="replication.html#replication-sbr-rbr" title="17.1.2.1 ステートメントベースおよび行ベースレプリケーションのメリットとデメリット">セクション17.1.2.1「ステートメントベースおよび行ベースレプリケーションのメリットとデメリット」</a>を参照してください。
            </p><p>
            行ベース形式を使用する場合、一時テーブルは複製されません (必要がないため)。また、一時テーブルはそれらを作成したスレッドからのみ読み取れるため、ステートメントベース形式を使用する場合でも、それらを複製することから得られるメリットはまずありません。
          </p><p>
            MySQL 5.6 では、一時テーブルが作成された場合でも、ステートメントベースから行ベースにバイナリロギングモードを切り替えることができます。ただし、行ベース形式の使用中は、MySQL サーバーは所定の一時テーブルが作成されたときに有効であったロギングモードを特定できません。このため、このようなケースのサーバーは、所定のクライアントセッションが終了するときに、そこにまだ存在する各一時テーブルの <code class="literal">DROP TEMPORARY TABLE IF EXISTS</code> ステートメントのログを記録します。これは、一部のケースで不必要な <code class="literal">DROP TEMPORARY TABLE</code> ステートメントのログが記録される可能性があることを意味しますが、このステートメントは無害であり、テーブルが存在しない場合でも <code class="literal">IF NOT EXISTS</code> オプションがあることでエラーになりません。
          </p><p>
            MySQL 5.6.6 以前では、行ベースロギングを使用するときに <code class="option">--disable-gtid-unsafe-statements</code> オプションを使用すると、一時テーブルを使用する非トランザクション DML ステートメントがエラーで失敗していました (バイナリログに書き込まれないという事実にかかわらず)。MySQL 5.6.7 以降は、ステートメントが影響を与える非トランザクションテーブルが一時テーブルであるかぎり、<code class="literal">binlog_format=ROW</code> を使用するときにこのようなステートメントが許可されます (Bug #14272672)。
          </p></li><li class="listitem"><p><b>非トランザクションテーブルの RBL と同期 </b>
              多くの行が影響を受ける場合、変更のセットは複数のイベントに分割されます。ステートメントがコミットすると、これらのイベントのすべてがバイナリログに書き込まれます。スレーブで実行中は、使用されるすべてのテーブルにテーブルロックが適用され、行はバッチモードで適用されます。(これは、スレーブによるテーブルコピーに使用されるエンジンに応じて効果的であったりなかったりします。)
            </p></li><li class="listitem"><p><b>待機時間およびバイナリログサイズ </b>
              RBL は各行の変更をバイナリログに書き込むため、そのサイズは急激に増える場合があります。このため、マスターでの変更に対応する変更をクライアントで行うために必要な時間が大きく増える可能性があります。アプリケーションでこのような遅延が発生する可能性を意識してください。
            </p></li><li class="listitem"><p><b>バイナリログの読み取り </b>
              <span class="command"><strong>mysqlbinlog</strong></span> は、<code class="literal">BINLOG</code> ステートメントを使用してバイナリログ内の行ベースイベントを表示します(<a class="xref" href="sql-syntax.html#binlog" title="13.7.6.1 BINLOG 構文">セクション13.7.6.1「BINLOG 構文」</a>を参照してください)。このステートメントは base 64 でエンコードされた文字列 (その意味は明白ではありません) としてイベントを表示します。<code class="option">--base64-output=DECODE-ROWS</code> および <code class="option">--verbose</code> オプションを付けて呼び出されたときは、<span class="command"><strong>mysqlbinlog</strong></span> はバイナリログの内容を人間が読める形式にします。バイナリログイベントが行ベース形式で書き込まれ、それらを読み取ったりレプリケーションまたはデータベース障害からリカバリしたりしたい場合は、このコマンドでバイナリログの内容を読み取ることができます。詳細については、<a class="xref" href="programs.html#mysqlbinlog-row-events" title="4.6.8.2 mysqlbinlog 行イベントの表示">セクション4.6.8.2「mysqlbinlog 行イベントの表示」</a>を参照してください。
            </p></li><li class="listitem"><p><b>バイナリログ実行エラーと slave_exec_mode </b>
              <code class="literal">slave_exec_mode</code> が <code class="literal">IDEMPOTENT</code> の場合は、元の行が見つからないために RBL から変更を適用できないときでも、エラーをトリガーしたり、レプリケーションが失敗したりしません。これは、更新がスレーブに適用されない可能性があるため、マスターとスレーブが同期されなくなったことを意味します。<code class="literal">slave_exec_mode</code> が <code class="literal">IDEMPOTENT</code> のときの、RBR での待機時間問題と非トランザクションテーブルの使用によって、マスターとスレーブとの相違がさらに広がる可能性があります。<code class="literal">slave_exec_mode</code> の詳細については、<a class="xref" href="server-administration.html#server-system-variables" title="5.1.4 サーバーシステム変数">セクション5.1.4「サーバーシステム変数」</a>を参照してください。
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              <code class="literal">slave_exec_mode=IDEMPOTENT</code> は一般的に、MySQL Cluster (<code class="literal">IDEMPOTENT</code> がデフォルト値) で循環レプリケーションまたはマルチマスターレプリケーションの場合にのみ役立ちます。
            </p></div><p>
            ほかのシナリオの場合、<code class="literal">slave_exec_mode</code> を <code class="literal">STRICT</code> に設定することで通常は十分で、これがデフォルト値です。

            
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              以前は MySQL Cluster を使用するときのデフォルト値は <code class="literal">slave_exec_mode=IDEMPOTENT</code> でしたが、MySQL Cluster NDB 7.3 以降ではこれは本当ではありません。
            </p></div></li><li class="listitem"><p><b>バイナリログチェックサムがない </b>
              RBL はチェックサムを使用しないため、バイナリログを処理するときにネットワーク、ディスク、およびその他のエラーが特定されない場合があります。ネットワーク破損なしでデータを確実に転送するには、レプリケーション接続に SSL を使用します。<code class="literal">CHANGE MASTER TO</code> ステートメントには、SSL を使用するレプリケーションを有効にするオプションがあります。SSL を使用する MySQL のセットアップに関する一般的な情報については、<a class="xref" href="sql-syntax.html#change-master-to" title="13.4.2.1 CHANGE MASTER TO 構文">セクション13.4.2.1「CHANGE MASTER TO 構文」</a>を参照してください。
            </p></li><li class="listitem"><p><b>サーバー ID に基づくフィルタリングはサポートされない </b>
              MySQL 5.6 では、<code class="literal">CHANGE MASTER TO</code> ステートメントで <code class="literal">IGNORE_SERVER_IDS</code> オプションを使用することで、サーバー ID に基づいてフィルタできます。このオプションは、ステートメントベースおよび行ベースロギング形式で使用できます。一部のスレーブで変更を除外するための別の方法は、<code class="literal">UPDATE</code> および <code class="literal">DELETE</code> ステートメントで、関係 <code class="literal">@@server_id &lt;&gt; <em class="replaceable"><code>id_value</code></em></code> 句を含む <code class="literal">WHERE</code> 句を使用することです。たとえば、<code class="literal">WHERE @@server_id &lt;&gt; 1</code>。ただし、これは行ベースロギングでは正しく動作しません。ステートメントフィルタリングに <code class="literal">server_id</code> システム変数を使用するには、ステートメントベースロギングを使用します。
            </p></li><li class="listitem"><p><b>データベースレベルレプリケーションオプション </b>
              <code class="option">--replicate-do-db</code>、<code class="option">--replicate-ignore-db</code>、および <code class="option">--replicate-rewrite-db</code> オプションの効果は、行ベースまたはステートメントベースのどちらのロギングが使用されるかに応じてかなり異なります。このため、データベースレベルオプションは避け、代わりに <code class="option">--replicate-do-table</code> や <code class="option">--replicate-ignore-table</code> などのテーブルレベルオプションを使用することをお勧めします。これらのオプションと、レプリケーション形式がそれらの動作にどのように影響するかについて詳しくは、<a class="xref" href="replication.html#replication-options" title="17.1.4 レプリケーションおよびバイナリロギングのオプションと変数">セクション17.1.4「レプリケーションおよびバイナリロギングのオプションと変数」</a>を参照してください。
            </p></li><li class="listitem"><p><b>RBL、非トランザクションテーブル、および停止したスレーブ </b>
              行ベースロギングを使用するときに、スレーブサーバーが停止していて、スレーブスレッドが非トランザクションテーブルを更新している場合、スレーブデータベースが矛盾状態に到達する可能性があります。このため、行ベース形式を使用して複製されたすべてのテーブルに、<code class="literal">InnoDB</code> などのトランザクションストレージエンジンを使用することをお勧めします。スレーブ MySQL サーバーをシャットダウンする前に <code class="literal">STOP SLAVE</code> または <code class="literal">STOP SLAVE SQL_THREAD</code> を使用することは、問題発生の回避に役立ち、使用するロギング形式やストレージエンジンにかかわらず常に推奨されます。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-rbr-safe-unsafe"></a>17.1.2.3 バイナリロギングでの安全および安全でないステートメントの判断</h4></div></div></div><a class="indexterm" name="idm139979055456784"></a><a class="indexterm" name="idm139979055454576"></a><a class="indexterm" name="idm139979055452560"></a><p>
        MySQL レプリケーションでのステートメントの<span class="quote">「<span class="quote">安全</span>」</span>とは、ステートメントベース形式を使用してステートメントとその結果を正しく複製できるかどうかのことです。これがステートメントに当てはまる場合、ステートメントは<em class="firstterm">安全</em>と言い、そうでない場合は<em class="firstterm">安全でない</em>と言います。
      </p><p>
        一般的に、ステートメントが決定的である場合は安全であり、そうでない場合は安全ではありません。ただし、特定の非決定的関数は「安全でない」と見なされ<span class="emphasis"><em>ません</em></span> (このセクションの後半の<a class="xref" href="replication.html#replication-rbr-safe-unsafe-not" title="安全でないと見なされない非決定的関数。">安全でないと見なされない非決定的関数。</a>を参照してください)。また、浮動小数点数学関数 (ハードウェア依存) からの結果を使用するステートメントは、常に安全でないと見なされます (<a class="xref" href="replication.html#replication-features-floatvalues" title="17.4.1.12 レプリケーションと浮動小数点値">セクション17.4.1.12「レプリケーションと浮動小数点値」</a>を参照してください)。
      </p><p><b>安全および安全でないステートメントの処理 </b>
          ステートメントは、ステートメントが安全と見なされるかどうかに応じて、およびバイナリロギング形式 (すなわち、<code class="literal">binlog_format</code> の現在の値) に基づいて異なる方法で処理されます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            行ベースロギングを使用する場合、安全および安全でないステートメントの扱いに違いはありません。
          </p></li><li class="listitem"><p>
            混合形式ロギングを使用する場合、安全でないとフラグされたステートメントは行ベース形式を使用してログが記録され、安全と見なされたステートメントはステートメントベース形式を使用してログが記録されます。
          </p></li><li class="listitem"><p>
            ステートメントベースロギングを使用する場合、安全でないとフラグされたステートメントはこの結果に警告を生成します。安全なステートメントは通常どおりにログが記録されます。
          </p></li></ul></div><p>
        安全でないとフラグされた各ステートメントは警告を生成します。以前は、このようなステートメントが大量にマスターで実行された場合、エラーログファイルが非常に大きくなる可能性がありました。これを回避するため、MySQL は次のように動作する警告抑止メカニズム (MySQL 5.6.7 で導入) を提供します。最近の 50 の <code class="literal">ER_BINLOG_UNSAFE_STATEMENT</code> 警告が 50 秒間隔で 50 回超生成された場合、警告抑止が有効になります。有効になっているときは、これによってこのような警告がエラーログに書き込まれることはありません。代わりに、このタイプの警告が 50 個生成されるたびに、<code class="literal">「最後の警告が <em class="replaceable"><code>N</code></em> 回、最近の <em class="replaceable"><code>S</code></em> 秒間に繰り返されました」</code>との注記がエラーログに書き込まれます。50 個の最近のこのような警告が 50 秒以内に発行されるかぎり、これが継続します。頻度がこのしきい値を下回ると、再度通常どおりに警告ログが記録されます。警告抑止は、ステートメントベースロギングでステートメントの安全がどのように判断されるか、および警告がクライアントにどのように送信されるかに影響しません。MySQL クライアントは引き続きこのようなステートメントごとに 1 つの警告を受け取ります。
      </p><p>
        詳細については、<a class="xref" href="replication.html#replication-formats" title="17.1.2 レプリケーション形式">セクション17.1.2「レプリケーション形式」</a>を参照してください。
      </p><p><b>安全でないと見なされるステートメント </b><a class="indexterm" name="idm139979055430720"></a>
          次の特徴を持つステートメントは安全でないと見なされます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>スレーブで異なる値を返す可能性があるシステム関数を含むステートメント。 </b>
              これらの関数には <code class="literal">FOUND_ROWS()</code>、<code class="literal">GET_LOCK()</code>、<code class="literal">IS_FREE_LOCK()</code>、<code class="literal">IS_USED_LOCK()</code>、<code class="literal">LOAD_FILE()</code>、<code class="literal">MASTER_POS_WAIT()</code>、<code class="literal">PASSWORD()</code>、<code class="literal">RAND()</code>、<code class="literal">RELEASE_LOCK()</code>、<code class="literal">ROW_COUNT()</code>、<code class="literal">SESSION_USER()</code>、<code class="literal">SLEEP()</code>、<code class="literal">SYSDATE()</code>、<code class="literal">SYSTEM_USER()</code>、<code class="literal">USER()</code>、<code class="literal">UUID()</code>、<code class="literal">UUID_SHORT()</code> が含まれます。
            </p><p><a name="replication-rbr-safe-unsafe-not"></a><b>安全でないと見なされない非決定的関数。 </b>
              これらの関数は決定的ではありませんが、ロギングおよびレプリケーション目的の場合は安全として処理されます: <code class="literal">CONNECTION_ID()</code>、<code class="literal">CURDATE()</code>、<code class="literal">CURRENT_DATE()</code>、<code class="literal">CURRENT_TIME()</code>、<code class="literal">CURRENT_TIMESTAMP()</code>、<code class="literal">CURTIME()</code>、<code class="literal">LAST_INSERT_ID()</code>、<code class="literal">LOCALTIME()</code>、<code class="literal">LOCALTIMESTAMP()</code>、<code class="literal">NOW()</code>、<code class="literal">UNIX_TIMESTAMP()</code>、<code class="literal">UTC_DATE()</code>、<code class="literal">UTC_TIME()</code>、および <code class="literal">UTC_TIMESTAMP()</code>。
            </p><p>
            詳細については、<a class="xref" href="replication.html#replication-features-functions" title="17.4.1.15 レプリケーションとシステム関数">セクション17.4.1.15「レプリケーションとシステム関数」</a>を参照してください。
          </p></li><li class="listitem"><p><b>システム変数への参照 </b>
              ほとんどのシステム変数は、ステートメントベース形式で正しく複製されません。<a class="xref" href="replication.html#replication-features-variables" title="17.4.1.34 レプリケーションと変数">セクション17.4.1.34「レプリケーションと変数」</a>を参照してください。例外については、<a class="xref" href="server-administration.html#binary-log-mixed" title="5.2.4.3 混合形式のバイナリロギング形式">セクション5.2.4.3「混合形式のバイナリロギング形式」</a>を参照してください。
            </p></li><li class="listitem"><p><b>UDF </b>
              UDF が何をするかは制御できないため、それが安全でないステートメントを実行していると推定する必要があります。
            </p></li><li class="listitem"><p><b>トリガーまたはストアドプログラムは AUTO_INCREMENT カラムを持つテーブルを更新する。 </b>
              行が更新される順番がマスターとスレーブで異なる可能性があるため、これは安全ではありません。
            </p><p>
            また、複合主キーを持つテーブルに、この複合キーの先頭カラムでない <code class="literal">AUTO_INCREMENT</code> カラムが含まれるテーブルに <code class="literal">INSERT</code> することは、安全ではありません。
          </p><p>
            詳細については、<a class="xref" href="replication.html#replication-features-auto-increment" title="17.4.1.1 レプリケーションと AUTO_INCREMENT">セクション17.4.1.1「レプリケーションと AUTO_INCREMENT」</a>を参照してください。
          </p></li><li class="listitem"><p><b>INSERT DELAYED ステートメント </b>
              このステートメントは、この行の挿入が並列実行されるステートメントによって差し込まれる可能性があるため、安全でないと見なされます。
            </p></li><li class="listitem"><p><b>複数の主キーまたは一意キーを持つテーブルでの INSERT ... ON DUPLICATE KEY UPDATE ステートメント </b>
              複数の主キーまたは一意キーを持つテーブルに対して実行されるときのこのステートメントは、安全でないと見なされます (ストレージエンジンがキーをチェックする順番に影響されやすいですが、これは決定的でなく、さらに MySQL Server が更新する行の選択がこれに依存するためです)。
            </p><p>
            複数の一意キーまたは主キーを持つテーブルに対する <code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> ステートメントは、MySQL 5.6.6 以降のステートメントベースレプリケーションでは安全でないとマークされます。(Bug #11765650、Bug #58637)
          </p></li><li class="listitem"><p><b>LIMIT を使用する更新 </b>
              行の取得順序が指定されていないため、安全でないと見なされます。<a class="xref" href="replication.html#replication-features-limit" title="17.4.1.16 レプリケーションと LIMIT">セクション17.4.1.16「レプリケーションと LIMIT」</a>を参照してください。
            </p></li><li class="listitem"><p><b>ログテーブルへのアクセスまたは参照 </b>
              システムログテーブルの内容は、マスターとスレーブで異なる可能性があります。
            </p></li><li class="listitem"><p><b>トランザクション操作後の非トランザクション操作 </b>
              トランザクション内で、トランザクション読み取りまたは書き込み後に非トランザクション読み取りまたは書き込みを実行することを許可することは、安全でないと見なされます。
            </p><p>
            詳細については、<a class="xref" href="replication.html#replication-features-transactions" title="17.4.1.31 レプリケーションとトランザクション">セクション17.4.1.31「レプリケーションとトランザクション」</a>を参照してください。
          </p></li><li class="listitem"><p><b>セルフロギングテーブルへのアクセスまたは参照 </b>
              セルフロギングテーブルへのすべての読み取りと書き込みは、安全でないと見なされます。トランザクション内で、セルフロギングテーブルへの読み取りまたは書き込みに続くステートメントも、安全でないと見なされます。
            </p></li><li class="listitem"><p><b>LOAD DATA INFILE ステートメント </b>
              MySQL 5.6 以降では、<code class="literal">LOAD DATA INFILE</code> は安全でないと見なされ、ステートメントベースモードで警告が生成され、混合形式ロギング使用時に行ベース形式に切り替わる原因となります。<a class="xref" href="replication.html#replication-features-load-data" title="17.4.1.17 レプリケーションと LOAD DATA INFILE">セクション17.4.1.17「レプリケーションと LOAD DATA INFILE」</a>を参照してください。
            </p></li></ul></div><p>
        追加情報については <a class="xref" href="replication.html#replication-features" title="17.4.1 レプリケーションの機能と問題">セクション17.4.1「レプリケーションの機能と問題」</a>を参照してください。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-gtids"></a>17.1.3 グローバルトランザクション識別子を使用したレプリケーション</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-gtids-concepts">17.1.3.1 GTID の概念</a></span></dt><dt><span class="section"><a href="replication.html#replication-gtids-howto">17.1.3.2 GTID を使用したレプリケーションのセットアップ</a></span></dt><dt><span class="section"><a href="replication.html#replication-gtids-failover">17.1.3.3 フェイルオーバーおよびスケールアウトでの GTID の使用</a></span></dt><dt><span class="section"><a href="replication.html#replication-gtids-restrictions">17.1.3.4 GTID ベースレプリケーションの制約</a></span></dt></dl></div><p>
      このセクションでは、MySQL 5.6.5 で導入された、<em class="firstterm">グローバルトランザクション識別子</em> (GTID) を使用したトランザクションベースレプリケーションについて説明します。GTID を使用することで、各トランザクションが発生元サーバーでコミットされて、スレーブによって適用されたあとに、それを特定して追跡できます。これは、GTID を使用することで、新しいスレーブを起動するとき、または新しいマスターにフェイルオーバーするときに、ログファイルまたはそれらのファイル内での位置を参照する必要がなくなり、これらのタスクが大幅に簡易化されることを意味します。GTID ベースレプリケーションが完全にトランザクションベースであるため、マスターとスレーブが一貫しているかどうかを判断することが容易です。マスターでコミットされたすべてのトランザクションがスレーブでもコミットされているかぎり、両者の一貫性は保証されます。ステートメントベースまたは行ベースレプリケーションを GTID に基づいて使用できます (<a class="xref" href="replication.html#replication-formats" title="17.1.2 レプリケーション形式">セクション17.1.2「レプリケーション形式」</a>を参照してください)。ただし、最善の結果を得るには、行ベース形式を使用することをお勧めします。
    </p><p>
      このセクションでは、次のトピックについて説明します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          GTID がどのように定義および作成され、それらが MySQL Server 内でどのように表現されるか (<a class="xref" href="replication.html#replication-gtids-concepts" title="17.1.3.1 GTID の概念">セクション17.1.3.1「GTID の概念」</a>を参照してください)。
        </p></li><li class="listitem"><p>
          GTID ベースレプリケーションをセットアップおよび起動するための一般的な手順 (<a class="xref" href="replication.html#replication-gtids-howto" title="17.1.3.2 GTID を使用したレプリケーションのセットアップ">セクション17.1.3.2「GTID を使用したレプリケーションのセットアップ」</a>を参照してください)。
        </p></li><li class="listitem"><p>
          GTID を使用するときに新しいレプリケーションサーバーをプロビジョニングするために推奨される方法 (<a class="xref" href="replication.html#replication-gtids-failover" title="17.1.3.3 フェイルオーバーおよびスケールアウトでの GTID の使用">セクション17.1.3.3「フェイルオーバーおよびスケールアウトでの GTID の使用」</a>を参照してください)。
        </p></li><li class="listitem"><p>
          GTID ベースレプリケーションを使用するときに留意すべき制約と制限 (<a class="xref" href="replication.html#replication-gtids-restrictions" title="17.1.3.4 GTID ベースレプリケーションの制約">セクション17.1.3.4「GTID ベースレプリケーションの制約」</a>を参照してください)。
        </p></li></ul></div><p>
      GTID ベースレプリケーションに関係する MySQL Server オプションおよび変数については、<a class="xref" href="replication.html#replication-options-gtids" title="17.1.4.5 グローバルトランザクション ID のオプションと変数">セクション17.1.4.5「グローバルトランザクション ID のオプションと変数」</a>を参照してください。GTID と一緒に使用するために MySQL 5.6 がサポートする SQL 関数については、<a class="xref" href="functions.html#gtid-functions" title="12.16 グローバルトランザクション ID とともに使用される関数">セクション12.16「グローバルトランザクション ID とともに使用される関数」</a>も参照してください。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        GTID は、MySQL Cluster が使用する <code class="literal">NDB</code> ストレージエンジンと互換性がなく、サポートされません。MySQL Cluster で GTID を有効にすると、<code class="literal">NDB</code> の問題が発生し、MySQL Cluster レプリケーションも失敗する可能性が非常に高くなります。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-gtids-concepts"></a>17.1.3.1 GTID の概念</h4></div></div></div><p>
        グローバルトランザクション識別子 (GTID) は、発生元のサーバー (マスター) で作成され、そこでコミットされた各トランザクションに関連付けられる一意識別子です。この識別子は、サーバーはもちろん、特定のレプリケーションセットアップ内のすべてのサーバーに一意です。すべてのトランザクションとすべての GTID との間には 1 対 1 マッピングがあります。
      </p><p>
        GTID は座標のペアとして表現され、次に示すように、コロン文字 (<code class="literal">:</code>) で区切られます。
      </p><pre class="programlisting">
GTID = <em class="replaceable"><code>source_id</code></em>:<em class="replaceable"><code>transaction_id</code></em>
</pre><p>
        <em class="replaceable"><code>source_id</code></em> は発生元サーバーを識別します。通常、サーバーの <code class="literal">server_uuid</code> はこの目的のために使用されます。<em class="replaceable"><code>transaction_id</code></em> は、このサーバーでコミットされた順番によって決められるシーケンス番号です。たとえば、コミットされる最初のトランザクションには、その <em class="replaceable"><code>transaction_id</code></em> として <code class="literal">1</code> が割り当てられ、同じ発生元サーバーでコミットされる 10 番目のトランザクションには <em class="replaceable"><code>transaction_id</code></em> として <code class="literal">10</code> が割り当てられます。トランザクションに、GTID のシーケンス番号として <code class="literal">0</code> を割り当てることはできません。たとえば、UUID が <code class="literal">3E11FA47-71CA-11E1-9E33-C80AA9429562</code> の発生元サーバーでコミットされた 23 番目のトランザクションの GTID は次のとおりです。
      </p><pre class="programlisting">
3E11FA47-71CA-11E1-9E33-C80AA9429562:23
</pre><p>
        この形式は、<code class="literal">SHOW SLAVE STATUS</code> などのステートメントの出力やバイナリログで GTID を表すために使用されます。それらは、<span class="command"><strong>mysqlbinlog</strong></span> <code class="option">--base64-output=DECODE-ROWS</code> でログファイルを表示するとき、または <code class="literal">SHOW BINLOG EVENTS</code> からの出力でも見ることができます。
      </p><p>
        GTID は <code class="literal">SHOW MASTER STATUS</code> や <code class="literal">SHOW SLAVE STATUS</code> などのステートメントの出力に書き込まれると、同じサーバーから発生する GTID シーケンスは次のように単一表現にまとめられることがあります。
      </p><pre class="programlisting">
3E11FA47-71CA-11E1-9E33-C80AA9429562:1-5
</pre><p>
        この例は、<code class="literal">server_uuid</code> が <code class="literal">3E11FA47-71CA-11E1-9E33-C80AA9429562</code> の MySQL Server で発生する 1 番目から 5 番目までのトランザクションを表します。
      </p><p>
        MySQL 5.6.6 以降では、この形式は <code class="literal">START SLAVE</code> のオプション <code class="literal">SQL_BEFORE_GTIDS</code> および <code class="literal">SQL_AFTER_GTIDS</code> で必要な引数を指定するためにも使用されます。
      </p><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="replication-gtids-concepts-gtid-sets"></a>GTID セット</h5></div></div></div><p>
          GTID セットとは、次のように表現されるグローバルトランザクション識別子のセットのことです。
        </p><pre class="programlisting">
<em class="replaceable"><code>gtid_set</code></em>:
    <em class="replaceable"><code>uuid_set</code></em> [, <em class="replaceable"><code>uuid_set</code></em>] ...
    | ''

<em class="replaceable"><code>uuid_set</code></em>:
    <em class="replaceable"><code>uuid</code></em>:<em class="replaceable"><code>interval</code></em>[:<em class="replaceable"><code>interval</code></em>]...

<em class="replaceable"><code>uuid</code></em>:
    <em class="replaceable"><code>hhhhhhhh</code></em>-<em class="replaceable"><code>hhhh</code></em>-<em class="replaceable"><code>hhhh</code></em>-<em class="replaceable"><code>hhhh</code></em>-<em class="replaceable"><code>hhhhhhhhhhhh</code></em>

<em class="replaceable"><code>h</code></em>:
    [0-9|A-F]

<em class="replaceable"><code>interval</code></em>:
    <em class="replaceable"><code>n</code></em>[-<em class="replaceable"><code>n</code></em>]

    (<em class="replaceable"><code>n</code></em> &gt;= 1) 
</pre><p>
          GTID セットは MySQL Server でいくつかの方法で使用されます。たとえば、<code class="literal">gtid_executed</code> と <code class="literal">gtid_purged</code> のシステム変数によって格納される値は、GTID セットとして表現されます。また、関数 <code class="literal">GTID_SUBSET()</code> および <code class="literal">GTID_SUBTRACT()</code> には、入力として GTID セットが必要です。
        </p><p>
          GTID はマスターとスレーブとの間で常に保持されます。これは、バイナリログを検査することで、スレーブに適用されたトランザクションのソースをいつでも特定できることを意味します。また、ある GTID のトランザクションがあるサーバーでコミットされると、同じ GTID のそれ以降のトランザクションはそのサーバーで無視されます。このように、マスターでコミットされるトランザクションはスレーブで一度だけ適用できるため、一貫性の保証に役立ちます。
        </p><p>
          GTID が使用されるときは、マスター上でのファイルの名前やそのファイル内での位置などの非ローカルデータがスレーブに必要なくなります。マスターとの同期に必要なすべてのデータは、レプリケーションデータストリームから直接取得されます。データベース管理者または開発者からは、GTID は、ファイルオフセットペアを完全に置き換えるものです (以前はマスターとスレーブ間のデータフローを開始、停止、または再開ポイントを決定するために必要でした)。これは、レプリケーションに GTID を使用しているときは、所定のマスターから複製するようにスレーブに指示するために使用する <code class="literal">MASTER_LOG_FILE</code> または <code class="literal">MASTER_LOG_POS</code> オプションを <code class="literal">CHANGE MASTER TO</code> ステートメントに含める必要がありません (含めたくありません)。これらのオプションの代わりに必要なのは、MySQL 5.6.5 で導入された <code class="literal">MASTER_AUTO_POSITION</code> オプションを有効にすることだけです。GTID ベースレプリケーションを使用してマスターとスレーブを構成して起動するために必要な正確な手順については、<a class="xref" href="replication.html#replication-gtids-howto" title="17.1.3.2 GTID を使用したレプリケーションのセットアップ">セクション17.1.3.2「GTID を使用したレプリケーションのセットアップ」</a>を参照してください。
        </p><p>
          GTID の生成とライフサイクルは次の手順で構成されます。
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              トランザクションがマスター上で実行され、コミットされます。
            </p><p>
              このトランザクションには、マスターの UUID と、このサーバーでまだ使用されていない最小のゼロでないトランザクションシーケンス番号を使用する GTID が割り当てられます。GTID はマスターのバイナリログに書き込まれます (ログ内のトランザクション自体の直前)。
            </p></li><li class="listitem"><p>
              バイナリログがスレーブに転送され、スレーブのリレーログに格納されたあと (このプロセスのために確立されたメカニズムを使用します。詳細については、<a class="xref" href="replication.html#replication-implementation" title="17.2 レプリケーションの実装">セクション17.2「レプリケーションの実装」</a>を参照してください)、スレーブは GTID を読み取り、その <code class="literal">gtid_next</code> システム変数値をこの GTID として設定します。これは、次のトランザクションのログはこの GTID を使用して記録される必要があることをスレーブに伝えます。
            </p><p>
              スレーブはセッションコンテキストに <code class="literal">gtid_next</code> を設定することに注目することが重要です。
            </p></li><li class="listitem"><p>
              スレーブは、自身のバイナリログにトランザクションログを記録するためにこの GTID が確実にまだ使用されていないことをチェックします。この GTID が使用されていない場合にのみ、スレーブは GTID を書き込み、トランザクションを適用します (そして、トランザクションをバイナリログに書き込みます)。トランザクション自体を処理する前に、まずトランザクションの GTID を読み取ってチェックすることで、スレーブは、この GTID を持つ前のトランザクションがスレーブにまだ適用されていないこと、さらにほかのセッションがまだこの GTID を読み取っておらず、関連付けられたトランザクションをまだコミットしていないことを保証します。つまり、複数のクライアントが並列に同じトランザクションを適用することは許可されません。
            </p></li><li class="listitem"><p>
              <code class="literal">gtid_next</code> が空でないため、スレーブはこのトランザクションの GTID を生成しようとせず、代わりにこの変数に格納された GTID (すなわち、マスターから取得した GTID) をバイナリログ内のトランザクションの直前に書き込みます。
            </p></li></ol></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-gtids-howto"></a>17.1.3.2 GTID を使用したレプリケーションのセットアップ</h4></div></div></div><p>
        このセクションでは、MySQL 5.6 で GTID ベースレプリケーションを構成および起動するためのプロセスについて説明します。これは、レプリケーションマスターをはじめて起動しているか、停止できることを前提とする<span class="quote">「<span class="quote">コールドスタート</span>」</span>手順です。動作中マスターから GTID を使用したレプリケーションスレーブのプロビジョニングについては、<a class="xref" href="replication.html#replication-gtids-failover" title="17.1.3.3 フェイルオーバーおよびスケールアウトでの GTID の使用">セクション17.1.3.3「フェイルオーバーおよびスケールアウトでの GTID の使用」</a>を参照してください。
      </p><p>
        最大限単純な GTID レプリケーショントポロジー (1 つのマスターと 1 つのスレーブで構成) を起動するこのプロセスの主要手順は、次のとおりです。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            レプリケーションがすでに動作している場合、両方のサーバーを読み取り専用にすることでそれらを同期します。
          </p></li><li class="listitem"><p>
            両方のサーバーを停止します。
          </p></li><li class="listitem"><p>
            GTID、バイナリロギング、およびスレーブ更新ロギングを有効にし、GTID ベースレプリケーションに安全でないステートメントを無効にした状態で、両方のサーバーを再起動します。また、サーバーは読み取り専用モードで起動し、スレーブ SQL および I/O スレッドがスレーブで起動されないようにしてください。
          </p><p>
            説明したサーバーを起動するために必要な <span class="command"><strong>mysqld</strong></span> オプションについては、このセクションの後半の例で説明します。
          </p></li><li class="listitem"><p>
            マスターをレプリケーションデータソースとして使用し、自動ポジショニングを使用するように、スレーブに指示してから、スレーブを起動します。
          </p><p>
            この手順の実施に必要な SQL ステートメントは、このセクションの後半の例で説明します。
          </p></li><li class="listitem"><p>
            更新を再度受け取ることができるように、両方のサーバーの読み取り専用モードを無効にします。
          </p></li></ol></div><p>
        次の例では、2 つのサーバーが MySQL の <span class="quote">「<span class="quote">クラシック</span>」</span>ファイルベースレプリケーションプロトコルを使用してマスターおよびスレーブとしてすでに動作しています。
      </p><p>
        後続のほとんどの手順では、<code class="literal">SUPER</code> 権限を持つ MySQL <code class="literal">root</code> アカウントまたは別の MySQL ユーザーアカウントを使用する必要があります。<span class="command"><strong>mysqladmin</strong></span> <code class="literal">shutdown</code> には、<code class="literal">SUPER</code> 権限または <code class="literal">SHUTDOWN</code> 権限が必要です。
      </p><p><b>手順 1: サーバーを同期します </b>
          サーバーを読み取り専用にします。これを行うには、次のステートメントを両方のサーバーで実行することで、<code class="literal">read_only</code> システム変数を有効にします。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET @@global.read_only = ON;</code></strong>
</pre><p>
        すると、スレーブはマスターに追い付くことができます。<span class="emphasis"><em>続行する前にスレーブがすべての更新を処理したことを確認することが非常に重要です</em></span>。
      </p><p><b>手順 2: 両方のサーバーを停止します。 </b>
          ここで示すように、<span class="command"><strong>mysqladmin</strong></span> を使用して各サーバーを停止します。ここで、<em class="replaceable"><code>username</code></em> はサーバーをシャットダウンするのに十分な権限を持つ MySQL ユーザーのユーザー名です。
        </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>mysqladmin -u<em class="replaceable"><code>username</code></em> -p shutdown</code></strong>
</pre><p>
        次に、プロンプトにこのユーザーのパスワードを指定します。
      </p><p><b>手順 3: GTID を有効にした状態で両方のサーバーを再起動します </b>
          グローバルトランザクション識別子でバイナリロギングを有効にするには、GTID モード、バイナリロギング、およびスレーブ更新ロギングを有効にし、GTID ベースレプリケーションに安全でないステートメントを無効にした状態で、各サーバーを起動する必要があります。また、読み取り専用モードで両方のサーバーを起動することで不要または予期しない更新がどちらかのサーバーで実行されないようにしてください。これは、両方のサーバーは (少なくとも) 次の <span class="command"><strong>mysqld_safe</strong></span> 呼び出しで示すオプションで起動する必要があることを意味します。
        </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>mysqld_safe --gtid_mode=ON --log-bin --log-slave-updates --enforce-gtid-consistency &amp;</code></strong> 
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          MySQL 5.6.9 より前では、<code class="option">--enforce-gtid-consistency</code> の名前は <code class="option">--disable-gtid-unsafe-statements</code> でした。
        </p></div><p>
        また、ここで示す例で指定したほかのサーバーオプションと <code class="option">--skip-slave-start</code> オプションでスレーブを起動してください。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="option">--gtid-mode</code> はブールではなく、列挙です。このオプションを設定するときは、値 <code class="literal">ON</code> または <code class="literal">OFF</code> の一方だけを使用します。0 や 1 などの数値を使用すると、予期しない結果になる場合があります。
        </p></div><p>
        <code class="option">--gtid-mode</code> および <code class="option">--enforce-gtid-consistency</code> サーバーオプションの詳細については、<a class="xref" href="replication.html#replication-options-gtids" title="17.1.4.5 グローバルトランザクション ID のオプションと変数">セクション17.1.4.5「グローバルトランザクション ID のオプションと変数」</a>を参照してください。
      </p><p>
        構成に応じて、<span class="command"><strong>mysqld_safe</strong></span> またはほかの <span class="command"><strong>mysqld</strong></span> 起動スクリプトに追加オプションを指定します。
      </p><p><b>手順 4: マスターを使用するようにスレーブに指示します </b>
          マスターをレプリケーションデータソースとして使用し、ファイルベースポジショニングではなく GTID ベース自動ポジショニングを使用するように、スレーブに指示します。トランザクションが GTID で識別されることをスレーブに伝える <code class="literal">MASTER_AUTO_POSITION</code> オプションを使用して、スレーブで <code class="literal">CHANGE MASTER TO</code> ステートメントを実行します。
        </p><p>
        マスターのホスト名とポート番号、およびマスターへの接続にスレーブが使用できるレプリケーションユーザーアカウントのユーザー名とパスワードの適切な値を指定する必要がある場合もあります。これらが手順 1 より前にすでに設定されていて、変更する必要がない場合、対応するオプションをここで示すステートメントから安全に省略できます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CHANGE MASTER TO</code></strong> 
     &gt;     <strong class="userinput"><code>MASTER_HOST = <em class="replaceable"><code>host</code></em>,</code></strong>
     &gt;     <strong class="userinput"><code>MASTER_PORT = <em class="replaceable"><code>port</code></em>,</code></strong>
     &gt;     <strong class="userinput"><code>MASTER_USER = <em class="replaceable"><code>user</code></em>,</code></strong>
     &gt;     <strong class="userinput"><code>MASTER_PASSWORD = <em class="replaceable"><code>password</code></em>,</code></strong>
     &gt;     <strong class="userinput"><code>MASTER_AUTO_POSITION = 1;</code></strong>
</pre><p>
        <code class="literal">MASTER_LOG_FILE</code> オプションと <code class="literal">MASTER_LOG_POS</code> オプションは、<code class="literal">MASTER_AUTO_POSITION</code> が 1 に設定されているときに使用できない場合があります。そのように試みると、<code class="literal">CHANGE MASTER TO</code> ステートメントはエラーで失敗します。(GTID ベースレプリケーションからファイルと位置に基づくレプリケーションに戻る必要がある場合、<code class="literal">CHANGE MASTER TO</code> ステートメントで <code class="literal">MASTER_AUTO_POSITION = 0</code> とともにこれらのオプションの 1 つまたは両方を使用する必要があります。)
      </p><p>
        <code class="literal">CHANGE MASTER TO</code> ステートメントが成功したことを前提として、このようにスレーブを起動できます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>START SLAVE;</code></strong>
</pre><p><b>手順 5: 読み取り専用モードを無効にします </b>
          次のステートメントを実行することで、マスターは更新の受け付けを再度開始できます。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET @@global.read_only = OFF;</code></strong>
</pre><p>
        これで、GTID ベースレプリケーションは動作中になり、マスターで前のようにアクティビティーを開始 (または再開) できます。<a class="xref" href="replication.html#replication-gtids-failover" title="17.1.3.3 フェイルオーバーおよびスケールアウトでの GTID の使用">セクション17.1.3.3「フェイルオーバーおよびスケールアウトでの GTID の使用」</a>では、GTID 使用時の新しいスレーブの作成について説明します。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-gtids-failover"></a>17.1.3.3 フェイルオーバーおよびスケールアウトでの GTID の使用</h4></div></div></div><p>
        MySQL 5.6.9 でグローバルトランザクション識別子 (GTID) に基づいて MySQL Replication を使用するとき、さらにあとで新しいスレーブ (スケールアウトに使用でき、必要に応じてフェイルオーバー時にマスターに昇格される) をプロビジョニングするために、いくつかの技術があります。このセクションでは、次に示す 4 つの技術について説明します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <a class="xref" href="replication.html#replication-gtids-failover-replicate" title="単純なレプリケーション">単純なレプリケーション</a>
          </p></li><li class="listitem"><p>
            <a class="xref" href="replication.html#replication-gtids-failover-copy" title="データとトランザクションをスレーブにコピーする">データとトランザクションをスレーブにコピーする</a>
          </p></li><li class="listitem"><p>
            <a class="xref" href="replication.html#replication-gtids-failover-empty" title="空のトランザクションの注入">空のトランザクションの注入</a>
          </p></li><li class="listitem"><p>
            <a class="xref" href="replication.html#replication-gtids-failover-gtid-purged" title="gtid_purged によるトランザクションの除外">gtid_purged によるトランザクションの除外</a>
          </p></li></ul></div><p>
        グローバルトランザクション識別子は、特にレプリケーションデータフローおよびフェイルオーバーアクティビティーの一般管理を簡易化するために、MySQL Replication に追加されました。各識別子は、全体でトランザクションを構成するバイナリログイベントセットを一意に識別します。GTID はデータベースに変更を適用する際に重要な役割を果たします。サーバーは、以前に処理済みと認識している識別子のトランザクションを自動的にスキップします。この動作は、自動レプリケーションポジショニングおよび正確なフェイルオーバーのために重要です。
      </p><p>
        トランザクションを構成する識別子とイベントセットとの間のマッピングは、バイナリログで取得されます。このことは、別の既存のサーバーからのデータで新しいサーバーをプロビジョニングする際に、いくつかの課題を提起します。新しいサーバーで識別子セットを再生するには、古いサーバーから新しいサーバーに識別子をコピーし、識別子と実際のイベントとの間の関係を保持する必要があります。これは、フェイルオーバーまたはスイッチオーバーで新しいマスターになる候補としてすぐに使用可能なスレーブをリストアするために必要です。
      </p><p><a name="replication-gtids-failover-replicate"></a><b>単純なレプリケーション </b>
          これは、新しいサーバーですべての識別子とトランザクションを再生するためのもっとも簡単な方法です。単純に、新しいサーバーをすべての実行履歴を持つマスターのスレーブにして、両方のサーバーでグローバルトランザクション識別子を有効にします。詳細については、<a class="xref" href="replication.html#replication-gtids-howto" title="17.1.3.2 GTID を使用したレプリケーションのセットアップ">セクション17.1.3.2「GTID を使用したレプリケーションのセットアップ」</a>を参照してください。
        </p><p>
        レプリケーションが起動されたあと、新しいサーバーはマスターからバイナリログ全体をコピーすることで、すべての GTID に関するすべての情報を取得します。
      </p><p>
        この方法は単純で効果的ですが、スレーブはマスターからバイナリログを読み取る必要があります。新しいスレーブがマスターに追い付くために比較的長い時間かかることがあり、この方法は迅速なフェイルオーバーまたはバックアップからのリストアには適していません。このセクションでは、バイナリログファイルを新しいサーバーにコピーすることで、マスターからすべての実行履歴をフェッチするのを回避する方法について説明します。
      </p><p><a name="replication-gtids-failover-copy"></a><b>データとトランザクションをスレーブにコピーする </b>
          再生を

          

          トランザクション履歴全体で行うには時間がかかることがあり、新しいレプリケーションスレーブをセットアップするときに大きなボトルネックになります。この要件を解消するために、マスターに含まれているデータセットのスナップショット、バイナリログ、およびグローバルトランザクション情報がスレーブにインポートされます。バイナリログが再生されたあとにレプリケーションを開始できるため、スレーブは残りのトランザクションに追い付くことができます。

          
        </p><p>
        この方法にはいくつかの種類があり、ここで示すように、データダンプとバイナリログからのトランザクションがスレーブに転送される方法に違いがあります。
      </p><div class="informaltable"><table summary="この表では、データセットとトランザクション履歴を新しいスレーブにコピーする方法について説明します。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">データセット</th><th scope="col">トランザクション履歴</th></tr></thead><tbody><tr><td scope="row"><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                      <span class="command"><strong>mysql</strong></span> クライアントを使用して、<span class="command"><strong>mysqldump</strong></span> で作成されたダンプファイルをインポートします。<code class="option">--master-data</code> オプションを使用してバイナリロギング情報を取り込み、<code class="literal">AUTO</code> (デフォルト) または <code class="literal">ON</code> の <code class="option">--set-gtid-purged</code> (MySQL 5.6.9 以降で使用可能) を使用して実行済みトランザクションに関する情報を取り込みます。スレーブでダンプをインポートするときは、<code class="option">--gtid-mode=ON</code> にしてください。(Bug #14832472)
                    </p></li><li class="listitem"><p>
                      スレーブを停止し、マスターのデータディレクトリの内容をスレーブのデータディレクトリにコピーしてから、スレーブを再起動します。
                    </p></li></ul></div></td><td><p>
                  <code class="literal">gtid_mode</code> が <code class="literal">ON</code> でない場合、GTID モードを有効にした状態でサーバーを再起動します。
                </p>

                <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                      <span class="command"><strong>mysqlbinlog</strong></span> を <code class="option">--read-from-remote-server</code> および <code class="option">--read-from-remote-master</code> オプションで使用してバイナリログをインポートします。
                    </p></li><li class="listitem"><p>
                      マスターのバイナリログファイルをスレーブにコピーします。<span class="command"><strong>mysqlbinlog</strong></span> <code class="option">--read-from-remote-server</code> <code class="option">--raw</code> を使用して、スレーブからコピーを作成できます。これらは、次のいずれかの方法でスレーブに読み取ることができます。
                    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                          スレーブの <code class="filename">binlog.index</code> ファイルを更新して、コピーされたログファイルをポイントします。次に、<span class="command"><strong>mysql</strong></span> クライアントで <code class="literal">CHANGE MASTER TO</code> ステートメントを実行して最初のログファイルをポイントし、<code class="literal">START SLAVE</code> を実行してそれらを読み取ります。
                        </p></li><li class="listitem"><p>
                          <span class="command"><strong>mysqlbinlog</strong></span> <code class="literal">&gt;</code> <code class="filename"><em class="replaceable"><code>file</code></em></code> (<code class="option">--raw</code> オプションなし) を使用して、<span class="command"><strong>mysql</strong></span> クライアントが処理できる SQL ファイルにバイナリログファイルをエクスポートします。
                        </p></li></ul></div></li></ul></div></td></tr></tbody></table></div><p>
        <a class="xref" href="programs.html#mysqlbinlog-backup" title="4.6.8.3 バイナリログファイルのバックアップのための mysqlbinlog の使用">セクション4.6.8.3「バイナリログファイルのバックアップのための mysqlbinlog の使用」</a>も参照してください。
      </p><p>
        この方法には、新しいサーバーをほぼ直後に使用できるというメリットがあります。ただし、スナップショットまたはダンプファイルが再生されている間にコミットされたトランザクションだけは、既存のマスターから取得される必要があります。これは、そのスレーブはすぐには使用できないことを意味しますが、スレーブがこれら少量の残りのトランザクションに追い付くために比較的短い時間しか必要ないはずです。
      </p><p>
        前もってターゲットサーバーにバイナリログをコピーすることは、トランザクション実行履歴全体をリアルタイムにマスターから読み取るよりも、通常は速いです。ただし、サイズやその他の考慮事項により、必要なときにこれらのファイルをターゲットに移動することが常に実現できるとはかぎらない場合があります。このセクションで説明した新しいスレーブをプロビジョニングするための残りの 2 つの方法は、別の手段を使用してトランザクションに関する情報を新しいスレーブに転送します。
      </p><p><a name="replication-gtids-failover-empty"></a><b>空のトランザクションの注入 </b>
          マスターのグローバル <code class="literal">gtid_executed</code> 変数には、マスターで実行されるすべてのトランザクションのセットが含まれます。新しいサーバーをプロビジョニングするためにスナップショットを作成するときにバイナリログをコピーする代わりに、スナップショットが作成されたサーバーで <code class="literal">gtid_executed</code> の内容に注目できます。新しいサーバーをレプリケーションチェーンに追加する前に、マスターの <code class="literal">gtid_executed</code> に含まれるトランザクション識別子ごとに、新しいサーバーで次のように単純に空のトランザクションをコミットします。
        </p><pre class="programlisting">
SET GTID_NEXT='aaa-bbb-ccc-ddd:N';

BEGIN;
COMMIT;

SET GTID_NEXT='AUTOMATIC';
</pre><p>
        すべてのトランザクション識別子が空のトランザクションを使用してこのように回復されたあとに、ここで示すようにスレーブのバイナリログをフラッシュしてパージする必要があります。ここで、<em class="replaceable"><code>N</code></em> は現在のバイナリログファイル名のゼロでないサフィクスです。
      </p><pre class="programlisting">
FLUSH LOGS;
PURGE BINARY LOGS TO 'master-bin.00000<em class="replaceable"><code>N</code></em>';
</pre><p>
        あとでマスターに昇格されたときにこのサーバーが不適切なトランザクションでレプリケーションストリームがあふれるのを回避するために、これを行うことをお勧めします。(<code class="literal">FLUSH LOGS</code> ステートメントは強制的に新しいバイナリログファイルを作成します。<code class="literal">PURGE BINARY LOGS</code> は空のトランザクションをパージしますが、その識別子を保持します。)
      </p><p>
        この方法は、本質的にはスナップショットであるけれども、あとでマスターになれるサーバーを作成します (そのバイナリログ履歴がレプリケーションストリームのそれに一致したとき、つまりマスターに追い付いたとき)。この結果は、残りのプロビジョニング方法を使用して得られる結果に実質的に似ています (次のいくつかの段落で説明します)。
      </p><p><a name="replication-gtids-failover-gtid-purged"></a><b>gtid_purged によるトランザクションの除外 </b>
          マスターのグローバル <code class="literal">gtid_purged</code> 変数には、マスターのバイナリログからパージされたすべてのトランザクションのセットが含まれます。前に説明した方法と同様に (<a class="xref" href="replication.html#replication-gtids-failover-empty" title="空のトランザクションの注入">空のトランザクションの注入</a>を参照してください)、スナップショットが作成されたサーバーで (バイナリログを新しいサーバーにコピーする代わりに) <code class="literal">gtid_executed</code> の値を記録できます。前の方法とは異なり、空のトランザクションをコミットする必要はありません (<code class="literal">PURGE BINARY LOGS</code> を発行する必要はありません)。代わりに、バックアップまたはスナップショットが作成されたサーバーの <code class="literal">gtid_executed</code> の値に基づいて、スレーブで直接 <code class="literal">gtid_purged</code> を設定できます。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          MySQL 5.6.9 より前は、<code class="literal">gtid_purged</code> を設定できませんでした。(Bug #14797808)
        </p></div><p>
        空のトランザクションを使用する方法と同様に、この方法は、機能的にはスナップショットであるけれども、あとでマスターになれるサーバーを作成します (そのバイナリログ履歴がレプリケーションマスターまたはグループのそれに一致したとき)。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-gtids-restrictions"></a>17.1.3.4 GTID ベースレプリケーションの制約</h4></div></div></div><p>
        GTID ベースレプリケーションはトランザクションに依存しているため、そうでなければ MySQL で使用できるいくつかの機能が、それを使用するときにサポートされません。このセクションでは、GTID ベースレプリケーションの制約と制限についての情報を提供します。
      </p><p><b>非トランザクションストレージエンジンに関係する更新 </b>
          GTID を使用する場合、<code class="literal">MyISAM</code> などの非トランザクションストレージエンジンを使用するテーブルへの更新は、<code class="literal">InnoDB</code> などのトランザクションストレージエンジンを使用するテーブルへの更新と同じステートメントまたはトランザクションで実行できません。
        </p><p>
        この制約は、非トランザクションストレージエンジンを使用するテーブルへの更新とトランザクションストレージエンジンを使用するテーブルへの更新が、同じトランザクション内に混在していると、複数の GTID が同じトランザクションに割り当てられる可能性があるためです。
      </p><p>
        このような問題は、マスターとスレーブが異なるストレージエンジンをそれぞれのバージョンの同じテーブルに使用するときにも発生する可能性があります (一方のストレージエンジンはトランザクション、他方はそうではない)。
      </p><p>
        今挙げたいずれの場合も、トランザクションと GTID との間の 1 対 1 対応が壊れていて、GTID ベースレプリケーションは正しく機能できません。
      </p><p><b>CREATE TABLE ... SELECT ステートメント </b>
          <code class="literal">CREATE TABLE ... SELECT</code> はステートメントベースレプリケーションには安全ではありません。行ベースレプリケーションを使用する場合、このステートメントのログは実際には 2 つの異なるイベントとして記録されます。1 つはテーブルを作成するためのもの、他方はソーステーブルから作成されたばかりの新しいテーブルに行を挿入するためのものです。このステートメントがトランザクション内で実行されると、同じトランザクション識別子を受け取るこれらの 2 つのイベントにいくつかのケースが可能であり、これは挿入を含むトランザクションがスレーブによってスキップされることを意味します。このため、GTID ベースレプリケーションを使用する場合は、<code class="literal">CREATE TABLE ... SELECT</code> はサポートされません。
        </p><p><b>一時テーブル </b>
          <code class="literal">CREATE TEMPORARY TABLE</code> および <code class="literal">DROP TEMPORARY TABLE</code> ステートメントは、GTID を使用するとき (つまり、サーバーが <code class="option">--enforce-gtid-consistency</code> オプションで起動されたとき) に、トランザクション内でサポートされません。GTID を有効にした状態でこれらのステートメントを使用することは可能です (ただし、トランザクションの外側のみ、および <code class="literal">autocommit=1</code> のときのみ)。
        </p><p><b>サポートされないステートメントの実行の回避 </b>
          GTID ベースレプリケーションが失敗するステートメントの実行を回避するために、GTID を有効にするときは、すべてのサーバーが <code class="option">--enforce-gtid-consistency</code> オプションで起動される必要があります。これにより、このセクションですでに説明したタイプのステートメントはエラーで失敗します。
        </p><p>
        GTID を有効にするときに必要なほかの起動オプションについては、<a class="xref" href="replication.html#replication-gtids-howto" title="17.1.3.2 GTID を使用したレプリケーションのセットアップ">セクション17.1.3.2「GTID を使用したレプリケーションのセットアップ」</a>を参照してください。
      </p><p>
        GTID を使用するときに、<code class="literal">sql_slave_skip_counter</code> はサポートされません。トランザクションをスキップする必要がある場合は、代わりにマスターの <code class="literal">gtid_executed</code> 変数を使用してください。詳細については、<a class="xref" href="replication.html#replication-gtids-failover-empty" title="空のトランザクションの注入">空のトランザクションの注入</a>を参照してください。
      </p><p><a name="replication-gtids-restrictions-mysqldump"></a><b>GTID モードと mysqldump </b>
          MySQL 5.6.9 以降では、ターゲットサーバーのバイナリログに GTID がないこと場合に、<span class="command"><strong>mysqldump</strong></span> を使用して作成されたダンプを GTID モードが有効な状態で動作する MySQL Server にインポートできます。
        </p><p>
        MySQL 5.6.9 より前では、<span class="command"><strong>mysqldump</strong></span> はグローバルトランザクション ID を記録せず、GTID をリストアするためにバイナリログと <span class="command"><strong>mysqlbinlog</strong></span> を使用する必要がありました。(Bug #14797808、Bug #14832472)
      </p><p><a name="replication-gtids-restrictions-mysql_upgrade"></a><b>GTID モードと mysql_upgrade </b>
          MySQL 5.6.7 より前では、<span class="command"><strong>mysql_upgrade</strong></span> が <code class="option">--write-binlog=OFF</code> で実行されないかぎり、<span class="command"><strong>mysql_upgrade</strong></span> は <code class="option">--gtid-mode=ON</code> で動作する MySQL Server に接続できませんでした。(そうでない場合は、<span class="command"><strong>mysqld</strong></span> は、<span class="command"><strong>mysql_upgrade</strong></span> を実行する前に <code class="option">--gtid-mode=OFF</code> で再起動されてから、あとで <code class="option">--gtid_mode=ON</code> で再起動される必要がありました。)これは MySQL 5.6.7 以降では問題ではなく、<span class="command"><strong>mysql_upgrade</strong></span> はデフォルトで <code class="option">--write-binlog=OFF</code> で動作します。(Bug #13833710) ただし、そのようにすることは推奨されません。<span class="command"><strong>mysql_upgrade</strong></span> が <code class="literal">MyISAM</code> ストレージエンジン (非トランザクション) を使用するシステムテーブルに変更を加えることができるためです。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-options"></a>17.1.4 レプリケーションおよびバイナリロギングのオプションと変数</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-options-table">17.1.4.1 レプリケーション、バイナリロギングオプション、および変数のリファレンス</a></span></dt><dt><span class="section"><a href="replication.html#replication-options-master">17.1.4.2 レプリケーションマスターのオプションと変数</a></span></dt><dt><span class="section"><a href="replication.html#replication-options-slave">17.1.4.3 レプリケーションスレーブのオプションと変数</a></span></dt><dt><span class="section"><a href="replication.html#replication-options-binary-log">17.1.4.4 バイナリログのオプションと変数</a></span></dt><dt><span class="section"><a href="replication.html#replication-options-gtids">17.1.4.5 グローバルトランザクション ID のオプションと変数</a></span></dt></dl></div><p>
    以降のセクションでは、<span class="command"><strong>mysqld</strong></span> オプション、およびレプリケーションで使用されてバイナリログを制御するためのサーバー変数の情報について説明します。レプリケーションマスターとレプリケーションスレーブで使用されるオプションと変数のうち、バイナリロギングに関係するオプションおよび変数であるものは、別途説明します。これらのオプションと変数に関する基本情報するクイックリファレンス表のセットも含まれています。
  </p><p><a name="option_mysqld_server-id"></a>
    <a class="indexterm" name="idm139979055070160"></a> <a class="indexterm" name="idm139979055068112"></a> 特に重要なものは <code class="option">--server-id</code> オプションです。
  </p><div class="informaltable"><table summary="Options for server-id" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--server-id=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="server-administration.html#sysvar_server_id">server_id</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">4294967295</code></td></tr></tbody></table></div><p>
    このオプションはマスターとスレーブのどちらのレプリケーションサーバーに共通で、レプリケーションで使用され、マスターおよびスレーブサーバーがそれら自身を一意に識別できます。詳細については、<a class="xref" href="replication.html#replication-options-master" title="17.1.4.2 レプリケーションマスターのオプションと変数">セクション17.1.4.2「レプリケーションマスターのオプションと変数」</a>,および<a class="xref" href="replication.html#replication-options-slave" title="17.1.4.3 レプリケーションスレーブのオプションと変数">セクション17.1.4.3「レプリケーションスレーブのオプションと変数」</a>を参照してください。
  </p><p>
    マスターおよび各スレーブでは、<code class="option">--server-id</code> オプションを使用して、範囲が 1 から 2<sup>32</sup> − 1 の一意レプリケーション ID を確立する<span class="emphasis"><em>必要があります</em></span>。<span class="quote">「<span class="quote">一意</span>」</span>とは、各 ID が、ほかのレプリケーションマスターまたはスレーブで使用されるほかのあらゆる ID と異なっている必要があるということです。たとえば、<code class="literal">server-id=3</code>。
  </p><p>
    <code class="option">--server-id</code> を省略すると、デフォルト ID は 0 になり、この場合、マスターはすべてのスレーブからの接続を拒否し、スレーブはマスターへの接続を拒否します。MySQL 5.6 では、サーバー ID が明示的に 0 に設定されていても、デフォルトの使用が許可されていても、サーバーは <code class="literal">server_id</code> システム変数を 1 に設定します。これは MySQL 5.7 で修正された既知の問題です。
  </p><p>
    詳細については、<a class="xref" href="replication.html#replication-howto-slavebaseconfig" title="17.1.1.2 レプリケーションスレーブ構成の設定">セクション17.1.1.2「レプリケーションスレーブ構成の設定」</a>を参照してください。
  </p><p><a name="sysvar_server_uuid"></a>
    <a class="indexterm" name="idm139979055030880"></a> <a class="indexterm" name="idm139979055028816"></a> <code class="literal">server_uuid</code>
  </p><p>
    MySQL 5.6 以降、サーバーはユーザーが指定する <code class="option">--server-id</code> に加えて真の UUID を生成します。これは、グローバルな読み取り専用変数 <code class="literal">server_uuid</code> として使用できます。
  </p><div class="informaltable"><table summary="Options for server_uuid" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.0</td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_server_uuid">server_uuid</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr></tbody></table></div><p>
    起動時、MySQL サーバーは次のように自動的に UUID を取得します。
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
        <a class="indexterm" name="idm139979055004880"></a> ファイル <code class="filename"><em class="replaceable"><code>data_dir</code></em>/auto.cnf</code> に書かれている UUID を読み取って使用しようとします (ここで、<em class="replaceable"><code>data_dir</code></em> はサーバーのデータディレクトリ)。
      </p></li><li class="listitem"><p>
        <code class="filename"><em class="replaceable"><code>data_dir</code></em>/auto.cnf</code> が見つからない場合、新しい UUID を生成してこのファイルに保存します (必要に応じてファイルを作成します)。
      </p></li></ol></div><p>
    <code class="filename">auto.cnf</code> ファイルは、<code class="filename">my.cnf</code> または <code class="filename">my.ini</code> ファイルに使用されるものに類似した形式です。MySQL 5.6 では、<code class="filename">auto.cnf</code> に単一 <code class="literal">server_uuid</code> 設定と値を含む、単一 <code class="literal">[auto]</code> セクションのみがあります。ファイルの内容は次に示すものに似ています。
  </p><pre class="programlisting">
[auto]
server_uuid=8a94f357-aab4-11df-86ab-c80aa9429562
</pre><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
      <code class="filename">auto.cnf</code> ファイルは自動的に生成されます。このファイルを書き込んだり修正したりしようとしないでください。
    </p></div><p>
    MySQL 5.6 以降では、MySQL レプリケーションを使用するときに、マスターとスレーブは互いの UUID がわかります。スレーブの UUID の値は <code class="literal">SHOW SLAVE HOSTS</code> の出力で確認できます。<code class="literal">START SLAVE</code> が実行されたあとは (前ではありません)、マスターの UUID の値はスレーブでは <code class="literal">SHOW SLAVE STATUS</code> の出力で確認できます。
  </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
      <code class="literal">STOP SLAVE</code> または <code class="literal">RESET SLAVE</code> ステートメントを発行しても、スレーブで使用されるマスターの UUID はリセット<span class="emphasis"><em>されません</em></span>。
    </p></div><p>
    MySQL 5.6.5 以降では、サーバーの <code class="literal">server_uuid</code> は、そのサーバーで発生するトランザクションの GTID でも使用されます。詳細は、<a class="xref" href="replication.html#replication-gtids" title="17.1.3 グローバルトランザクション識別子を使用したレプリケーション">セクション17.1.3「グローバルトランザクション識別子を使用したレプリケーション」</a>を参照してください。
  </p><p>
    起動時に、スレーブ I/O スレッドは、そのマスターの UUID がそれ自身と等しい場合、<code class="option">--replicate-same-server-id</code> オプションが設定されている場合を除き、エラーを生成して中断します。また次のどちらかが true の場合、スレーブ I/O スレッドは警告を生成します。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        予期された <code class="literal">server_uuid</code> を持つマスターが存在しない。
      </p></li><li class="listitem"><p>
        <code class="literal">CHANGE MASTER TO</code> ステートメントがこれまで実行されなかったのみ、マスターの <code class="literal">server_uuid</code> が変化した。
      </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
      MySQL 5.6 で <code class="literal">server_uuid</code> システム変数が追加されても、このセクションですでに説明したように、MySQL レプリケーションの準備と実行の一部として MySQL サーバーごとに一意の <code class="option">--server-id</code> を設定する必要があることは変わりません。
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-options-table"></a>17.1.4.1 レプリケーション、バイナリロギングオプション、および変数のリファレンス</h4></div></div></div><p>
      次の表は、レプリケーションおよびバイナリログに適用できる、MySQL コマンド行オプションとシステム変数に関する基本情報の一覧です。
    </p><div class="table"><a name="replication-optvar-summary-table"></a><p class="title"><b>表 17.1 MySQL 5.6 でのレプリケーションのオプションおよび変数のサマリー</b></p><div class="table-contents"><table id="replication-optvar-summary-table" summary="Replication Options and Variables: MySQL 5.6"><col width="33%"><col width="33%"><col width="33%"><thead><tr>
      <th id="replicationoptvar" colspan="3" abbr="Name" align="center">オプションまたは変数名</th>
    </tr><tr>
      <th id="replicationcli" abbr="CLI">コマンド行</th>
      <th id="replicationsysvar" abbr="System">システム変数</th>
      <th id="replicationstatvar" abbr="Status">ステータス変数</th>
    </tr><tr>
      <th id="replicationoptfile" abbr="File">オプションファイル</th>
      <th id="replicationscope">スコープ</th>
      <th id="replicationdynamic">動的</th>
    </tr><tr>
      <th id="replicationnotes" colspan="3">メモ</th>
    </tr></thead><tbody><tr>
      <td colspan="3" align="center" id="rowCom_change_master" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#statvar_Com_xxx">Com_change_master</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowCom_change_master replicationcli">いいえ</td>
      <td headers="rowCom_change_master replicationsysvar">いいえ</td>
      <td headers="rowCom_change_master replicationstatvar">はい</td>
    </tr><tr>
      <td headers="rowCom_change_master replicationoptfile">いいえ</td>
      <td headers="rowCom_change_master replicationscope">両方</td>
      <td headers="rowCom_change_master replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowCom_change_master replicationnotes">
        <p>
          説明: CHANGE MASTER ステートメントの数
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowCom_show_master_status" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#statvar_Com_xxx">Com_show_master_status</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowCom_show_master_status replicationcli">いいえ</td>
      <td headers="rowCom_show_master_status replicationsysvar">いいえ</td>
      <td headers="rowCom_show_master_status replicationstatvar">はい</td>
    </tr><tr>
      <td headers="rowCom_show_master_status replicationoptfile">いいえ</td>
      <td headers="rowCom_show_master_status replicationscope">両方</td>
      <td headers="rowCom_show_master_status replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowCom_show_master_status replicationnotes">
        <p>
          説明: SHOW MASTER STATUS ステートメントの数
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowCom_show_new_master" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#statvar_Com_xxx">Com_show_new_master</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowCom_show_new_master replicationcli">いいえ</td>
      <td headers="rowCom_show_new_master replicationsysvar">いいえ</td>
      <td headers="rowCom_show_new_master replicationstatvar">はい</td>
    </tr><tr>
      <td headers="rowCom_show_new_master replicationoptfile">いいえ</td>
      <td headers="rowCom_show_new_master replicationscope">両方</td>
      <td headers="rowCom_show_new_master replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowCom_show_new_master replicationnotes">
        <p>
          説明: SHOW NEW MASTER ステートメントの数
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowCom_show_slave_hosts" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#statvar_Com_xxx">Com_show_slave_hosts</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowCom_show_slave_hosts replicationcli">いいえ</td>
      <td headers="rowCom_show_slave_hosts replicationsysvar">いいえ</td>
      <td headers="rowCom_show_slave_hosts replicationstatvar">はい</td>
    </tr><tr>
      <td headers="rowCom_show_slave_hosts replicationoptfile">いいえ</td>
      <td headers="rowCom_show_slave_hosts replicationscope">両方</td>
      <td headers="rowCom_show_slave_hosts replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowCom_show_slave_hosts replicationnotes">
        <p>
          説明: SHOW SLAVE HOSTS ステートメントの数
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowCom_show_slave_status" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#statvar_Com_xxx">Com_show_slave_status</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowCom_show_slave_status replicationcli">いいえ</td>
      <td headers="rowCom_show_slave_status replicationsysvar">いいえ</td>
      <td headers="rowCom_show_slave_status replicationstatvar">はい</td>
    </tr><tr>
      <td headers="rowCom_show_slave_status replicationoptfile">いいえ</td>
      <td headers="rowCom_show_slave_status replicationscope">両方</td>
      <td headers="rowCom_show_slave_status replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowCom_show_slave_status replicationnotes">
        <p>
          説明: SHOW SLAVE STATUS ステートメントの数
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowCom_slave_start" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#statvar_Com_xxx">Com_slave_start</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowCom_slave_start replicationcli">いいえ</td>
      <td headers="rowCom_slave_start replicationsysvar">いいえ</td>
      <td headers="rowCom_slave_start replicationstatvar">はい</td>
    </tr><tr>
      <td headers="rowCom_slave_start replicationoptfile">いいえ</td>
      <td headers="rowCom_slave_start replicationscope">両方</td>
      <td headers="rowCom_slave_start replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowCom_slave_start replicationnotes">
        <p>
          説明: START SLAVE ステートメントの数
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowCom_slave_stop" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#statvar_Com_xxx">Com_slave_stop</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowCom_slave_stop replicationcli">いいえ</td>
      <td headers="rowCom_slave_stop replicationsysvar">いいえ</td>
      <td headers="rowCom_slave_stop replicationstatvar">はい</td>
    </tr><tr>
      <td headers="rowCom_slave_stop replicationoptfile">いいえ</td>
      <td headers="rowCom_slave_stop replicationscope">両方</td>
      <td headers="rowCom_slave_stop replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowCom_slave_stop replicationnotes">
        <p>
          説明: STOP SLAVE ステートメントの数
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowRpl_semi_sync_master_clients" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_clients">Rpl_semi_sync_master_clients</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowRpl_semi_sync_master_clients replicationcli">いいえ</td>
      <td headers="rowRpl_semi_sync_master_clients replicationsysvar">いいえ</td>
      <td headers="rowRpl_semi_sync_master_clients replicationstatvar">はい</td>
    </tr><tr>
      <td headers="rowRpl_semi_sync_master_clients replicationoptfile">いいえ</td>
      <td headers="rowRpl_semi_sync_master_clients replicationscope">グローバル</td>
      <td headers="rowRpl_semi_sync_master_clients replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowRpl_semi_sync_master_clients replicationnotes">
        <p>
          説明: 準同期スレーブの数
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowRpl_semi_sync_master_net_avg_wait_time" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_net_avg_wait_time">Rpl_semi_sync_master_net_avg_wait_time</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowRpl_semi_sync_master_net_avg_wait_time replicationcli">いいえ</td>
      <td headers="rowRpl_semi_sync_master_net_avg_wait_time replicationsysvar">いいえ</td>
      <td headers="rowRpl_semi_sync_master_net_avg_wait_time replicationstatvar">はい</td>
    </tr><tr>
      <td headers="rowRpl_semi_sync_master_net_avg_wait_time replicationoptfile">いいえ</td>
      <td headers="rowRpl_semi_sync_master_net_avg_wait_time replicationscope">グローバル</td>
      <td headers="rowRpl_semi_sync_master_net_avg_wait_time replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowRpl_semi_sync_master_net_avg_wait_time replicationnotes">
        <p>
          説明: マスターがスレーブ応答を待機した平均時間
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowRpl_semi_sync_master_net_wait_time" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_net_wait_time">Rpl_semi_sync_master_net_wait_time</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowRpl_semi_sync_master_net_wait_time replicationcli">いいえ</td>
      <td headers="rowRpl_semi_sync_master_net_wait_time replicationsysvar">いいえ</td>
      <td headers="rowRpl_semi_sync_master_net_wait_time replicationstatvar">はい</td>
    </tr><tr>
      <td headers="rowRpl_semi_sync_master_net_wait_time replicationoptfile">いいえ</td>
      <td headers="rowRpl_semi_sync_master_net_wait_time replicationscope">グローバル</td>
      <td headers="rowRpl_semi_sync_master_net_wait_time replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowRpl_semi_sync_master_net_wait_time replicationnotes">
        <p>
          説明: マスターがスレーブ応答を待機した合計時間
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowRpl_semi_sync_master_net_waits" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_net_waits">Rpl_semi_sync_master_net_waits</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowRpl_semi_sync_master_net_waits replicationcli">いいえ</td>
      <td headers="rowRpl_semi_sync_master_net_waits replicationsysvar">いいえ</td>
      <td headers="rowRpl_semi_sync_master_net_waits replicationstatvar">はい</td>
    </tr><tr>
      <td headers="rowRpl_semi_sync_master_net_waits replicationoptfile">いいえ</td>
      <td headers="rowRpl_semi_sync_master_net_waits replicationscope">グローバル</td>
      <td headers="rowRpl_semi_sync_master_net_waits replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowRpl_semi_sync_master_net_waits replicationnotes">
        <p>
          説明: マスターがスレーブ応答を待機した合計回数
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowRpl_semi_sync_master_no_times" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_no_times">Rpl_semi_sync_master_no_times</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowRpl_semi_sync_master_no_times replicationcli">いいえ</td>
      <td headers="rowRpl_semi_sync_master_no_times replicationsysvar">いいえ</td>
      <td headers="rowRpl_semi_sync_master_no_times replicationstatvar">はい</td>
    </tr><tr>
      <td headers="rowRpl_semi_sync_master_no_times replicationoptfile">いいえ</td>
      <td headers="rowRpl_semi_sync_master_no_times replicationscope">グローバル</td>
      <td headers="rowRpl_semi_sync_master_no_times replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowRpl_semi_sync_master_no_times replicationnotes">
        <p>
          説明: マスターが準同期レプリケーションをオフにした回数
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowRpl_semi_sync_master_no_tx" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_no_tx">Rpl_semi_sync_master_no_tx</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowRpl_semi_sync_master_no_tx replicationcli">いいえ</td>
      <td headers="rowRpl_semi_sync_master_no_tx replicationsysvar">いいえ</td>
      <td headers="rowRpl_semi_sync_master_no_tx replicationstatvar">はい</td>
    </tr><tr>
      <td headers="rowRpl_semi_sync_master_no_tx replicationoptfile">いいえ</td>
      <td headers="rowRpl_semi_sync_master_no_tx replicationscope">グローバル</td>
      <td headers="rowRpl_semi_sync_master_no_tx replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowRpl_semi_sync_master_no_tx replicationnotes">
        <p>
          説明: 正常に肯定応答されなかったコミットの数
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowRpl_semi_sync_master_status" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_status">Rpl_semi_sync_master_status</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowRpl_semi_sync_master_status replicationcli">いいえ</td>
      <td headers="rowRpl_semi_sync_master_status replicationsysvar">いいえ</td>
      <td headers="rowRpl_semi_sync_master_status replicationstatvar">はい</td>
    </tr><tr>
      <td headers="rowRpl_semi_sync_master_status replicationoptfile">いいえ</td>
      <td headers="rowRpl_semi_sync_master_status replicationscope">グローバル</td>
      <td headers="rowRpl_semi_sync_master_status replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowRpl_semi_sync_master_status replicationnotes">
        <p>
          説明: 準同期レプリケーションがマスター上で動作しているかどうか
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowRpl_semi_sync_master_timefunc_failures" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_timefunc_failures">Rpl_semi_sync_master_timefunc_failures</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowRpl_semi_sync_master_timefunc_failures replicationcli">いいえ</td>
      <td headers="rowRpl_semi_sync_master_timefunc_failures replicationsysvar">いいえ</td>
      <td headers="rowRpl_semi_sync_master_timefunc_failures replicationstatvar">はい</td>
    </tr><tr>
      <td headers="rowRpl_semi_sync_master_timefunc_failures replicationoptfile">いいえ</td>
      <td headers="rowRpl_semi_sync_master_timefunc_failures replicationscope">グローバル</td>
      <td headers="rowRpl_semi_sync_master_timefunc_failures replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowRpl_semi_sync_master_timefunc_failures replicationnotes">
        <p>
          説明: 時間関数を呼び出すときにマスターが失敗した回数
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowRpl_semi_sync_master_tx_avg_wait_time" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_tx_avg_wait_time">Rpl_semi_sync_master_tx_avg_wait_time</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowRpl_semi_sync_master_tx_avg_wait_time replicationcli">いいえ</td>
      <td headers="rowRpl_semi_sync_master_tx_avg_wait_time replicationsysvar">いいえ</td>
      <td headers="rowRpl_semi_sync_master_tx_avg_wait_time replicationstatvar">はい</td>
    </tr><tr>
      <td headers="rowRpl_semi_sync_master_tx_avg_wait_time replicationoptfile">いいえ</td>
      <td headers="rowRpl_semi_sync_master_tx_avg_wait_time replicationscope">グローバル</td>
      <td headers="rowRpl_semi_sync_master_tx_avg_wait_time replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowRpl_semi_sync_master_tx_avg_wait_time replicationnotes">
        <p>
          説明: マスターが各トランザクションを待機した平均時間
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowRpl_semi_sync_master_tx_wait_time" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_tx_wait_time">Rpl_semi_sync_master_tx_wait_time</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowRpl_semi_sync_master_tx_wait_time replicationcli">いいえ</td>
      <td headers="rowRpl_semi_sync_master_tx_wait_time replicationsysvar">いいえ</td>
      <td headers="rowRpl_semi_sync_master_tx_wait_time replicationstatvar">はい</td>
    </tr><tr>
      <td headers="rowRpl_semi_sync_master_tx_wait_time replicationoptfile">いいえ</td>
      <td headers="rowRpl_semi_sync_master_tx_wait_time replicationscope">グローバル</td>
      <td headers="rowRpl_semi_sync_master_tx_wait_time replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowRpl_semi_sync_master_tx_wait_time replicationnotes">
        <p>
          説明: マスターがトランザクションを待機した合計時間
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowRpl_semi_sync_master_tx_waits" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_tx_waits">Rpl_semi_sync_master_tx_waits</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowRpl_semi_sync_master_tx_waits replicationcli">いいえ</td>
      <td headers="rowRpl_semi_sync_master_tx_waits replicationsysvar">いいえ</td>
      <td headers="rowRpl_semi_sync_master_tx_waits replicationstatvar">はい</td>
    </tr><tr>
      <td headers="rowRpl_semi_sync_master_tx_waits replicationoptfile">いいえ</td>
      <td headers="rowRpl_semi_sync_master_tx_waits replicationscope">グローバル</td>
      <td headers="rowRpl_semi_sync_master_tx_waits replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowRpl_semi_sync_master_tx_waits replicationnotes">
        <p>
          説明: マスターがトランザクションを待機した合計回数
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowRpl_semi_sync_master_wait_pos_backtraverse" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_wait_pos_backtraverse">Rpl_semi_sync_master_wait_pos_backtraverse</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowRpl_semi_sync_master_wait_pos_backtraverse replicationcli">いいえ</td>
      <td headers="rowRpl_semi_sync_master_wait_pos_backtraverse replicationsysvar">いいえ</td>
      <td headers="rowRpl_semi_sync_master_wait_pos_backtraverse replicationstatvar">はい</td>
    </tr><tr>
      <td headers="rowRpl_semi_sync_master_wait_pos_backtraverse replicationoptfile">いいえ</td>
      <td headers="rowRpl_semi_sync_master_wait_pos_backtraverse replicationscope">グローバル</td>
      <td headers="rowRpl_semi_sync_master_wait_pos_backtraverse replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowRpl_semi_sync_master_wait_pos_backtraverse replicationnotes">
        <p>
          説明: 以前待機したイベントよりもバイナリ座標が低いイベントをマスターが待機した合計回数
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowRpl_semi_sync_master_wait_sessions" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_wait_sessions">Rpl_semi_sync_master_wait_sessions</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowRpl_semi_sync_master_wait_sessions replicationcli">いいえ</td>
      <td headers="rowRpl_semi_sync_master_wait_sessions replicationsysvar">いいえ</td>
      <td headers="rowRpl_semi_sync_master_wait_sessions replicationstatvar">はい</td>
    </tr><tr>
      <td headers="rowRpl_semi_sync_master_wait_sessions replicationoptfile">いいえ</td>
      <td headers="rowRpl_semi_sync_master_wait_sessions replicationscope">グローバル</td>
      <td headers="rowRpl_semi_sync_master_wait_sessions replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowRpl_semi_sync_master_wait_sessions replicationnotes">
        <p>
          説明: 現在スレーブ応答を待機しているセッションの数
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowRpl_semi_sync_master_yes_tx" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_master_yes_tx">Rpl_semi_sync_master_yes_tx</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowRpl_semi_sync_master_yes_tx replicationcli">いいえ</td>
      <td headers="rowRpl_semi_sync_master_yes_tx replicationsysvar">いいえ</td>
      <td headers="rowRpl_semi_sync_master_yes_tx replicationstatvar">はい</td>
    </tr><tr>
      <td headers="rowRpl_semi_sync_master_yes_tx replicationoptfile">いいえ</td>
      <td headers="rowRpl_semi_sync_master_yes_tx replicationscope">グローバル</td>
      <td headers="rowRpl_semi_sync_master_yes_tx replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowRpl_semi_sync_master_yes_tx replicationnotes">
        <p>
          説明: 正常に肯定応答されたコミットの数
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowRpl_semi_sync_slave_status" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#statvar_Rpl_semi_sync_slave_status">Rpl_semi_sync_slave_status</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowRpl_semi_sync_slave_status replicationcli">いいえ</td>
      <td headers="rowRpl_semi_sync_slave_status replicationsysvar">いいえ</td>
      <td headers="rowRpl_semi_sync_slave_status replicationstatvar">はい</td>
    </tr><tr>
      <td headers="rowRpl_semi_sync_slave_status replicationoptfile">いいえ</td>
      <td headers="rowRpl_semi_sync_slave_status replicationscope">グローバル</td>
      <td headers="rowRpl_semi_sync_slave_status replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowRpl_semi_sync_slave_status replicationnotes">
        <p>
          説明: 準同期レプリケーションがスレーブ上で動作しているかどうか
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowslave_exec_mode" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_slave_exec_mode">slave_exec_mode</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowslave_exec_mode replicationcli">はい</td>
      <td headers="rowslave_exec_mode replicationsysvar">はい</td>
      <td headers="rowslave_exec_mode replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowslave_exec_mode replicationoptfile">はい</td>
      <td headers="rowslave_exec_mode replicationscope">グローバル</td>
      <td headers="rowslave_exec_mode replicationdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowslave_exec_mode replicationnotes">
        <p>
          説明: スレーブスレッドを IDEMPOTENT モード (重大なおよびほかのいくつかのエラーが抑止されます) と STRICT モードの間で切り替えることを許可します。IDEMPOTENT が常に使用される MySQL Cluster を除いて、STRICT モードがデフォルトです。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowSlave_open_temp_tables" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#statvar_Slave_open_temp_tables">Slave_open_temp_tables</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowSlave_open_temp_tables replicationcli">いいえ</td>
      <td headers="rowSlave_open_temp_tables replicationsysvar">いいえ</td>
      <td headers="rowSlave_open_temp_tables replicationstatvar">はい</td>
    </tr><tr>
      <td headers="rowSlave_open_temp_tables replicationoptfile">いいえ</td>
      <td headers="rowSlave_open_temp_tables replicationscope">グローバル</td>
      <td headers="rowSlave_open_temp_tables replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowSlave_open_temp_tables replicationnotes">
        <p>
          説明: スレーブ SQL スレッドが現在開いている一時テーブルの数
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowSlave_retried_transactions" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#statvar_Slave_retried_transactions">Slave_retried_transactions</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowSlave_retried_transactions replicationcli">いいえ</td>
      <td headers="rowSlave_retried_transactions replicationsysvar">いいえ</td>
      <td headers="rowSlave_retried_transactions replicationstatvar">はい</td>
    </tr><tr>
      <td headers="rowSlave_retried_transactions replicationoptfile">いいえ</td>
      <td headers="rowSlave_retried_transactions replicationscope">グローバル</td>
      <td headers="rowSlave_retried_transactions replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowSlave_retried_transactions replicationnotes">
        <p>
          説明: 起動以降、レプリケーションスレーブ SQL スレッドがトランザクションを再試行した合計回数
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowSlave_running" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#statvar_Slave_running">Slave_running</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowSlave_running replicationcli">いいえ</td>
      <td headers="rowSlave_running replicationsysvar">いいえ</td>
      <td headers="rowSlave_running replicationstatvar">はい</td>
    </tr><tr>
      <td headers="rowSlave_running replicationoptfile">いいえ</td>
      <td headers="rowSlave_running replicationscope">グローバル</td>
      <td headers="rowSlave_running replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowSlave_running replicationnotes">
        <p>
          説明: このサーバーのレプリケーションスレーブとしての状態 (スレーブ I/O スレッドステータス)
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowabort-slave-event-count" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_abort-slave-event-count">abort-slave-event-count</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowabort-slave-event-count replicationcli">はい</td>
      <td headers="rowabort-slave-event-count replicationsysvar">いいえ</td>
      <td headers="rowabort-slave-event-count replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowabort-slave-event-count replicationoptfile">はい</td>
      <td headers="rowabort-slave-event-count replicationscope"></td>
      <td headers="rowabort-slave-event-count replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowabort-slave-event-count replicationnotes">
        <p>
          説明: mysql-test によってレプリケーションのデバッグとテストのために使用されるオプション
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowbinlog_gtid_recovery_simplified" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_binlog_gtid_recovery_simplified">binlog_gtid_recovery_simplified</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowbinlog_gtid_recovery_simplified replicationcli">はい</td>
      <td headers="rowbinlog_gtid_recovery_simplified replicationsysvar">はい</td>
      <td headers="rowbinlog_gtid_recovery_simplified replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowbinlog_gtid_recovery_simplified replicationoptfile">はい</td>
      <td headers="rowbinlog_gtid_recovery_simplified replicationscope">グローバル</td>
      <td headers="rowbinlog_gtid_recovery_simplified replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowbinlog_gtid_recovery_simplified replicationnotes">
        <p>
          説明: GTID リカバリ中にバイナリログがどのように反復されるかを制御します
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowdisable-gtid-unsafe-statements" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_disable-gtid-unsafe-statements">disable-gtid-unsafe-statements</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowdisable-gtid-unsafe-statements replicationcli">はい</td>
      <td headers="rowdisable-gtid-unsafe-statements replicationsysvar">はい</td>
      <td headers="rowdisable-gtid-unsafe-statements replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowdisable-gtid-unsafe-statements replicationoptfile">はい</td>
      <td headers="rowdisable-gtid-unsafe-statements replicationscope">グローバル</td>
      <td headers="rowdisable-gtid-unsafe-statements replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowdisable-gtid-unsafe-statements replicationnotes">
        <p>
          説明: 廃止: MySQL 5.6.9 では、--enforce-gtid-consistency によって置き換えられます。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowdisable_gtid_unsafe_statements" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_disable_gtid_unsafe_statements">disable_gtid_unsafe_statements</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowdisable_gtid_unsafe_statements replicationcli">はい</td>
      <td headers="rowdisable_gtid_unsafe_statements replicationsysvar">はい</td>
      <td headers="rowdisable_gtid_unsafe_statements replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowdisable_gtid_unsafe_statements replicationoptfile">はい</td>
      <td headers="rowdisable_gtid_unsafe_statements replicationscope">グローバル</td>
      <td headers="rowdisable_gtid_unsafe_statements replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowdisable_gtid_unsafe_statements replicationnotes">
        <p>
          説明: 廃止: MySQL 5.6.9 では、enforce_gtid_consistency によって置き換えられます。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowdisconnect-slave-event-count" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_disconnect-slave-event-count">disconnect-slave-event-count</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowdisconnect-slave-event-count replicationcli">はい</td>
      <td headers="rowdisconnect-slave-event-count replicationsysvar">いいえ</td>
      <td headers="rowdisconnect-slave-event-count replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowdisconnect-slave-event-count replicationoptfile">はい</td>
      <td headers="rowdisconnect-slave-event-count replicationscope"></td>
      <td headers="rowdisconnect-slave-event-count replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowdisconnect-slave-event-count replicationnotes">
        <p>
          説明: mysql-test によってレプリケーションのデバッグとテストのために使用されるオプション
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowenforce-gtid-consistency" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_enforce-gtid-consistency">enforce-gtid-consistency</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowenforce-gtid-consistency replicationcli">はい</td>
      <td headers="rowenforce-gtid-consistency replicationsysvar">はい</td>
      <td headers="rowenforce-gtid-consistency replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowenforce-gtid-consistency replicationoptfile">はい</td>
      <td headers="rowenforce-gtid-consistency replicationscope">グローバル</td>
      <td headers="rowenforce-gtid-consistency replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowenforce-gtid-consistency replicationnotes">
        <p>
          説明: トランザクションセーフな方法でログを記録できないステートメントの実行を回避します。これらには、トランザクション内の CREATE TEMPORARY TABLE、CREATE TABLE ... SELECT、トランザクションおよび非トランザクションの両方のテーブルを更新するトランザクションやステートメントなどがあります。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowenforce_gtid_consistency" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_enforce_gtid_consistency">enforce_gtid_consistency</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowenforce_gtid_consistency replicationcli">はい</td>
      <td headers="rowenforce_gtid_consistency replicationsysvar">はい</td>
      <td headers="rowenforce_gtid_consistency replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowenforce_gtid_consistency replicationoptfile">はい</td>
      <td headers="rowenforce_gtid_consistency replicationscope">グローバル</td>
      <td headers="rowenforce_gtid_consistency replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowenforce_gtid_consistency replicationnotes">
        <p>
          説明: true のときは、トランザクションセーフな方法でログを記録できないため、ステートメントの実行は許可されません。このようなステートメントには、トランザクション内の CREATE TEMPORARY TABLE、CREATE TABLE ... SELECT、トランザクションおよび非トランザクションの両方のテーブルを更新するトランザクションやステートメントなどがあります。読み取り専用。サーバーの起動時に --disable-gtid-unsafe-statements を使用して設定します。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowgtid_done" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_gtid_done">gtid_done</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowgtid_done replicationcli">いいえ</td>
      <td headers="rowgtid_done replicationsysvar">はい</td>
      <td headers="rowgtid_done replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowgtid_done replicationoptfile">いいえ</td>
      <td headers="rowgtid_done replicationscope">両方</td>
      <td headers="rowgtid_done replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowgtid_done replicationnotes">
        <p>
          説明: 廃止: MySQL 5.6.9 では、gtid_executed に置き換えられました。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowgtid_executed" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_gtid_executed">gtid_executed</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowgtid_executed replicationcli">いいえ</td>
      <td headers="rowgtid_executed replicationsysvar">はい</td>
      <td headers="rowgtid_executed replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowgtid_executed replicationoptfile">いいえ</td>
      <td headers="rowgtid_executed replicationscope">両方</td>
      <td headers="rowgtid_executed replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowgtid_executed replicationnotes">
        <p>
          説明: グローバル: バイナリログ （グローバル） または現在のトランザクション （セッション） 内のすべての GTID。読み取り専用
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowgtid_lost" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_gtid_lost">gtid_lost</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowgtid_lost replicationcli">いいえ</td>
      <td headers="rowgtid_lost replicationsysvar">はい</td>
      <td headers="rowgtid_lost replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowgtid_lost replicationoptfile">いいえ</td>
      <td headers="rowgtid_lost replicationscope">グローバル</td>
      <td headers="rowgtid_lost replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowgtid_lost replicationnotes">
        <p>
          説明: 廃止: MySQL 5.6.9 では、gtid_purged に置き換えられました。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowgtid-mode" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_gtid-mode">gtid-mode</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowgtid-mode replicationcli">はい</td>
      <td headers="rowgtid-mode replicationsysvar">はい</td>
      <td headers="rowgtid-mode replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowgtid-mode replicationoptfile">はい</td>
      <td headers="rowgtid-mode replicationscope">グローバル</td>
      <td headers="rowgtid-mode replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowgtid-mode replicationnotes">
        <p>
          説明: ON は GTID を有効にし、OFF は無効にします。UPGRADE_STEP_1 と UPGRADE_STEP_2 は現在サポートされていません。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowgtid_mode" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_gtid_mode">gtid_mode</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowgtid_mode replicationcli">いいえ</td>
      <td headers="rowgtid_mode replicationsysvar">はい</td>
      <td headers="rowgtid_mode replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowgtid_mode replicationoptfile">いいえ</td>
      <td headers="rowgtid_mode replicationscope">グローバル</td>
      <td headers="rowgtid_mode replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowgtid_mode replicationnotes">
        <p>
          説明: GTID が有効かどうかを示します。読み取り専用
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowgtid_next" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_gtid_next">gtid_next</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowgtid_next replicationcli">いいえ</td>
      <td headers="rowgtid_next replicationsysvar">はい</td>
      <td headers="rowgtid_next replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowgtid_next replicationoptfile">いいえ</td>
      <td headers="rowgtid_next replicationscope">セッション</td>
      <td headers="rowgtid_next replicationdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowgtid_next replicationnotes">
        <p>
          説明: 次に実行するステートメントの GTID を指定します。詳細は、ドキュメントを参照してください。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowgtid_owned" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_gtid_owned">gtid_owned</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowgtid_owned replicationcli">いいえ</td>
      <td headers="rowgtid_owned replicationsysvar">はい</td>
      <td headers="rowgtid_owned replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowgtid_owned replicationoptfile">いいえ</td>
      <td headers="rowgtid_owned replicationscope">両方</td>
      <td headers="rowgtid_owned replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowgtid_owned replicationnotes">
        <p>
          説明: 所有者 （グローバル） のスレッド ID に加えて、このクライアント (セッション) またはすべてのクライアントによって所有される GTID セットです。読み取り専用
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowgtid_purged" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_gtid_purged">gtid_purged</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowgtid_purged replicationcli">いいえ</td>
      <td headers="rowgtid_purged replicationsysvar">はい</td>
      <td headers="rowgtid_purged replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowgtid_purged replicationoptfile">いいえ</td>
      <td headers="rowgtid_purged replicationscope">グローバル</td>
      <td headers="rowgtid_purged replicationdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowgtid_purged replicationnotes">
        <p>
          説明: バイナリログからパージされたすべてのグループのセット。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowinit_slave" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_init_slave">init_slave</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowinit_slave replicationcli">はい</td>
      <td headers="rowinit_slave replicationsysvar">はい</td>
      <td headers="rowinit_slave replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowinit_slave replicationoptfile">はい</td>
      <td headers="rowinit_slave replicationscope">グローバル</td>
      <td headers="rowinit_slave replicationdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowinit_slave replicationnotes">
        <p>
          説明: スレーブがマスターに接続するときに実行されるステートメント
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowlog-slave-updates" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_log-slave-updates">log-slave-updates</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowlog-slave-updates replicationcli">はい</td>
      <td headers="rowlog-slave-updates replicationsysvar">はい</td>
      <td headers="rowlog-slave-updates replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowlog-slave-updates replicationoptfile">はい</td>
      <td headers="rowlog-slave-updates replicationscope">グローバル</td>
      <td headers="rowlog-slave-updates replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowlog-slave-updates replicationnotes">
        <p>
          説明: このオプションは、スレーブ SQL スレッドが実行した更新のログを自身のバイナリログに記録するようにスレーブに指示します。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowlog_slave_updates" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_log_slave_updates">log_slave_updates</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowlog_slave_updates replicationcli">はい</td>
      <td headers="rowlog_slave_updates replicationsysvar">はい</td>
      <td headers="rowlog_slave_updates replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowlog_slave_updates replicationoptfile">はい</td>
      <td headers="rowlog_slave_updates replicationscope">グローバル</td>
      <td headers="rowlog_slave_updates replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowlog_slave_updates replicationnotes">
        <p>
          説明: スレーブがその SQL スレッドによって実行された更新のログを自身のバイナリログに記録するかどうかを指示します。読み取り専用。--log-slave-updates サーバーオプションを使用して設定します。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowmaster-info-file" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_master-info-file">master-info-file</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowmaster-info-file replicationcli">はい</td>
      <td headers="rowmaster-info-file replicationsysvar">いいえ</td>
      <td headers="rowmaster-info-file replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowmaster-info-file replicationoptfile">はい</td>
      <td headers="rowmaster-info-file replicationscope"></td>
      <td headers="rowmaster-info-file replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowmaster-info-file replicationnotes">
        <p>
          説明: マスターを記憶するファイルの場所と名前、および I/O レプリケーションスレッドがマスターのバイナリログ内でどこにあるか
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowmaster-info-repository" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_master-info-repository">master-info-repository</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowmaster-info-repository replicationcli">はい</td>
      <td headers="rowmaster-info-repository replicationsysvar">いいえ</td>
      <td headers="rowmaster-info-repository replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowmaster-info-repository replicationoptfile">はい</td>
      <td headers="rowmaster-info-repository replicationscope"></td>
      <td headers="rowmaster-info-repository replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowmaster-info-repository replicationnotes">
        <p>
          説明: マスターのバイナリログ内のマスターステータス情報とレプリケーション I/O スレッド位置をファイルまたはテーブルに書き込むかどうか。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowmaster_info_repository" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_master_info_repository">master_info_repository</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowmaster_info_repository replicationcli">はい</td>
      <td headers="rowmaster_info_repository replicationsysvar">はい</td>
      <td headers="rowmaster_info_repository replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowmaster_info_repository replicationoptfile">はい</td>
      <td headers="rowmaster_info_repository replicationscope">グローバル</td>
      <td headers="rowmaster_info_repository replicationdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowmaster_info_repository replicationnotes">
        <p>
          説明: マスターのバイナリログ内のマスターステータス情報とレプリケーション I/O スレッド位置をファイルまたはテーブルに書き込むかどうか。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowmaster-retry-count" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_master-retry-count">master-retry-count</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowmaster-retry-count replicationcli">はい</td>
      <td headers="rowmaster-retry-count replicationsysvar">いいえ</td>
      <td headers="rowmaster-retry-count replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowmaster-retry-count replicationoptfile">はい</td>
      <td headers="rowmaster-retry-count replicationscope"></td>
      <td headers="rowmaster-retry-count replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowmaster-retry-count replicationnotes">
        <p>
          説明: スレーブがマスターへの接続を試行する回数 (このあとは停止)
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowrelay-log" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_relay-log">relay-log</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowrelay-log replicationcli">はい</td>
      <td headers="rowrelay-log replicationsysvar">はい</td>
      <td headers="rowrelay-log replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowrelay-log replicationoptfile">はい</td>
      <td headers="rowrelay-log replicationscope">グローバル</td>
      <td headers="rowrelay-log replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowrelay-log replicationnotes">
        <p>
          説明: リレーログに使用する場所とベース名
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowrelay_log_basename" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_relay_log_basename">relay_log_basename</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowrelay_log_basename replicationcli">いいえ</td>
      <td headers="rowrelay_log_basename replicationsysvar">はい</td>
      <td headers="rowrelay_log_basename replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowrelay_log_basename replicationoptfile">いいえ</td>
      <td headers="rowrelay_log_basename replicationscope">グローバル</td>
      <td headers="rowrelay_log_basename replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowrelay_log_basename replicationnotes">
        <p>
          説明: リレーログへの完全パス （ファイル名を含む）
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowrelay-log-index" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_relay-log-index">relay-log-index</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowrelay-log-index replicationcli">はい</td>
      <td headers="rowrelay-log-index replicationsysvar">はい</td>
      <td headers="rowrelay-log-index replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowrelay-log-index replicationoptfile">はい</td>
      <td headers="rowrelay-log-index replicationscope">グローバル</td>
      <td headers="rowrelay-log-index replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowrelay-log-index replicationnotes">
        <p>
          説明: 最後のリレーログのリストを保持するファイルに使用する場所と名前
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowrelay-log-info-file" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_relay-log-info-file">relay-log-info-file</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowrelay-log-info-file replicationcli">はい</td>
      <td headers="rowrelay-log-info-file replicationsysvar">いいえ</td>
      <td headers="rowrelay-log-info-file replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowrelay-log-info-file replicationoptfile">はい</td>
      <td headers="rowrelay-log-info-file replicationscope"></td>
      <td headers="rowrelay-log-info-file replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowrelay-log-info-file replicationnotes">
        <p>
          説明: SQL レプリケーションスレッドがリレーログ内のどこにあるかを記憶するファイルの場所と名前
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowrelay_log_info_file" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_relay_log_info_file">relay_log_info_file</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowrelay_log_info_file replicationcli">はい</td>
      <td headers="rowrelay_log_info_file replicationsysvar">はい</td>
      <td headers="rowrelay_log_info_file replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowrelay_log_info_file replicationoptfile">はい</td>
      <td headers="rowrelay_log_info_file replicationscope">グローバル</td>
      <td headers="rowrelay_log_info_file replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowrelay_log_info_file replicationnotes">
        <p>
          説明: スレーブがリレーログの情報を記録するファイルの名前。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowrelay-log-info-repository" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_relay-log-info-repository">relay-log-info-repository</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowrelay-log-info-repository replicationcli">はい</td>
      <td headers="rowrelay-log-info-repository replicationsysvar">いいえ</td>
      <td headers="rowrelay-log-info-repository replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowrelay-log-info-repository replicationoptfile">はい</td>
      <td headers="rowrelay-log-info-repository replicationscope"></td>
      <td headers="rowrelay-log-info-repository replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowrelay-log-info-repository replicationnotes">
        <p>
          説明: レプリケーション SQL スレッドのリレーログ内での場所をファイルまたはテーブルに書き込むかどうか。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowrelay_log_info_repository" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_relay_log_info_repository">relay_log_info_repository</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowrelay_log_info_repository replicationcli">いいえ</td>
      <td headers="rowrelay_log_info_repository replicationsysvar">はい</td>
      <td headers="rowrelay_log_info_repository replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowrelay_log_info_repository replicationoptfile">いいえ</td>
      <td headers="rowrelay_log_info_repository replicationscope">グローバル</td>
      <td headers="rowrelay_log_info_repository replicationdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowrelay_log_info_repository replicationnotes">
        <p>
          説明: レプリケーション SQL スレッドのリレーログ内での場所をファイルまたはテーブルに書き込むかどうか。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowrelay_log_index" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_relay_log_index">relay_log_index</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowrelay_log_index replicationcli">はい</td>
      <td headers="rowrelay_log_index replicationsysvar">はい</td>
      <td headers="rowrelay_log_index replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowrelay_log_index replicationoptfile">はい</td>
      <td headers="rowrelay_log_index replicationscope">グローバル</td>
      <td headers="rowrelay_log_index replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowrelay_log_index replicationnotes">
        <p>
          説明: リレーログインデックスファイルの名前。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowrelay_log_purge" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#sysvar_relay_log_purge">relay_log_purge</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowrelay_log_purge replicationcli">はい</td>
      <td headers="rowrelay_log_purge replicationsysvar">はい</td>
      <td headers="rowrelay_log_purge replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowrelay_log_purge replicationoptfile">はい</td>
      <td headers="rowrelay_log_purge replicationscope">グローバル</td>
      <td headers="rowrelay_log_purge replicationdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowrelay_log_purge replicationnotes">
        <p>
          説明: リレーログがパージされるかどうかを決定します
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowrelay-log-recovery" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_relay-log-recovery">relay-log-recovery</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowrelay-log-recovery replicationcli">はい</td>
      <td headers="rowrelay-log-recovery replicationsysvar">いいえ</td>
      <td headers="rowrelay-log-recovery replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowrelay-log-recovery replicationoptfile">はい</td>
      <td headers="rowrelay-log-recovery replicationscope"></td>
      <td headers="rowrelay-log-recovery replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowrelay-log-recovery replicationnotes">
        <p>
          説明: 起動時のマスターからのリレーログファイル自動リカバリを有効にします
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowrelay_log_recovery" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_relay_log_recovery">relay_log_recovery</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowrelay_log_recovery replicationcli">はい</td>
      <td headers="rowrelay_log_recovery replicationsysvar">はい</td>
      <td headers="rowrelay_log_recovery replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowrelay_log_recovery replicationoptfile">はい</td>
      <td headers="rowrelay_log_recovery replicationscope">グローバル</td>
      <td headers="rowrelay_log_recovery replicationdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowrelay_log_recovery replicationnotes">
        <p>
          説明: 起動時のマスターからのリレーログファイル自動リカバリが有効であるかどうか。クラッシュセーフスレーブにするには有効にする必要があります。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowrelay_log_space_limit" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#sysvar_relay_log_space_limit">relay_log_space_limit</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowrelay_log_space_limit replicationcli">はい</td>
      <td headers="rowrelay_log_space_limit replicationsysvar">はい</td>
      <td headers="rowrelay_log_space_limit replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowrelay_log_space_limit replicationoptfile">はい</td>
      <td headers="rowrelay_log_space_limit replicationscope">グローバル</td>
      <td headers="rowrelay_log_space_limit replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowrelay_log_space_limit replicationnotes">
        <p>
          説明: すべてのリレーログに使用する最大領域
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowreplicate-do-db" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_replicate-do-db">replicate-do-db</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowreplicate-do-db replicationcli">はい</td>
      <td headers="rowreplicate-do-db replicationsysvar">いいえ</td>
      <td headers="rowreplicate-do-db replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowreplicate-do-db replicationoptfile">はい</td>
      <td headers="rowreplicate-do-db replicationscope"></td>
      <td headers="rowreplicate-do-db replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowreplicate-do-db replicationnotes">
        <p>
          説明: 指定されたデータベースにレプリケーションを制限するようにスレーブ SQL スレッドに指示します
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowreplicate-do-table" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_replicate-do-table">replicate-do-table</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowreplicate-do-table replicationcli">はい</td>
      <td headers="rowreplicate-do-table replicationsysvar">いいえ</td>
      <td headers="rowreplicate-do-table replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowreplicate-do-table replicationoptfile">はい</td>
      <td headers="rowreplicate-do-table replicationscope"></td>
      <td headers="rowreplicate-do-table replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowreplicate-do-table replicationnotes">
        <p>
          説明: 指定されたテーブルにレプリケーションを制限するようにスレーブ SQL スレッドに指示します
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowreplicate-ignore-db" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_replicate-ignore-db">replicate-ignore-db</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowreplicate-ignore-db replicationcli">はい</td>
      <td headers="rowreplicate-ignore-db replicationsysvar">いいえ</td>
      <td headers="rowreplicate-ignore-db replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowreplicate-ignore-db replicationoptfile">はい</td>
      <td headers="rowreplicate-ignore-db replicationscope"></td>
      <td headers="rowreplicate-ignore-db replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowreplicate-ignore-db replicationnotes">
        <p>
          説明: 指定されたデータベースに複製しないようにスレーブ SQL スレッドに指示します
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowreplicate-ignore-table" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_replicate-ignore-table">replicate-ignore-table</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowreplicate-ignore-table replicationcli">はい</td>
      <td headers="rowreplicate-ignore-table replicationsysvar">いいえ</td>
      <td headers="rowreplicate-ignore-table replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowreplicate-ignore-table replicationoptfile">はい</td>
      <td headers="rowreplicate-ignore-table replicationscope"></td>
      <td headers="rowreplicate-ignore-table replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowreplicate-ignore-table replicationnotes">
        <p>
          説明: 指定されたテーブルに複製しないようにスレーブ SQL スレッドに指示します
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowreplicate-rewrite-db" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_replicate-rewrite-db">replicate-rewrite-db</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowreplicate-rewrite-db replicationcli">はい</td>
      <td headers="rowreplicate-rewrite-db replicationsysvar">いいえ</td>
      <td headers="rowreplicate-rewrite-db replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowreplicate-rewrite-db replicationoptfile">はい</td>
      <td headers="rowreplicate-rewrite-db replicationscope"></td>
      <td headers="rowreplicate-rewrite-db replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowreplicate-rewrite-db replicationnotes">
        <p>
          説明: 元の名前とは異なる名前のデータベースに更新します
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowreplicate-same-server-id" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_replicate-same-server-id">replicate-same-server-id</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowreplicate-same-server-id replicationcli">はい</td>
      <td headers="rowreplicate-same-server-id replicationsysvar">いいえ</td>
      <td headers="rowreplicate-same-server-id replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowreplicate-same-server-id replicationoptfile">はい</td>
      <td headers="rowreplicate-same-server-id replicationscope"></td>
      <td headers="rowreplicate-same-server-id replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowreplicate-same-server-id replicationnotes">
        <p>
          説明: レプリケーションで、1 に設定されている場合は、同じサーバー ID を持つイベントをスキップしません
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowreplicate-wild-do-table" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_replicate-wild-do-table">replicate-wild-do-table</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowreplicate-wild-do-table replicationcli">はい</td>
      <td headers="rowreplicate-wild-do-table replicationsysvar">いいえ</td>
      <td headers="rowreplicate-wild-do-table replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowreplicate-wild-do-table replicationoptfile">はい</td>
      <td headers="rowreplicate-wild-do-table replicationscope"></td>
      <td headers="rowreplicate-wild-do-table replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowreplicate-wild-do-table replicationnotes">
        <p>
          説明: 指定されたワイルドカードパターンに一致するテーブルにレプリケーションを制限するようにスレーブスレッドに指示します
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowreplicate-wild-ignore-table" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_replicate-wild-ignore-table">replicate-wild-ignore-table</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowreplicate-wild-ignore-table replicationcli">はい</td>
      <td headers="rowreplicate-wild-ignore-table replicationsysvar">いいえ</td>
      <td headers="rowreplicate-wild-ignore-table replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowreplicate-wild-ignore-table replicationoptfile">はい</td>
      <td headers="rowreplicate-wild-ignore-table replicationscope"></td>
      <td headers="rowreplicate-wild-ignore-table replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowreplicate-wild-ignore-table replicationnotes">
        <p>
          説明: 指定されたワイルドカードパターンに一致するテーブルに複製しないようにスレーブスレッドに指示します
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowreport-host" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_report-host">report-host</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowreport-host replicationcli">はい</td>
      <td headers="rowreport-host replicationsysvar">はい</td>
      <td headers="rowreport-host replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowreport-host replicationoptfile">はい</td>
      <td headers="rowreport-host replicationscope">グローバル</td>
      <td headers="rowreport-host replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowreport-host replicationnotes">
        <p>
          説明: スレーブ登録中にマスターに報告するスレーブのホスト名または IP
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowreport-password" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_report-password">report-password</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowreport-password replicationcli">はい</td>
      <td headers="rowreport-password replicationsysvar">はい</td>
      <td headers="rowreport-password replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowreport-password replicationoptfile">はい</td>
      <td headers="rowreport-password replicationscope">グローバル</td>
      <td headers="rowreport-password replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowreport-password replicationnotes">
        <p>
          説明: スレーブサーバーがマスターに報告すべき任意パスワード。MySQL レプリケーションユーザーアカウント用のパスワードと同じではないもの
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowreport-port" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_report-port">report-port</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowreport-port replicationcli">はい</td>
      <td headers="rowreport-port replicationsysvar">はい</td>
      <td headers="rowreport-port replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowreport-port replicationoptfile">はい</td>
      <td headers="rowreport-port replicationscope">グローバル</td>
      <td headers="rowreport-port replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowreport-port replicationnotes">
        <p>
          説明: スレーブ登録中にマスターに報告される、スレーブに接続するためのポート
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowreport-user" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_report-user">report-user</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowreport-user replicationcli">はい</td>
      <td headers="rowreport-user replicationsysvar">はい</td>
      <td headers="rowreport-user replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowreport-user replicationoptfile">はい</td>
      <td headers="rowreport-user replicationscope">グローバル</td>
      <td headers="rowreport-user replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowreport-user replicationnotes">
        <p>
          説明: スレーブサーバーがマスターに報告すべき任意ユーザー名。MySQL レプリケーションユーザーアカウントで使用される名前と同じではないもの。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowrpl_semi_sync_master_enabled" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#sysvar_rpl_semi_sync_master_enabled">rpl_semi_sync_master_enabled</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowrpl_semi_sync_master_enabled replicationcli">いいえ</td>
      <td headers="rowrpl_semi_sync_master_enabled replicationsysvar">はい</td>
      <td headers="rowrpl_semi_sync_master_enabled replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowrpl_semi_sync_master_enabled replicationoptfile">いいえ</td>
      <td headers="rowrpl_semi_sync_master_enabled replicationscope">グローバル</td>
      <td headers="rowrpl_semi_sync_master_enabled replicationdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowrpl_semi_sync_master_enabled replicationnotes">
        <p>
          説明: 準同期レプリケーションがマスターで有効であるかどうか
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowrpl_semi_sync_master_timeout" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#sysvar_rpl_semi_sync_master_timeout">rpl_semi_sync_master_timeout</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowrpl_semi_sync_master_timeout replicationcli">いいえ</td>
      <td headers="rowrpl_semi_sync_master_timeout replicationsysvar">はい</td>
      <td headers="rowrpl_semi_sync_master_timeout replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowrpl_semi_sync_master_timeout replicationoptfile">いいえ</td>
      <td headers="rowrpl_semi_sync_master_timeout replicationscope">グローバル</td>
      <td headers="rowrpl_semi_sync_master_timeout replicationdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowrpl_semi_sync_master_timeout replicationnotes">
        <p>
          説明: スレーブ肯定応答を待機するミリ秒
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowrpl_semi_sync_master_trace_level" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#sysvar_rpl_semi_sync_master_trace_level">rpl_semi_sync_master_trace_level</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowrpl_semi_sync_master_trace_level replicationcli">いいえ</td>
      <td headers="rowrpl_semi_sync_master_trace_level replicationsysvar">はい</td>
      <td headers="rowrpl_semi_sync_master_trace_level replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowrpl_semi_sync_master_trace_level replicationoptfile">いいえ</td>
      <td headers="rowrpl_semi_sync_master_trace_level replicationscope">グローバル</td>
      <td headers="rowrpl_semi_sync_master_trace_level replicationdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowrpl_semi_sync_master_trace_level replicationnotes">
        <p>
          説明: マスターでの準同期レプリケーションデバッグトレースレベル
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowrpl_semi_sync_master_wait_no_slave" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#sysvar_rpl_semi_sync_master_wait_no_slave">rpl_semi_sync_master_wait_no_slave</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowrpl_semi_sync_master_wait_no_slave replicationcli">いいえ</td>
      <td headers="rowrpl_semi_sync_master_wait_no_slave replicationsysvar">はい</td>
      <td headers="rowrpl_semi_sync_master_wait_no_slave replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowrpl_semi_sync_master_wait_no_slave replicationoptfile">いいえ</td>
      <td headers="rowrpl_semi_sync_master_wait_no_slave replicationscope">グローバル</td>
      <td headers="rowrpl_semi_sync_master_wait_no_slave replicationdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowrpl_semi_sync_master_wait_no_slave replicationnotes">
        <p>
          説明: マスターがタイムアウトを待機するかどうか (スレーブなしでも可)
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowrpl_semi_sync_slave_enabled" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#sysvar_rpl_semi_sync_slave_enabled">rpl_semi_sync_slave_enabled</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowrpl_semi_sync_slave_enabled replicationcli">いいえ</td>
      <td headers="rowrpl_semi_sync_slave_enabled replicationsysvar">はい</td>
      <td headers="rowrpl_semi_sync_slave_enabled replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowrpl_semi_sync_slave_enabled replicationoptfile">いいえ</td>
      <td headers="rowrpl_semi_sync_slave_enabled replicationscope">グローバル</td>
      <td headers="rowrpl_semi_sync_slave_enabled replicationdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowrpl_semi_sync_slave_enabled replicationnotes">
        <p>
          説明: 準同期レプリケーションがスレーブで有効かどうか
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowrpl_semi_sync_slave_trace_level" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#sysvar_rpl_semi_sync_slave_trace_level">rpl_semi_sync_slave_trace_level</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowrpl_semi_sync_slave_trace_level replicationcli">いいえ</td>
      <td headers="rowrpl_semi_sync_slave_trace_level replicationsysvar">はい</td>
      <td headers="rowrpl_semi_sync_slave_trace_level replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowrpl_semi_sync_slave_trace_level replicationoptfile">いいえ</td>
      <td headers="rowrpl_semi_sync_slave_trace_level replicationscope">グローバル</td>
      <td headers="rowrpl_semi_sync_slave_trace_level replicationdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowrpl_semi_sync_slave_trace_level replicationnotes">
        <p>
          説明: スレーブでの準同期レプリケーションデバッグトレースレベル
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowrpl_stop_slave_timeout" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_rpl_stop_slave_timeout">rpl_stop_slave_timeout</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowrpl_stop_slave_timeout replicationcli">はい</td>
      <td headers="rowrpl_stop_slave_timeout replicationsysvar">はい</td>
      <td headers="rowrpl_stop_slave_timeout replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowrpl_stop_slave_timeout replicationoptfile">はい</td>
      <td headers="rowrpl_stop_slave_timeout replicationscope">グローバル</td>
      <td headers="rowrpl_stop_slave_timeout replicationdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowrpl_stop_slave_timeout replicationnotes">
        <p>
          説明: STOP SLAVE が待機する秒数を設定します (このあとはタイムアウト)。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowserver_uuid" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_server_uuid">server_uuid</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowserver_uuid replicationcli">いいえ</td>
      <td headers="rowserver_uuid replicationsysvar">はい</td>
      <td headers="rowserver_uuid replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowserver_uuid replicationoptfile">いいえ</td>
      <td headers="rowserver_uuid replicationscope">グローバル</td>
      <td headers="rowserver_uuid replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowserver_uuid replicationnotes">
        <p>
          説明: サーバーのグローバル一意ID、サーバー起動時に自動的に生成 （再生成）
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowshow-slave-auth-info" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_show-slave-auth-info">show-slave-auth-info</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowshow-slave-auth-info replicationcli">はい</td>
      <td headers="rowshow-slave-auth-info replicationsysvar">いいえ</td>
      <td headers="rowshow-slave-auth-info replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowshow-slave-auth-info replicationoptfile">はい</td>
      <td headers="rowshow-slave-auth-info replicationscope"></td>
      <td headers="rowshow-slave-auth-info replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowshow-slave-auth-info replicationnotes">
        <p>
          説明: このマスターでの SHOW SLAVE HOSTS でユーザー名とパスワードを表示します
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowsimplified_binlog_gtid_recovery" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_simplified_binlog_gtid_recovery">simplified_binlog_gtid_recovery</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowsimplified_binlog_gtid_recovery replicationcli">はい</td>
      <td headers="rowsimplified_binlog_gtid_recovery replicationsysvar">はい</td>
      <td headers="rowsimplified_binlog_gtid_recovery replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowsimplified_binlog_gtid_recovery replicationoptfile">はい</td>
      <td headers="rowsimplified_binlog_gtid_recovery replicationscope">グローバル</td>
      <td headers="rowsimplified_binlog_gtid_recovery replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowsimplified_binlog_gtid_recovery replicationnotes">
        <p>
          説明: GTID リカバリ中にバイナリログがどのように反復されるかを制御します
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowskip-slave-start" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_skip-slave-start">skip-slave-start</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowskip-slave-start replicationcli">はい</td>
      <td headers="rowskip-slave-start replicationsysvar">いいえ</td>
      <td headers="rowskip-slave-start replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowskip-slave-start replicationoptfile">はい</td>
      <td headers="rowskip-slave-start replicationscope"></td>
      <td headers="rowskip-slave-start replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowskip-slave-start replicationnotes">
        <p>
          説明: 設定されている場合は、スレーブは自動起動されません
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowslave-load-tmpdir" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_slave-load-tmpdir">slave-load-tmpdir</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowslave-load-tmpdir replicationcli">はい</td>
      <td headers="rowslave-load-tmpdir replicationsysvar">はい</td>
      <td headers="rowslave-load-tmpdir replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowslave-load-tmpdir replicationoptfile">はい</td>
      <td headers="rowslave-load-tmpdir replicationscope">グローバル</td>
      <td headers="rowslave-load-tmpdir replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowslave-load-tmpdir replicationnotes">
        <p>
          説明: スレーブが LOAD DATA INFILE ステートメントを複製するときにその一次ファイルを置くべき場所
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowslave-skip-errors" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_slave-skip-errors">slave-skip-errors</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowslave-skip-errors replicationcli">はい</td>
      <td headers="rowslave-skip-errors replicationsysvar">はい</td>
      <td headers="rowslave-skip-errors replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowslave-skip-errors replicationoptfile">はい</td>
      <td headers="rowslave-skip-errors replicationscope">グローバル</td>
      <td headers="rowslave-skip-errors replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowslave-skip-errors replicationnotes">
        <p>
          説明: 提供されたリストからクエリーがエラーを返すときでもレプリケーションを継続するようにスレーブスレッドに指示します
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowslave-checkpoint-group" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_slave-checkpoint-group">slave-checkpoint-group</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowslave-checkpoint-group replicationcli">はい</td>
      <td headers="rowslave-checkpoint-group replicationsysvar">いいえ</td>
      <td headers="rowslave-checkpoint-group replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowslave-checkpoint-group replicationoptfile">はい</td>
      <td headers="rowslave-checkpoint-group replicationscope"></td>
      <td headers="rowslave-checkpoint-group replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowslave-checkpoint-group replicationnotes">
        <p>
          説明: 進捗状況ステータスを更新するためにチェックポイント操作が呼び出される前に、マルチスレッドスレーブによって処理される最大トランザクション数。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowslave_checkpoint_group" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_slave_checkpoint_group">slave_checkpoint_group</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowslave_checkpoint_group replicationcli">はい</td>
      <td headers="rowslave_checkpoint_group replicationsysvar">はい</td>
      <td headers="rowslave_checkpoint_group replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowslave_checkpoint_group replicationoptfile">はい</td>
      <td headers="rowslave_checkpoint_group replicationscope">グローバル</td>
      <td headers="rowslave_checkpoint_group replicationdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowslave_checkpoint_group replicationnotes">
        <p>
          説明: 進捗状況ステータスを更新するためにチェックポイント操作が呼び出される前に、マルチスレッドスレーブによって処理される最大トランザクション数。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowslave-checkpoint-period" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_slave-checkpoint-period">slave-checkpoint-period</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowslave-checkpoint-period replicationcli">はい</td>
      <td headers="rowslave-checkpoint-period replicationsysvar">いいえ</td>
      <td headers="rowslave-checkpoint-period replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowslave-checkpoint-period replicationoptfile">はい</td>
      <td headers="rowslave-checkpoint-period replicationscope"></td>
      <td headers="rowslave-checkpoint-period replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowslave-checkpoint-period replicationnotes">
        <p>
          説明: このミリ秒後に、マルチスレッドスレーブの進捗状況ステータスを更新し、リレーログ情報をディスクにフラッシュします。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowslave_checkpoint_period" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_slave_checkpoint_period">slave_checkpoint_period</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowslave_checkpoint_period replicationcli">はい</td>
      <td headers="rowslave_checkpoint_period replicationsysvar">はい</td>
      <td headers="rowslave_checkpoint_period replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowslave_checkpoint_period replicationoptfile">はい</td>
      <td headers="rowslave_checkpoint_period replicationscope">グローバル</td>
      <td headers="rowslave_checkpoint_period replicationdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowslave_checkpoint_period replicationnotes">
        <p>
          説明: このミリ秒後に、マルチスレッドスレーブの進捗状況ステータスを更新し、リレーログ情報をディスクにフラッシュします。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowslave_compressed_protocol" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_slave_compressed_protocol">slave_compressed_protocol</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowslave_compressed_protocol replicationcli">はい</td>
      <td headers="rowslave_compressed_protocol replicationsysvar">はい</td>
      <td headers="rowslave_compressed_protocol replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowslave_compressed_protocol replicationoptfile">はい</td>
      <td headers="rowslave_compressed_protocol replicationscope">グローバル</td>
      <td headers="rowslave_compressed_protocol replicationdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowslave_compressed_protocol replicationnotes">
        <p>
          説明: マスター/スレーブプロトコルで圧縮を使用します
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowslave-max-allowed-packet" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_slave-max-allowed-packet">slave-max-allowed-packet</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowslave-max-allowed-packet replicationcli">はい</td>
      <td headers="rowslave-max-allowed-packet replicationsysvar">いいえ</td>
      <td headers="rowslave-max-allowed-packet replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowslave-max-allowed-packet replicationoptfile">はい</td>
      <td headers="rowslave-max-allowed-packet replicationscope"></td>
      <td headers="rowslave-max-allowed-packet replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowslave-max-allowed-packet replicationnotes">
        <p>
          説明: レプリケーションマスターからスレーブに送信できるパケットの最大サイズ （バイト単位）。max_allowed_packet をオーバーライドします。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowslave_max_allowed_packet" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_slave_max_allowed_packet">slave_max_allowed_packet</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowslave_max_allowed_packet replicationcli">いいえ</td>
      <td headers="rowslave_max_allowed_packet replicationsysvar">はい</td>
      <td headers="rowslave_max_allowed_packet replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowslave_max_allowed_packet replicationoptfile">いいえ</td>
      <td headers="rowslave_max_allowed_packet replicationscope">グローバル</td>
      <td headers="rowslave_max_allowed_packet replicationdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowslave_max_allowed_packet replicationnotes">
        <p>
          説明: レプリケーションマスターからスレーブに送信できるパケットの最大サイズ （バイト単位）。max_allowed_packet をオーバーライドします。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowslave_net_timeout" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_slave-net-timeout">slave_net_timeout</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowslave_net_timeout replicationcli">はい</td>
      <td headers="rowslave_net_timeout replicationsysvar">はい</td>
      <td headers="rowslave_net_timeout replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowslave_net_timeout replicationoptfile">はい</td>
      <td headers="rowslave_net_timeout replicationscope">グローバル</td>
      <td headers="rowslave_net_timeout replicationdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowslave_net_timeout replicationnotes">
        <p>
          説明: マスター/スレーブ接続から後続のデータを待機する秒数 (このあとは読み取りを中止)
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowslave_parallel_workers" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_slave_parallel_workers">slave_parallel_workers</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowslave_parallel_workers replicationcli">いいえ</td>
      <td headers="rowslave_parallel_workers replicationsysvar">はい</td>
      <td headers="rowslave_parallel_workers replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowslave_parallel_workers replicationoptfile">いいえ</td>
      <td headers="rowslave_parallel_workers replicationscope">グローバル</td>
      <td headers="rowslave_parallel_workers replicationdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowslave_parallel_workers replicationnotes">
        <p>
          説明: イベントを並列実行するためのワーカースレッドの数。0 (デフォルト) に設定すると、スレーブマルチスレッドが無効になります。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowslave-parallel-workers" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_slave-parallel-workers">slave-parallel-workers</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowslave-parallel-workers replicationcli">はい</td>
      <td headers="rowslave-parallel-workers replicationsysvar">いいえ</td>
      <td headers="rowslave-parallel-workers replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowslave-parallel-workers replicationoptfile">はい</td>
      <td headers="rowslave-parallel-workers replicationscope"></td>
      <td headers="rowslave-parallel-workers replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowslave-parallel-workers replicationnotes">
        <p>
          説明: イベントを並列実行するためのワーカースレッドの数。0 (デフォルト) に設定すると、スレーブマルチスレッドが無効になります。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowslave-pending-jobs-size-max" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_slave-pending-jobs-size-max">slave-pending-jobs-size-max</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowslave-pending-jobs-size-max replicationcli">はい</td>
      <td headers="rowslave-pending-jobs-size-max replicationsysvar">いいえ</td>
      <td headers="rowslave-pending-jobs-size-max replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowslave-pending-jobs-size-max replicationoptfile">いいえ</td>
      <td headers="rowslave-pending-jobs-size-max replicationscope"></td>
      <td headers="rowslave-pending-jobs-size-max replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowslave-pending-jobs-size-max replicationnotes">
        <p>
          説明: まだ適用されていないイベントを保持するスレーブワーカーキューの最大サイズ。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowslave_pending_jobs_size_max" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_slave_pending_jobs_size_max">slave_pending_jobs_size_max</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowslave_pending_jobs_size_max replicationcli">いいえ</td>
      <td headers="rowslave_pending_jobs_size_max replicationsysvar">はい</td>
      <td headers="rowslave_pending_jobs_size_max replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowslave_pending_jobs_size_max replicationoptfile">いいえ</td>
      <td headers="rowslave_pending_jobs_size_max replicationscope">グローバル</td>
      <td headers="rowslave_pending_jobs_size_max replicationdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowslave_pending_jobs_size_max replicationnotes">
        <p>
          説明: まだ適用されていないイベントを保持するスレーブワーカーキューの最大サイズ。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowslave-rows-search-algorithms" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_slave-rows-search-algorithms">slave-rows-search-algorithms</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowslave-rows-search-algorithms replicationcli">はい</td>
      <td headers="rowslave-rows-search-algorithms replicationsysvar">いいえ</td>
      <td headers="rowslave-rows-search-algorithms replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowslave-rows-search-algorithms replicationoptfile">はい</td>
      <td headers="rowslave-rows-search-algorithms replicationscope"></td>
      <td headers="rowslave-rows-search-algorithms replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowslave-rows-search-algorithms replicationnotes">
        <p>
          説明: スレーブ更新バッチに使用される検索アルゴリズムを決定します。リスト INDEX_SEARCH、TABLE_SCAN、HASH_SCAN からの任意の 2 つまたは 3 つ。デフォルトは TABLE_SCAN、INDEX_SCAN。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowslave_rows_search_algorithms" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_slave_rows_search_algorithms">slave_rows_search_algorithms</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowslave_rows_search_algorithms replicationcli">いいえ</td>
      <td headers="rowslave_rows_search_algorithms replicationsysvar">はい</td>
      <td headers="rowslave_rows_search_algorithms replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowslave_rows_search_algorithms replicationoptfile">いいえ</td>
      <td headers="rowslave_rows_search_algorithms replicationscope">グローバル</td>
      <td headers="rowslave_rows_search_algorithms replicationdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowslave_rows_search_algorithms replicationnotes">
        <p>
          説明: スレーブ更新バッチに使用される検索アルゴリズムを決定します。リスト INDEX_SEARCH、TABLE_SCAN、HASH_SCAN からの任意の 2 つまたは 3 つ。デフォルトは TABLE_SCAN、INDEX_SCAN。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowslave_transaction_retries" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_slave_transaction_retries">slave_transaction_retries</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowslave_transaction_retries replicationcli">はい</td>
      <td headers="rowslave_transaction_retries replicationsysvar">はい</td>
      <td headers="rowslave_transaction_retries replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowslave_transaction_retries replicationoptfile">はい</td>
      <td headers="rowslave_transaction_retries replicationscope">グローバル</td>
      <td headers="rowslave_transaction_retries replicationdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowslave_transaction_retries replicationnotes">
        <p>
          説明: スレーブ SQL スレッドがデッドロックまたはロック待機タイムアウト経過によって失敗した場合にトランザクションを再試行する回数 (このあとは中止して停止)
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowslave_type_conversions" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_slave_type_conversions">slave_type_conversions</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowslave_type_conversions replicationcli">はい</td>
      <td headers="rowslave_type_conversions replicationsysvar">はい</td>
      <td headers="rowslave_type_conversions replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowslave_type_conversions replicationoptfile">はい</td>
      <td headers="rowslave_type_conversions replicationscope">グローバル</td>
      <td headers="rowslave_type_conversions replicationdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowslave_type_conversions replicationnotes">
        <p>
          説明: レプリケーションスレーブでの型変換モードを制御します。値は、リスト ALL_LOSSY、ALL_NON_LOSSY からのゼロ個以上の要素のリストです。空の文字列に設定すると、マスターとスレーブ間の型変換を禁止します。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowsql_slave_skip_counter" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_sql_slave_skip_counter">sql_slave_skip_counter</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowsql_slave_skip_counter replicationcli">いいえ</td>
      <td headers="rowsql_slave_skip_counter replicationsysvar">はい</td>
      <td headers="rowsql_slave_skip_counter replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowsql_slave_skip_counter replicationoptfile">いいえ</td>
      <td headers="rowsql_slave_skip_counter replicationscope">グローバル</td>
      <td headers="rowsql_slave_skip_counter replicationdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowsql_slave_skip_counter replicationnotes">
        <p>
          説明: スレーブサーバーがスキップすべき、マスターからのイベントの数。GTID レプリケーションと互換性はありません。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowsync_binlog" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_sync_binlog">sync_binlog</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowsync_binlog replicationcli">はい</td>
      <td headers="rowsync_binlog replicationsysvar">はい</td>
      <td headers="rowsync_binlog replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowsync_binlog replicationoptfile">はい</td>
      <td headers="rowsync_binlog replicationscope">グローバル</td>
      <td headers="rowsync_binlog replicationdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowsync_binlog replicationnotes">
        <p>
          説明: # 番目のイベントごとに同期的にバイナリログをディスクにフラッシュします
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowsync_master_info" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_sync_master_info">sync_master_info</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowsync_master_info replicationcli">はい</td>
      <td headers="rowsync_master_info replicationsysvar">はい</td>
      <td headers="rowsync_master_info replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowsync_master_info replicationoptfile">はい</td>
      <td headers="rowsync_master_info replicationscope">グローバル</td>
      <td headers="rowsync_master_info replicationdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowsync_master_info replicationnotes">
        <p>
          説明: # 番目のイベントごとに master.info をディスクに同期します。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowsync_relay_log" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_sync_relay_log">sync_relay_log</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowsync_relay_log replicationcli">はい</td>
      <td headers="rowsync_relay_log replicationsysvar">はい</td>
      <td headers="rowsync_relay_log replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowsync_relay_log replicationoptfile">はい</td>
      <td headers="rowsync_relay_log replicationscope">グローバル</td>
      <td headers="rowsync_relay_log replicationdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowsync_relay_log replicationnotes">
        <p>
          説明: # 番目のイベントごとにリレーログをディスクに同期します。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowsync_relay_log_info" headers="replicationoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_sync_relay_log_info">sync_relay_log_info</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowsync_relay_log_info replicationcli">はい</td>
      <td headers="rowsync_relay_log_info replicationsysvar">はい</td>
      <td headers="rowsync_relay_log_info replicationstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowsync_relay_log_info replicationoptfile">はい</td>
      <td headers="rowsync_relay_log_info replicationscope">グローバル</td>
      <td headers="rowsync_relay_log_info replicationdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowsync_relay_log_info replicationnotes">
        <p>
          説明: # 番目のイベントごとに relay.info ファイルをディスクに同期します。
        </p>
      </td>
    </tr></tbody></table></div></div><br class="table-break"><p>
      <a class="xref" href="replication.html#replication-options-master" title="17.1.4.2 レプリケーションマスターのオプションと変数">セクション17.1.4.2「レプリケーションマスターのオプションと変数」</a>は、レプリケーションマスターサーバーに関係するオプションと変数に関する詳細情報を提供します。レプリケーションスレーブに関係するオプションと変数に関する詳細情報については、<a class="xref" href="replication.html#replication-options-slave" title="17.1.4.3 レプリケーションスレーブのオプションと変数">セクション17.1.4.3「レプリケーションスレーブのオプションと変数」</a>を参照してください。
    </p><div class="table"><a name="binlog-optvar-summary-table"></a><p class="title"><b>表 17.2 MySQL 5.6 でのバイナリロギングのオプションおよび変数のサマリー</b></p><div class="table-contents"><table id="binlog-optvar-summary-table" summary="Binary Logging Options and Variables: MySQL 5.6"><col width="33%"><col width="33%"><col width="33%"><thead><tr>
      <th id="binlogoptvar" colspan="3" abbr="Name" align="center">オプションまたは変数名</th>
    </tr><tr>
      <th id="binlogcli" abbr="CLI">コマンド行</th>
      <th id="binlogsysvar" abbr="System">システム変数</th>
      <th id="binlogstatvar" abbr="Status">ステータス変数</th>
    </tr><tr>
      <th id="binlogoptfile" abbr="File">オプションファイル</th>
      <th id="binlogscope">スコープ</th>
      <th id="binlogdynamic">動的</th>
    </tr><tr>
      <th id="binlognotes" colspan="3">メモ</th>
    </tr></thead><tbody><tr>
      <td colspan="3" align="center" id="rowBinlog_cache_disk_use" headers="binlogoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#statvar_Binlog_cache_disk_use">Binlog_cache_disk_use</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowBinlog_cache_disk_use binlogcli">いいえ</td>
      <td headers="rowBinlog_cache_disk_use binlogsysvar">いいえ</td>
      <td headers="rowBinlog_cache_disk_use binlogstatvar">はい</td>
    </tr><tr>
      <td headers="rowBinlog_cache_disk_use binlogoptfile">いいえ</td>
      <td headers="rowBinlog_cache_disk_use binlogscope">グローバル</td>
      <td headers="rowBinlog_cache_disk_use binlogdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowBinlog_cache_disk_use binlognotes">
        <p>
          説明: バイナリログキャッシュの代わりに一時ファイルを使用したトランザクションの数
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowbinlog_row_image" headers="binlogoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_binlog_row_image">binlog_row_image</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowbinlog_row_image binlogcli">はい</td>
      <td headers="rowbinlog_row_image binlogsysvar">はい</td>
      <td headers="rowbinlog_row_image binlogstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowbinlog_row_image binlogoptfile">はい</td>
      <td headers="rowbinlog_row_image binlogscope">両方</td>
      <td headers="rowbinlog_row_image binlogdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowbinlog_row_image binlognotes">
        <p>
          説明: 行変更のログを記録するときに full または minimal イメージを使用します。許容される値は full、minimal、および noblob です。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowbinlog_rows_query_log_events" headers="binlogoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_binlog_rows_query_log_events">binlog_rows_query_log_events</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowbinlog_rows_query_log_events binlogcli">いいえ</td>
      <td headers="rowbinlog_rows_query_log_events binlogsysvar">はい</td>
      <td headers="rowbinlog_rows_query_log_events binlogstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowbinlog_rows_query_log_events binlogoptfile">いいえ</td>
      <td headers="rowbinlog_rows_query_log_events binlogscope">両方</td>
      <td headers="rowbinlog_rows_query_log_events binlogdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowbinlog_rows_query_log_events binlognotes">
        <p>
          説明: TRUE のとき、行ベースロギングモードで行クエリーログイベントのロギングを有効にします。デフォルトは FALSE です。5.6.2 より前のレプリケーションスレーブまたはほかのリーダーのログを生成するときは有効にしないでください。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowBinlog_stmt_cache_disk_use" headers="binlogoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#statvar_Binlog_stmt_cache_disk_use">Binlog_stmt_cache_disk_use</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowBinlog_stmt_cache_disk_use binlogcli">いいえ</td>
      <td headers="rowBinlog_stmt_cache_disk_use binlogsysvar">いいえ</td>
      <td headers="rowBinlog_stmt_cache_disk_use binlogstatvar">はい</td>
    </tr><tr>
      <td headers="rowBinlog_stmt_cache_disk_use binlogoptfile">いいえ</td>
      <td headers="rowBinlog_stmt_cache_disk_use binlogscope">グローバル</td>
      <td headers="rowBinlog_stmt_cache_disk_use binlogdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowBinlog_stmt_cache_disk_use binlognotes">
        <p>
          説明: バイナリログステートメントキャッシュの代わりに一時ファイルを使用した非トランザクションステートメントの数
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowBinlog_cache_use" headers="binlogoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#statvar_Binlog_cache_use">Binlog_cache_use</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowBinlog_cache_use binlogcli">いいえ</td>
      <td headers="rowBinlog_cache_use binlogsysvar">いいえ</td>
      <td headers="rowBinlog_cache_use binlogstatvar">はい</td>
    </tr><tr>
      <td headers="rowBinlog_cache_use binlogoptfile">いいえ</td>
      <td headers="rowBinlog_cache_use binlogscope">グローバル</td>
      <td headers="rowBinlog_cache_use binlogdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowBinlog_cache_use binlognotes">
        <p>
          説明: 一時バイナリログキャッシュを使用したトランザクションの数
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowBinlog_stmt_cache_use" headers="binlogoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#statvar_Binlog_stmt_cache_use">Binlog_stmt_cache_use</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowBinlog_stmt_cache_use binlogcli">いいえ</td>
      <td headers="rowBinlog_stmt_cache_use binlogsysvar">いいえ</td>
      <td headers="rowBinlog_stmt_cache_use binlogstatvar">はい</td>
    </tr><tr>
      <td headers="rowBinlog_stmt_cache_use binlogoptfile">いいえ</td>
      <td headers="rowBinlog_stmt_cache_use binlogscope">グローバル</td>
      <td headers="rowBinlog_stmt_cache_use binlogdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowBinlog_stmt_cache_use binlognotes">
        <p>
          説明: 一時バイナリログステートメントキャッシュを使用したステートメントの数
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowCom_show_binlog_events" headers="binlogoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#statvar_Com_xxx">Com_show_binlog_events</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowCom_show_binlog_events binlogcli">いいえ</td>
      <td headers="rowCom_show_binlog_events binlogsysvar">いいえ</td>
      <td headers="rowCom_show_binlog_events binlogstatvar">はい</td>
    </tr><tr>
      <td headers="rowCom_show_binlog_events binlogoptfile">いいえ</td>
      <td headers="rowCom_show_binlog_events binlogscope">両方</td>
      <td headers="rowCom_show_binlog_events binlogdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowCom_show_binlog_events binlognotes">
        <p>
          説明: SHOW BINLOG EVENTS ステートメントの数
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowCom_show_binlogs" headers="binlogoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#statvar_Com_xxx">Com_show_binlogs</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowCom_show_binlogs binlogcli">いいえ</td>
      <td headers="rowCom_show_binlogs binlogsysvar">いいえ</td>
      <td headers="rowCom_show_binlogs binlogstatvar">はい</td>
    </tr><tr>
      <td headers="rowCom_show_binlogs binlogoptfile">いいえ</td>
      <td headers="rowCom_show_binlogs binlogscope">両方</td>
      <td headers="rowCom_show_binlogs binlogdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowCom_show_binlogs binlognotes">
        <p>
          SHOW BINLOGS ステートメントの数
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowbinlog-checksum" headers="binlogoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_binlog-checksum">binlog-checksum</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowbinlog-checksum binlogcli">はい</td>
      <td headers="rowbinlog-checksum binlogsysvar">いいえ</td>
      <td headers="rowbinlog-checksum binlogstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowbinlog-checksum binlogoptfile">はい</td>
      <td headers="rowbinlog-checksum binlogscope"></td>
      <td headers="rowbinlog-checksum binlogdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowbinlog-checksum binlognotes">
        <p>
          説明: バイナリログチェックサムを有効化/無効化します
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowbinlog_checksum" headers="binlogoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_binlog_checksum">binlog_checksum</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowbinlog_checksum binlogcli">いいえ</td>
      <td headers="rowbinlog_checksum binlogsysvar">はい</td>
      <td headers="rowbinlog_checksum binlogstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowbinlog_checksum binlogoptfile">いいえ</td>
      <td headers="rowbinlog_checksum binlogscope">グローバル</td>
      <td headers="rowbinlog_checksum binlogdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowbinlog_checksum binlognotes">
        <p>
          説明: バイナリログチェックサムを有効化/無効化します
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowbinlog-do-db" headers="binlogoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_binlog-do-db">binlog-do-db</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowbinlog-do-db binlogcli">はい</td>
      <td headers="rowbinlog-do-db binlogsysvar">いいえ</td>
      <td headers="rowbinlog-do-db binlogstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowbinlog-do-db binlogoptfile">はい</td>
      <td headers="rowbinlog-do-db binlogscope"></td>
      <td headers="rowbinlog-do-db binlogdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowbinlog-do-db binlognotes">
        <p>
          説明: バイナリロギングを特定のデータベースに制限します
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowbinlog_error_action" headers="binlogoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_binlog_error_action">binlog_error_action</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowbinlog_error_action binlogcli">はい</td>
      <td headers="rowbinlog_error_action binlogsysvar">はい</td>
      <td headers="rowbinlog_error_action binlogstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowbinlog_error_action binlogoptfile">はい</td>
      <td headers="rowbinlog_error_action binlogscope">両方</td>
      <td headers="rowbinlog_error_action binlogdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowbinlog_error_action binlognotes">
        <p>
          説明: サーバーがバイナリログに書き込めないときに何が起きるかを制御します。2 つのいずれかの値を想定できます: IGNORE_ERROR (デフォルト) は、サーバーはエラーログを記録しますが、更新処理を継続することを意味します。ABORT_SERVER の場合は、バイナリログを書き込みめないときにサーバーがシャットダウンします。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowbinlog-ignore-db" headers="binlogoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_binlog-ignore-db">binlog-ignore-db</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowbinlog-ignore-db binlogcli">はい</td>
      <td headers="rowbinlog-ignore-db binlogsysvar">いいえ</td>
      <td headers="rowbinlog-ignore-db binlogstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowbinlog-ignore-db binlogoptfile">はい</td>
      <td headers="rowbinlog-ignore-db binlogscope"></td>
      <td headers="rowbinlog-ignore-db binlogdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowbinlog-ignore-db binlognotes">
        <p>
          説明: 指定されたデータベースへの更新をバイナリログにログを記録すべきでないことをマスターに指示します
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowbinlogging_impossible_mode" headers="binlogoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_binlogging_impossible_mode">binlogging_impossible_mode</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowbinlogging_impossible_mode binlogcli">はい</td>
      <td headers="rowbinlogging_impossible_mode binlogsysvar">はい</td>
      <td headers="rowbinlogging_impossible_mode binlogstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowbinlogging_impossible_mode binlogoptfile">はい</td>
      <td headers="rowbinlogging_impossible_mode binlogscope">両方</td>
      <td headers="rowbinlogging_impossible_mode binlogdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowbinlogging_impossible_mode binlognotes">
        <p>
          説明: 非推奨であり、将来のバージョンで削除されます。代わりに、名前が変更された binlog_error_action を使用します。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowbinlog-row-event-max-size" headers="binlogoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_binlog-row-event-max-size">binlog-row-event-max-size</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowbinlog-row-event-max-size binlogcli">はい</td>
      <td headers="rowbinlog-row-event-max-size binlogsysvar">いいえ</td>
      <td headers="rowbinlog-row-event-max-size binlogstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowbinlog-row-event-max-size binlogoptfile">はい</td>
      <td headers="rowbinlog-row-event-max-size binlogscope"></td>
      <td headers="rowbinlog-row-event-max-size binlogdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowbinlog-row-event-max-size binlognotes">
        <p>
          説明: バイナリログ最大イベントサイズ
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowbinlog_cache_size" headers="binlogoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_binlog_cache_size">binlog_cache_size</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowbinlog_cache_size binlogcli">はい</td>
      <td headers="rowbinlog_cache_size binlogsysvar">はい</td>
      <td headers="rowbinlog_cache_size binlogstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowbinlog_cache_size binlogoptfile">はい</td>
      <td headers="rowbinlog_cache_size binlogscope">グローバル</td>
      <td headers="rowbinlog_cache_size binlogdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowbinlog_cache_size binlognotes">
        <p>
          説明: トランザクション中にバイナリログのために SQL ステートメントを保持するキャッシュのサイズ
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowbinlog_max_flush_queue_time" headers="binlogoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_binlog_max_flush_queue_time">binlog_max_flush_queue_time</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowbinlog_max_flush_queue_time binlogcli">いいえ</td>
      <td headers="rowbinlog_max_flush_queue_time binlogsysvar">はい</td>
      <td headers="rowbinlog_max_flush_queue_time binlogstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowbinlog_max_flush_queue_time binlogoptfile">いいえ</td>
      <td headers="rowbinlog_max_flush_queue_time binlogscope">グローバル</td>
      <td headers="rowbinlog_max_flush_queue_time binlogdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowbinlog_max_flush_queue_time binlognotes">
        <p>
          説明: バイナリログにフラッシュする前にどのくらいトランザクションを読み取るか
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowbinlog_order_commits" headers="binlogoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_binlog_order_commits">binlog_order_commits</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowbinlog_order_commits binlogcli">いいえ</td>
      <td headers="rowbinlog_order_commits binlogsysvar">はい</td>
      <td headers="rowbinlog_order_commits binlogstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowbinlog_order_commits binlogoptfile">いいえ</td>
      <td headers="rowbinlog_order_commits binlogscope">グローバル</td>
      <td headers="rowbinlog_order_commits binlogdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowbinlog_order_commits binlognotes">
        <p>
          説明: バイナリログへの書き込みと同じ順序でコミットするかどうか
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowbinlog_stmt_cache_size" headers="binlogoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_binlog_stmt_cache_size">binlog_stmt_cache_size</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowbinlog_stmt_cache_size binlogcli">はい</td>
      <td headers="rowbinlog_stmt_cache_size binlogsysvar">はい</td>
      <td headers="rowbinlog_stmt_cache_size binlogstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowbinlog_stmt_cache_size binlogoptfile">はい</td>
      <td headers="rowbinlog_stmt_cache_size binlogscope">グローバル</td>
      <td headers="rowbinlog_stmt_cache_size binlogdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowbinlog_stmt_cache_size binlognotes">
        <p>
          説明: トランザクション中にバイナリログのために非トランザクションステートメントを保持するキャッシュのサイズ
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowbinlog_format" headers="binlogoptvar">
        <p>
          <code class="literal"><a class="link" href="server-administration.html#option_mysqld_binlog-format">binlog_format</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowbinlog_format binlogcli">はい</td>
      <td headers="rowbinlog_format binlogsysvar">はい</td>
      <td headers="rowbinlog_format binlogstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowbinlog_format binlogoptfile">はい</td>
      <td headers="rowbinlog_format binlogscope">両方</td>
      <td headers="rowbinlog_format binlogdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowbinlog_format binlognotes">
        <p>
          説明: バイナリログの形式を指定します
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowbinlog-rows-query-log-events" headers="binlogoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_binlog-rows-query-log-events">binlog-rows-query-log-events</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowbinlog-rows-query-log-events binlogcli">はい</td>
      <td headers="rowbinlog-rows-query-log-events binlogsysvar">いいえ</td>
      <td headers="rowbinlog-rows-query-log-events binlogstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowbinlog-rows-query-log-events binlogoptfile">はい</td>
      <td headers="rowbinlog-rows-query-log-events binlogscope"></td>
      <td headers="rowbinlog-rows-query-log-events binlogdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowbinlog-rows-query-log-events binlognotes">
        <p>
          説明: 行ベースロギングを使用するときに行クエリーログイベントのロギングを有効にします。デフォルトで無効になっています。5.6.2 より前のスレーブ/リーダーにログを生成するときは有効にしないでください。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowbinlog_direct_non_transactional_updates" headers="binlogoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_binlog_direct_non_transactional_updates">binlog_direct_non_transactional_updates</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowbinlog_direct_non_transactional_updates binlogcli">はい</td>
      <td headers="rowbinlog_direct_non_transactional_updates binlogsysvar">はい</td>
      <td headers="rowbinlog_direct_non_transactional_updates binlogstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowbinlog_direct_non_transactional_updates binlogoptfile">はい</td>
      <td headers="rowbinlog_direct_non_transactional_updates binlogscope">両方</td>
      <td headers="rowbinlog_direct_non_transactional_updates binlogdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowbinlog_direct_non_transactional_updates binlognotes">
        <p>
          説明: 非トランザクションエンジンにステートメント形式を使用する更新が直接バイナリログに書き込まれます。使用する前にドキュメントを参照してください。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowlog_bin_basename" headers="binlogoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_log_bin_basename">log_bin_basename</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowlog_bin_basename binlogcli">いいえ</td>
      <td headers="rowlog_bin_basename binlogsysvar">はい</td>
      <td headers="rowlog_bin_basename binlogstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowlog_bin_basename binlogoptfile">いいえ</td>
      <td headers="rowlog_bin_basename binlogscope">グローバル</td>
      <td headers="rowlog_bin_basename binlogdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowlog_bin_basename binlognotes">
        <p>
          説明: バイナリログへの完全パス （ファイル名を含む）
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowlog-bin-use-v1-row-events" headers="binlogoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_log-bin-use-v1-row-events">log-bin-use-v1-row-events</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowlog-bin-use-v1-row-events binlogcli">はい</td>
      <td headers="rowlog-bin-use-v1-row-events binlogsysvar">はい</td>
      <td headers="rowlog-bin-use-v1-row-events binlogstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowlog-bin-use-v1-row-events binlogoptfile">はい</td>
      <td headers="rowlog-bin-use-v1-row-events binlogscope">グローバル</td>
      <td headers="rowlog-bin-use-v1-row-events binlogdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowlog-bin-use-v1-row-events binlognotes">
        <p>
          説明: バージョン 1 バイナリログ行イベントを使用します
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowlog_bin_use_v1_row_events" headers="binlogoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_log_bin_use_v1_row_events">log_bin_use_v1_row_events</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowlog_bin_use_v1_row_events binlogcli">はい</td>
      <td headers="rowlog_bin_use_v1_row_events binlogsysvar">はい</td>
      <td headers="rowlog_bin_use_v1_row_events binlogstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowlog_bin_use_v1_row_events binlogoptfile">はい</td>
      <td headers="rowlog_bin_use_v1_row_events binlogscope">グローバル</td>
      <td headers="rowlog_bin_use_v1_row_events binlogdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowlog_bin_use_v1_row_events binlognotes">
        <p>
          説明: サーバーがバージョン 1 バイナリログ行イベントを使用しているかどうか
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowmaster-verify-checksum" headers="binlogoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_master-verify-checksum">master-verify-checksum</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowmaster-verify-checksum binlogcli">はい</td>
      <td headers="rowmaster-verify-checksum binlogsysvar">いいえ</td>
      <td headers="rowmaster-verify-checksum binlogstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowmaster-verify-checksum binlogoptfile">はい</td>
      <td headers="rowmaster-verify-checksum binlogscope"></td>
      <td headers="rowmaster-verify-checksum binlogdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowmaster-verify-checksum binlognotes">
        <p>
          説明: マスターがバイナリログから読み取るときにチェックサムを検査します。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowmaster_verify_checksum" headers="binlogoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_master_verify_checksum">master_verify_checksum</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowmaster_verify_checksum binlogcli">いいえ</td>
      <td headers="rowmaster_verify_checksum binlogsysvar">はい</td>
      <td headers="rowmaster_verify_checksum binlogstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowmaster_verify_checksum binlogoptfile">いいえ</td>
      <td headers="rowmaster_verify_checksum binlogscope">グローバル</td>
      <td headers="rowmaster_verify_checksum binlogdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowmaster_verify_checksum binlognotes">
        <p>
          説明: マスターがバイナリログからチェックサムを読み取ります。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowmax-binlog-dump-events" headers="binlogoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_max-binlog-dump-events">max-binlog-dump-events</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowmax-binlog-dump-events binlogcli">はい</td>
      <td headers="rowmax-binlog-dump-events binlogsysvar">いいえ</td>
      <td headers="rowmax-binlog-dump-events binlogstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowmax-binlog-dump-events binlogoptfile">はい</td>
      <td headers="rowmax-binlog-dump-events binlogscope"></td>
      <td headers="rowmax-binlog-dump-events binlogdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowmax-binlog-dump-events binlognotes">
        <p>
          説明: mysql-test によってレプリケーションのデバッグとテストのために使用されるオプション
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowmax_binlog_cache_size" headers="binlogoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_max_binlog_cache_size">max_binlog_cache_size</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowmax_binlog_cache_size binlogcli">はい</td>
      <td headers="rowmax_binlog_cache_size binlogsysvar">はい</td>
      <td headers="rowmax_binlog_cache_size binlogstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowmax_binlog_cache_size binlogoptfile">はい</td>
      <td headers="rowmax_binlog_cache_size binlogscope">グローバル</td>
      <td headers="rowmax_binlog_cache_size binlogdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowmax_binlog_cache_size binlognotes">
        <p>
          説明: マルチステートメントトランザクションをキャッシュするために使用される合計サイズを制限するために使用できます
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowmax_binlog_size" headers="binlogoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_max_binlog_size">max_binlog_size</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowmax_binlog_size binlogcli">はい</td>
      <td headers="rowmax_binlog_size binlogsysvar">はい</td>
      <td headers="rowmax_binlog_size binlogstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowmax_binlog_size binlogoptfile">はい</td>
      <td headers="rowmax_binlog_size binlogscope">グローバル</td>
      <td headers="rowmax_binlog_size binlogdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowmax_binlog_size binlognotes">
        <p>
          説明: サイズがこの値を超えたときにバイナリログが自動的にローテーションします。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowmax_binlog_stmt_cache_size" headers="binlogoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_max_binlog_stmt_cache_size">max_binlog_stmt_cache_size</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowmax_binlog_stmt_cache_size binlogcli">はい</td>
      <td headers="rowmax_binlog_stmt_cache_size binlogsysvar">はい</td>
      <td headers="rowmax_binlog_stmt_cache_size binlogstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowmax_binlog_stmt_cache_size binlogoptfile">はい</td>
      <td headers="rowmax_binlog_stmt_cache_size binlogscope">グローバル</td>
      <td headers="rowmax_binlog_stmt_cache_size binlogdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowmax_binlog_stmt_cache_size binlognotes">
        <p>
          説明: トランザクション中にすべての非トランザクションステートメントをキャッシュするために使用される合計サイズを制限するために使用できます
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowslave-sql-verify-checksum" headers="binlogoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_slave-sql-verify-checksum">slave-sql-verify-checksum</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowslave-sql-verify-checksum binlogcli">はい</td>
      <td headers="rowslave-sql-verify-checksum binlogsysvar">いいえ</td>
      <td headers="rowslave-sql-verify-checksum binlogstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowslave-sql-verify-checksum binlogoptfile">はい</td>
      <td headers="rowslave-sql-verify-checksum binlogscope"></td>
      <td headers="rowslave-sql-verify-checksum binlogdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowslave-sql-verify-checksum binlognotes">
        <p>
          説明: スレーブがリレーログから読み取るときにチェックサムを検査します
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowslave_sql_verify_checksum" headers="binlogoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#sysvar_slave_sql_verify_checksum">slave_sql_verify_checksum</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowslave_sql_verify_checksum binlogcli">いいえ</td>
      <td headers="rowslave_sql_verify_checksum binlogsysvar">はい</td>
      <td headers="rowslave_sql_verify_checksum binlogstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowslave_sql_verify_checksum binlogoptfile">いいえ</td>
      <td headers="rowslave_sql_verify_checksum binlogscope">グローバル</td>
      <td headers="rowslave_sql_verify_checksum binlogdynamic">はい</td>
    </tr><tr>
      <td colspan="3" headers="rowslave_sql_verify_checksum binlognotes">
        <p>
          説明: スレーブがリレーログから読み取るときにチェックサムを検査します。
        </p>
      </td>
    </tr></tbody><tbody><tr>
      <td colspan="3" align="center" id="rowsporadic-binlog-dump-fail" headers="binlogoptvar">
        <p>
          <code class="literal"><a class="link" href="replication.html#option_mysqld_sporadic-binlog-dump-fail">sporadic-binlog-dump-fail</a></code>
        </p>
      </td>
    </tr><tr>
      <td headers="rowsporadic-binlog-dump-fail binlogcli">はい</td>
      <td headers="rowsporadic-binlog-dump-fail binlogsysvar">いいえ</td>
      <td headers="rowsporadic-binlog-dump-fail binlogstatvar">いいえ</td>
    </tr><tr>
      <td headers="rowsporadic-binlog-dump-fail binlogoptfile">はい</td>
      <td headers="rowsporadic-binlog-dump-fail binlogscope"></td>
      <td headers="rowsporadic-binlog-dump-fail binlogdynamic">いいえ</td>
    </tr><tr>
      <td colspan="3" headers="rowsporadic-binlog-dump-fail binlognotes">
        <p>
          説明: mysql-test によってレプリケーションのデバッグとテストのために使用されるオプション
        </p>
      </td>
    </tr></tbody></table></div></div><br class="table-break"><p>
      <a class="xref" href="replication.html#replication-options-binary-log" title="17.1.4.4 バイナリログのオプションと変数">セクション17.1.4.4「バイナリログのオプションと変数」</a>は、バイナリロギングに関係するオプションと変数に関する詳細情報を提供します。バイナリログに関するその他の一般情報については、<a class="xref" href="server-administration.html#binary-log" title="5.2.4 バイナリログ">セクション5.2.4「バイナリログ」</a>を参照してください。
    </p><p>
      <code class="literal">sql_log_bin</code> および <code class="literal">sql_log_off</code> 変数については、<a class="xref" href="server-administration.html#server-system-variables" title="5.1.4 サーバーシステム変数">セクション5.1.4「サーバーシステム変数」</a>を参照してください。
    </p><p>
      <span class="command"><strong>mysqld</strong></span> で使用される<span class="emphasis"><em>すべての</em></span>コマンド行オプション、システム変数、およびステータス変数を示す表については、<a class="xref" href="server-administration.html#mysqld-option-tables" title="5.1.1 サーバーオプションおよび変数リファレンス">セクション5.1.1「サーバーオプションおよび変数リファレンス」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-options-master"></a>17.1.4.2 レプリケーションマスターのオプションと変数</h4></div></div></div><p>
      このセクションでは、レプリケーションマスターサーバーで使用できるサーバーオプションとシステム変数について説明します。オプションは<a class="link" href="programs.html#command-line-options" title="4.2.4 コマンド行でのオプションの使用">コマンド行</a>または<a class="link" href="programs.html#option-files" title="4.2.6 オプションファイルの使用">オプションファイル</a>で指定できます。システム変数値は<code class="literal">SET</code> を使用して指定できます。
    </p><p>
      マスターと各スレーブでは、<code class="option">server-id</code> オプションを使用して一意レプリケーション ID を確立する必要があります。サーバーごとに、一意の正の整数を 1 から 2<sup>32</sup> − 1 の範囲から選択してください。各 ID は、ほかのレプリケーションのマスターまたはスレーブが使用するほかのあらゆる ID と異なっている必要があります。例: <code class="literal">server-id=3</code>。
    </p><p>
      バイナリロギングを制御するためにマスターで使用されるオプションについては、<a class="xref" href="replication.html#replication-options-binary-log" title="17.1.4.4 バイナリログのオプションと変数">セクション17.1.4.4「バイナリログのオプションと変数」</a>を参照してください。
    </p><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="replication-sysvars-masters"></a>レプリケーションマスターで使用されるシステム変数</h5></div></div></div><p>
        次のシステム変数は、レプリケーションマスターを制御するために使用されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="sysvar_auto_increment_increment"></a>
            <a class="indexterm" name="idm139979052584880"></a> <a class="indexterm" name="idm139979052583328"></a> <code class="literal">auto_increment_increment</code>
          </p><div class="informaltable"><table summary="Options for auto_increment_increment" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_auto_increment_increment">auto_increment_increment</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル、セッション</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">65535</code></td></tr></tbody></table></div><p>
            <code class="literal">auto_increment_increment</code> および <code class="literal">auto_increment_offset</code> は、マスターからマスターへのレプリケーションで使用するためのもので、<code class="literal">AUTO_INCREMENT</code> カラムの操作を制御するために使用できます。両方の変数はグローバル値とセッション値を持ち、各値は 1 から 65,535 (1 と 65,535 を含みます) の間の整数値を取ることができます。これらの 2 つの変数のいずれかの値を 0 に設定すると、代わりにその値は 1 に設定されます。これらの 2 つの変数のいずれかの値を 65,535 より大きな整数または 0 より小さい整数に設定しようとすると、代わりにその値は 65,535 に設定されます。<code class="literal">auto_increment_increment</code> または <code class="literal">auto_increment_offset</code> の値を整数でない値に設定しようとすると、エラーが発生し、変数の実際の値は変化しません。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              <code class="literal">auto_increment_increment</code> は <code class="literal">NDB</code> テーブルで使用する場合にもサポートされます。
            </p></div><p>
            これら 2 つの変数は、次のように <code class="literal">AUTO_INCREMENT</code> カラムの動作に影響します。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">auto_increment_increment</code> は、連続するカラム値の間隔を制御します。例:
              </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'auto_inc%';</code></strong>
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| auto_increment_increment | 1     |
| auto_increment_offset    | 1     |
+--------------------------+-------+
2 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>CREATE TABLE autoinc1</code></strong>
    -&gt; <strong class="userinput"><code>(col INT NOT NULL AUTO_INCREMENT PRIMARY KEY);</code></strong>
  Query OK, 0 rows affected (0.04 sec)

mysql&gt; <strong class="userinput"><code>SET @@auto_increment_increment=10;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'auto_inc%';</code></strong>
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| auto_increment_increment | 10    |
| auto_increment_offset    | 1     |
+--------------------------+-------+
2 rows in set (0.01 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO autoinc1 VALUES (NULL), (NULL), (NULL), (NULL);</code></strong>
Query OK, 4 rows affected (0.00 sec)
Records: 4  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT col FROM autoinc1;</code></strong>
+-----+
| col |
+-----+
|   1 |
|  11 |
|  21 |
|  31 |
+-----+
4 rows in set (0.00 sec)
</pre></li><li class="listitem"><p>
                <code class="literal">auto_increment_offset</code> は <code class="literal">AUTO_INCREMENT</code> カラム値の開始点を指定します。次のことは、<code class="literal">auto_increment_increment</code> の記述で示した例のように、同じセッション中にこれらのステートメントが実行されるものと仮定しています。
              </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET @@auto_increment_offset=5;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'auto_inc%';</code></strong>
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| auto_increment_increment | 10    |
| auto_increment_offset    | 5     |
+--------------------------+-------+
2 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>CREATE TABLE autoinc2</code></strong>
    -&gt; <strong class="userinput"><code>(col INT NOT NULL AUTO_INCREMENT PRIMARY KEY);</code></strong>
Query OK, 0 rows affected (0.06 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO autoinc2 VALUES (NULL), (NULL), (NULL), (NULL);</code></strong>
Query OK, 4 rows affected (0.00 sec)
Records: 4  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT col FROM autoinc2;</code></strong>
+-----+
| col |
+-----+
|   5 |
|  15 |
|  25 |
|  35 |
+-----+
4 rows in set (0.02 sec)
</pre><p>
                <code class="literal">auto_increment_offset</code> の値が <code class="literal">auto_increment_increment</code> の値よりも大きいと、<code class="literal">auto_increment_offset</code> の値は無視されます。
              </p></li></ul></div><p>
            これらの変数のいずれかが変更されてから、<code class="literal">AUTO_INCREMENT</code> カラムを含むテーブルに新しい行が挿入される場合、結果は反直感的に見える場合があります。<code class="literal">AUTO_INCREMENT</code> 値のシリーズがカラムにすでに存在する値に関係なく計算され、挿入される次の値が <code class="literal">AUTO_INCREMENT</code> カラムに存在する最大値よりも大きなシリーズ内最小値であるためです。シリーズは次のように計算されます。
          </p><p>
            <code class="literal">auto_increment_offset</code> + <em class="replaceable"><code>N</code></em> × <code class="literal">auto_increment_increment</code>
          </p><p>
            ここで、<em class="replaceable"><code>N</code></em> はシリーズ内正の整数値 [1, 2, 3, ...] です。例:
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'auto_inc%';</code></strong>
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| auto_increment_increment | 10    |
| auto_increment_offset    | 5     |
+--------------------------+-------+
2 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT col FROM autoinc1;</code></strong>
+-----+
| col |
+-----+
|   1 |
|  11 |
|  21 |
|  31 |
+-----+
4 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO autoinc1 VALUES (NULL), (NULL), (NULL), (NULL);</code></strong>
Query OK, 4 rows affected (0.00 sec)
Records: 4  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT col FROM autoinc1;</code></strong>
+-----+
| col |
+-----+
|   1 |
|  11 |
|  21 |
|  31 |
|  35 |
|  45 |
|  55 |
|  65 |
+-----+
8 rows in set (0.00 sec)
</pre><p>
            <code class="literal">auto_increment_increment</code> と <code class="literal">auto_increment_offset</code> に示される値は、シリーズ 5 + <em class="replaceable"><code>N</code></em> × 10、つまり [5, 15, 25, 35, 45, ...] を生成します。<code class="literal">INSERT</code> より前に <code class="literal">col</code> カラムに存在する最高値は 31、<code class="literal">AUTO_INCREMENT</code> シリーズ内で次に使用できる値は 35 なので、<code class="literal">col</code> に挿入される値はそのポイントで始まり、結果は <code class="literal">SELECT</code> クエリーで示されるようになります。
          </p><p>
            これらの 2 つの変数の影響を単一テーブルに制限することはできません。これらの変数は MySQL サーバーの<span class="emphasis"><em>すべて</em></span>のテーブルのすべての <code class="literal">AUTO_INCREMENT</code> カラムの動作を制御します。どちらかの変数のグローバル値が設定されると、グローバル値が変更されるか、セッション値の設定によってオーバーライドされるまで、または <span class="command"><strong>mysqld</strong></span> が再起動されるまでその効果は持続します。ローカル値が設定されると、新しい値は、セッションの期間に現在のユーザーが新しい行を挿入したすべてのテーブルの <code class="literal">AUTO_INCREMENT</code> カラムに影響します (そのセッション中にそれらの値が変更される場合を除く)。
          </p><p>
            <code class="literal">auto_increment_increment</code> のデフォルト値は 1 です。<a class="xref" href="replication.html#replication-features-auto-increment" title="17.4.1.1 レプリケーションと AUTO_INCREMENT">セクション17.4.1.1「レプリケーションと AUTO_INCREMENT」</a>を参照してください。
          </p></li><li class="listitem"><p><a name="sysvar_auto_increment_offset"></a>
            <a class="indexterm" name="idm139979052499120"></a> <a class="indexterm" name="idm139979052497568"></a> <code class="literal">auto_increment_offset</code>
          </p><div class="informaltable"><table summary="Options for auto_increment_offset" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_auto_increment_offset">auto_increment_offset</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル、セッション</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">65535</code></td></tr></tbody></table></div><p>
            この変数のデフォルト値は 1 です。詳細については、<code class="literal">auto_increment_increment</code> の説明を参照してください。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              <code class="literal">auto_increment_offset</code> は <code class="literal">NDB</code> テーブルで使用する場合にもサポートされます。
            </p></div></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-options-slave"></a>17.1.4.3 レプリケーションスレーブのオプションと変数</h4></div></div></div><p>
      <a class="xref" href="replication.html#replication-optvars-slaves" title="レプリケーションスレーブの起動オプション">レプリケーションスレーブの起動オプション</a>
    </p><p>
      <a class="xref" href="replication.html#replication-options-slave-log-tables" title="スレーブステータスログをテーブルに記録するためのオプション">スレーブステータスログをテーブルに記録するためのオプション</a>
    </p><p>
      <a class="xref" href="replication.html#replication-optvars-slaves-obsolete" title="廃止されたレプリケーションスレーブオプション">廃止されたレプリケーションスレーブオプション</a>
    </p><p>
      <a class="xref" href="replication.html#replication-sysvars-slaves" title="レプリケーションスレーブで使用されるシステム変数">レプリケーションスレーブで使用されるシステム変数</a>
    </p><p>
      オプションは<a class="link" href="programs.html#command-line-options" title="4.2.4 コマンド行でのオプションの使用">コマンド行</a>または<a class="link" href="programs.html#option-files" title="4.2.6 オプションファイルの使用">オプションファイル</a>で指定します。多くのオプションは、サーバーの動作中に <code class="literal">CHANGE MASTER TO</code> ステートメントを使用して設定できます。システム変数値は <code class="literal">SET</code> を使用して指定します。
    </p><p><b>サーバー ID </b>
        マスターと各スレーブでは、<code class="option">server-id</code> オプションを使用して、範囲が 1 から 2<sup>32</sup> − 1 の一意レプリケーション ID を確立する必要があります。<span class="quote">「<span class="quote">一意</span>」</span>とは、各 ID が、ほかのレプリケーションマスターまたはスレーブで使用されるほかのあらゆる ID とは異なっている必要があるということです。<code class="filename">my.cnf</code> ファイルの例:
      </p><pre class="programlisting">
[mysqld]
server-id=3
</pre><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="replication-optvars-slaves"></a>レプリケーションスレーブの起動オプション</h5></div></div></div><p>
        このセクションでは、レプリケーションスレーブサーバーを制御するための起動オプションについて説明します。これらのオプションの多くは、サーバーの動作中に <code class="literal">CHANGE MASTER TO</code> ステートメントを使用して設定できます。<code class="option">--replicate-*</code> などのその他のオプションは、スレーブサーバーが起動するときにのみ設定できます。レプリケーションに関連するシステム変数はこのセクションの後半で説明します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="option_mysqld_abort-slave-event-count"></a>
            

            <a class="indexterm" name="idm139979052447008"></a> <a class="indexterm" name="idm139979052444768"></a> <code class="option">--abort-slave-event-count</code>
          </p><div class="informaltable"><table summary="Options for abort-slave-event-count" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--abort-slave-event-count=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr></tbody></table></div><p>
            このオプションが 0 (デフォルト) 以外の正の整数<em class="replaceable"><code>値</code></em>に設定されると、次のようにレプリケーションの動作に影響します。スレーブ SQL スレッドが起動したあと、<em class="replaceable"><code>値</code></em>ログイベントの実行が許可され、スレーブ SQL スレッドはマスターからのネットワーク接続が切断されたかのようにそれ以上イベントを受け取りません。スレーブのスレッドの実行は継続し、<code class="literal">SHOW SLAVE STATUS</code> からの出力には <code class="literal">Slave_IO_Running</code> および <code class="literal">Slave_SQL_Running</code> カラムの両方に <code class="literal">Yes</code> が表示されますが、それ以降のイベントはリレーログから読み取られません。
          </p><p>
            このオプションは、レプリケーションのテストとデバッグのために、MySQL テストスイートで内部的に使用されます。本番環境設定で使用することを想定していません。
          </p></li><li class="listitem"><p><a name="option_mysqld_disconnect-slave-event-count"></a>
            <a class="indexterm" name="idm139979052420880"></a> <a class="indexterm" name="idm139979052418688"></a> <code class="option">--disconnect-slave-event-count</code>
          </p><div class="informaltable"><table summary="Options for disconnect-slave-event-count" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--disconnect-slave-event-count=#</code></td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr></tbody></table></div><p>
            このオプションは、レプリケーションのテストとデバッグのために、MySQL テストスイートで内部的に使用されます。
          </p></li><li class="listitem"><p><a name="option_mysqld_log-slave-updates"></a>
            <a class="indexterm" name="idm139979052402336"></a> <a class="indexterm" name="idm139979052400176"></a> <code class="option">--log-slave-updates</code>
          </p><div class="informaltable"><table summary="Options for log-slave-updates" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--log-slave-updates</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_log_slave_updates">log_slave_updates</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr></tbody></table></div><p>
            通常、スレーブはマスターサーバーから受け取った更新をそれ自身のバイナリログに書き込みません。このオプションによって、スレーブはその SQL スレッドによって実行される更新をそれ自身のバイナリログに書き込みます。このオプションを有効にするには、<code class="option">--log-bin</code> オプションを使用してスレーブを起動してバイナリロギングを有効にする必要もあります。MySQL 5.5 より前では、<code class="option">--log-slave-updates</code> オプションを使用しても、<code class="option">--log-bin</code> オプションでサーバーを起動することなくサーバーは起動せず、エラーで失敗します。MySQL 5.6 では、警告が生成されるだけです。(Bug #44663) <code class="option">--log-slave-updates</code> はレプリケーションサーバーをチェーンするときに使用されます。たとえば、このようにレプリケーションサーバーをセットアップするとします。
          </p><pre class="programlisting">
A -&gt; B -&gt; C
</pre><p>
            ここでは、<code class="literal">A</code> はスレーブ <code class="literal">B</code> のマスターとして機能し、<code class="literal">B</code> はスレーブ <code class="literal">C</code> のマスターとして機能します。これが機能するには、<code class="literal">B</code> はマスター<span class="emphasis"><em>かつ</em></span>スレーブである必要があります。バイナリロギングを有効にするために <code class="literal">A</code> と <code class="literal">B</code> の両方を <code class="option">--log-bin</code> で起動し、<code class="literal">A</code> から受け取った更新が <code class="literal">B</code> によってそのバイナリログに記録されるように <code class="literal">B</code> を <code class="option">--log-slave-updates</code> オプションで起動する必要があります。
          </p></li><li class="listitem"><p><a name="option_mysqld_log-slow-slave-statements"></a>
            <a class="indexterm" name="idm139979052361584"></a> <a class="indexterm" name="idm139979052359344"></a> <code class="option">--log-slow-slave-statements</code>
          </p><div class="informaltable"><table summary="Options for log-slow-slave-statements" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>削除</strong></span></td><td colspan="3">5.6.11</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--log-slow-slave-statements</code> (&lt;= 5.6.10)</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr></tbody></table></div><p>
            スロークエリーログが有効化されている場合、このオプションはスレーブでの実行に <code class="literal">long_query_time</code> 秒を超える時間がかかったクエリーのロギングを有効にします。
          </p><p>
            このコマンド行オプションは MySQL 5.6.11 で削除され、<code class="literal">log_slow_slave_statements</code> システム変数によって置き換えられました。システム変数はオプションと同じ方法でコマンド行またはオプションファイルに設定できるため、サーバー起動時に何らかの変更を行う必要はありませんが、システム変数は実行時に値を検査または設定することも可能です。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979052338336"></a> <a class="indexterm" name="idm139979052336128"></a> <code class="option">--log-warnings[=<em class="replaceable"><code>level</code></em>]</code>
          </p><div class="informaltable"><table summary="Options for log-warnings" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--log-warnings[=#]</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数 (&lt;= 5.6.3)</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="server-administration.html#sysvar_log_warnings">log_warnings</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル、セッション</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数 (&gt;= 5.6.4)</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="server-administration.html#sysvar_log_warnings">log_warnings</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (32 ビットプラットフォーム)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">4294967295</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (64 ビットプラットフォーム)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">18446744073709551615</code></td></tr></tbody></table></div><p>
            サーバーは、それが実行していることに関するメッセージをより多くエラーログに記録します。レプリケーションに関して、サーバーは、それがネットワークまたは接続障害後の再接続に成功したことの警告を生成し、各スレーブスレッドがどのように起動したかに関する情報を提供します。このオプションはデフォルトでは (1) が有効です。無効にするには、<code class="option">--log-warnings=0</code> を使用します。値が 1 より大きい場合、中止された接続がエラーログに書き込まれ、新しい接続の試行についてのアクセス拒否エラーが書き込まれます。<a class="xref" href="error-handling.html#communication-errors" title="B.5.2.11 通信エラーおよび中止された接続">セクションB.5.2.11「通信エラーおよび中止された接続」</a>を参照してください。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              このオプションの影響はレプリケーションに制限されません。サーバーアクティビティー全体を対象として警告を生成します。
            </p></div></li><li class="listitem"><p><a name="option_mysqld_master-info-file"></a>
            <a class="indexterm" name="idm139979052286240"></a> <a class="indexterm" name="idm139979052284112"></a> <code class="option">--master-info-file=<em class="replaceable"><code>file_name</code></em></code>
          </p><div class="informaltable"><table summary="Options for master-info-file" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--master-info-file=file_name</code></td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ファイル名</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">master.info</code></td></tr></tbody></table></div><p>
            マスターの情報をスレーブが記録するファイルに使用する名前。データディレクトリ内のデフォルト名は <code class="filename">master.info</code> です。このファイルの形式については、<a class="xref" href="replication.html#slave-logs-status" title="17.2.2.2 スレーブステータスログ">セクション17.2.2.2「スレーブステータスログ」</a>を参照してください。
          </p></li><li class="listitem"><p><a name="option_mysqld_master-retry-count"></a>
            <a class="indexterm" name="idm139979052266032"></a> <a class="indexterm" name="idm139979052263904"></a> <code class="option">--master-retry-count=<em class="replaceable"><code>count</code></em></code>
          </p><div class="informaltable"><table summary="Options for master-retry-count" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>非推奨</strong></span></td><td colspan="3">5.6.1</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--master-retry-count=#</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (32 ビットプラットフォーム)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">86400</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">4294967295</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (64 ビットプラットフォーム)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">86400</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">18446744073709551615</code></td></tr></tbody></table></div><p>
            スレーブマスターに接続を試みる回数 (これを超えると中断)。再接続は、<code class="literal">CHANGE MASTER TO</code> ステートメントの <code class="literal">MASTER_CONNECT_RETRY</code> オプションによって設定された間隔で (デフォルトは 60) で試行されます。再接続は、<code class="option">--slave-net-timeout</code> オプションに応じてスレーブによるデータ読み取りがタイムアウトしたときにトリガーされます。デフォルト値は 86400 です。値 0 は<span class="quote">「<span class="quote">永続</span>」</span>を意味し、スレーブは永久に接続を試みます。
          </p><p>
            このオプションは MySQL 5.6.1 以降で非推奨となり、将来の MySQL リリースで削除される予定です。代わりに、<code class="literal">CHANGE MASTER TO</code> ステートメントの <code class="literal">MASTER_RETRY_COUNT</code> オプションを使用するように、アプリケーションを更新してください。
          </p></li><li class="listitem"><p><a name="option_mysqld_max-relay-log-size"></a>
            <a class="indexterm" name="idm139979052224480"></a> <a class="indexterm" name="idm139979052222320"></a> <code class="option">--max-relay-log-size=<em class="replaceable"><code>size</code></em></code>
          </p><div class="informaltable"><table summary="Options for max_relay_log_size" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--max_relay_log_size=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="server-administration.html#sysvar_max_relay_log_size">max_relay_log_size</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">1073741824</code></td></tr></tbody></table></div><p>
            このサイズで、サーバーはリレーログファイルを自動的にローテーションします。この値がゼロでない場合は、サイズがこの値を超えたときにリレーログは自動的にローテーションされます。この値がゼロ (デフォルト) の場合、リレーログローテーションが発生するサイズは <code class="literal">max_binlog_size</code> の値によって決められます。詳細については、<a class="xref" href="replication.html#slave-logs-relaylog" title="17.2.2.1 スレーブリレーログ">セクション17.2.2.1「スレーブリレーログ」</a>を参照してください。
          </p></li><li class="listitem"><p><a name="option_mysqld_read-only"></a>
            <a class="indexterm" name="idm139979052191744"></a> <a class="indexterm" name="idm139979052189584"></a> <code class="option">--read-only</code>
          </p><div class="informaltable"><table summary="Options for read_only" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--read-only</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="server-administration.html#sysvar_read_only">read_only</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">false</code></td></tr></tbody></table></div><p>
            スレーブがスレーブスレッドまたは <code class="literal">SUPER</code> 権限を持つユーザー以外からの更新を許可しなくなります。スレーブサーバーで、スレーブがクライアントからは受け付けず、確実にそのマスターサーバーからのみ更新を受け付けるようにするには、これが役立つ場合があります。この変数は <code class="literal">TEMPORARY</code> テーブルには適用されません。
          </p></li><li class="listitem"><p><a name="option_mysqld_relay-log"></a>
            <a class="indexterm" name="idm139979052163728"></a> <a class="indexterm" name="idm139979052161568"></a> <code class="option">--relay-log=<em class="replaceable"><code>file_name</code></em></code>
          </p><div class="informaltable"><table summary="Options for relay-log" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--relay-log=file_name</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_relay_log">relay_log</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ファイル名</code></td></tr></tbody></table></div><p>
            リレーログのベース名。デフォルトベース名は <code class="filename"><em class="replaceable"><code>host_name</code></em>-relay-bin</code> です。別のディレクトリを指定するために先頭に絶対パス名を付けたベース名が指定されないかぎり、サーバーはデータディレクトリにファイルを書き込みます。サーバーは、ベース名に数値サフィクスを追加することで、順番にリレーログファイルを作成します。
          </p><p>
            MySQL がサーバーオプションを解析する方法が原因で、このオプションを指定する場合は、値を指定する必要があります。<span class="emphasis"><em>デフォルトベース名はオプションが実際に指定されない場合にのみ使用されます</em></span>。値を指定しないで <code class="option">--relay-log</code> オプションを使用する場合、予期しない動作になる場合があります。この動作は、使用されるほかのオプション、それらが指定される順序、およびそれらがコマンド行でまたはオプションファイルのどちらで指定されたかに依存します。MySQL がサーバーオプションをどのように処理するかについて詳しくは、<a class="xref" href="programs.html#program-options" title="4.2.3 プログラムオプションの指定">セクション4.2.3「プログラムオプションの指定」</a>を参照してください。
          </p><p>
            このオプションを指定した場合、指定された値はリレーログインデックスファイルのベース名としても使用されます。<code class="option">--relay-log-index</code> オプションを使用して別のリレーログインデックスファイルを指定することで、この動作をオーバーライドできます。
          </p><p>
            MySQL 5.6.5 以降は、サーバーがインデックスファイルからエントリを読み取るときに、エントリに相対パスが含まれるかどうかをチェックします。その場合、パスの相対部は <code class="option">--relay-log</code> オプションを使用して設定された絶対パスに置き換わります。絶対パスは変わりません。このような場合、使用される新しいパスを有効にするために、インデックスを手動で編集する必要があります。MySQL 5.6.5 より前は、バイナリログまたはリレーログファイルの位置を変更するときは手動介入が必要でした。(Bug #11745230、Bug #12133)
          </p><p>
            次のタスクを実行するときに、<code class="option">--relay-log</code> オプションが役立つ場合があります。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                名前がホスト名に依存しないリレーログを作成する。
              </p></li><li class="listitem"><p>
                リレーログが非常に大きくなる傾向があり、<code class="literal">max_relay_log_size</code> を小さくしたくないため、リレーログをデータディレクトリ以外の領域に置く必要がある場合。
              </p></li><li class="listitem"><p>
                ディスク間のロードバランシングを使用して速度を上げるため。
              </p></li></ul></div><p>
            MySQL 5.6.2 以降では、リレーログファイル名 (およびパス) を <code class="literal">relay_log_basename</code> システム変数から取得できます。
          </p></li><li class="listitem"><p><a name="option_mysqld_relay-log-index"></a>
            <a class="indexterm" name="idm139979052123696"></a> <a class="indexterm" name="idm139979052121536"></a> <code class="option">--relay-log-index=<em class="replaceable"><code>file_name</code></em></code>
          </p><div class="informaltable"><table summary="Options for relay-log-index" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--relay-log-index=file_name</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_relay_log_index">relay_log_index</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ファイル名</code></td></tr></tbody></table></div><p>
            リレーログインデックスファイルに使用する名前。データディレクトリ内のデフォルト名は <code class="filename"><em class="replaceable"><code>host_name</code></em>-relay-bin.index</code> です。ここで、<em class="replaceable"><code>host_name</code></em> はスレーブサーバーの名前です。
          </p><p>
            MySQL がサーバーオプションを解析する方法が原因で、このオプションを指定する場合は、値を指定する必要があります。<span class="emphasis"><em>デフォルトベース名はオプションが実際に指定されない場合にのみ使用されます</em></span>。値を指定しないで <code class="option">--relay-log-index</code> オプションを使用する場合、予期しない動作になる場合があります。この動作は、使用されるほかのオプション、それらが指定される順序、およびオプションがコマンド行またはオプションファイルのどちらで指定されたに依存します。MySQL がサーバーオプションをどのように処理するかについて詳しくは、<a class="xref" href="programs.html#program-options" title="4.2.3 プログラムオプションの指定">セクション4.2.3「プログラムオプションの指定」</a>を参照してください。
          </p><p>
            このオプションを指定した場合、指定される値はリレーログのベース名としても使用されます。<code class="option">--relay-log</code> オプションを使用して別のリレーログファイルベース名を指定することで、この動作をオーバーライドできます。
          </p></li><li class="listitem"><p><a name="option_mysqld_relay-log-info-file"></a>
            <a class="indexterm" name="idm139979052093152"></a> <a class="indexterm" name="idm139979052090928"></a> <code class="option">--relay-log-info-file=<em class="replaceable"><code>file_name</code></em></code>
          </p><div class="informaltable"><table summary="Options for relay-log-info-file" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--relay-log-info-file=file_name</code></td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ファイル名</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">relay-log.info</code></td></tr></tbody></table></div><p>
            スレーブがリレーログの情報を記録するファイルに使用する名前。データディレクトリ内のデフォルト名は <code class="filename">relay-log.info</code> です。このファイルの形式については、<a class="xref" href="replication.html#slave-logs-status" title="17.2.2.2 スレーブステータスログ">セクション17.2.2.2「スレーブステータスログ」</a>を参照してください。
          </p></li><li class="listitem"><p><a name="option_mysqld_relay-log-purge"></a>
            <a class="indexterm" name="idm139979052072816"></a> <a class="indexterm" name="idm139979052070688"></a> <code class="option">--relay-log-purge={0|1}</code>
          </p><div class="informaltable"><table summary="Options for relay_log_purge" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--relay_log_purge</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="server-administration.html#sysvar_relay_log_purge">relay_log_purge</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">TRUE</code></td></tr></tbody></table></div><p>
            リレーログファイルが不要になるとすぐに自動的にパージすることを無効または有効にします。デフォルト値は 1 (有効)です。これは <code class="literal">SET GLOBAL relay_log_purge = <em class="replaceable"><code>N</code></em></code> で動的に変更できるグローバル変数です。<code class="option">--relay-log-recovery</code> オプションを使用するときにリレーログのパージを無効にすると、データ一貫性が危険にさらされるため、クラッシュセーフではありません。
          </p></li><li class="listitem"><p><a name="option_mysqld_relay-log-recovery"></a>
            <a class="indexterm" name="idm139979052044752"></a> <a class="indexterm" name="idm139979052042592"></a> <a class="indexterm" name="idm139979052040608"></a> <code class="option">--relay-log-recovery={0|1}</code>
          </p><div class="informaltable"><table summary="Options for relay-log-recovery" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--relay-log-recovery</code></td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">FALSE</code></td></tr></tbody></table></div><p>
            サーバー起動直後のリレーログ自動リカバリを有効にします。リカバリプロセスでは、新しいリレーログファイルを作成し、SQL スレッド位置をこの新しいリレーログに初期化し、I/O スレッドを SQL スレッド位置に初期化します。その後、マスターからのリレーログ読み取りが続行されます。これは、破損した可能性のあるリレーログが処理されないことを保証するために、レプリケーションスレーブでクラッシュ後に使用してください。デフォルト値は 0 (無効)です。
          </p><p>
            クラッシュセーフなスレーブを提供するには、このオプションを有効にし (1 に設定)、<code class="option">--relay-log-info-repository</code> を <code class="literal">TABLE</code> に設定し、<code class="option">relay-log-purge</code> を有効にする必要があります。<code class="option">relay-log-purge</code> が無効なときに <code class="option">--relay-log-recovery</code> オプションを有効にすることで、パージされなかったファイルからリレーログを読み取り、データ矛盾が発生し、クラッシュセーフでなくなるリスクが抑止されます。詳細は、<a class="xref" href="replication.html#replication-implementation-crash-safe" title="クラッシュセーフレプリケーション">クラッシュセーフレプリケーション</a>を参照してください。
          </p><p>
            MySQL 5.6.6 より前で、このオプションがマルチスレッドスレーブで有効の場合、スレーブはエラーで失敗し、そのスレーブで <code class="literal">CHANGE MASTER TO</code> を実行できません。MySQL 5.6.6 以降では、<code class="literal">START SLAVE UNTIL SQL_AFTER_MTS_GAPS</code> を使用してリレーログ内のギャップを処理できます。このステートメントを実行したあと、<code class="literal">CHANGE MASTER TO</code> を使用してこのスレーブを新しいマスターにフェイルオーバーできます。(Bug #13893363)
          </p></li><li class="listitem"><p><a name="option_mysqld_relay-log-space-limit"></a>
            <a class="indexterm" name="idm139979052014016"></a> <a class="indexterm" name="idm139979052011776"></a> <code class="option">--relay-log-space-limit=<em class="replaceable"><code>size</code></em></code>
          </p><div class="informaltable"><table summary="Options for relay_log_space_limit" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--relay_log_space_limit=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="server-administration.html#sysvar_relay_log_space_limit">relay_log_space_limit</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (32 ビットプラットフォーム)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">4294967295</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (64 ビットプラットフォーム)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">18446744073709551615</code></td></tr></tbody></table></div><p>
            このオプションは、スレーブのすべてのリレーログの合計サイズ (バイト単位) の上限を設定します。値 0 は <span class="quote">「<span class="quote">制限なし</span>」</span>を表します。これは、ディスク領域が制限されているスレーブサーバーホストに役立ちます。制限に達した場合、SQL スレッドが追い付いて未使用のリレーログの一部を削除するまで、I/O スレッドはマスターサーバーからのバイナリログイベントの読み取りを停止します。この制限は絶対ではありません。SQL スレッドがリレーログを削除する前により多くのイベントを必要とする場合があります。その場合、SQL スレッドが一部のリレーログを削除できるようになるまで I/O スレッドは制限を超えます。そうしないとデッドロックになるためです。<code class="option">--relay-log-space-limit</code> を <code class="option">--max-relay-log-size</code> (または <code class="option">--max-relay-log-size</code> が 0 の場合は <code class="option">--max-binlog-size</code>) の値の 2 倍未満に設定しないでください。その場合、I/O スレッドが空き領域を待機する可能性があります。<code class="option">--relay-log-space-limit</code> を超えたけれども、SQL スレッドはパージするリレーログを持たず、I/O スレッドを満たすことができないためです。この場合、I/O スレッドは強制的に <code class="option">--relay-log-space-limit</code> を一時的に無視します。
          </p></li><li class="listitem"><p><a name="option_mysqld_replicate-do-db"></a>
            <a class="indexterm" name="idm139979051966192"></a> <a class="indexterm" name="idm139979051964032"></a> <code class="option">--replicate-do-db=<em class="replaceable"><code>db_name</code></em></code>
          </p><div class="informaltable"><table summary="Options for replicate-do-db" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--replicate-do-db=name</code></td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr></tbody></table></div><p>
            このオプションの影響は、ステートメントベースまたは行ベースのどちらのレプリケーションを使用中かによって異なります。
          </p><p><b>ステートメントベースのレプリケーション </b>
              デフォルトデータベース (つまり、<code class="literal">USE</code> で選択されたもの) が <em class="replaceable"><code>db_name</code></em> であるステートメントにレプリケーションを限定するように、スレーブ SQL スレッドに指示します。複数のデータベースを指定するには、このオプションを複数回 (データベースごとに 1 回) 使用します。ただし、このようにすると別のデータベースは選択される (またはデータベースが選択されない) けれども、<code class="literal">UPDATE <em class="replaceable"><code>some_db.some_table</code></em> SET foo='bar'</code> などのクロスデータベースステートメントを複製<span class="emphasis"><em>しません</em></span>。
            </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
              複数のデータベースを指定するには、このオプションの複数インスタンスを使用する<span class="emphasis"><em>必要があります</em></span>。データベース名にカンマを含めることができるため、カンマで区切られたリストを指定すると、リストは単一データベースの名前として扱われます。
            </p></div><p>
            ステートメントベースレプリケーションを使用するときに期待するとおりに機能しない例: スレーブが <code class="option">--replicate-do-db=sales</code> で起動され、マスターで次のステートメントを発行する場合、<code class="literal">UPDATE</code> ステートメントは複製され<span class="emphasis"><em>ません</em></span>。
          </p><pre class="programlisting">
USE prices;
UPDATE sales.january SET amount=amount+1000;
</pre><p>
            この<span class="quote">「<span class="quote">デフォルトデータベースだけをチェックする</span>」</span>動作の主な理由は、ステートメントだけから複製すべきかどうかを知るのが難しいためです (たとえば、複数のデータベースをまたがって動作する複数テーブル<code class="literal">DELETE</code> ステートメントまたは <code class="literal">UPDATE</code> ステートメントを使用する場合)。また、必要がない場合、すべてのデータベースではなくデフォルトデータベースだけをチェックする方が早いです。
          </p><p><b>行ベースのレプリケーション </b>
              データベース <em class="replaceable"><code>db_name</code></em> にレプリケーションを制限するように、スレーブ SQL スレッドに指示します。<em class="replaceable"><code>db_name</code></em> に属するテーブルだけが変更されます。現在のデータベースはこれに影響しません。スレーブが <code class="option">--replicate-do-db=sales</code> で起動され、行ベースレプリケーションが有効である場合、次のステートメントがマスターで実行されます。
            </p><pre class="programlisting">
USE prices;
UPDATE sales.february SET amount=amount+100;
</pre><p>
            スレーブ上の <code class="literal">sales</code> データベース内の <code class="literal">february</code> テーブルが <code class="literal">UPDATE</code> ステートメントに従って変更されます。これは <code class="literal">USE</code> ステートメントが発行されたかどうかに関係なく発生します。ただし、行ベースレプリケーションと <code class="option">--replicate-do-db=sales</code> の使用時に、次のステートメントをマスターで発行してもスレーブに影響はありません。
          </p><pre class="programlisting">
USE prices;
UPDATE prices.march SET amount=amount-25;
</pre><p>
            ステートメント <code class="literal">USE prices</code> が <code class="literal">USE sales</code> に変更された場合でも、<code class="literal">UPDATE</code> ステートメントの結果は複製されません。
          </p><p>
            <code class="option">--replicate-do-db</code> が行ベースレプリケーションとステートメントベースレプリケーションでどのように扱われるかについてもう 1 つ重要な違いは、複数のデータベースを参照するステートメントで発生します。スレーブが <code class="option">--replicate-do-db=db1</code> で起動され、次のステートメントがマスターで実行されるものとします。
          </p><pre class="programlisting">
USE db1;
UPDATE db1.table1 SET col1 = 10, db2.table2 SET col2 = 20;
</pre><p>
            ステートメントベースレプリケーションを使用する場合、両方のテーブルがスレーブで更新されます。しかし、行ベースレプリケーションを使用するときは、<code class="literal">table1</code> だけがスレーブで影響を受けます。<code class="literal">table2</code> は別のデータベース内にあるため、スレーブ上の <code class="literal">table2</code> は <code class="literal">UPDATE</code> によって変更されません。ここで、<code class="literal">USE db1</code> ステートメントの代わりに、<code class="literal">USE db4</code> ステートメントが使用されたものとします。
          </p><pre class="programlisting">
USE db4;
UPDATE db1.table1 SET col1 = 10, db2.table2 SET col2 = 20;
</pre><p>
            このケースで、ステートメントベースレプリケーションを使用するときは、<code class="literal">UPDATE</code> ステートメントの影響はスレーブではありません。しかし、行ベースレプリケーションを使用する場合は、<code class="literal">UPDATE</code> はスレーブ上の <code class="literal">table1</code> を変更しますが、<code class="literal">table2</code> は変更しません。つまり、<code class="option">--replicate-do-db</code> によって指定されたデータベース内のテーブルのみが変更され、デフォルトデータベースを選択してもこの動作に影響しません。
          </p><p>
            クロスデータベース更新を機能させる必要がある場合は、代わりに <code class="option">--replicate-wild-do-table=<em class="replaceable"><code>db_name</code></em>.%</code> を使用してください。<a class="xref" href="replication.html#replication-rules" title="17.2.3 サーバーがレプリケーションフィルタリングルールをどのように評価するか">セクション17.2.3「サーバーがレプリケーションフィルタリングルールをどのように評価するか」</a>を参照してください。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              このオプションは、<code class="option">--binlog-do-db</code> がバイナリロギングに影響するのと同じ方法でレプリケーションに影響し、<code class="option">--replicate-do-db</code> がレプリケーション動作にどのように影響するかに対してレプリケーション形式がどのように影響するかは、<code class="option">--binlog-do-db</code> 動作に対してロギング形式がどのように影響するかと同じです。
            </p><p>
              このオプションは、<code class="literal">BEGIN</code>、<code class="literal">COMMIT</code>、または <code class="literal">ROLLBACK</code> ステートメントに影響しません。
            </p></div></li><li class="listitem"><p><a name="option_mysqld_replicate-ignore-db"></a>
            <a class="indexterm" name="idm139979051896208"></a> <a class="indexterm" name="idm139979051894048"></a> <code class="option">--replicate-ignore-db=<em class="replaceable"><code>db_name</code></em></code>
          </p><div class="informaltable"><table summary="Options for replicate-ignore-db" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--replicate-ignore-db=name</code></td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr></tbody></table></div><p>
            <code class="option">--replicate-do-db</code> と同様に、このオプションの影響はステートメントベースまたは行ベースのどちらのレプリケーションが使用されるかによって異なります。
          </p><p><b>ステートメントベースのレプリケーション </b>
              デフォルトデータベース (つまり、<code class="literal">USE</code> で選択されたもの) が <em class="replaceable"><code>db_name</code></em> であるステートメントを複製しないようにスレーブ SQL スレッドに指示します。
            </p><p><b>行ベースのレプリケーション </b>
              データベース <em class="replaceable"><code>db_name</code></em> 内のテーブルを更新しないようにスレーブ SQL スレッドに指示します。デフォルトデータベースは影響しません。
            </p><p>
            ステートメントベースレプリケーションを使用する場合、次の例は予期したとおりに機能しません。スレーブが <code class="option">--replicate-ignore-db=sales</code> で起動され、次のステートメントをマスターで発行するものとします。
          </p><pre class="programlisting">
USE prices;
UPDATE sales.january SET amount=amount+1000;
</pre><p>
            このような場合 <code class="literal">UPDATE</code> ステートメントは複製され<span class="emphasis"><em>ます</em></span>。<code class="option">--replicate-ignore-db</code> が (<code class="literal">USE</code> ステートメントで指定された) デフォルトデータベースにのみ適用されるためです。<code class="literal">sales</code> データベースがステートメントで明示的に指定されたため、ステートメントはフィルタされませんでした。しかし、行ベースレプリケーションを使用するときは、<code class="literal">UPDATE</code> ステートメントの影響はスレーブに伝達<span class="emphasis"><em>されず</em></span>、<code class="literal">sales.january</code> テーブルのスレーブのコピーは変更されません。この例では、<code class="literal">sales</code> データベースのマスターのコピー内のテーブルに加えられた<span class="emphasis"><em>すべての</em></span>変更は、<code class="option">--replicate-ignore-db=sales</code> によってスレーブで無視されます。
          </p><p>
            無視するデータベースを複数指定するには、このオプションを複数回 (データベースごとに 1 回) 使用します。データベース名にカンマを含めることができるため、カンマで区切られたリストを指定すると、リストは単一データベースの名前として扱われます。
          </p><p>
            クロスデータベース更新を使用していて、これらの更新を複製したくない場合は、このオプションを使用しないでください。<a class="xref" href="replication.html#replication-rules" title="17.2.3 サーバーがレプリケーションフィルタリングルールをどのように評価するか">セクション17.2.3「サーバーがレプリケーションフィルタリングルールをどのように評価するか」</a>を参照してください。
          </p><p>
            クロスデータベース更新を機能させる必要がある場合、代わりに <code class="option">--replicate-wild-ignore-table=<em class="replaceable"><code>db_name</code></em>.%</code> を使用してください。<a class="xref" href="replication.html#replication-rules" title="17.2.3 サーバーがレプリケーションフィルタリングルールをどのように評価するか">セクション17.2.3「サーバーがレプリケーションフィルタリングルールをどのように評価するか」</a>を参照してください。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              このオプションは、<code class="option">--binlog-ignore-db</code> がバイナリロギングに影響するのと同じ方法でレプリケーションに影響し、<code class="option">--replicate-ignore-db</code> がレプリケーション動作にどのように影響するかに対してレプリケーション形式がどのように影響するかは、<code class="option">--binlog-ignore-db</code> 動作に対してロギング形式がどのように影響するかと同じです。
            </p><p>
              このオプションは、<code class="literal">BEGIN</code>、<code class="literal">COMMIT</code>、または <code class="literal">ROLLBACK</code> ステートメントに影響しません。
            </p></div></li><li class="listitem"><p><a name="option_mysqld_replicate-do-table"></a>
            <a class="indexterm" name="idm139979051849072"></a> <a class="indexterm" name="idm139979051846912"></a> <code class="option">--replicate-do-table=<em class="replaceable"><code>db_name.tbl_name</code></em></code>
          </p><div class="informaltable"><table summary="Options for replicate-do-table" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--replicate-do-table=name</code></td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr></tbody></table></div><p>
            レプリケーションを特定のテーブルに制限するようにスレーブ SQL スレッドに指示することで、レプリケーションフィルタを作成します。複数のテーブルを指定するには、このオプションを複数回 (テーブルごとに 1 回) 使用します。<code class="option">--replicate-do-db</code> とは対照的に、これはクロスデータベース更新とデフォルトデータベース更新の両方に機能します。<a class="xref" href="replication.html#replication-rules" title="17.2.3 サーバーがレプリケーションフィルタリングルールをどのように評価するか">セクション17.2.3「サーバーがレプリケーションフィルタリングルールをどのように評価するか」</a>を参照してください。
          </p><p>
            このオプションは、テーブルに適用されるステートメントにのみ影響します。ストアドルーチンなど、ほかのデータベースオブジェクトにのみ適用されるステートメントには影響しません。ストアドルーチンに作用するステートメントをフィルタするには、1 つまたは複数の <code class="option">--replicate-*-db</code> オプションを使用します。
          </p></li><li class="listitem"><p><a name="option_mysqld_replicate-ignore-table"></a>
            <a class="indexterm" name="idm139979051829136"></a> <a class="indexterm" name="idm139979051826896"></a> <code class="option">--replicate-ignore-table=<em class="replaceable"><code>db_name.tbl_name</code></em></code>
          </p><div class="informaltable"><table summary="Options for replicate-ignore-table" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--replicate-ignore-table=name</code></td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr></tbody></table></div><p>
            指定されたテーブルを更新するステートメントを複製しないように (ほかのテーブルが同じステートメントによって更新される可能性があったとしても) スレーブ SQL スレッドに指示することで、レプリケーションフィルタを作成します。無視するテーブルを複数指定するには、このオプションを複数回 (テーブルごとに 1 回) 使用します。<code class="option">--replicate-ignore-db</code> とは対照的に、これはクロスデータベース更新に機能します。<a class="xref" href="replication.html#replication-rules" title="17.2.3 サーバーがレプリケーションフィルタリングルールをどのように評価するか">セクション17.2.3「サーバーがレプリケーションフィルタリングルールをどのように評価するか」</a>を参照してください。
          </p><p>
            このオプションは、テーブルに適用されるステートメントにのみ影響します。ストアドルーチンなど、ほかのデータベースオブジェクトにのみ適用されるステートメントには影響しません。ストアドルーチンに作用するステートメントをフィルタするには、1 つまたは複数の <code class="option">--replicate-*-db</code> オプションを使用します。
          </p></li><li class="listitem"><p><a name="option_mysqld_replicate-rewrite-db"></a>
            <a class="indexterm" name="idm139979051809152"></a> <a class="indexterm" name="idm139979051806976"></a> <code class="option">--replicate-rewrite-db=<em class="replaceable"><code>from_name</code></em>-&gt;<em class="replaceable"><code>to_name</code></em></code>
          </p><div class="informaltable"><table summary="Options for replicate-rewrite-db" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--replicate-rewrite-db=old_name-&gt;new_name</code></td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr></tbody></table></div><p>
            デフォルトデータベース (つまり、<code class="literal">USE</code> で選択されたもの) を <em class="replaceable"><code>to_name</code></em> に変換するレプリケーションフィルタを作成するように (それがマスター上の <em class="replaceable"><code>from_name</code></em> であった場合)、スレーブに指示します。(<code class="literal">CREATE DATABASE</code>、<code class="literal">DROP DATABASE</code>、<code class="literal">ALTER DATABASE</code> などのステートメントではなく) テーブルに関係するステートメントだけが影響されます (<em class="replaceable"><code>from_name</code></em> がマスター上のデフォルトデータベースの場合のみ)。複数の書き換えを指定するには、複数回このオプションを使用します。サーバーは、一致する <em class="replaceable"><code>from_name</code></em> 値で最初のものを使用します。データベース名変換は、<code class="option">--replicate-*</code> ルールがテストされる<span class="emphasis"><em>前に</em></span>行われます。
          </p><p>
            このオプションを使用するときにテーブル名がデータベース名で修飾されるステートメントは、<code class="option">--replicate-do-table</code> などのテーブルレベルレプリケーションフィルタリングオプションで機能しません。名前が <code class="literal">a</code> のデータベースがマスター上にあり、名前が <code class="literal">b</code> のものがスレーブ上にあり、それぞれにテーブル <code class="literal">t</code> が含まれ、<code class="option">--replicate-rewrite-db='a-&gt;b'</code> でマスターを起動したものとします。あとで、<code class="literal">DELETE FROM a.t</code> を実行します。この場合、関連のあるフィルタリングルールは、次に示した理由で機能しません。
          </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                テーブル <code class="literal">t</code> がスレーブのデータベース <code class="literal">b</code> 内にあるため、<code class="option">--replicate-do-table=a.t</code> は機能しません。
              </p></li><li class="listitem"><p>
                <code class="option">--replicate-do-table=b.t</code> は、元のステートメントを照合しないため無視されます。
              </p></li><li class="listitem"><p>
                <code class="option">--replicate-do-table=*.t</code> も、<code class="option">--replicate-do-table=a.t</code> と同等に処理されるため機能しません。
              </p></li></ol></div><p>
            同様に、<code class="option">--replication-rewrite-db</code> オプションはクロスデータベース更新では機能しません。
          </p><p>
            このオプションをコマンド行で使用するときに、<span class="quote">「<span class="quote"><code class="literal">&gt;</code></span>」</span> がコマンドインタープリターに固有である場合は、オプション値を引用符で囲みます。例:
          </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>mysqld --replicate-rewrite-db="<em class="replaceable"><code>olddb</code></em>-&gt;<em class="replaceable"><code>newdb</code></em>"</code></strong>
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              MySQL 5.6.7 より前では、マルチスレッドスレーブはこのオプションを正しく処理しませんでした。(Bug #14232958)
            </p></div></li><li class="listitem"><p><a name="option_mysqld_replicate-same-server-id"></a>
            <a class="indexterm" name="idm139979051765360"></a> <a class="indexterm" name="idm139979051763120"></a> <code class="option">--replicate-same-server-id</code>
          </p><div class="informaltable"><table summary="Options for replicate-same-server-id" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--replicate-same-server-id</code></td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">FALSE</code></td></tr></tbody></table></div><p>
            スレーブサーバーで使用されるべきです。循環レプリケーションの原因となる無限ループを避けるため、通常はデフォルト設定の 0 を使用してください。1 に設定すると、スレーブはそれ自身のサーバー ID を持つイベントをスキップしません。通常は、これはまれな構成でのみ役立ちます。<code class="option">--log-slave-updates</code> が使用されている場合、1 に設定できません。デフォルトでは、バイナリログイベントのサーバー ID がスレーブのものである場合、スレーブ I/O スレッドはリレーログにそれらを書き込みません (この最適化はディスク使用量の節約に役立ちます)。<code class="option">--replicate-same-server-id</code> を使用する場合、このオプションでスレーブを確実に起動してから、スレーブ SQL スレッドで実行したいスレーブ独自のイベントをスレーブで読み取ってください。
          </p></li><li class="listitem"><p><a name="option_mysqld_replicate-wild-do-table"></a>
            <a class="indexterm" name="idm139979051744064"></a> <a class="indexterm" name="idm139979051741824"></a> <code class="option">--replicate-wild-do-table=<em class="replaceable"><code>db_name.tbl_name</code></em></code>
          </p><div class="informaltable"><table summary="Options for replicate-wild-do-table" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--replicate-wild-do-table=name</code></td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr></tbody></table></div><p>
            更新されるテーブルが指定されたデータベースおよびテーブル名パターンに一致するステートメントにレプリケーションを制限するようにスレーブスレッドに指示することで、レプリケーションフィルタを作成します。パターンには <span class="quote">「<span class="quote"><code class="literal">%</code></span>」</span> および <span class="quote">「<span class="quote"><code class="literal">_</code></span>」</span> ワイルドカード文字を含めることができます。これらは <code class="literal">LIKE</code> パターンマッチング演算子と同じ意味を持ちます。複数のテーブルを指定するには、このオプションを複数回 (テーブルごとに 1 回) 使用します。これはクロスデータベース更新に役立ちます。<a class="xref" href="replication.html#replication-rules" title="17.2.3 サーバーがレプリケーションフィルタリングルールをどのように評価するか">セクション17.2.3「サーバーがレプリケーションフィルタリングルールをどのように評価するか」</a>を参照してください。
          </p><p>
            このオプションはテーブル、ビュー、およびトリガーに適用されます。ストアドプロシージャーと関数、またはイベントには適用されません。後者のオブジェクトで作用するステートメントをフィルタするには、1 つまたは複数の <code class="option">--replicate-*-db</code> オプションを使用します。
          </p><p>
            例: <code class="option">--replicate-wild-do-table=foo%.bar%</code> は、データベース名が <code class="literal">foo</code> で始まり、テーブル名が <code class="literal">bar</code> で始まるテーブルを使用する更新のみを複製します。
          </p><p>
            テーブル名パターンが <code class="literal">%</code> の場合、それは任意のテーブル名に一致し、このオプションはデータベースレベルステートメント (<code class="literal">CREATE DATABASE</code>、<code class="literal">DROP DATABASE</code>、および <code class="literal">ALTER DATABASE</code>) にも適用されます。たとえば、<code class="option">--replicate-wild-do-table=foo%.%</code> を使用する場合に、データベース名がパターン <code class="literal">foo%</code> に一致する場合はデータベースレベルステートメントが複製されます。
          </p><p>
            リテラルワイルドカード文字をデータベースまたはテーブル名パターンに含めるには、バックスラッシュでそれらをエスケープします。たとえば、名前が <code class="literal">my_own%db</code> のデータベースのすべてのテーブルを複製するけれども、<code class="literal">my1ownAABCdb</code> データベースからのテーブルは複製しないときは、<span class="quote">「<span class="quote"><code class="literal">_</code></span>」</span> および <span class="quote">「<span class="quote"><code class="literal">%</code></span>」</span> 文字を <code class="option">--replicate-wild-do-table=my\_own\%db</code> のようにエスケープしてください。このオプションをコマンド行で使用する場合、コマンドインタープリターによっては、バックスラッシュを二重にしたりオプション値を引用符で囲んだりする必要があります。たとえば、<span class="command"><strong>bash</strong></span> シェルでは、<code class="option">--replicate-wild-do-table=my\\_own\\%db</code> と入力する必要があります。
          </p></li><li class="listitem"><p><a name="option_mysqld_replicate-wild-ignore-table"></a>
            <a class="indexterm" name="idm139979051705520"></a> <a class="indexterm" name="idm139979051703344"></a> <code class="option">--replicate-wild-ignore-table=<em class="replaceable"><code>db_name.tbl_name</code></em></code>
          </p><div class="informaltable"><table summary="Options for replicate-wild-ignore-table" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--replicate-wild-ignore-table=name</code></td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr></tbody></table></div><p>
            何らかのテーブルが指定されたワイルドカードパターンに一致するステートメントをスレーブスレッドが複製するのを抑止する、レプリケーションフィルタを作成します。無視するテーブルを複数指定するには、このオプションを複数回 (テーブルごとに 1 回) 使用します。これはクロスデータベース更新に役立ちます。<a class="xref" href="replication.html#replication-rules" title="17.2.3 サーバーがレプリケーションフィルタリングルールをどのように評価するか">セクション17.2.3「サーバーがレプリケーションフィルタリングルールをどのように評価するか」</a>を参照してください。
          </p><p>
            例: <code class="option">--replicate-wild-ignore-table=foo%.bar%</code> は、データベース名が <code class="literal">foo</code> で始まりテーブル名が <code class="literal">bar</code> で始まるテーブルを使用する更新を複製しません。
          </p><p>
            照合の仕組みについては、<code class="option">--replicate-wild-do-table</code> オプションの説明を参照してください。オプション値にリテラルワイルドカード文字を含めるためのルールは、<code class="option">--replicate-wild-ignore-table</code> 場合と同じです。
          </p></li><li class="listitem"><p><a name="option_mysqld_report-host"></a>
            <a class="indexterm" name="idm139979051682944"></a> <a class="indexterm" name="idm139979051680800"></a> <code class="option">--report-host=<em class="replaceable"><code>host_name</code></em></code>
          </p><div class="informaltable"><table summary="Options for report-host" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--report-host=host_name</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="server-administration.html#sysvar_report_host">report_host</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr></tbody></table></div><p>
            スレーブ登録中にマスターに報告されるスレーブのホスト名または IP アドレス。この値は、マスターサーバーでの <code class="literal">SHOW SLAVE HOSTS</code> の出力に出現します。マスターにスレーブ自身を登録しない場合は、値を設定しないままにします。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              スレーブ接続後にマスターが TCP/IP ソケットからスレーブの IP アドレスを読み取るだけでは十分ではありません。NAT およびその他のルーティングの問題により、その IP はマスターまたはほかのホストからスレーブへの接続に有効でない可能性があります。
            </p></div></li><li class="listitem"><p><a name="option_mysqld_report-password"></a>
            <a class="indexterm" name="idm139979051656352"></a> <a class="indexterm" name="idm139979051654192"></a> <code class="option">--report-password=<em class="replaceable"><code>password</code></em></code>
          </p><div class="informaltable"><table summary="Options for report-password" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--report-password=name</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="server-administration.html#sysvar_report_password">report_password</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr></tbody></table></div><p>
            スレーブ登録中にマスターに報告されるスレーブのアカウントパスワード。この値は、<code class="option">--show-slave-auth-info</code> オプションが指定された場合にマスターサーバーでの <code class="literal">SHOW SLAVE HOSTS</code> の出力に出現します。
          </p><p>
            このオプションの名前は別の方法で暗示されることもありますが、<code class="option">--report-password</code> は MySQL ユーザー権限システムに接続されないため、MySQL レプリケーションユーザーアカウントのパスワードとは必ずしも同じとはかぎりません （または同じである可能性は高くありません）。
          </p></li><li class="listitem"><p><a name="option_mysqld_report-port"></a>
            <a class="indexterm" name="idm139979051628992"></a> <a class="indexterm" name="idm139979051626848"></a> <a class="indexterm" name="idm139979051624880"></a> <a class="indexterm" name="idm139979051623536"></a> <code class="option">--report-port=<em class="replaceable"><code>slave_port_num</code></em></code>
          </p><div class="informaltable"><table summary="Options for report-port" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--report-port=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="server-administration.html#sysvar_report_port">report_port</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (&lt;= 5.6.4)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">65535</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (&gt;= 5.6.5)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">[slave_port]</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">65535</code></td></tr></tbody></table></div><p>
            スレーブに接続するための TCP/IP ポート番号で、スレーブ登録中にマスターに報告されます。スレーブが非デフォルトポートで待機している場合、またはマスターまたはほかのクライアントからスレーブへの特別なトンネルがある場合にのみ、これを設定します。確実でない場合は、このオプションを使用しないでください。
          </p><p>
            MySQL 5.6.5 より前は、このオプションのデフォルト値は 3306 でした。MySQL 5.6.5 以降では、表示される値はスレーブで実際に使用されるポート番号です (Bug #13333431)。この変更は <code class="literal">SHOW SLAVE HOSTS</code> によって表示されるデフォルト値にも影響します。
          </p></li><li class="listitem"><p><a name="option_mysqld_report-user"></a>
            <a class="indexterm" name="idm139979051583072"></a> <a class="indexterm" name="idm139979051580928"></a> <code class="option">--report-user=<em class="replaceable"><code>user_name</code></em></code>
          </p><div class="informaltable"><table summary="Options for report-user" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--report-user=name</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="server-administration.html#sysvar_report_user">report_user</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr></tbody></table></div><p>
            スレーブ登録中にマスターに報告されるスレーブのアカウントユーザー名。この値は、<code class="option">--show-slave-auth-info</code> オプションが指定された場合にマスターサーバーでの <code class="literal">SHOW SLAVE HOSTS</code> の出力に出現します。
          </p><p>
            このオプションの名前は別の方法で暗示されることもありますが、<code class="option">--report-user</code> は MySQL ユーザー権限システムに接続されないため、MySQL レプリケーションユーザーアカウントの名前とは必ずしも同じとはかぎりません （または同じである可能性は高くありません）。
          </p></li><li class="listitem"><p><a name="option_mysqld_show-slave-auth-info"></a>
            <a class="indexterm" name="idm139979051555776"></a> <a class="indexterm" name="idm139979051553536"></a> <code class="option">--show-slave-auth-info</code>
          </p><div class="informaltable"><table summary="Options for show-slave-auth-info" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--show-slave-auth-info</code></td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">FALSE</code></td></tr></tbody></table></div><p>
            <code class="option">--report-user</code> および <code class="option">--report-password</code> オプションで起動されたスレーブのマスターサーバーでの、<code class="literal">SHOW SLAVE HOSTS</code> の出力にスレーブユーザー名とパスワードを表示します。
          </p></li><li class="listitem"><p><a name="option_mysqld_slave-checkpoint-group"></a>
            <a class="indexterm" name="idm139979051534912"></a> <a class="indexterm" name="idm139979051532672"></a> <code class="option">--slave-checkpoint-group=<em class="replaceable"><code>#</code></em></code>
          </p><div class="informaltable"><table summary="Options for slave-checkpoint-group" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.3</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--slave-checkpoint-group=#</code></td></tr><tr><td scope="row" rowspan="5"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">512</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">32</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">524280</code></td></tr><tr><td scope="row"><span class="bold"><strong>ブロックサイズ</strong></span></td><td colspan="2"><code class="literal">8</code></td></tr></tbody></table></div><p>
            <code class="literal">SHOW SLAVE STATUS</code> によって表示されるマルチスレッドスレーブステータスを更新するためにチェックポイント操作が呼び出される前に、スレーブが処理できる最大トランザクション数を設定します。このオプションを設定しても、マルチスレッドが有効でないスレーブには影響しません。
          </p><p>
            このオプションは、<code class="option">--slave-checkpoint-period</code> オプションとの組み合わせで、どちらかの制限を超えたときに、チェックポイントが実行され、トランザクションの数と最後のチェックポイントから経過した時間の両方を追跡するカウンタがリセットされる、という方法で機能します。
          </p><p>
            このオプションの最小許容値は 32 です (サーバーが <code class="option">-DWITH_DEBUG</code> を使用して構築された場合を除く、その場合の最小値は 1)。効果的な値は常に 8 の倍数です。そのような倍数でない値に設定することもできますが、サーバーは値を格納する前に次に小さい 8 の倍数に丸めます。(<span class="emphasis"><em>例外</em></span>: このような丸めはデバッグサーバーでは実行されません。)サーバーの構築方法にかかわらず、デフォルト値は 512 であり、最大許容値は 524280 です。
          </p><p>
            <code class="option">--slave-checkpoint-group</code> は MySQL 5.6.3 で追加されました。
          </p></li><li class="listitem"><p><a name="option_mysqld_slave-checkpoint-period"></a>
            <a class="indexterm" name="idm139979051500720"></a> <a class="indexterm" name="idm139979051498480"></a> <code class="option">--slave-checkpoint-period=<em class="replaceable"><code>#</code></em></code>
          </p><div class="informaltable"><table summary="Options for slave-checkpoint-period" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.3</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--slave-checkpoint-period=#</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">300</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">4G</code></td></tr></tbody></table></div><p>
            <code class="literal">SHOW SLAVE STATUS</code> によって表示されるマルチスレッドのスレーブステータスを更新するためにチェックポイント操作が呼び出される前に、経過できる最大時間 （ミリ秒単位） を設定します。このオプションを設定しても、マルチスレッドが有効でないスレーブには影響しません。
          </p><p>
            このオプションは、<code class="option">--slave-checkpoint-group</code> オプションとの組み合わせで、どちらかの制限を超えたときに、チェックポイントが実行され、トランザクションの数と最後のチェックポイントから経過した時間の両方を追跡するカウンタがリセットされる、という方法で機能します。
          </p><p>
            このオプションの最小許容値は 1 です (サーバーが <code class="option">-DWITH_DEBUG</code> を使用して構築された場合を除く、その場合の最小値は 0)。サーバーの構築方法にかかわらず、デフォルト値は 300 であり、最大可能値は 4294967296 (4G バイト) です。
          </p><p>
            <code class="option">--slave-checkpoint-period</code> は MySQL 5.6.3 で追加されました。
          </p></li><li class="listitem"><p><a name="option_mysqld_slave-parallel-workers"></a>
            <a class="indexterm" name="idm139979051469696"></a> <a class="indexterm" name="idm139979051467456"></a> <code class="option">--slave-parallel-workers</code>
          </p><div class="informaltable"><table summary="Options for slave-parallel-workers" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.3</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--slave-parallel-workers=#</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">1024</code></td></tr></tbody></table></div><p>
            レプリケーションイベント （トランザクション） を並列に実行するためのスレーブワーカースレッドの数を設定します。この変数を 0 (デフォルト) に設定すると、並列実行が無効になります。最大値は 1024 です。
          </p><p>
            並列実行が有効のときは、スレーブ SQL スレッドはスレーブワーカースレッドのコーディネーターとして機能し、トランザクションはそれらにデータベースごとに分散されます。これは、スレーブ上のワーカースレッドは、ほかのデータベースへの更新が完了するのを待たずに、所定のデータベースに基づいてトランザクションを次々に処理できることを意味します。スレーブでのマルチスレッドの現在の実装は、データがデータベースごとに分割されていて、所定のデータベース内の更新が正しく機能するようにマスターの場合と同様に相対順序で行われることを前提としています。ただし、2 つのデータベース間でトランザクションを調整する必要はありません。
          </p><p>
            異なるデータベースでのトランザクションは、スレーブではマスターとは異なる順序が実行されることがあるという事実のため、最後に実行されたトランザクションをチェックしても、マスターからの以前のすべてのトランザクションがスレーブ上で実行されたことが保証されません。これは、マルチスレッド化したスレーブを使用する場合にロギングとリカバリに影響します。スレーブ上でマルチスレッドを使用したときにバイナリロギング情報をどのように解釈すればよいかについては、<a class="xref" href="sql-syntax.html#show-slave-status" title="13.7.5.35 SHOW SLAVE STATUS 構文">セクション13.7.5.35「SHOW SLAVE STATUS 構文」</a>を参照してください。また、<code class="literal">START SLAVE UNTIL</code> がマルチスレッドスレーブでサポートされないことを意味します。
          </p><p>
            マルチスレッドが有効のときは、<code class="literal">slave_transaction_retries</code> は 0 に等しいとして処理され、変更できません。(現在のところ、トランザクションの再試行はマルチスレッドスレーブではサポートされません。)
          </p><p>
            MySQL 5.6.7 以降では、異なるデータベース内のテーブル間に外部キー関係を適用すると、マルチスレッドスレーブが並列モードではなくシーケンシャルを使用することになり、これがパフォーマンスに悪影響を与える可能性があることも認識するようにしてください。(Bug #14092635)
          </p><p>
            このオプションは MySQL 5.6.3 で追加されました。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              このオプション (または対応する <code class="literal">slave_parallel_workers</code> システム変数) に設定される値は、MySQL 5.6.3 で正しく処理されるとはかぎりません。この問題は MySQL 5.6.4 で修正されました (Bug #13334470)。
            </p></div></li><li class="listitem"><p><a name="option_mysqld_slave-pending-jobs-size-max"></a>
            <a class="indexterm" name="idm139979051432576"></a> <a class="indexterm" name="idm139979051430400"></a> <code class="option">--slave-pending-jobs-size-max=<em class="replaceable"><code>#</code></em></code>
          </p><div class="informaltable"><table summary="Options for slave-pending-jobs-size-max" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.3</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--slave-pending-jobs-size-max=#</code></td></tr><tr><td scope="row" rowspan="5"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">16M</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1024</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">18EB</code></td></tr><tr><td scope="row"><span class="bold"><strong>ブロックサイズ</strong></span></td><td colspan="2"><code class="literal">1024</code></td></tr></tbody></table></div><p>
            マルチスレッドスレーブの場合、このオプションは、まだ適用されていないイベントを保持するスレーブワーカーキューに使用可能な最大メモリー量 (バイト単位) を設定します。このオプションを設定しても、マルチスレッドが有効でないスレーブには影響しません。
          </p><p>
            このオプションの可能な最小値は 1024 で、デフォルトは 16M バイトです。可能な最大値は 18446744073709551615 (16E バイト) です。1024 の正確な倍数でない値は、保存される前に次に大きい 1024 の倍数に丸められます。
          </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
              このオプションの値はマスターの <code class="literal">max_allowed_packet</code> の値以上である必要があります。そうでない場合は、マスターから到着する処理すべきイベントが残っているときにスレーブワーカーキューがいっぱいになる場合があります。
            </p></div><p>
            このオプションは MySQL 5.6.3 で追加されました。
          </p></li><li class="listitem"><p><a name="option_mysqld_skip-slave-start"></a>
            <a class="indexterm" name="idm139979051401040"></a> <a class="indexterm" name="idm139979051398880"></a> <code class="option">--skip-slave-start</code>
          </p><div class="informaltable"><table summary="Options for skip-slave-start" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--skip-slave-start</code></td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">FALSE</code></td></tr></tbody></table></div><p>
            サーバーの起動時にスレーブスレッドを起動しないように、スレーブサーバーに指示します。スレッドをあとで起動するには、<code class="literal">START SLAVE</code> ステートメントを使用します。
          </p></li><li class="listitem"><p><a name="option_mysqld_slave_compressed_protocol"></a>
            <a class="indexterm" name="idm139979051381456"></a> <a class="indexterm" name="idm139979051379216"></a> <code class="option">--slave_compressed_protocol={0|1}</code>
          </p><div class="informaltable"><table summary="Options for slave_compressed_protocol" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--slave_compressed_protocol</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_slave_compressed_protocol">slave_compressed_protocol</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr></tbody></table></div><p>
            このオプションが 1 に設定されている場合は、スレーブとマスターの両方がサポートしている場合は、マスター/スレーブプロトコルに圧縮を使用します。デフォルトは 0 (圧縮なし) です。
          </p></li><li class="listitem"><p><a name="option_mysqld_slave-load-tmpdir"></a>
            <a class="indexterm" name="idm139979051355280"></a> <a class="indexterm" name="idm139979051353120"></a> <code class="option">--slave-load-tmpdir=<em class="replaceable"><code>file_name</code></em></code>
          </p><div class="informaltable"><table summary="Options for slave-load-tmpdir" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--slave-load-tmpdir=path</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_slave_load_tmpdir">slave_load_tmpdir</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ディレクトリ名</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">/tmp</code></td></tr></tbody></table></div><p>
            スレーブが一時ファイルを作成するディレクトリの名前。このオプションはデフォルトでは、<code class="literal">tmpdir</code> システム変数の値と同じです。スレーブ SQL スレッドは、<code class="literal">LOAD DATA INFILE</code> ステートメントを複製するときに、リレーログからロードされるファイルを一時ファイルに抽出してから、それらをテーブルにロードします。マスターでロードされるファイルが非常に大きい場合は、スレーブの一時ファイルも非常に大きくなります。このため、このオプションを使用して、利用可能な多くの空き領域を持つファイルシステム内にあるディレクトリに一時ファイルを置くように、スレーブに指示することをお勧めします。この場合、リレーログも非常に大きいため、<code class="option">--relay-log</code> オプションを使用してそのファイルシステムにリレーログも置くことをお勧めします。
          </p><p>
            このオプションで指定するディレクトリは (メモリーベースファイルシステムではなく) ディスクベースファイルシステムに配置してください。<code class="literal">LOAD DATA INFILE</code> の複製に使用される一時ファイルがマシン再起動後も存続する必要があるためです。このディレクトリは、システム起動プロセス中にオペレーティングシステムによってクリアされるものではいけません。
          </p></li><li class="listitem"><p><a name="option_mysqld_slave-max-allowed-packet"></a>
            <a class="indexterm" name="idm139979051321808"></a> <a class="indexterm" name="idm139979051320480"></a> <code class="option">slave-max-allowed-packet=<em class="replaceable"><code>bytes</code></em></code>
          </p><div class="informaltable"><table summary="Options for slave-max-allowed-packet" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.6</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--slave-max-allowed-packet=#</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">1073741824</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1024</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">1073741824</code></td></tr></tbody></table></div><p>
            MySQL 5.6.6 以降では、このオプションがスレーブ SQL スレッドおよび I/O スレッドの最大パケットサイズ （バイト単位） を設定するので、行ベースレプリケーションを使用する大きな更新が <code class="literal">max_allowed_packet</code> を超えていることが原因でレプリケーションが失敗することはありません。(Bug #12400221、Bug #60926)
          </p><p>
            対応するサーバー変数 <code class="literal">slave_max_allowed_packet</code> は常に、1024 の正の整数の倍数である値を持ちます。このような倍数でない値に設定しても、値は次に大きい 1024 の倍数に自動的に丸められます。(たとえば、<code class="option">--slave-max-allowed-packet=10000</code> でサーバーを起動する場合、使用される値は 9216 です。値として 0 に設定すると、1024 が使用されます。)このような場合、切り捨ての警告が発行されます。
          </p><p>
            最大 (およびデフォルト) 値は 1073741824 (1G バイト) で、最小は 1024 です。
          </p></li><li class="listitem"><p><a name="option_mysqld_slave-net-timeout"></a>
            <a class="indexterm" name="idm139979051292592"></a> <a class="indexterm" name="idm139979051290432"></a> <code class="option">--slave-net-timeout=<em class="replaceable"><code>seconds</code></em></code>
          </p><div class="informaltable"><table summary="Options for slave-net-timeout" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--slave-net-timeout=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_slave_net_timeout">slave_net_timeout</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">3600</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr></tbody></table></div><p>
            マスターからの後続のデータを待機する秒数 (これ以降は、スレーブは接続が切断されていると見なし、読み取りを中止し、再接続を試行)。最初の再試行はタイムアウトの直後に発生します。再試行の間隔は <code class="literal">CHANGE MASTER TO</code> ステートメントの <code class="literal">MASTER_CONNECT_RETRY</code> オプションで制御され、再接続の試行回数は <code class="option">--master-retry-count</code> オプションによって制限されます。デフォルトは 3600 秒 (1 時間) です。
          </p></li><li class="listitem"><p><a name="option_mysqld_slave-rows-search-algorithms"></a>
            <a class="indexterm" name="idm139979051261072"></a> <a class="indexterm" name="idm139979051259744"></a> <code class="option">slave-rows-search-algorithms=<em class="replaceable"><code>list</code></em></code>
          </p><div class="informaltable"><table summary="Options for slave-rows-search-algorithms" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.6</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--slave-rows-search-algorithms=list</code></td></tr><tr><td scope="row" rowspan="6"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">セット</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">TABLE_SCAN,INDEX_SCAN</code></td></tr><tr><td scope="row" rowspan="4" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">TABLE_SCAN,INDEX_SCAN</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">INDEX_SCAN,HASH_SCAN</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">TABLE_SCAN,HASH_SCAN</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">TABLE_SCAN,INDEX_SCAN,HASH_SCAN</code> (INDEX_SCAN,HASH_SCAN と同等)</td></tr></tbody></table></div><p>
            <code class="literal">slave_allow_batching</code> を使用して行ベースロギングとレプリケーションのために大量の行を準備するときに、このオプションは行の一致がどのように検索されるか、つまり、主キー、一意キー、または何らかのほかのキーを使用する検索、またはキーをまったく使用しない検索にハッシュを使用するかどうかを制御します。このオプションは、リスト <code class="literal">INDEX_SCAN</code>、<code class="literal">TABLE_SCAN</code>、<code class="literal">HASH_SCAN</code> から 2 つの値 （または 3 つも可） のカンマ区切りリストを取ります。リストを引用符で囲む必要はありませんが、引用符を使用するかどうかにかかわらず、リストに空白文字を含めてはいけません。可能な組み合わせ (リスト) とその結果を次の表に示します。
          </p><div class="informaltable"><table summary="この表は、slave_allow_batching オプションに指定される値に基づいて、行の一致がどのように検索されるかを示します。" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th scope="col">使用されるインデックス/オプション値</th><th scope="col"><code class="literal">INDEX_SCAN,HASH_SCAN</code> または <code class="literal">INDEX_SCAN,TABLE_SCAN,HASH_SCAN</code></th><th scope="col"><code class="literal">INDEX_SCAN,TABLE_SCAN</code></th><th scope="col"><code class="literal">TABLE_SCAN,HASH_SCAN</code></th></tr></thead><tbody><tr><td scope="row"><span class="emphasis"><em>主キーまたは一意キー</em></span></td><td>インデックススキャン</td><td>インデックススキャン</td><td>インデックスに基づくハッシュスキャン</td></tr><tr><td scope="row"><span class="emphasis"><em>(ほかの) キー</em></span></td><td>インデックスに基づくハッシュスキャン</td><td>インデックススキャン</td><td>インデックスに基づくハッシュスキャン</td></tr><tr><td scope="row"><span class="emphasis"><em>インデックスなし</em></span></td><td>ハッシュスキャン</td><td>テーブルスキャン</td><td>ハッシュスキャン</td></tr></tbody></table></div><p>
            リスト内でアルゴリズムが指定される順序は、<code class="literal">SELECT</code> または <code class="literal">SHOW VARIABLES</code> ステートメントで表示される順序と違いはありません (直前に示した表で使用されるものと同じ)。デフォルト値は <code class="literal">TABLE_SCAN,INDEX_SCAN</code> で、これはインデックスを使用できるすべての検索はそれらを使用し、インデックスなしの検索はテーブルスキャンを使用することを意味します。
          </p><p>
            <code class="literal">INDEX_SCAN,TABLE_SCAN,HASH_SCAN</code> を指定することは、<code class="literal">INDEX_SCAN,HASH_SCAN</code> を指定する場合と同じ結果になります。主キーまたは一意キーを使用しない検索にハッシュを使用するには、このオプションを <code class="literal">INDEX_SCAN,HASH_SCAN</code> に設定します。<span class="emphasis"><em>すべての</em></span>検索にハッシュを強制的に使用するには、<code class="literal">TABLE_SCAN,HASH_SCAN</code> に設定します。
          </p><p>
            このオプションは MySQL 5.6.6 で追加されました。
          </p></li><li class="listitem"><p><a name="option_mysqld_slave-skip-errors"></a>
            <a class="indexterm" name="idm139979051204704"></a> <a class="indexterm" name="idm139979051202544"></a> <code class="option">--slave-skip-errors=[<em class="replaceable"><code>err_code1</code></em>,<em class="replaceable"><code>err_code2</code></em>,...|all|ddl_exist_errors]</code>
          </p><div class="informaltable"><table summary="Options for slave-skip-errors" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--slave-skip-errors=name</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_slave_skip_errors">slave_skip_errors</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="5"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr><tr><td scope="row" rowspan="3" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">[list of error codes]</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">all</code></td></tr><tr><td scope="row" rowspan="6"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr><tr><td scope="row" rowspan="4" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">[list of error codes]</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">all</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">ddl_exist_errors</code></td></tr><tr><td scope="row" rowspan="6"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr><tr><td scope="row" rowspan="4" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">[list of error codes]</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">all</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">ddl_exist_errors</code></td></tr></tbody></table></div><p>
            レプリケーションは通常、スレーブでエラーが発生したときに停止します。これは、データ内の不一致を手動で解決する機会です。このオプションは、ステートメントがオプション値にリストされたエラーを返すときに、レプリケーションを継続するようにスレーブ SQL スレッドに指示します。
          </p><p>
            このオプションは、エラーが発生している理由を完全に理解しないかぎり使用しないでください。レプリケーションセットアップとクライアントプログラムにバグがなく、MySQL 自体にバグがない場合は、レプリケーションを停止するエラーは発生しないはずです。このオプションを無計画に使用すると、スレーブとマスターの同期が絶望的に取れなくなり、これがなぜ発生したかの見当がつかなくなります。
          </p><p>
            エラーコードについては、スレーブエラーログおよび <code class="literal">SHOW SLAVE STATUS</code> の出力のエラーメッセージによって提供される数値を使用してください。<a class="xref" href="error-handling.html" title="付録 B エラー、エラーコード、および一般的な問題">付録B <i>エラー、エラーコード、および一般的な問題</i></a> にはサーバーエラーコードがリストされています。
          </p><p>
            非推奨値 <code class="literal">all</code> を使用して、スレーブにすべてのエラーメッセージを無視させて、何が発生しても継続させることもできます （ただし、使用すべきではありません）。言うまでもなく、<code class="literal">all</code> を使用した場合、データの完全性に関して保証はありません。スレーブのデータがマスター上のものとかなり違っていても不満を言わないで下さい （バグレポートを出さないでください）。<span class="emphasis"><em>以上のことを警告しました</em></span>。
          </p><p>
            MySQL 5.6 と MySQL Cluster NDB 7.3 以降では、追加の簡略版 <code class="literal">ddl_exist_errors</code> がサポートされ、これはエラーコードリスト <code class="literal">1007,1008,1050,1051,1054,1060,1061,1068,1094,1146</code> に相当します。
          </p><p>
            例:
          </p><pre class="programlisting">
--slave-skip-errors=1062,1053
--slave-skip-errors=all
--slave-skip-errors=ddl_exist_errors
</pre></li><li class="listitem"><p><a name="option_mysqld_slave-sql-verify-checksum"></a>
            <a class="indexterm" name="idm139979051136848"></a> <a class="indexterm" name="idm139979051134608"></a> <code class="option">--slave-sql-verify-checksum={0|1}</code>
          </p><div class="informaltable"><table summary="Options for slave-sql-verify-checksum" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.2</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--slave-sql-verify-checksum=value</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row" rowspan="2" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">1</code></td></tr></tbody></table></div><p>
            このオプションが有効のときは、スレーブはリレーログから読み取られたチェックサムを調べて、不一致があった場合にスレーブはエラーで停止します。デフォルトで無効になっています。
          </p><p>
            このオプションは MySQL 5.6.2 で追加されました。
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="replication-options-slave-log-tables"></a>スレーブステータスログをテーブルに記録するためのオプション</h5></div></div></div><p>
        MySQL 5.6 以降では、レプリケーションスレーブステータス情報をファイルではなくテーブルに記録できます。マスター情報ログおよびリレーログ情報ログの書き込みは、ここで示す、MySQL 5.6.2 で追加された 2 つのサーバーオプションを使用して個別に構成できます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="option_mysqld_master-info-repository"></a>
            <a class="indexterm" name="idm139979051108896"></a> <a class="indexterm" name="idm139979051106656"></a> <code class="option">--master-info-repository={FILE|TABLE}</code>
          </p><div class="informaltable"><table summary="Options for master-info-repository" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.2</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--master-info-repository=FILE|TABLE</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">FILE</code></td></tr><tr><td scope="row" rowspan="2" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">FILE</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">TABLE</code></td></tr></tbody></table></div><p>
            このオプションにより、サーバーはそのマスター情報ログをファイルまたはテーブルに書き込みます。ファイル名はデフォルトで <code class="filename">master.info</code> になります。ファイルの名前は <code class="option">--master-info-file</code> サーバーオプションを使用して変更できます。
          </p><p>
            このオプションのデフォルト値は <code class="literal">FILE</code> です。<code class="literal">TABLE</code> を使用する場合、ログは <code class="literal">mysql</code> データベースの <code class="literal">slave_master_info</code> テーブルに書き込まれます。
          </p><p>
            <code class="option">--master-info-repository</code> オプションは MySQL 5.6.2 で追加されました。
          </p></li><li class="listitem"><p><a name="option_mysqld_relay-log-info-repository"></a>
            <a class="indexterm" name="idm139979051078240"></a> <a class="indexterm" name="idm139979051076000"></a> <a class="indexterm" name="idm139979051073984"></a> <code class="option">--relay-log-info-repository={FILE|TABLE}</code>
          </p><div class="informaltable"><table summary="Options for relay-log-info-repository" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.2</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--relay-log-info-repository=FILE|TABLE</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">FILE</code></td></tr><tr><td scope="row" rowspan="2" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">FILE</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">TABLE</code></td></tr></tbody></table></div><p>
            このオプションにより、サーバーはそのリレーログ情報のログをファイルまたはテーブルに記録します。ファイル名はデフォルトで <code class="filename">relay-log.info</code> になります。ファイルの名前は <code class="option">--relay-log-info-file</code> サーバーオプションを使用して変更できます。
          </p><p>
            このオプションのデフォルト値は <code class="literal">FILE</code> です。<code class="literal">TABLE</code> を使用する場合、ログは <code class="literal">mysql</code> データベースの <code class="literal">slave_relay_log_info</code> テーブルに書き込まれます。
          </p><p>
            レプリケーションをクラッシュセーフにするために、このオプションは <code class="literal">TABLE</code> に設定する必要があります。さらに、<code class="option">--relay-log-recovery</code> オプションを有効にする必要があります。詳細は、<a class="xref" href="replication.html#replication-implementation-crash-safe" title="クラッシュセーフレプリケーション">クラッシュセーフレプリケーション</a>を参照してください。
          </p><p>
            <code class="option">--relay-log-info-repository</code> オプションは MySQL 5.6.2 で追加されました。
          </p></li></ul></div><p>
        情報ログテーブルとその内容は、所定の MySQL Server にローカルと見なされます。MySQL 5.6.9 以降では、それらは複製されず、それらへの変更はバイナリログに書き込まれません。(Bug #14741537)
      </p><p>
        詳細については、<a class="xref" href="replication.html#slave-logs" title="17.2.2 レプリケーションリレーおよびステータスログ">セクション17.2.2「レプリケーションリレーおよびステータスログ」</a>を参照してください。
      </p></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="replication-optvars-slaves-obsolete"></a>廃止されたレプリケーションスレーブオプション</h5></div></div></div><p>
        <span class="emphasis"><em>次のオプションは MySQL 5.5 で削除されました。MySQL 5.6 でこれらのオプションを使用して <span class="command"><strong>mysqld</strong></span> を起動しようとすると、サーバーは次で停止します: <span class="errortext">不明な変数</span>エラー</em></span>.これらのオプションにすでに関連付けられているレプリケーションパラメータを設定するには、<code class="literal">CHANGE MASTER TO ...</code> ステートメントを使用する必要があります (<a class="xref" href="sql-syntax.html#change-master-to" title="13.4.2.1 CHANGE MASTER TO 構文">セクション13.4.2.1「CHANGE MASTER TO 構文」</a>を参照してください)。
      </p><p>
        影響するオプションをこのリストに示します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="option_mysqld_master-host"></a>
            <code class="option">--master-host</code>
          </p></li><li class="listitem"><p><a name="option_mysqld_master-user"></a>
            <code class="option">--master-user</code>
          </p></li><li class="listitem"><p><a name="option_mysqld_master-password"></a>
            <code class="option">--master-password</code>
          </p></li><li class="listitem"><p><a name="option_mysqld_master-port"></a>
            <code class="option">--master-port</code>
          </p></li><li class="listitem"><p><a name="option_mysqld_master-connect-retry"></a>
            <code class="option">--master-connect-retry</code>
          </p></li><li class="listitem"><p><a name="option_mysqld_master-ssl"></a>
            <code class="option">--master-ssl</code>
          </p></li><li class="listitem"><p><a name="option_mysqld_master-ssl-ca"></a>
            <code class="option">--master-ssl-ca</code>
          </p></li><li class="listitem"><p><a name="option_mysqld_master-ssl-capath"></a>
            <code class="option">--master-ssl-capath</code>
          </p></li><li class="listitem"><p><a name="option_mysqld_master-ssl-cert"></a>
            <code class="option">--master-ssl-cert</code>
          </p></li><li class="listitem"><p><a name="option_mysqld_master-ssl-cipher"></a>
            <code class="option">--master-ssl-cipher</code>
          </p></li><li class="listitem"><p><a name="option_mysqld_master-ssl-key"></a>
            <code class="option">--master-ssl-key</code>
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="replication-sysvars-slaves"></a>レプリケーションスレーブで使用されるシステム変数</h5></div></div></div><p>
        次の一覧で、レプリケーションスレーブサーバーを制御するためのシステム変数について説明します。これらはサーバー起動時に設定でき、それらの一部は <code class="literal">SET</code> を使用して実行時に変更できます。レプリケーションスレーブで使用されるサーバーオプションは、このセクションですでにリストされています。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="sysvar_init_slave"></a>
            <a class="indexterm" name="idm139979051012208"></a> <a class="indexterm" name="idm139979051010768"></a> <code class="literal">init_slave</code>
          </p><div class="informaltable"><table summary="Options for init_slave" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--init-slave=name</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_init_slave">init_slave</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr></tbody></table></div><p>
            この変数は <code class="literal">init_connect</code> に似ていますが、SQL スレッドが起動するたびにスレーブサーバーによって実行される文字列です。文字列の形式は <code class="literal">init_connect</code> 変数の場合と同じです。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              SQL スレッドは、クライアントに確認応答を送信してから <code class="literal">init_slave</code> を実行します。このため、<code class="literal">START SLAVE</code> が戻されるときに <code class="literal">init_slave</code> が実行されていることは保証されません。詳細については、<a class="xref" href="sql-syntax.html#start-slave" title="13.4.2.5 START SLAVE 構文">セクション13.4.2.5「START SLAVE 構文」</a>を参照してください。
            </p></div></li><li class="listitem"><p><a name="sysvar_log_slow_slave_statements"></a>
            <a class="indexterm" name="idm139979050982032"></a> <a class="indexterm" name="idm139979050979920"></a> <code class="literal">log_slow_slave_statements</code>
          </p><div class="informaltable"><table summary="Options for log_slow_slave_statements" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.11</td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_log_slow_slave_statements">log_slow_slave_statements</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr></tbody></table></div><p>
            スロークエリーログが有効のときは、この変数はスレーブで実行するために <code class="literal">long_query_time</code> 秒を超える時間がかかったクエリーのロギングを有効にします。この変数は MySQL 5.6.11 で追加されました。
          </p></li><li class="listitem"><p><a name="sysvar_master_info_repository"></a>
            <a class="indexterm" name="idm139979050954976"></a> <a class="indexterm" name="idm139979050953424"></a> <code class="literal">master_info_repository</code>
          </p><div class="informaltable"><table summary="Options for master_info_repository" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.2</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--master-info-repository=FILE|TABLE</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_master_info_repository">master_info_repository</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">FILE</code></td></tr><tr><td scope="row" rowspan="2" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">FILE</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">TABLE</code></td></tr></tbody></table></div><p>
            この変数の設定によって、スレーブがマスターステータスおよび接続情報のログを <code class="literal">FILE</code> (<code class="filename">master.info</code>) または <code class="literal">TABLE</code> (<code class="literal">mysql.slave_master_info</code>) のどちらに記録するかが決まります。
          </p><p>
            この変数の設定は、<code class="literal">sync_master_info</code> システム変数の設定による影響にも直接影響します。詳細については、変数の説明を参照してください。
          </p><p>
            この変数は MySQL 5.6.2 で追加されました。
          </p></li><li class="listitem"><p><a name="sysvar_relay_log"></a>
            <a class="indexterm" name="idm139979050918320"></a> <a class="indexterm" name="idm139979050916832"></a> <code class="literal">relay_log</code>
          </p><div class="informaltable"><table summary="Options for relay-log" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--relay-log=file_name</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_relay_log">relay_log</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ファイル名</code></td></tr></tbody></table></div><p>
            リレーログファイルの名前。
          </p></li><li class="listitem"><p><a name="sysvar_relay_log_basename"></a>
            <a class="indexterm" name="idm139979050895328"></a> <a class="indexterm" name="idm139979050893776"></a> <code class="literal">relay_log_basename</code>
          </p><div class="informaltable"><table summary="Options for relay_log_basename" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.2</td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_relay_log_basename">relay_log_basename</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ファイル名</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">datadir + '/' + hostname + '-relay-bin'</code></td></tr></tbody></table></div><p>
            リレーログファイルの名前と完全パスを保持します。
          </p><p>
            <code class="literal">relay_log_basename</code> システム変数は MySQL 5.6.2 で追加されました。
          </p></li><li class="listitem"><p><a name="sysvar_relay_log_index"></a>
            <a class="indexterm" name="idm139979050868896"></a> <a class="indexterm" name="idm139979050867392"></a> <code class="literal">relay_log_index</code>
          </p><div class="informaltable"><table summary="Options for relay_log_index" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--relay-log-index</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_relay_log_index">relay_log_index</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ファイル名</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">*host_name*-relay-bin.index</code></td></tr></tbody></table></div><p>
            リレーログのインデックスファイルの名前。データディレクトリ内のデフォルト名は <code class="filename"><em class="replaceable"><code>host_name</code></em>-relay-bin.index</code> です。ここで、<em class="replaceable"><code>host_name</code></em> はスレーブサーバーの名前です。
          </p></li><li class="listitem"><p><a name="sysvar_relay_log_info_file"></a>
            <a class="indexterm" name="idm139979050841904"></a> <a class="indexterm" name="idm139979050840352"></a> <code class="literal">relay_log_info_file</code>
          </p><div class="informaltable"><table summary="Options for relay_log_info_file" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--relay-log-info-file=file_name</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_relay_log_info_file">relay_log_info_file</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ファイル名</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">relay-log.info</code></td></tr></tbody></table></div><p>
            スレーブがリレーログの情報を記録するファイルの名前。データディレクトリ内のデフォルト名は <code class="filename">relay-log.info</code> です。
          </p></li><li class="listitem"><p><a name="sysvar_relay_log_info_repository"></a>
            <a class="indexterm" name="idm139979050815664"></a> <a class="indexterm" name="idm139979050814208"></a> <code class="literal">relay_log_info_repository</code>
          </p><div class="informaltable"><table summary="Options for relay_log_info_repository" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.2</td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_relay_log_info_repository">relay_log_info_repository</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">FILE</code></td></tr><tr><td scope="row" rowspan="2" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">FILE</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">TABLE</code></td></tr></tbody></table></div><p>
            この変数によって、スレーブのリレーログ内での位置が <code class="literal">FILE</code> (<code class="filename">relay-log.info</code>) または <code class="literal">TABLE</code> (<code class="literal">mysql.slave_relay_log_info</code>) のどちらに書き込まれるかが決まります。
          </p><p>
            この変数の設定は、<code class="literal">sync_relay_log_info</code> システム変数の設定による影響にも直接影響します。詳細については、変数の説明を参照してください。
          </p><p>
            この変数は MySQL 5.6.2 で追加されました。
          </p></li><li class="listitem"><p><a name="sysvar_relay_log_recovery"></a>
            <a class="indexterm" name="idm139979050781200"></a> <a class="indexterm" name="idm139979050779200"></a> <code class="literal">relay_log_recovery</code>
          </p><div class="informaltable"><table summary="Options for relay_log_recovery" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--relay-log-recovery</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数 (&lt;= 5.6.5)</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_relay_log_recovery">relay_log_recovery</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数 (&gt;= 5.6.6)</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_relay_log_recovery">relay_log_recovery</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">FALSE</code></td></tr></tbody></table></div><p>
            サーバー起動直後のリレーログ自動リカバリを有効にします。リカバリプロセスでは、新しいリレーログファイルを作成し、SQL スレッド位置をこの新しいリレーログに初期化し、I/O スレッドを SQL スレッド位置に初期化します。その後、マスターからのリレーログ読み取りが続行されます。MySQL 5.6.5 以前では、このグローバル変数を動的に変更できました。MySQL 5.6.6 以降は読み取り専用です。(Bug #13840948) MySQL Server バージョンにかかわらず、<code class="option">--relay-log-recovery</code> オプションでスレーブを起動することで、その値を変更できます。これは、レプリケーションスレーブでクラッシュが発生したあとに、破損した可能性のあるリレーログが処理されないことを保証するために使用するべきであり、クラッシュセーフなスレーブを保証するために使用する必要があります。デフォルト値は 0 (無効)です。
          </p><p>
            <code class="literal">relay_log_recovery</code> が有効であり、スレーブがマルチスレッドモードで動作中に発生したエラーが原因で停止したときでも、ログにギャップがある場合には <code class="literal">CHANGE MASTER TO</code> を実行できません。MySQL 5.6.6 以降では、<code class="literal">START SLAVE UNTIL SQL_AFTER_MTS_GAPS</code> を使用して確実にすべてのギャップが処理されてから、単一スレッドモードに戻ったり <code class="literal">CHANGE MASTER TO</code> ステートメントを実行したりするようにしてください。
          </p></li><li class="listitem"><p><a name="sysvar_rpl_stop_slave_timeout"></a>
            <a class="indexterm" name="idm139979050741584"></a> <a class="indexterm" name="idm139979050739568"></a> <code class="literal">rpl_stop_slave_timeout</code>
          </p><div class="informaltable"><table summary="Options for rpl_stop_slave_timeout" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.13</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--rpl-stop-slave-timeout=seconds</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_rpl_stop_slave_timeout">rpl_stop_slave_timeout</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (&gt;= 5.6.13)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">整数</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">31536000</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">2</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">31536000</code></td></tr></tbody></table></div><p>
            MySQL 5.6.13 以降では、この変数を設定することで、タイムアウトまでに <code class="literal">STOP SLAVE</code> が待機する時間 （秒単位） を制御できます。これは、<code class="literal">STOP SLAVE</code> ステートメントと、スレーブへのさまざまなクライアント接続を使用するほかのスレーブ SQL ステートメントとの間のデッドロックを回避するために使用できます。<code class="literal">rpl_stop_slave_timeout</code> の最大値およびデフォルト値は 31536000 秒 (1 年) です。最小は 2 秒です。
          </p></li><li class="listitem"><p><a name="sysvar_slave_checkpoint_group"></a>
            <a class="indexterm" name="idm139979050706496"></a> <a class="indexterm" name="idm139979050704480"></a> <code class="literal">slave_checkpoint_group</code>
          </p><div class="informaltable"><table summary="Options for slave_checkpoint_group" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.3</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--slave-checkpoint-group=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal">slave_checkpoint_group=#</code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="5"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">512</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">32</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">524280</code></td></tr><tr><td scope="row"><span class="bold"><strong>ブロックサイズ</strong></span></td><td colspan="2"><code class="literal">8</code></td></tr></tbody></table></div><p>
            <code class="literal">SHOW SLAVE STATUS</code> によって表示されるマルチスレッドスレーブステータスを更新するためにチェックポイント操作が呼び出される前に、スレーブが処理できる最大トランザクション数を設定します。この変数を設定しても、マルチスレッドが有効ではないスレーブには影響しません。
          </p><p>
            この変数は、<code class="literal">slave_checkpoint_period</code> システム変数との組み合わせで、どちらかの制限を超えたときに、チェックポイントが実行され、トランザクションの数と最後のチェックポイントから経過した時間の両方を追跡するカウンタがリセットされる、という方法で機能します。
          </p><p>
            この変数の最小許容値は 32 です (サーバーが <code class="option">-DWITH_DEBUG</code> を使用して構築された場合を除く、この場合の最小値は 1)。効果的な値は常に 8 の倍数です。そのような倍数でない値に設定することもできますが、サーバーは値を格納する前に次に小さい 8 の倍数に丸めます。(<span class="emphasis"><em>例外</em></span>: このような丸めはデバッグサーバーでは実行されません。)サーバーの構築方法にかかわらず、デフォルト値は 512 であり、最大許容値は 524280 です。
          </p><p>
            <code class="literal">slave_checkpoint_group</code> は MySQL 5.6.3 で追加されました。
          </p></li><li class="listitem"><p><a name="sysvar_slave_checkpoint_period"></a>
            <a class="indexterm" name="idm139979050665856"></a> <a class="indexterm" name="idm139979050663840"></a> <code class="literal">slave_checkpoint_period</code>
          </p><div class="informaltable"><table summary="Options for slave_checkpoint_period" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.3</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--slave-checkpoint-period=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal">slave_checkpoint_period=#</code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">300</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">4G</code></td></tr></tbody></table></div><p>
            <code class="literal">SHOW SLAVE STATUS</code> によって表示されるマルチスレッドのスレーブステータスを更新するためにチェックポイント操作が呼び出される前に、経過できる最大時間 （ミリ秒単位） を設定します。この変数を設定しても、マルチスレッドが有効ではないスレーブには影響しません。
          </p><p>
            この変数は、<code class="literal">slave_checkpoint_group</code> システム変数との組み合わせで、どちらかの制限を超えたときに、チェックポイントが実行され、トランザクションの数と最後のチェックポイントから経過した時間の両方を追跡するカウンタがリセットされる、という方法で機能します。
          </p><p>
            この変数の最小許容値は 1 です (サーバーが <code class="option">-DWITH_DEBUG</code> を使用して構築された場合を除く、この場合の最小値は 0)。サーバーの構築方法にかかわらず、デフォルト値は 300 であり、最大可能値は 4294967296 (4G バイト) です。
          </p><p>
            <code class="literal">slave_checkpoint_period</code> は MySQL 5.6.3 で追加されました。
          </p></li><li class="listitem"><p><a name="sysvar_slave_compressed_protocol"></a>
            <a class="indexterm" name="idm139979050628432"></a> <a class="indexterm" name="idm139979050626976"></a> <code class="literal">slave_compressed_protocol</code>
          </p><div class="informaltable"><table summary="Options for slave_compressed_protocol" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--slave_compressed_protocol</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_slave_compressed_protocol">slave_compressed_protocol</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr></tbody></table></div><p>
            スレーブ/マスタープロトコルの圧縮を使用するかどうか (スレーブとマスターの両方がサポートしている場合)。
          </p></li><li class="listitem"><p><a name="sysvar_slave_exec_mode"></a>
            <a class="indexterm" name="idm139979050602960"></a> <a class="indexterm" name="idm139979050601456"></a> <code class="literal">slave_exec_mode</code>
          </p><div class="informaltable"><table summary="Options for slave_exec_mode" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--slave-exec-mode=mode</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_slave_exec_mode">slave_exec_mode</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="5"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">列挙</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">STRICT</code> (ALL)</td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">IDEMPOTENT</code> (NDB)</td></tr><tr><td scope="row" rowspan="2" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">IDEMPOTENT</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">STRICT</code></td></tr></tbody></table></div><p>
            <code class="literal">IDEMPOTENT</code> または <code class="literal">STRICT</code> モードがレプリケーション競合解決とエラーチェックで使用されるかどうかを制御します。<code class="literal">IDEMPOTENT</code> モードでは、キーが重複しているエラーとキーが見つからないエラーが抑制されます。
          </p><p>
            このモードは、MySQL Cluster レプリケーションのマルチマスターレプリケーション、循環レプリケーション、およびその他の特別なレプリケーションシナリオに必要です。(詳しくは、<a class="xref" href="mysql-cluster.html#mysql-cluster-replication-multi-master" title="18.6.10 MySQL Cluster レプリケーション: マルチマスターと循環レプリケーション">セクション18.6.10「MySQL Cluster レプリケーション: マルチマスターと循環レプリケーション」</a>および<a class="xref" href="mysql-cluster.html#mysql-cluster-replication-conflict-resolution" title="18.6.11 MySQL Cluster レプリケーションの競合解決">セクション18.6.11「MySQL Cluster レプリケーションの競合解決」</a>を参照してください。)MySQL Cluster で提供される <span class="command"><strong>mysqld</strong></span> は、<code class="literal">slave_exec_mode</code> に明示的に設定される値を無視し、これを常に <code class="literal">IDEMPOTENT</code> として扱います。
          </p><p>
            MySQL Server 5.6 では、<code class="literal">STRICT</code> モードがデフォルト値です。これを変更しないでください。現在のところ、<code class="literal">IDEMPOTENT</code> モードは <code class="literal">NDB</code> でのみサポートされます。
          </p></li><li class="listitem"><p><a name="sysvar_slave_load_tmpdir"></a>
            <a class="indexterm" name="idm139979050560000"></a> <a class="indexterm" name="idm139979050558448"></a> <code class="literal">slave_load_tmpdir</code>
          </p><div class="informaltable"><table summary="Options for slave-load-tmpdir" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--slave-load-tmpdir=path</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_slave_load_tmpdir">slave_load_tmpdir</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ディレクトリ名</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">/tmp</code></td></tr></tbody></table></div><p>
            <code class="literal">LOAD DATA INFILE</code> ステートメントを複製するためにスレーブが一時ファイルを作成するディレクトリの名前。
          </p></li><li class="listitem"><p><a name="sysvar_slave_max_allowed_packet"></a>
            <a class="indexterm" name="idm139979050533312"></a> <a class="indexterm" name="idm139979050531760"></a> <code class="literal">slave_max_allowed_packet</code>
          </p><div class="informaltable"><table summary="Options for slave_max_allowed_packet" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.6</td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_slave_max_allowed_packet">slave_max_allowed_packet</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">1073741824</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1024</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">1073741824</code></td></tr></tbody></table></div><p>
            MySQL 5.6.6 以降では、この変数はスレーブ SQL スレッドおよび I/O スレッドの最大パケットサイズを設定するので、更新が <code class="literal">max_allowed_packet</code> を超えたことが原因で、行ベースレプリケーションを使用する大きな更新がレプリケーションに失敗することはありません。
          </p><p>
            このグローバル変数は常に、1024 の正の整数の倍数である値を持ちます。そうでない何らかの値に設定しても、値は次に大きい 1024 の倍数に自動的に丸められて、格納または使用されます。<code class="literal">slave_max_allowed_packet</code> を 0 に設定すると、1024 が使用されます。(このような場合、切り捨ての警告が発行されます。)デフォルトおよび最大値は 1073741824 (1G バイト) で、最小は 1024 です。
          </p><p>
            <code class="literal">slave_max_allowed_packet</code> は <code class="option">--slave-max-allowed-packet</code> オプションを使用して、起動時に設定することもできます。
          </p></li><li class="listitem"><p><a name="sysvar_slave_net_timeout"></a>
            <a class="indexterm" name="idm139979050498160"></a> <a class="indexterm" name="idm139979050496608"></a> <code class="literal">slave_net_timeout</code>
          </p><div class="informaltable"><table summary="Options for slave-net-timeout" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--slave-net-timeout=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_slave_net_timeout">slave_net_timeout</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">3600</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr></tbody></table></div><p>
            マスター/スレーブ接続から後続のデータを待機する秒数 (これ以降は、読み取りを中止)。
          </p></li><li class="listitem"><p><a name="sysvar_slave_parallel_workers"></a>
            <a class="indexterm" name="idm139979050470496"></a> <a class="indexterm" name="idm139979050468944"></a> <code class="literal">slave_parallel_workers</code>
          </p><div class="informaltable"><table summary="Options for slave_parallel_workers" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.3</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--slave-parallel-workers=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_slave_parallel_workers">slave_parallel_workers</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">1024</code></td></tr></tbody></table></div><p>
            レプリケーションイベント （トランザクション） を並列に実行するためのスレーブワーカースレッドの数を設定します。この変数を 0 (デフォルト) に設定すると、並列実行が無効になります。最大値は 1024 です。
          </p><p>
            並列実行が有効のときは、スレーブ SQL スレッドはスレーブワーカースレッドのコーディネーターとして機能し、トランザクションはそれらにデータベースごとに分散されます。これは、スレーブ上のワーカースレッドは、ほかのデータベースへの更新が完了するのを待たずに、所定のデータベースに基づいてトランザクションを次々に処理できることを意味します。スレーブでのマルチスレッドの現在の実装は、データがデータベースごとに分割されていて、所定のデータベース内の更新が正しく機能するようにマスターの場合と同様に相対順序で行われることを前提としています。ただし、2 つのデータベース間でトランザクションを調整する必要はありません。
          </p><p>
            異なるデータベースでのトランザクションは、スレーブではマスターとは異なる順序が実行されることがあるという事実のため、最後に実行されたトランザクションをチェックしても、マスターからの以前のすべてのトランザクションがスレーブ上で実行されたことが保証されません。これは、マルチスレッド化したスレーブを使用する場合にロギングとリカバリに影響します。スレーブ上でマルチスレッドを使用したときにバイナリロギング情報をどのように解釈すればよいかについては、<a class="xref" href="sql-syntax.html#show-slave-status" title="13.7.5.35 SHOW SLAVE STATUS 構文">セクション13.7.5.35「SHOW SLAVE STATUS 構文」</a>を参照してください。また、<code class="literal">START SLAVE UNTIL</code> がマルチスレッドスレーブでサポートされないことを意味します。
          </p><p>
            マルチスレッドが有効のときは、<code class="literal">slave_transaction_retries</code> は 0 に等しいとして処理され、変更できません。(現在のところ、トランザクションの再試行はマルチスレッドスレーブではサポートされません。)
          </p><p>
            この変数は MySQL 5.6.3 で追加されました。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              この変数 (または対応する <code class="option">--slave-parallel-workers</code> オプション) の値セットは MySQL 5.6.3 で正しく処理されるとはかぎりません。この問題は MySQL 5.6.4 で修正されました (Bug #13334470)。
            </p></div></li><li class="listitem"><p><a name="sysvar_slave_pending_jobs_size_max"></a>
            <a class="indexterm" name="idm139979050427792"></a> <a class="indexterm" name="idm139979050425760"></a> <code class="literal">slave_pending_jobs_size_max</code>
          </p><div class="informaltable"><table summary="Options for slave_pending_jobs_size_max" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.3</td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_slave_pending_jobs_size_max">slave_pending_jobs_size_max</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="5"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1024</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">18EB</code></td></tr><tr><td scope="row"><span class="bold"><strong>ブロックサイズ</strong></span></td><td colspan="2"><code class="literal">1024</code></td></tr></tbody></table></div><p>
            マルチスレッドスレーブの場合、この変数は、まだ適用されていないイベントを保持するスレーブワーカーキューに使用可能な最大メモリー量 (バイト単位) を設定します。この変数を設定しても、マルチスレッドが有効ではないスレーブには影響しません。
          </p><p>
            この変数の可能な最小値は 1024 で、デフォルトは 16M バイトです。可能な最大値は 18446744073709551615 (16E バイト) です。1024 の正確な倍数でない値は、保存される前に次に大きい 1024 の倍数に丸められます。
          </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
              この変数の値はマスターの <code class="literal">max_allowed_packet</code> の値以上である必要があります。そうでない場合は、マスターから到着する処理すべきイベントが残っているときにスレーブワーカーキューがいっぱいになる場合があります。
            </p></div><p>
            <code class="literal">slave_pending_jobs_size_max</code> は MySQL 5.6.3 で追加されました。
          </p></li><li class="listitem"><p><a name="sysvar_slave_rows_search_algorithms"></a>
            <a class="indexterm" name="idm139979050391040"></a> <a class="indexterm" name="idm139979050389568"></a> <code class="literal">slave_rows_search_algorithms</code>
          </p><div class="informaltable"><table summary="Options for slave_rows_search_algorithms" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.6</td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal">slave_rows_search_algorithms=list</code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="6"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">セット</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">TABLE_SCAN,INDEX_SCAN</code></td></tr><tr><td scope="row" rowspan="4" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">TABLE_SCAN,INDEX_SCAN</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">INDEX_SCAN,HASH_SCAN</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">TABLE_SCAN,HASH_SCAN</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">TABLE_SCAN,INDEX_SCAN,HASH_SCAN</code> (INDEX_SCAN,HASH_SCAN と同等)</td></tr></tbody></table></div><p>
            <code class="literal">slave_allow_batching</code> を使用して行ベースロギングとレプリケーションのために大量の行を準備するときに、<code class="literal">slave_rows_search_algorithms</code> 変数は行の一致がどのように検索されるか、つまり、主キー、一意キー、または何らかのほかのキーを使用する検索、またはキーをまったく使用しない検索にハッシュを使用するかどうかを制御します。このオプションは、リスト <code class="literal">INDEX_SCAN</code>、<code class="literal">TABLE_SCAN</code>、<code class="literal">HASH_SCAN</code> から少なくとも 2 つの値のカンマ区切りリストを取ります。値は文字列を想定するため、値は引用符で囲む必要があります。また、値に空白文字を含めてはいけません。可能な組み合わせ (リスト) とその結果を次の表に示します。
          </p><div class="informaltable"><table summary="この表は、slave_rows_search_algorithms 変数に指定される値に基づいて、行の一致がどのように検索されるかを示します。" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th scope="col">使用されるインデックス/オプション値</th><th scope="col"><code class="literal">INDEX_SCAN,HASH_SCAN</code> または <code class="literal">INDEX_SCAN,TABLE_SCAN,HASH_SCAN</code></th><th scope="col"><code class="literal">INDEX_SCAN,TABLE_SCAN</code></th><th scope="col"><code class="literal">TABLE_SCAN,HASH_SCAN</code></th></tr></thead><tbody><tr><td scope="row"><span class="emphasis"><em>主キーまたは一意キー</em></span></td><td>インデックススキャン</td><td>インデックススキャン</td><td>インデックスハッシュ</td></tr><tr><td scope="row"><span class="emphasis"><em>(ほかの) キー</em></span></td><td>インデックスハッシュ</td><td>インデックススキャン</td><td>インデックスハッシュ</td></tr><tr><td scope="row"><span class="emphasis"><em>インデックスなし</em></span></td><td>テーブルハッシュ</td><td>テーブルスキャン</td><td>テーブルハッシュ</td></tr></tbody></table></div><p>
            リスト内でアルゴリズムが指定される順序は、ここで示すように、<code class="literal">SELECT</code> または <code class="literal">SHOW VARIABLES</code> ステートメントで表示される順序と違いはありません。
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET GLOBAL slave_rows_search_algorithms = "INDEX_SCAN,TABLE_SCAN";</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE '%algorithms%';</code></strong>
+------------------------------+-----------------------+
| Variable_name                | Value                 |
+------------------------------+-----------------------+
| slave_rows_search_algorithms | TABLE_SCAN,INDEX_SCAN |
+------------------------------+-----------------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SET GLOBAL slave_rows_search_algorithms = "TABLE_SCAN,INDEX_SCAN";</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE '%algorithms%';</code></strong>
+------------------------------+-----------------------+
| Variable_name                | Value                 |
+------------------------------+-----------------------+
| slave_rows_search_algorithms | TABLE_SCAN,INDEX_SCAN |
+------------------------------+-----------------------+
1 row in set (0.00 sec)
</pre><p>
            デフォルト値は <code class="literal">TABLE_SCAN,INDEX_SCAN</code> で、これはインデックスを使用できるすべての検索はそれらを使用し、インデックスなしの検索はテーブルスキャンを使用することを意味します。
          </p><p>
            <code class="literal">INDEX_SCAN,TABLE_SCAN,HASH_SCAN</code> を指定することは、<code class="literal">INDEX_SCAN,HASH_SCAN</code> を指定する場合と同じ結果になります。主キーまたは一意キーを使用しない検索にハッシュを使用するには、この変数を <code class="literal">INDEX_SCAN,HASH_SCAN</code> に設定します。<span class="emphasis"><em>すべての</em></span>検索にハッシュを強制的に使用するには、<code class="literal">TABLE_SCAN,HASH_SCAN</code> に設定します。
          </p><p>
            この変数は MySQL 5.6.6 で追加されました。
          </p></li><li class="listitem"><p><a name="sysvar_slave_skip_errors"></a>
            <a class="indexterm" name="idm139979050324080"></a> <a class="indexterm" name="idm139979050322560"></a> <code class="literal">slave_skip_errors</code>
          </p><div class="informaltable"><table summary="Options for slave-skip-errors" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--slave-skip-errors=name</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_slave_skip_errors">slave_skip_errors</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="5"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr><tr><td scope="row" rowspan="3" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">[list of error codes]</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">all</code></td></tr><tr><td scope="row" rowspan="6"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr><tr><td scope="row" rowspan="4" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">[list of error codes]</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">all</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">ddl_exist_errors</code></td></tr><tr><td scope="row" rowspan="6"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr><tr><td scope="row" rowspan="4" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">[list of error codes]</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">all</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">ddl_exist_errors</code></td></tr></tbody></table></div><p>
            レプリケーションは通常、スレーブでエラーが発生したときに停止します。これは、データ内の不一致を手動で解決する機会です。この変数は、ステートメントが変数値にリストされたエラーを返すときに、レプリケーションを継続するようにスレーブ SQL スレッドに指示します。
          </p></li><li class="listitem"><p><a name="sysvar_slave_sql_verify_checksum"></a>
            <a class="indexterm" name="idm139979050267888"></a> <a class="indexterm" name="idm139979050266432"></a> <code class="literal">slave_sql_verify_checksum</code>
          </p><div class="informaltable"><table summary="Options for slave_sql_verify_checksum" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.2</td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_slave_sql_verify_checksum">slave_sql_verify_checksum</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row" rowspan="2" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">1</code></td></tr></tbody></table></div><p>
            スレーブ SQL スレッドはリレーログから読み取られたチェックサムを使用してデータを検証します。不一致があった場合、スレーブはエラーで停止します。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              スレーブ I/O スレッドは常に、ネットワークからイベントを受け取るときに可能であればチェックサムを読み取ります。
            </p></div><p>
            <code class="literal">slave_sql_verify_checksum</code> は MySQL 5.6.2 で追加されました。
          </p></li><li class="listitem"><p><a name="sysvar_slave_transaction_retries"></a>
            <a class="indexterm" name="idm139979050236144"></a> <a class="indexterm" name="idm139979050234688"></a> <code class="literal">slave_transaction_retries</code>
          </p><div class="informaltable"><table summary="Options for slave_transaction_retries" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--slave_transaction_retries=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_slave_transaction_retries">slave_transaction_retries</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (32 ビットプラットフォーム)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">10</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">4294967295</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (64 ビットプラットフォーム)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">10</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">18446744073709551615</code></td></tr></tbody></table></div><p>
            <code class="literal">InnoDB</code> デッドロック、またはトランザクションの実行時間が <code class="literal">InnoDB</code> の <code class="literal">innodb_lock_wait_timeout</code>、または <code class="literal">NDB</code> の <code class="literal">TransactionDeadlockDetectionTimeout</code> または <code class="literal">TransactionInactiveTimeout</code> を超えたために、レプリケーションスレーブ SQL スレッドがトランザクションの実行に失敗した場合、自動的に <code class="literal">slave_transaction_retries</code> 回再試行してからエラーで停止します。デフォルト値は 10 です。
          </p><p>
            マルチスレッドスレーブを使用するときは、トランザクションを再試行できません。つまり、<code class="literal">slave_parallel_workers</code> が 0 より大きい場合は、<code class="literal">slave_transaction_retries</code> が 0 に等しいとして扱われ、変更できません。
          </p></li><li class="listitem"><p><a name="sysvar_slave_type_conversions"></a>
            <a class="indexterm" name="idm139979050186064"></a> <a class="indexterm" name="idm139979050184512"></a> <code class="literal">slave_type_conversions</code>
          </p><div class="informaltable"><table summary="Options for slave_type_conversions" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--slave_type_conversions=set</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_slave_type_conversions">slave_type_conversions</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (&lt;= 5.6.12)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">セット</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal"></code></td></tr><tr><td scope="row" rowspan="2" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">ALL_LOSSY</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">ALL_NON_LOSSY</code></td></tr><tr><td scope="row" rowspan="6"><span class="bold"><strong>許可されている値</strong></span> (&gt;= 5.6.13)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">セット</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal"></code></td></tr><tr><td scope="row" rowspan="4" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">ALL_LOSSY</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">ALL_NON_LOSSY</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">ALL_SIGNED</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">ALL_UNSIGNED</code></td></tr></tbody></table></div><p>
            行ベースレプリケーションを使用するときにスレーブで有効なタイプ変換モードを制御します。MySQL 5.6.13 以降では、その値はリスト <code class="literal">ALL_LOSSY</code>、<code class="literal">ALL_NON_LOSSY</code>、<code class="literal">ALL_SIGNED</code>、<code class="literal">ALL_UNSIGNED</code> からのゼロ個以上の要素のカンマ区切りセットです。この変数を空の文字列に設定すると、マスターとスレーブの間のタイプ変換が禁止されます。変更を有効にするには、スレーブの再起動が必要です。
          </p><p>
            <code class="literal">ALL_SIGNED</code> および <code class="literal">ALL_UNSIGNED</code> は MySQL 5.6.13 で追加されました (Bug#15831300)。行ベースレプリケーションで属性の昇格と降格に適用できるタイプ変換モードの詳細については、<a class="xref" href="replication.html#replication-features-attribute-promotion" title="行ベースレプリケーション: 属性の昇格と降格">行ベースレプリケーション: 属性の昇格と降格</a>を参照してください。
          </p></li><li class="listitem"><p><a name="sysvar_sql_slave_skip_counter"></a>
            <a class="indexterm" name="idm139979050137248"></a> <a class="indexterm" name="idm139979050135696"></a> <code class="literal">sql_slave_skip_counter</code>
          </p><div class="informaltable"><table summary="Options for sql_slave_skip_counter" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_sql_slave_skip_counter">sql_slave_skip_counter</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr></tbody></table></div><p>
            マスターからのイベントのうち、スレーブサーバーがスキップすべき数。
          </p><p>
            このオプションは GTID ベースレプリケーションと互換性がなく、<code class="option">--gtid-mode=ON</code> のときにゼロ以外の値に設定してはいけません。MySQL 5.6.10 以降では、そのようにすることは明確に禁止されています。(Bug #15833516) GTID を採用するときにトランザクションをスキップする必要がある場合は、代わりにマスターから <code class="literal">gtid_executed</code> を使用してください。これを行う方法については、<a class="xref" href="replication.html#replication-gtids-failover-empty" title="空のトランザクションの注入">空のトランザクションの注入</a>を参照してください。
          </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
              この変数を設定することで指定される数のイベントをスキップして、スレーブがイベントグループの途中で開始する場合、スレーブは次のイベントグループの開始を見つけるまでスキップを続け、そのポイントから開始します。詳細については、<a class="xref" href="sql-syntax.html#set-global-sql-slave-skip-counter" title="13.4.2.4 SET GLOBAL sql_slave_skip_counter 構文">セクション13.4.2.4「SET GLOBAL sql_slave_skip_counter 構文」</a>を参照してください。
            </p></div></li><li class="listitem"><p><a name="sysvar_sync_master_info"></a>
            <a class="indexterm" name="idm139979050110384"></a> <a class="indexterm" name="idm139979050108880"></a> <code class="literal">sync_master_info</code>
          </p><div class="informaltable"><table summary="Options for sync_master_info" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--sync-master-info=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_sync_master_info">sync_master_info</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (32 ビットプラットフォーム, &lt;= 5.6.5)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">4294967295</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (64 ビットプラットフォーム, &lt;= 5.6.5)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">18446744073709551615</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (32 ビットプラットフォーム, &gt;= 5.6.6)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">10000</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">4294967295</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (64 ビットプラットフォーム, &gt;= 5.6.6)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">10000</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">18446744073709551615</code></td></tr></tbody></table></div><p>
            レプリケーションスレーブでのこの変数の影響は、次の段落で説明するように、スレーブの <code class="literal">master_info_repository</code> が <code class="literal">FILE</code> または <code class="literal">TABLE</code> のどちらに設定されているかによって異なります。
          </p><p><b>master_info_repository = FILE </b>
              <code class="literal">sync_master_info</code> の値が 0 より大きい場合は、スレーブはすべての <code class="literal">sync_master_info</code> イベントのあとにその <code class="filename">master.info</code> ファイルをディスクに同期します (<code class="literal">fdatasync()</code> を使用)。0 の場合は、MySQL サーバーは <code class="filename">master.info</code> ファイルからディスクへの同期を実行しません。代わりに、サーバーはオペレーティングシステムに依存して、ほかのファイルと同様にその内容を定期的にフラッシュします。
            </p><p><b>master_info_repository = TABLE </b>
              <code class="literal">sync_master_info</code> の値が 0 より大きい場合は、スレーブはすべての <code class="literal">sync_master_info</code> イベントのあとにそのマスター情報リポジトリテーブルを更新します。0 の場合は、テーブルは更新されません。
            </p><p>
            <code class="literal">sync_master_info</code> のデフォルト値は、MySQL 5.6.6 以降では 10000、その前は 0 です。
          </p></li><li class="listitem"><p><a name="sysvar_sync_relay_log"></a>
            <a class="indexterm" name="idm139979050037280"></a> <a class="indexterm" name="idm139979050035776"></a> <code class="literal">sync_relay_log</code>
          </p><div class="informaltable"><table summary="Options for sync_relay_log" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--sync-relay-log=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_sync_relay_log">sync_relay_log</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (32 ビットプラットフォーム, &lt;= 5.6.5)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">4294967295</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (64 ビットプラットフォーム, &lt;= 5.6.5)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">18446744073709551615</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (32 ビットプラットフォーム, &gt;= 5.6.6)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">10000</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">4294967295</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (64 ビットプラットフォーム, &gt;= 5.6.6)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">10000</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">18446744073709551615</code></td></tr></tbody></table></div><p>
            この変数の値が 0 より大きい場合は、すべての <code class="literal">sync_relay_log</code> イベントがリレーログに書き込まれたあとに、MySQL サーバーはそのリレーログをディスクに同期します (<code class="literal">fdatasync()</code> を使用)。
          </p><p>
            <code class="literal">sync_relay_log</code> を 0 に設定すると、ディスクへの同期は実行されません。この場合、サーバーはオペレーティングシステムに依存してほかのファイルに関してリレーログの内容をときどきフラッシュします。
          </p><p>
            MySQL 5.6.6 より前は、0 がこの変数のデフォルトでした。MySQL 5.6. 以降では、デフォルトは 10000 です。
          </p><p>
            値 1 が一番安全な選択です (クラッシュの場合にリレーログから失われるイベントが最大で 1 つです)。しかし、一番遅い選択でもあります (ディスクにバッテリ付きキャッシュがある場合を除きます。その場合は同期が非常に速くなります)。
          </p></li><li class="listitem"><p><a name="sysvar_sync_relay_log_info"></a>
            <a class="indexterm" name="idm139979049971584"></a> <a class="indexterm" name="idm139979049970032"></a> <code class="literal">sync_relay_log_info</code>
          </p><div class="informaltable"><table summary="Options for sync_relay_log_info" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--sync-relay-log-info=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_sync_relay_log_info">sync_relay_log_info</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (32 ビットプラットフォーム, &lt;= 5.6.5)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">4294967295</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (64 ビットプラットフォーム, &lt;= 5.6.5)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">18446744073709551615</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (32 ビットプラットフォーム, &gt;= 5.6.6)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">10000</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">4294967295</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (64 ビットプラットフォーム, &gt;= 5.6.6)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">10000</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">18446744073709551615</code></td></tr></tbody></table></div><p>
            スレーブでのこの変数の影響は、サーバーの <code class="literal">relay_log_info_repository</code> 設定 （<code class="literal">FILE</code> または <code class="literal">TABLE</code>）、これが <code class="literal">TABLE</code> の場合は、さらにリレーログ情報テーブルで使用されるストレージエンジンがトランザクション対応か （<code class="literal">InnoDB</code> など） そうでないか （<code class="literal">MyISAM</code>）に依存します。これらの要因が、<code class="literal">sync_relay_log_info</code> 値がゼロおよびゼロより大きい場合にサーバーの動作にどのように影響するかを次の表で示します。
          </p><div class="informaltable"><table summary="レプリケーションスレーブに対する sync_relay_log_info および relay_log_info_repository 変数の影響" border="1"><colgroup><col><col class="f1"><col class="f2"><col class="f3"></colgroup><thead><tr><th scope="col" rowspan="3"><code class="literal">sync_relay_log_info</code></th><th scope="col" colspan="3"><code class="literal">relay_log_info_repository</code></th></tr><tr><th scope="col" rowspan="2"><code class="literal">FILE</code></th><th scope="col" colspan="2"><code class="literal">TABLE</code></th></tr><tr><th scope="col">トランザクション対応</th><th scope="col">トランザクション対応でない</th></tr></thead><tbody><tr><td scope="row"><code class="literal"><em class="replaceable"><code>N</code></em> &gt; 0</code></td><td><p>
                      スレーブは各 <em class="replaceable"><code>N</code></em> トランザクション後にその <code class="filename">relay-log.info</code> ファイルをディスクに同期します (<code class="literal">fdatasync()</code> を使用)。
                    </p></td><td rowspan="2"><p>
                      テーブルは各トランザクション後に更新されます。(<em class="replaceable"><code>N</code></em> は事実上無視されます。)
                    </p></td><td><p>
                      テーブルは各 <em class="replaceable"><code>N</code></em> イベント後に更新されます。
                    </p></td></tr><tr><td scope="row"><code class="literal">0</code></td><td><p>
                      MySQL サーバーは <code class="filename">relay-log.info</code> ファイルからディスクへの同期を実行しません。代わりに、サーバーはオペレーティングシステムに依存してほかのファイルと同様にその内容を定期的にフラッシュします。
                    </p></td><td><p>
                      テーブルは更新されません。
                    </p></td></tr></tbody></table></div><p>
            <code class="literal">sync_relay_log_info</code> のデフォルト値は、MySQL 5.6.6 以降では 10000、それより前は 0 です。
          </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-options-binary-log"></a>17.1.4.4 バイナリログのオプションと変数</h4></div></div></div><p>
      <a class="xref" href="replication.html#replication-optvars-binlog" title="バイナリロギングで使用する起動オプション">バイナリロギングで使用する起動オプション</a>
    </p><p>
      <a class="xref" href="replication.html#replication-sysvars-binlog" title="バイナリロギングで使用されるシステム変数">バイナリロギングで使用されるシステム変数</a>
    </p><p>
      このセクションで説明する <span class="command"><strong>mysqld</strong></span> オプションおよびシステム変数を使用して、バイナリログの操作に影響を与えたり、バイナリログにどのステートメントが書き込まれたかを制御したりできます。バイナリログの追加情報については、<a class="xref" href="server-administration.html#binary-log" title="5.2.4 バイナリログ">セクション5.2.4「バイナリログ」</a>を参照してください。MySQL サーバーのオプションとシステム変数の使用に関する追加情報については、<a class="xref" href="server-administration.html#server-options" title="5.1.3 サーバーコマンドオプション">セクション5.1.3「サーバーコマンドオプション」</a>および<a class="xref" href="server-administration.html#server-system-variables" title="5.1.4 サーバーシステム変数">セクション5.1.4「サーバーシステム変数」</a>を参照してください。
    </p><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="replication-optvars-binlog"></a>バイナリロギングで使用する起動オプション</h5></div></div></div><p>
        次のリストでは、バイナリログを有効化したり構成したりするための起動オプションについて説明します。バイナリロギングで使用するシステム変数については、このセクションの後半で説明します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="option_mysqld_binlog-row-event-max-size"></a>
            <a class="indexterm" name="idm139979049869088"></a> <a class="indexterm" name="idm139979049866880"></a> <code class="option">--binlog-row-event-max-size=<em class="replaceable"><code>N</code></em></code>
          </p><div class="informaltable"><table summary="Options for binlog-row-event-max-size" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--binlog-row-event-max-size=#</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (32 ビットプラットフォーム, &lt;= 5.6.5)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">1024</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">256</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">4294967295</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (64 ビットプラットフォーム, &lt;= 5.6.5)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">1024</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">256</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">18446744073709551615</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (32 ビットプラットフォーム, &gt;= 5.6.6)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">8192</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">256</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">4294967295</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (64 ビットプラットフォーム, &gt;= 5.6.6)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">8192</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">256</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">18446744073709551615</code></td></tr></tbody></table></div><p>
            行ベースのバイナリログイベントの最大サイズをバイト単位で指定します。可能であれば、行はこのサイズより小さいイベントにグループ化されます。値は 256 の倍数であるべきです。デフォルトは、MySQL 5.6.6 以降では 8192、それより前では 1024 です。<a class="xref" href="replication.html#replication-formats" title="17.1.2 レプリケーション形式">セクション17.1.2「レプリケーション形式」</a>を参照してください。
          </p></li><li class="listitem"><p><a name="option_mysqld_log-bin"></a>
            <a class="indexterm" name="idm139979049814064"></a> <a class="indexterm" name="idm139979049811904"></a> <code class="option">--log-bin[=<em class="replaceable"><code>base_name</code></em>]</code>
          </p><div class="informaltable"><table summary="Options for log-bin" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--log-bin</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_log_bin">log_bin</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ファイル名</code></td></tr></tbody></table></div><p>
            バイナリロギングを有効化します。サーバーはデータを変更するすべてのステートメントのログをバイナリログに記録し、これはバックアップとレプリケーションに使用されます。<a class="xref" href="server-administration.html#binary-log" title="5.2.4 バイナリログ">セクション5.2.4「バイナリログ」</a>を参照してください。
          </p><p>
            オプション値 (指定された場合) はログシーケンスのベース名です。サーバーは、ベース名に数字サフィクスを追加することで、バイナリログファイルを次々に作成します。ベース名を指定することをお勧めします (その理由は <a class="xref" href="error-handling.html#bugs" title="B.5.8 MySQL の既知の問題">セクションB.5.8「MySQL の既知の問題」</a>を参照してください)。そうでない場合、MySQL はベース名として <code class="filename"><em class="replaceable"><code>host_name</code></em>-bin</code> を使用します。
          </p><p>
            MySQL 5.6.5 以降のサーバーは、インデックスファイルからエントリを読み取るときに、エントリに相対パスが含まれるかどうかをチェックし、さらにそうである場合は、パスの相対部が <code class="option">--log-bin</code> オプションを使用して設定された絶対パスに置き換えられます。絶対パスは変わりません。このような場合、使用される新しいパスを有効にするために、インデックスを手動で編集する必要があります。MySQL 5.6.5 より前は、バイナリログまたはリレーログファイルの位置を変更するときは、手動介入が必要でした。(Bug #11745230、Bug #12133)
          </p><p>
            このオプションを設定することで、<code class="literal">log_bin</code> システム変数は <code class="literal">ON</code> (または <code class="literal">1</code>) に設定されます (ベース名にではなく)。MySQL 5.6.2 以降では、バイナリログファイル名 (パス付き) は <code class="literal">log_bin_basename</code> システム変数として使用できます。
          </p></li><li class="listitem"><p><a name="option_mysqld_log-bin-index"></a>
            <a class="indexterm" name="idm139979049780048"></a> <a class="indexterm" name="idm139979049777888"></a> <code class="option">--log-bin-index[=<em class="replaceable"><code>file_name</code></em>]</code>
          </p><div class="informaltable"><table summary="Options for log-bin-index" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--log-bin-index=file_name</code></td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ファイル名</code></td></tr></tbody></table></div><p>
            バイナリログファイル名のインデックスファイル。<a class="xref" href="server-administration.html#binary-log" title="5.2.4 バイナリログ">セクション5.2.4「バイナリログ」</a>を参照してください。ファイル名を省略した場合、および <code class="option">--log-bin</code> でこれを指定しなかった場合、MySQL はファイル名として <code class="filename"><em class="replaceable"><code>host_name</code></em>-bin.index</code> を使用します。
          </p></li><li class="listitem"><p><a name="option_mysqld_log-bin-trust-function-creators"></a>
            <a class="indexterm" name="idm139979049760912"></a> <a class="indexterm" name="idm139979049758720"></a> <code class="option">--log-bin-trust-function-creators[={0|1}]</code>
          </p><div class="informaltable"><table summary="Options for log-bin-trust-function-creators" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--log-bin-trust-function-creators</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="server-administration.html#sysvar_log_bin_trust_function_creators">log_bin_trust_function_creators</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">FALSE</code></td></tr></tbody></table></div><p>
            このオプションは対応する <code class="literal">log_bin_trust_function_creators</code> システム変数を設定します。引数が指定されない場合、このオプションは変数を 1 に設定します。<code class="literal">log_bin_trust_function_creators</code> は、ストアドファンクションおよびトリガー作成に対して MySQL がどのように制限を適用するかに影響します。<a class="xref" href="stored-programs-views.html#stored-programs-logging" title="20.7 ストアドプログラムのバイナリロギング">セクション20.7「ストアドプログラムのバイナリロギング」</a>を参照してください。
          </p></li><li class="listitem"><p><a name="option_mysqld_log-bin-use-v1-row-events"></a>
            <a class="indexterm" name="idm139979049731760"></a> <a class="indexterm" name="idm139979049729552"></a> <code class="option">--log-bin-use-v1-row-events[={0|1}]</code>
          </p><div class="informaltable"><table summary="Options for log-bin-use-v1-row-events" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.6</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--log-bin-use-v1-row-events[={0|1}]</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_log_bin_use_v1_row_events">log_bin_use_v1_row_events</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span> (&gt;= 5.6.6)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr></tbody></table></div><p>
            バージョン 2 バイナリログ行イベントを MySQL 5.6.6 以降で使用できます。ただし、バージョン 2 イベントは前の MySQL Server リリースで読み取れません。このオプションを 1 に設定することで、<span class="command"><strong>mysqld</strong></span> はバージョン 1 ロギングイベント （これが、以前のリリースで使用されるバイナリログイベントの唯一のバージョン） を使用してバイナリログを書き込み、古いスレーブで読み取れるバイナリログを生成します。<code class="option">--log-bin-use-v1-row-events</code> を 0 (デフォルト) に設定することで、<span class="command"><strong>mysqld</strong></span> はバージョン 2 バイナリログイベントを使用します。
          </p><p>
            このオプションに使用される値は、読み取り専用 <code class="literal">log_bin_use_v1_row_events</code> システム変数から取得できます。
          </p><p>
            <code class="option">--log-bin-use-v1-row-events</code> は主に、<code class="literal">NDB$EPOCH_TRANS()</code> (バージョン 2 バイナリログ行イベントが必要) を競合検出関数として使用してレプリケーション競合検出および解決をセットアップするときに役立ちます。したがって、このオプションと <code class="option">--ndb-log-transaction-id</code> は互換性がありません。
          </p><p>
            詳細は、<a class="xref" href="mysql-cluster.html#mysql-cluster-replication-conflict-resolution" title="18.6.11 MySQL Cluster レプリケーションの競合解決">セクション18.6.11「MySQL Cluster レプリケーションの競合解決」</a>を参照してください。
          </p></li><li class="listitem"><p>


            <a class="indexterm" name="idm139979049695568"></a> <a class="indexterm" name="idm139979049693360"></a> <code class="option">--log-short-format</code>
          </p><div class="informaltable"><table summary="Options for log-short-format" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--log-short-format</code></td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">FALSE</code></td></tr></tbody></table></div><p>
            バイナリログおよびスロークエリーログがアクティブ化されている場合、これらのログに記録する情報を少なくします。
          </p></li></ul></div><p><b>ステートメント選択オプション </b>
          次のリスト内のオプションは、どのステートメントがバイナリログに書き込まれ、レプリケーションマスターサーバーによってそのスレーブに送られるかを制御します。マスターから受け取ったステートメントのどれを実行または無視すべきかを制御する、スレーブサーバーのオプションもあります。詳細については、<a class="xref" href="replication.html#replication-options-slave" title="17.1.4.3 レプリケーションスレーブのオプションと変数">セクション17.1.4.3「レプリケーションスレーブのオプションと変数」</a>を参照してください。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="option_mysqld_binlog-do-db"></a>
            <a class="indexterm" name="idm139979049674112"></a> <a class="indexterm" name="idm139979049671952"></a> <code class="option">--binlog-do-db=<em class="replaceable"><code>db_name</code></em></code>
          </p><div class="informaltable"><table summary="Options for binlog-do-db" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--binlog-do-db=name</code></td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr></tbody></table></div><p>
            このオプションは、<code class="option">--replicate-do-db</code> がレプリケーションに影響するのと同様にバイナリロギングに影響します。
          </p><p>
            このオプションの影響は、ステートメントベースまたは行ベースロギング形式のどちらが使用されるかに依存します (<code class="option">--replicate-do-db</code> の影響がステートメントベースまたは行ベースレプリケーションのどちらが使用されたかに依存すると同じ)。指定されたステートメントのログを記録するために使用される形式が、<code class="literal">binlog_format</code> の値で示される形式と必ずしも同じではないことに留意してください。たとえば、<code class="literal">CREATE TABLE</code> や <code class="literal">ALTER TABLE</code> などの DDL ステートメントは、有効になっているロギング形式にかかわらず、常にステートメントとしてログが記録されるため、<code class="option">--binlog-do-db</code> の次のステートメントベースルールはステートメントのログが記録されるかどうかの判断に常に適用されます。
          </p><p><b>ステートメントベースのロギング </b>
              デフォルトデータベース (つまり、<code class="literal">USE</code> で選択されたもの) が <em class="replaceable"><code>db_name</code></em> であるステートメントだけが、バイナリログに書き込まれます。複数のデータベースを指定するには、このオプションを複数回 （データベースごとに 1 回） 使用します。ただし、このようにしても、別のデータベースが選択されているとき （またはデータベースが選択されていないとき） に、<code class="literal">UPDATE <em class="replaceable"><code>some_db.some_table</code></em> SET foo='bar'</code> などのクロスデータベースステートメントのログは記録<span class="emphasis"><em>されません</em></span>。
            </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
              複数のデータベースを指定するには、このオプションの複数インスタンスを使用する<span class="emphasis"><em>必要があります</em></span>。データベース名にカンマを含めることができるため、カンマ区切りリストを指定した場合は、リストは単一データベースの名前として扱われます。
            </p></div><p>
            ステートメントベースロギングを使用するときに想定される、機能しない例: サーバーが <code class="option">--binlog-do-db=sales</code> で起動され、次のステートメントを発行する場合、<code class="literal">UPDATE</code> ステートメントのログは記録<span class="emphasis"><em>されません</em></span>。
          </p><pre class="programlisting">
USE prices;
UPDATE sales.january SET amount=amount+1000;
</pre><p>
            この<span class="quote">「<span class="quote">デフォルトデータベースをチェックするだけ</span>」</span>動作の主な理由は、ステートメントだけから複製すべきかどうかを知ることが難しいことです (たとえば、複数のデータベースをまたがって動作する複数テーブル <code class="literal">DELETE</code> ステートメントまたは複数テーブル <code class="literal">UPDATE</code> ステートメントを使用する場合)。また、必要がない場合、すべてのデータベースではなくデフォルトデータベースだけをチェックする方が早いです。
          </p><p>
            もう 1 つのケースは自明ではないかもしれませんが、オプションを設定するときに指定されなかったけれども所定のデータベースが複製されます。サーバーが <code class="option">--binlog-do-db=sales</code> で起動される場合、<code class="option">--binlog-do-db</code> の設定時に <code class="literal">prices</code> が含まれなかったけれども、次の <code class="literal">UPDATE</code> ステートメントのログが記録されます。
          </p><pre class="programlisting">          
USE sales;
UPDATE prices.discounts SET percentage = percentage + 10;
</pre><p>
            <code class="literal">UPDATE</code> ステートメントが発行されたときに <code class="literal">sales</code> がデフォルトデータベースであるため、<code class="literal">UPDATE</code> のログが記録されます。
          </p><p><b>行ベースのロギング </b>
              ロギングはデータベース <em class="replaceable"><code>db_name</code></em> に制限されます。<em class="replaceable"><code>db_name</code></em> に属するテーブルへの変更だけがログに記録されます。デフォルトデータベースはこれに影響しません。サーバーが <code class="option">--binlog-do-db=sales</code> で起動され、行ベースロギングが有効であると想定すると、次のステートメントが実行されます。
            </p><pre class="programlisting">
USE prices;
UPDATE sales.february SET amount=amount+100;
</pre><p>
            <code class="literal">sales</code> データベース内の <code class="literal">february</code> テーブルへの変更が、<code class="literal">UPDATE</code> ステートメントに従ってログに記録されます。これは <code class="literal">USE</code> ステートメントが発行されたかどうかにかかわらず発生します。ただし、行ベースロギング形式および <code class="option">--binlog-do-db=sales</code> を使用するときは、次の <code class="literal">UPDATE</code> によって行われた変更のログは記録されません。
          </p><pre class="programlisting">
USE prices;
UPDATE prices.march SET amount=amount-25;
</pre><p>
            <code class="literal">USE prices</code> ステートメントが <code class="literal">USE sales</code> に変更された場合でも、<code class="literal">UPDATE</code> ステートメントの結果は依然としてバイナリログに書き込まれません。
          </p><p>
            <code class="option">--binlog-do-db</code> 処理でステートメントベースロギングと行ベースロギング間のもう 1 つの重要な違いは、複数のデータベースを参照するステートメントに関して発生します。サーバーが <code class="option">--binlog-do-db=db1</code> で起動され、次のステートメントが実行されると想定します。
          </p><pre class="programlisting">
USE db1;
UPDATE db1.table1 SET col1 = 10, db2.table2 SET col2 = 20;
</pre><p>
            ステートメントベースロギングを使用している場合、両方のテーブルへの更新がバイナリログに書き込まれます。一方、行ベース形式を使用するときは、<code class="literal">table1</code> への変更だけがログに記録されます。<code class="literal">table2</code> は別のデータベース内にあり、<code class="literal">UPDATE</code> によって変更されません。ここで、<code class="literal">USE db1</code> ステートメントの代わりに、<code class="literal">USE db4</code> ステートメントが使用されたものとします。
          </p><pre class="programlisting">
USE db4;
UPDATE db1.table1 SET col1 = 10, db2.table2 SET col2 = 20;
</pre><p>
            この場合、ステートメントベースロギングを使用するときに <code class="literal">UPDATE</code> ステートメントはバイナリログに書き込まれません。一方、行ベースロギングを使用するときは、<code class="literal">table1</code> への変更のログは記録されますが、<code class="literal">table2</code> へはそうなりません。つまり、<code class="option">--binlog-do-db</code> によって指定されたデータベース内のテーブルへの変更のみがログに記録され、デフォルトデータベースの選択はこの動作に影響しません。
          </p></li><li class="listitem"><p><a name="option_mysqld_binlog-ignore-db"></a>
            <a class="indexterm" name="idm139979049600880"></a> <a class="indexterm" name="idm139979049598720"></a> <code class="option">--binlog-ignore-db=<em class="replaceable"><code>db_name</code></em></code>
          </p><div class="informaltable"><table summary="Options for binlog-ignore-db" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--binlog-ignore-db=name</code></td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr></tbody></table></div><p>
            このオプションは、<code class="option">--replicate-ignore-db</code> がレプリケーションに影響するように、バイナリロギングに影響します。
          </p><p>
            このオプションの影響は、ステートメントベースまたは行ベースロギング形式のどちらが使用されるかに依存します (<code class="option">--replicate-ignore-db</code> の影響がステートメントベースまたは行ベースレプリケーションのどちらが使用されたかに依存すると同じ)。指定されたステートメントのログを記録するために使用される形式が、<code class="literal">binlog_format</code> の値で示される形式と必ずしも同じではないことに留意してください。たとえば、<code class="literal">CREATE TABLE</code> や <code class="literal">ALTER TABLE</code> などの DDL ステートメントは、有効になっているロギング形式にかかわらず、常にステートメントとしてログが記録されるため、<code class="option">--binlog-ignore-db</code> の次のステートメントベースルールはステートメントのログが記録されるかどうかの判断に常に適用されます。
          </p><p><b>ステートメントベースのロギング </b>
              デフォルトデータベース (つまり、<code class="literal">USE</code> で選択されたもの) が <em class="replaceable"><code>db_name</code></em> であるステートメントのログを記録しないようにサーバーに指示します。
            </p><p>
            MySQL 5.6.12 より前は、このオプションにより、デフォルトデータベースが指定されなかった場合 (つまり、<code class="literal">SELECT</code> <code class="literal">DATABASE()</code> が <code class="literal">NULL</code> を返したとき) は、完全修飾テーブル名を含むステートメントのログを記録しませんでした。MySQL 5.6.12 以降では、デフォルトデータベースがないときは、<code class="option">--binlog-ignore-db</code> オプションは適用されず、常にこのようなステートメントのログが記録されます。(Bug #11829838、Bug #60188)
          </p><p><b>行ベース形式 </b>
              データベース <em class="replaceable"><code>db_name</code></em> 内のテーブルへの更新のログを記録しないようにサーバーに指示します。現在のデータベースは影響しません。
            </p><p>
            ステートメントベースロギングを使用するとき、次の例は予期するとおりに機能しません。サーバーが <code class="option">--binlog-ignore-db=sales</code> で起動され、次のステートメントを発行すると想定します。
          </p><pre class="programlisting">
USE prices;
UPDATE sales.january SET amount=amount+1000;
</pre><p>
            <code class="option">--binlog-ignore-db</code> がデフォルトデータベース (<code class="literal">USE</code> ステートメントで決定) にのみ適用されるため、このような場合は <code class="literal">UPDATE</code> ステートメントのログが記録され<span class="emphasis"><em>ます</em></span>。<code class="literal">sales</code> データベースがステートメントで明示的に指定されたため、ステートメントはフィルタされませんでした。一方、行ベースロギングを使用するときは、<code class="literal">UPDATE</code> ステートメントの結果はバイナリログに<span class="emphasis"><em>書き込まれず</em></span>、これは <code class="literal">sales.january</code> テーブルへの変更がログに記録されないことを意味します。この例では、<code class="option">--binlog-ignore-db=sales</code> によって、マスターの <code class="literal">sales</code> データベースのコピー内のテーブルに加えられた<span class="emphasis"><em>すべての</em></span>変更がバイナリロギングのために無視されます。
          </p><p>
            無視するデータベースを複数指定するには、このオプションを複数回 (データベースごとに 1 回) 使用します。データベース名にカンマを含めることができるため、カンマ区切りリストを指定した場合は、リストは単一データベースの名前として扱われます。
          </p><p>
            クロスデータベース更新を使用していて、それらの更新ログを記録したくない場合は、このオプションを使用しないでください。
          </p></li></ul></div><p><b>チェックサムオプション </b>
          MySQL 5.6.2 以降では、MySQL はバイナリログチェックサムの読み取りと書き込みをサポートします。これらは、ここで示す 2 つのオプションを使用して有効化されます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="option_mysqld_binlog-checksum"></a>
            <a class="indexterm" name="idm139979049552208"></a> <a class="indexterm" name="idm139979049550048"></a> <code class="option">--binlog-checksum={NONE|CRC32}</code>
          </p><div class="informaltable"><table summary="Options for binlog-checksum" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.2</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--binlog-checksum=type</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (&lt;= 5.6.5)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">NONE</code></td></tr><tr><td scope="row" rowspan="2" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">NONE</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">CRC32</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (&gt;= 5.6.6)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">CRC32</code></td></tr><tr><td scope="row" rowspan="2" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">NONE</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">CRC32</code></td></tr></tbody></table></div><p>
            このオプションを有効にすることで、マスターはバイナリログに書き込まれるイベントのチェックサムを書き込みます。<code class="literal">NONE</code> に設定すると無効になり、そうしない場合は、アルゴリズムの名前を使用してチェックサムが生成されます。現在のところ、CRC32 チェックサムだけがサポートされます。MySQL 5.6.6 以降では、CRC32 がデフォルトです。
          </p><p>
            このオプションは MySQL 5.6.2 で追加されました。
          </p></li><li class="listitem"><p><a name="option_mysqld_master-verify-checksum"></a>
            <a class="indexterm" name="idm139979049515840"></a> <a class="indexterm" name="idm139979049513600"></a> <code class="option">--master-verify-checksum={0|1}</code>
          </p><div class="informaltable"><table summary="Options for master-verify-checksum" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.2</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--master-verify-checksum=name</code></td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr></tbody></table></div><p>
            このオプションを有効にすることで、マスターはチェックサムを使用してバイナリログからのイベントを検証し、不一致の場合はエラーで停止します。デフォルトで無効になっています。
          </p><p>
            このオプションは MySQL 5.6.2 で追加されました。
          </p></li></ul></div><p>
        スレーブ （リレーから） ログによるチェックサム読み取りを制御するには、<code class="option">--slave-sql-verify-checksum</code> オプションを使用します。
      </p><p><b>テストおよびデバッグのオプション </b>
          次のバイナリログオプションは、レプリケーションテストおよびデバッグで使用されます。これらは通常操作での使用を意図していません。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="option_mysqld_max-binlog-dump-events"></a>
            <a class="indexterm" name="idm139979049490512"></a> <a class="indexterm" name="idm139979049488272"></a> <code class="option">--max-binlog-dump-events=<em class="replaceable"><code>N</code></em></code>
          </p><div class="informaltable"><table summary="Options for max-binlog-dump-events" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--max-binlog-dump-events=#</code></td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr></tbody></table></div><p>
            このオプションは、レプリケーションのテストとデバッグのために、MySQL テストスイートで内部的に使用されます。
          </p></li><li class="listitem"><p><a name="option_mysqld_sporadic-binlog-dump-fail"></a>
            <a class="indexterm" name="idm139979049471744"></a> <a class="indexterm" name="idm139979049469504"></a> <code class="option">--sporadic-binlog-dump-fail</code>
          </p><div class="informaltable"><table summary="Options for sporadic-binlog-dump-fail" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--sporadic-binlog-dump-fail</code></td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">FALSE</code></td></tr></tbody></table></div><p>
            このオプションは、レプリケーションのテストとデバッグのために、MySQL テストスイートで内部的に使用されます。
          </p></li><li class="listitem"><p><a name="option_mysqld_binlog-rows-query-log-events"></a>
            <a class="indexterm" name="idm139979049453152"></a> <a class="indexterm" name="idm139979049450960"></a> <code class="option">--binlog-rows-query-log-events</code>
          </p><div class="informaltable"><table summary="Options for binlog-rows-query-log-events" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.2</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--binlog-rows-query-log-events</code></td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">FALSE</code></td></tr></tbody></table></div><p>
            このオプションは MySQL 5.6.2 で追加され、<code class="literal">binlog_rows_query_log_events</code> を有効にします。MySQL 5.6.1 以前のスレーブサーバーまたは <span class="command"><strong>mysqlbinlog</strong></span> のバージョンのためにログを生成するときは、<code class="literal">OFF</code> (デフォルト) に設定する必要があります。
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="replication-sysvars-binlog"></a>バイナリロギングで使用されるシステム変数</h5></div></div></div><p>
        次の一覧で、バイナリロギングを制御するためのシステム変数について説明します。これらはサーバー起動時に設定でき、それらの一部は <code class="literal">SET</code> を使用して実行時に変更できます。バイナリロギングを制御するために使用されるサーバーオプションは、このセクションですでにリストされています。<code class="literal">sql_log_bin</code> および <code class="literal">sql_log_off</code> 変数については、<a class="xref" href="server-administration.html#server-system-variables" title="5.1.4 サーバーシステム変数">セクション5.1.4「サーバーシステム変数」</a>を参照してください。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="sysvar_binlog_cache_size"></a>
            <a class="indexterm" name="idm139979049423296"></a> <a class="indexterm" name="idm139979049421776"></a> <code class="literal">binlog_cache_size</code>
          </p><div class="informaltable"><table summary="Options for binlog_cache_size" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--binlog_cache_size=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_binlog_cache_size">binlog_cache_size</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (32 ビットプラットフォーム)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">32768</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">4096</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">4294967295</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (64 ビットプラットフォーム)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">32768</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">4096</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">18446744073709551615</code></td></tr></tbody></table></div><p>
            トランザクション中にバイナリログへの変更を保持するキャッシュのサイズ。サーバーがトランザクションストレージエンジンをサポートし、サーバーのバイナリログが有効 (<code class="option">--log-bin</code> オプション) になっている場合は、バイナリログキャッシュがクライアントごとに割り当てられます。大きなトランザクションをよく使用する場合、パフォーマンスを向上するためにこのキャッシュサイズを増やすことができます。<code class="literal">Binlog_cache_use</code> および <code class="literal">Binlog_cache_disk_use</code> ステータス変数は、この変数のサイズを調整するために役立つことがあります。<a class="xref" href="server-administration.html#binary-log" title="5.2.4 バイナリログ">セクション5.2.4「バイナリログ」</a>を参照してください。
          </p><p>
            <code class="literal">binlog_cache_size</code> はトランザクションキャッシュのみのサイズを設定します。ステートメントキャッシュのサイズは <code class="literal">binlog_stmt_cache_size</code> システム変数によって管理されます。
          </p></li><li class="listitem"><p><a name="sysvar_binlog_checksum"></a>
            <a class="indexterm" name="idm139979049376080"></a> <a class="indexterm" name="idm139979049374576"></a> <code class="literal">binlog_checksum</code>
          </p><div class="informaltable"><table summary="Options for binlog_checksum" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.2</td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_binlog_checksum">binlog_checksum</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (&lt;= 5.6.5)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">NONE</code></td></tr><tr><td scope="row" rowspan="2" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">NONE</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">CRC32</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (&gt;= 5.6.6)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">CRC32</code></td></tr><tr><td scope="row" rowspan="2" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">NONE</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">CRC32</code></td></tr></tbody></table></div><p>
            この変数が有効のときは、マスターはバイナリログに各イベントのチェックサムを書き込みます。<code class="literal">binlog_checksum</code> は値 <code class="literal">NONE</code> (無効) および <code class="literal">CRC32</code> をサポートします。デフォルトは MySQL 5.6.6 以降では<code class="literal">CRC32</code>、それより前は <code class="literal">NONE</code> です。
          </p><p>
            <code class="literal">binlog_checksum</code> が無効 (値 <code class="literal">NONE</code>) のときは、サーバーは各イベントのイベント長 （チェックサムではなく） を書き込んでチェックすることで、すべてそろったイベントのみをバイナリログに書き込んでいることを検証します。
          </p><p>
            この変数の値を変更すると、バイナリログがローテーションします。チェックサムは常にバイナリログファイル全体に (その一部だけにではなく) 書き込まれます。
          </p><p>
            この変数は MySQL 5.6.2 で追加されました。
          </p><p>
            MySQL 5.6.6 以降では、マスター上のこの変数をスレーブで認識されない値に設定すると、スレーブは独自の <code class="literal">binlog_checksum</code> 値を <code class="literal">NONE</code> に設定し、レプリケーションをエラーで停止します。(Bug #13553750、Bug #61096) 古いスレーブとの下位互換性が懸念される場合は、明示的に値を <code class="literal">NONE</code> に設定することをお勧めします。
          </p></li><li class="listitem"><p><a name="sysvar_binlog_direct_non_transactional_updates"></a>
            <a class="indexterm" name="idm139979049325872"></a> <a class="indexterm" name="idm139979049324272"></a> <code class="literal">binlog_direct_non_transactional_updates</code>
          </p><div class="informaltable"><table summary="Options for binlog_direct_non_transactional_updates" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--binlog_direct_non_transactional_updates[=value]</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_binlog_direct_non_transactional_updates">binlog_direct_non_transactional_updates</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル、セッション</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr></tbody></table></div><p>
            トランザクションテーブルおよび非トランザクションテーブルの両方への更新がトランザクションに含まれるときは、並列問題によってスレーブが不整合になる可能性があります。MySQL は、非トランザクションステートメントをトランザクションキャッシュに書き込むことで （コミット時にフラッシュされる）、これらのステートメント間の因果関係を維持しようとします。ただし、トランザクションに代わって非トランザクションテーブルに行われた変更がほかの接続にただちに可視になるときに、問題が起こります (これらの変更がただちにバイナリログに書き込まれない場合があるため)。
          </p><p>
            <code class="literal">binlog_direct_non_transactional_updates</code> 変数は、この問題に対する 1 つの可能な回避策を提供します。デフォルトでは、この変数は無効です。<code class="literal">binlog_direct_non_transactional_updates</code> を有効にすることで、非トランザクションテーブルへの更新が、トランザクションキャッシュではなく直接バイナリログに書き込まれます。
          </p><p>
            <span class="emphasis"><em><code class="literal">binlog_direct_non_transactional_updates</code> は、ステートメントベースバイナリロギング形式を使用して複製されるステートメントにのみ機能します。</em></span>つまり、<code class="literal">binlog_format</code> の値が <code class="literal">STATEMENT</code> のとき、または <code class="literal">binlog_format</code> が <code class="literal">MIXED</code> で、与えられたステートメントがステートメントベース形式を使用して複製されているときにのみ機能します。バイナリログ形式が <code class="literal">ROW</code> のとき、または <code class="literal">binlog_format</code> が <code class="literal">MIXED</code> に設定され、与えられたステートメントが行ベース形式で複製されるときは、この変数は効果がありません。
          </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
              この変数を有効にする前に、トランザクションおよび非トランザクションテーブルの間に依存関係がないことを確認する必要があります。このような依存関係の例は、ステートメント <code class="literal">INSERT INTO myisam_table SELECT * FROM innodb_table</code> です。そうでない場合、このようなステートメントによって、スレーブとマスターの間に相違が発生する可能性があります。
            </p></div><p>
            MySQL 5.6 では、バイナリログ形式が <code class="literal">ROW</code> または <code class="literal">MIXED</code> のとき、この変数は効果がありません。(Bug #51291)
          </p></li><li class="listitem"><p><a name="sysvar_binlog_error_action"></a>
            <a class="indexterm" name="idm139979049282832"></a> <a class="indexterm" name="idm139979049281280"></a> <code class="literal">binlog_error_action</code>
          </p><div class="informaltable"><table summary="Options for binlog_error_action" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.22</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--binlog_error_action[=value]</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_binlog_error_action">binlog_error_action</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル、セッション</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">列挙</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">IGNORE_ERROR</code></td></tr><tr><td scope="row" rowspan="2" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">IGNORE_ERROR</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">ABORT_SERVER</code></td></tr></tbody></table></div><p>
            サーバーがバイナリログに書き込みめないとき (マスターのログが不整合になり、レプリケーションスレーブが同期を失う可能性がある) に何が起きるかを制御します。以前のリリースでは、名前 <code class="literal">binlogging_impossible_mode</code> を使用していました。
          </p><p>
            MySQL 5.6 では、<code class="literal">binlog_error_action</code> のデフォルトは <code class="literal">IGNORE_ERROR</code> で、サーバーがエラーのログを記録し、ロギングを停止してから、更新の実行を継続することを意味します。これは、古いバージョンの MySQL Server との下位互換性を提供するためです。この変数を <code class="literal">ABORT_SERVER</code> に設定すると、サーバーがバイナリログに書き込めないときはロギングを停止し、シャットダウンします。これが推奨される設定です (特に複雑なレプリケーション環境で)。
          </p></li><li class="listitem"><p><a name="sysvar_binlog_format"></a>
            <a class="indexterm" name="idm139979049246416"></a> <a class="indexterm" name="idm139979049244928"></a> <code class="literal">binlog_format</code>
          </p><div class="informaltable"><table summary="Options for binlog-format" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--binlog-format=format</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_binlog_format">binlog_format</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル、セッション</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="5"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">列挙</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">STATEMENT</code></td></tr><tr><td scope="row" rowspan="3" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">ROW</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">STATEMENT</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">MIXED</code></td></tr><tr><td scope="row" rowspan="5"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">列挙</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">MIXED</code></td></tr><tr><td scope="row" rowspan="3" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">ROW</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">STATEMENT</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">MIXED</code></td></tr><tr><td scope="row" rowspan="5"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">列挙</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">MIXED</code></td></tr><tr><td scope="row" rowspan="3" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">ROW</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">STATEMENT</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">MIXED</code></td></tr><tr><td scope="row" rowspan="5"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">列挙</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">MIXED</code></td></tr><tr><td scope="row" rowspan="3" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">ROW</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">STATEMENT</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">MIXED</code></td></tr><tr><td scope="row" rowspan="5"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">列挙</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">MIXED</code></td></tr><tr><td scope="row" rowspan="3" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">ROW</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">STATEMENT</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">MIXED</code></td></tr><tr><td scope="row" rowspan="5"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">列挙</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">MIXED</code></td></tr><tr><td scope="row" rowspan="3" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">ROW</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">STATEMENT</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">MIXED</code></td></tr></tbody></table></div><p>
            この変数はバイナリロギング形式を設定し、<code class="literal">STATEMENT</code>、<code class="literal">ROW</code>、<code class="literal">MIXED</code> のいずれかが可能です。<a class="xref" href="replication.html#replication-formats" title="17.1.2 レプリケーション形式">セクション17.1.2「レプリケーション形式」</a>を参照してください。<code class="literal">binlog_format</code> は、起動時に <code class="option">--binlog-format</code> オプションで、または実行時に <code class="literal">binlog_format</code> 変数で設定されます。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              実行時にロギング形式を変更できますが、レプリケーションの進行中に変更することは推奨されていま<span class="emphasis"><em>せん</em></span>。これは一つには、スレーブがマスターの <code class="literal">binlog_format</code> 設定に従わず、所定の MySQL Server が独自のロギング形式のみを変更できるという事実によります。
            </p></div><p>
            MySQL 5.6 では、デフォルト形式は <code class="literal">STATEMENT</code> です。<span class="emphasis"><em>例外</em></span>: MySQL Cluster NDB 7.3 以降では、デフォルトは <code class="literal">MIXED</code> です。ステートメントベースレプリケーションは MySQL Cluster ではサポートされていません。
          </p><p>
            グローバルまたはセッション <code class="literal">binlog_format</code> 値を設定するには、<code class="literal">SUPER</code> 権限が必要です。
          </p><p>
            この変数への変更がいつ有効になり、影響はどのくらい長く続くかを管理するルールは、ほかの MySQL サーバーシステム変数の場合と同じです。詳細については、<a class="xref" href="sql-syntax.html#set-statement" title="13.7.4 SET 構文">セクション13.7.4「SET 構文」</a>を参照してください。
          </p><p>
            <code class="literal">MIXED</code> が指定されている場合、行ベースレプリケーションだけが適切な結果になることが保証されている場合を除き、ステートメントベースレプリケーションが使用されます。たとえば、これはユーザー定義関数 (UDF) または <code class="literal">UUID()</code> 関数がステートメントに含まれているときに発生します。このルールの例外は、<code class="literal">MIXED</code> がストアドファンクションおよびトリガーのために常にステートメントベースレプリケーションを使用することです。
          </p><p>
            レプリケーション形式を実行時に切り替えることができない例外もあります。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                ストアドファンクションまたはトリガー内から。
              </p></li><li class="listitem"><p>
                セッションが現在行ベースレプリケーションモードで、開いている一時テーブルを持つ場合。
              </p></li><li class="listitem"><p>
                トランザクション内から。
              </p></li></ul></div><p>
            これらの場合に形式を切りかえようとするとエラーになります。
          </p><p>
            バイナリログ形式は次のサーバーオプションの動作に影響を与えます。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="option">--replicate-do-db</code>
              </p></li><li class="listitem"><p>
                <code class="option">--replicate-ignore-db</code>
              </p></li><li class="listitem"><p>
                <code class="option">--binlog-do-db</code>
              </p></li><li class="listitem"><p>
                <code class="option">--binlog-ignore-db</code>
              </p></li></ul></div><p>
            これらの影響の詳細は、個々のオプションの説明に記載されています。
          </p></li><li class="listitem"><p><a name="sysvar_binlog_gtid_recovery_simplified"></a>
            <a class="indexterm" name="idm139979049128560"></a> <a class="indexterm" name="idm139979049127232"></a> <code class="literal">binlog_gtid_recovery_simplified</code>
          </p><div class="informaltable"><table summary="Options for binlog_gtid_recovery_simplified" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.23</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--binlog-gtid-recovery-simplified</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_binlog_gtid_recovery_simplified">binlog_gtid_recovery_simplified</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">FALSE</code></td></tr></tbody></table></div><p>
            MySQL バージョン 5.6.21 では、この変数は <code class="literal">simplified_binlog_gtid_recovery</code> として追加され、MySQL バージョン 5.6.23 では、その名前が <code class="literal">binlog_gtid_recovery_simplified</code> に変わりました。
          </p><p>
            デフォルトでは、MySQL はクラッシュからリカバリするときに、バイナリログファイルを反復して一番古いファイルから始めて GTID イベントを検索するため、大量のバイナリログファイルがある場合はこれに時間がかかることがあります。このオプションを有効にすることで、代わりに一番新しいバイナリログファイルから GTID イベントが検索されます。<code class="literal">Previous_gtids_log_event</code> および <code class="literal">Gtid_log_event</code> が検出されると、<code class="literal">gtid_executed</code> と <code class="literal">gtid_purged</code> はリカバリ中に通常どおりこれらのイベントを使用して初期化されます。GTID イベントが検出されない場合は、2 番目のスキャンが一番古いバイナリログファイルから GTID イベントを検索します。これらのファイルのどちらにも GTID イベントが含まれない場合は、これ以上バイナリログファイルは検索されず、<code class="literal">gtid_executed</code> と <code class="literal">gtid_purged</code> は空の文字列に設定されます。
          </p></li><li class="listitem"><p><a name="sysvar_binlogging_impossible_mode"></a>
            <a class="indexterm" name="idm139979049092544"></a> <a class="indexterm" name="idm139979049091088"></a> <code class="literal">binlogging_impossible_mode</code>
          </p><div class="informaltable"><table summary="Options for binlogging_impossible_mode" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.20</td></tr><tr><td scope="row"><span class="bold"><strong>非推奨</strong></span></td><td colspan="3">5.6.22</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--binlogging_impossible_mode[=value]</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_binlogging_impossible_mode">binlogging_impossible_mode</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル、セッション</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">列挙</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">IGNORE_ERROR</code></td></tr><tr><td scope="row" rowspan="2" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">IGNORE_ERROR</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">ABORT_SERVER</code></td></tr></tbody></table></div><p>
            このオプションは非推奨で、今後の MySQL リリースで削除される予定です。名前が変更された <code class="literal">binlog_error_action</code> を使用して、サーバーがバイナリログに書き込めないときに何が起きるかを制御してください。
          </p></li><li class="listitem"><p><a name="sysvar_binlog_max_flush_queue_time"></a>
            <a class="indexterm" name="idm139979049057904"></a> <a class="indexterm" name="idm139979049056432"></a> <code class="literal">binlog_max_flush_queue_time</code>
          </p><div class="informaltable"><table summary="Options for binlog_max_flush_queue_time" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.6</td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_binlog_max_flush_queue_time">binlog_max_flush_queue_time</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">100000</code></td></tr></tbody></table></div><p>
            グループコミットを進める前にフラッシュキューからのトランザクション読み取り (および、<code class="literal">sync_binlog</code> が 0 より大きい場合はログとディスクの同期) をどのくらい続けるか (マイクロ秒単位)。値が 0 (デフォルト) の場合、タイムアウトはなく、キューが空になるまでサーバーは新しいトランザクションの読み取りを続けます。
          </p><p>
            通常、<code class="literal">binlog_max_flush_queue_time</code> を 0 に設定されたままでかまいません。サーバーが大量の接続 (たとえば、100 以上)、および低遅延要件の多くの短いトランザクションを処理する場合、0 より大きな値を設定して、ディスクへのフラッシュを強制的により頻繁にすることが役立つ場合があります。
          </p><p>
            この変数は MySQL 5.6.6 で追加されました。
          </p></li><li class="listitem"><p><a name="sysvar_binlog_order_commits"></a>
            <a class="indexterm" name="idm139979049024160"></a> <a class="indexterm" name="idm139979049022608"></a> <code class="literal">binlog_order_commits</code>
          </p><div class="informaltable"><table summary="Options for binlog_order_commits" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.6</td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_binlog_order_commits">binlog_order_commits</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">ON</code></td></tr></tbody></table></div><p>
            この変数が有効の場合は (デフォルト)、トランザクションはバイナリログに書き込まれる順序と同じ順序でコミットされます。無効の場合は、トランザクションは並列にコミットされる場合があります。場合によっては、この変数を無効にすることでパフォーマンスが向上することがあります。
          </p><p>
            この変数は MySQL 5.6.6 で追加されました。
          </p></li><li class="listitem"><p><a name="sysvar_binlog_row_image"></a>
            <a class="indexterm" name="idm139979048998272"></a> <a class="indexterm" name="idm139979048996768"></a> <code class="literal">binlog_row_image</code>
          </p><div class="informaltable"><table summary="Options for binlog_row_image" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.2</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--binlog-row-image=image_type</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal">binlog_row_image=image_type</code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル、セッション</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="5"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">列挙</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">full</code></td></tr><tr><td scope="row" rowspan="3" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">full</code> (すべてのカラムをログに記録)</td></tr><tr><td scope="row" colspan="2"><code class="literal">minimal</code> (変更されたカラムおよび、行を特定するために必要とされたカラムのみをログに記録)</td></tr><tr><td scope="row" colspan="2"><code class="literal">noblob</code> (不要な BLOB カラムおよび TEXT カラム以外のすべてのカラムをログに記録)</td></tr></tbody></table></div><p>
            MySQL 行ベースレプリケーションでは、各行変更イベントに 2 つのイメージ、つまり<span class="quote">「<span class="quote">前</span>」</span>イメージ (更新される行を検索するときにこれらのカラムが照合される) と<span class="quote">「<span class="quote">後</span>」</span>イメージ (変更を含む) が含まれます。通常、MySQL は前イメージと後イメージの両方のためにすべての行 （つまり、すべてのカラム） のログを記録します。ただし、両方のイメージにすべてのカラムが厳密に含まれている必要はなく、多くの場合、実際に必要なカラムのログのみを記録することでディスク、メモリー、およびネットワーク使用量を節約できます。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              行を削除するときは、削除後に伝達する変更後の値がないため、前イメージのみのログが記録されます。行を挿入するときは、照合される既存の行がないため、後イメージのみのログが記録されます。行を更新するときのみ、前イメージと後イメージの両方が必要で、両方がバイナリログに書き込まれます。
            </p></div><p>
            前イメージについては、行を一意に識別するために必要な最小カラムセットのログが記録されることのみが必要です。行を含むテーブルに主キーがある場合、主キーカラムだけがバイナリログに書き込まれます。そうではなく、テーブルに一意キーがあり、そのカラムのすべてが <code class="literal">NOT NULL</code> の場合は、一意キー内のカラムのログのみを記録する必要があります。(テーブルに <code class="literal">NULL</code> カラムなしの主キーまたは一意キーがない場合、すべてのカラムが前イメージで使用され、それらのログが記録される必要があります。)後イメージでは、実際に変更されたカラムのログのみを記録する必要があります。
          </p><p>
            MySQL 5.6 ではサーバーに、<code class="literal">binlog_row_image</code> システム変数を使用して full または minimal 行のログを記録させることができます。この変数は実際には、次のリストで示す 3 つの可能な値の 1 つを取ることができます。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">full</code>: 前イメージと後イメージの両方にすべてのカラムのログを記録します。
              </p></li><li class="listitem"><p>
                <code class="literal">minimal</code>: 変更する行を識別するために必要なカラムのみのログを前イメージに記録し、実際に変更されるカラムのみのログを後イメージに記録します。
              </p></li><li class="listitem"><p>
                <code class="literal">noblob</code>: すべてのカラム (<code class="literal">full</code> と同じ) のログを記録しますが、行の識別に必要がない、または変更されなかった <code class="literal">BLOB</code> および <code class="literal">TEXT</code> カラムは除きます。
              </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              この変数は MySQL Cluster ではサポートされません。設定しても <code class="literal">NDB</code> テーブルのロギングには影響しません。(Bug #16316828)
            </p></div><p>
            デフォルト値は <code class="literal">full</code> です。MySQL 5.5 以前は、前イメージと後イメージの両方に常に full 行イメージが使用されます。MySQL 5.6 以降のマスターから以前のバージョンの MySQL を実行するからスレーブに複製する必要がある場合、マスターは常にこの値を使用してください。
          </p><p>
            <code class="literal">minimal</code> または <code class="literal">noblob</code> を使用するときは、ソーステーブルと宛先テーブルの両方について次の条件が true の場合にのみ、所定のテーブルに対して削除と更新が正しく機能することが保証されます。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                すべてのカラムが同じ順番で存在する必要があります。それぞれのカラムがもう一方のテーブル内の対応するものと同じデータ型を使用する必要があります。
              </p></li><li class="listitem"><p>
                これらのテーブルの主キー定義が同じである必要があります。
              </p></li></ul></div><p>
            (つまり、これらのテーブルは同じである必要がありますが、テーブルの主キーの一部でないインデックスがある場合にはそれらは除きます。)
          </p><p>
            これらの条件が満たされない場合は、宛先テーブル内の主キーカラム値が、削除または更新のための一意一致を提供するために不十分であることが判明する場合があります。この場合、警告またはエラーは発行されません。マスターとスレーブはサイレントに相違し、一貫性がなくなります。
          </p><p>
            バイナリロギング形式が <code class="literal">STATEMENT</code> のときは、この変数を設定しても効果はありません。<code class="literal">binlog_format</code> が <code class="literal">MIXED</code> のときは、<code class="literal">binlog_row_image</code> の設定は行ベース形式を使用してログが記録される変更に適用されますが、この設定はステートメントとしてログが記録される変更には影響しません。
          </p><p>
            グローバルまたはセッションレベルのいずれかで <code class="literal">binlog_row_image</code> を設定しても、暗黙的にコミットされません。これは、トランザクションの進行中にトランザクションに影響を与えずにこの変数を変更できることを意味します。
          </p></li><li class="listitem"><p><a name="sysvar_binlog_rows_query_log_events"></a>
            <a class="indexterm" name="idm139979048931600"></a> <a class="indexterm" name="idm139979048930128"></a> <code class="literal">binlog_rows_query_log_events</code>
          </p><div class="informaltable"><table summary="Options for binlog_rows_query_log_events" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.2</td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_binlog_rows_query_log_events">binlog_rows_query_log_events</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル、セッション</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">FALSE</code></td></tr></tbody></table></div><p>
            <code class="literal">binlog_rows_query_log_events</code> システム変数は行ベースロギングにのみ影響します。有効のときは、MySQL 5.6.2 以降のサーバーは行クエリーログイベントなどの情報ログイベントをそのバイナリログに書き込みます。この情報は、デバッグおよび関連する目的 (マスター上で発行された元のクエリーを行更新から再構成できないときにそのクエリーを取得する、など) のために使用できます。
          </p><p>
            これらのイベントは通常、バイナリログを読み取る MySQL 5.6.2 以降のプログラムで無視されるため、レプリケーションまたはバックアップからのリストア時に問題は発生しません。これは、MySQL 5.6.1 以前の <span class="command"><strong>mysqld</strong></span> または <span class="command"><strong>mysqlbinlog</strong></span> では true ではありません。ログを読み取る古いバージョンのプログラムが情報ログイベントに遭遇すると、それは失敗し、その時点で読み取りを停止します。MySQL 5.6.1 以前の配布からのスレーブレプリケーション MySQL サーバーおよびその他のリーダー (たとえば、<span class="command"><strong>mysqlbinlog</strong></span>) がバイナリログを読み取れるようにするには、ログ記録中は <code class="literal">binlog_rows_query_log_events</code> を無効にする必要があります。
          </p></li><li class="listitem"><p><a name="sysvar_binlog_stmt_cache_size"></a>
            <a class="indexterm" name="idm139979048900400"></a> <a class="indexterm" name="idm139979048898848"></a> <code class="literal">binlog_stmt_cache_size</code>
          </p><div class="informaltable"><table summary="Options for binlog_stmt_cache_size" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.1</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--binlog_stmt_cache_size=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_binlog_stmt_cache_size">binlog_stmt_cache_size</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (32 ビットプラットフォーム)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">32768</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">4096</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">4294967295</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (64 ビットプラットフォーム)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">32768</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">4096</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">18446744073709551615</code></td></tr></tbody></table></div><p>
            この変数は、トランザクション中に発行される非トランザクションステートメントを保持するバイナリログログ用キャッシュのサイズを決定します。サーバーがトランザクションストレージエンジンをサポートし、かつサーバーでバイナリログが有効 （<code class="option">--log-bin</code> オプション） になっている場合は、個別のバイナリログトランザクションおよびステートメントキャッシュが各クライアントに割り当てられます。トランザクション中に大きな非トランザクションステートメントを頻繁に使用する場合は、このキャッシュサイズを増やしてパフォーマンスを向上させることができます。<code class="literal">Binlog_stmt_cache_use</code> および <code class="literal">Binlog_stmt_cache_disk_use</code> ステータス変数は、この変数のサイズを調整する場合に役立つ場合があります。<a class="xref" href="server-administration.html#binary-log" title="5.2.4 バイナリログ">セクション5.2.4「バイナリログ」</a>を参照してください。
          </p><p>
            <code class="literal">binlog_cache_size</code> システム変数はトランザクションキャッシュのサイズを設定します。
          </p></li><li class="listitem"><p><a name="sysvar_log_bin"></a>
            <a class="indexterm" name="idm139979048852096"></a> <a class="indexterm" name="idm139979048850624"></a> <code class="literal">log_bin</code>
          </p><div class="informaltable"><table summary="Options for log_bin" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_log_bin">log_bin</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr></tbody></table></div><p>
            バイナリログが有効かどうか。<code class="option">--log-bin</code> オプションが使用されている場合、この変数の値は <code class="literal">ON</code> です。そうでない場合、<code class="literal">OFF</code> です。この変数は、バイナリロギングのステータス (有効または無効) についてのみ報告します。<code class="option">--log-bin</code> が設定されている値を実際に報告するわけではありません。
          </p><p>
            <a class="xref" href="server-administration.html#binary-log" title="5.2.4 バイナリログ">セクション5.2.4「バイナリログ」</a>を参照してください。
          </p></li><li class="listitem"><p><a name="sysvar_log_bin_basename"></a>
            <a class="indexterm" name="idm139979048830240"></a> <a class="indexterm" name="idm139979048828736"></a> <code class="literal">log_bin_basename</code>
          </p><div class="informaltable"><table summary="Options for log_bin_basename" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.2</td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_log_bin_basename">log_bin_basename</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ファイル名</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">datadir + '/' + hostname + '-bin'</code></td></tr></tbody></table></div><p>
            バイナリログファイルの名前と完全パスを保持します。<code class="literal">log_bin</code> システム変数とは異なり、<code class="literal">log_bin_basename</code> は <code class="option">--log-bin</code> サーバーオプションで設定される名前を反映します。
          </p><p>
            <code class="literal">log_bin_basename</code> システム変数は MySQL 5.6.2 で追加されました。
          </p></li><li class="listitem"><p><a name="sysvar_log_bin_index"></a>
            <a class="indexterm" name="idm139979048800928"></a> <a class="indexterm" name="idm139979048799424"></a> <code class="literal">log_bin_index</code>
          </p><div class="informaltable"><table summary="Options for log_bin_index" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.4</td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_log_bin_index">log_bin_index</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ファイル名</code></td></tr></tbody></table></div><p>
            バイナリログファイル名のインデックスファイル。
          </p><p>
            <code class="literal">log_bin_index</code> システム変数は MySQL 5.6.4 で追加されました。
          </p></li><li class="listitem"><p><a name="sysvar_log_bin_use_v1_row_events"></a>
            <a class="indexterm" name="idm139979048776736"></a> <a class="indexterm" name="idm139979048775264"></a> <code class="literal">log_bin_use_v1_row_events</code>
          </p><div class="informaltable"><table summary="Options for log_bin_use_v1_row_events" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.6</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--log-bin-use-v1-row-events[={0|1}]</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_log_bin_use_v1_row_events">log_bin_use_v1_row_events</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span> (&gt;= 5.6.6)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr></tbody></table></div><p>
            MySQL 5.6.6 以降で使用可能なバージョン 2 バイナリロギングが使用されているかどうかを示します。値 1 は、サーバーがバージョン 1 ロギングイベント （MySQL 5.6.5 および以前の MySQL Server リリースで使用されるバイナリログイベントの唯一のバージョン） を使用してバイナリログを書き出していて、古いスレーブで読み取れるバイナリログを生成していることを示します。値 0 は、バージョン 2 バイナリログイベントが使用されていることを示します。
          </p><p>
            この変数は読み取り専用です。バージョン 1 および バージョン 2 バイナリイベントバイナリロギングを切りかえるには、<span class="command"><strong>mysqld</strong></span> を <code class="option">--log-bin-use-v1-row-events</code> オプションで再起動する必要があります。
          </p><p>
            MySQL Cluster レプリケーションのアップグレードを実行するとき以外では、<code class="option">--log-bin-use-v1-events</code> は主に、<code class="literal">NDB$EPOCH_TRANS()</code> (バージョン 2 バイナリ行イベントロギングが必要) を使用してレプリケーション競合検出および解決をセットアップときに役立ちます。したがって、このオプションと <code class="option">--ndb-log-transaction-id</code> は互換性がありません。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              MySQL Cluster NDB 7.3 以降はデフォルトでバージョン 2 バイナリログ行イベントを使用します。アップグレードまたはダウングレードを計画するとき、および MySQL Cluster Replication を使用してセットアップする場合は、このことに留意してください。
            </p></div><p>
            詳細は、<a class="xref" href="mysql-cluster.html#mysql-cluster-replication-conflict-resolution" title="18.6.11 MySQL Cluster レプリケーションの競合解決">セクション18.6.11「MySQL Cluster レプリケーションの競合解決」</a>を参照してください。
          </p></li><li class="listitem"><p><a name="sysvar_log_slave_updates"></a>
            <a class="indexterm" name="idm139979048740752"></a> <a class="indexterm" name="idm139979048739200"></a> <code class="literal">log_slave_updates</code>
          </p><div class="informaltable"><table summary="Options for log_slave_updates" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--log-slave-updates</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_log_slave_updates">log_slave_updates</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">FALSE</code></td></tr></tbody></table></div><p>
            スレーブサーバーがマスターサーバーから受け取った更新のログをスレーブ独自のバイナリログに記録する必要があるかどうか。この変数を有効にするには、スレーブでバイナリロギングを有効にする必要があります。<a class="xref" href="replication.html#replication-options" title="17.1.4 レプリケーションおよびバイナリロギングのオプションと変数">セクション17.1.4「レプリケーションおよびバイナリロギングのオプションと変数」</a>を参照してください。
          </p></li><li class="listitem"><p><a name="sysvar_master_verify_checksum"></a>
            <a class="indexterm" name="idm139979048714240"></a> <a class="indexterm" name="idm139979048712720"></a> <code class="literal">master_verify_checksum</code>
          </p><div class="informaltable"><table summary="Options for master_verify_checksum" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.2</td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_master_verify_checksum">master_verify_checksum</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr></tbody></table></div><p>
            この変数を有効にすることで、マスターはバイナリログから読み取るときにチェックサムを検査します。<code class="literal">master_verify_checksum</code> はデフォルトでは無効になっています。その場合は、マスターはバイナリログからのイベント長を使用してイベントを検証するため、すべてそろったイベントだけがバイナリログから読み取られます。
          </p><p>
            この変数は MySQL 5.6.2 で追加されました。
          </p></li><li class="listitem"><p><a name="sysvar_max_binlog_cache_size"></a>
            <a class="indexterm" name="idm139979048687456"></a> <a class="indexterm" name="idm139979048685904"></a> <code class="literal">max_binlog_cache_size</code>
          </p><div class="informaltable"><table summary="Options for max_binlog_cache_size" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--max_binlog_cache_size=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_max_binlog_cache_size">max_binlog_cache_size</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">18446744073709551615</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">4096</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">18446744073709551615</code></td></tr></tbody></table></div><p>
            トランザクション内の非トランザクションステートメントがこのバイト数より多くのメモリーを必要とする場合、サーバーは<span class="errortext">Multi-statement transaction required more than 'max_binlog_cache_size' bytes of storage</span>エラーを生成します。最小値は 4096 です。可能な最大値は 16E バイト (エクサバイト) です。推奨される最大値は 4G バイトです。これは、MySQL が現在 4G バイトより大きなバイナリログ位置で作業できないという事実によります。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              MySQL 5.6.7 より前では、64 ビット Windows プラットフォームは、この変数に格納された値を 4G に切り捨てました (これより大きい値に設定されたとしても) (Bug #13961678)。
            </p></div><p>
            <code class="literal">max_binlog_cache_size</code> はトランザクションキャッシュのみのサイズを設定します。ステートメントキャッシュの上限値は <code class="literal">max_binlog_stmt_cache_size</code> システム変数によって管理されます。
          </p><p>
            MySQL 5.6 では、<code class="literal">max_binlog_cache_size</code> のセッションの可視性は <code class="literal">binlog_cache_size</code> システム変数のものと一致します。つまり、この値の変更は、値が変更されたあとに起動された新しいセッションにのみ影響します。
          </p></li><li class="listitem"><p><a name="sysvar_max_binlog_size"></a>
            <a class="indexterm" name="idm139979048650032"></a> <a class="indexterm" name="idm139979048648528"></a> <code class="literal">max_binlog_size</code>
          </p><div class="informaltable"><table summary="Options for max_binlog_size" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--max_binlog_size=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_max_binlog_size">max_binlog_size</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">1073741824</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">4096</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">1073741824</code></td></tr></tbody></table></div><p>
            バイナリログへの書き込みによって、現在のログファイルサイズがこの変数の値を超えた場合、サーバーはバイナリログをローテーションします (現在のファイルを閉じて、新しいものを開きます)。最小値は 4096 バイトです。最大値およびデフォルト値は 1G バイトです。
          </p><p>
            トランザクションはバイナリログにひとまとまりで書き込まれ、複数のバイナリログ間に分割されることはありません。このため、大きなトランザクションの場合、<code class="literal">max_binlog_size</code> より大きいバイナリログファイルが見られることがあります。
          </p><p>
            <code class="literal">max_relay_log_size</code> が 0 の場合、<code class="literal">max_binlog_size</code> の値がリレーログにも適用されます。
          </p></li><li class="listitem"><p><a name="sysvar_max_binlog_stmt_cache_size"></a>
            <a class="indexterm" name="idm139979048615264"></a> <a class="indexterm" name="idm139979048613792"></a> <code class="literal">max_binlog_stmt_cache_size</code>
          </p><div class="informaltable"><table summary="Options for max_binlog_stmt_cache_size" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.1</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--max_binlog_stmt_cache_size=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_max_binlog_stmt_cache_size">max_binlog_stmt_cache_size</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">18446744073709547520</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">4096</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">18446744073709547520</code></td></tr></tbody></table></div><p>
            トランザクション内の非トランザクションステートメントがこのバイト数より多くのメモリーを必要とする場合、サーバーはエラーを生成します。最小値は 4096 です。最大値およびデフォルト値は、32 ビットプラットフォームでは 4G バイト、64 ビットプラットフォームでは 16E バイト (エクサバイト) です。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              MySQL 5.6.7 より前では、64 ビット Windows プラットフォームは、この変数に格納された値を 4G に切り捨てました (これより大きい値に設定されたとしても) (Bug #13961678)。
            </p></div><p>
            <code class="literal">max_binlog_stmt_cache_size</code> はステートメントキャッシュのみのサイズを設定します。トランザクションキャッシュの上限値は <code class="literal">max_binlog_cache_size</code> システム変数によって排他的に管理されます。
          </p></li><li class="listitem"><p><a name="sysvar_sync_binlog"></a>
            <a class="indexterm" name="idm139979048579312"></a> <a class="indexterm" name="idm139979048577824"></a> <code class="literal">sync_binlog</code>
          </p><div class="informaltable"><table summary="Options for sync_binlog" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--sync-binlog=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_sync_binlog">sync_binlog</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (32 ビットプラットフォーム)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">4294967295</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (64 ビットプラットフォーム)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">4294967295</code></td></tr></tbody></table></div><p>
            この変数の値が 0 より大きい場合は、<code class="literal">sync_binlog</code> コミットグループがバイナリログに書き込まれたあとに、MySQL サーバーはそのバイナリログをディスクに同期します (<code class="literal">fdatasync()</code> を使用)。<code class="literal">sync_binlog</code> のデフォルト値は 0 で、これはディスクに同期しません。この場合、サーバーはオペレーティングシステムに依存して、ほかのファイルに関してバイナリログの内容をときどきフラッシュします。値 1 が一番安全な選択です (クラッシュの場合にバイナリログから失われるコミットグループが最大で 1 つです)。しかし、一番遅い選択でもあります (ディスクにバッテリ付きキャッシュがある場合を除きます。その場合は同期が非常に速くなります)。
          </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-options-gtids"></a>17.1.4.5 グローバルトランザクション ID のオプションと変数</h4></div></div></div><p>
      <a class="xref" href="replication.html#replication-optvars-gtids" title="GTID レプリケーションで使用される起動オプション">GTID レプリケーションで使用される起動オプション</a>
    </p><p>
      <a class="xref" href="replication.html#replication-sysvars-gtids" title="GTID レプリケーションで使用されるシステム変数">GTID レプリケーションで使用されるシステム変数</a>
    </p><p>
      このセクションで説明した MySQL Server オプションおよびシステム変数は、MySQL 5.6.5 で導入されたグローバルトランザクション識別子 (GTID) のモニターと制御に使用されます。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        これらのオプションと変数の多くは、MySQL 5.6.9 で名前が変わりました。詳細については、このセクションの説明を参照してください。
      </p></div><p>
      追加情報については <a class="xref" href="replication.html#replication-gtids" title="17.1.3 グローバルトランザクション識別子を使用したレプリケーション">セクション17.1.3「グローバルトランザクション識別子を使用したレプリケーション」</a>を参照してください。
    </p><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="replication-optvars-gtids"></a>GTID レプリケーションで使用される起動オプション</h5></div></div></div><p>
        次のサーバー起動オプションは GTID ベースレプリケーションで使用されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="option_mysqld_disable-gtid-unsafe-statements"></a>
            <a class="indexterm" name="idm139979048525520"></a> <a class="indexterm" name="idm139979048524160"></a> <code class="option">--disable-gtid-unsafe-statements</code>
          </p><div class="informaltable"><table summary="Options for disable-gtid-unsafe-statements" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.5</td></tr><tr><td scope="row"><span class="bold"><strong>削除</strong></span></td><td colspan="3">5.6.9</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--disable-gtid-unsafe-statements[=value]</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_disable_gtid_unsafe_statements">disable_gtid_unsafe_statements</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">false</code></td></tr></tbody></table></div><p>
            <span class="emphasis"><em>廃止</em></span>: MySQL 5.6.9 で <code class="option">--enforce-gtid-consistency</code> に置き換わりました。(Bug #14775984)
          </p></li><li class="listitem"><p><a name="option_mysqld_enforce-gtid-consistency"></a>
            <a class="indexterm" name="idm139979048495888"></a> <a class="indexterm" name="idm139979048494336"></a> <code class="option">--enforce-gtid-consistency</code>
          </p><div class="informaltable"><table summary="Options for enforce-gtid-consistency" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.9</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--enforce-gtid-consistency[=value]</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_enforce_gtid_consistency">enforce_gtid_consistency</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">false</code></td></tr></tbody></table></div><p>
            このオプションが有効のときは、トランザクションセーフな方法でログを記録できるステートメントのみの実行を許可することで、GTID 一貫性を適用します。<code class="option">--enforce-gtid-consistency</code> を有効にしてから <code class="option">--gtid-mode</code> を <code class="literal">ON</code> に設定する<span class="emphasis"><em>必要があります</em></span>。そうしないで GTID モードを有効にすると、エラーで失敗します。システムが GTID を使用する準備ができているかどうかをテストするために、<code class="option">--gtid-mode</code> を使用する<span class="emphasis"><em>前に</em></span>このオプションを使用<span class="emphasis"><em>できます</em></span> (使用する<span class="emphasis"><em>ことをお勧めします</em></span>)。
          </p><p>
            <code class="option">--enforce-gtid-consistency</code> が有効のときは、トランザクションセーフなステートメントのみのログを記録できるため、次に示す操作はこのオプションで使用できないことになります。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">CREATE TABLE ... SELECT</code> ステートメント
              </p></li><li class="listitem"><p>
                トランザクション内の <code class="literal">CREATE TEMPORARY TABLE</code> ステートメント
              </p></li><li class="listitem"><p>
                トランザクションおよび非トランザクションテーブルの両方を更新するトランザクションまたはステートメント。
              </p></li></ul></div><p>
            MySQL 5.6.9 より前では、このオプションの名前は <code class="option">--disable-gtid-unsafe-statements</code> でした。(Bug #14775984)
          </p><p>
            MySQL 5.6.7 より前では、このオプションを使用することで、一時テーブルでの非トランザクション DML が失敗しました (行ベースバイナリロギングを使用するときに一時テーブルへの変更のログが記録されない)。MySQL 5.6.7 以降では、影響されるすべてのテーブルが一時テーブルであるかぎり、<code class="option">--disable-gtid-unsafe-statements</code> (MySQL 5.6.9 以降では <code class="option">--enforce-gtid-consistency</code>) の状態で非トランザクション DML ステートメントが一時テーブルで許可されます (Bug #14272672)。
          </p><p>
            MySQL 5.6.7 より前では、<code class="option">--write-binlog</code> が明示的に無効の状態で <span class="command"><strong>mysql_upgrade</strong></span> が実行されていないかぎり、<span class="command"><strong>mysql_upgrade</strong></span> をこのオプションが有効の状態で動作する MySQL Server で使用できませんでした。(Bug #13833710、Bug #14221043) MySQL 5.6.7 以降では、<code class="option">--gtid-mode=ON</code> の状態のサーバー上で <span class="command"><strong>mysql_upgrade</strong></span> を実行できますが、推奨されていません。MySQL システムテーブルが、非トランザクションである <code class="literal">MyISAM</code> ストレージエンジンを使用するためです。
          </p><p>
            MySQL 5.6.8 以前では、<code class="option">--enforce-gtid-consistency</code> が使用されるとき (このオプションは <code class="option">--disable-gtid-unsafe-statements</code> と呼ばれていました) に、非トランザクションテーブルに影響するステートメントを使用できませんでした。MySQL 5.6.9 以降では、このオプションは非トランザクションテーブルを更新する単一ステートメントを許可します。これは主に、<span class="command"><strong>mysql_install_db</strong></span> や <span class="command"><strong>mysql_upgrade</strong></span> などのプログラムで使用されることを意図しています。(Bug #14722659)
          </p></li><li class="listitem"><p><a name="option_mysqld_gtid-mode"></a>
            <a class="indexterm" name="idm139979048443664"></a> <a class="indexterm" name="idm139979048442176"></a> <code class="option">--gtid-mode</code>
          </p><div class="informaltable"><table summary="Options for gtid-mode" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.5</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--gtid-mode=MODE</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_gtid_mode">gtid_mode</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="6"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">列挙</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr><tr><td scope="row" rowspan="4" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">UPGRADE_STEP_1</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">UPGRADE_STEP_2</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">ON</code></td></tr></tbody></table></div><p>
            このオプションは GTID が有効であるかどうかを指定します。<code class="option">--gtid-mode=ON</code> でサーバーを起動するには、サーバーも <code class="option">--log-bin</code>、<code class="option">--log-slave-updates</code>、および <code class="option">--enforce-gtid-consistency</code> オプションで起動される必要があります。
          </p><p>
            このオプションを、バイナリログまたはリレーログ内に GTID があるときに <code class="literal">OFF</code> に、または実行すべき無名トランザクションが残っているときに <code class="literal">ON</code> に設定すると、エラーになります。
          </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
              このオプションはブール値を採用しません。つまり、値は列挙されます。このオプションを設定するときに数値の使用を試みないでください。予期しない結果になることがあります。値 <code class="literal">UPGRADE_STEP_1</code> および <code class="literal">UPGRADE_STEP_2</code> は今後の使用のために予約されていますが、現在のところ本番環境ではサポートされていません。これら 2 つの値のいずれかを <code class="option">--gtid-mode</code> で使用する場合、サーバーは起動を拒否します。
            </p></div><p>
            MySQL 5.6.7 より前では、<code class="option">--write-binlog</code> が明示的に無効の状態で <span class="command"><strong>mysql_upgrade</strong></span> が実行されていないかぎり、<span class="command"><strong>mysql_upgrade</strong></span> をこのオプションが有効の状態で動作する MySQL Server で使用できませんでした。(Bug #13833710、Bug #14221043) MySQL 5.6.7 以降では、<code class="option">--gtid-mode=ON</code> の状態のサーバー上で <span class="command"><strong>mysql_upgrade</strong></span> を実行できますが、推奨されていません。非トランザクションである <code class="literal">MyISAM</code> ストレージエンジンを使用する MySQL システムテーブルに変更を加える可能性があるためです。
          </p><p>
            MySQL 5.6.10 より前では、<code class="option">--gtid-mode</code> が <code class="literal">ON</code> に設定されているときに <code class="literal">sql_slave_skip_counter</code> 変数のグローバル値を 1 に設定しても、効果はありませんでした。(Bug #15833516) MySQL 5.6.9 以前のバージョンでの回避策は、<code class="literal">CHANGE MASTER TO ... MASTER_LOG_FILE = ... MASTER_LOG_POS = ...</code> を使用して (必要に応じてこのステートメントに <code class="literal">MASTER_AUTO_POSITION = 0</code> オプションを含めて)、スレーブの位置をリセットすることです。
          </p></li></ul></div></div><div class="simplesect"><div class="titlepage"><div><div><h5 class="title"><a name="replication-sysvars-gtids"></a>GTID レプリケーションで使用されるシステム変数</h5></div></div></div><p>
        次のシステム変数は GTID ベースレプリケーションで使用されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="sysvar_disable_gtid_unsafe_statements"></a>
            <a class="indexterm" name="idm139979048387552"></a> <a class="indexterm" name="idm139979048386080"></a> <code class="literal">disable_gtid_unsafe_statements</code>
          </p><div class="informaltable"><table summary="Options for disable_gtid_unsafe_statements" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.5</td></tr><tr><td scope="row"><span class="bold"><strong>削除</strong></span></td><td colspan="3">5.6.9</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--disable-gtid-unsafe-statements[=value]</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_disable_gtid_unsafe_statements">disable_gtid_unsafe_statements</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">false</code></td></tr></tbody></table></div><p>
            <span class="emphasis"><em>廃止</em></span>: MySQL 5.6.9 で <code class="literal">enforce_gtid_consistency</code> に置き換わりました。(Bug #14775984)
          </p></li><li class="listitem"><p><a name="sysvar_gtid_done"></a>
            <a class="indexterm" name="idm139979048357328"></a> <a class="indexterm" name="idm139979048355840"></a> <code class="literal">gtid_done</code>
          </p><div class="informaltable"><table summary="Options for gtid_done" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.5</td></tr><tr><td scope="row"><span class="bold"><strong>削除</strong></span></td><td colspan="3">5.6.9</td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_gtid_done">gtid_done</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル、セッション</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr></tbody></table></div><p>
            <span class="emphasis"><em>廃止</em></span>: MySQL 5.6.9 で <code class="literal">gtid_executed</code> に置き換わりました。(Bug #14775984)
          </p></li><li class="listitem"><p><a name="sysvar_enforce_gtid_consistency"></a>
            <a class="indexterm" name="idm139979048331472"></a> <a class="indexterm" name="idm139979048329920"></a> <code class="literal">enforce_gtid_consistency</code>
          </p><div class="informaltable"><table summary="Options for enforce_gtid_consistency" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.9</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--enforce-gtid-consistency[=value]</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_enforce_gtid_consistency">enforce_gtid_consistency</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">false</code></td></tr></tbody></table></div><p>
            この変数が true のときは、トランザクションセーフな方法でログを記録できるステートメントのみの実行を許可することで、サーバーは GTID 一貫性を適用します。サーバーを <code class="option">--gtid-mode=ON</code> で起動する前に、GTID 一貫性を有効にする (<code class="option">--enforce-gtid-consistency</code> を使用することで) <span class="emphasis"><em>必要があります</em></span>。そうしないで GTID モードを有効にすると、エラーで失敗します。システムが GTID を使用する準備ができているかどうかをテストするために、<code class="option">--gtid-mode</code> を使用する<span class="emphasis"><em>前に</em></span> GTID 一貫性を有効に<span class="emphasis"><em>できます</em></span> (<span class="emphasis"><em>お勧めします</em></span>)。
          </p><p>
            <code class="literal">enforce_gtid_consistency</code> が true のときは、トランザクションセーフなステートメントのみのログを記録できるため、次に示す操作はこの場合には使用できないことになります。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">CREATE TABLE ... SELECT</code> ステートメント
              </p></li><li class="listitem"><p>
                トランザクション内の <code class="literal">CREATE TEMPORARY TABLE</code> ステートメント
              </p></li><li class="listitem"><p>
                トランザクションおよび非トランザクションテーブルの両方を更新するトランザクションまたはステートメント。
              </p></li></ul></div><p>
            この変数は読み取り専用です。これを設定するには、MySQL Server の起動時にコマンド行またはオプションファイルで <code class="option">--enforce-gtid-consistency</code> オプションを使用してください。
          </p><p>
            MySQL 5.6.9 より前では、この変数の名前は <code class="literal">disable_gtid_unsafe_statements</code> でした。(Bug #14775984)
          </p></li><li class="listitem"><p><a name="sysvar_gtid_executed"></a>
            <a class="indexterm" name="idm139979048289680"></a> <a class="indexterm" name="idm139979048288192"></a> <code class="literal">gtid_executed</code>
          </p><div class="informaltable"><table summary="Options for gtid_executed" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.9</td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_gtid_executed">gtid_executed</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル、セッション</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr></tbody></table></div><p>
            この変数は、グローバルスコープで使用されるとき、バイナリログにログが記録されるすべてのトランザクションセットの表現を含みます。これは、<code class="literal">SHOW MASTER STATUS</code> および <code class="literal">SHOW SLAVE STATUS</code> の出力内の <code class="literal">Executed_Gtid_Set</code> カラムの値と同じです。
          </p><p>
            この変数は、セッションスコープで使用されるとき、現在のセッションのキャッシュに書き込まれるすべてのトランザクションセットの表現を含みます。
          </p><p>
            任意の時点のバイナリログで見つかるトランザクションのセットは、<code class="literal">GTID_SUBTRACT(@@global.gtid_executed, @@global.gtid_purged)</code> に等しいです (つまり、バイナリログ内で、まだパージされていないすべてのトランザクション)。
          </p><p>
            サーバーが起動すると、<code class="literal">@@global.gtid_executed</code> は次の 2 つのセットの和集合に初期化されます。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                一番新しいバイナリログの <code class="literal">Previous_gtids_log_event</code> にリストされる GTID
              </p></li><li class="listitem"><p>
                一番新しいバイナリログ内のすべての <code class="literal">Gtid_log_event</code> で見つかる GTID
              </p></li></ul></div><p>
            これ以降、トランザクションが実行されるときに GTID がそのセットに追加されます。
          </p><p>
            <code class="literal">RESET MASTER</code> を発行することで、この変数のグローバル値 (ただし、セッション値ではない) は空の文字列にリセットされます。GTID は、セットが <code class="literal">RESET MASTER</code> によってクリアされるときを除いてセットから削除されません。セットは、サーバーがシャットダウンされてすべてのバイナリログが削除される場合にもクリアされます。
          </p><p>
            MySQL 5.6.9 より前では、この変数は <code class="literal">gtid_done</code> と呼ばれていました。
          </p></li><li class="listitem"><p><a name="sysvar_gtid_lost"></a>
            <a class="indexterm" name="idm139979048250928"></a> <a class="indexterm" name="idm139979048249440"></a> <code class="literal">gtid_lost</code>
          </p><div class="informaltable"><table summary="Options for gtid_lost" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.5</td></tr><tr><td scope="row"><span class="bold"><strong>削除</strong></span></td><td colspan="3">5.6.9</td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_gtid_lost">gtid_lost</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr></tbody></table></div><p>
            <span class="emphasis"><em>廃止</em></span>: MySQL 5.6.9 で <code class="literal">gtid_purged</code> に置き換わりました。(Bug #14775984)
          </p></li><li class="listitem"><p><a name="sysvar_gtid_mode"></a>
            <a class="indexterm" name="idm139979048225136"></a> <a class="indexterm" name="idm139979048223648"></a> <code class="literal">gtid_mode</code>
          </p><div class="informaltable"><table summary="Options for gtid_mode" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.5</td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_gtid_mode">gtid_mode</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="6"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">列挙</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr><tr><td scope="row" rowspan="4" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">UPGRADE_STEP_1</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">UPGRADE_STEP_2</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">ON</code></td></tr></tbody></table></div><p>
            GTID が有効かどうかを示します。読み取り専用。<code class="option">--gtid-mode</code> を使用して設定します。
          </p></li><li class="listitem"><p><a name="sysvar_gtid_next"></a>
            <a class="indexterm" name="idm139979048192624"></a> <a class="indexterm" name="idm139979048191136"></a> <code class="literal">gtid_next</code>
          </p><div class="informaltable"><table summary="Options for gtid_next" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.5</td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_gtid_next">gtid_next</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">セッション</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="5"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">列挙</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">AUTOMATIC</code></td></tr><tr><td scope="row" rowspan="3" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">AUTOMATIC</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">ANONYMOUS</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">UUID:NUMBER</code></td></tr></tbody></table></div><p>
            この変数は、次の GTID が取得されたかどうか、およびどのように取得されたかを指定するために使用されます。<code class="literal">gtid_next</code> は次の値のいずれかを取ることができます。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">AUTOMATIC</code>: 自動的に生成される次のグローバルトランザクション ID を使用します。
              </p></li><li class="listitem"><p>
                <code class="literal">ANONYMOUS</code>: トランザクションはグローバル識別子を持たず、ファイルと位置のみで識別されます。
              </p></li><li class="listitem"><p>
                <em class="replaceable"><code>UUID</code></em>:<em class="replaceable"><code>NUMBER</code></em> 形式のグローバルトランザクション ID。
              </p></li></ul></div><p>
            この変数を設定するには、<code class="literal">SUPER</code> 権限が必要です。<code class="literal">gtid_mode</code> が <code class="literal">OFF</code> の場合、この変数を設定しても効果はありません。
          </p><p>
            MySQL 5.6.20 より前は、GTID は有効でも <code class="literal">gtid_next</code> が <code class="literal">AUTOMATIC</code> でない場合、<code class="literal">DROP TABLE</code> は、非一時テーブルと一時テーブル、またはトランザクションストレージエンジンを使用する一時テーブルと非トランザクションストレージエンジンを使用する一時テーブルの組み合わせで使用されたときに、正しく機能しません。MySQL 5.6.20 以降では、<code class="literal">DROP TABLE</code> または <code class="literal">DROP TEMPORARY TABLE</code> は、テーブルのこれらの組み合わせのいずれかで使用されると明示的なエラーで失敗します。(Bug #17620053)
          </p><p>
            MySQL 5.6.11 だけですが、<code class="literal">gtid_next</code> が <code class="literal">AUTOMATIC</code> 以外の値に設定されているとき、ステートメント <code class="literal">CHANGE MASTER TO</code>、<code class="literal">START SLAVE</code>、<code class="literal">STOP SLAVE</code>、<code class="literal">REPAIR TABLE</code>、<code class="literal">OPTIMIZE TABLE</code>、<code class="literal">ANALYZE TABLE</code>、<code class="literal">CHECK TABLE</code>、<code class="literal">CREATE SERVER</code>、<code class="literal">ALTER SERVER</code>、<code class="literal">DROP SERVER</code>、<code class="literal">CACHE INDEX</code>、<code class="literal">LOAD INDEX INTO CACHE</code>、<code class="literal">FLUSH</code>、または <code class="literal">RESET</code> を実行できません。このような場合、ステートメントはエラーで失敗します。このようなステートメントは、MySQL 5.6.12 以降では拒否され<span class="emphasis"><em>ません</em></span>。(Bug #16062608、Bug #16715809、Bug #69045)
          </p></li><li class="listitem"><p><a name="sysvar_gtid_owned"></a>
            <a class="indexterm" name="idm139979048129664"></a> <a class="indexterm" name="idm139979048128176"></a> <code class="literal">gtid_owned</code>
          </p><div class="informaltable"><table summary="Options for gtid_owned" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.5</td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_gtid_owned">gtid_owned</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル、セッション</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr></tbody></table></div><p>
            この読み取り専用変数は、内容がそのスコープに依存するリストを保持します。セッションスコープで使用されるときは、リストはこのクライアントが所有するすべての GTID を保持します。グローバルスコープで使用されるときは、すべての GTID とその所有者のリストを保持します。
          </p></li><li class="listitem"><p><a name="sysvar_gtid_purged"></a>
            <a class="indexterm" name="idm139979048106608"></a> <a class="indexterm" name="idm139979048105120"></a> <code class="literal">gtid_purged</code>
          </p><div class="informaltable"><table summary="Options for gtid_purged" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.9</td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_gtid_purged">gtid_purged</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr></tbody></table></div><p>
            バイナリログからパージされたすべてのトランザクションのセット。
          </p><p>
            サーバーが起動するときに、<code class="literal">gtid_purged</code> のグローバル値は、一番古いバイナリログの <code class="literal">Previous_gtid_log_event</code> に含まれる GTID のセットに初期化されます。バイナリログがパージされると、一番古いものになったバイナリログから <code class="literal">@@global.gtid_purged</code> が再度読み取られます。
          </p><p>
            <code class="literal">RESET MASTER</code> を発行することで、この変数の値は空の文字列にリセットされます。
          </p><p>
            MySQL 5.6.9 より前では、この変数は <code class="literal">gtid_lost</code> と呼ばれ、読み取り専用でした。MySQL 5.6.9 以降では、この変数の値を更新できます (ただし、すでにリストされたものに GTID を追加することでのみ、および <code class="literal">gtid_executed</code> が設定解除されたとき、つまり新しいサーバー上でのみ)。(Bug #14797808)
          </p></li><li class="listitem"><p><a name="sysvar_simplified_binlog_gtid_recovery"></a>
            <a class="indexterm" name="idm139979048075808"></a> <a class="indexterm" name="idm139979048074480"></a> <code class="literal">simplified_binlog_gtid_recovery</code>
          </p><div class="informaltable"><table summary="Options for simplified_binlog_gtid_recovery" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.21</td></tr><tr><td scope="row"><span class="bold"><strong>非推奨</strong></span></td><td colspan="3">5.6.23</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--simplified-binlog-gtid-recovery</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="replication.html#sysvar_simplified_binlog_gtid_recovery">simplified_binlog_gtid_recovery</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">FALSE</code></td></tr></tbody></table></div><p>
            このオプションは非推奨で、今後の MySQL リリースで削除される予定です。名前が変更された <code class="literal">binlog_gtid_recovery_simplified</code> を使用して、クラッシュ後に MySQL がバイナリログファイルをどのように反復するかを制御します。
          </p></li></ul></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-administration"></a>17.1.5 一般的なレプリケーション管理タスク</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-administration-status">17.1.5.1 レプリケーションステータスの確認</a></span></dt><dt><span class="section"><a href="replication.html#replication-administration-pausing">17.1.5.2 スレーブでレプリケーションを一時停止する</a></span></dt></dl></div><p>
      レプリケーションが開始されると、定期的な管理をあまり行わなくても実行されるはずです。レプリケーション環境に応じて、各スレーブのレプリケーションステータスを定期的に (毎日、またはさらに頻繁に) 確認することをお勧めします。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-administration-status"></a>17.1.5.1 レプリケーションステータスの確認</h4></div></div></div><p>
        レプリケーションプロセスを管理するときにもっとも一般的なタスクは、レプリケーションが実行中であること、およびスレーブとマスターとの間でエラーがないことを確認することです。このための主要なステートメントは <code class="literal">SHOW SLAVE STATUS</code> で、各スレーブで実行する必要があります。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW SLAVE STATUS\G</code></strong>
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
                  Master_Host: master1
                  Master_User: root
                  Master_Port: 3306
                Connect_Retry: 60
              Master_Log_File: mysql-bin.000004
          Read_Master_Log_Pos: 931
               Relay_Log_File: slave1-relay-bin.000056
                Relay_Log_Pos: 950
        Relay_Master_Log_File: mysql-bin.000004
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
              Replicate_Do_DB:
          Replicate_Ignore_DB:
           Replicate_Do_Table:
       Replicate_Ignore_Table:
      Replicate_Wild_Do_Table:
  Replicate_Wild_Ignore_Table:
                   Last_Errno: 0
                   Last_Error:
                 Skip_Counter: 0
          Exec_Master_Log_Pos: 931
              Relay_Log_Space: 1365
              Until_Condition: None
               Until_Log_File:
                Until_Log_Pos: 0
           Master_SSL_Allowed: No
           Master_SSL_CA_File:
           Master_SSL_CA_Path:
              Master_SSL_Cert:
            Master_SSL_Cipher:
               Master_SSL_Key:
        Seconds_Behind_Master: 0
Master_SSL_Verify_Server_Cert: No
                Last_IO_Errno: 0
                Last_IO_Error:
               Last_SQL_Errno: 0
               Last_SQL_Error:
  Replicate_Ignore_Server_Ids: 0
</pre><p>
        ステータスレポートの中で調査すべき主要フィールドは、次のとおりです。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Slave_IO_State</code>: スレーブの現在のステータス。詳しくは、<a class="xref" href="optimization.html#slave-io-thread-states" title="8.12.5.6 レプリケーションスレーブの I/O スレッド状態">セクション8.12.5.6「レプリケーションスレーブの I/O スレッド状態」</a>および<a class="xref" href="optimization.html#slave-sql-thread-states" title="8.12.5.7 レプリケーションスレーブ SQL スレッドの状態">セクション8.12.5.7「レプリケーションスレーブ SQL スレッドの状態」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">Slave_IO_Running</code>: マスターのバイナリログを読み取るための I/O スレッドが実行中かどうか。レプリケーションをまだ起動していないか <code class="literal">STOP SLAVE</code> で明示的に停止した場合を除き、通常はこれを <code class="literal">Yes</code> にすることをお勧めします。
          </p></li><li class="listitem"><p>
            <code class="literal">Slave_SQL_Running</code>: リレーログでイベントを実行するための SQL スレッドが実行中かどうか。I/O スレッドと同様、これは通常は <code class="literal">Yes</code> にすることをお勧めします。
          </p></li><li class="listitem"><p>
            <code class="literal">Last_IO_Error</code>、<code class="literal">Last_SQL_Error</code>: リレーログを処理するときに I/O および SQL スレッドによって登録された最後のエラー。理想的には、これらはエラーがないことを示すブランクであるべきです。
          </p></li><li class="listitem"><p>
            <code class="literal">Seconds_Behind_Master</code>: スレーブ SQL スレッドがマスターバイナリログの処理より何秒遅れているか。高い (または増加する) 数値は、スレーブがマスターからのイベントを適時に処理できないことを示している可能性があります。
          </p><p>
            <code class="literal">Seconds_Behind_Master</code> が値 0 の場合は通常、スレーブがマスターに追い付いたことを意味すると解釈できますが、これが厳密には正しくない場合がいくつかあります。たとえば、マスターとスレーブの間のネットワーク接続が切断されたけれども、スレーブ I/O スレッドがまだこれを通知されていない場合、つまり <code class="literal">slave_net_timeout</code> がまだ経過していない場合に、これが発生する可能性があります。
          </p><p>
            <code class="literal">Seconds_Behind_Master</code> の過渡値が状況を正確に反映しない場合もあります。スレーブ SQL スレッドが I/O に追い付くと、<code class="literal">Seconds_Behind_Master</code> は 0 を表示しますが、スレーブ I/O スレッドがまだ新しいイベントをキューに入れているときは、<code class="literal">Seconds_Behind_Master</code> は SQL スレッドが新しいイベントの実行を終了するまで大きな値を示す場合があります。これは特に、イベントのタイムスタンプが古い場合に発生する可能性があります。そのような場合、比較的短い期間に数回 <code class="literal">SHOW SLAVE STATUS</code> 実行すると、この値が 0 と比較的大きな値との間を前後に繰り返し変化するのが見える可能性があります。
          </p></li></ul></div><p>
        フィールドのいくつかのペアは、スレーブがマスターバイナリログからイベントを読み取り、リレーログでそれらを処理するときの進捗状況に関する情報を提供します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            (<code class="literal">Master_Log_file</code>、<code class="literal">Read_Master_Log_Pos</code>): スレーブ I/O スレッドがマスターバイナリログからどのくらい離れてイベントを読み取ったかを示す、ログ内の座標。
          </p></li><li class="listitem"><p>
            (<code class="literal">Relay_Master_Log_File</code>、<code class="literal">Exec_Master_Log_Pos</code>): スレーブ SQL スレッドがマスターバイナリログから受け取ったイベントをどのくらい離れて実行したかを示す、ログ内の座標。
          </p></li><li class="listitem"><p>
            (<code class="literal">Relay_Log_File</code>、<code class="literal">Relay_Log_Pos</code>): スレーブ SQL スレッドがスレーブリレーログをどのくらい離れて実行したかを示す、リレーログ内の座標。これらは前述の座標に対応しますが、マスターバイナリログ座標ではなく、スレーブリレーログ座標で表現されます。
          </p></li></ul></div><p>
        マスターでは、接続されたスレーブのステータスを <code class="literal">SHOW PROCESSLIST</code> を使用して確認することで、実行中プロセスのリストを確認できます。スレーブ接続では、<code class="literal">Command</code> フィールドに <code class="literal">Binlog Dump</code> があります。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW PROCESSLIST \G;</code></strong>
*************************** 4. row ***************************
     Id: 10
   User: root
   Host: slave1:58371
     db: NULL
Command: Binlog Dump
   Time: 777
  State: Has sent all binlog to slave; waiting for binlog to be updated
   Info: NULL
</pre><p>
        レプリケーションプロセスを実行するのはスレーブであるため、このレポートで入手できる情報はほとんどありません。
      </p><p>
        <code class="option">--report-host</code> オプションで起動されて、マスターに接続されているスレーブの場合は、マスターでの <code class="literal">SHOW SLAVE HOSTS</code> ステートメントはスレーブに関する基本情報を示します。出力には、スレーブサーバーの ID、<code class="option">--report-host</code> オプションの値、接続中のポート、マスター ID が含まれます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW SLAVE HOSTS;</code></strong>
+-----------+--------+------+-------------------+-----------+
| Server_id | Host   | Port | Rpl_recovery_rank | Master_id |
+-----------+--------+------+-------------------+-----------+
|        10 | slave1 | 3306 |                 0 |         1 |
+-----------+--------+------+-------------------+-----------+
1 row in set (0.00 sec)
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-administration-pausing"></a>17.1.5.2 スレーブでレプリケーションを一時停止する</h4></div></div></div><p>
        <code class="literal">STOP SLAVE</code> および <code class="literal">START SLAVE</code> ステートメントを使用して、スレーブでステートメントのレプリケーションを停止したり開始したりできます。
      </p><p>
        マスターからバイナリログの処理を停止するには、<code class="literal">STOP SLAVE</code> を使用します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>STOP SLAVE;</code></strong>
</pre><p>
        レプリケーションが停止されると、スレーブ I/O スレッドはマスターバイナリログからイベントを読み取りそれらをリレーログに書き込むのを停止し、SQL スレッドはリレーログからイベントの読み取りそれらを実行するのを停止します。スレッドタイプを指定することで、I/O または SQL スレッドを個別に一時停止できます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>STOP SLAVE IO_THREAD;</code></strong>
mysql&gt; <strong class="userinput"><code>STOP SLAVE SQL_THREAD;</code></strong>
</pre><p>
        実行を再開するには、<code class="literal">START SLAVE</code> ステートメントを使用します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>START SLAVE;</code></strong>
</pre><p>
        特定のスレッドを開始するには、スレッドタイプを指定します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>START SLAVE IO_THREAD;</code></strong>
mysql&gt; <strong class="userinput"><code>START SLAVE SQL_THREAD;</code></strong>
</pre><p>
        マスターからイベントを処理することでのみ更新を実行するスレーブの場合、SQL スレッドのみを停止することが、バックアップまたはほかのタスクを実行する場合に役立つ可能性があります。I/O スレッドは引き続きマスターからイベントを読み取りますが、それらは実行されません。これにより、SQL スレッドを再起動するときに、スレーブが追い付くことが簡単になります。
      </p><p>
        I/O スレッドだけを停止することで、SQL スレッドはリレーログが終了したポイントまでリレーログ内のイベントを実行できます。マスターからすでに受け取ったイベントに追い付くために実行を停止したいとき、スレーブで管理を実行したいけれども特定のポイントまですべての更新を処理したことを確認したいときに、これが役立つ場合があります。この方法は、マスターで管理を実行中に、スレーブでイベント受け取りを一時停止するときにも使用できます。I/O スレッドは停止するけれども SQL スレッドの実行を許可することで、レプリケーションが再開したときに実行される大量のイベントバックログを確実になくすのに役立ちます。
      </p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="replication-implementation"></a>17.2 レプリケーションの実装</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-implementation-details">17.2.1 レプリケーション実装の詳細</a></span></dt><dt><span class="section"><a href="replication.html#slave-logs">17.2.2 レプリケーションリレーおよびステータスログ</a></span></dt><dt><span class="section"><a href="replication.html#replication-rules">17.2.3 サーバーがレプリケーションフィルタリングルールをどのように評価するか</a></span></dt></dl></div><a class="indexterm" name="idm139979047974304"></a><p>
    レプリケーションは、データベースへのあらゆる変更 (更新、削除など) をバイナリログで追跡するマスターサーバーに基づきます。バイナリログは、サーバーが起動した瞬間からデータベースの構造または内容 （データ） を変更するあらゆるイベントが書き込まれた記録として機能します。<code class="literal">SELECT</code> ステートメントは通常、データベースの構造および内容を変更しないため記録されません。
  </p><p>
    マスターに接続する各スレーブはバイナリログのコピーを要求します。つまり、マスターがスレーブにデータをプッシュのではなく、スレーブがマスターからデータをプルします。スレーブはまた、それが受け取るバイナリログからイベントを実行します。これによって、元の変更がマスターで実行されたように繰り返されることになります。マスターで最初に実行された変更に応じて、テーブルが作成されたり、それらの構造が変更されたり、データが挿入、削除、更新されたりします。
  </p><p>
    各スレーブは独立しているので、マスターのバイナリログからの変更の再生が、マスターに接続された各スレーブで単独に発生します。さらに、各スレーブはバイナリログのコピーをマスターから要求することでのみ受け取るため、スレーブはそれ自身のペースでデータベースのコピーを読み取ったり更新したりでき、マスター側またはスレーブ側で最新のデータベースステータスを更新できる能力に影響を与えずにレプリケーションプロセスを自由に開始したり停止したりできます。
  </p><p>
    レプリケーション実装の仕様に関する詳細は、<a class="xref" href="replication.html#replication-implementation-details" title="17.2.1 レプリケーション実装の詳細">セクション17.2.1「レプリケーション実装の詳細」</a>を参照してください。
  </p><p>
    マスターとスレーブは、レプリケーションプロセスに関するステータスをモニターできるように、定期的にそれらを報告します。すべてのレプリケーション関連ステータスの説明については、<a class="xref" href="optimization.html#thread-information" title="8.12.5 スレッド情報の検査">セクション8.12.5「スレッド情報の検査」</a>を参照してください。
  </p><p>
    マスターバイナリログは、スレーブ上のローカルリレーログに書き込まれてから処理されます。スレーブは、マスターのバイナリログとローカルリレーログと一緒に、現在の位置に関する情報も記録します。<a class="xref" href="replication.html#slave-logs" title="17.2.2 レプリケーションリレーおよびステータスログ">セクション17.2.2「レプリケーションリレーおよびステータスログ」</a>を参照してください。
  </p><p>
    データベース変更は、さまざまな構成オプションおよびイベント評価を制御する変数に従って適用されるルールセットに応じて、スレーブ上でフィルタされます。これらのルールがどのように適用されるかについての詳細は、<a class="xref" href="replication.html#replication-rules" title="17.2.3 サーバーがレプリケーションフィルタリングルールをどのように評価するか">セクション17.2.3「サーバーがレプリケーションフィルタリングルールをどのように評価するか」</a>を参照してください。
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-implementation-details"></a>17.2.1 レプリケーション実装の詳細</h3></div></div></div><p>
      MySQL レプリケーション機能は、3 つのスレッド (マスターサーバー上で 1 つ、スレーブ上で 2 つ) を使用して実装されます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Binlog ダンプスレッド </b>
            マスターは、スレーブが接続したときにバイナリログ内容をスレーブに送信するスレッドを作成します。このスレッドは、マスター上の <code class="literal">SHOW PROCESSLIST</code> の出力内で <code class="literal">Binlog Dump</code> スレッドとして識別できます。
          </p><p>
          バイナリログダンプスレッドは、スレーブに送信される各イベントを読み取るために、マスターのバイナリログでロックを獲得します。イベントが読み取られるとすぐにロックは解除されます (イベントがスレーブに送信される前でも)。
        </p></li><li class="listitem"><p><b>スレーブ I/O スレッド </b>
             <code class="literal">START SLAVE</code> ステートメントがスレーブサーバー上で発行されると、スレーブは I/O スレッドを作成し、これがマスターに接続されてそのバイナリログに記録された更新を送信することを要求します。
          </p><p>
          スレーブ I/O スレッドは、マスターの <code class="literal">Binlog Dump</code> スレッドが送信する更新を読み取って (前の項目を参照)、それらをスレーブのリレーログで構成されるローカルファイルにコピーします。
        </p><p>
          このスレッドの状態は、<code class="literal">SHOW SLAVE STATUS</code> の出力では <code class="literal">Slave_IO_running</code> として、<code class="literal">SHOW STATUS</code> の出力では <code class="literal">Slave_running</code> として表示されます。
        </p></li><li class="listitem"><p><b>スレーブ SQL スレッド </b>
            スレーブは、スレーブ I/O スレッドによって書き込まれるリレーログを読み取り、それらに含まれるイベントを実行する SQL スレッドを作成します。
          </p></li></ul></div><p>
      マスター/スレーブ接続ごとに 3 つのスレーブがあることをすでに説明しました。複数のスレーブを持つマスターは、現在接続されているスレーブごとに 1 つのバイナリログダンプスレッドを作成し、スレーブごとに独自の I/O および SQL スレッドがあります。
    </p><p>
      スレーブは 2 つのスレッドを使用して、マスターからの更新を読み取ることとそれらを実行することを、独立タスクに分類します。このようにしても、ステートメント実行が遅い場合でも、ステートメントを読み取るタスクが遅くなることはありません。たとえば、スレーブサーバーがしばらくの間実行されなかった場合、その I/O スレッドはスレーブ起動時にマスターからすべてのバイナリログ内容をすばやくフェッチできます (SQL スレッドがかなり遅れていても)。SQL スレッドがすべてのフェッチ済みステートメントの実行を完了する前にスレーブが停止した場合でも、I/O スレッドは少なくともすべてのものをフェッチしているため、ステートメントの安全なコピーがスレーブのリレーログにローカルに保存されていて、次にスレーブが起動するときに実行できる状態です。これによって、マスターサーバーはそのバイナリログをすぐにパージできます (スレーブがそれらの内容をフェッチするのをそれ以上待機する必要がないため)。
    </p><p>
      <code class="literal">SHOW PROCESSLIST</code> ステートメントは、レプリケーションに関してマスターおよびスレーブ上で何が起きているかを伝える情報を提供します。マスター状態については、<a class="xref" href="optimization.html#master-thread-states" title="8.12.5.5 レプリケーションマスタースレッドの状態">セクション8.12.5.5「レプリケーションマスタースレッドの状態」</a>を参照してください。スレーブ状態については、<a class="xref" href="optimization.html#slave-io-thread-states" title="8.12.5.6 レプリケーションスレーブの I/O スレッド状態">セクション8.12.5.6「レプリケーションスレーブの I/O スレッド状態」</a>および<a class="xref" href="optimization.html#slave-sql-thread-states" title="8.12.5.7 レプリケーションスレーブ SQL スレッドの状態">セクション8.12.5.7「レプリケーションスレーブ SQL スレッドの状態」</a>を参照してください。
    </p><p>
      次の例では、3 つのスレッドが <code class="literal">SHOW PROCESSLIST</code> からの出力でどのように表示されるかを示します。
    </p><p>
      マスターサーバーでは、<code class="literal">SHOW PROCESSLIST</code> からの出力は次のようになります。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW PROCESSLIST\G</code></strong>
*************************** 1. row ***************************
     Id: 2
   User: root
   Host: localhost:32931
     db: NULL
Command: Binlog Dump
   Time: 94
  State: Has sent all binlog to slave; waiting for binlog to
         be updated
   Info: NULL
</pre><p>
      ここで、スレッド 2 は接続されたスレーブにサービスを提供する <code class="literal">Binlog Dump</code> レプリケーションスレッドです。<code class="literal">State</code> 情報は、すべての未処理更新がスレーブに送信され、マスターは後続の更新の発生を待機していることを示しています。マスターサーバー上で <code class="literal">Binlog Dump</code> スレッドが見られない場合、これは、レプリケーションが実行中でない、つまり現在スレーブが接続されていないことを意味します。
    </p><p>
      スレーブサーバーでは、<code class="literal">SHOW PROCESSLIST</code> からの出力は次のようになります。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW PROCESSLIST\G</code></strong>
*************************** 1. row ***************************
     Id: 10
   User: system user
   Host:
     db: NULL
Command: Connect
   Time: 11
  State: Waiting for master to send event
   Info: NULL
*************************** 2. row ***************************
     Id: 11
   User: system user
   Host:
     db: NULL
Command: Connect
   Time: 11
  State: Has read all relay log; waiting for the slave I/O
         thread to update it
   Info: NULL
</pre><p>
      <code class="literal">State</code> 情報は、スレッド 10 がマスターサーバーと通信している I/O スレッド、スレッド 11 がリレーログに格納された更新を処理している SQL スレッドであることを示しています。<code class="literal">SHOW PROCESSLIST</code> が実行された時点で、両方のスレッドはアイドルで、後続の更新を待機中でした。
    </p><p>
      <code class="literal">Time</code> カラムの値は、マスターと比較してスレーブがどのくらい遅れているかを示すことができます。<a class="xref" href="faqs.html#faqs-replication" title="A.13 MySQL 5.6 FAQ: レプリケーション">セクションA.13「MySQL 5.6 FAQ: レプリケーション」</a>を参照してください。マスター側で <code class="literal">Binlog Dump</code> スレッドの活動がない状態で十分な時間が経過した場合、マスターはスレーブがもう接続されていないと判断します。ほかのクライアント接続に関して、これのタイムアウトは <code class="option">net_write_timeout</code> および <code class="option">net_retry_count</code> の値によって異なります。これらの詳細については、<a class="xref" href="server-administration.html#server-system-variables" title="5.1.4 サーバーシステム変数">セクション5.1.4「サーバーシステム変数」</a>を参照してください。
    </p><p>
      <code class="literal">SHOW SLAVE STATUS</code> ステートメントは、スレーブサーバー上のレプリケーション処理に関する追加情報を提供します。<a class="xref" href="replication.html#replication-administration-status" title="17.1.5.1 レプリケーションステータスの確認">セクション17.1.5.1「レプリケーションステータスの確認」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="slave-logs"></a>17.2.2 レプリケーションリレーおよびステータスログ</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#slave-logs-relaylog">17.2.2.1 スレーブリレーログ</a></span></dt><dt><span class="section"><a href="replication.html#slave-logs-status">17.2.2.2 スレーブステータスログ</a></span></dt></dl></div><a class="indexterm" name="idm139979047911504"></a><a class="indexterm" name="idm139979047909360"></a><a class="indexterm" name="idm139979047907296"></a><a class="indexterm" name="idm139979047905904"></a><a class="indexterm" name="idm139979047904496"></a><a class="indexterm" name="idm139979047903056"></a><a class="indexterm" name="idm139979047901616"></a><a class="indexterm" name="idm139979047900176"></a><a class="indexterm" name="idm139979047898736"></a><a class="indexterm" name="idm139979047897328"></a><p>
      レプリケーション中にスレーブサーバーは、マスターからスレーブにリレーされるバイナリログイベントを保持し、現在のステータスとリレーログ内の位置に関する情報を記録するいくつかのログを作成します。処理に使用されるログには、ここで示すように 3 つのタイプがあります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <span class="emphasis"><em>リレーログ</em></span>は、スレーブ I/O スレッドによってマスターのバイナリログから読み取られ、書き込まれるイベントから構成されます。リレーログ内のイベントは、SQL スレッドの一部としてスレーブ上で実行されます。
        </p></li><li class="listitem"><p>
          <em class="firstterm">マスター情報ログ</em> には、スレーブのマスターへの接続に関するステータスと現在の構成情報が含まれます。このログは、マスターホスト名、ログイン資格証明、およびスレーブがマスターのバイナリログからどのくらい離れて読み取ったかを示す座標に関する情報を保持します。
        </p><p>
          MySQL 5.6 より前では、このログは常にファイル (<code class="filename">master.info</code>) でしたが、MySQL 5.6 以降では、スレーブを <code class="option">--master-info-repository=TABLE</code> で起動することで、このログをファイルにではなく <code class="literal">mysql.slave_master_info</code> テーブルに書き込むことができます。
        </p></li><li class="listitem"><p>
          <em class="firstterm">リレーログ情報</em> は、スレーブのリレーログ内の実行ポイントに関するステータス情報を保持します。
        </p><p>
          MySQL 5.6 より前では、このログは常にファイル (<code class="filename">relay-log.info</code>) でしたが、MySQL 5.6 以降では、スレーブを <code class="option">--relay-log-info-repository=TABLE</code> で起動することで、このログをファイルにではなく <code class="literal">mysql.slave_relay_log_info</code> テーブルに書き込むことができます。
        </p></li></ul></div><p>
      MySQL 5.6.7 より前では、<code class="literal">slave_master_info</code> および <code class="literal">slave_relay_log_info</code> テーブルの <code class="literal">Master_id</code> カラムは、マスターのサーバー ID ではなくスレーブのサーバー ID を示していました。(Bug #12334346)
    </p><a class="indexterm" name="idm139979047880144"></a><p><a name="replication-implementation-crash-safe"></a><b>クラッシュセーフレプリケーション </b>
        ステータスおよびリレー情報のログのためにテーブルを使用するときにレプリケーションがクラッシュセーフであるためには、これらのテーブルは <code class="literal">InnoDB</code> などのトランザクションストレージエンジンを使用する必要があります。MySQL 5.6.6 以降では、これらのテーブルは <code class="literal">InnoDB</code> を使用して作成されます。(Bug #13538891)
      </p><p>
      このため、スレーブでのクラッシュ安全性を保証するには、<code class="option">--relay-log-recovery</code> が有効な状態でスレーブを実行し、さらに <code class="option">--relay-log-info-repository</code> を <code class="literal">TABLE</code> に設定する必要があります。
    </p><p>
      MySQL 5.6.6 より前では、<span class="command"><strong>mysqld</strong></span> がレプリケーションロギングテーブルを初期化できなかった場合、スレーブは起動を拒否しました。MySQL 5.6.6 以降では、これが発生すると警告が出されますが、スレーブは起動を続けることが許可されます。(Bug #13971348) この状況が発生する可能性が高いのは、スレーブロギングテーブルをサポートしないバージョンの MySQL からサポートされるバージョンにアップグレードするときです。
    </p><p>
      MySQL 5.6.5 以前では、<code class="literal">slave_master_info</code> および <code class="literal">slave_relay_log_info</code> テーブルがデフォルトで <code class="literal">MyISAM</code> を使用していて、これはレプリケーションを開始する前にここで示すように <code class="literal">ALTER TABLE ... ENGINE=InnoDB</code> を発行することで、これらのテーブルが使用するストレージエンジンを変更する必要がありました。
    </p><pre class="programlisting">
ALTER TABLE mysql.slave_master_info ENGINE=InnoDB;
ALTER TABLE mysql.slave_relay_log_info ENGINE=InnoDB;
</pre><p>
      <code class="literal">ALTER TABLE</code> ステートメントは、<code class="literal">mysql</code> データベースで適切な権限を持つ MySQL <code class="literal">root</code> またはほかのユーザーアカウントで実行される必要があります。レプリケーションの実行中にこれを実行しようとしてはいけません。MySQL 5.6.3 以降では、レプリケーションの進行中にこれらのいずれかのテーブルで <code class="literal">ALTER TABLE</code> を実行しようとすることは許可されません。MySQL 5.6.4 以降では、これらのテーブルのいずれかまたは両方で書き込みロックを必要とするステートメントを実行することは、レプリケーションの進行中は許可されませんが、読み取りのみを実行するステートメントはいつでも許可されます。
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        <code class="literal">slave_master_info</code> または <code class="literal">slave_relay_log_info</code> テーブルで手動で行を更新または挿入しようとしないでください。そのようにすることは、未定義の動作になる可能性があり、サポートされていません。
      </p></div><p>
      MySQL 5.6.4 より前では、<span class="command"><strong>mysqldump</strong></span> はレプリケーションログテーブルをダンプしませんでした (それらが名前で指定されて <code class="option">--master-data</code> オプションが使用された場合を除く)。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="slave-logs-relaylog"></a>17.2.2.1 スレーブリレーログ</h4></div></div></div><p>
        リレーログは、バイナリログと同様に、データベース変更を記述するイベントを含む番号付きファイルのセットと、使用されたすべてのリレーログファイルの名前を含むインデックスファイルとで構成されます。
      </p><p>
        用語<span class="quote">「<span class="quote">リレーログファイル</span>」</span>は一般的に、データベースイベントを含む個々の番号付きファイルを示します。用語<span class="quote">「<span class="quote">リレーログ</span>」</span>は、番号付きリレーログファイルとインデックスファイルのセットの総称です。
      </p><p>
        リレーログファイルはバイナリログファイルと同じ形式で、<span class="command"><strong>mysqlbinlog</strong></span> を使用して読み取ることができます (<a class="xref" href="programs.html#mysqlbinlog" title="4.6.8 mysqlbinlog — バイナリログファイルを処理するためのユーティリティー">セクション4.6.8「<span class="command"><strong>mysqlbinlog</strong></span> — バイナリログファイルを処理するためのユーティリティー」</a>を参照)。
      </p><p>
        デフォルトでは、データディレクトリ内でのリレーログファイル名の形式は <code class="filename"><em class="replaceable"><code>host_name</code></em>-relay-bin.<em class="replaceable"><code>nnnnnn</code></em></code> です。ここで、<em class="replaceable"><code>host_name</code></em> はスレーブサーバーホストの名前、<em class="replaceable"><code>nnnnnn</code></em> はシーケンス番号です。連続するリレーログファイルは、<code class="literal">000001</code> で始まる連続シーケンス番号を使用して作成されます。スレーブはインデックスファイルを使用して現在使用中のリレーログファイルを追跡します。データディレクトリ内でのデフォルトのリレーログインデックスファイル名は、<code class="filename"><em class="replaceable"><code>host_name</code></em>-relay-bin.index</code> です。
      </p><p>
        デフォルトのリレーログファイルおよびリレーログインデックスファイル名はそれぞれ、<code class="option">--relay-log</code> および <code class="option">--relay-log-index</code> サーバーオプションでオーバーライドできます (<a class="xref" href="replication.html#replication-options" title="17.1.4 レプリケーションおよびバイナリロギングのオプションと変数">セクション17.1.4「レプリケーションおよびバイナリロギングのオプションと変数」</a>を参照)。
      </p><p>
        スレーブがデフォルトのホストベースリレーログファイル名を使用する場合、レプリケーションセットアップ後にスレーブのホスト名を変更すると、レプリケーションが次のエラーで失敗する可能性があります: <span class="errortext">Failed to open the relay log</span> および <span class="errortext">Could not find target log during relay log initialization</span>。これは既知の問題です (Bug #2122 を参照してください)。今後スレーブのホスト名が変更される見込みがある場合は (たとえば、DHCP を使用してそのホスト名を変更できるように、スレーブでネットワークがセットアップされている場合)、スレーブを最初にセットアップするときに <code class="option">--relay-log</code> および <code class="option">--relay-log-index</code> オプションを使用してリレーログファイル名を明示的に指定することで、この問題を完全に回避できます。これにより、サーバーホスト名の変更との間に名前の依存関係がなくなります。
      </p><p>
        レプリケーションがすでに開始されたあとに問題が発生した場合、これを回避する 1 つの方法は、スレーブサーバーを停止し、古いリレーログインデックスファイルの内容を新しいものの前に付加してからスレーブを再起動することです。Unix システムでは、ここで示すようにこれを実行できます。
      </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>cat <em class="replaceable"><code>new_relay_log_name</code></em>.index &gt;&gt; <em class="replaceable"><code>old_relay_log_name</code></em>.index</code></strong>
shell&gt; <strong class="userinput"><code>mv <em class="replaceable"><code>old_relay_log_name</code></em>.index <em class="replaceable"><code>new_relay_log_name</code></em>.index</code></strong>
</pre><p>
        スレーブサーバーは次の条件で新しいリレーログファイルを作成します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            I/O スレッドが起動するたび。
          </p></li><li class="listitem"><p>
            ログがフラッシュされたとき。たとえば、<code class="literal">FLUSH LOGS</code> または <span class="command"><strong>mysqladmin flush-logs</strong></span> で。
          </p></li><li class="listitem"><p>
            現在のリレーログファイルのサイズが<span class="quote">「<span class="quote">大きくなりすぎた</span>」</span>とき。次のように判断します。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">max_relay_log_size</code> (最大リレーログファイルサイズ) の値が 0 より大きい場合。
              </p></li><li class="listitem"><p>
                <code class="literal">max_relay_log_size</code> の値が 0 の場合、<code class="literal">max_binlog_size</code> が最大リレーログファイルサイズを判断します。
              </p></li></ul></div></li></ul></div><p>
        SQL スレッドは、各リレーログファイル内のすべてのイベントの実行し、それが不要になるとすぐに、ファイルを自動的に削除します。SQL スレッドがこの処理を担当するため、リレーログを削除するための明示的なメカニズムはありません。ただし、<code class="literal">FLUSH LOGS</code> はリレーログをローテーションしますが、これは SQL スレッドがいつそれらを削除するかに影響します。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="slave-logs-status"></a>17.2.2.2 スレーブステータスログ</h4></div></div></div><p>
        レプリケーションスレーブサーバーは 2 つのログを作成します。デフォルトでは、これらのログは <code class="filename">master.info</code> および <code class="filename">relay-log.info</code> という名前のファイルで、データディレクトリ内に作成されます。これらのファイルの名前と場所はそれぞれ、<code class="option">--master-info-file</code> および <code class="option">--relay-log-info-file</code> オプションを使用して変更できます。MySQL 5.6 以降では、適切なオプションでサーバーを起動することで、これらのどちらかまたは両方のログを <code class="literal">mysql</code> データベース内のテーブルに書き込むこともできます: <code class="option">--master-info-repository</code> を使用すると、マスター情報ログが <code class="literal">mysql.slave_master_info</code> テーブルに書き込まれ、<code class="option">--relay-log-info-repository</code> を使用すると、リレーログ情報ログが <code class="literal">mysql.slave_relay_log_info</code> テーブルに書き込まれます。<a class="xref" href="replication.html#replication-options" title="17.1.4 レプリケーションおよびバイナリロギングのオプションと変数">セクション17.1.4「レプリケーションおよびバイナリロギングのオプションと変数」</a>を参照してください。
      </p><p>
        2 つのステータスログには、<code class="literal">SHOW SLAVE STATUS</code> ステートメントの出力で示されるような情報が含まれます (<a class="xref" href="sql-syntax.html#replication-slave-sql" title="13.4.2 スレーブサーバーを制御するための SQL ステートメント">セクション13.4.2「スレーブサーバーを制御するための SQL ステートメント」</a>を参照)。ステータスログはディスクに格納されるため、スレーブサーバーのシャットダウン後も存在します。スレーブは、次に起動するときに 2 つのログを読み取って、マスターからのバイナリログ読み取りがそれ自身のリレーログの処理がどのくらい進んだかを判断します。
      </p><p>
        マスター情報ログファイルまたはテーブルは、マスターに接続するためのパスワードを含んでいるため、保護することをお勧めします。<a class="xref" href="security.html#password-logging" title="6.1.2.3 パスワードおよびロギング">セクション6.1.2.3「パスワードおよびロギング」</a>を参照してください。
      </p><p>
        スレーブ I/O スレッドはマスター情報ログを更新します。次の表は、<code class="filename">master.info</code> ファイル内の行、<code class="literal">mysql.slave_master_info</code> テーブル内のカラム、および <code class="literal">SHOW SLAVE STATUS</code> で表示されるカラムの間の対応を示しています。
      </p><div class="informaltable"><table summary="この表は、master.info ファイル内の行、mysql.slave_master_info テーブル内のカラム、および SHOW SLAVE STATUS で表示されるカラムの間の対応を示しています。" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th scope="col"><code class="filename">master.info</code> ファイル内の行</th><th scope="col"><code class="literal">slave_master_info</code> テーブルのカラム</th><th scope="col"><code class="literal">SHOW SLAVE STATUS</code> のカラム</th><th scope="col">説明</th></tr></thead><tbody><tr><td scope="row">1</td><td><code class="literal">Number_of_lines</code></td><td>[None]</td><td>ファイル内の行、またはテーブル内のカラムの数</td></tr><tr><td scope="row">2</td><td><code class="literal">Master_log_name</code></td><td><code class="literal">Master_Log_File</code></td><td>マスターから現在読み取られているマスターバイナリログの名前</td></tr><tr><td scope="row">3</td><td><code class="literal">Master_log_pos</code></td><td><code class="literal">Read_Master_Log_Pos</code></td><td>マスターから読み取られたマスターのバイナリログ内の現在の位置です</td></tr><tr><td scope="row">4</td><td><code class="literal">Host</code></td><td><code class="literal">Master_Host</code></td><td>マスターのホスト名</td></tr><tr><td scope="row">5</td><td><code class="literal">User_name</code></td><td><code class="literal">Master_User</code></td><td>マスターへの接続に使用されるユーザー名</td></tr><tr><td scope="row">6</td><td><code class="literal">User_password</code></td><td>パスワード (<code class="literal">SHOW SLAVE STATUS</code> では表示されない)</td><td>マスターへの接続に使用されるパスワード</td></tr><tr><td scope="row">7</td><td><code class="literal">Port</code></td><td><code class="literal">Master_Port</code></td><td>マスターへの接続に使用されるネットワークポート</td></tr><tr><td scope="row">8</td><td><code class="literal">Connect_retry</code></td><td><code class="literal">Connect_Retry</code></td><td>マスターへの再接続を試みる前にスレーブが待機する期間 （秒単位）</td></tr><tr><td scope="row">9</td><td><code class="literal">Enabled_ssl</code></td><td><code class="literal">Master_SSL_Allowed</code></td><td>サーバーが SSL 接続をサポートするかどうかを示す</td></tr><tr><td scope="row">10</td><td><code class="literal">Ssl_ca</code></td><td><code class="literal">Master_SSL_CA_File</code></td><td>認証局 (CA) 証明書に使用されるファイル</td></tr><tr><td scope="row">11</td><td><code class="literal">Ssl_capath</code></td><td><code class="literal">Master_SSL_CA_Path</code></td><td>認証局 (CA) 証明書へのパス</td></tr><tr><td scope="row">12</td><td><code class="literal">Ssl_cert</code></td><td><code class="literal">Master_SSL_Cert</code></td><td>SSL 証明書ファイルの名前</td></tr><tr><td scope="row">13</td><td><code class="literal">Ssl_cipher</code></td><td><code class="literal">Master_SSL_Cipher</code></td><td>SSL 接続のハンドシェイクで使用される可能な暗号のリスト</td></tr><tr><td scope="row">14</td><td><code class="literal">Ssl_key</code></td><td><code class="literal">Master_SSL_Key</code></td><td>SSL キーファイルの名前</td></tr><tr><td scope="row">15</td><td><code class="literal">Ssl_verify_server_cert</code></td><td><code class="literal">Master_SSL_Verify_Server_Cert</code></td><td>サーバー証明書を検証するかどうか</td></tr><tr><td scope="row">16</td><td><code class="literal">Heartbeat</code></td><td>[None]</td><td>レプリケーションハートビートの間隔 （秒単位）</td></tr><tr><td scope="row">17</td><td><code class="literal">Bind</code></td><td><code class="literal">Master_Bind</code></td><td>マスターへの接続にスレーブのどのネットワークインタフェースを使用すべきか</td></tr><tr><td scope="row">18</td><td><code class="literal">Ignored_server_ids</code></td><td><code class="literal">Replicate_Ignore_Server_Ids</code></td><td>無視するサーバー ID のリスト。<code class="literal">Ignored_server_ids</code> の場合、サーバー ID のリストの前に、無視するサーバー ID の合計数が付きます。</td></tr><tr><td scope="row">19</td><td><code class="literal">Uuid</code></td><td><code class="literal">Master_UUID</code></td><td>マスターの一意 ID</td></tr><tr><td scope="row">20</td><td><code class="literal">Retry_count</code></td><td><code class="literal">Master_Retry_Count</code></td><td>許容される再接続試行の最大数</td></tr><tr><td scope="row">21</td><td><code class="literal">Ssl_crl</code></td><td>[None]</td><td>SSL 証明書失効リストファイルへのパス (MySQL バージョン 5.6.3 で追加)</td></tr><tr><td scope="row">22</td><td><code class="literal">Ssl_crl_path</code></td><td>[None]</td><td>SSL 証明書失効リストファイルを含むディレクトリへのパス (MySQL バージョン 5.6.3 で追加)</td></tr><tr><td scope="row">23</td><td><code class="literal">Enabled_auto_position</code></td><td><code class="literal">Auto_position</code></td><td>自動ポジショニングが使用中かどうか (MySQL バージョン 5.6.5 で追加)</td></tr></tbody></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          MySQL 5.6.3 より前では、<code class="literal">Ssl_verify_server_cert</code> カラムの名前は <code class="literal">Ssl_verify_servert_cert</code> でした。(Bug #12407446、Bug #60988)
        </p></div><p>
        スレーブ SQL スレッドはリレーログ情報ログを更新します。MySQL 5.6 では、<code class="filename">relay-log.info</code> ファイルに行数とレプリケーション遅延値が含まれます。次の表は、<code class="filename">relay-log.info</code> ファイル内の行、<code class="literal">mysql.slave_relay_log_info</code> テーブル内のカラム、および <code class="literal">SHOW SLAVE STATUS</code> で表示されるカラムの間の対応を示します。
      </p><div class="informaltable"><table summary="この表は、relay-log.info ファイル内の行、mysql.slave_relay_log_info テーブル内のカラム、および SHOW SLAVE STATUS で表示されるカラムの間の対応を示します。" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th scope="col"><code class="filename">relay-log.info</code> 内の行</th><th scope="col"><code class="literal">slave_relay_log_info</code> テーブルのカラム</th><th scope="col"><code class="literal">SHOW SLAVE STATUS</code> のカラム</th><th scope="col">説明</th></tr></thead><tbody><tr><td scope="row">1</td><td><code class="literal">Number_of_lines</code></td><td>[None]</td><td>ファイル内の行またはテーブル内のカラムの数</td></tr><tr><td scope="row">2</td><td><code class="literal">Relay_log_name</code></td><td><code class="literal">Relay_Log_File</code></td><td>現在のリレーログファイルの名前</td></tr><tr><td scope="row">3</td><td><code class="literal">Relay_log_pos</code></td><td><code class="literal">Relay_Log_Pos</code></td><td>リレーログファイル内の現在の位置。この位置までのイベントがスレーブデータベースで実行された</td></tr><tr><td scope="row">4</td><td><code class="literal">Master_log_name</code></td><td><code class="literal">Relay_Master_Log_File</code></td><td>リレーログファイル内のイベントが読み取られたマスターバイナリログファイルの名前</td></tr><tr><td scope="row">5</td><td><code class="literal">Master_log_pos</code></td><td><code class="literal">Exec_Master_Log_Pos</code></td><td>すでに実行されたイベントの、マスターのバイナリログファイル内での対応位置</td></tr><tr><td scope="row">5</td><td><code class="literal">Sql_delay</code></td><td><code class="literal">SQL_Delay</code></td><td>スレーブがマスターより遅れる必要がある秒数</td></tr><tr><td scope="row">6</td><td><code class="literal">Number_of_workers</code></td><td>[None]</td><td>レプリケーションイベント （トランザクション） を並列に実行するためのスレーブワーカースレッドの数 （MySQL バージョン 5.6.7 で追加）</td></tr><tr><td scope="row">7</td><td><code class="literal">Id</code></td><td>[None]</td><td>スレーブがマスターより遅れる必要がある秒数 （MySQL バージョン 5.6.7 で追加）</td></tr></tbody></table></div><p>
        MySQL 5.6 より前では、<code class="filename">relay-log.info</code> ファイルに行数または遅延値が含まれません (さらに、<code class="literal">slave_relay_log_info</code> テーブルを使用できません)。
      </p><div class="informaltable"><table summary="この表は、relay-log.info ファイル内の行、および Status カラムに表示される項目の間の対応を示します。" border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">行</th><th scope="col">Status カラム</th><th scope="col">説明</th></tr></thead><tbody><tr><td scope="row">1</td><td><code class="literal">Relay_Log_File</code></td><td>現在のリレーログファイルの名前</td></tr><tr><td scope="row">2</td><td><code class="literal">Relay_Log_Pos</code></td><td>リレーログファイル内の現在の位置。この位置までのイベントがスレーブデータベースで実行された</td></tr><tr><td scope="row">3</td><td><code class="literal">Relay_Master_Log_File</code></td><td>リレーログファイル内のイベントが読み取られたマスターバイナリログファイルの名前</td></tr><tr><td scope="row">4</td><td><code class="literal">Exec_Master_Log_Pos</code></td><td>すでに実行されたイベントの、マスターのバイナリログファイル内での対応位置</td></tr></tbody></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          スレーブサーバーを MySQL 5.6 より古いバージョンにダウングレードした場合、古いサーバーは <code class="filename">relay-log.info</code> ファイルを正しく読み取りません。これに対処するには、テキストエディタでファイルを変更し、行数を含む最初の行を削除してください。
        </p></div><p>
        <code class="filename">relay-log.info</code> ファイルの内容と <code class="literal">SHOW SLAVE STATUS</code> ステートメントで表示される状態は、<code class="filename">relay-log.info</code> ファイルがディスクにフラッシュされていない場合には一致しない場合があります。理想を言えば、オフライン (つまり、<code class="literal">mysqld</code> が動作していない) であるスレーブ上でのみ <code class="filename">relay-log.info</code> を表示することをお勧めします。動作中のシステムでは、<code class="literal">SHOW SLAVE STATUS</code> を使用するか、ステータスログをテーブルに書き込んでいる場合は <code class="literal">slave_master_info</code> および <code class="literal">slave_relay_log_info</code> テーブルを照会できます。
      </p><p>
        スレーブのデータをバックアップするときは、リレーログファイルに加えてこれらの 2 つのステータスログもバックアップすることをお勧めします。ステータスログは、スレーブからデータをリストアしたあとにレプリケーションを再開するために必要です。リレーログを失ったけれども、まだリレーログ情報ログがある場合には、それを調べて、マスターバイナリログで SQL スレッドがどのくらい離れて実行されたかを判断できます。それから <code class="literal">MASTER_LOG_FILE</code> および <code class="literal">MASTER_LOG_POS</code> オプションで <code class="literal">CHANGE MASTER TO</code> を使用することで、そのポイントからバイナリログを再度読み取るようにスレーブに指示できます。もちろん、これにはバイナリログがまだマスター上に存在している必要があります。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-rules"></a>17.2.3 サーバーがレプリケーションフィルタリングルールをどのように評価するか</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-rules-db-options">17.2.3.1 データベースレベルレプリケーションオプションおよびバイナリロギングオプションの評価</a></span></dt><dt><span class="section"><a href="replication.html#replication-rules-table-options">17.2.3.2 テーブルレベルレプリケーションオプションの評価</a></span></dt><dt><span class="section"><a href="replication.html#replication-rules-examples">17.2.3.3 レプリケーションルールの適用</a></span></dt></dl></div><p>
      マスターサーバーがそのバイナリログにステートメントを書き込まない場合は、ステートメントは複製されません。サーバーがステートメントのログを記録すると、ステートメントはすべてのスレーブに送信され、各スレーブはそれを実行するか無視するかを判断します。
    </p><p>
      マスターでは、<code class="option">--binlog-do-db</code> および <code class="option">--binlog-ignore-db</code> オプションを使用してバイナリロギングを制御することで、どのデータベースが変更ログを記録するかを制御できます。これらのオプションを評価するときにサーバーが使用するルールの詳細は、<a class="xref" href="replication.html#replication-rules-db-options" title="17.2.3.1 データベースレベルレプリケーションオプションおよびバイナリロギングオプションの評価">セクション17.2.3.1「データベースレベルレプリケーションオプションおよびバイナリロギングオプションの評価」</a>を参照してください。複製するデータベースとテーブルを制御するためにこれらのオプションを使用しないでください。代わりに、スレーブ上でフィルタリングを使用してスレーブで実行されるイベントを制御してください。
    </p><p>
      スレーブ側では、マスターから受け取るステートメントを実行するか無視するかの判断は、スレーブの起動時に使用される <code class="option">--replicate-*</code> オプションに従って行われます。<a class="xref" href="replication.html#replication-options" title="17.1.4 レプリケーションおよびバイナリロギングのオプションと変数">セクション17.1.4「レプリケーションおよびバイナリロギングのオプションと変数」</a>を参照してください。
    </p><p>
      <code class="option">--replicate-*</code> オプションがないときは (もっとも単純なケース)、スレーブはマスターから受け取るすべてのステートメントを実行します。そうでない場合は、結果は指定された特定のオプションに依存します。
    </p><p>
      データベースレベルオプション (<code class="option">--replicate-do-db</code>、<code class="option">--replicate-ignore-db</code>) が最初にチェックされます。このプロセスの説明については、<a class="xref" href="replication.html#replication-rules-db-options" title="17.2.3.1 データベースレベルレプリケーションオプションおよびバイナリロギングオプションの評価">セクション17.2.3.1「データベースレベルレプリケーションオプションおよびバイナリロギングオプションの評価」</a>を参照してください。データベースレベルオプションが使用されない場合は、オプションチェックはテーブルレベルオプション (使用されている場合がある) のチェックに進みます (これらの説明については、<a class="xref" href="replication.html#replication-rules-table-options" title="17.2.3.2 テーブルレベルレプリケーションオプションの評価">セクション17.2.3.2「テーブルレベルレプリケーションオプションの評価」</a>を参照してください)。1 つ以上のデータベースレベルオプションが使用されているけれども、一致するものがない場合は、ステートメントは複製されません。
    </p><p>
      データベースにのみ影響するステートメントの場合 (つまり、<code class="literal">CREATE DATABASE</code>、<code class="literal">DROP DATABASE</code>、および <code class="literal">ALTER DATABASE</code>)、データベースレベルオプションは <code class="option">--replicate-wild-do-table</code> オプションより常に優先されます。つまり、このようなステートメントの場合、適用するデータベースレベルオプションがない場合にかぎり、<code class="option">--replicate-wild-do-table</code> オプションがチェックされます。これは、MySQL の以前のバージョンの動作からの変更です。スレーブが <code class="option">--replicate-do-db=dbx</code> <code class="option">--replicate-wild-do-table=db%.t1</code> で起動された場合には、ステートメント <code class="literal">CREATE DATABASE dbx</code> は複製されませんでした。(Bug #46110)
    </p><p>
      オプションセットに何が影響するかの判断を簡素化するために、<span class="quote">「<span class="quote">do</span>」</span> と <span class="quote">「<span class="quote">ignore</span>」</span> オプション、またはワイルドカードと非ワイルドカードオプションを混在させるのを避けることをお勧めします。
    </p><p>
      <code class="option">--replicate-rewrite-db</code> オプションが指定された場合、それらは <code class="option">--replicate-*</code> フィルタリングルールがテストされる前に適用されます。
    </p><a class="indexterm" name="idm139979047625344"></a><a class="indexterm" name="idm139979047623056"></a><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        MySQL 5.6 では、すべてのレプリケーションフィルタリングオプションは、<code class="literal">lower_case_table_names</code> システム変数の影響を含めて、MySQL サーバー内のほかの場所のデータベースおよびテーブルの名前に適用されるものと同じ、大文字と小文字の区別に関するルールに従います。
      </p><p>
        これは以前のバージョンの MySQL からの変更点です。(Bug #51639)
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-rules-db-options"></a>17.2.3.1 データベースレベルレプリケーションオプションおよびバイナリロギングオプションの評価</h4></div></div></div><p>
        レプリケーションオプションを評価するときに、スレーブは適用される <code class="option">--replicate-do-db</code> または <code class="option">--replicate-ignore-db</code> オプションがあるかどうかを検査することで始めます。<code class="option">--binlog-do-db</code> または <code class="option">--binlog-ignore-db</code> を使用するときは、プロセスは似ていますが、オプションはマスター上で検査されます。
      </p><p>
        ステートメントレベルレプリケーションでは、デフォルトデータベースの一致が検査されます。行ベースレプリケーションでは、データを変更すべきデータベースが検査されるデータベースです。バイナリロギング形式にかかわらず、データベースレベルオプションの検査は次の図で示すように進みます。
      </p><div class="mediaobject"><img src="images/replication-filtering-db-rules.png" width="600" height="635" alt="レプリケーションでのデータベースレベルフィルタリングルールの評価"></div><p>
        関係する手順の一覧は次のとおりです。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            <code class="option">--replicate-do-db</code> オプションはありますか ?
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>はい </b>
                  それらのいずれかがデータベースに一致しますか ?

                  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>はい </b>
                          ステートメントを実行して終了します。
                        </p></li><li class="listitem"><p><b>いいえ </b>
                          ステートメントを無視して終了します。
                        </p></li></ul></div><p>
                </p></li><li class="listitem"><p><b>いいえ </b>
                  手順 2 に進みます。
                </p></li></ul></div></li><li class="listitem"><p>
            <code class="option">--replicate-ignore-db</code> オプションはありますか ?
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>はい </b>
                  それらのいずれかがデータベースに一致しますか ?

                  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>はい </b>
                          ステートメントを無視して終了します。
                        </p></li><li class="listitem"><p><b>いいえ </b>
                          手順 3 に進みます。
                        </p></li></ul></div><p>
                </p></li><li class="listitem"><p><b>いいえ </b>
                  手順 3 に進みます。
                </p></li></ul></div></li><li class="listitem"><p>
            テーブルレベルレプリケーションオプションがある場合、それらの検査に進みます。これらのオプションの検査方法の説明については、<a class="xref" href="replication.html#replication-rules-table-options" title="17.2.3.2 テーブルレベルレプリケーションオプションの評価">セクション17.2.3.2「テーブルレベルレプリケーションオプションの評価」</a>を参照してください。
          </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
              この段階でまだ許可されているステートメントは、実際にはまだ実行されていません。ステートメントはすべてのテーブルレベルオプション （ある場合） が検査されるまで実行されず、そのプロセスの結果がステートメントの実行を許可します。
            </p></div></li></ol></div><p>
        バイナリロギングの場合、関連する手順の一覧は次のとおりです。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            <code class="option">--binlog-do-db</code> または <code class="option">--binlog-ignore-db</code> オプションはありますか ?
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>はい </b>
                  手順 2 に進みます。
                </p></li><li class="listitem"><p><b>いいえ </b>
                  ステートメントのログを記録して終了します。
                </p></li></ul></div></li><li class="listitem"><p>
            デフォルトデータベースはありますか (データベースが <code class="literal">USE</code> で選択されていますか) ?
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>はい </b>
                  手順 3 に進みます。
                </p></li><li class="listitem"><p><b>いいえ </b>
                  ステートメントを無視して終了します。
                </p></li></ul></div></li><li class="listitem"><p>
            デフォルトデータベースがあります。<code class="option">--binlog-do-db</code> オプションはありますか ?
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>はい </b>
                  それらのいずれかがデータベースに一致しますか ?

                  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>はい </b>
                          ステートメントのログを記録して終了します。
                        </p></li><li class="listitem"><p><b>いいえ </b>
                          ステートメントを無視して終了します。
                        </p></li></ul></div><p>
                </p></li><li class="listitem"><p><b>いいえ </b>
                  手順 4 に進みます。
                </p></li></ul></div></li><li class="listitem"><p>
            <code class="option">--binlog-ignore-db</code> オプションのいずれかがデータベースに一致しますか ?
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>はい </b>
                  ステートメントを無視して終了します。
                </p></li><li class="listitem"><p><b>いいえ </b>
                  ステートメントのログを記録して終了します。
                </p></li></ul></div></li></ol></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          ステートメントベースロギングの場合、<code class="literal">CREATE DATABASE</code>、<code class="literal">ALTER DATABASE</code>、および <code class="literal">DROP DATABASE</code> ステートメントに適用されるルールにだけ例外が作成されています。これらの場合には、更新のログを記録または無視するかを判断するときに、<span class="emphasis"><em>作成、変更、またはドロップされる</em></span>データベースがデフォルトデータベースを置き換えます。
        </p></div><p>
        <code class="option">--binlog-do-db</code> は<span class="quote">「<span class="quote">ほかのデータベースを無視する</span>」</span>ことを意味する場合があります。たとえば、ステートメントベースロギングを使用するときに、<code class="option">--binlog-do-db=sales</code> だけで動作するサーバーは、デフォルトデータベースが <code class="literal">sales</code> ではないバイナリログステートメントに書き込みません。同じオプションで行ベースロギングを使用するときは、サーバーは <code class="literal">sales</code> 内のデータを変更する更新のみのログを記録します。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-rules-table-options"></a>17.2.3.2 テーブルレベルレプリケーションオプションの評価</h4></div></div></div><p>
        スレーブは、次の 2 つの条件のいずれかが true の場合にのみ、テーブルオプションを検査して評価します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            一致するデータベースオプションが見つからなかった。
          </p></li><li class="listitem"><p>
            1 つ以上のデータベースオプションが見つかり、前のセクションで説明したルール (<a class="xref" href="replication.html#replication-rules-db-options" title="17.2.3.1 データベースレベルレプリケーションオプションおよびバイナリロギングオプションの評価">セクション17.2.3.1「データベースレベルレプリケーションオプションおよびバイナリロギングオプションの評価」</a>を参照) に従って、<span class="quote">「<span class="quote">実行</span>」</span>条件に達していると評価された。
          </p></li></ul></div><p>
        最初に、予備条件として、スレーブはステートメントベースレプリケーションが有効であるかどうかを検査します。そうである場合、かつステートメントがストアドファンクション内にある場合には、スレーブはステートメントを実行して終了します。行ベースレプリケーションが有効である場合、スレーブはステートメントがマスター上のストアドファンクション内にあるかどうかがわからないため、この条件は適用されません。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          ステートメントベースレプリケーションの場合、レプリケーションイベントがステートメントを表現します (あるイベントを構成するすべての変更が単一 SQL ステートメントに関連付けられています)。行ベースレプリケーションの場合、各イベントが単一テーブル行内の変更を表現します (このため、<code class="literal">UPDATE mytable SET mycol = 1</code> などの単一ステートメントが多くの行ベースイベントを生成する場合があります)。イベントの観点から見ると、テーブルオプションを検査するプロセスは行ベースおよびステートメントベースレプリケーションの両方について同じです。
        </p></div><p>
        このポイントに到達して、テーブルオプションがない場合には、スレーブは単純にすべてのイベントを実行します。<code class="option">--replicate-do-table</code> または <code class="option">--replicate-wild-do-table</code> オプションがある場合は、それが実行すべきイベントの場合、イベントはこれらのいずれかに一致する必要があります。そうでない場合、無視されます。<code class="option">--replicate-ignore-table</code> または <code class="option">--replicate-wild-ignore-table</code> オプションがある場合、これらのオプションのいずれかに一致するものを除いてすべてのイベントが実行されます。このプロセスを次の図に示します。
      </p><div class="mediaobject"><img src="images/replication-filtering-tbl-rules.png" width="585" height="1245" alt="レプリケーションでのテーブルレベルフィルタリングルールの評価"></div><p>
        次の手順で、この評価の詳細について説明します。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            テーブルオプションがありますか ?
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>はい </b>
                  手順 2 に進みます。
                </p></li><li class="listitem"><p><b>いいえ </b>
                  イベントを実行して終了します。
                </p></li></ul></div></li><li class="listitem"><p>
            <code class="option">--replicate-do-table</code> オプションはありますか ?
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>はい </b>
                  テーブルはそれらのいずれかに一致しますか ?
                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>はい </b>
                      イベントを実行して終了します。
                    </p></li><li class="listitem"><p><b>いいえ </b>
                      手順 3 に進みます。
                    </p></li></ul></div></li><li class="listitem"><p><b>いいえ </b>
                  手順 3 に進みます。
                </p></li></ul></div></li><li class="listitem"><p>
            <code class="option">--replicate-ignore-table</code> オプションはありますか ?
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>はい </b>
                  テーブルはそれらのいずれかに一致しますか ?
                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>はい </b>
                      イベントを無視して終了します。
                    </p></li><li class="listitem"><p><b>いいえ </b>
                      手順 4 に進みます。
                    </p></li></ul></div></li><li class="listitem"><p><b>いいえ </b>
                  手順 4 に進みます。
                </p></li></ul></div></li><li class="listitem"><p>
            <code class="option">--replicate-wild-do-table</code> オプションはありますか ?
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>はい </b>
                  テーブルはそれらのいずれかに一致しますか ?
                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>はい </b>
                      イベントを実行して終了します。
                    </p></li><li class="listitem"><p><b>いいえ </b>
                      手順 5 に進みます。
                    </p></li></ul></div></li><li class="listitem"><p><b>いいえ </b>
                  手順 5 に進みます。
                </p></li></ul></div></li><li class="listitem"><p>
            <code class="option">--replicate-wild-ignore-table</code> オプションはありますか ?
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>はい </b>
                  テーブルはそれらのいずれかに一致しますか ?
                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>はい </b>
                      イベントを無視して終了します。
                    </p></li><li class="listitem"><p><b>いいえ </b>
                      手順 6 に進みます。
                    </p></li></ul></div></li><li class="listitem"><p><b>いいえ </b>
                  手順 6 に進みます。
                </p></li></ul></div></li><li class="listitem"><p>
            <code class="option">--replicate-do-table</code> または <code class="option">--replicate-wild-do-table</code> オプションはありますか ?
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>はい </b>
                  イベントを無視して終了します。
                </p></li><li class="listitem"><p><b>いいえ </b>
                  イベントを実行して終了します。
                </p></li></ul></div></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-rules-examples"></a>17.2.3.3 レプリケーションルールの適用</h4></div></div></div><p>
        このセクションでは、レプリケーションフィルタリングオプションのさまざまな組み合わせの追加説明と例を示します。
      </p><p>
        次の表に、レプリケーションフィルタルールのいくつかの典型的な組み合わせをいくつか示します。
      </p><div class="informaltable"><table summary="この表では、レプリケーションフィルタルールタイプの典型的組み合わせを示し、それぞれの結果について説明します。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">条件 (オプションのタイプ)</th><th scope="col">結果</th></tr></thead><tbody><tr><td scope="row"><code class="option">--replicate-*</code> オプションが全然ない</td><td>スレーブはマスターから受け取るすべてのイベントを実行します。</td></tr><tr><td scope="row"><code class="option">--replicate-*-db</code> オプション、しかしテーブルオプションがない</td><td>スレーブは、データベースオプションを使用してイベントを受け入れるか無視します。テーブル制約がないため、これらのオプションで許可されるすべてのイベントを実行します。</td></tr><tr><td scope="row"><code class="option">--replicate-*-table</code> オプション、しかしデータベースオプションがない</td><td>データベース条件がないため、データベース検査段階ですべてのイベントが受け入れられます。スレーブは、テーブルオプションにのみ基づいてイベントを実行または無視します。</td></tr><tr><td scope="row">データベースおよびテーブルオプションの組み合わせ</td><td>スレーブは、データベースオプションを使用してイベントを受け入れるか無視します。それから、テーブルオプションに従ってこれらのオプションで許可されるすべてのイベントを評価します。これは、直観に反しているように見えたり、ステートメントベースまたは行ベースレプリケーションのどちらを使用するかによって異なる結果となったりする場合があります。例のテキストを参照してください。</td></tr></tbody></table></div><p>
        より複雑な例を示します。ステートメントベースおよび行ベースの両方の設定の結果を調べます。
      </p><p>
        データベース <code class="literal">db1</code> 内に <code class="literal">mytbl1</code>、データベース <code class="literal">db2</code> 内に <code class="literal">mytbl2</code> という 2つのテーブルがマスター上にあり、スレーブが次のオプションで動作していると想定します （ほかのレプリケーションフィルタリングオプションはない）。
      </p><pre class="programlisting">
replicate-ignore-db = db1
replicate-do-table  = db2.tbl2
</pre><p>
        ここで、次のステートメントをマスター上で実行します。
      </p><pre class="programlisting">
USE db1;
INSERT INTO db2.tbl2 VALUES (1);
</pre><p>
        スレーブでの結果はバイナリログ形式によって大きく異なり、どちらかのケースで当初の予測に一致しない場合があります。
      </p><p><b>ステートメントベースのレプリケーション </b>
          <code class="literal">USE</code> ステートメントによって <code class="literal">db1</code> がデフォルトデータベースになります。このため、<code class="option">--replicate-ignore-db</code> オプションが一致し、<span class="emphasis"><em><code class="literal">INSERT</code> ステートメントが無視されます</em></span>。テーブルオプションは検査されません。
        </p><p><b>行ベースのレプリケーション </b>
          デフォルトデータベースは、行ベースレプリケーションを使用するときにスレーブがデータベースオプションをどのように読み取るかに影響しません。その結果、<code class="literal">USE</code> ステートメントは <code class="option">--replicate-ignore-db</code> オプションがどのように処理されるかに違いをもたらしません。このオプションで指定されるデータベースは <code class="literal">INSERT</code> ステートメントがデータを変更するデータベースに一致しないため、スレーブはテーブルオプションの検査に進みます。<code class="option">--replicate-do-table</code> で指定されるテーブルは、更新すべきテーブルに一致し、<span class="emphasis"><em>行が挿入されます</em></span>。
        </p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="replication-solutions"></a>17.3 レプリケーションソリューション</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-solutions-backups">17.3.1 バックアップ用にレプリケーションを使用する</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-diffengines">17.3.2 異なるマスターおよびスレーブストレージエンジンでレプリケーションを使用する</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-scaleout">17.3.3 スケールアウトのためにレプリケーションを使用する</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-partitioning">17.3.4 異なるデータベースを異なるスレーブに複製する</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-performance">17.3.5 レプリケーションパフォーマンスを改善する</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-switch">17.3.6 フェイルオーバー中にマスターを切り替える</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-ssl">17.3.7 SSL を使用してレプリケーションをセットアップする</a></span></dt><dt><span class="section"><a href="replication.html#replication-semisync">17.3.8 準同期レプリケーション</a></span></dt><dt><span class="section"><a href="replication.html#replication-delayed">17.3.9 遅延レプリケーション</a></span></dt></dl></div><p>
    レプリケーションは、多くの異なる環境でさまざまな目的に使用できます。このセクションでは、特定のソリューションタイプにレプリケーションを使用する場合の一般的な注意点とアドバイスを提供します。
  </p><p>
    セットアップに関する注意点、バックアップ手順、バックアップするファイルなど、バックアップ環境でレプリケーションを使用する場合の情報については、<a class="xref" href="replication.html#replication-solutions-backups" title="17.3.1 バックアップ用にレプリケーションを使用する">セクション17.3.1「バックアップ用にレプリケーションを使用する」</a>を参照してください。
  </p><p>
    マスターとスレーブで異なるストレージエンジンを使用している場合のアドバイスやヒントは、<a class="xref" href="replication.html#replication-solutions-diffengines" title="17.3.2 異なるマスターおよびスレーブストレージエンジンでレプリケーションを使用する">セクション17.3.2「異なるマスターおよびスレーブストレージエンジンでレプリケーションを使用する」</a>を参照してください。
  </p><p>
    スケールアウトソリューションとしてレプリケーションを使用するには、ソリューションを使用するアプリケーションのロジックとオペレーションで若干の変更が必要になります。<a class="xref" href="replication.html#replication-solutions-scaleout" title="17.3.3 スケールアウトのためにレプリケーションを使用する">セクション17.3.3「スケールアウトのためにレプリケーションを使用する」</a>を参照してください。
  </p><p>
    パフォーマンスやデータ分散のため、データベースごとに異なるレプリケーションスレーブに複製することをお勧めします。<a class="xref" href="replication.html#replication-solutions-partitioning" title="17.3.4 異なるデータベースを異なるスレーブに複製する">セクション17.3.4「異なるデータベースを異なるスレーブに複製する」</a>を参照してください。
  </p><p>
    レプリケーションスレーブの数が増えるにつれ、マスターでの負荷が増えてパフォーマンスの低下につながる可能性があります (バイナリログを各スレーブに複製する必要があるため)。単一セカンダリサーバーをレプリケーションマスターとして使用する方法など、レプリケーションパフォーマンスを向上するためのヒントについては、<a class="xref" href="replication.html#replication-solutions-performance" title="17.3.5 レプリケーションパフォーマンスを改善する">セクション17.3.5「レプリケーションパフォーマンスを改善する」</a>を参照してください。
  </p><p>
    非常時のフェイルオーバーソリューションの一環としてマスターを切り替えたりスレーブをマスターに変換したりする際のガイドについては、<a class="xref" href="replication.html#replication-solutions-switch" title="17.3.6 フェイルオーバー中にマスターを切り替える">セクション17.3.6「フェイルオーバー中にマスターを切り替える」</a>を参照してください。
  </p><p>
    レプリケーション通信を安全に行うため、SSL を使用して通信チャネルを暗号化できます。手順を追った説明については、<a class="xref" href="replication.html#replication-solutions-ssl" title="17.3.7 SSL を使用してレプリケーションをセットアップする">セクション17.3.7「SSL を使用してレプリケーションをセットアップする」</a>を参照してください。
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-solutions-backups"></a>17.3.1 バックアップ用にレプリケーションを使用する</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-solutions-backups-mysqldump">17.3.1.1 mysqldump を使用してスレーブをバックアップする</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-backups-rawdata">17.3.1.2 スレーブからローデータをバックアップする</a></span></dt><dt><span class="section"><a href="replication.html#replication-solutions-backups-read-only">17.3.1.3 マスターまたはスレーブを読み取り専用にしてバックアップする</a></span></dt></dl></div><p>
      レプリケーションをバックアップソリューションとして使用するには、データをマスターからスレーブに複製してから、データスレーブをバックアップします。スレーブはマスターの実行動作に影響を与えずに一時停止したりシャットダウンしたりできるため、<span class="quote">「<span class="quote">ライブ</span>」</span>データの効果的なスナップショットを作成できます (ほかの方法ではマスターをシャットダウンする必要がある)。
    </p><p>
      データベースをどのようにバックアップするかは、そのサイズ、およびデータだけまたはデータとレプリケーションスレーブ状態 (障害時にスレーブを再構築できるように) をバックアップするのかによって異なります。つまり、2 つの選択肢があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          マスター上のデータをバックアップするためのソリューションとしてレプリケーションを使用し、データベースのサイズがあまり大きくない場合は、<span class="command"><strong>mysqldump</strong></span> ツールをお勧めします。<a class="xref" href="replication.html#replication-solutions-backups-mysqldump" title="17.3.1.1 mysqldump を使用してスレーブをバックアップする">セクション17.3.1.1「mysqldump を使用してスレーブをバックアップする」</a>を参照してください。
        </p></li><li class="listitem"><p>
          より大きなデータベースの場合は、<span class="command"><strong>mysqldump</strong></span> は実用的または効率的でなく、代わりにローデータファイルをバックアップできます。ローデータファイルオプションを使用することは、スレーブ障害時にスレーブを再作成できるように、バイナリおよびリレーログをバックアップできることも意味します。詳細については、<a class="xref" href="replication.html#replication-solutions-backups-rawdata" title="17.3.1.2 スレーブからローデータをバックアップする">セクション17.3.1.2「スレーブからローデータをバックアップする」</a>を参照してください。
        </p></li></ul></div><p>
      もう一つのバックアップ方法は読み取り専用状態のサーバーを置くことで、これはマスターまたはスレーブサーバーに使用できます。バックアップは読み取り専用サーバーに対して実行され、これが通常の読み取り/書き込み操作ステータスに戻されます。<a class="xref" href="replication.html#replication-solutions-backups-read-only" title="17.3.1.3 マスターまたはスレーブを読み取り専用にしてバックアップする">セクション17.3.1.3「マスターまたはスレーブを読み取り専用にしてバックアップする」</a>を参照してください。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-solutions-backups-mysqldump"></a>17.3.1.1 mysqldump を使用してスレーブをバックアップする</h4></div></div></div><p>
        <span class="command"><strong>mysqldump</strong></span> を使用してデータベースのコピーを作成することで、MySQL Server の別のインスタンスに情報をインポートできる形式でデータベース内のすべてのデータを取得できます (<a class="xref" href="programs.html#mysqldump" title="4.5.4 mysqldump — データベースバックアッププログラム">セクション4.5.4「<span class="command"><strong>mysqldump</strong></span> — データベースバックアッププログラム」</a>を参照してください)。情報の形式が SQL ステートメントであるため、緊急時にデータにアクセスする必要がある場合にファイルを実行中サーバーに配布して適用することも簡単にできます。ただし、データセットのサイズが非常に大きい場合は、<span class="command"><strong>mysqldump</strong></span> が実用的でない場合があります。
      </p><p>
        <span class="command"><strong>mysqldump</strong></span> を使用するときは、一貫性のあるデータセットがダンプに含まれるように、スレーブ上でレプリケーションを停止してからダンププロセスを起動してください。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            スレーブでの要求処理を停止します。<span class="command"><strong>mysqladmin</strong></span> を使用してスレーブでのレプリケーションを完全に停止できます。
          </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysqladmin stop-slave</code></strong></pre><p>
            イベント実行を一時停止するために、スレーブ SQL スレッドだけを停止することもできます。
          </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysql -e 'STOP SLAVE SQL_THREAD;'</code></strong></pre><p>
            これにより、スレーブは引き続きマスターのバイナリログからデータ変更イベントを受け取り、I/O スレッドを使用してそれらをリレーログに格納できますが、スレーブはこれらのイベントを実行したりそのデータを変更したりできません。ビジーなレプリケーション環境では、バックアップ中に I/O スレッドの実行を許可することで、スレーブ SQL スレッド再起動時に追い付くプロセスの速度が向上する場合があります。
          </p></li><li class="listitem"><p>
            <span class="command"><strong>mysqldump</strong></span> を実行してデータベースをダンプします。すべてのデータベースをダンプしたり、ダンプするデータベースを選択したりできます。たとえば、すべてのデータベースをダンプするには: 
          </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysqldump --all-databases &gt; fulldb.dump</code></strong></pre></li><li class="listitem"><p>
            ダンプが完了したら、スレーブの動作を再開します。
          </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysqladmin start-slave</code></strong></pre></li></ol></div><p>
        前の例では、ログイン資格証明 (ユーザー名、パスワード) をコマンドに追加したり、毎日自動的に実行できるプロセスをスクリプトにバンドルしたりすることをお勧めします。
      </p><p>
        この方法を使用する場合、スレーブレプリケーションプロセスをモニターして、バックアップの実行にかかる時間がマスターからのイベントにスレーブが追い付く能力に影響しないようにしてください。<a class="xref" href="replication.html#replication-administration-status" title="17.1.5.1 レプリケーションステータスの確認">セクション17.1.5.1「レプリケーションステータスの確認」</a>を参照してください。スレーブが追い付けない場合は、別のスレーブを追加してバックアッププロセスを分散することをお勧めします。このシナリオの構成方法の例は、<a class="xref" href="replication.html#replication-solutions-partitioning" title="17.3.4 異なるデータベースを異なるスレーブに複製する">セクション17.3.4「異なるデータベースを異なるスレーブに複製する」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-solutions-backups-rawdata"></a>17.3.1.2 スレーブからローデータをバックアップする</h4></div></div></div><p>
        コピーされるファイルの完全性を保証するには、MySQL レプリケーションスレーブ上のローデータファイルのバックアップが、スレーブサーバーがシャットダウンしている間に実行されるべきです。MySQL サーバーがまだ実行中の場合は、バックグラウンドタスクがデータベースファイルをまだ更新中の可能性があります (特に、<code class="literal">InnoDB</code> などのストレージエンジンをバックグラウンドプロセスで使用するもの)。<code class="literal">InnoDB</code> の場合、これらの問題はクラッシュリカバリ中に解決されるはずですが、バックアッププロセス中にマスターの実行に影響を与えずにスレーブサーバーをシャットダウンできるため、この機能を利用することは意味があります。
      </p><p>
        サーバーをシャットダウンしてファイルをバックアップするには：
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            スレーブ MySQL サーバーをシャットダウンします。
          </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysqladmin shutdown</code></strong></pre></li><li class="listitem"><p>
            データファイルをコピーします。<span class="command"><strong>cp</strong></span>、<span class="command"><strong>tar</strong></span>、<span class="command"><strong>WinZip</strong></span> など、コピーまたはアーカイブに適したユーティリティーを使用できます。たとえば、データディレクトリが現在のディレクトリの下にある場合、ディレクトリ全体を次のようにアーカイブできます。
          </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>tar cf /tmp/dbbackup.tar ./data</code></strong></pre></li><li class="listitem"><p>
            MySQL サーバーを再起動します。Unix の場合:
          </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysqld_safe &amp;</code></strong></pre><p>
            Windows の場合:
          </p><pre class="programlisting">C:\&gt; <strong class="userinput"><code>"C:\Program Files\MySQL\MySQL Server 5.6\bin\mysqld"</code></strong></pre></li></ol></div><p>
        通常は、スレーブ MySQL サーバーのデータディレクトリ全体をバックアップしてください。データをリストアしてそれらをスレーブとして運用できるようにしたい場合 (たとえば、スレーブの障害時)、スレーブのデータに加えて、スレーブステータスファイル、マスター情報およびリレーログ情報リポジトリ、およびリレーログファイルもバックアップしてください。これらのファイルは、スレーブのデータをリストアしたあとにレプリケーションを再開するために必要です。
      </p><p>
        リレーログを失ったけれども <code class="filename">relay-log.info</code> ファイルがある場合は、これを調べることで SQL スレッドがマスターバイナリログ内でどのくらい実行されたかを判断できます。それから <code class="literal">MASTER_LOG_FILE</code> および <code class="literal">MASTER_LOG_POS</code> オプションで <code class="literal">CHANGE MASTER TO</code> を使用することで、そのポイントからバイナリログを再度読み取るようにスレーブに指示できます。これには、マスターサーバー上にバイナリログが残っている必要があります。
      </p><p>
        スレーブが <code class="literal">LOAD DATA INFILE</code> ステートメントをレプリケートする場合、スレーブがこのために使用するディレクトリ内に存在する <code class="filename">SQL_LOAD-*</code> ファイルもバックアップしてください。スレーブは、中断した <code class="literal">LOAD DATA INFILE</code> 操作のレプリケーションを再開するためにこれらのファイルを必要とします。このディレクトリの場所は <code class="option">--slave-load-tmpdir</code> オプションの値です。そのオプションでサーバーを起動しなかった場合、ディレクトリの場所は <code class="literal">tmpdir</code> システム変数の値になります。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-solutions-backups-read-only"></a>17.3.1.3 マスターまたはスレーブを読み取り専用にしてバックアップする</h4></div></div></div><p>
        グローバル読み取りロックを獲得してから <code class="literal">read_only</code> システム変数を操作して、バックアップするサーバーの状態を読み取り専用に変更することで、レプリケーションセットアップでマスターまたはスレーブサーバーをバックアップできます。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            サーバーを読み取り専用にします (検索のみが処理され、更新はブロックされます)。
          </p></li><li class="listitem"><p>
            バックアップを実行します。
          </p></li><li class="listitem"><p>
            サーバーを通常の読み取り/書き込み状態に戻します。
          </p></li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          このセクションの手順では、バックアップするサーバーを、サーバーからデータを取得するバックアップ方式 (<span class="command"><strong>mysqldump</strong></span> など) に安全な状態に変換しています (<a class="xref" href="programs.html#mysqldump" title="4.5.4 mysqldump — データベースバックアッププログラム">セクション4.5.4「<span class="command"><strong>mysqldump</strong></span> — データベースバックアッププログラム」</a>を参照してください)。バイナリバックアップを作成するために、ファイルを直接コピーする方法でこれらの手順の使用を試みてはいけません (サーバーが変更後データをまだメモリー内にキャッシュしていてディスクにフラッシュしていない可能性があるため)。
        </p></div><p>
        後続の手順では、マスターサーバーおよびスレーブサーバーに対してこれを行う方法を説明します。ここで説明する両方のシナリオでは、次のレプリケーションセットアップを想定します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            マスターサーバー M1
          </p></li><li class="listitem"><p>
            マスターとして M1 を持つスレーブサーバー S1
          </p></li><li class="listitem"><p>
            M1 に接続されたクライアント C1
          </p></li><li class="listitem"><p>
            S1 に接続されたクライアント C2
          </p></li></ul></div><p>
        どちらのシナリオでも、グローバル読み取りロックを獲得して <code class="literal">read_only</code> 変数を操作するステートメントは、バックアップするサーバーで実行され、そのサーバーのスレーブには伝達されません。
      </p><p>
        <span class="bold"><strong>シナリオ 1: 読み取り専用マスターでのバックアップ</strong></span>
      </p><p>
        これらのステートメントをマスター M1 で実行して、これを読み取り専用状態にします。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>FLUSH TABLES WITH READ LOCK;</code></strong>
mysql&gt; <strong class="userinput"><code>SET GLOBAL read_only = ON;</code></strong>
</pre><p>
        M1 が読み取り専用状態のときは、次の属性が true になります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            C1 によって M1 に送られる更新要求は、サーバーが読み取り専用モードであるためブロックされます。
          </p></li><li class="listitem"><p>
            C1 によって M1 に送られるクエリー結果要求は成功します。
          </p></li><li class="listitem"><p>
            M1 でバックアップを作成することは安全です。
          </p></li><li class="listitem"><p>
            S1 でバックアップを作成することは安全ではありません。このサーバーはまだ実行中で、バイナリログを処理中であったり、クライアント C2 から着信する要求を更新したりする可能性があります。
          </p></li></ul></div><p>
        M1 が読み取り専用のときに、バックアップを実行してください。たとえば、<span class="command"><strong>mysqldump</strong></span> を使用できます。
      </p><p>
        M1 でのバックアップ操作が完了したあとに、これらのステートメントを実行することで M1 を通常の動作状態に戻します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET GLOBAL read_only = OFF;</code></strong>
mysql&gt; <strong class="userinput"><code>UNLOCK TABLES;</code></strong>
</pre><p>
        M1 でバックアップを実行することは安全ですが (バックアップに関するかぎり)、パフォーマンスには最適ではありません (M1 のクライアントが更新の実行をブロックされるため)。
      </p><p>
        この方法は、レプリケーションセットアップのマスターサーバーのバックアップに適用されますが、非レプリケーションセットアップの単一サーバーに使用することもできます。
      </p><p>
        <span class="bold"><strong>シナリオ 2: 読み取り専用スレーブでのバックアップ</strong></span>
      </p><p>
        これらのステートメントをスレーブ S1 で実行して、これを読み取り専用状態にします。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>FLUSH TABLES WITH READ LOCK;</code></strong>
mysql&gt; <strong class="userinput"><code>SET GLOBAL read_only = ON;</code></strong>
</pre><p>
        S1 が読み取り専用状態のときは、次の属性が true になります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            マスター M1 が動作を継続しているため、マスター上でバックアップを作成することは安全ではありません。
          </p></li><li class="listitem"><p>
            スレーブ S1 が停止しているため、スレーブ S1 上でバックアップを作成することは安全です。
          </p></li></ul></div><p>
        これらの属性は一般的なバックアップシナリオの基礎を提供します。あるスレーブが少しの間バックアップの実行でビジーであっても問題ではありません。ネットワーク全体に影響せず、システムはバックアップ中でも動作しているためです。特に、クライアントは引き続きマスターサーバー上で更新を実行でき、依然としてスレーブでのバックアップアクティビティーによる影響を受けません。
      </p><p>
        S1 が読み取り専用のときに、バックアップを実行してください。たとえば、<span class="command"><strong>mysqldump</strong></span> を使用できます。
      </p><p>
        S1 でのバックアップ操作が完了したあとに、これらのステートメントを実行することで S1 を通常の動作状態に戻します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET GLOBAL read_only = OFF;</code></strong>
mysql&gt; <strong class="userinput"><code>UNLOCK TABLES;</code></strong>
</pre><p>
        スレーブは、通常動作に戻ったあとにマスターのバイナリログからの未処理の更新に追い付くことで、ふたたびマスターに同期されます。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-solutions-diffengines"></a>17.3.2 異なるマスターおよびスレーブストレージエンジンでレプリケーションを使用する</h3></div></div></div><p>
      レプリケーションプロセスでは、マスター上のソーステーブルとスレーブ上の複製先テーブルが異なるエンジンタイプを使用しているかどうかは重要ではありません。実際、<code class="literal">default_storage_engine</code> および <code class="literal">storage_engine</code> システム変数は複製されません。
    </p><p>
      これは、異なるレプリケーションシナリオに異なるエンジンタイプを利用できるという点で、レプリケーションプロセスにいくつかの利点を提供します。たとえば、典型的なスケールアウトシナリオでは (<a class="xref" href="replication.html#replication-solutions-scaleout" title="17.3.3 スケールアウトのためにレプリケーションを使用する">セクション17.3.3「スケールアウトのためにレプリケーションを使用する」</a>を参照してください)、マスター上ではトランザクション機能を利用するために <code class="literal">InnoDB</code> テーブルを使用し、スレーブ上ではデータが読み取られるだけでトランザクションサポートが必要ないので <code class="literal">MyISAM</code> を使用します。データロギング環境でレプリケーションを使用するときは、スレーブ上で <code class="literal">Archive</code> ストレージエンジンを使用することをお勧めします。
    </p><p>
      マスターおよびスレーブ上で異なるエンジンを構成するかどうかは、最初のレプリケーションプロセスをどのようにセットアップするかに依存します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <span class="command"><strong>mysqldump</strong></span> を使用してマスター上のデータベーススナップショットを作成した場合は、ダンプファイルテキストを編集して各テーブルで使用されるエンジンタイプを変更できます。
        </p><p>
          <span class="command"><strong>mysqldump</strong></span> の別の使用方法は、スレーブ上で使用したくないエンジンタイプを無効にしてから、このダンプを使用してスレーブ上にデータを構築することです。たとえば、<code class="literal">FEDERATED</code> エンジンを無効にするために、<code class="option">--skip-federated</code> オプションをスレーブ上に追加できます。作成するテーブル用に特定のエンジンが存在しない場合、MySQL はデフォルトエンジンタイプ （通常は <code class="literal">MyISAM</code>） を使用します。(これには、<code class="literal">NO_ENGINE_SUBSTITUTION</code> SQL モードが有効でないことが必要です。)この方法でほかのエンジンを無効にする場合は、必要なエンジンだけをサポートする特別なバイナリを構築してスレーブで使用することを検討することをお勧めします。
        </p></li><li class="listitem"><p>
          ローデータファイル (バイナリバックアップ) を使用してスレーブをセットアップしている場合、最初のテーブル形式を変更できなくなります。代わりに、スレーブが起動したあとに <code class="literal">ALTER TABLE</code> を使用してテーブルタイプを変更してください。
        </p></li><li class="listitem"><p>
          新しいマスター/スレーブレプリケーションセットアップで、マスター上に現在テーブルがない場合は、新しいテーブルを作成するときにエンジンタイプを指定することは避けてください。
        </p></li></ul></div><p>
      レプリケーションソリューションをすでに実行していて、既存のテーブルを別のエンジンタイプに変更する場合は、これらの手順に従ってください。
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          スレーブがレプリケーション更新を実行するのを停止します。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>STOP SLAVE;</code></strong>
</pre><p>
          これにより、中断なしにエンジンタイプを変更できるようになります。
        </p></li><li class="listitem"><p>
          変更するテーブルごとに <code class="literal">ALTER TABLE ... ENGINE='<em class="replaceable"><code>engine_type</code></em>'</code> を実行します。
        </p></li><li class="listitem"><p>
          スレーブレプリケーションプロセスを再開します。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>START SLAVE;</code></strong>
</pre></li></ol></div><p>
      <code class="literal">default_storage_engine</code> 変数は複製されませんが、エンジン指定を含む <code class="literal">CREATE TABLE</code> および <code class="literal">ALTER TABLE</code> ステートメントはスレーブに正しく複製されます。たとえば、CSV テーブルがある場合はこれを実行します。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>ALTER TABLE csvtable Engine='MyISAM';</code></strong>
</pre><p>
      上記のステートメントはスレーブに複製され、スレーブ上のエンジンタイプが <code class="literal">MyISAM</code> に変換されます (以前にスレーブ上のエンジンタイプを CSV 以外のエンジンに変更した場合でも)。マスターとスレーブでのエンジンの違いを保持する場合は、新しいテーブルを作成するときに <code class="literal">default_storage_engine</code> 変数を慎重に使用してください。たとえば、次の代わりに: 
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE tablea (columna int) Engine=MyISAM;</code></strong>
</pre><p>
      この形式を使用してください。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET default_storage_engine=MyISAM;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE TABLE tablea (columna int);</code></strong>
</pre><p>
      複製されるときに、<code class="literal">default_storage_engine</code> 変数は無視され、<code class="literal">CREATE TABLE</code> ステートメントはスレーブ上のデフォルトエンジンを使用してスレーブ上で実行されます。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-solutions-scaleout"></a>17.3.3 スケールアウトのためにレプリケーションを使用する</h3></div></div></div><p>
      レプリケーションをスケールアウトソリューションとして、つまり、いくつかの合理的な制限内でデータベースクエリーの負荷を複数のデータベースサーバーに分割するために使用できます
    </p><p>
      レプリケーションが 1 つのマスターから 1 つ以上のスレーブに分散するように機能するため、スケールアウトにレプリケーションを使用することは、読み取りが非常に多く、書き込み/更新が少ない環境で最適に機能します。ほとんどの Web サイトはこのカテゴリ (ユーザーが Web サイトをブラウズしたり、記事や投稿を読んだり、製品を見たりする) に該当します。更新は、セッション管理中、購入するとき、またはフォーラムにコメント/メッセージを追加するときにのみ発生します。
    </p><p>
      この状況でレプリケーションを使用すると、読み取りをレプリケーションスレーブに分散しながら、Web サーバーは書き込みが必要なときにレプリケーションマスターとやり取りできます。このシナリオのためのサンプルレプリケーションレイアウトは、<a class="xref" href="replication.html#figure_replication-scaleout" title="図 17.1 スケールアウト中のパフォーマンスを向上するためにレプリケーションを使用する">図17.1「スケールアウト中のパフォーマンスを向上するためにレプリケーションを使用する」</a>で見ることができます。
    </p><div class="figure"><a name="figure_replication-scaleout"></a><p class="title"><b>図 17.1 スケールアウト中のパフォーマンスを向上するためにレプリケーションを使用する</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/scaleout.png" width="687" height="341" alt="スケールアウト中のパフォーマンスを向上するためにレプリケーションを使用する"></div></div></div><br class="figure-break"><p>
      データベースにアクセスするコードの一部が適切に抽象化/モジュール化されている場合は、それを複製されたセットアップで動作するように変換することはとても効率的かつ簡単であるはずです。データベースアクセスの実装を、すべての書き込みをマスターに送信し、読み取りをマスターまたはスレーブに送信するように変更してください。コードがこのレベルの抽象を備えていない場合、複製されたシステムのセットアップは整理するための機会および動機となります。まずは、次の関数を実装するラッパーライブラリまたはモジュールを作成してください。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">safe_writer_connect()</code>
        </p></li><li class="listitem"><p>
          <code class="literal">safe_reader_connect()</code>
        </p></li><li class="listitem"><p>
          <code class="literal">safe_reader_statement()</code>
        </p></li><li class="listitem"><p>
          <code class="literal">safe_writer_statement()</code>
        </p></li></ul></div><p>
      各関数名の <code class="literal">safe_</code> は、その関数がすべてのエラー条件の処理を引き受けることを意味します。関数に別の名前を使用できます。重要なことは、読み取りのための接続、書き込みのための接続、読み取りの実行、および書き込みの実行に対して、統一されたインタフェースを持つことです。
    </p><p>
      次に、ラッパーライブラリを使用するようにクライアントコードを変換してください。これは、最初は苦しくて怖い工程かもしれませんが、長い目でみるとやるだけの価値があります。説明した方法を使用するすべてのアプリケーションは、マスター/スレーブ構成を利用できます (複数のスレーブを使用するものであっても)。こうしたコードは非常に保守しやすく、トラブルシューティングオプションを追加するのも手間がかかりません。たとえば、1 つか 2 つの関数を変更するだけで、各ステートメントにどのくらいの時間がかかったかや、発行されたステートメントの中でどのステートメントがエラーになったかのログを記録できます。
    </p><p>
      たくさんのコードを書いた経験がある場合は、MySQL 標準配布に付属の <span class="command"><strong>replace</strong></span> ユーティリティーを使用することで変換タスクを自動化したり、独自の変換スクリプトを書いたりすることをお勧めします。理想的には、コードが一貫性のあるプログラミングスタイル規則を使用するべきです。そうでない場合は、一貫性のあるスタイルを使用するために、とにかく書き換えたり、少なくとも詳しく調べて手動で整理したりすることをお勧めします。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-solutions-partitioning"></a>17.3.4 異なるデータベースを異なるスレーブに複製する</h3></div></div></div><p>
      マスターが 1 つで、異なるデータベースを異なるスレーブに複製したい場合があります。たとえば、データ分析時の負荷を分散するために、異なる売上データを異なる部門に分散したい場合です。このレイアウトの例を<a class="xref" href="replication.html#figure_replication-multi-db" title="図 17.2 データベースを別個のレプリケーションスレーブに複製するためにレプリケーションを使用する">図17.2「データベースを別個のレプリケーションスレーブに複製するためにレプリケーションを使用する」</a>に示します。
    </p><div class="figure"><a name="figure_replication-multi-db"></a><p class="title"><b>図 17.2 データベースを別個のレプリケーションスレーブに複製するためにレプリケーションを使用する</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/multi-db.png" width="424" height="178" alt="データベースを別個のレプリケーションスレーブに複製するためにレプリケーションを使用する"></div></div></div><br class="figure-break"><p>
      この分散は、マスターとスレーブを通常どおり構成してから、各スレーブ上で <code class="option">--replicate-wild-do-table</code> 構成オプションを使用して各スレーブが処理するバイナリログステートメントを制限することで、実現できます。
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        ステートメントベースレプリケーションを使用するときに、この目的のために <code class="option">--replicate-do-db</code> を使用しては<span class="emphasis"><em>いけません</em></span>。ステートメントベースレプリケーションでは、このオプションの効果が、現在選択されているデータベースによって異なるためです。このことは、混合形式のレプリケーションにも当てはまります。一部の更新をステートメントベース形式を使用して複製できるためです。
      </p><p>
        しかし、行ベースレプリケーションだけを使用している場合には、この目的のために <code class="option">--replicate-do-db</code> を使用しても安全なはずです。この場合には、現在選択されているデータベースがオプションの動作に影響しないためです。
      </p></div><p>
      たとえば、<a class="xref" href="replication.html#figure_replication-multi-db" title="図 17.2 データベースを別個のレプリケーションスレーブに複製するためにレプリケーションを使用する">図17.2「データベースを別個のレプリケーションスレーブに複製するためにレプリケーションを使用する」</a> に示すような分散をサポートするには、<code class="literal">START SLAVE</code> を実行する前に、各レプリケーションスレーブを次のように構成してください。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          レプリケーションスレーブ 1 は <code class="option">--replicate-wild-do-table=databaseA.%</code> を使用するべきです。
        </p></li><li class="listitem"><p>
          レプリケーションスレーブ 2 は <code class="option">--replicate-wild-do-table=databaseB.%</code> を使用するべきです。
        </p></li><li class="listitem"><p>
          レプリケーションスレーブ 3 は <code class="option">--replicate-wild-do-table=databaseC.%</code> を使用するべきです。
        </p></li></ul></div><p>
      この構成の各スレーブはマスターからバイナリログ全体を受け取りますが、そのバイナリログから、そのスレーブで有効な <code class="option">--replicate-wild-do-table</code> オプションによって含まれるデータベースとテーブルに適用されるイベントだけを実行します。
    </p><p>
      レプリケーションが開始する前にスレーブに同期する必要があるデータがある場合、いくつかの選択肢があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          すべてのデータを各スレーブに同期し、保持したくないデータベースまたはテーブル、あるいはその両方を削除します。
        </p></li><li class="listitem"><p>
          <span class="command"><strong>mysqldump</strong></span> を使用してデータベースごとに別々のダンプファイルを作成し、各スレーブに該当するダンプファイルをロードします。
        </p></li><li class="listitem"><p>
          ローデータファイルダンプを使用して、各スレーブに必要な固有のファイルとデータベースのみを含めます。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            これは、<code class="literal">innodb_file_per_table</code> を使用しないかぎり、<code class="literal">InnoDB</code> データベースでは機能しません。
          </p></div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-solutions-performance"></a>17.3.5 レプリケーションパフォーマンスを改善する</h3></div></div></div><p>
      マスターに接続するスレーブの数が増えるにつれ、各スレーブがマスターへのクライアント接続を使用するため、最小限ですが負荷も増えます。また、各スレーブはマスターバイナリログのフルコピーを受け取る必要があるため、マスター上のネットワーク負荷も増加し、ボトルネックになる場合があります。
    </p><p>
      1 つのマスターに接続される非常に多くのスレーブを使用していて、そのマスターも要求の処理にビジーな場合には （たとえば、スケールアウトソリューションの一部として）、レプリケーションプロセスのパフォーマンスを改善することをお勧めします。
    </p><p>
      レプリケーションプロセスのパフォーマンスを改善する方法の 1 つは、より深いレプリケーション構造を作成して、マスターは 1 つのスレーブにのみ複製し、残りのスレーブは個々のレプリケーション要件のためにこのプライマリスレーブに接続します。この構造のサンプルを<a class="xref" href="replication.html#figure_replication-performance" title="図 17.3 パフォーマンスを改善するために追加レプリケーションホストを使用する">図17.3「パフォーマンスを改善するために追加レプリケーションホストを使用する」</a>に示します。
    </p><div class="figure"><a name="figure_replication-performance"></a><p class="title"><b>図 17.3 パフォーマンスを改善するために追加レプリケーションホストを使用する</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/submaster-performance.png" width="534" height="179" alt="パフォーマンスを改善するために追加レプリケーションホストを使用"></div></div></div><br class="figure-break"><p>
      これが機能するには、MySQL インスタンスを次のように構成する必要があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          マスター 1 はプライマリマスターで、すべての変更と更新がこのデータベースに書き込まれます。バイナリロギングはこのマシンで有効にすべきです。
        </p></li><li class="listitem"><p>
          マスター 2 はマスター 1 のスレーブで、レプリケーション構造内の残りのスレーブにレプリケーション機能を提供します。マスター 2 はマスター 1 への接続を許可される唯一のマシンです。マスター 2 のバイナリロギングも有効になっていて、<code class="option">--log-slave-updates</code> オプションによってマスター 1 からのレプリケーション命令がマスター 2 のバイナリログにも書き込まれるため、それらを真のスレーブに複製できます。
        </p></li><li class="listitem"><p>
          スレーブ 1、スレーブ 2、およびスレーブ 3 はマスター 2 のスレーブとして機能し、マスター 2 からの情報 (実際にはマスター 1 でログが記録された更新で構成される) を複製します。
        </p></li></ul></div><p>
      上記のソリューションは、クライアント負荷とプライマリマスターでのネットワークインタフェース負荷を低減するため、直接のデータベースソリューションとして使用されるときにプライマリマスターの全体的なパフォーマンスを改善するはずです。
    </p><p>
      スレーブがマスター上のレプリケーションプロセスに追い付くことに問題がある場合には、利用できるオプションがいくつかあります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          可能であれば、リレーログとデータファイルを異なる物理ドライブに置きます。これを行うには、<code class="option">--relay-log</code> オプションを使用してリレーログの場所を指定します。
        </p></li><li class="listitem"><p>
          スレーブがマスターよりかなり遅い場合は、異なるデータベースを異なるスレーブに複製する責任を分割することをお勧めします。<a class="xref" href="replication.html#replication-solutions-partitioning" title="17.3.4 異なるデータベースを異なるスレーブに複製する">セクション17.3.4「異なるデータベースを異なるスレーブに複製する」</a>を参照してください。
        </p></li><li class="listitem"><p>
          マスターがトランザクションを使用するため、スレーブ上でのトランザクションサポートに関心がない場合は、スレーブ上で <code class="literal">MyISAM</code> または別の非トランザクションエンジンを使用してください。<a class="xref" href="replication.html#replication-solutions-diffengines" title="17.3.2 異なるマスターおよびスレーブストレージエンジンでレプリケーションを使用する">セクション17.3.2「異なるマスターおよびスレーブストレージエンジンでレプリケーションを使用する」</a>を参照してください。
        </p></li><li class="listitem"><p>
          スレーブがマスターとして動作せず、障害時に確実にマスターを回復できる潜在的ソリューションが実装されている場合は、<code class="option">--log-slave-updates</code> をオフに切り替えることができます。これにより、<span class="quote">「<span class="quote">ダム</span>」</span>スレーブが実行したイベントのログが自身のバイナリログに記録されなくなります。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-solutions-switch"></a>17.3.6 フェイルオーバー中にマスターを切り替える</h3></div></div></div><p>
      GTID ベースのレプリケーションを使用するときは (<a class="xref" href="replication.html#replication-gtids" title="17.1.3 グローバルトランザクション識別子を使用したレプリケーション">セクション17.1.3「グローバルトランザクション識別子を使用したレプリケーション」</a>を参照してください)、障害時に MySQL Utilities で提供される <span class="command"><strong>mysqlfailover</strong></span> を使用してマスターとスレーブ間のフェイルオーバーを提供できます。詳細については、<a class="ulink" href="http://dev.mysql.com/doc/mysql-utilities/1.5/en/mysqlfailover.html" target="_top"><span class="command"><strong>mysqlfailover</strong></span> — Automatic replication health monitoring and failover</a>を参照してください。そうでない場合は、マスターと 1 つ以上のスレーブをセットアップする必要があります。それから、起動しているかどうかを確認するためにマスターをモニターするアプリケーションまたはスクリプトを書いたり、障害時に別のマスターに変更するようにスレーブおよびアプリケーションに指示したりする必要があります。このセクションでは、この方法でフェイルオーバーをセットアップするときに遭遇するいくつかの問題について説明します。
    </p><p>
      <code class="literal">CHANGE MASTER TO</code> ステートメントを使用して、新しいマスターに切り替えるようにスレーブに指示できます。スレーブは、マスター上のデータベースがスレーブ上のものと互換性があるかどうかを確認しません。単に、新しいマスターのバイナリログ内の指定された座標からイベントを読み取って実行するだけです。フェイルオーバーの状況では、グループ内のすべてのサーバーが同じバイナリログファイルから同じイベントを実行するのが一般的であるため、イベントのソースを変更しても、変更を加えるときに注意することで、データベースの構造または完全性に影響を与えないはずです。
    </p><p>
      スレーブは、<code class="option">--log-bin</code> オプション付き、<code class="option">--log-slave-updates</code> なしで実行するべきです。この方法では、スレーブはスレーブ <span class="command"><strong>mysqld</strong></span> を再起動せずにマスターになる準備が整っています。<a class="xref" href="replication.html#figure_replication-redundancy-before" title="図 17.4 レプリケーションを使用する冗長性、初期構造">図17.4「レプリケーションを使用する冗長性、初期構造」</a>で示す構造を想定してください。
    </p><div class="figure"><a name="figure_replication-redundancy-before"></a><p class="title"><b>図 17.4 レプリケーションを使用する冗長性、初期構造</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/redundancy-before.png" width="504" height="353" alt="レプリケーションを使用する冗長性、初期構造"></div></div></div><br class="figure-break"><p>
      この図では、<code class="literal">MySQL Master</code> はマスターデータベースを保持し、<code class="literal">MySQL Slave</code> ホストはレプリケーションスレーブで、<code class="literal">Web Client</code> マシンはデータベース読み取りおよび書き込みを発行しています。読み取りだけを発行する （そして、一般的にスレーブに接続されている） Web クライアントは示されていません。障害時に新しいサーバーに切り替える必要がないためです。読み取り/書き込みスケールアウトレプリケーション構造の詳細例については、<a class="xref" href="replication.html#replication-solutions-scaleout" title="17.3.3 スケールアウトのためにレプリケーションを使用する">セクション17.3.3「スケールアウトのためにレプリケーションを使用する」</a>を参照してください。
    </p><p>
      各 MySQL Slave (<code class="literal">Slave 1</code>、<code class="literal">Slave 2</code>、<code class="literal">Slave 3</code>) は、<code class="option">--log-bin</code> 付き、<code class="option">--log-slave-updates</code> なしで動作しているスレーブです。<code class="option">--log-slave-updates</code> が指定されないかぎり、スレーブがマスターから受け取る更新のログはバイナリログに記録されないため、各スレーブ上のバイナリログは最初は空です。何らかの原因により <code class="literal">MySQL Master</code> が使用できなくなった場合、スレーブの 1 つを選んで新しいマスターにできます。たとえば、<code class="literal">Slave 1</code> を選択した場合、すべての <code class="literal">Web Clients</code> を <code class="literal">Slave 1</code> (そのバイナリログに更新を書き込む) にリダイレクトされるはずです。すると、<code class="literal">Slave 2</code> と <code class="literal">Slave 3</code> は <code class="literal">Slave 1</code> から複製されるはずです。
    </p><p>
      <code class="option">--log-slave-updates</code> なしでスレーブを実行する理由は、スレーブの 1 つを新しいマスターにしたために、スレーブが更新を 2 回受け取らないようにすることです。<code class="literal">Slave 1</code> は、その <code class="option">--log-slave-updates</code> が有効である場合は、<code class="literal">Master</code> から受け取る更新を自身のバイナリログに書き込みます。これは、<code class="literal">Slave 2</code> のマスターが <code class="literal">Master</code> から <code class="literal">Slave 1</code> に変更されると、<code class="literal">Slave 1</code> がすでに <code class="literal">Master</code> から受け取っていた更新を受け取る可能性があることを意味します。
    </p><p>
      すべてのスレーブがそれぞれのリレーログ内のステートメントを処理したことを確認してください。各スレーブで <code class="literal">STOP SLAVE IO_THREAD</code> を発行して、<code class="literal">Has read all relay log</code> を見るまで <code class="literal">SHOW PROCESSLIST</code> の出力をチェックしてください。これがすべてのスレーブで true のときは、それらを新しいセットアップに再構成できます。昇格してマスターになるスレーブ <code class="literal">Slave 1</code> では、<code class="literal">STOP SLAVE</code> と <code class="literal">RESET MASTER</code> を発行してください。
    </p><p>
      ほかのスレーブ <code class="literal">Slave 2</code> と <code class="literal">Slave 3</code> では、<code class="literal">STOP SLAVE</code> および <code class="literal">CHANGE MASTER TO MASTER_HOST='Slave1'</code> を使用します (ここで、<code class="literal">'Slave1'</code> は <code class="literal">Slave 1</code> の実際のホスト名を表します)。<code class="literal">CHANGE MASTER TO</code> を使用するには、<code class="literal">Slave 2</code> または <code class="literal">Slave 3</code> から <code class="literal">Slave 1</code> に接続する方法に関するすべての情報 (<em class="replaceable"><code>ユーザー</code></em>、<em class="replaceable"><code>パスワード</code></em>、<em class="replaceable"><code>ポート</code></em>) を追加してください。ここで <code class="literal">CHANGE MASTER TO</code> ステートメントを発行するときは、<code class="literal">Slave 1</code> バイナリログファイルの名前、または読み取るログ位置を指定する必要はありません (最初のバイナリログファイルおよび位置 4 がデフォルトです)。最後に、<code class="literal">Slave 2</code> と <code class="literal">Slave 3</code> で <code class="literal">START SLAVE</code> を実行します。
    </p><p>
      新しいレプリケーションセットアップが実行されたあと、各 <code class="literal">Web Client</code> がそれぞれのステートメントを <code class="literal">Slave 1</code> に送るように指示する必要があります。この時点から、<code class="literal">Web Client</code> から <code class="literal">Slave 1</code> に送られるすべての更新ステートメントが <code class="literal">Slave 1</code> のバイナリログに書き込まれます (<code class="literal">Master</code> の停止以降に <code class="literal">Slave 1</code> に送られるすべての更新ステートメントが含まれます)。
    </p><p>
      結果のサーバー構造を<a class="xref" href="replication.html#figure_replication-redundancy-after" title="図 17.5 レプリケーションを使用する冗長性、マスター障害後">図17.5「レプリケーションを使用する冗長性、マスター障害後」</a>に示します。
    </p><div class="figure"><a name="figure_replication-redundancy-after"></a><p class="title"><b>図 17.5 レプリケーションを使用する冗長性、マスター障害後</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/redundancy-after.png" width="538" height="432" alt="レプリケーションを使用する冗長性、マスター障害後"></div></div></div><br class="figure-break"><p>
      <code class="literal">Master</code> がふたたび利用できる状態になったら、それを <code class="literal">Slave 1</code> のスレーブにするべきです。これを実行するには、先ほど <code class="literal">Slave 2</code> と <code class="literal">Slave 3</code> で発行したものと同じ <code class="literal">CHANGE MASTER TO</code> ステートメントを <code class="literal">Master</code> で発行します。すると <code class="literal">Master</code> が <code class="literal">Slave 1</code> のスレーブになり、オフラインであったときに受け取らなかった <code class="literal">Web Client</code> 書き込みを受け取ります。
    </p><p>
      <code class="literal">Master</code> をふたたびマスターにするには (たとえば、これがもっとも強力なマシンであるため)、<code class="literal">Slave 1</code> が利用できない状態で <code class="literal">Master</code> が新しいマスターになるように先ほどの手順を使用します。この手順では、<code class="literal">Master</code> の <code class="literal">Slave 1</code>、<code class="literal">Slave 2</code>、および <code class="literal">Slave 3</code> を作成する前に、<code class="literal">Master</code> で <code class="literal">RESET MASTER</code> を実行するのを忘れないでください。これを実行しない場合は、スレーブが <code class="literal">Web Client</code> アプリケーションから、<code class="literal">Master</code> が利用できなくなった時点より前の古い書き込みを受け取る可能性があります。
    </p><p>
      スレーブ間の同期がないため (それらが同じマスターを共有していても)、一部のスレーブがほかのものよりかなり進んでしまう可能性があることを承知してください。これは場合によっては、前の例で説明した手順が期待どおりに機能しない可能性があることを意味します。ただし実際には、すべてのスレーブ上のリレーログは互いにかなり近いはずです。
    </p><p>
      アプリケーションがマスターの場所を常に知っているための 1 つの方法は、マスターの動的 DNS エントリを持つことです。<code class="literal">bind</code> で <code class="filename">nsupdate</code> を使用することで DNS を動的に更新できます。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-solutions-ssl"></a>17.3.7 SSL を使用してレプリケーションをセットアップする</h3></div></div></div><p>
      レプリケーション中に必要なバイナリログの転送を暗号化するために SSL を使用するには、マスターとスレーブの両方が SSL ネットワーク接続をサポートする必要があります。どちらかのホストが SSL 接続をサポートしない場合は (SSL 用にコンパイルまたは構成されていなかったため)、SSL 接続ベースのレプリケーションは実現できません。
    </p><p>
      SSL 接続を使用するレプリケーションをセットアップすることは、SSL を使用するサーバーとクライアントをセットアップすることに似ています。マスターで使用できる適切なセキュリティー証明書、および各スレーブで同様の証明書 （同じ認証局からの） を取得 （または作成） する必要があります。
    </p><p>
      サーバーとクライアントを SSL 接続用にセットアップする際の詳細は、<a class="xref" href="security.html#configuring-for-ssl" title="6.3.10.2 SSL を使用するための MySQL の構成">セクション6.3.10.2「SSL を使用するための MySQL の構成」</a>を参照してください。
    </p><p>
      マスター上で SSL を有効にするには、適切な証明書を作成または取得してから、マスターの <code class="filename">my.cnf</code> ファイルの <code class="literal">[mysqld]</code> セクション内でマスターの構成に次の構成オプションを追加する必要があります。
    </p><pre class="programlisting">
[mysqld]
ssl-ca=<em class="replaceable"><code>cacert.pem</code></em>
ssl-cert=<em class="replaceable"><code>server-cert.pem</code></em>
ssl-key=<em class="replaceable"><code>server-key.pem</code></em>
</pre><p>
      証明書へのパスは相対でも絶対でもかまいません。この目的のためには完全パスを常に使用することをお勧めします。
    </p><p>
      オプションは次のとおりです。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">ssl-ca</code> は認証局 （CA） 証明書を識別します。
        </p></li><li class="listitem"><p>
          <code class="literal">ssl-cert</code> はサーバー公開鍵を識別します。これをクライアントに送信し、それに含まれる CA 証明書と照合して認証できます。
        </p></li><li class="listitem"><p>
          <code class="literal">ssl-key</code> はサーバー秘密鍵を識別します。
        </p></li></ul></div><p>
      スレーブでは、SSL 情報を設定するために 2 つのオプションを利用できます。スレーブの <code class="filename">my.cnf</code> ファイルの <code class="literal">[client]</code> セクションにスレーブ証明書を追加するか、または <code class="literal">CHANGE MASTER TO</code> ステートメントを使用して SSL 情報を明示的に指定できます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          オプションファイルを使用してスレーブ証明書を追加するには、スレーブの <code class="filename">my.cnf</code> ファイルの <code class="literal">[client]</code> セクションに次の行を追加します。
        </p><pre class="programlisting">[client]
ssl-ca=<em class="replaceable"><code>cacert.pem</code></em>
ssl-cert=<em class="replaceable"><code>client-cert.pem</code></em>
ssl-key=<em class="replaceable"><code>client-key.pem</code></em></pre><p>
          スレーブがマスターに接続しないように <code class="option">--skip-slave-start</code> オプションを使用して、スレーブサーバーを再起動します。SSL 接続を有効にする <code class="literal">MASTER_SSL</code> オプションを使用して、マスター構成を指定する <code class="literal">CHANGE MASTER TO</code> を使用します。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CHANGE MASTER TO</code></strong>
    -&gt; <strong class="userinput"><code>MASTER_HOST='master_hostname',</code></strong>
    -&gt; <strong class="userinput"><code>MASTER_USER='replicate',</code></strong>
    -&gt; <strong class="userinput"><code>MASTER_PASSWORD='password',</code></strong>
    -&gt; <strong class="userinput"><code>MASTER_SSL=1;</code></strong>
</pre></li><li class="listitem"><p>
          <code class="literal">CHANGE MASTER TO</code> ステートメントを使用して SSL 証明書のオプション指定するには、SSL オプションを付加します。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CHANGE MASTER TO</code></strong>
    -&gt; <strong class="userinput"><code>MASTER_HOST='master_hostname',</code></strong>
    -&gt; <strong class="userinput"><code>MASTER_USER='replicate',</code></strong>
    -&gt; <strong class="userinput"><code>MASTER_PASSWORD='password',</code></strong>
    -&gt; <strong class="userinput"><code>MASTER_SSL=1,</code></strong>
    -&gt; <strong class="userinput"><code>MASTER_SSL_CA = 'ca_file_name',</code></strong>
    -&gt; <strong class="userinput"><code>MASTER_SSL_CAPATH = 'ca_directory_name',</code></strong>
    -&gt; <strong class="userinput"><code>MASTER_SSL_CERT = 'cert_file_name',</code></strong>
    -&gt; <strong class="userinput"><code>MASTER_SSL_KEY = 'key_file_name';</code></strong>
</pre></li></ul></div><p>
      マスター情報が更新されたあとに、スレーブレプリケーションプロセスを起動します。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>START SLAVE;</code></strong>
</pre><p>
      <code class="literal">SHOW SLAVE STATUS</code> ステートメントを使用して、SSL 接続が正常に確立されたことを確認できます。
    </p><p>
      <code class="literal">CHANGE MASTER TO</code> ステートメントの詳細については、<a class="xref" href="sql-syntax.html#change-master-to" title="13.4.2.1 CHANGE MASTER TO 構文">セクション13.4.2.1「CHANGE MASTER TO 構文」</a>を参照してください。
    </p><p>
      レプリケーション中に SSL 接続の使用を適用する場合は、<code class="literal">REPLICATION SLAVE</code> 権限のユーザーを作成して、そのユーザーに <code class="literal">REQUIRE SSL</code> オプションを使用します。例:
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE USER 'repl'@'%.mydomain.com' IDENTIFIED BY 'slavepass';</code></strong>
mysql&gt; <strong class="userinput"><code>GRANT REPLICATION SLAVE ON *.*</code></strong>
    -&gt; <strong class="userinput"><code>TO 'repl'@'%.mydomain.com' REQUIRE SSL;</code></strong>
</pre><p>
      アカウントがすでに存在する場合は、このステートメントでそれに <code class="literal">REQUIRE SSL</code> を追加できます。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>GRANT USAGE ON *.*</code></strong>
    -&gt; <strong class="userinput"><code>TO 'repl'@'%.mydomain.com' REQUIRE SSL;</code></strong>
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-semisync"></a>17.3.8 準同期レプリケーション</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-semisync-interface">17.3.8.1 準同期レプリケーション管理インタフェース</a></span></dt><dt><span class="section"><a href="replication.html#replication-semisync-installation">17.3.8.2 準同期レプリケーションのインストールと構成</a></span></dt><dt><span class="section"><a href="replication.html#replication-semisync-monitoring">17.3.8.3 準同期レプリケーションモニタリング</a></span></dt></dl></div><a class="indexterm" name="idm139979047025024"></a><a class="indexterm" name="idm139979047023552"></a><p>
      MySQL 5.6 は、非同期レプリケーションを内蔵していますが、さらにプラグインによって実装される準同期レプリケーションへのインタフェースをサポートします。このセクションでは、準同期レプリケーションの概要とその動作について説明します。後続のセクションでは、準同期レプリケーションへの管理インタフェース、およびこれをインストール、構成、およびモニターする方法について説明します。
    </p><p>
      MySQL レプリケーションはデフォルトで非同期です。マスターはイベントをそのバイナリログに書き込みますが、スレーブがそれらを取得して処理したかどうかまたはその日時を認識しません。非同期レプリケーションでは、マスターがクラッシュしても、それがコミットしたトランザクションがスレーブに転送されていない場合があります。つまり、このケースでマスターからスレーブへのフェイルオーバーが発生すると、マスターに関係するトランザクションがないサーバーにフェイルオーバーされる場合があります。
    </p><p>
      準同期レプリケーションは非同期レプリケーションの代替として使用できます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          スレーブは、マスターに接続されるときに準同期対応かどうかを伝えます。
        </p></li><li class="listitem"><p>
          準同期レプリケーションがマスター側で有効であり、準同期スレーブが少なくとも 1 つある場合、マスター上でトランザクションコミットを実行するスレッドは、コミット後にブロックされ、少なくとも 1 つの準同期スレーブがそのトランザクションのすべてのイベントを受け取ったことを通知するか、タイムアウトが発生するまで、待機します。
        </p></li><li class="listitem"><p>
          スレーブは、イベントがそのリレーログに書き込まれてディスクにフラッシュされたあとにのみ、トランザクションのイベントを受け取ったことを通知します。
        </p></li><li class="listitem"><p>
          スレーブからのトランザクション受け取り通知がない状態でタイムアウトが発生した場合、マスターは非同期レプリケーションに戻ります。少なくとも 1 つの準同期スレーブが追い付いたときに、マスターは準同期レプリケーションに戻ります。
        </p></li><li class="listitem"><p>
          準同期レプリケーションはマスターとスレーブの両方で有効になっている必要があります。準同期レプリケーションがマスターで無効になっている場合、またはマスター上で有効でもスレーブ上でそうなっていない場合は、マスターは非同期レプリケーションを使用します。
        </p></li></ul></div><p>
      マスターは、ブロック中 (コミットを実行したあとにスレーブからの通知を待機中) はトランザクションを実行したセッションに戻りません。ブロックが終了すると、マスターはそのセッションに戻り、ほかのステートメントの実行に進めます。この時点で、トランザクションはマスター側でコミット済みで、そのイベントを受け取ったことが少なくとも 1 つのスレーブから通知されています。
    </p><p>
      ブロックはバイナリログに書き込まれるロールバック後にも発生し、これは非トランザクションテーブルを変更するトランザクションがロールバックされるときに発生します。ロールバックされるトランザクションは、トランザクションテーブルに影響しない場合を含めて、ログが記録されます。非トランザクションテーブルへの変更はロールバックできず、スレーブに送信される必要があるためです。
    </p><p>
      トランザクションコンテキストで発生しないステートメントの場合 (つまり、トランザクションが <code class="literal">START TRANSACTION</code> または <code class="literal">SET autocommit = 0</code> で起動されなかったとき)、自動コミットが有効になっていて、各ステートメントは暗黙的にコミットされます。準同期レプリケーションでは、明示的なトランザクションコミットと同様に、マスターはこのような各ステートメントをコミットしたあとにブロックされます。
    </p><p>
      <span class="quote">「<span class="quote">準同期レプリケーション</span>」</span>の<span class="quote">「<span class="quote">準</span>」</span>の意味を理解するには、非同期および完全同期レプリケーションと比較してください。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          非同期レプリケーションでは、マスターはイベントをそのバイナリログに書き込み、スレーブは準備ができたときにそれらを要求します。イベントがスレーブに必ず到達することは保証されていません。
        </p></li><li class="listitem"><p>
          完全同期レプリケーションでは、マスターがトランザクションをコミットすると、マスターがトランザクションを実行したセッションに戻る前に、すべてのスレーブもトランザクションをコミットします。これの欠点は、トランザクションの完了が大きく遅れる場合があることです。
        </p></li><li class="listitem"><p>
          準同期レプリケーションは、非同期および完全同期レプリケーションの中間です。マスターはコミット後、少なくとも 1 つのスレーブがイベントを受け取ってログを記録するまで待機します。すべてのスレーブが受け取りを通知するのを待機せず、スレーブ側でイベントが完全に実行されてコミットされたことではなく、受け取りのみを要求します。
        </p></li></ul></div><p>
      準同期レプリケーションでは、非同期レプリケーションに比べて、データの完全性が向上します。コミットが成功したことが返されると、データが少なくとも 2 つの場所 （マスター上と少なくとも 1 つのスレーブ上） に存在することがわかります。マスターはコミットしたけれども、マスターがスレーブからの通知を待機中にクラッシュが発生した場合は、トランザクションがスレーブに到達できなかった可能性があります。
    </p><p>
      準同期レプリケーションは、バイナリログイベントをマスターからスレーブに送信できる速度を制限することで、ビジーセッションに速度制限を設定することもできます。あるユーザーがとてもビジーのときは、これによって速度が遅くなり、一部の配備状況で役立ちます。
    </p><p>
      準同期レプリケーションは、スレーブを待機する必要性によってコミットが遅くなるため、パフォーマンスに若干影響します。これは、データ完全性の向上とのトレードオフです。速度低下の量は、スレーブにコミットを送信して、スレーブからの受け取りの通知を待機するための、TCP/IP ラウンドトリップ時間以上です。これは、準同期レプリケーションは高速ネットワーク上で通信する近いサーバーに最適で、低速ネットワークで通信する遠いサーバーに最悪であることを意味します。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-semisync-interface"></a>17.3.8.1 準同期レプリケーション管理インタフェース</h4></div></div></div><a class="indexterm" name="idm139979046994288"></a><p>
        準同期レプリケーションへの管理インタフェースにはいくつかのコンポーネントがあります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            準同期機能を実装する 2 つのプラグイン。マスター側に 1 つのプラグイン、スレーブ側に 1 つあります。
          </p></li><li class="listitem"><p>
            プラグインの動作を制御するシステム変数。例: 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">rpl_semi_sync_master_enabled</code>
              </p><p>
                準同期レプリケーションがマスター上で有効かどうかを制御します。プラグインを有効または無効にするには、この変数をそれぞれ 1 または 0 に設定します。デフォルトは 0 （オフ） です。
              </p></li><li class="listitem"><p>
                <code class="literal">rpl_semi_sync_master_timeout</code>
              </p><p>
                タイムアウトが発生して非同期レプリケーションに戻すまでに、スレーブからの肯定応答のコミットをマスターが待機する時間を制御する、ミリ秒単位の値。デフォルト値は 10000 (10 秒) です。
              </p></li><li class="listitem"><p>
                <code class="literal">rpl_semi_sync_slave_enabled</code>
              </p><p>
                <code class="literal">rpl_semi_sync_master_enabled</code> に似ていますが、スレーブプラグインを制御します。
              </p></li></ul></div><p>
            すべての <code class="literal">rpl_semi_sync_<em class="replaceable"><code>xxx</code></em></code> システム変数は<a class="xref" href="server-administration.html#server-system-variables" title="5.1.4 サーバーシステム変数">セクション5.1.4「サーバーシステム変数」</a>で説明されています。
          </p></li><li class="listitem"><p>
            準同期レプリケーションモニタリングを有効にするステータス変数。例: 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">Rpl_semi_sync_master_clients</code>
              </p><p>
                準同期スレーブの数。
              </p></li><li class="listitem"><p>
                <code class="literal">Rpl_semi_sync_master_status</code>
              </p><p>
                準同期レプリケーションがマスター上で現在動作中であるかどうか。プラグインが有効になっていてコミット通知が発生していない場合、値は 1 です。プラグインが有効になっていないか、コミット通知タイムアウトによりマスターが非同期レプリケーションに戻った場合、これは 0 です。
              </p></li><li class="listitem"><p>
                <code class="literal">Rpl_semi_sync_master_no_tx</code>
              </p><p>
                スレーブによって正しく認証されなかったコミット数。
              </p></li><li class="listitem"><p>
                <code class="literal">Rpl_semi_sync_master_yes_tx</code>
              </p><p>
                スレーブによって正しく認証されたコミットの数。
              </p></li><li class="listitem"><p>
                <code class="literal">Rpl_semi_sync_slave_status</code>
              </p><p>
                準同期レプリケーションがスレーブ上で現在動作中かどうか。プラグインが有効になっていて、スレーブ I/O スレッドが実行中の場合は 1、それ以外の場合は 0 です。
              </p></li></ul></div><p>
            すべての <code class="literal">Rpl_semi_sync_<em class="replaceable"><code>xxx</code></em></code> ステータス変数は<a class="xref" href="server-administration.html#server-status-variables" title="5.1.6 サーバーステータス変数">セクション5.1.6「サーバーステータス変数」</a>で説明されています。
          </p></li></ul></div><p>
        システムおよびステータス変数は、該当するマスターまたはスレーブプラグインが <code class="literal">INSTALL PLUGIN</code> でインストールされた場合にのみ利用できます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-semisync-installation"></a>17.3.8.2 準同期レプリケーションのインストールと構成</h4></div></div></div><a class="indexterm" name="idm139979046958640"></a><a class="indexterm" name="idm139979046956496"></a><p>
        準同期レプリケーションはプラグインを使用して実装されるため、プラグインがサーバーにインストールされて利用できる状態である必要があります。プラグインがインストールされたあと、それに関連付けられたシステム変数によって制御します。これらのシステム変数は、関連付けられたプラグインがインストールされるまで利用できません。
      </p><p>
        準同期レプリケーションを使用するには、次の要件を満たす必要があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            MySQL 5.5 以降がインストールされている必要があります。
          </p></li><li class="listitem"><p>
            プラグインをインストールする機能には、動的ローディングをサポートする MySQL サーバーが必要です。これを検証するために、<code class="literal">have_dynamic_loading</code> システム変数の値が <code class="literal">YES</code> であることを確認してください。バイナリ配布は動的ローディングをサポートしているはずです。
          </p></li><li class="listitem"><p>
            レプリケーションがすでに機能している必要があります。マスター/スレーブ関係の作成については、<a class="xref" href="replication.html#replication-howto" title="17.1.1 レプリケーションのセットアップ方法">セクション17.1.1「レプリケーションのセットアップ方法」</a>を参照してください。
          </p></li></ul></div><p>
        準同期レプリケーションをセットアップするには、次の指示を使用してください。ここで示す <code class="literal">INSTALL PLUGIN</code>、<code class="literal">SET GLOBAL</code>、<code class="literal">STOP SLAVE</code>、および <code class="literal">START SLAVE</code> ステートメントには、<code class="literal">SUPER</code> 権限が必要です。
      </p><p>
        準同期レプリケーションプラグインは MySQL 配布に含まれています。
      </p><p>
        コンポーネント配布を解凍します (マスター側とスレーブ側のファイルが含まれます)。
      </p><p>
        コンポーネントファイルを該当するサーバーのプラグインディレクトリにインストールします。<code class="filename">semisync_master*</code> ファイルをマスターサーバーのプラグインディレクトリにインストールします。<code class="filename">semisync_slave*</code> ファイルを各スレーブサーバーのプラグインディレクトリにインストールします。プラグインディレクトリの位置は、サーバーの <code class="literal">plugin_dir</code> システム変数の値として利用できます。
      </p><p>
        プラグインをロードするには、準同期にするマスターと各スレーブで <code class="literal">INSTALL PLUGIN</code> ステートメントを使用します。
      </p><p>
        マスターで: 
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>INSTALL PLUGIN rpl_semi_sync_master SONAME 'semisync_master.so';</code></strong>
</pre><p>
        各スレーブで: 
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>INSTALL PLUGIN rpl_semi_sync_slave SONAME 'semisync_slave.so';</code></strong>
</pre><p>
        上述のコマンドは、プラグインファイル名サフィクス <code class="filename">.so</code> を使用します。システムで異なるサフィクスを適用してもかまいません。プラグインファイル名に自信がない場合は、サーバーのプラグインディレクトリでプラグインを探してください。
      </p><p>
        プラグインをインストールしようとして、Linux でここで示すようなエラーが発生する場合は、<code class="literal">libimf</code> をインストールする必要があります。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>INSTALL PLUGIN rpl_semi_sync_master SONAME 'semisync_master.so';</code></strong>
ERROR 1126 (HY000): Can't open shared library
'/usr/local/mysql/lib/plugin/semisync_master.so' (errno: 22 libimf.so: cannot open
shared object file: No such file or directory)
</pre><p>
        <code class="literal">libimf</code> は <a class="ulink" href="http://dev.mysql.com/downloads/os-linux.html" target="_top">http://dev.mysql.com/downloads/os-linux.html</a>から取得できます。
      </p><p>
        どのプラグインがインストールされているかを確認するには、<code class="literal">SHOW PLUGINS</code> ステートメントを使用するか、<code class="literal">INFORMATION_SCHEMA.PLUGINS</code> テーブルを照会してください。
      </p><p>
        準同期レプリケーションプラグインがインストールされたあとは、デフォルトで無効になっています。準同期レプリケーションを有効にするには、プラグインがマスター側とスレーブ側の両方で有効にする必要があります。一方の側だけが有効の場合には、レプリケーションは非同期になります。
      </p><p>
        インストールされたプラグインが有効かどうかを制御するには、該当するシステム変数を設定します。これらの変数は実行時に <code class="literal">SET GLOBAL</code> を使用して、またはコマンド行またはオプションファイルでサーバー起動時に設定できます。
      </p><p>
        実行時に、これらのマスター側システム変数を利用できます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET GLOBAL rpl_semi_sync_master_enabled = {0|1};</code></strong>
mysql&gt; <strong class="userinput"><code>SET GLOBAL rpl_semi_sync_master_timeout = <em class="replaceable"><code>N</code></em>;</code></strong>
</pre><p>
        スレーブ側で、このシステム変数を利用できます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET GLOBAL rpl_semi_sync_slave_enabled = {0|1};</code></strong>
</pre><p>
        <code class="literal">rpl_semi_sync_master_enabled</code> または <code class="literal">rpl_semi_sync_slave_enabled</code> の場合、準同期レプリケーションを有効にするには値を 1、無効にするには 0 にすべきです。デフォルトでは、これらの変数は 0 に設定されています。
      </p><p>
        <code class="literal">rpl_semi_sync_master_timeout</code> の場合、値 <em class="replaceable"><code>N</code></em> はミリ秒で指定されます。デフォルト値は 10000 (10 秒) です。
      </p><p>
        実行時にスレーブ上で準同期レプリケーションを有効にする場合、スレーブ I/O スレッドを起動して (すでに実行中の場合はまず停止してから)、スレーブをマスターに接続し、準同期スレーブとして登録する必要があります。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>STOP SLAVE IO_THREAD; START SLAVE IO_THREAD;</code></strong>
</pre><p>
        I/O スレッドがすでに実行中で再起動しない場合は、スレーブは非同期レプリケーションを使用し続けます。
      </p><p>
        サーバー起動時に、準同期レプリケーションを制御する変数をコマンド行オプションとしてまたはオプションファイルに設定できます。オプションファイルにリストされる設定は、サーバーが起動するたびに有効になります。たとえば、マスター側およびスレーブ側の <code class="filename">my.cnf</code> ファイルに次のように変数を設定できます。
      </p><p>
        マスターで: 
      </p><pre class="programlisting">
[mysqld]
rpl_semi_sync_master_enabled=1
rpl_semi_sync_master_timeout=1000 # 1 second
</pre><p>
        各スレーブで: 
      </p><pre class="programlisting">
[mysqld]
rpl_semi_sync_slave_enabled=1
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-semisync-monitoring"></a>17.3.8.3 準同期レプリケーションモニタリング</h4></div></div></div><a class="indexterm" name="idm139979046898688"></a><p>
        準同期レプリケーション機能用のプラグインはいくつのシステム変数とステータス変数を公開しており、その構成および運用状態を判断するためにそれらを調べることができます。
      </p><p>
        システム変数は準同期レプリケーションがどのように構成されているかを反映します。これらの値を確認するには、<code class="literal">SHOW VARIABLES</code> を使用します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'rpl_semi_sync%';</code></strong>
</pre><p>
        ステータス変数によって、準同期レプリケーションの動作をモニターできます。これらの値を確認するには、<code class="literal">SHOW STATUS</code> を使用します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW STATUS LIKE 'Rpl_semi_sync%';</code></strong>
</pre><p>
        コミット-ブロックがタイムアウトになるかスレーブが追い付いたことにより、マスターが非同期レプリケーションと準同期レプリケーションを切り替えるときは、<code class="literal">Rpl_semi_sync_master_status</code> ステータス変数を該当する値に設定します。マスター上で準同期レプリケーションから非同期レプリケーションに自動的にフォールバックすることは、<code class="literal">rpl_semi_sync_master_enabled</code> システム変数がマスター側で 1 である可能性があることを意味します (準同期レプリケーションがその時点で実際に動作していなくても)。<code class="literal">Rpl_semi_sync_master_status</code> ステータス変数をモニターすることで、マスターが現在非同期または準同期レプリケーションのどちらを使用しているかを判断できます。
      </p><p>
        多数の準同期スレーブがどのように接続されているかを確認するには、<code class="literal">Rpl_semi_sync_master_clients</code> をチェックします。
      </p><p>
        スレーブから成功または不成功と通知されたコミットの数は、<code class="literal">Rpl_semi_sync_master_yes_tx</code> および <code class="literal">Rpl_semi_sync_master_no_tx</code> 変数で示されます。
      </p><p>
        スレーブ側の <code class="literal">Rpl_semi_sync_slave_status</code> は、準同期レプリケーションが現在動作しているかどうかを示します。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-delayed"></a>17.3.9 遅延レプリケーション</h3></div></div></div><a class="indexterm" name="idm139979046877024"></a><a class="indexterm" name="idm139979046875568"></a><p>
      MySQL 5.6 は、スレーブサーバーがマスターから意図的に少なくとも指定した時間遅れる、遅延レプリケーションをサポートします。デフォルトの遅延は 0 秒です。<code class="literal">CHANGE MASTER TO</code> の <code class="literal">MASTER_DELAY</code> オプションを使用して、遅延を <em class="replaceable"><code>N</code></em> 秒に設定してください。
    </p><pre class="programlisting">
CHANGE MASTER TO MASTER_DELAY = <em class="replaceable"><code>N</code></em>;
</pre><p>
      マスターから受信するイベントは、マスター上での実行より少なくとも <em class="replaceable"><code>N</code></em> 秒後になるまで実行されません。例外は、形式記述イベントまたはログファイルローテーションイベントには遅延がなく、これらは SQL スレッドの内部状態にのみ影響します。
    </p><p>
      遅延レプリケーションはいくつかの目的に使用できます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          マスター上でのユーザーの誤りから保護するため。DBA は遅延スレーブを障害の直前までロールバックできます。
        </p></li><li class="listitem"><p>
          遅延があるときにシステムがどのように動作するかをテストするため。たとえば、アプリケーションで、スレーブでの大きな負荷が原因で遅延が発生する場合があります。しかし、この負荷レベルを生成するのが難しい場合があります。遅延レプリケーションは、負荷をシミュレートしなくても遅延をシミュレートできます。遅延をしているスレーブに関連する条件をデバッグするために使用することもできます。
        </p></li><li class="listitem"><p>
          バックアップをリロードすることなく、データベースが以前にどのようであったかを調べるため。たとえば、遅延が 1 週間で、最後の数日間の開発の前にデータベースがどのようであったかを DBA が確認する必要がある場合には、遅延スレーブを検査できます。
        </p></li></ul></div><p>
      <code class="literal">START SLAVE</code> および <code class="literal">STOP SLAVE</code> はすぐに適用され、遅延を無視します。<code class="literal">RESET SLAVE</code> は遅延を 0 にリセットします。
    </p><p>
      <code class="literal">SHOW SLAVE STATUS</code> には、遅延に関する情報を提供する次のような 3 つのフィールドがあります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">SQL_Delay</code>: スレーブがマスターより遅延する必要がある秒数を示す、負でない整数。
        </p></li><li class="listitem"><p>
          <code class="literal">SQL_Remaining_Delay</code>: <code class="literal">Slave_SQL_Running_State</code> が <code class="literal">Waiting until MASTER_DELAY seconds after master executed event</code> のときに、このフィールドには遅延の残り秒数を示す整数が含まれます。ほかのときは、このフィールドは <code class="literal">NULL</code> です。
        </p></li><li class="listitem"><p>
          <code class="literal">Slave_SQL_Running_State</code>: SQL スレッドの状態を示す文字列 (<code class="literal">Slave_IO_State</code> に似ています)。値は、<code class="literal">SHOW PROCESSLIST</code> で表示される、SQL スレッドの <code class="literal">State</code> 値と同じです。
        </p></li></ul></div><p>
      スレーブ SQL スレッドがイベント実行前に遅延が経過するのを待機しているときは、<code class="literal">SHOW PROCESSLIST</code> はその <code class="literal">State</code> 値を <code class="literal">Waiting until MASTER_DELAY seconds after master executed event</code> として表示します。
    </p><p>
      <code class="filename">relay-log.info</code> ファイルに遅延値が含まれるようになり、ファイル形式が変更されました。<a class="xref" href="replication.html#slave-logs-status" title="17.2.2.2 スレーブステータスログ">セクション17.2.2.2「スレーブステータスログ」</a>を参照してください。たとえば、ファイルの最初の行がファイル内の行数を示すようになりました。スレーブサーバーを MySQL 5.6 より前のバージョンにダウングレードすると、古いサーバーはファイルを正しく読み取りません。これに対処するには、テキストエディタでファイルを変更し、行数を含む最初の行を削除します。
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="replication-notes"></a>17.4 レプリケーションの注釈とヒント</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-features">17.4.1 レプリケーションの機能と問題</a></span></dt><dt><span class="section"><a href="replication.html#replication-compatibility">17.4.2 MySQL バージョン間のレプリケーション互換性</a></span></dt><dt><span class="section"><a href="replication.html#replication-upgrade">17.4.3 レプリケーションセットアップをアップグレードする</a></span></dt><dt><span class="section"><a href="replication.html#replication-problems">17.4.4 レプリケーションのトラブルシューティング</a></span></dt><dt><span class="section"><a href="replication.html#replication-bugs">17.4.5 レプリケーションバグまたは問題を報告する方法</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-features"></a>17.4.1 レプリケーションの機能と問題</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-features-auto-increment">17.4.1.1 レプリケーションと AUTO_INCREMENT</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-blackhole">17.4.1.2 レプリケーションと BLACKHOLE テーブル</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-charset">17.4.1.3 レプリケーションと文字セット</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-create-if-not-exists">17.4.1.4 CREATE ... IF NOT EXISTS ステートメントのレプリケーション</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-create-select">17.4.1.5 CREATE TABLE ... SELECT ステートメントのレプリケーション</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-create-alter-drop-server">17.4.1.6 CREATE SERVER、ALTER SERVER、および DROP SERVER のレプリケーション</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-current-user">17.4.1.7 CURRENT_USER() のレプリケーション</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-drop-if-exists">17.4.1.8 DROP ... IF EXISTS ステートメントのレプリケーション</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-differing-tables">17.4.1.9 テーブル定義が異なるマスターとスレーブでのレプリケーション</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-directory">17.4.1.10 レプリケーションと DIRECTORY テーブルオプション</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-invoked">17.4.1.11 呼び出される機能のレプリケーション</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-floatvalues">17.4.1.12 レプリケーションと浮動小数点値</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-fractional-seconds">17.4.1.13 レプリケーションと小数秒サポート</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-flush">17.4.1.14 レプリケーションと FLUSH</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-functions">17.4.1.15 レプリケーションとシステム関数</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-limit">17.4.1.16 レプリケーションと LIMIT</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-load-data">17.4.1.17 レプリケーションと LOAD DATA INFILE</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-repair-table">17.4.1.18 レプリケーションと REPAIR TABLE</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-shutdowns">17.4.1.19 レプリケーションとマスターまたはスレーブシャットダウン</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-max-allowed-packet">17.4.1.20 レプリケーションと max_allowed_packet</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-memory">17.4.1.21 レプリケーションと MEMORY テーブル</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-temptables">17.4.1.22 レプリケーションと一時テーブル</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-mysqldb">17.4.1.23 mysql システムデータベースのレプリケーション</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-optimizer">17.4.1.24 レプリケーションとクエリーオプティマイザ</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-reserved-words">17.4.1.25 レプリケーションと予約語</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-slaveerrors">17.4.1.26 レプリケーション中のスレーブエラー</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-server-side-help">17.4.1.27 サーバー側ヘルプテーブルのレプリケーション</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-sql-mode">17.4.1.28 レプリケーションとサーバー SQL モード</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-timeout">17.4.1.29 レプリケーション再試行とタイムアウト</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-timezone">17.4.1.30 レプリケーションとタイムゾーン</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-transactions">17.4.1.31 レプリケーションとトランザクション</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-triggers">17.4.1.32 レプリケーションとトリガー</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-truncate">17.4.1.33 レプリケーションと TRUNCATE TABLE</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-variables">17.4.1.34 レプリケーションと変数</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-views">17.4.1.35 レプリケーションとビュー</a></span></dt></dl></div><a class="indexterm" name="idm139979046839216"></a><a class="indexterm" name="idm139979046837072"></a><a class="indexterm" name="idm139979046835696"></a><a class="indexterm" name="idm139979046833632"></a><a class="indexterm" name="idm139979046832256"></a><a class="indexterm" name="idm139979046830896"></a><p>
      以降のセクションでは、MySQL レプリケーションでサポートされていることとされていないことに関する情報、および特定のステートメントの複製時に発生する可能性がある固有の問題と状況に関する情報を提供します。
    </p><p>
      ステートメントベースレプリケーションは、SQL レベルでのマスターとスレーブ間の互換性に依存します。つまり、SBR が成功するには、使用する SQL 機能がマスターおよびスレーブサーバーの両方でサポートされる必要があります。たとえば、マスターサーバーで MySQL 5.6 (以降) でのみ利用できる機能を使用する場合、MySQL 5.5 (以前) を使用するスレーブに複製できません。
    </p><p>
      このような非互換性は、本番前リリースの MySQL を使用するときのリリースシリーズ内で発生することもあります。たとえば、<code class="literal">SLEEP()</code> 関数は MySQL 5.0.12 以降で使用できます。この関数をマスターで使用する場合、MySQL 5.0.11 以前を使用するスレーブに複製できません。
    </p><p>
      このため、本番設定のステートメントベースレプリケーションには、GA (Generally Available) リリースの SQL を使用してください。あるリリースシリーズが GA リリースステータスに到達すると、オラクルはそのシリーズ内で新しい SQL ステートメントを導入したりそれらの機能を変更したりしないためです。
    </p><p>
      MySQL 5.6 と 1 つ前の MySQL リリースシリーズとの間でステートメントベースレプリケーションを使用することを計画している場合は、そのシリーズのレプリケーション特性に関する情報について、以前のリリースシリーズに対応するエディションの <em class="citetitle">MySQL リファレンスマニュアル</em>を参照することもお勧めします。
    </p><p>
      MySQL のステートメントベースレプリケーションでは、ストアドルーチンまたはトリガーの複製で問題が発生する場合があります。これらの問題は、代わりに MySQL の行ベースのレプリケーションを使用することで回避できます。問題の詳細な一覧は、<a class="xref" href="stored-programs-views.html#stored-programs-logging" title="20.7 ストアドプログラムのバイナリロギング">セクション20.7「ストアドプログラムのバイナリロギング」</a>を参照してください。行ベースロギングおよび行ベースレプリケーションに関する詳細は、<a class="xref" href="server-administration.html#binary-log-formats" title="5.2.4.1 バイナリロギング形式">セクション5.2.4.1「バイナリロギング形式」</a>および<a class="xref" href="replication.html#replication-formats" title="17.1.2 レプリケーション形式">セクション17.1.2「レプリケーション形式」</a>を参照してください。
    </p><p>
      レプリケーションおよび <code class="literal">InnoDB</code> に固有の追加情報については、<a class="xref" href="innodb-storage-engine.html#innodb-and-mysql-replication" title="14.17 InnoDB と MySQL レプリケーション">セクション14.17「InnoDB と MySQL レプリケーション」</a>を参照してください。MySQL Cluster でのレプリケーションに関連する情報は、<a class="xref" href="mysql-cluster.html#mysql-cluster-replication" title="18.6 MySQL Cluster レプリケーション">セクション18.6「MySQL Cluster レプリケーション」</a>を参照してください。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-auto-increment"></a>17.4.1.1 レプリケーションと AUTO_INCREMENT</h4></div></div></div><a class="indexterm" name="idm139979046814960"></a><a class="indexterm" name="idm139979046812800"></a><a class="indexterm" name="idm139979046810736"></a><a class="indexterm" name="idm139979046808640"></a><a class="indexterm" name="idm139979046806576"></a><a class="indexterm" name="idm139979046804512"></a><p>
        <code class="literal">AUTO_INCREMENT</code>、<code class="literal">LAST_INSERT_ID()</code>、および <code class="literal">TIMESTAMP</code> 値のステートメントレベルレプリケーションは正しく行われますが、次の例外があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            MySQL 5.6.10 より前のステートメントベースレプリケーションを使用するときは、スレーブ上のテーブル内の <code class="literal">AUTO_INCREMENT</code> カラムは、マスター上の同じカラムに一致する必要があります。つまり、<code class="literal">AUTO_INCREMENT</code> カラムは <code class="literal">AUTO_INCREMENT</code> カラムに複製される必要があります。(Bug #12669186)
          </p></li><li class="listitem"><p>
            <code class="literal">AUTO_INCREMENT</code> カラムを更新するトリガーまたは関数を呼び出すステートメントは、ステートメントベースレプリケーションでは正しく複製されません。MySQL 5.6 では、このようなステートメントは安全でないとマークされます。(Bug #45677)
          </p></li><li class="listitem"><p>
            複合主キーを持ち、この複合キーの先頭カラムでない <code class="literal">AUTO_INCREMENT</code> カラムを含むテーブルに <code class="literal">INSERT</code> を実行することは、ステートメントベースロギングまたはレプリケーションにとって安全ではありません。MySQL 5.6.6 以降では、このようなステートメントは安全でないとマークされます。(Bug #11754117、Bug #45670)
          </p><p>
            この問題は <code class="literal">InnoDB</code> ストレージエンジンを使用するテーブルに影響しません。<a class="link" href="glossary.html#glos_auto_increment" title="自動インクリメント">AUTO_INCREMENT</a> カラムを持つ <code class="literal">InnoDB</code> テーブルには、自動インクリメントカラムが唯一または左端のカラムであるキーが少なくとも 1 つ必要であるためです。
          </p></li><li class="listitem"><p>
            <code class="literal">ALTER TABLE</code> でテーブルに <code class="literal">AUTO_INCREMENT</code> カラムを追加した場合、行の順序がスレーブとマスターで同じにならない場合があります。これが発生するのは、行が番号付けされる順序が、テーブルに使用される固有のストレージエンジンおよび行が挿入された順序に依存するためです。マスターとスレーブで同じ順序を持つことが重要である場合は、行を並べ替えてから <code class="literal">AUTO_INCREMENT</code> 番号を割り当てる必要があります。カラム <code class="literal">col1</code> と <code class="literal">col2</code> を持つテーブル <code class="literal">t1</code> に <code class="literal">AUTO_INCREMENT</code> カラムを追加するものと仮定すると、次のステートメントは <code class="literal">t1</code> と同じであるけれども <code class="literal">AUTO_INCREMENT</code> カラムを持つ新しいテーブル <code class="literal">t2</code> を生成します。
          </p><pre class="programlisting">
CREATE TABLE t2 LIKE t1;
ALTER TABLE t2 ADD id INT AUTO_INCREMENT PRIMARY KEY;
INSERT INTO t2 SELECT * FROM t1 ORDER BY col1, col2;
</pre><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
              マスターとスレーブの両方で同じ順序を保証するには、<code class="literal">ORDER BY</code> 句で <code class="literal">t1</code> の<span class="emphasis"><em>すべての</em></span>カラムの名前を指定する必要があります。
            </p></div><p>
            上記の指示には <code class="literal">CREATE TABLE ... LIKE</code> の制限が適用されます。外部キー定義は <code class="literal">DATA DIRECTORY</code> および <code class="literal">INDEX DIRECTORY</code> テーブルオプションと同様に無視されます。テーブル定義がこれらの特性を含む場合、<code class="literal">t1</code> の作成に使用したものと同じであるけれども <code class="literal">AUTO_INCREMENT</code> カラムを追加した <code class="literal">CREATE TABLE</code> ステートメントを使用して、<code class="literal">t2</code> を作成してください。
          </p><p>
            <code class="literal">AUTO_INCREMENT</code> カラムを持つコピーを作成および移入するために使用する方法にかかわらず、最終手順は元のテーブルを削除してコピーの名前を変更することです。
          </p><pre class="programlisting">
DROP t1;
ALTER TABLE t2 RENAME t1;
</pre><p>
            <a class="xref" href="error-handling.html#alter-table-problems" title="B.5.7.1 ALTER TABLE での問題">セクションB.5.7.1「ALTER TABLE での問題」</a>も参照してください。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-blackhole"></a>17.4.1.2 レプリケーションと BLACKHOLE テーブル</h4></div></div></div><a class="indexterm" name="idm139979046762464"></a><a class="indexterm" name="idm139979046760480"></a><a class="indexterm" name="idm139979046758304"></a><a class="indexterm" name="idm139979046756384"></a><p>
        <code class="literal">BLACKHOLE</code> ストレージエンジンはデータを受け入れますが、それを破棄し、格納しません。バイナリロギングを実行するときは、使用しているロギング形式にかかわらず、このようなテーブルへのすべての挿入は常にログが記録されます。更新と削除は、ステートメントベースまたは行ベースのどちらのロギングが使用されているかによって扱いが異なります。ステートメントベースロギング形式では、<code class="literal">BLACKHOLE</code> テーブルに影響するすべてのステートメントのログが記録されますが、それらの影響は無視されます。行ベースロギングを使用するときは、このようなテーブルへの更新と削除は単にスキップされ、バイナリログに書き込まれません。MySQL 5.6.12 以降では、これが発生するたびに警告ログが記録されます (Bug #13004581)
      </p><p>
        このため、<code class="literal">BLACKHOLE</code> ストレージエンジンを使用してテーブルに複製するときは、<code class="literal">binlog_format</code> サーバー変数を <code class="literal">ROW</code> または <code class="literal">MIXED</code> ではなく <code class="literal">STATEMENT</code> に設定することをお勧めします。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-charset"></a>17.4.1.3 レプリケーションと文字セット</h4></div></div></div><a class="indexterm" name="idm139979046744896"></a><a class="indexterm" name="idm139979046742736"></a><p>
        次のことは、異なる文字セットを使用する MySQL サーバー間でのレプリケーションに適用されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            マスターが MySQL 4.1 を使用する場合、スレーブ MySQL バージョンに関係なく、マスターとスレーブで<span class="emphasis"><em>常に</em></span>同じ<span class="emphasis"><em>グローバル</em></span>文字セットおよび照合順序を使用する必要があります。(これらは、<code class="option">--character-set-server</code> および <code class="option">--collation-server</code> オプションで制御されます。)そうでない場合、スレーブで重複キーエラーが発生する可能性があります。マスター文字セットで一意のキーがスレーブ文字セットで一意でない場合があるためです。マスターとスレーブが両方とも MySQL 5.0 以降であるときは、これは心配の種にはなりません。
          </p></li><li class="listitem"><p>
            マスターが MySQL 4.1.3 より古い場合、クライアントの文字セットをそのグローバル値と異なるものにしてはいけません。この文字セットの変更はスレーブに認識されないためです。つまり、クライアントは <code class="literal">SET NAMES</code>、<code class="literal">SET CHARACTER SET</code> などを使用しないでください。マスターとスレーブの両方が 4.1.3 以降である場合、クライアントは文字セット変数のセッション値を自由に設定できます。これらの設定がバイナリログに書き込まれるため、スレーブに認識されるためです。つまり、クライアントは <code class="literal">SET NAMES</code> または <code class="literal">SET CHARACTER SET</code> を使用したり、<code class="literal">collation_client</code> や <code class="literal">collation_server</code> などの変数を設定したりできます。ただし、クライアントはこれらの変数の<span class="emphasis"><em>グローバル</em></span>値を変更することはできません。前述のように、マスターとスレーブは常に同一グローバル文字セット値を使用する必要があります。これは、ステートメントベースのレプリケーションと行ベースのレプリケーションのどちらを使用している場合にも当てはまります。
          </p></li><li class="listitem"><p>
            マスターのデータベースの文字セットがグローバル <code class="literal">character_set_server</code> 値と異なる場合、データベースのデフォルト文字セットを暗黙的に信頼しないように <code class="literal">CREATE TABLE</code> ステートメントを設計してください。推奨される回避策は、<code class="literal">CREATE TABLE</code> ステートメントに明示的に文字セットと照合順序を指定することです。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-create-if-not-exists"></a>17.4.1.4 CREATE ... IF NOT EXISTS ステートメントのレプリケーション</h4></div></div></div><a class="indexterm" name="idm139979046721648"></a><a class="indexterm" name="idm139979046719440"></a><p>
        MySQL は、さまざまな <code class="literal">CREATE ... IF NOT EXISTS</code> ステートメントが複製されるときにこれらの値を適用します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            各 <code class="literal">CREATE DATABASE IF NOT EXISTS</code> ステートメントは、データベースがマスター上にすでに存在しているかどうかにかかわらず、複製されます。
          </p></li><li class="listitem"><p>
            同様に、<code class="literal">SELECT</code> のない各 <code class="literal">CREATE TABLE IF NOT EXISTS</code> ステートメントは、テーブルがマスター上にすでに存在しているかどうかにかかわらず、複製されます。これは <code class="literal">CREATE TABLE IF NOT EXISTS ... LIKE</code> を含みます。<code class="literal">CREATE TABLE IF NOT EXISTS ... SELECT</code> のレプリケーションは、多少異なるルールに従います。詳細については、<a class="xref" href="replication.html#replication-features-create-select" title="17.4.1.5 CREATE TABLE ... SELECT ステートメントのレプリケーション">セクション17.4.1.5「CREATE TABLE ... SELECT ステートメントのレプリケーション」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">CREATE EVENT IF NOT EXISTS</code> は、ステートメントに指定されたイベントがすでにマスター上に存在しているかどうかにかかわらず、MySQL 5.6 で常に複製されます。
          </p></li></ul></div><p>
        Bug #45574 も参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-create-select"></a>17.4.1.5 CREATE TABLE ... SELECT ステートメントのレプリケーション</h4></div></div></div><a class="indexterm" name="idm139979046702128"></a><a class="indexterm" name="idm139979046699968"></a><p>
        このセクションでは、MySQL が <code class="literal">CREATE TABLE ... SELECT</code> ステートメントを複製する方法について説明します。
      </p><p>
        MySQL 5.6 は、<code class="literal">CREATE TABLE ... SELECT</code> ステートメントが、このステートメントで作成されたテーブル以外のテーブルで変更を行うことを許可しません。これは、以前のバージョンの MySQL (これらのステートメントがそうすることを許可していました) からの動作の変更です。これは、MySQL 5.6 以降のスレーブと前のバージョンの MySQL を実行しているマスターとの間でステートメントベースレプリケーションを使用するときに、マスター上のほかのテーブルで変更を行う <code class="literal">CREATE TABLE ... SELECT</code> ステートメントがスレーブ上で失敗し、レプリケーションが停止することを意味します。これが発生しないようにするには、行ベースレプリケーションを使用するか、問題のステートメントをマスター上で実行する前に書き直すか、マスターを MySQL 5.6 (以降) にアップグレードしてください。(マスターをアップグレードすることを選択する場合、このような <code class="literal">CREATE TABLE ... SELECT</code> ステートメントは、ほかのテーブルでの副作用をなくすように書き直さないかぎり、アップグレード後に失敗することに留意してください。)これは、行ベースのプリケーションを使用するときは問題になりません。このステートメントのログが、<code class="literal">CREATE TABLE ... SELECT</code> 全体としてではなく、<code class="literal">CREATE TABLE</code> ステートメントとして記録される (テーブルデータへの変更のログが行挿入イベントとして記録される) ためです。
      </p><p>
        これらの動作は MySQL バージョンに依存しません。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CREATE TABLE ... SELECT</code> は常に暗黙的コミットを実行します (<a class="xref" href="sql-syntax.html#implicit-commit" title="13.3.3 暗黙的なコミットを発生させるステートメント">セクション13.3.3「暗黙的なコミットを発生させるステートメント」</a>)。
          </p></li><li class="listitem"><p>
            目的のテーブルが存在しない場合、ロギングは次のように発生します。<code class="literal">IF NOT EXISTS</code> が存在するかどうかは重要ではありません。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">STATEMENT</code> または <code class="literal">MIXED</code> 形式: ステートメントは、書き込まれたものとしてログに記録されます。
              </p></li><li class="listitem"><p>
                <code class="literal">ROW</code> 形式: ステートメントは、<code class="literal">CREATE TABLE</code> ステートメントおよび一連の行挿入イベントとしてログに記録されます。
              </p></li></ul></div></li><li class="listitem"><p>
            ステートメントが失敗した場合、ログは記録されません。これには、宛先テーブルが存在し、<code class="literal">IF NOT EXISTS</code> が指定されていないケースが含まれます。
          </p></li></ul></div><p>
        宛先テーブルが存在し、<code class="literal">IF NOT EXISTS</code> が指定されているときは、MySQL はバージョンに依存する方法でステートメントを処理します。
      </p><p>
        5.1.51 より前の MySQL 5.1 および 5.5.6 より前の MySQL 5.5 で (これがオリジナルの動作です):
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">STATEMENT</code> または <code class="literal">MIXED</code> 形式: ステートメントは、書き込まれたものとしてログに記録されます。
          </p></li><li class="listitem"><p>
            <code class="literal">ROW</code> 形式: ステートメントは、<code class="literal">CREATE TABLE</code> ステートメントおよび一連の行挿入イベントとしてログに記録されます。
          </p></li></ul></div><p>
        5.1.51 以降の MySQL 5.1 で:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">STATEMENT</code> または <code class="literal">MIXED</code> 形式: ステートメントは、<code class="literal">CREATE TABLE</code> および <code class="literal">INSERT INTO ... SELECT</code> ステートメントの同等ペアとしてログに記録されます。
          </p></li><li class="listitem"><p>
            <code class="literal">ROW</code> 形式: ステートメントは、<code class="literal">CREATE TABLE</code> ステートメントおよび一連の行挿入イベントとしてログに記録されます。
          </p></li></ul></div><p>
        5.5.6 以降の MySQL 5.5 で:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            何も挿入されず、ログが記録されません。
          </p></li></ul></div><p>
        これらのバージョン依存が発生するのは、MySQL 5.5.6 で、目的のテーブルがすでに存在する場合に行を挿入しないように <code class="literal">CREATE TABLE ... SELECT</code> の処理が変更されたことと、MySQL 5.1.51 で、このようなステートメントを 5.1 マスターから 5.5 スレーブに複製する際の上位互換性を保持するように変更されたことによります。詳細については、<a class="xref" href="sql-syntax.html#create-table-select" title="13.1.17.1 CREATE TABLE ... SELECT 構文">セクション13.1.17.1「CREATE TABLE ... SELECT 構文」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-create-alter-drop-server"></a>17.4.1.6 CREATE SERVER、ALTER SERVER、および DROP SERVER のレプリケーション</h4></div></div></div><p>
        MySQL 5.6 では、ステートメント <code class="literal">CREATE SERVER</code>、<code class="literal">ALTER SERVER</code>、および <code class="literal">DROP SERVER</code> は、使用中のバイナリロギング形式にかかわらず、バイナリログに書き込まれません。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-current-user"></a>17.4.1.7 CURRENT_USER() のレプリケーション</h4></div></div></div><p>
        次のステートメントでは、<code class="literal">CURRENT_USER()</code> 関数を使用して、該当するユーザーまたは定義者の名前 (あるいはそれらのホスト) を置き換えることがサポートされます。そのような場合、<code class="literal">CURRENT_USER()</code> は必要に応じて展開されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">DROP USER</code>
          </p></li><li class="listitem"><p>
            <code class="literal">RENAME USER</code>
          </p></li><li class="listitem"><p>
            <code class="literal">GRANT</code>
          </p></li><li class="listitem"><p>
            <code class="literal">REVOKE</code>
          </p></li><li class="listitem"><p>
            <code class="literal">CREATE FUNCTION</code>
          </p></li><li class="listitem"><p>
            <code class="literal">CREATE PROCEDURE</code>
          </p></li><li class="listitem"><p>
            <code class="literal">CREATE TRIGGER</code>
          </p></li><li class="listitem"><p>
            <code class="literal">CREATE EVENT</code>
          </p></li><li class="listitem"><p>
            <code class="literal">CREATE VIEW</code>
          </p></li><li class="listitem"><p>
            <code class="literal">ALTER EVENT</code>
          </p></li><li class="listitem"><p>
            <code class="literal">ALTER VIEW</code>
          </p></li><li class="listitem"><p>
            <code class="literal">SET PASSWORD</code>
          </p></li></ul></div><p>
        バイナリロギングが有効のときに <code class="literal">CURRENT_USER()</code> または <code class="literal">CURRENT_USER</code> がステートメント <code class="literal">CREATE FUNCTION</code>、<code class="literal">CREATE PROCEDURE</code>、<code class="literal">CREATE TRIGGER</code>、<code class="literal">CREATE EVENT</code>、<code class="literal">CREATE VIEW</code>、または <code class="literal">ALTER VIEW</code> のいずれかで定義者として使用されるときは、関数参照はバイナリログに書き込まれる前に展開されるため、これらのステートメントが複製されるときはステートメントはマスターとスレーブの両方で同じユーザーを参照します。<code class="literal">CURRENT_USER()</code> または <code class="literal">CURRENT_USER</code> は、<code class="literal">DROP USER</code>、<code class="literal">RENAME USER</code>、<code class="literal">GRANT</code>、<code class="literal">REVOKE</code>、または <code class="literal">ALTER EVENT</code> で使用されるときも、バイナリログに書き込まれる前に展開されます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-drop-if-exists"></a>17.4.1.8 DROP ... IF EXISTS ステートメントのレプリケーション</h4></div></div></div><a class="indexterm" name="idm139979046605264"></a><a class="indexterm" name="idm139979046603104"></a><p>
        <code class="literal">DROP DATABASE IF EXISTS</code>、<code class="literal">DROP TABLE IF EXISTS</code>、および <code class="literal">DROP VIEW IF EXISTS</code> ステートメントは常に複製されます (削除するデータベース、テーブル、またはビューがマスター上に存在しない場合でも)。これは、スレーブがマスターに追い付いたあと、削除するオブジェクトがマスターとスレーブのどちらにも確実に存在しないようにするためです。
      </p><p>
        ストアドプログラム (ストアドプロシージャーと関数、トリガー、およびイベント) 用の <code class="literal">DROP ... IF EXISTS</code> ステートメントも複製されます (削除するストアドプログラムがマスターに存在しない場合でも)。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-differing-tables"></a>17.4.1.9 テーブル定義が異なるマスターとスレーブでのレプリケーション</h4></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="replication.html#replication-features-more-columns">17.4.1.9.1 マスターまたはスレーブでカラムが多い場合のレプリケーション</a></span></dt><dt><span class="section"><a href="replication.html#replication-features-different-data-types">17.4.1.9.2 データ型が異なるカラムのレプリケーション</a></span></dt></dl></div><a class="indexterm" name="idm139979046593360"></a><p>
        レプリケーションのソースおよびターゲットテーブルは同じである必要はありません。マスター上のテーブルのカラム数が、テーブルのスレーブコピーのものより多くても少なくてもかまいません。また、マスターおよびスレーブ上の対応するテーブルカラムが、一定の条件が適用されますが、異なるデータ型を使用していてもかまいません。
      </p><p>
        ソースおよびターゲットテーブルの定義が同じでない場合でも、データベースおよびテーブルの名前はマスターとスレーブの両方で同じである必要があります。次の 2 つのセクションで、追加条件について例を示して説明します。
      </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="replication-features-more-columns"></a>17.4.1.9.1 マスターまたはスレーブでカラムが多い場合のレプリケーション</h5></div></div></div><p>
          マスターとスレーブコピーでテーブルのカラム数が異なる場合でも、次の条件に従って、テーブルをマスターからスレーブに複製できます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              両方のバージョンのテーブルに共通するカラムは、マスターとスレーブで同じ順番に定義する必要があります。
            </p><p>
              (これは、両方のテーブルのカラム数が同じ場合でも当てはまります。)
            </p></li><li class="listitem"><p>
              両方のバージョンのテーブルに共通するカラムは、追加カラムの前に定義する必要があります。
            </p><p>
              これは、スレーブで <code class="literal">ALTER TABLE</code> ステートメントを実行して、新しいカラムが両方のテーブルに共通するカラムの範囲内にテーブルに挿入される場合は、次の例で示すように、レプリケーションが失敗することを意味します。
            </p><p>
              テーブル <code class="literal">t</code> がマスターおよびスレーブ上に存在し、次の <code class="literal">CREATE TABLE</code> ステートメントで定義されているとします。
            </p><pre class="programlisting">
CREATE TABLE t (
    c1 INT,
    c2 INT,
    c3 INT
); 
</pre><p>
              ここで示す <code class="literal">ALTER TABLE</code> ステートメントがスレーブで実行されるとします。
            </p><pre class="programlisting">
ALTER TABLE t ADD COLUMN cnew1 INT AFTER c3;
</pre><p>
              上記の <code class="literal">ALTER TABLE</code> はスレーブ上で許可されます。テーブル <code class="literal">t</code> の両方のバージョンに共通するカラム <code class="literal">c1</code>、<code class="literal">c2</code>、および <code class="literal">c3</code> が両方のバージョンのテーブルでまとまったままであり、共通しないカラムはそのあとに来るためです。
            </p><p>
              しかし、次の <code class="literal">ALTER TABLE</code> ステートメントをスレーブ上で実行すると、レプリケーションは必ず失敗します。
            </p><pre class="programlisting">
ALTER TABLE t ADD COLUMN cnew2 INT AFTER c2;
</pre><p>
              ここで示す <code class="literal">ALTER TABLE</code> ステートメントをスレーブ上で実行すると、新しいカラム <code class="literal">cnew2</code> が両方のバージョンの <code class="literal">t</code> に共通するカラムの間に来るため、レプリケーションは失敗します。
            </p></li><li class="listitem"><p>
              カラム数の多いバージョンのテーブルの<span class="quote">「<span class="quote">追加</span>」</span>カラムごとに、デフォルト値が必要です。
            </p><p>
              カラムのデフォルト値は、その型、<code class="literal">DEFAULT</code> オプションで定義されているかどうか、<code class="literal">NULL</code> として宣言されているかどうか、作成時に有効であったサーバー SQL モードなど、いくつかの要因で決まります。詳細については、<a class="xref" href="data-types.html#data-type-defaults" title="11.6 データ型デフォルト値">セクション11.6「データ型デフォルト値」</a>を参照してください)。
            </p></li></ul></div><p>
          また、テーブルのスレーブコピーがマスターのコピーよりカラム数が多いときは、テーブルに共通する各カラムは両方のテーブルで同じデータ型を使用する必要があります。
        </p><p><b>例 </b>
            次の例は、有効および無効なテーブル定義をいくつか示します。
          </p><p><b>マスターのカラム数が多い </b>
            次のテーブル定義は有効で、正しく複製されます。
          </p><pre class="programlisting">
master&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT, c2 INT, c3 INT);</code></strong>
slave&gt;  <strong class="userinput"><code>CREATE TABLE t1 (c1 INT, c2 INT);</code></strong>
</pre><p>
          次のテーブル定義は、両方のバージョンのテーブルに共通するカラムの定義がスレーブ上とマスター上とで順番が異なるため、エラー 1532 (<code class="literal">ER_BINLOG_ROW_RBR_TO_SBR</code>) が発生します。
        </p><pre class="programlisting">
master&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT, c2 INT, c3 INT);</code></strong>
slave&gt;  <strong class="userinput"><code>CREATE TABLE t1 (c2 INT, c1 INT);</code></strong>
</pre><p>
          次のテーブル定義でも、両方のバージョンのテーブルに共通するカラムの定義の前に、マスター上の追加カラムの定義があるため、エラー 1532 が発生します。
        </p><pre class="programlisting">
master&gt; <strong class="userinput"><code>CREATE TABLE t1 (c3 INT, c1 INT, c2 INT);</code></strong>
slave&gt;  <strong class="userinput"><code>CREATE TABLE t1 (c1 INT, c2 INT);</code></strong>
</pre><p><b>スレーブのカラム数が多い </b>
            次のテーブル定義は有効で、正しく複製されます。
          </p><pre class="programlisting">
master&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT, c2 INT);</code></strong>
slave&gt;  <strong class="userinput"><code>CREATE TABLE t1 (c1 INT, c2 INT, c3 INT);</code></strong>
                  </pre><p>
          次の定義では、両方のバージョンのテーブルに共通するカラムが、マスターとスレーブの両方で同じ順序で定義されていないため、エラー 1532 が発生します。
        </p><pre class="programlisting">
master&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT, c2 INT);</code></strong>
slave&gt;  <strong class="userinput"><code>CREATE TABLE t1 (c2 INT, c1 INT, c3 INT);</code></strong>
</pre><p>
          次のテーブル定義でも、両方のバージョンのテーブルに共通のするカラムの定義の前に、スレーブバージョンのテーブルの追加カラムの定義があるため、エラー 1532 が発生します。
        </p><pre class="programlisting">
master&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT, c2 INT);</code></strong>
slave&gt;  <strong class="userinput"><code>CREATE TABLE t1 (c3 INT, c1 INT, c2 INT);</code></strong>
</pre><p>
          次のテーブル定義は、スレーブバージョンのテーブルはマスターバージョンに比べてカラム数が多く、2 つのバージョンのテーブルに共通するカラム <code class="literal">c2</code> が使用するデータ型が異なっているため、失敗します。
        </p><pre class="programlisting">
master&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT, c2 BIGINT);</code></strong>
slave&gt;  <strong class="userinput"><code>CREATE TABLE t1 (c1 INT, c2 INT, c3 INT);</code></strong>
</pre></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="replication-features-different-data-types"></a>17.4.1.9.2 データ型が異なるカラムのレプリケーション</h5></div></div></div><a class="indexterm" name="idm139979046533840"></a><a class="indexterm" name="idm139979046531648"></a><a class="indexterm" name="idm139979046529568"></a><a class="indexterm" name="idm139979046527488"></a><p>
          同じテーブルのマスターコピーとスレーブコピー上の対応するカラムは、理想的には同じデータ型であるべきです。ただし MySQL 5.1.21 以降では、一定の条件が満たされるかぎり、これは必ずしも厳密に適用されません。
        </p><p>
          ほかのすべてのことが等しい場合、あるデータ型のカラムから、同じ型、同じサイズまたは幅 (該当する場合は、それより大きい) の別のカラムに複製することは常に可能です。たとえば、<code class="literal">CHAR(10)</code> カラムから別の <code class="literal">CHAR(10)</code> に、または <code class="literal">CHAR(10)</code> カラムから <code class="literal">CHAR(25)</code> カラムに、問題なく複製できます。場合によっては、あるデータ型を持つカラム (マスター上) から異なるデータ型を持つカラム (スレーブ上) に複製できることもあります。マスターバージョンのカラムのデータ型が、同じサイズまたはそれより大きい型に昇格されるとき、これは<em class="firstterm">属性昇格</em>と呼ばれます。
        </p><p>
          属性昇格は、ステートメントベースおよび行ベースレプリケーションで使用でき、マスターまたはスレーブで使用されるストレージエンジンに依存しません。ただし、ロギング形式の選択は許可される型変換に影響します。詳細は、このセクションで後述します。
        </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
            ステートメントベースまたは行ベースのどちらのレプリケーションを使用するときでも、属性昇格を使用する場合はテーブルのスレーブコピーのカラム数をマスターコピーより多くすることはできません。
          </p></div><p><b>ステートメントベースのレプリケーション </b>
            ステートメントベースレプリケーションを使用するときに従うべき簡単な経験則は、<span class="quote">「<span class="quote">マスター上で実行されるステートメントがスレーブ上でも正常に実行される場合は、複製も成功するはず</span>」</span>ということです。つまり、スレーブ上のあるカラムの型と互換性のある値をステートメントが使用する場合、そのステートメントは複製できます。たとえば、<code class="literal">TINYINT</code> カラムに適合する値を <code class="literal">BIGINT</code> カラムにも挿入できます。これは、テーブルのスレーブコピー内の <code class="literal">TINYINT</code> カラムの型を <code class="literal">BIGINT</code> に変更する場合でも、マスター上で成功するそのカラムへの挿入は、スレーブ上でも成功するはずである、ということに従っています (<code class="literal">BIGINT</code> カラムを越えるほど大きな、正当な <code class="literal">TINYINT</code> 値を持つことができないため)。
          </p><p>
          MySQL 5.6.10 より前では、ステートメントベースレプリケーションを使用するときに、<code class="literal">AUTO_INCREMENT</code> カラムはマスターとスレーブの両方で同じである必要がありました。そうでない場合、スレーブ上の間違ったテーブルに更新が適用される可能性がありました (Bug #12669186)
        </p><p><a name="replication-features-attribute-promotion"></a><b>行ベースレプリケーション: 属性の昇格と降格 </b>
            MySQL 5.6 の行ベースレプリケーションは、小さなデータ型と大きなデータ型の間の属性昇格および降格をサポートします。このセクションで後述するように、降格されるカラム値の不可逆 (切り捨て) または非不可逆変換を許可するかどうかを指定することもできます。
          </p><p><b>不可逆および非不可逆変換 </b>
            ターゲット型が挿入される値を表現できない場合、変換をどのように扱うかについての決定が必要になります。変換を許可するけれども、ターゲットカラムで<span class="quote">「<span class="quote">適合</span>」</span>を実現するためにソース値を切り捨てる (または変更する) 場合、<em class="firstterm">不可逆変換</em>と呼ばれることを行います。ソースカラム値をターゲットカラムに適合させるために切り捨てまたは同様の変更を必要としない変換は、<em class="firstterm">非不可逆</em>変換です。
          </p><p><b>型変換モード (slave_type_conversions 変数) </b>
            <code class="literal">slave_type_conversions</code> グローバルサーバー変数の設定は、スレーブで使用される型変換モードを制御します。この変数は次の表 (スレーブの型変換動作に対する各モードの影響を示す) からの値セットを取ります。
          </p><div class="informaltable"><table summary="この表では、slave_type_conversions グローバルサーバー変数の型変換モードを示し、スレーブの型変換動作に対する各モードの影響を記述します。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">モード</th><th scope="col">影響</th></tr></thead><tbody><tr><td scope="row"><code class="literal">ALL_LOSSY</code></td><td><p>
                    このモードでは、情報の損失を意味する型変換が許可されます。
                  </p>



                  <p>
                    これは非不可逆変換が許可されることを暗示せず、不可逆変換を必要とするまたは変換をまったく必要としないケースのみが許可されることだけを暗示します。たとえば、このモード<span class="emphasis"><em>のみ</em></span>を有効にした場合、<code class="literal">INT</code> カラムが <code class="literal">TINYINT</code> に変換されること (不可逆変換) は許可されますが、<code class="literal">TINYINT</code> カラムが <code class="literal">INT</code> カラムに変換されること (非不可逆) は許可されません。このケースで後者の変換を試みると、レプリケーションがスレーブ上のエラーで停止します。
                  </p></td></tr><tr><td scope="row"><code class="literal">ALL_NON_LOSSY</code></td><td><p>
                    このモードは、ソース値の切り捨てまたは特別処理を必要とない変換を許可します。すなわち、ターゲット型の範囲がソース型より広い変換を許可します。
                  </p>



                  <p>
                    このモードを設定することは、不可逆変換が許可されるかどうかに関係ありません。これは <code class="literal">ALL_LOSSY</code> モードで制御されます。<code class="literal">ALL_NON_LOSSY</code> だけが設定され、<code class="literal">ALL_LOSSY</code> はされない場合、データが損失する変換を試みると (<code class="literal">INT</code> から <code class="literal">TINYINT</code> へ、<code class="literal">CHAR(25)</code> から <code class="literal">VARCHAR(20)</code> へなど)、スレーブはエラーで停止します。
                  </p></td></tr><tr><td scope="row"><code class="literal">ALL_LOSSY,ALL_NON_LOSSY</code></td><td><p>
                    このモードが設定されると、サポートされるすべての型変換が、不可逆変換かどうかにかかわらず、許可されます。
                  </p></td></tr><tr><td scope="row"><code class="literal">ALL_SIGNED</code></td><td><p>
                    昇格される整数型を符号付き値として扱います (デフォルト動作)。
                  </p></td></tr><tr><td scope="row"><code class="literal">ALL_UNSIGNED</code></td><td><p>
                    昇格される整数型を符号なし値として扱います。
                  </p></td></tr><tr><td scope="row"><code class="literal">ALL_SIGNED,ALL_UNSIGNED</code></td><td><p>
                    昇格される整数型を、可能な場合符号付きとして、そうでない場合は符号なしとして扱います。
                  </p></td></tr><tr><td scope="row">[<span class="emphasis"><em>empty</em></span>]</td><td><p>
                    <code class="literal">slave_type_conversions</code> が設定されていなときは、属性の昇格または降格は許可されません。これは、ソースおよびターゲットテーブル内のすべてのカラムが同じ型である必要があることを意味します。
                  </p>



                  <p>
                    このモードがデフォルトです。
                  </p></td></tr></tbody></table></div><p>
          整数型が昇格されるときに、符号ありか符号なしかは保持されません。デフォルトでは、スレーブはこのような値をすべて符号付きとして扱います。MySQL 5.6.13 以降では、<code class="literal">ALL_SIGNED</code>、<code class="literal">ALL_UNSIGNED</code>、またはその両方を使用してこの動作を制御できます。(Bug#15831300) <code class="literal">ALL_SIGNED</code> は昇格されるすべての整数型を符号付きとして扱うようにスレーブに指示します。<code class="literal">ALL_UNSIGNED</code> はこれらを符号なしとして扱うように指示します。両方を指定すると、スレーブは、可能な場合は値を符号付きとして扱い、そうでない場合は符号なしとして扱います。リストされている順序は重要ではありません。少なくとも <code class="literal">ALL_LOSSY</code> または <code class="literal">ALL_NONLOSSY</code> のいずれかが使用されていない場合は、<code class="literal">ALL_SIGNED</code> も <code class="literal">ALL_UNSIGNED</code> も効果を持ちません。
        </p><p>
          型変換モードを変更するには、新しい <code class="literal">slave_type_conversions</code> 設定でスレーブを再起動する必要があります。
        </p><p><b>サポートされる変換 </b>
            違うけれども似ているデータ型の間でサポートされる変換を次のリストに示します。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              整数型 <code class="literal">TINYINT</code>、<code class="literal">SMALLINT</code>、<code class="literal">MEDIUMINT</code>、<code class="literal">INT</code>、および <code class="literal">BIGINT</code> のいずれかの間。
            </p><p>
              これには、これらの型の符号付きおよび符号なしバージョンの間の変換が含まれます。
            </p><p>
              不可逆変換は、ソース値をターゲットカラムで許可される最大値 (または最小値) に切り捨てることで行われます。符号なしから符号付き型への非不可逆変換を保証するには、ターゲットカラムがソースカラム内の値の範囲を受け入れるのに十分な大きさである必要があります。たとえば、<code class="literal">TINYINT UNSIGNED</code> は、非不可逆に <code class="literal">SMALLINT</code> に降格できますが、<code class="literal">TINYINT</code> にはできません。
            </p></li><li class="listitem"><p>
              小数点型 <code class="literal">DECIMAL</code>、<code class="literal">FLOAT</code>、<code class="literal">DOUBLE</code>、および <code class="literal">NUMERIC</code> のいずれかの間。
            </p><p>
              <code class="literal">FLOAT</code> から <code class="literal">DOUBLE</code> へは非不可逆変換です。<code class="literal">DOUBLE</code> から <code class="literal">FLOAT</code> へは不可逆にしか扱えません。<code class="literal">DECIMAL(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)</code> から <code class="literal">DECIMAL(<em class="replaceable"><code>M'</code></em>,<em class="replaceable"><code>D'</code></em>)</code> への変換 (<code class="literal"><em class="replaceable"><code>D'</code></em> &gt;= <em class="replaceable"><code>D</code></em></code> および <code class="literal">(<em class="replaceable"><code>M'</code></em>-<em class="replaceable"><code>D'</code></em>) &gt;= (<em class="replaceable"><code>M</code></em></code>-<em class="replaceable"><code>D</code></em>)) は非不可逆です。<code class="literal"><em class="replaceable"><code>M'</code></em> &lt; <em class="replaceable"><code>M</code></em></code>、<code class="literal"><em class="replaceable"><code>D'</code></em> &lt; <em class="replaceable"><code>D</code></em></code>、またはその両方の場合、不可逆変換だけを行うことができます。
            </p><p>
              いずれかの小数点型の場合、格納される値をターゲット型に適合させることができない場合は、このマニュアルのほかの場所でサーバーに定義される丸めルールに従って値が切り捨てられます。小数点型でこれがどのように実行されるかについては、<a class="xref" href="functions.html#precision-math-rounding" title="12.20.4 丸め動作">セクション12.20.4「丸め動作」</a>を参照してください。
            </p></li><li class="listitem"><p>
              文字列型 <code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、および <code class="literal">TEXT</code> のいずれかの間 (異なる幅の間での変換を含む)。
            </p><p>
              <code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、または <code class="literal">TEXT</code> から、同じまたはそれより大きいサイズの <code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、または <code class="literal">TEXT</code> カラムへの変換は、決して不可逆ではありません。不可逆変換は、スレーブ上の文字列の最初の <em class="replaceable"><code>N</code></em> 文字だけを挿入することで処理されます。ここで、<em class="replaceable"><code>N</code></em> はターゲットカラムの幅です。
            </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
                異なる文字セットを使用するカラム間のレプリケーションはサポートされません。
              </p></div></li><li class="listitem"><p>
              バイナリデータ型 <code class="literal">BINARY</code>、<code class="literal">VARBINARY</code>、および <code class="literal">BLOB</code> のいずれかの間 (異なる幅の間での変換を含む)。
            </p><p>
              <code class="literal">BINARY</code>、<code class="literal">VARBINARY</code>、または <code class="literal">BLOB</code> から、同じまたはそれより大きいサイズの <code class="literal">BINARY</code>、<code class="literal">VARBINARY</code>、または <code class="literal">BLOB</code> カラムへの変換は、決して不可逆ではありません。不可逆変換は、スレーブ上の文字列の最初の <em class="replaceable"><code>N</code></em> バイトだけを挿入することで扱われます。ここで、<em class="replaceable"><code>N</code></em> はターゲットカラムの幅です。
            </p></li><li class="listitem"><p>
              任意の 2 つのサイズの任意の 2 つの <code class="literal">BIT</code> カラムの間。
            </p><p>
              <code class="literal">BIT(<em class="replaceable"><code>M</code></em>)</code> カラムからの値を <code class="literal">BIT(<em class="replaceable"><code>M'</code></em>)</code> カラムに挿入するときは (<code class="literal"><em class="replaceable"><code>M'</code></em> &gt; <em class="replaceable"><code>M</code></em></code>)、<code class="literal">BIT(<em class="replaceable"><code>M'</code></em>)</code> カラムの最上位ビットがクリアされ (ゼロに設定され)、<code class="literal">BIT(<em class="replaceable"><code>M</code></em>)</code> 値の <em class="replaceable"><code>M</code></em> ビットが <code class="literal">BIT(<em class="replaceable"><code>M'</code></em>)</code> カラムの最下位ビットとして設定されます。
            </p><p>
              ソース <code class="literal">BIT(<em class="replaceable"><code>M</code></em>)</code> カラムからの値をターゲット <code class="literal">BIT(<em class="replaceable"><code>M'</code></em>)</code> カラムに挿入するときは (<code class="literal"><em class="replaceable"><code>M'</code></em> &lt; <em class="replaceable"><code>M</code></em></code>)、<code class="literal">BIT(<em class="replaceable"><code>M'</code></em>)</code> カラムの可能な最大値が割り当てられます。つまり、<span class="quote">「<span class="quote">すべてが設定された</span>」</span>値がターゲットカラムに割り当てられます。
            </p></li></ul></div><p>
          前のリストにない型の間の変換は許可されません。
        </p><p><a name="replication-features-type-conversions-old"></a><b>MySQL 5.5.3 以前でのレプリケーション型変換 </b>
            MySQL 5.5.3 より前は、行ベースバイナリロギングで、<code class="literal">TINYINT</code> から <code class="literal">BIGINT</code> へなど、異なる <code class="literal">INT</code> サブ型の間で複製することはできませんでした。行ベースロギングを使用するときは、これらの型のカラムへの変更が、バイナリログ内で互いに異なる方法で表現されていたためです。(ただし、行ベースレプリケーションを使用して <code class="literal">BLOB</code> から <code class="literal">TEXT</code> に複製することはできました。<code class="literal">BLOB</code> および <code class="literal">TEXT</code> カラムへの変更がバイナリログ内で同じ形式を使用して表現されていたためです。)
          </p><p>
          MySQL 5.5.3 より前の行ベースレプリケーションを使用するときに、属性昇格でサポートされる変換を次の表に示します。
        </p><div class="informaltable"><table summary="この表は、MySQL 5.5.3 より前の行ベースレプリケーションを使用するときに、属性昇格でサポートされる変換を示します。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">変換前 (マスター)</th><th scope="col">変換後 (スレーブ)</th></tr></thead><tbody><tr><td scope="row"><code class="literal">BINARY</code></td><td><code class="literal">CHAR</code></td></tr><tr><td scope="row"><code class="literal">BLOB</code></td><td><code class="literal">TEXT</code></td></tr><tr><td scope="row"><code class="literal">CHAR</code></td><td><code class="literal">BINARY</code></td></tr><tr><td scope="row"><code class="literal">DECIMAL</code></td><td><code class="literal">NUMERIC</code></td></tr><tr><td scope="row"><code class="literal">NUMERIC</code></td><td><code class="literal">DECIMAL</code></td></tr><tr><td scope="row"><code class="literal">TEXT</code></td><td><code class="literal">BLOB</code></td></tr><tr><td scope="row"><code class="literal">VARBINARY</code></td><td><code class="literal">VARCHAR</code></td></tr><tr><td scope="row"><code class="literal">VARCHAR</code></td><td><code class="literal">VARBINARY</code></td></tr></tbody></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            すべてのケースで、スレーブ上のカラムのサイズまたは幅は、マスター上のカラムのもの以上にする必要があります。たとえば、マスター上の <code class="literal">CHAR(10)</code> カラムから、スレーブ上の <code class="literal">BINARY(10)</code> または <code class="literal">BINARY(25)</code> を使用するカラムに複製できましたが、マスター上の <code class="literal">CHAR(10)</code> カラムからスレーブ上の <code class="literal">BINARY(5)</code> カラムに複製することはできませんでした。
          </p><p>
            プリフィクスを持つ一意インデックス (主キーを含む) は、マスターとスレーブの両方で同じ長さのプリフィクスを使用する必要があります。このような場合、異なるプリフィクス長は許可されません。プリフィクス長がマスターとスレーブで異なる一意でないインデックスを使用することは可能ですが、これによって重大なパフォーマンス問題が発生する場合があります (特に、マスター上で使用されるプリフィクスの方が長いとき)。これは、ある長さの 2 つの一意プリフィクスが、長さが短くなると一意でなくなる場合があるという事実によります。たとえば、単語 <span class="emphasis"><em>catalogue</em></span> と <span class="emphasis"><em>catamount</em></span> は、それぞれ 5 文字のプリフィクス <span class="emphasis"><em>catal</em></span> と <span class="emphasis"><em>catam</em></span> を持ちますが、4 文字の同じプリフィクス (<span class="emphasis"><em>cata</em></span>) を共有します。これにより、このようなインデックスを使用するクエリーが、同じインデックスのスレーブ定義でマスター上のものより短いプリフィクスが使用されるときに、スレーブ上での実行効率が低下する可能性があります。
          </p><p>
            <code class="literal">DECIMAL</code> および <code class="literal">NUMERIC</code> カラムの場合、仮数 (<span class="emphasis"><em>M</em></span>) と小数以下の桁数 (<span class="emphasis"><em>D</em></span>) の両方が、マスターに比べてスレーブ上で同じまたはそれより大きいサイズである必要があります。たとえば、<code class="literal">NUMERIC(5,4)</code> から <code class="literal">DECIMAL(6,4)</code> へのレプリケーションは機能しましたが、<code class="literal">NUMERIC(5,4)</code> から <code class="literal">DECIMAL(5,3)</code> へのレプリケーションはしませんでした。
          </p></div><p>
          MySQL 5.5.3 より前は、行ベースレプリケーションを使用するときに、MySQL レプリケーションは次のデータ型とほかのデータ型との間で属性昇格をサポートしませんでした。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">INT</code> (<code class="literal">TINYINT</code>、<code class="literal">SMALLINT</code>、<code class="literal">MEDIUMINT</code>、<code class="literal">BIGINT</code> を含む)。
            </p><p>
              <code class="literal">INT</code> サブ型間の昇格 (たとえば、<code class="literal">SMALLINT</code> から <code class="literal">BIGINT</code> へ) も、MySQL 5.5.3 より前はサポートされませんでした。
            </p></li><li class="listitem"><p>
              <code class="literal">SET</code> または <code class="literal">ENUM</code>。
            </p></li><li class="listitem"><p>
              <code class="literal">FLOAT</code> または <code class="literal">DOUBLE</code>。
            </p></li><li class="listitem"><p>
              日付、時間、またはその両方に関連するデータ型のすべて: <code class="literal">DATE</code>、<code class="literal">TIME</code>、<code class="literal">DATETIME</code>、<code class="literal">TIMESTAMP</code>、および <code class="literal">YEAR</code>。
            </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-directory"></a>17.4.1.10 レプリケーションと DIRECTORY テーブルオプション</h4></div></div></div><a class="indexterm" name="idm139979046317360"></a><a class="indexterm" name="idm139979046315216"></a><a class="indexterm" name="idm139979046313152"></a><a class="indexterm" name="idm139979046311056"></a><a class="indexterm" name="idm139979046308992"></a><p>
        <code class="literal">DATA DIRECTORY</code> または <code class="literal">INDEX DIRECTORY</code> テーブルオプションが、マスターサーバー上の <code class="literal">CREATE TABLE</code> ステートメントで使用されている場合、そのテーブルオプションはスレーブでも使用されます。このため、対応するディレクトリがスレーブホストファイルシステムに存在しない場合、または存在するけれどもスレーブサーバーにアクセスできない場合は、問題が発生する可能性があります。これはスレーブ上で <code class="literal">NO_DIR_IN_CREATE</code> サーバー SQL モードを使用することでオーバーライドでき、これによってスレーブは <code class="literal">CREATE TABLE</code> ステートメントを複製するときに <code class="literal">DATA DIRECTORY</code> および <code class="literal">INDEX DIRECTORY</code> テーブルオプションを無視します。その結果、テーブルのデータベースディレクトリ内に <code class="literal">MyISAM</code> データおよびインデックスファイルが作成されます。
      </p><p>
        詳細は、<a class="xref" href="server-administration.html#sql-mode" title="5.1.7 サーバー SQL モード">セクション5.1.7「サーバー SQL モード」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-invoked"></a>17.4.1.11 呼び出される機能のレプリケーション</h4></div></div></div><a class="indexterm" name="idm139979046295472"></a><a class="indexterm" name="idm139979046293344"></a><a class="indexterm" name="idm139979046291216"></a><a class="indexterm" name="idm139979046289120"></a><a class="indexterm" name="idm139979046287056"></a><a class="indexterm" name="idm139979046284960"></a><a class="indexterm" name="idm139979046282864"></a><p>
        ユーザー定義関数 (UDF) やストアドプログラム (ストアドプロシージャーと関数、トリガー、およびイベント) などの呼び出される機能のレプリケーションには、次の特徴があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            機能の影響は常に複製されます。
          </p></li><li class="listitem"><p>
            次のステートメントはステートメントベースレプリケーションを使用して複製されます。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">CREATE EVENT</code>
              </p></li><li class="listitem"><p>
                <code class="literal">ALTER EVENT</code>
              </p></li><li class="listitem"><p>
                <code class="literal">DROP EVENT</code>
              </p></li><li class="listitem"><p>
                <code class="literal">CREATE PROCEDURE</code>
              </p></li><li class="listitem"><p>
                <code class="literal">DROP PROCEDURE</code>
              </p></li><li class="listitem"><p>
                <code class="literal">CREATE FUNCTION</code>
              </p></li><li class="listitem"><p>
                <code class="literal">DROP FUNCTION</code>
              </p></li><li class="listitem"><p>
                <code class="literal">CREATE TRIGGER</code>
              </p></li><li class="listitem"><p>
                <code class="literal">DROP TRIGGER</code>
              </p></li></ul></div><p>
            ただし、これらのステートメントを使用して作成、変更、または削除される機能の<span class="emphasis"><em>影響</em></span>は、行ベースレプリケーションを使用して複製されます。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              呼び出される機能をステートメントベースレプリケーションを使用して複製しようとすると、警告が生成されます: <span class="errortext">Statement is not safe to log in statement format</span>。たとえば、ステートメントベースプリケーションで UDF を複製しようとすると、MySQL サーバーは現在 UDF が決定的かどうかを判断できないため、この警告が生成されます。呼び出される機能の影響が決定的であることを確実にわかっている場合は、このような警告を安全に無視できます。
            </p></div></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979046257712"></a> <a class="indexterm" name="idm139979046255536"></a> <a class="indexterm" name="idm139979046253472"></a> <a class="indexterm" name="idm139979046251376"></a><code class="literal">CREATE EVENT</code> および <code class="literal">ALTER EVENT</code> の場合:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                イベントのステータスは、指定された状態にかかわらず、スレーブ上で <code class="literal">SLAVESIDE_DISABLED</code> に設定されます (これは <code class="literal">DROP EVENT</code> には適用されません)。
              </p></li><li class="listitem"><p>
                イベントが作成されたマスターは、スレーブ上でそのサーバー ID によって識別されます。<code class="literal">INFORMATION_SCHEMA.EVENTS</code> 内の <code class="literal">ORIGINATOR</code> カラムおよび <code class="literal">mysql.event</code> 内の <code class="literal">originator</code> カラムにこの情報が格納されます。詳しくは、<a class="xref" href="information-schema.html#events-table" title="21.7 INFORMATION_SCHEMA EVENTS テーブル">セクション21.7「INFORMATION_SCHEMA EVENTS テーブル」</a>および<a class="xref" href="sql-syntax.html#show-events" title="13.7.5.19 SHOW EVENTS 構文">セクション13.7.5.19「SHOW EVENTS 構文」</a>を参照してください。
              </p></li></ul></div></li><li class="listitem"><p>
            機能実装は、マスターが失敗してもイベント処理を失うことなくスレーブをマスターとして使用できるように、再生可能な状態でスレーブ上に存在します。
          </p></li></ul></div><p>
        別のサーバー (レプリケーションマスターとして動作していました) 上で作成されたスケジュールされたイベントが MySQL サーバー上にあるかどうかを判断するには、ここで示すような方法で <code class="literal">INFORMATION_SCHEMA.EVENTS</code> テーブルを照会してください。
      </p><pre class="programlisting">
SELECT EVENT_SCHEMA, EVENT_NAME
    FROM INFORMATION_SCHEMA.EVENTS
    WHERE STATUS = 'SLAVESIDE_DISABLED';
</pre><p>
        また、<code class="literal">SHOW EVENTS</code> ステートメントを次のように使用できます。
      </p><pre class="programlisting">
SHOW EVENTS
    WHERE STATUS = 'SLAVESIDE_DISABLED';
</pre><p>
        このようなイベントを持つレプリケーションスレーブをレプリケーションマスターに昇格するときは、<code class="literal">ALTER EVENT <em class="replaceable"><code>event_name</code></em> ENABLED</code> を使用して各イベントを有効にする必要があります。ここで、<em class="replaceable"><code>event_name</code></em> はイベントの名前です。
      </p><p>
        複数のマスターがこのスレーブ上でイベントを作成することに使用され、サーバー ID <em class="replaceable"><code>master_id</code></em> を持つマスター上で作成されたイベントのみを識別したい場合は、ここで示すように、<code class="literal">EVENTS</code> テーブルに対する先ほどのクエリーを変更して <code class="literal">ORIGINATOR</code> カラムを追加してください。
      </p><pre class="programlisting">
SELECT EVENT_SCHEMA, EVENT_NAME, ORIGINATOR
    FROM INFORMATION_SCHEMA.EVENTS
    WHERE STATUS = 'SLAVESIDE_DISABLED'
    AND   ORIGINATOR = '<em class="replaceable"><code>master_id</code></em>'
</pre><p>
        同じような方法で <code class="literal">SHOW EVENTS</code> ステートメントで <code class="literal">ORIGINATOR</code> を使用できます。
      </p><pre class="programlisting">
SHOW EVENTS
    WHERE STATUS = 'SLAVESIDE_DISABLED'
    AND   ORIGINATOR = '<em class="replaceable"><code>master_id</code></em>'
</pre><p>
        マスターから複製されたイベントを有効にする前に、スレーブ上で MySQL イベントスケジューラを無効にし (<code class="literal">SET GLOBAL event_scheduler = OFF;</code> などのステートメントを使用して)、必要な <code class="literal">ALTER EVENT</code> ステートメントを実行し、サーバーを再起動し、その後スレーブ上でイベントスケジューラを再度有効にしてください (<code class="literal">SET GLOBAL event_scheduler = ON;</code> などのステートメントを使用)。
      </p><p>
        あとで新しいマスターをレプリケーションスレーブに降格する場合は、<code class="literal">ALTER EVENT</code> ステートメントで有効にしたすべてのイベントを手動で無効にする必要があります。これは、前に示した <code class="literal">SELECT</code> ステートメントからのイベントの名前を別個のテーブルに格納するか、<code class="literal">ALTER EVENT</code> ステートメントを使用してイベントを識別する共通プリフィクス ( <code class="literal">replicated_</code> など) でそれらの名前を変更することで、行うことができます。
      </p><p>
        イベントの名前を変更した場合は、このサーバーをレプリケーションスレーブに降格するときに、ここで示すように <code class="literal">EVENTS</code> テーブルを照会することでイベントを識別できます。
      </p><pre class="programlisting">
SELECT CONCAT(EVENT_SCHEMA, '.', EVENT_NAME) AS 'Db.Event'
      FROM INFORMATION_SCHEMA.EVENTS
      WHERE INSTR(EVENT_NAME, 'replicated_') = 1;
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-floatvalues"></a>17.4.1.12 レプリケーションと浮動小数点値</h4></div></div></div><a class="indexterm" name="idm139979046208240"></a><a class="indexterm" name="idm139979046206064"></a><p>
        ステートメントベースレプリケーションでは、値は 10 進からバイナリに変換されます。それらの表現を 10 進とバイナリの間で変換すると近似値になる場合があるため、浮動小数点値を含む比較が不正確になります。これは、浮動小数点値を明示的に使用したり、浮動小数点に暗黙的に変換された値を使用したりする演算に当てはまります。コンピュータアーキテクチャーや MySQL をビルドするために使用されたコンパイラなどの違いにより、浮動小数点値の比較がマスターおよびスレーブサーバーで異なる結果になる場合があります。<a class="xref" href="functions.html#type-conversion" title="12.2 式評価での型変換">セクション12.2「式評価での型変換」</a>および<a class="xref" href="error-handling.html#problems-with-float" title="B.5.5.8 浮動小数点値に関する問題">セクションB.5.5.8「浮動小数点値に関する問題」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-fractional-seconds"></a>17.4.1.13 レプリケーションと小数秒サポート</h4></div></div></div><a class="indexterm" name="idm139979046199424"></a><a class="indexterm" name="idm139979046197312"></a><p>
        MySQL 5.6.4 以降では、マイクロ秒 (6 桁) までの精度を持つ <code class="literal">TIME</code>、<code class="literal">DATETIME</code>、および <code class="literal">TIMESTAMP</code> 値の小数秒に対応できるようになりました。<a class="xref" href="data-types.html#fractional-seconds" title="11.3.6 時間値での小数秒">セクション11.3.6「時間値での小数秒」</a>を参照してください。
      </p><p>
        小数秒を理解するマスターサーバーから理解しない古いスレーブに複製する際、問題が発生することがあります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <em class="replaceable"><code>fsp</code></em> (小数秒精度) 値が 0 より大きいカラムを含む <code class="literal">CREATE TABLE</code> ステートメントの場合、レプリケーションはパーサーエラーで失敗します。
          </p></li><li class="listitem"><p>
            <em class="replaceable"><code>fsp</code></em> 値が 0 の一時データ型を使用するステートメントは、ステートメントベースロギングでは機能しますが、行ベースロギングでは機能しません。後者の場合、このデータ型がマスター上で持つバイナリ形式と型コードは、スレーブ上のものと異なります。
          </p></li><li class="listitem"><p>
            いくつかの式の結果がマスター上とスレーブ上で異なります。例: マスター上では、<code class="literal">timestamp</code> システム変数はマイクロ秒小数部を含む値を返し、スレーブ上では整数を返します。マスター上では、現在時間を含む結果を返す関数 (<code class="literal">CURTIME()</code>、<code class="literal">SYSDATE()</code>、<code class="literal">UTC_TIMESTAMP()</code> など) は引数を <em class="replaceable"><code>fsp</code></em> 値として解釈し、戻り値はその多くの桁の小数秒部を含みます。スレーブ上では、これらの関数は引数を許可しますが無視します。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-flush"></a>17.4.1.14 レプリケーションと FLUSH</h4></div></div></div><a class="indexterm" name="idm139979046178368"></a><a class="indexterm" name="idm139979046176192"></a><p>
        一部の形式の <code class="literal">FLUSH</code> ステートメント (<code class="literal">FLUSH LOGS</code>、<code class="literal">FLUSH MASTER</code>、<code class="literal">FLUSH SLAVE</code>、および <code class="literal">FLUSH TABLES WITH READ LOCK</code>) は、それらがスレーブに複製される場合に問題が発生する可能性があるため、ログに記録されません。構文例は、<a class="xref" href="sql-syntax.html#flush" title="13.7.6.3 FLUSH 構文">セクション13.7.6.3「FLUSH 構文」</a>を参照してください。 <code class="literal">FLUSH TABLES</code>、<code class="literal">ANALYZE TABLE</code>、<code class="literal">OPTIMIZE TABLE</code>、および <code class="literal">REPAIR TABLE</code> ステートメントはバイナリログに書き込まれるため、スレーブに複製されます。これらのステートメントはテーブルデータを変更しないため、通常は問題ではありません。
      </p><p>
        ただし、ある状況では、この動作が問題になる場合があります。<code class="literal">mysql</code> データベース内の権限テーブルを複製し、これらのテーブルを <code class="literal">GRANT</code> を使用しないで直接更新する場合は、スレーブ上で <code class="literal">FLUSH PRIVILEGES</code> を発行して新しい権限を有効にする必要があります。また、<code class="literal">MERGE</code> テーブルの一部である <code class="literal">MyISAM</code> テーブルの名前を変更するときに <code class="literal">FLUSH TABLES</code> を使用する場合は、スレーブ上で <code class="literal">FLUSH TABLES</code> を手動で発行する必要があります。<code class="literal">NO_WRITE_TO_BINLOG</code> またはそのエイリアスの <code class="literal">LOCAL</code> を指定しない場合、これらのステートメントはバイナリログに書き込まれます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-functions"></a>17.4.1.15 レプリケーションとシステム関数</h4></div></div></div><a class="indexterm" name="idm139979046150688"></a><a class="indexterm" name="idm139979046148560"></a><p>
        一部の関数は条件によっては適切に複製されません。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">USER()</code>、<code class="literal">CURRENT_USER()</code> (または <code class="literal">CURRENT_USER</code>)、<code class="literal">UUID()</code>、<code class="literal">VERSION()</code>、および <code class="literal">LOAD_FILE()</code> 関数は、変更なしで複製されますが、行ベースレプリケーションが有効である場合を除いてスレーブ上での機能に信頼性がありません。(<a class="xref" href="replication.html#replication-formats" title="17.1.2 レプリケーション形式">セクション17.1.2「レプリケーション形式」</a>を参照してください。)
          </p><p>
            <code class="literal">USER()</code> および <code class="literal">CURRENT_USER()</code> は、<code class="literal">MIXED</code> モード使用時に行ベースレプリケーションを使用して自動的に複製され、<code class="literal">STATEMENT</code> モードでは警告を生成します。(<a class="xref" href="replication.html#replication-features-current-user" title="17.4.1.7 CURRENT_USER() のレプリケーション">セクション17.4.1.7「CURRENT_USER() のレプリケーション」</a>も参照してください。)これは、<code class="literal">VERSION()</code> および <code class="literal">RAND()</code> にも当てはまります。
          </p></li><li class="listitem"><p>
            <code class="literal">NOW()</code> の場合、バイナリログはタイムスタンプを含みます。これは、<span class="emphasis"><em>マスター上でこの関数への呼び出しによって戻される値が</em></span>スレーブに複製されることを意味します。タイムゾーンが異なる MySQL サーバー間で複製するときの予期しない結果を回避するには、マスターとスレーブの両方でタイムゾーンを設定してください。<a class="xref" href="replication.html#replication-features-timezone" title="17.4.1.30 レプリケーションとタイムゾーン">セクション17.4.1.30「レプリケーションとタイムゾーン」</a>も参照してください。
          </p><p>
            タイムゾーンが異なるサーバー間で複製するときに発生する可能性のある問題を説明するために、マスターはニューヨークにあり、スレーブはストックホルムにあり、両方のサーバーが現地時間を使用しているものとします。さらに、ここで示すようにマスター上で、テーブル <code class="literal">mytable</code> を作成し、このテーブルで <code class="literal">INSERT</code> ステートメントを実行してから、テーブルから選択するものとします。
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE mytable (mycol TEXT);</code></strong>
Query OK, 0 rows affected (0.06 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO mytable VALUES ( NOW() );</code></strong>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM mytable;</code></strong>
+---------------------+
| mycol               |
+---------------------+
| 2009-09-01 12:00:00 |
+---------------------+
1 row in set (0.00 sec)
</pre><p>
            ストックホルムの現地時間はニューヨークより 6 時間遅れます。このため、スレーブ上で <code class="literal">SELECT NOW()</code> を完全に同じタイミングで発行すると、値 <code class="literal">2009-09-01 18:00:00</code> が戻されます。このため、上記の <code class="literal">CREATE TABLE</code> および <code class="literal">INSERT</code> ステートメントが複製されたあとに、<code class="literal">mytable</code> のスレーブコピーから選択すると、<code class="literal">mycol</code> に値 <code class="literal">2009-09-01 18:00:00</code> が含まれると予想できます。しかし、これはそうなりません。<code class="literal">mytable</code> のスレーブコピーから選択すると、マスターとまったく同じ結果になります。
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT * FROM mytable;</code></strong>
+---------------------+
| mycol               |
+---------------------+
| 2009-09-01 12:00:00 |
+---------------------+
1 row in set (0.00 sec)
</pre><p>
            <code class="literal">SYSDATE()</code> 関数は、<code class="literal">NOW()</code> とは異なり、レプリケーションに安全ではありません。バイナリログ内で <code class="literal">SET TIMESTAMP</code> ステートメントに影響されず、ステートメントベースロギングが使用される場合は非決定的であるためです。行ベースロギングを使用する場合は、これは問題ではありません。
          </p><p>
            ほかの方法は <code class="option">--sysdate-is-now</code> オプションを使用することで、<code class="literal">SYSDATE()</code> が <code class="literal">NOW()</code> のエイリアスになります。正しく機能するには、これをマスターとスレーブで行う必要があります。このような場合でも、この関数によって警告が発行されますが、<code class="option">--sysdate-is-now</code> がマスターとスレーブの両方で使用されるかぎり安全に無視できます。
          </p><p>
            MySQL 5.5.1 以降では、<code class="literal">SYSDATE()</code> は <code class="literal">MIXED</code> モード使用時に行ベースレプリケーションを使用して自動的に複製され、<code class="literal">STATEMENT</code> モードで警告を生成します。(Bug #47995)
          </p><p>
            <a class="xref" href="replication.html#replication-features-timezone" title="17.4.1.30 レプリケーションとタイムゾーン">セクション17.4.1.30「レプリケーションとタイムゾーン」</a>も参照してください。
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>次の制限は、ステートメントベースレプリケーションにのみ適用され、行ベースレプリケーションには適用されません。</em></span>ユーザーレベルロックを扱う <code class="literal">GET_LOCK()</code>、<code class="literal">RELEASE_LOCK()</code>、<code class="literal">IS_FREE_LOCK()</code>、および <code class="literal">IS_USED_LOCK()</code> 関数は、スレーブがマスター上の並列コンテキストを知ることなく複製されます。したがって、スレーブ上の内容が違ってしまうため、これらの関数を使用してマスターテーブルに挿入しないでください。たとえば、<code class="literal">INSERT INTO mytable VALUES(GET_LOCK(...))</code> などのステートメントを発行しないでください。
          </p><p>
            MySQL 5.5.1 以降では、これらの関数は <code class="literal">MIXED</code> モード使用時に行ベースレプリケーションを使用して自動的に複製され、<code class="literal">STATEMENT</code> モードで警告を生成します。(Bug #47995)
          </p></li></ul></div><p>
        ステートメントベースレプリケーションが有効のときに前述の制限に対する回避策として、問題のある関数結果をユーザー変数に保存して、後続のステートメントでその変数を参照する方法を使用できます。たとえば、次の単一行 <code class="literal">INSERT</code> は、<code class="literal">UUID()</code> 関数を参照するため問題があります。
      </p><pre class="programlisting">
INSERT INTO t VALUES(UUID());
</pre><p>
        この問題を回避するには、代わりにこれを実行してください。
      </p><pre class="programlisting">
SET @my_uuid = UUID();
INSERT INTO t VALUES(@my_uuid);
</pre><p>
        このステートメントの連続は複製されます。<code class="literal">@my_uuid</code> の値が <code class="literal">INSERT</code> ステートメントの前にユーザー変数イベントとしてバイナリログに格納されて <code class="literal">INSERT</code> で使用できるためです。
      </p><p>
        同じ概念が複数行挿入に適用されますが、使用するのが面倒です。2 行挿入の場合、このようにできます。
      </p><pre class="programlisting">
SET @my_uuid1 = UUID(); @my_uuid2 = UUID();
INSERT INTO t VALUES(@my_uuid1),(@my_uuid2);
</pre><p>
        ただし、行数が多いか不明の場合、この回避策は困難であるか実用的でありません。たとえば、次のステートメントを個々のユーザー変数が各行に関連付けられているものに変換することはできません。
      </p><pre class="programlisting">
INSERT INTO t2 SELECT UUID(), * FROM t1;
</pre><p>
        ストアドファンクション内で、<code class="literal">RAND()</code> は、関数の実行中に 1 回だけ呼び出されるかぎり、正しく複製されます。(関数実行タイムスタンプと乱数シードをマスターとスレーブで同じ暗黙的入力と見なすことができます。)
      </p><p>
        <code class="literal">FOUND_ROWS()</code> と <code class="literal">ROW_COUNT()</code> 関数がステートメントベースレプリケーションを使用して複製されるときは、信頼性がありません。回避策は、関数呼び出しの結果をユーザー変数に格納してから、<code class="literal">INSERT</code> ステートメントでこれを使用することです。たとえば、<code class="literal">mytable</code> という名前のテーブルに結果を格納する場合は、普通は次のように実行するかもしれません。
      </p><pre class="programlisting">
SELECT SQL_CALC_FOUND_ROWS FROM mytable LIMIT 1;
INSERT INTO mytable VALUES( FOUND_ROWS() );
</pre><p>
        しかし、<code class="literal">mytable</code> を複製する場合は、次のように <code class="literal">SELECT ... INTO</code> を使用してから変数をテーブルに格納することをお勧めします。
      </p><pre class="programlisting">
SELECT SQL_CALC_FOUND_ROWS INTO @found_rows FROM mytable LIMIT 1;
INSERT INTO mytable VALUES(@found_rows);
</pre><p>
        このようにすることで、ユーザー変数はコンテキストの一部として複製され、スレーブ上で正しく適用されます。
      </p><p>
        これらの関数は、<code class="literal">MIXED</code> モード使用時に行ベースレプリケーションを使用して自動的に複製され、<code class="literal">STATEMENT</code> モードで警告を生成します。(Bug #12092、Bug #30244)
      </p><p>
        MySQL 5.6.15 より前は、<code class="option">--replicate-ignore-db</code> や <code class="option">--replicate-do-table</code> などのフィルタリングオプションがスレーブで有効になっていた場合、<code class="literal">LAST_INSERT_ID()</code> の値は正しく複製されませんでした。(Bug #17234370、BUG# 69861)
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-limit"></a>17.4.1.16 レプリケーションと LIMIT</h4></div></div></div><a class="indexterm" name="idm139979046059760"></a><a class="indexterm" name="idm139979046057584"></a><p>
        <code class="literal">DELETE</code>、<code class="literal">UPDATE</code>、および <code class="literal">INSERT ... SELECT</code> ステートメント内の <code class="literal">LIMIT</code> 句のステートメントベースレプリケーションは、影響を受ける行の順序が未定義のため、安全ではありません。(このようなステートメントは、<code class="literal">ORDER BY</code> 句も含んでいる場合にのみ、ステートメントベースレプリケーションで正しく複製できます。)このようなステートメントに遭遇したときは:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">STATEMENT</code> モード使用時は、このステートメントがステートメントベースレプリケーションで安全でないという警告が発行されるようになりました。
          </p><p>
            現在のところ、<code class="literal">STATEMENT</code> モード使用時は、<code class="literal">LIMIT</code> を含む DML ステートメントに対して警告が発行されます (それらが <code class="literal">ORDER BY</code> 句も含んでいても (それによって決定的にされても))。これは既知の問題です。(Bug #42851)
          </p></li><li class="listitem"><p>
            <code class="literal">MIXED</code> モード使用時は、このステートメントは行ベースモードを使用して自動的に複製されるようになりました。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-load-data"></a>17.4.1.17 レプリケーションと LOAD DATA INFILE</h4></div></div></div><a class="indexterm" name="idm139979046041312"></a><a class="indexterm" name="idm139979046039184"></a><p>
        <code class="literal">LOAD DATA INFILE</code> ステートメントは、MySQL 4.0 以前が動作するマスターから MySQL 5.5.0 以前が動作するスレーブに常に正しく複製されるとはかぎりませんでした。ステートメントベースレプリケーションを使用するときは、<code class="literal">LOAD DATA INFILE</code> ステートメント <code class="literal">CONCURRENT</code> オプションは複製されませんでした。この問題は MySQL 5.5.0 で解決されました。MySQL 5.1 以降で行ベースレプリケーションを使用するときは、この問題は <code class="literal">CONCURRENT</code> オプション処理に影響しません。(Bug #34628)
      </p><p>
        MySQL 5.6 以降は、<code class="literal">LOAD DATA INFILE</code> は安全でないと見なされています (<a class="xref" href="replication.html#replication-rbr-safe-unsafe" title="17.1.2.3 バイナリロギングでの安全および安全でないステートメントの判断">セクション17.1.2.3「バイナリロギングでの安全および安全でないステートメントの判断」</a>を参照してください)。ステートメントベースロギング形式を使用時に警告が発行され、混合形式ロギング使用時は行ベース形式を使用してログが記録されます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-repair-table"></a>17.4.1.18 レプリケーションと REPAIR TABLE</h4></div></div></div><a class="indexterm" name="idm139979046027760"></a><a class="indexterm" name="idm139979046025568"></a><p>
        破損または損傷したテーブルで使用されるとき、<code class="literal">REPAIR TABLE</code> ステートメントはリカバリできない行を削除できます。ただし、このステートメントによって実行されたテーブルデータのそのような変更は複製されないため、マスターとスレーブが同期を失う可能性があります。このため、マスター上のテーブルが損傷し、<code class="literal">REPAIR TABLE</code> を使用してそれを修復する場合は、<code class="literal">REPAIR TABLE</code> を使用する前にまずレプリケーションを停止し (まだ実行中の場合)、その後テーブルのマスターおよびスレーブコピーを比較して相違を手動で訂正する準備を整えてから、レプリケーションを再開するようにしてください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-shutdowns"></a>17.4.1.19 レプリケーションとマスターまたはスレーブシャットダウン</h4></div></div></div><a class="indexterm" name="idm139979046017408"></a><a class="indexterm" name="idm139979046015248"></a><a class="indexterm" name="idm139979046013184"></a><a class="indexterm" name="idm139979046011120"></a><p>
        マスターサーバーをシャットダウンしてあとで再起動することは安全です。スレーブがマスターへの接続を失った場合、スレーブはすぐに再接続しようとし、それが失敗した場合は定期的に再試行します。デフォルトでは 60 秒ごとに再試行します。これは、<code class="literal">CHANGE MASTER TO</code> ステートメントで変更できます。スレーブはネットワーク接続停止にも対応できます。ただし、スレーブは、マスターからのデータを <code class="literal">slave_net_timeout</code> 秒間受け取らなかったあとにのみ、ネットワーク停止を認識します。停止時間が短い場合は、<code class="literal">slave_net_timeout</code> を減らすことをお勧めします。<a class="xref" href="server-administration.html#server-system-variables" title="5.1.4 サーバーシステム変数">セクション5.1.4「サーバーシステム変数」</a>を参照してください。
      </p><p>
        マスター側で予期しないシャットダウン (たとえば、クラッシュ) が発生すると、マスターバイナリログファイルがフラッシュされていないため、マスターバイナリログにスレーブが読み取った最新の位置より前の最終位置が記録される可能性があります。このため、マスターが復帰したときにスレーブを複製できないことがあります。マスター <code class="filename">my.cnf</code> ファイルで <code class="literal">sync_binlog=1</code> を設定することは、マスターがそのバイナリログをフラッシュする頻度が上がることになるため、この問題を最小化するのに役立ちます。
      </p><p>
        スレーブをクリーンにシャットダウンすることは、中断した場所が追跡されるため安全です。ただし、スレーブが一時テーブルを開いていないことを考慮してください。<a class="xref" href="replication.html#replication-features-temptables" title="17.4.1.22 レプリケーションと一時テーブル">セクション17.4.1.22「レプリケーションと一時テーブル」</a>を参照してください。予期しないシャットダウンにより問題が発生する場合があります (特に、ディスクキャッシュがディスクにフラッシュされない状態で問題が発生した場合)。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            トランザクションについては、スレーブはコミットしてから <code class="filename">relay-log.info</code> を更新します。これら 2 つの操作の間にクラッシュが発生した場合、リレーログ処理はファイルが示す情報より先に進み、スレーブは再起動されたあとにリレーログ内の最後のトランザクションからイベントを再実行します。
          </p></li><li class="listitem"><p>
            同様な問題は、スレーブが <code class="filename">relay-log.info</code> を更新したけれども、その書き込みがディスクにフラッシュされる前にサーバーホストがクラッシュした場合にも発生する可能性があります。これが発生する可能性を最小化するには、スレーブ <code class="filename">my.cnf</code> ファイルに <code class="literal">sync_relay_log_info=1</code> を設定してください。<code class="literal">sync_relay_log_info</code> のデフォルト値は 0 で、この場合はディスクへの書き込みは強制されません。サーバーはオペレーティングシステムに依存して随時ファイルをフラッシュします。
          </p></li></ul></div><p>
        システムのこのような問題に対する耐障害性は、優れた無停電電源があると大幅に向上します。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-max-allowed-packet"></a>17.4.1.20 レプリケーションと max_allowed_packet</h4></div></div></div><a class="indexterm" name="idm139979045989504"></a><a class="indexterm" name="idm139979045987344"></a><p>
        <code class="literal">max_allowed_packet</code> は、MySQL サーバーとクライアント (レプリケーションスレーブを含みます) の間の単一メッセージのサイズに上限を設定します。大きなカラム値 (<code class="literal">TEXT</code> または <code class="literal">BLOB</code> カラムで見つかる場合があります) を複製していて、<code class="literal">max_allowed_packet</code> がマスター上で小さすぎる場合は、マスターがエラーで失敗し、スレーブは I/O スレッドをシャットダウンします。<code class="literal">max_allowed_packet</code> がスレーブ上で小さすぎる場合も、スレーブは I/O スレッドを停止します。
      </p><p>
        行ベースレプリケーションは現在、更新された行のすべてのカラムとカラム値をマスターからスレーブに送信します (更新で実際には変更されなかったカラムの値を含みます)。これは、行ベースレプリケーションを使用して大きなカラム値を複製するときに、複製されるテーブル内でもっとも大きい行を格納できるだけの大きさに <code class="literal">max_allowed_packet</code> を設定するように気をつける必要があります (更新だけを複製したり、比較的小さい値だけを挿入したりする場合でも)。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-memory"></a>17.4.1.21 レプリケーションと MEMORY テーブル</h4></div></div></div><a class="indexterm" name="idm139979045975344"></a><a class="indexterm" name="idm139979045973184"></a><p>
        マスターサーバーがシャットダウンして再起動すると、その <code class="literal">MEMORY</code> テーブルは空になります。マスターはこの影響をスレーブに複製するために、起動後に所定の <code class="literal">MEMORY</code> テーブルを最初に使用するときに、空にすべきテーブルの <code class="literal">DELETE</code> ステートメントをバイナリログに書き込むことで、そのテーブルを空にする必要があることをスレーブに通知するイベントのログを記録します。
      </p><p>
        スレーブサーバーがシャットダウンして再起動すると、その <code class="literal">MEMORY</code> テーブルは空になります。これによってスレーブはマスターとの同期を失うため、ほかの障害が発生したりスレーブが停止したりすることがあります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            マスターから受け取る行形式更新および削除が<code class="literal">「'<em class="replaceable"><code>memory_table</code></em>' にレコードが見つかりません」</code>で失敗する場合があります。
          </p></li><li class="listitem"><p>
            <code class="literal">INSERT INTO ... SELECT FROM <em class="replaceable"><code>memory_table</code></em></code> などのステートメントがマスターおよびスレーブ上で異なる行セットを挿入することがあります。
          </p></li></ul></div><p>
        <code class="literal">MEMORY</code> テーブルを複製するスレーブを再起動する安全な方法は、最初にマスター上の <code class="literal">MEMORY</code> テーブルからのすべての行をドロップまたは削除して、これらの変更がスレーブに複製されるまで待つことです。すると、スレーブを再起動しても安全です。
      </p><p>
        場合によっては、別の再起動方法を適用できることがあります。<code class="literal">binlog_format=ROW</code> のときは、スレーブを再起動する前に <code class="literal">slave_exec_mode=IDEMPOTENT</code> を設定すれば、スレーブの停止を回避できます。これによってスレーブは複製を継続できますが、<code class="literal">MEMORY</code> テーブルは依然としてマスター上のものと異なります。アプリケーションロジックが <code class="literal">MEMORY</code> テーブルの内容を安全に失うことができるようなものである場合 (たとえば、<code class="literal">MEMORY</code> テーブルがキャッシュに使用されている場合) は、これでかまいません。<code class="literal">slave_exec_mode=IDEMPOTENT</code> がすべてのテーブルにグローバルに適用されるため、<code class="literal">MEMORY</code> でないテーブルでほかのレプリケーションエラーを隠すことができます。
      </p><p>
        (上記の方法は MySQL Cluster には適用されません。<code class="literal">slave_exec_mode</code> は常に <code class="literal">IDEMPOTENT</code> で、変更できません。)
      </p><p>
        <code class="literal">MEMORY</code> テーブルのサイズは、<code class="literal">max_heap_table_size</code> システム変数の値によって制限され、これは複製されません (<a class="xref" href="replication.html#replication-features-variables" title="17.4.1.34 レプリケーションと変数">セクション17.4.1.34「レプリケーションと変数」</a>を参照してください)。<code class="literal">max_heap_table_size</code> での変更は、変更後に <code class="literal">ALTER TABLE ... ENGINE = MEMORY</code> または <code class="literal">TRUNCATE TABLE</code> を使用して作成または更新された <code class="literal">MEMORY</code> テーブルに、またはサーバー再起動後にすべての <code class="literal">MEMORY</code> テーブルに反映されます。この変数の値をマスター上で増やしスレーブ上でそうしない場合は、マスター上のテーブルがスレーブ上のものより大きくなることができるため、挿入がマスター上で成功するけれどもスレーブ上で <span class="errortext">Table is full</span>エラーで失敗します:これは既知の問題です (Bug #48666)。このような場合、マスター上と同様にスレーブ上で <code class="literal">max_heap_table_size</code> のグローバル値を設定してから、レプリケーションを再開する必要があります。また、新しい値がそれぞれで完全 (グローバル) に反映されることを保証するために、マスターとスレーブの両方の MySQL サーバーを再起動することをお勧めします。
      </p><p>
        <code class="literal">MEMORY</code> テーブルに関する詳細は、<a class="xref" href="storage-engines.html#memory-storage-engine" title="15.3 MEMORY ストレージエンジン">セクション15.3「MEMORY ストレージエンジン」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-temptables"></a>17.4.1.22 レプリケーションと一時テーブル</h4></div></div></div><a class="indexterm" name="idm139979045931376"></a><a class="indexterm" name="idm139979045929248"></a><a class="indexterm" name="idm139979045927136"></a><p>
        <code class="literal">binlog_format=ROW</code> のときは次の段落の説明は適用されません。なぜなら、その場合は一時テーブルは複製されないためです。これは、スレーブによる計画外シャットダウンの場合、スレーブ上の一時テーブルが失われることがないことを意味します。このセクションの残りは、ステートメントベースまたは混合形式レプリケーションを使用するときにのみ適用されます。ステートメントベース形式を使用して安全にログを記録できる一時テーブルを使用するステートメントでは、<code class="literal">binlog_format</code> が <code class="literal">STATEMENT</code> または <code class="literal">MIXED</code> のときは常に、スレーブ上で複製された一時テーブルを失うことが問題となる可能性があります。行ベースレプリケーションと一時テーブルの詳細は、<a class="xref" href="replication.html#replication-rbr-usage-temptables" title="一時テーブルの行ベースロギング">一時テーブルの行ベースロギング</a>を参照してください。
      </p><p><b>一時テーブルを使用するときの安全なスレーブシャットダウン </b>
          スレーブサーバーを停止する場合 (スレーブスレッドだけではなく)、およびスレーブ上でまだ実行されていない更新で使用するために開いている一時テーブルを複製した場合を除いて、一時テーブルは複製されます。スレーブサーバーを停止した場合、これらの更新が必要とする一時テーブルは、スレーブが再起動されたときに使用できなくなっています。この問題を回避するために、一時テーブルが開いている間はスレーブをシャットダウンしないでください。代わりに、次の手順を使用してください。
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            <code class="literal">STOP SLAVE SQL_THREAD</code> ステートメントを発行します。
          </p></li><li class="listitem"><p>
            <code class="literal">SHOW STATUS</code> を使用して <code class="literal">Slave_open_temp_tables</code> 変数の値を確認します。
          </p></li><li class="listitem"><p>
            値が 0 でない場合は、スレーブ SQL スレッドを <code class="literal">START SLAVE SQL_THREAD</code> で再起動してから、あとで手順を繰り返します。
          </p></li><li class="listitem"><p>
            値が 0 のときは、<span class="command"><strong>mysqladmin shutdown</strong></span> コマンドを発行してスレーブを停止します。
          </p></li></ol></div><p><b>一時テーブルとレプリケーションオプション </b>
          デフォルトでは、すべての一時テーブルが複製されます。これは、対応する <code class="option">--replicate-do-db</code>、<code class="option">--replicate-do-table</code>、または <code class="option">--replicate-wild-do-table</code> オプションが有効かどうかに関係なく発生します。ただし、<code class="option">--replicate-ignore-table</code> および <code class="option">--replicate-wild-ignore-table</code> オプションは一時テーブルで受け付けられます。
        </p><p>
        ステートメントベースまたは混合形式レプリケーションを使用するときに推奨される操作は、複製したくない一時テーブルに名前を付けるためだけに使用するプリフィクスを指定してから、そのプリフィクスを照合するために <code class="option">--replicate-wild-ignore-table</code> オプションを使用することです。たとえば、このようなすべてのテーブルに <code class="literal">norep</code> で始まる名前を付けてから (たとえば、<code class="literal">norepmytable</code>、<code class="literal">norepyourtable</code> など)、テーブルが複製されることを回避するために <code class="option">--replicate-wild-ignore-table=norep%</code> を使用します。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-mysqldb"></a>17.4.1.23 mysql システムデータベースのレプリケーション</h4></div></div></div><a class="indexterm" name="idm139979045895392"></a><a class="indexterm" name="idm139979045893200"></a><a class="indexterm" name="idm139979045891072"></a><a class="indexterm" name="idm139979045889008"></a><p>
        <code class="literal">mysql</code> データベース内のテーブルに行われたデータ変更ステートメントは、<code class="literal">binlog_format</code> の値に従って複製されます。この値が <code class="literal">MIXED</code> の場合、これらのステートメントは行ベース形式を使用して複製されます。ただし、通常はこの情報を間接的に更新するステートメント (<code class="literal">GRANT</code>、<code class="literal">REVOKE</code>、およびトリガー、ストアドルーチン、ビューを操作するステートメントなど) は、ステートメントベースレプリケーションを使用してスレーブに複製されます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-optimizer"></a>17.4.1.24 レプリケーションとクエリーオプティマイザ</h4></div></div></div><a class="indexterm" name="idm139979045880016"></a><a class="indexterm" name="idm139979045877824"></a><p>
        データ変更が非決定的であるような方法でステートメントが書き込まれた場合、マスターおよびスレーブ上のデータが違ってくる可能性があります。つまり、クエリーオプティマイザの出番です。(一般的に、これはレプリケーション以外であっても良い行動ではありません。)非決定的なステートメントの例には、<code class="literal">ORDER BY</code> 句なしの <code class="literal">LIMIT</code> を使用する <code class="literal">DELETE</code> または <code class="literal">UPDATE</code> ステートメントが含まれます。これらの説明の詳細は、<a class="xref" href="replication.html#replication-features-limit" title="17.4.1.16 レプリケーションと LIMIT">セクション17.4.1.16「レプリケーションと LIMIT」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-reserved-words"></a>17.4.1.25 レプリケーションと予約語</h4></div></div></div><a class="indexterm" name="idm139979045869200"></a><a class="indexterm" name="idm139979045867024"></a><p>
        古いマスターから新しいスレーブに複製しようとするとき、およびスレーブで実行中の新しい MySQL バージョンで予約語である識別子をマスター上で使用するときに、問題が発生する可能性があります。たとえば、4.1 以降のスレーブに複製している 4.0 マスター上で名前が <code class="literal">current_user</code> のテーブルカラムを使用しているときです。<code class="literal">CURRENT_USER</code> は MySQL 4.1 以降で予約語であるためです。このような場合、レプリケーションはエラー 1064 <span class="errortext">You have an error in your SQL syntax...</span> で失敗する可能性があります <span class="emphasis"><em>(予約語を使用して名前が付けられたデータベースまたはテーブル、または予約語を使用して名前が付けられたカラムを持つテーブルが、レプリケーションから除外されていても)</em></span>。これは、各 SQL イベントが実行前にスレーブによって解析される必要があるため、スレーブはどのデータベースオブジェクトが影響されるかがわかるという事実によります。スレーブは、イベントが解析されたあとにのみ、<code class="option">--replicate-do-db</code>、<code class="option">--replicate-do-table</code>, <code class="option">--replicate-ignore-db</code>、および <code class="option">--replicate-ignore-table</code> で定義されたフィルタリングルールを適用できます。
      </p><p>
        スレーブが予約語と見なす、マスター上のデータベース、テーブル、またはカラム名の問題を回避するには、次のいずれかを行ってください。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            マスター上で 1 つまたは複数の <code class="literal">ALTER TABLE</code> ステートメントを使用して、これらの名前がスレーブ上で予約語と見なされるデータベースオブジェクトの名前を変更するか、古い名前を使用する SQL ステートメントを変更して代わりに新しい名前を使用してください。
          </p></li><li class="listitem"><p>
            これらのデータベースオブジェクト名を使用する SQL ステートメントで、それらの名前をバッククォート文字 (<code class="literal">`</code>) で囲まれた識別子として書いてください。
          </p></li></ul></div><p>
        MySQL バージョン別の予約語の一覧については、「<em class="citetitle">MySQL Server Version Reference</em>」の「<a class="ulink" href="http://dev.mysql.com/doc/mysqld-version-reference/en/mysqld-version-reference-optvar.html" target="_top">Reserved Words</a>」を参照してください。識別子を囲むルールについては、<a class="xref" href="language-structure.html#identifiers" title="9.2 スキーマオブジェクト名">セクション9.2「スキーマオブジェクト名」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-slaveerrors"></a>17.4.1.26 レプリケーション中のスレーブエラー</h4></div></div></div><a class="indexterm" name="idm139979045848000"></a><a class="indexterm" name="idm139979045845872"></a><a class="indexterm" name="idm139979045843808"></a><a class="indexterm" name="idm139979045841712"></a><p>
        ステートメントがマスターとスレーブの両方で同じエラー (同じエラーコード) を返した場合、エラーログは記録されますが、レプリケーションは継続します。
      </p><p>
        ステートメントがマスターとスレーブで異なるエラーを返した場合、スレーブ SQL スレッドは終了し、スレーブはそのエラーログにメッセージを書き込み、データベース管理者がそのエラーについて何をするかを決めるまで待ちます。これには、ステートメントがマスターまたはスレーブ上で (両方ではなく) エラーを返した場合が含まれます。この問題に対処するには、手動でスレーブに接続して問題の原因を判断してください。これには、<code class="literal">SHOW SLAVE STATUS</code> が役立ちます。それから問題を解決して <code class="literal">START SLAVE</code> を実行してください。たとえば、スレーブを再起動する前に、存在しないテーブルの作成が必要な場合があります。
      </p><p>
        このエラーコード検証動作が望ましくない場合は、<code class="option">--slave-skip-errors</code> オプションでエラーの一部またはすべてを隠す (無視する) ことができます。
      </p><p>
        <code class="literal">MyISAM</code> などの非トランザクションストレージエンジンの場合、テーブルを不完全に更新してエラーコードを返すだけのステートメントが存在する場合があります。これはたとえば、1 つの行がキー制約に違反する複数行挿入で、または長い更新ステートメントが一部の行を更新したあとに強制終了された場合に発生する可能性があります。これがマスター上で発生した場合は、スレーブはステートメントの実行を予期しますが、同じエラーコードで終了します。そうしない場合は、スレーブ SQL スレッドはすでに説明したように停止します。
      </p><p>
        マスターおよびスレーブ上で異なるストレージエンジンを使用するテーブル間で複製する場合、同じステートメントが、一方のバージョンのテーブルに実行し、もう一方で実行しないときに異なるエラーを返したり、一方のバージョンのテーブルでエラーが発生し、もう一方では発生しなかったりすることがあることに留意してください。たとえば、<code class="literal">MyISAM</code> は外部キー制約を無視するため、マスター上の <code class="literal">InnoDB</code> テーブルにアクセスする <code class="literal">INSERT</code> または <code class="literal">UPDATE</code> ステートメントで外部キー違反が発生することがあっても、スレーブ上の <code class="literal">MyISAM</code> バージョンの同じテーブルで実行された同じステートメントはこのようなエラーを返さずにレプリケーションが停止します。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-server-side-help"></a>17.4.1.27 サーバー側ヘルプテーブルのレプリケーション</h4></div></div></div><p>
        サーバーは、<code class="literal">HELP</code> ステートメントの情報を格納するテーブルを <code class="literal">mysql</code> データベース内で保持します (<a class="xref" href="sql-syntax.html#help" title="13.8.3 HELP 構文">セクション13.8.3「HELP 構文」</a>を参照してください)。これらのテーブルは、<a class="xref" href="server-administration.html#server-side-help-support" title="5.1.10 サーバー側のヘルプ">セクション5.1.10「サーバー側のヘルプ」</a>で説明したとおり、手動でロードできます。
      </p><p>
        ヘルプテーブル内容は MySQL リファレンスマニュアルから抽出されます。各 MySQL リリースシリーズに固有のマニュアルバージョンがあるため、ヘルプの内容も各シリーズに固有です。一般的には、サーバーバージョンに一致するバージョンのヘルプ内容をロードしてください。これはレプリケーションに密接な関係があります。たとえば、MySQL 5.5 マスターサーバーには MySQL 5.5 ヘルプ内容をロードしますが、5.6 ヘルプ内容がより適している MySQL 5.6 スレーブサーバーには必ずしもその内容を複製する必要はありません。
      </p><p>
        このセクションでは、サーバーがレプリケーションに参加するときに、ヘルプテーブル内容の更新をどのように管理するかについて説明します。サーバーバージョンがこのタスクの 1 つの要因です。もう 1 つは、ヘルプテーブル構造がマスターとスレーブで異なる場合があることです。
      </p><p>
        ヘルプ内容が <code class="filename">fill_help_tables.sql</code> という名前のファイルに格納されているとします。MySQL 配布では、このファイルは <code class="filename">share</code> または <code class="literal">share/mysql</code> ディレクトリの下にあり、最新版はいつでも <a class="ulink" href="http://dev.mysql.com/doc/index-other.html" target="_top">http://dev.mysql.com/doc/index-other.html</a>からダウンロードできます。
      </p><p>
        ヘルプテーブルをアップグレードするには、次の手順を使用ます。ここで説明する <span class="command"><strong>mysql</strong></span> コマンドの接続パラメータは示されていません。どのような場合でも、<code class="literal">mysql</code> データベース内のテーブルを変更するための権限を持つ、<code class="literal">root</code> などのアカウントを使用してサーバーに接続してください。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            <span class="command"><strong>mysql_upgrade</strong></span> をまずスレーブ上で実行してからマスター上で実行することで、サーバーをアップグレードします。スレーブを最初にアップグレードするというのが一般原則です。
          </p></li><li class="listitem"><p>
            ヘルプテーブル内容をマスターからそのスレーブに複製するかどうかを決めます。しない場合は、マスターと各スレーブに個別に内容をロードします。または、マスターおよびそのスレーブ上のヘルプテーブル構造の非互換を確認し、ある場合は解決してから、内容をマスターにロードしてそこからスレーブに複製します。
          </p><p>
            ヘルプテーブル内容をロードするためのこれらの 2 つの方法をこれから詳しく説明します。
          </p></li></ol></div><h5><a name="idm139979045805552"></a>スレーブへのレプリケーションなしでヘルプテーブル内容をロードする</h5><p>
        ヘルプテーブル内容をレプリケーションなしでロードするには、サーバーバージョンに適した内容を含む <code class="filename">fill_help_tables.sql</code> ファイルを使用して、マスターおよび各スレーブで個々に次のコマンドを実行します (コマンドは 1 行に入力します)。
      </p><pre class="programlisting">
mysql --init-command="SET sql_log_bin=0"
  mysql &lt; fill_help_tables.sql
</pre><p>
        レプリケーショントポロジ内でスレーブがほかのスレーブのマスターとしても動作している場合は、各サーバー (スレーブを含む) に <code class="option">--init-command</code> オプションを使用します。<code class="literal">SET</code> ステートメントはバイナリロギングを抑止します。アップグレードする各サーバーでコマンドが実行されると、完了です。
      </p><h5><a name="idm139979045799600"></a>スレーブへのレプリケーションありでヘルプテーブル内容をロードする</h5><p>
        ヘルプテーブル内容を複製しない場合は、マスターとそのスレーブ間のヘルプテーブル非互換を確認します。<code class="literal">help_category</code> および <code class="literal">help_topic</code> テーブル内の <code class="literal">url</code> カラムは、最初は <code class="literal">CHAR(128)</code> でしたが、長い URL に対応するために新しい MySQL バージョンでは <code class="literal">TEXT</code> です。ヘルプテーブル構造を確認するには、次のステートメントを使用します。
      </p><pre class="programlisting">
SELECT TABLE_NAME, COLUMN_NAME, COLUMN_TYPE
FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_SCHEMA = 'mysql'
AND COLUMN_NAME = 'url';
</pre><p>
        古い構造のテーブルの場合、ステートメントは次の結果を返します。
      </p><pre class="programlisting">
+---------------+-------------+-------------+
| TABLE_NAME    | COLUMN_NAME | COLUMN_TYPE |
+---------------+-------------+-------------+
| help_category | url         | char(128)   |
| help_topic    | url         | char(128)   |
+---------------+-------------+-------------+
</pre><p>
        新しい構造のテーブルの場合、ステートメントは次の結果を返します。
      </p><pre class="programlisting">
+---------------+-------------+-------------+
| TABLE_NAME    | COLUMN_NAME | COLUMN_TYPE |
+---------------+-------------+-------------+
| help_category | url         | text        |
| help_topic    | url         | text        |
+---------------+-------------+-------------+
</pre><p>
        マスターとスレーブの両方が古い構造の場合、または両方が新しい構造の場合は、互換であるため、マスターで次のコマンドを実行することでヘルプテーブル内容を複製できます。
      </p><pre class="programlisting">
mysql mysql &lt; fill_help_tables.sql
</pre><p>
        テーブル内容はマスターにロードされてから、スレーブに複製されます。
      </p><p>
        マスターとスレーブのヘルプテーブルが非互換の場合は (一方のサーバーが古い構造で、もう一方が新しい構造)、ヘルプテーブル内容を最終的に複製しないか、または内容を複製できるようにテーブル構造を互換にするかを選択できます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            最終的に内容を複製しないことを決めた場合、すでに説明したように、<code class="option">--init-command</code> オプション付きの <span class="command"><strong>mysql</strong></span> を使用してマスターとスレーブを個々にアップグレードします。
          </p></li><li class="listitem"><p>
            そうではなく、テーブル構造に互換することを決めた場合は、サーバー上の古い構造のテーブルをアップグレードします。マスターサーバーのテーブル構造が古いとします。次のステートメントを実行することで、テーブルを新しい構造に手動でアップグレードします (すでに新しい構造のスレーブに変更が複製されることを回避するために、ここではバイナリロギングが無効になっています)。
          </p><pre class="programlisting">
SET sql_log_bin=0;
ALTER TABLE mysql.help_category ALTER COLUMN url TEXT;
ALTER TABLE mysql.help_topic ALTER COLUMN url TEXT;
</pre><p>
            次に、マスターで次のコマンドを実行します。
          </p><pre class="programlisting">
mysql mysql &lt; fill_help_tables.sql
</pre><p>
            テーブル内容はマスターにロードされてから、スレーブに複製されます。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-sql-mode"></a>17.4.1.28 レプリケーションとサーバー SQL モード</h4></div></div></div><a class="indexterm" name="idm139979045778400"></a><a class="indexterm" name="idm139979045776272"></a><a class="indexterm" name="idm139979045774192"></a><a class="indexterm" name="idm139979045772096"></a><a class="indexterm" name="idm139979045770000"></a><a class="indexterm" name="idm139979045767920"></a><p>
        マスターとスレーブで異なるサーバー SQL モード設定を使用すると、同じ <code class="literal">INSERT</code> ステートメントがマスターとスレーブで異なる方法で処理され、マスターとスレーブが同期を失う場合があります。最適な結果を得るために、マスターとスレーブとで常に同じサーバー SQL モードを使用してください。このアドバイスは、ステートメントベースまたは行ベースのどちらのレプリケーションを使用しているかにかかわらず、適用されます。
      </p><p>
        パーティション化されたテーブルを複製する場合、マスターとスレーブで異なる SQL モードを使用すると、問題が発生する可能性が高くなります。少なくとも、所定のテーブルのマスターおよびスレーブコピー間で、パーティションへのデータ配分が違ってくる可能性が高くなります。マスター上で成功するパーティション化されたテーブルへの挿入が、スレーブ上で失敗する可能性もあります。
      </p><p>
        詳細は、<a class="xref" href="server-administration.html#sql-mode" title="5.1.7 サーバー SQL モード">セクション5.1.7「サーバー SQL モード」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-timeout"></a>17.4.1.29 レプリケーション再試行とタイムアウト</h4></div></div></div><a class="indexterm" name="idm139979045760176"></a><a class="indexterm" name="idm139979045758048"></a><a class="indexterm" name="idm139979045755952"></a><a class="indexterm" name="idm139979045754544"></a><a class="indexterm" name="idm139979045752480"></a><p>
        グローバルシステム変数 <code class="literal">slave_transaction_retries</code> は、次のようにレプリケーションに影響します: <code class="literal">InnoDB</code> デッドロックが原因で、または <code class="literal">InnoDB</code> <code class="literal">innodb_lock_wait_timeout</code> 値あるいは <code class="literal">NDB</code> <code class="literal">TransactionDeadlockDetectionTimeout</code> または <code class="literal">TransactionInactiveTimeout</code> 値を越えたことが原因で、スレーブ SQL スレッドがトランザクションの実行に失敗した場合、スレーブはトランザクションを <code class="literal">slave_transaction_retries</code> 回自動的に再試行してからエラーで停止します。デフォルト値は 10 です。合計再試行回数は <code class="literal">SHOW STATUS</code> の出力で確認できます。<a class="xref" href="server-administration.html#server-status-variables" title="5.1.6 サーバーステータス変数">セクション5.1.6「サーバーステータス変数」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-timezone"></a>17.4.1.30 レプリケーションとタイムゾーン</h4></div></div></div><a class="indexterm" name="idm139979045740160"></a><a class="indexterm" name="idm139979045738032"></a><p>
        デフォルトでは、マスターおよびスレーブサーバーは、それらが同じタイムゾーンであることを想定します。タイムゾーンが異なるサーバー間で複製する場合、マスターとスレーブの両方でタイムゾーンを設定する必要があります。そうでない場合は、<code class="literal">NOW()</code> または <code class="literal">FROM_UNIXTIME()</code> 関数を使用するステートメントなど、マスター上のローカル時間に依存するステートメントが適切に複製されません。MySQL サーバーが動作するタイムゾーンは、<code class="filename">mysqld_safe</code> スクリプトの <code class="option">--timezone=<em class="replaceable"><code>timezone_name</code></em></code> オプションを使用するか、<code class="literal">TZ</code> 環境変数を設定することで、設定します。<a class="xref" href="replication.html#replication-features-functions" title="17.4.1.15 レプリケーションとシステム関数">セクション17.4.1.15「レプリケーションとシステム関数」</a>も参照してください。
      </p><p>
        マスターが MySQL 4.1 以前の場合はさらに、マスターとスレーブの両方が同じデフォルト接続タイムゾーンを使用するべきです。つまり、<code class="option">--default-time-zone</code> パラメータをマスターとスレーブの両方で同じ値にしてください。
      </p><p>
        <code class="literal">CONVERT_TZ(...,...,@@session.time_zone)</code> は、マスターとスレーブの両方が MySQL 5.0.4 以降を実行している場合にのみ、正しく複製されます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-transactions"></a>17.4.1.31 レプリケーションとトランザクション</h4></div></div></div><a class="indexterm" name="idm139979045724640"></a><a class="indexterm" name="idm139979045722480"></a><p><b>同じトランザクション内にトランザクションおよび非トランザクションステートメントを混在させる </b>
          一般的に、レプリケーション環境でトランザクションおよび非トランザクションテーブルの両方を更新するトランザクションは避けるべきです。トランザクション (または一時) および非トランザクションテーブルの両方にアクセスしてそれらに書き込むステートメントを使用することも避けるべきです。
        </p><p>
        MySQL 5.5.2 以降では、サーバーはバイナリロギングに次のルールを使用します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            トランザクション内の最初のステートメントが非トランザクションである場合、それらはすぐにバイナリログに書き込まれます。トランザクション内の残りのステートメントはキャッシュされ、トランザクションがコミットされるまでバイナリログに書き込まれません。(トランザクションがロールバックされた場合、キャッシュされたステートメントは、ロールバックできない非トランザクション変更を行う場合にのみバイナリログに書き込まれます。それ以外の場合は、それらは破棄されます。)
          </p></li><li class="listitem"><p>
            ステートメントベースロギングの場合、非トランザクションステートメントのロギングは <code class="literal">binlog_direct_non_transactional_updates</code> システム変数によって影響されます。この変数が <code class="literal">OFF</code>の場合 (デフォルト)、ロギングは上記のとおりになります。この変数が <code class="literal">ON</code> の場合、非トランザクションステートメントがトランザクション内のどこで発生しても (最初の非トランザクションステートメントだけではありません)、ただちにロギングが発生します。ほかのステートメントはトランザクションキャッシュに保持され、トランザクションがコミットしたときにログが記録されます。<code class="literal">binlog_direct_non_transactional_updates</code> は行形式または混合形式バイナリロギングに影響しません。
          </p></li></ul></div><p><a name="replication-features-transactions-trx-nontrx-mixed"></a><b>トランザクション、非トランザクション、および混合ステートメント </b><a class="indexterm" name="idm139979045708544"></a>
          これらのルールを適用する場合、サーバーは、非トランザクションテーブルだけを変更する場合にはステートメントを非トランザクションと見なし、トランザクションテーブルだけを変更する場合にはトランザクションと見なします。MySQL 5.6 では、非トランザクションおよびトランザクションテーブルの両方を参照し、使用される<span class="emphasis"><em>すべての</em></span>テーブルを更新するステートメントは、<span class="quote">「<span class="quote">混合</span>」</span> ステートメントと見なされます。(以前の MySQL リリースシリーズでは、非トランザクションおよびトランザクションテーブルの両方を変更するステートメントが、混合と見なされていました。)混合ステートメントは、トランザクションステートメントと同様に、キャッシュされ、トランザクションがコミットするときにログが記録されます。
        </p><p>
        トランザクションテーブルを更新する混合ステートメントは、次のアクションのいずれかを実行する場合も、安全ではないと見なされます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            トランザクションテーブルを更新または読み取る
          </p></li><li class="listitem"><p>
            非トランザクションテーブルを読み取り、トランザクション分離レベルが REPEATABLE_READ 未満
          </p></li></ul></div><p>
        トランザクション内でトランザクションテーブル更新に続く混合ステートメントは、次のアクションのいずれかを実行する場合、安全ではないと見なされます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            テーブルを更新し、一時テーブルから読み取る
          </p></li><li class="listitem"><p>
            非トランザクションテーブルを更新し、binlog_direct_non_trans_update が OFF
          </p></li></ul></div><p>
        詳細については、<a class="xref" href="replication.html#replication-rbr-safe-unsafe" title="17.1.2.3 バイナリロギングでの安全および安全でないステートメントの判断">セクション17.1.2.3「バイナリロギングでの安全および安全でないステートメントの判断」</a>を参照してください。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          混合ステートメントは混合バイナリロギング形式とは関係ありません。
        </p></div><p>
        トランザクション内でトランザクションおよび非トランザクションテーブルへの更新が混在している状況で、バイナリログ内のステートメントの順序は正しく、必要なすべてのステートメントがバイナリログに書き込まれます (<code class="literal">ROLLBACK</code> の場合でも)。ただし、最初の接続トランザクションが完了する前に 2 番目の接続が非トランザクションテーブルを更新するときは、ステートメントログが記録される順序が乱れる場合があります。最初の接続によって実行されているトランザクションの状態にかかわらず、2 番目の接続更新が実行された直後に書き込まれるためです。
      </p><p><b>マスターとスレーブで異なるストレージエンジンを使用する </b>
          スレーブ上の非トランザクションテーブルを使用してマスター上のトランザクションテーブルを複製できます。たとえば、<code class="literal">InnoDB</code> マスターテーブルを <code class="literal">MyISAM</code> スレーブテーブルとして複製できます。ただし、これを行う場合、スレーブが <code class="literal">BEGIN</code> ブロックの始めで再起動したために <code class="literal">BEGIN</code> ... <code class="literal">COMMIT</code> ブロックの途中でスレーブが停止した場合に問題が発生します。
        </p><p>
        MySQL 5.6 では、マスター上の <code class="literal">MyISAM</code> テーブルからスレーブ上のトランザクションテーブル (<code class="literal">InnoDB</code> ストレージエンジンを使用するテーブルなど) にトランザクションを複製することも安全です。このような場合 (MySQL 5.5.0 以降)、マスター上で発行された <code class="literal">AUTOCOMMIT=1</code> ステートメントが複製されて、スレーブ上で <code class="literal">AUTOCOMMIT</code> モードが適用されます。
      </p><p>
        スレーブのストレージエンジンタイプが非トランザクションの場合、トランザクションおよび非トランザクションテーブルへの更新が混在するマスター上のトランザクションは、マスタートランザクションテーブルとスレーブ非トランザクションテーブルの間でデータの不整合が発生する可能性があるため、避けるべきです。つまり、このようなトランザクションはレプリケーションの同期を失って、マスターストレージエンジン独自の動作になる可能性があります。現在のところ、MySQL はこれについて警告を発行しないため、トランザクションテーブルをマスターからスレーブ上の非トランザクションテーブルに複製するときは十分に気を付けるようにしてください。
      </p><p><b>トランザクション内でバイナリロギング形式を変更する </b>
          MySQL 5.5.3 以降では、トランザクションが進行中のときは <code class="literal">binlog_format</code> システム変数は読み取り専用です。(Bug #47863)
        </p><p>
        各トランザクション (<code class="literal">autocommit</code> トランザクションを含む) は、<code class="literal">BEGIN</code> ステートメントで始まり、<code class="literal">COMMIT</code> または <code class="literal">ROLLBACK</code> ステートメントで終わるかのように、バイナリログに記録されます。MySQL 5.6 では、この真実は、非トランザクションストレージエンジン (<code class="literal">MyISAM</code> など) を使用するテーブルに影響するステートメントにも適用されます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-triggers"></a>17.4.1.32 レプリケーションとトリガー</h4></div></div></div><a class="indexterm" name="idm139979045668080"></a><a class="indexterm" name="idm139979045665904"></a><p>
        ステートメントベースレプリケーションでは、マスター上で実行されたトリガーはスレーブでも実行されます。行ベースレプリケーションでは、マスター上で実行されたトリガーはスレーブ上で実行されません。代わりに、トリガー実行によって発生するマスター上の行変更は複製され、スレーブ上で適用されます。
      </p><p>
        この動作は設計によります。行ベースレプリケーション時に、スレーブがトリガーおよびそれらによって発生する行変更を適用した場合、変更は実際にはスレーブ上で 2 回適用されるため、マスターとスレーブでデータが違ってきます。
      </p><p>
        マスターとスレーブの両方でトリガーを実行したい場合 (おそらく、マスターとスレーブでトリガーが違うため)、ステートメントベースレプリケーションを使用する必要があります。ただし、スレーブ側トリガーを有効にするために、ステートメントベースレプリケーションを排他的に使用する必要はありません。この効果が必要なステートメントでのみステートメントベースレプリケーションに切り替え、残りの時間は行ベースレプリケーションを使用することで十分です。
      </p><p>
        <code class="literal">AUTO_INCREMENT</code> カラムを更新するトリガー (または関数) を呼び出すステートメントは、ステートメントベースレプリケーションを使用して正しく複製されません。MySQL 5.6 はこのようなステートメントを安全でないとマークします。(Bug #45677)
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-truncate"></a>17.4.1.33 レプリケーションと TRUNCATE TABLE</h4></div></div></div><a class="indexterm" name="idm139979045657072"></a><a class="indexterm" name="idm139979045654944"></a><p>
        <code class="literal">TRUNCATE TABLE</code> は通常は DML ステートメントと見なされるため、バイナリロギングモードが <code class="literal">ROW</code> または <code class="literal">MIXED</code> のときは行ベース形式を使用してログが記録されて複製されることが予想されます。しかしこのことが、<code class="literal">InnoDB</code> などのトランザクションストレージエンジン (トランザクション分離レベルが <code class="literal">READ COMMITTED</code> または <code class="literal">READ UNCOMMITTED</code> (ステートメントベースロギングを排除)) を使用するテーブルを <code class="literal">STATEMENT</code> または <code class="literal">MIXED</code> モードでログを記録または複製するときに、問題を発生させました。
      </p><p>
        <code class="literal">TRUNCATE TABLE</code> は、ロギングおよびレプリケーション目的のときはステートメントとしてログを記録し複製できるように、DML ではなく DDL として扱われます。ただし、レプリケーションスレーブ上の <code class="literal">InnoDB</code> およびほかのトランザクションテーブルに適用されるこのステートメントの効果は、このようなテーブルを制御するルール (<a class="xref" href="sql-syntax.html#truncate-table" title="13.1.33 TRUNCATE TABLE 構文">セクション13.1.33「TRUNCATE TABLE 構文」</a> を参照) に依然として従います。(Bug #36763)
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-variables"></a>17.4.1.34 レプリケーションと変数</h4></div></div></div><a class="indexterm" name="idm139979045640128"></a><a class="indexterm" name="idm139979045637984"></a><a class="indexterm" name="idm139979045635920"></a><a class="indexterm" name="idm139979045633840"></a><a class="indexterm" name="idm139979045631760"></a><p>
        システム変数は、次の変数を除き (セッションスコープで使用されるとき)、<code class="literal">STATEMENT</code> モード使用時は正しく複製されません。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">auto_increment_increment</code>
          </p></li><li class="listitem"><p>
            <code class="literal">auto_increment_offset</code>
          </p></li><li class="listitem"><p>
            <code class="literal">character_set_client</code>
          </p></li><li class="listitem"><p>
            <code class="literal">character_set_connection</code>
          </p></li><li class="listitem"><p>
            <code class="literal">character_set_database</code>
          </p></li><li class="listitem"><p>
            <code class="literal">character_set_server</code>
          </p></li><li class="listitem"><p>
            <code class="literal">collation_connection</code>
          </p></li><li class="listitem"><p>
            <code class="literal">collation_database</code>
          </p></li><li class="listitem"><p>
            <code class="literal">collation_server</code>
          </p></li><li class="listitem"><p>
            <code class="literal">foreign_key_checks</code>
          </p></li><li class="listitem"><p>
            <code class="literal">identity</code>
          </p></li><li class="listitem"><p>
            <code class="literal">last_insert_id</code>
          </p></li><li class="listitem"><p>
            <code class="literal">lc_time_names</code>
          </p></li><li class="listitem"><p>
            <code class="literal">pseudo_thread_id</code>
          </p></li><li class="listitem"><p>
            <code class="literal">sql_auto_is_null</code>
          </p></li><li class="listitem"><p>
            <code class="literal">time_zone</code>
          </p></li><li class="listitem"><p>
            <code class="literal">timestamp</code>
          </p></li><li class="listitem"><p>
            <code class="literal">unique_checks</code>
          </p></li></ul></div><p>
        <code class="literal">MIXED</code> モード使用時に、前述のリスト内の変数がセッションスコープで使用されるときはステートメントベースから行ベースロギングに切り替わります。<a class="xref" href="server-administration.html#binary-log-mixed" title="5.2.4.3 混合形式のバイナリロギング形式">セクション5.2.4.3「混合形式のバイナリロギング形式」</a>を参照してください。
      </p><p>
        <code class="literal">NO_DIR_IN_CREATE</code> モードの場合を除いて、<code class="literal">sql_mode</code> も複製されます。スレーブは常に、<code class="literal">NO_DIR_IN_CREATE</code> にその独自の値を保持します (マスター上での変更にかかわらず)。これは、すべてのレプリケーション形式に当てはまります。
      </p><p>
        ただし、<span class="command"><strong>mysqlbinlog</strong></span> が <code class="literal">SET @@sql_mode = <em class="replaceable"><code>mode</code></em></code> ステートメントを解析したときに、<code class="literal">NO_DIR_IN_CREATE</code>を含む完全な <em class="replaceable"><code>mode</code></em> 値が受信サーバーに渡されます。このため、このようなステートメントのレプリケーションは、<code class="literal">STATEMENT</code> モード使用時は安全でない場合があります。
      </p><p>
        <code class="literal">default_storage_engine</code> および <code class="literal">storage_engine</code> のシステム変数は、ロギングモードにかかわらず複製されません。これは、異なるストレージエンジン間のレプリケーションを容易にすることを意図しています。
      </p><p>
        <code class="literal">read_only</code> システム変数は複製されません。さらに、この変数を有効にした場合の一時テーブル、テーブルロック、および <code class="literal">SET PASSWORD</code> ステートメントに関する効果は、MySQL バージョンごとに異なります。
      </p><p>
        <code class="literal">max_heap_table_size</code> システム変数は複製されません。スレーブ上でこの変数の値を増やさずにマスター上で増やすと、最終的にスレーブ上で<span class="errortext">Table is full</span>エラーになる可能性があります (スレーブの対応するものより大きくなることが許可されたマスター上の<code class="literal">MEMORY</code> テーブルで <code class="literal">INSERT</code> ステートメントを実行しようとするとき)。詳細については、<a class="xref" href="replication.html#replication-features-memory" title="17.4.1.21 レプリケーションと MEMORY テーブル">セクション17.4.1.21「レプリケーションと MEMORY テーブル」</a>を参照してください。
      </p><p>
        ステートメントベースレプリケーションで、セッション変数は、テーブルを更新するステートメントで使用されるときに正しく複製されません。たとえば、次のシーケンスのステートメントはマスターとスレーブで同じデータを挿入しません。
      </p><pre class="programlisting">
SET max_join_size=1000;
INSERT INTO mytable VALUES(@@max_join_size);
</pre><p>
        これは、一般的なシーケンスには適用されません。
      </p><pre class="programlisting">
SET time_zone=...;
INSERT INTO mytable VALUES(CONVERT_TZ(..., ..., @@time_zone));
</pre><p>
        セッション変数のレプリケーションは、行ベースレプリケーションが使用されているときは問題ではありません。このケースでは、セッション変数は常に安全に複製されます。<a class="xref" href="replication.html#replication-formats" title="17.1.2 レプリケーション形式">セクション17.1.2「レプリケーション形式」</a>を参照してください。
      </p><p>
        MySQL 5.6 では、次のセッション変数はロギング形式にかかわらず、バイナリログに書き込まれ、バイナリログを解析するときにレプリケーションスレーブによって受け付けられます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">sql_mode</code>
          </p></li><li class="listitem"><p>
            <code class="literal">foreign_key_checks</code>
          </p></li><li class="listitem"><p>
            <code class="literal">unique_checks</code>
          </p></li><li class="listitem"><p>
            <code class="literal">character_set_client</code>
          </p></li><li class="listitem"><p>
            <code class="literal">collation_connection</code>
          </p></li><li class="listitem"><p>
            <code class="literal">collation_database</code>
          </p></li><li class="listitem"><p>
            <code class="literal">collation_server</code>
          </p></li><li class="listitem"><p>
            <code class="literal">sql_auto_is_null</code>
          </p></li></ul></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          文字セットと照合順序に関係するセッション変数はバイナリログに書き込まれるけれども、異なる文字セット間のレプリケーションはサポートされません。
        </p></div><p>
        混乱の可能性を減らすため、マスターとスレーブの両方で <code class="literal">lower_case_table_names</code> システム変数に常に同じ設定を使用することをお勧めします (特に、ファイルシステムが大文字小文字を区別するプラットフォームで MySQL を実行しているとき)。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          以前のバージョンの MySQL で、大文字小文字を区別するファイルシステムが使用されているとき、この変数をスレーブで 1 に、マスターで異なる値に設定すると、レプリケーションが失敗することがありました。この問題は MySQL 5.6.1 で解決されています。(Bug #37656)
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="replication-features-views"></a>17.4.1.35 レプリケーションとビュー</h4></div></div></div><a class="indexterm" name="idm139979045549504"></a><a class="indexterm" name="idm139979045547328"></a><p>
        ビューは常にスレーブに複製されます。ビューは、それらが参照するテーブルではなく、それら独自の名前でフィルタリングされます。これは、通常は <code class="option">replication-ignore-table</code> ルールで除外されるテーブルがビューに含まれている場合でも、そのビューをスレーブに複製できることを意味します。このため、通常はセキュリティー上の理由でフィルタリングされるテーブルデータをビューが複製しないように、気を付けるようにしてください。
      </p><p>
        テーブルから同じ名前のビューへのレプリケーションは、ステートメントベースロギング使用時はサポートされますが、行ベースロギング使用時はされません。MySQL 5.6.11 以降で、行ベースロギングが有効のときにそうしようとすると、エラーになります。(Bug #11752707、Bug #43975)
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-compatibility"></a>17.4.2 MySQL バージョン間のレプリケーション互換性</h3></div></div></div><p>
      MySQL は、あるメジャーバージョンから次以降のメジャーバージョンへのレプリケーションをサポートします。たとえば、MySQL 4.1 を実行するマスターから MySQL 5.0 を実行するスレーブ、MySQL 5.0 を実行するマスターから MySQL 5.1 を実行するスレーブなどへの複製ができます。
    </p><p>
      ただし、古いマスターから新しいスレーブに複製するときに、マスターがスレーブ上で使用されているバージョンの MySQL でもうサポートされていないステートメントを使用したり、そのような動作に依存したりする場合は、問題が発生することがあります。たとえば、MySQL 5.5 では、<code class="literal">CREATE TABLE ... SELECT</code> ステートメントが、作成済みでないテーブルを変更することが許可されますが、MySQL 5.6 では許可されなくなりました (<a class="xref" href="replication.html#replication-features-create-select" title="17.4.1.5 CREATE TABLE ... SELECT ステートメントのレプリケーション">セクション17.4.1.5「CREATE TABLE ... SELECT ステートメントのレプリケーション」</a>を参照してください)。
    </p><p>
      2 つを超える MySQL Server バージョンを使用することは、マスターまたはスレーブ MySQL サーバーの数にかかわらず、複数のマスターを使用するレプリケーションセットアップでサポートされません。この制限は、メジャーバージョンだけではなく、同じメジャーバージョン内のマイナーバージョンにも適用されます。たとえば、チェーンまたは循環レプリケーションセットアップを使用している場合、MySQL 5.6.1、MySQL 5.6.2、および MySQL 5.6.4 は同時に使用できませんが、これらのリリースの任意の 2 つを一緒に使用することはできます。
    </p><p>
      場合によっては、マスターと、マスターよりメジャーバージョン 2 つ以上新しいスレーブとの間で複製できます。ただし、MySQL 4.1 以前を実行するマスターから MySQL 5.1 以降を実行するスレーブに複製しようとすることに関する既知の問題があります。このような問題に対処するために、2 つの間に中間バージョンを実行する MySQL サーバーを挿入できます。たとえば、MySQL 4.1 マスターから MySQL 5.1 スレーブに直接複製するのではなく、MySQL 4.1 サーバーから MySQL 5.0 サーバーに複製してから、MySQL 5.0 サーバーから MySQL 5.1 サーバーに複製できます。
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        レプリケーション (およびほかの) 機能は継続的に改善されているので、その MySQL メジャーバージョン内で使用可能な最新リリースを使用することを強くお勧めします。また、MySQL メジャーバージョンの早期リリースを使用するマスターとスレーブは GA (本番環境) リリースに更新することをお勧めします (そのメジャーバージョンで後者を入手できるようになったとき)。
      </p></div><p>
      新しいマスターから古いスレーブに複製できる場合がありますが、一般的にはサポートされません。これはいくつかの要因によります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>バイナリログ形式の変更 </b>
            バイナリログ形式はメジャーリリース間で変わることがあります。下位互換性を維持しようと試みてはいますが、これがいつか可能なわけではありません。たとえば、MySQL 5.0 に実装されたバイナリログ形式は、以前のバージョンで使用されたものから大幅に変わりました (特に、文字セット、<code class="literal">LOAD DATA INFILE</code>、およびタイムゾーンの扱いに関して)。これは、MySQL 5.0 (以降) マスターから MySQL 4.1 (以前) スレーブへのレプリケーションは一般的にサポートされないことを意味します。
          </p><p>
          これは、レプリケーションサーバーのアップグレードにも密接な関係があります。詳細は、<a class="xref" href="replication.html#replication-upgrade" title="17.4.3 レプリケーションセットアップをアップグレードする">セクション17.4.3「レプリケーションセットアップをアップグレードする」</a>を参照してください。
        </p></li><li class="listitem"><p><b>行ベースレプリケーションの使用 </b>
            行ベースレプリケーションが MySQL 5.1.5 で実装されたため、行ベースレプリケーションを使用して MySQL 5.6 以降のマスターから MySQL 5.1.5 より古いスレーブに複製することはできません。
          </p><p>
          行ベースレプリケーションの詳細は、<a class="xref" href="replication.html#replication-formats" title="17.1.2 レプリケーション形式">セクション17.1.2「レプリケーション形式」</a>を参照してください。
        </p></li><li class="listitem"><p><b>SQL 非互換 </b>
            複製されるステートメントが、マスター上で利用できるけれどもスレーブ上で利用できない SQL 機能を使用する場合は、ステートメントベースレプリケーションを使用して新しいマスターから古いスレーブに複製することはできません。
          </p><p>
          ただし、マスターとスレーブの両方が行ベースレプリケーションをサポートし、複製するデータ定義ステートメントにマスター上で見つかるけれどもスレーブ上で見つからない SQL 機能に依存するものがない場合は、行ベースレプリケーションを使用してデータ変更ステートメントの効果を複製できます (マスター上で実行される DDL がスレーブ上でサポートされない場合でも)。
        </p></li><li class="listitem"><p><b>MySQL 5.6 の重要な変数 </b>
            以前の MySQL バージョンに複製するときに無効にする必要がある機能が、MySQL 5.6 に追加されています。非互換を回避するには、MySQL 5.6 マスターで次の変数を設定してください。
          </p><p>
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">binlog_checksum=NONE</code>
              </p></li><li class="listitem"><p>
                <code class="literal">binlog_row_image=FULL</code>
              </p></li><li class="listitem"><p>
                <code class="literal">binlog_rows_query_log_events=OFF</code>
              </p></li><li class="listitem"><p>
                <code class="literal">log_bin_use_v1_row_events=1</code>
              </p></li><li class="listitem"><p>
                <code class="literal">gtid_mode=OFF</code>
              </p></li></ul></div><p>
        </p></li></ul></div><p>
      潜在的なレプリケーション問題の詳細は、<a class="xref" href="replication.html#replication-features" title="17.4.1 レプリケーションの機能と問題">セクション17.4.1「レプリケーションの機能と問題」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-upgrade"></a>17.4.3 レプリケーションセットアップをアップグレードする</h3></div></div></div><p>
      レプリケーションセットアップに関与するサーバーをアップグレードするときに、アップグレードの手順は現在のサーバーバージョンとアップグレード後のバージョンによって異なります。
    </p><p>
      このセクションは、古いバージョンの MySQL から MySQL 5.6 にレプリケーションをアップグレードすることに割り当てられます。4.0 サーバーは 4.0.3 以降であるべきです。マスター上のレプリケーションユーザーには、ハッシュ方式の変更により、MySQL バージョン 4.1.1 以降で生成されたパスワードハッシュが<span class="emphasis"><em>必要です</em></span>。詳細は、<a class="xref" href="security.html#password-hashing" title="6.1.2.4 MySQL でのパスワードハッシュ">セクション6.1.2.4「MySQL でのパスワードハッシュ」</a>を参照してください。
    </p><p>
      以前の MySQL リリースシリーズから 5.6 にマスターをアップグレードするときは、最初にこのマスターのすべてのスレーブが同じ 5.6.x リリースを使用していることを確認してください。そうでない場合は、まずスレーブをアップグレードしてください。各スレーブをアップグレードするには、シャットダウンし、適切な 5.6.x バージョンにアップグレードし、再起動してから、レプリケーションを再開してください。アップグレード後にスレーブによって作成されるリレーログは 5.6 形式です。
    </p><p>
      厳密な SQL モードでの操作に影響する変更があると、更新後のスレーブでレプリケーションが失敗する場合があります。たとえば、MySQL 5.6.13 以降では、サーバーは、厳密モード (<code class="literal">STRICT_TRANS_TABLES</code> または <code class="literal">STRICT_ALL_TABLES</code>) で時間データ型の <code class="literal">DEFAULT</code> 値への 0 の挿入を制限します。ステートメントベースロギング (<code class="literal">binlog_format=STATEMENT</code>) を使用する場合にレプリケーションで非互換になるのは、スレーブがアップグレードされた場合、アップグレードされていないマスターがエラーなしで実行するステートメントが、スレーブ上で失敗することがあり、するとレプリケーションが停止します。これに対処するには、マスター上のすべての新しいステートメントを停止し、スレーブが追い付くのを待ちます。それからスレーブをアップグレードします。あるいは、新しいステートメントを停止できない場合は、マスターで一時的に行ベースのロギングに変更し (<code class="literal">binlog_format=ROW</code>)、すべてのスレーブが、この変更の時点までに生成されたすべてのバイナリログを処理するまで待ちます。それからスレーブをアップグレードします。
    </p><p>
      スレーブがアップグレードされたあとに、マスターをシャットダウンし、スレーブと同じ 5.6.x リリースにアップグレードしてから、再起動します。一時的にマスターを行ベースロギングに変更した場合は、ステートメントベースロギングに戻します。5.6 マスターは、アップグレード前に書き込まれた古いバイナリログを読み取って、それらを 5.6 スレーブに送信できます。スレーブは、古い形式を認識し、適切に処理します。アップグレード後にマスターによって作成されるバイナリログは 5.6 形式です。これらも 5.6 スレーブによって認識されます。
    </p><p>
      つまり、MySQL 5.6 にアップグレードするときは、マスターを 5.6 にアップグレードする前に、スレーブが MySQL 5.6 である必要があります。5.6 から古いバージョンへのダウングレードは、それほど簡単には機能しません。ダウングレードに進む前に 5.6 バイナリログまたはリレーログを削除できるように、それらが完全に処理されたことを確認する必要があります。
    </p><p>
      レプリケーションセットアップを以前のバージョンにダウングレードすることは、ステートメントベースから行ベースレプリケーションに切り替えたあと、および最初の行ベースステートメントが binlog に書き込まれたあとには実行できません。<a class="xref" href="replication.html#replication-formats" title="17.1.2 レプリケーション形式">セクション17.1.2「レプリケーション形式」</a>を参照してください。
    </p><p>
      アップグレードによっては、ある MySQL シリーズから次のものに移行するときに、データベースオブジェクトの削除と再作成が必要になる場合があります。たとえば、照合順序の変更には、テーブルインデックスの再構築が必要な場合があります。このような操作が必要な場合は、詳細を<a class="xref" href="installing.html#upgrading-from-previous-series" title="2.11.1.3 MySQL 5.5 から 5.6 へのアップグレード">セクション2.11.1.3「MySQL 5.5 から 5.6 へのアップグレード」</a>で参照してください。これらの操作をスレーブとマスターで個別に実行し、これらの操作をマスターからスレーブに複製することを無効にするのがもっとも安全です。 これを実現するには、次の手順を使用してください。
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          すべてのスレーブを停止してそれらをアップグレードします。マスターに接続しないように、<code class="option">--skip-slave-start</code> オプションでそれらを再起動します。データベースオブジェクトの再作成に必要なテーブル修復または再構築操作 (<code class="literal">REPAIR TABLE</code>、<code class="literal">ALTER TABLE</code> の使用など)、またはテーブルまたはトリガーのダンプおよびリロードを実行します。
        </p></li><li class="listitem"><p>
          マスター上でバイナリログを無効にします。マスターを再起動しないでこれを行うには、<code class="literal">SET sql_log_bin = 0</code> ステートメントを実行します。または、マスターを停止して、<code class="option">--log-bin</code> オプションなしで再起動します。マスターを再起動する場合、クライアント接続を拒否することもお勧めします。たとえば、すべてのクライアントが TCP/IP を使用して接続する場合は、マスターを再起動するときに <code class="option">--skip-networking</code> オプションを使用します。
        </p></li><li class="listitem"><p>
          バイナリログが無効の状態で、データベースオブジェクトの再作成に必要なテーブル修復または再構築操作を実行します。これらの操作がログに記録されてあとでスレーブに送信されることを回避するには、この手順の間バイナリログを無効にする必要があります。
        </p></li><li class="listitem"><p>
          マスター上でバイナリログを再度有効にします。以前に <code class="literal">sql_log_bin</code> を 0 に設定した場合、<code class="literal">SET sql_log_bin = 1</code> ステートメントを実行します。バイナリログを無効にするためにマスターを再起動した場合は、クライアントとスレーブが接続できるように <code class="option">--log-bin</code> あり、<code class="option">--skip-networking</code> なしで再起動します。
        </p></li><li class="listitem"><p>
          今度は <code class="option">--skip-slave-start</code> オプションなしで、スレーブを再起動します。
        </p></li></ol></div><p>
      グローバルトランザクション識別子を持つレプリケーションが MySQL 5.6.7 で導入されました。GTID をサポートしないバージョンの MySQL から、サポートするバージョンに既存のレプリケーションセットアップをアップグレードする場合、GTID ベースレプリケーションのすべての要件をセットアップが満たすことを確認する前に、マスターまたはスレーブで GTID を有効にしないでください。<a class="xref" href="replication.html#replication-gtids-howto" title="17.1.3.2 GTID を使用したレプリケーションのセットアップ">セクション17.1.3.2「GTID を使用したレプリケーションのセットアップ」</a>を参照してください。GTID ベースレプリケーションを使用するために既存のレプリケーションセットアップを変換することに関する情報が含まれています。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-problems"></a>17.4.4 レプリケーションのトラブルシューティング</h3></div></div></div><a class="indexterm" name="idm139979045464720"></a><p>
      指示に従ってもレプリケーションセットアップが機能しない場合、最初に行うことは<span class="emphasis"><em>エラーログでメッセージを確認する</em></span>ことです。多くのユーザーは、問題が発生したあとにこれを十分に実行せずに、時間を失います。
    </p><p>
      エラーログから何が問題だったのかがわからない場合は、次の手法を試してください。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          マスターでバイナリロギングが有効になっていることを、<code class="literal">SHOW MASTER STATUS</code> ステートメントを発行して確認します。ロギングが有効であると、<code class="literal">Position</code> はゼロではありません。バイナリロギングが有効でない場合、<code class="option">--log-bin</code> オプションでマスターを実行していることを確認してください。
        </p></li><li class="listitem"><p>
          マスターとスレーブの両方が <code class="option">--server-id</code> オプションで起動されたこと、および ID 値が各サーバーで一意であることを確認します。
        </p></li><li class="listitem"><p>
          スレーブが動作していることを確認します。<code class="literal">SHOW SLAVE STATUS</code> を使用して、<code class="literal">Slave_IO_Running</code> および <code class="literal">Slave_SQL_Running</code>の値が両方とも <code class="literal">Yes</code> であるかどうかを確認してください。そうでない場合、スレーブサーバーを起動するときに使用したオプションを確認してください。たとえば、<code class="option">--skip-slave-start</code> は、<code class="literal">START SLAVE</code> ステートメントを発行するまでスレーブスレッドが起動するのを妨げます。
        </p></li><li class="listitem"><p>
          スレーブが動作している場合、マスターとの接続が確立されたかどうかを確認します。<code class="literal">SHOW PROCESSLIST</code> を使用して I/O スレッドと SQL スレッドを見つけ、それらの <code class="literal">State</code> カラムをチェックしてそれらに何が表示されているかを確認してください。<a class="xref" href="replication.html#replication-implementation-details" title="17.2.1 レプリケーション実装の詳細">セクション17.2.1「レプリケーション実装の詳細」</a>を参照してください。I/O スレッド状態が <code class="literal">Connecting to master</code> である場合、次のことを確認してください。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              マスター上でレプリケーションに使用されているユーザーの権限を確認します。
            </p></li><li class="listitem"><p>
              マスターのホスト名前が正しいこと、正しいポートを使用してマスターに接続していることを確認します。レプリケーションに使用されるポートは、クライアントネットワーク通信に使用されるポートと同じです (デフォルトは <code class="literal">3306</code> です)。ホスト名の場合、その名前が正しい IP アドレスに解決されることを確認してください。
            </p></li><li class="listitem"><p>
              ネットワークがマスターまたはスレーブ上で無効化されていないことを確認します。構成ファイルで <code class="option">skip-networking</code> オプションを探してください。存在する場合、コメントアウトするか、削除してください。
            </p></li><li class="listitem"><p>
              マスターにファイアウォールまたは IP フィルタリング構成がある場合、MySQL に使用されるネットワークポートがフィルタリングされていないことを確認します。
            </p></li><li class="listitem"><p>
              <code class="literal">ping</code> または <code class="literal">traceroute</code>/<code class="literal">tracert</code> を使用してホストに到達することで、マスターに到達できることを確認します。
            </p></li></ul></div></li><li class="listitem"><p>
          スレーブが以前は動作していたのに停止した場合、通常はマスターで成功したステートメントの一部がスレーブで失敗したことが原因です。マスターの適切なスナップショットを作成し、スレーブスレッド以外にスレーブでそのデータを変更しなかった場合、これは決して発生しないはずです。スレーブが突然停止する場合、それはバグであるか、または<a class="xref" href="replication.html#replication-features" title="17.4.1 レプリケーションの機能と問題">セクション17.4.1「レプリケーションの機能と問題」</a>で説明した既知のレプリケーション制限のいずれかが発生しています。バグの場合は、報告方法の説明を<a class="xref" href="replication.html#replication-bugs" title="17.4.5 レプリケーションバグまたは問題を報告する方法">セクション17.4.5「レプリケーションバグまたは問題を報告する方法」</a>で参照してください。
        </p></li><li class="listitem"><p>
          マスター上で成功したステートメントがスレーブ上で実行することを拒否する場合に、スレーブのデータベースを削除してマスターから新しいスナップショットをコピーすることによる完全なデータベース再同期を実行できない場合は、次の手順を試みてください。
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              スレーブ上の影響されるテーブルがマスターテーブルと異なるかどうかを判断します。これがどのように発生したかを理解しようとしてください。それから、スレーブのテーブルをマスターのものと同じにして <code class="literal">START SLAVE</code> を実行してください。
            </p></li><li class="listitem"><p>
              前述の手順が機能しない、または当てはまらない場合は、手動で更新を行ってから (必要な場合)、マスターからの次のステートメントを無視することが安全かどうかを理解しようとしてください。
            </p></li><li class="listitem"><p>
              スレーブがマスターからの次のステートメントをスキップできると判断した場合、次のステートメントを発行します。
            </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET GLOBAL sql_slave_skip_counter = <em class="replaceable"><code>N</code></em>;</code></strong>
mysql&gt; <strong class="userinput"><code>START SLAVE;</code></strong>
</pre><p>
              マスターからの次のステートメントが <code class="literal">AUTO_INCREMENT</code> または <code class="literal">LAST_INSERT_ID()</code> を使用しない場合、<em class="replaceable"><code>N</code></em> の値は 1 であるべきです。そうでない場合は、値は 2 であるべきです。<code class="literal">AUTO_INCREMENT</code> または <code class="literal">LAST_INSERT_ID()</code> を使用するステートメントに値 2 を使用する理由は、それらがマスターのバイナリログ内で 2 つのイベントを必要とすることです。
            </p><p>
              <a class="xref" href="sql-syntax.html#set-global-sql-slave-skip-counter" title="13.4.2.4 SET GLOBAL sql_slave_skip_counter 構文">セクション13.4.2.4「SET GLOBAL sql_slave_skip_counter 構文」</a>も参照してください。
            </p></li><li class="listitem"><p>
              スレーブがマスターと完全に同期された状態で起動したこと、およびスレーブスレッド以外で使用されるテーブルをだれも更新しなかったことがわかっている場合は、おそらくこの矛盾はバグの結果です。最新バージョンの MySQL を実行している場合は、この問題を報告してください。古いバージョンを実行している場合は、最新の本番環境リリースにアップグレードして問題が持続するかどうかを判断してみてください。
            </p></li></ol></div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-bugs"></a>17.4.5 レプリケーションバグまたは問題を報告する方法</h3></div></div></div><p>
      関係するユーザーエラーはないと判断したけれども、依然としてレプリケーションがまったく機能しないか安定しない場合は、バグレポートを送る時期です。バグを突き止めるため、できるだけ多くの情報をユーザーから入手する必要があります。優れたバグレポートを準備するために、ある程度の時間と労力を費やしてくださるようにお願いします。
    </p><p>
      そのバグをはっきりと示す再現可能なテストケースがある場合は、<a class="xref" href="introduction.html#bug-reports" title="1.7 質問またはバグをレポートする方法">セクション1.7「質問またはバグをレポートする方法」</a>で示す手順を使用してオラクルのバグデータベースに入力してくださるようにお願いします。<span class="quote">「<span class="quote">幽霊のような</span>」</span>問題 (意のままに再現できないもの) の場合は、次の手順を使用してください。
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          ユーザーエラーが関係していないことを確認します。たとえば、スレーブスレッド以外の場所でスレーブを更新すると、データが同期を失い、更新時に一意キー違反が発生することがあります。この場合、スレーブスレッドは停止し、ユーザーが手動でテーブルをクリーンアップして同期された状態に戻すまで待ちます。 <span class="emphasis"><em>これは、レプリケーションの問題ではありません。外部干渉の問題でレプリケーションが失敗しています。</em></span>
        </p></li><li class="listitem"><p>
          <code class="option">--log-slave-updates</code> および <code class="option">--log-bin</code> オプションでスレーブを実行します。これらのオプションにより、スレーブはマスターから受け取る更新のログをその独自のバイナリログに記録します。
        </p></li><li class="listitem"><p>
          レプリケーション状態をリセットする前のすべての証拠を保存します。情報がなかったり、不完全な情報しかなかったりすると、オラクルでは問題を突き止めることが困難または不可能になります。収集すべき証拠:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              マスターからのすべてのバイナリログファイル
            </p></li><li class="listitem"><p>
              スレーブからのすべてのバイナリログファイル
            </p></li><li class="listitem"><p>
              問題を発見した時点の、マスターからの <code class="literal">SHOW MASTER STATUS</code> の出力
            </p></li><li class="listitem"><p>
              問題を発見した時点の、スレーブからの <code class="literal">SHOW SLAVE STATUS</code> の出力
            </p></li><li class="listitem"><p>
              マスターおよびスレーブからのエラーログ
            </p></li></ul></div></li><li class="listitem"><p>
          <span class="command"><strong>mysqlbinlog</strong></span> を使用してバイナリログを調べます。次のことは、問題のステートメントを見つけるのに役立つはずです。<em class="replaceable"><code>log_file</code></em> および <em class="replaceable"><code>log_pos</code></em> は、<code class="literal">SHOW SLAVE STATUS</code> からの <code class="literal">Master_Log_File</code> および <code class="literal">Read_Master_Log_Pos</code> 値です。
        </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>mysqlbinlog --start-position=<em class="replaceable"><code>log_pos</code></em> <em class="replaceable"><code>log_file</code></em> | head</code></strong>
</pre></li></ol></div><p>
      問題の証拠を収集したあとは、まずそれらを個別のテストケースとして切り分けてみてください。そのうえで、<a class="xref" href="introduction.html#bug-reports" title="1.7 質問またはバグをレポートする方法">セクション1.7「質問またはバグをレポートする方法」</a>での指示を使用して問題およびできるだけ多くの情報をオラクルのバグデータベースに入力してください。
    </p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ha-overview.html">前</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="mysql-cluster.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第 16 章 高可用性と拡張性 </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 第 18 章 MySQL Cluster NDB 7.3 および MySQL Cluster NDB 7.4</td></tr></table></div><div class="copyright-footer"></div></body></html>
