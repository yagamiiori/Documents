<html lang="ja"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>第 23 章 Connector および API</title><link rel="stylesheet" type="text/css" href="mvl.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="MySQL 5.6 リファレンスマニュアル"><link rel="up" href="index.html" title="MySQL 5.6 リファレンスマニュアル"><link rel="prev" href="performance-schema.html" title="第 22 章 MySQL パフォーマンススキーマ"><link rel="next" href="extending-mysql.html" title="第 24 章 MySQL の拡張">
<script language="javascript" type="text/javascript">
  function addOnload(theFunc)
  {
    var previous = window.onload;
    if (typeof window.onload != 'function')
    {
      window.onload = theFunc;
    }
    else
    {
      window.onload = function()
      {
        previous();
        theFunc();
      }
    }
  }

  addOnload(function()
  {
    var base = new Date(1442918127*1000);
    var now = new Date();
    var diff = ((now-base)/1000)/(24*3600);

    if (diff > 90) {
      var nodes = document.getElementsByClassName('titlepage');
      nodes[0].innerHTML = '<p style="border: 5px #ff0000 solid; padding: 5px; margin 5px">' +
        'This copy of the manual is more than 90 days old. We encourage you to download a ' +
        'new version from <a href="http://dev.mysql.com">dev.mysql.com/doc</a>.</p>' + nodes[0].innerHTML;
    }
  });
</script>
<noscript></noscript>
</head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第 23 章 Connector および API</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="performance-schema.html">前</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="extending-mysql.html">次へ</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="connectors-apis"></a>第 23 章 Connector および API</h1></div></div></div><div class="toc"><p><b>目次</b></p><dl class="toc"><dt><span class="section"><a href="connectors-apis.html#connector-odbc-info">23.1 MySQL Connector/ODBC</a></span></dt><dt><span class="section"><a href="connectors-apis.html#connector-net-info">23.2 MySQL Connector/Net</a></span></dt><dt><span class="section"><a href="connectors-apis.html#connector-j-info">23.3 MySQL Connector/J</a></span></dt><dt><span class="section"><a href="connectors-apis.html#connector-cpp-info">23.4 MySQL Connector/C++</a></span></dt><dt><span class="section"><a href="connectors-apis.html#connector-c-info">23.5 MySQL Connector/C</a></span></dt><dt><span class="section"><a href="connectors-apis.html#connector-python-info">23.6 MySQL Connector/Python</a></span></dt><dt><span class="section"><a href="connectors-apis.html#libmysqld">23.7 組み込み MySQL サーバーライブラリ libmysqld</a></span></dt><dd><dl><dt><span class="section"><a href="connectors-apis.html#libmysqld-compiling">23.7.1 libmysqld によるプログラムのコンパイル</a></span></dt><dt><span class="section"><a href="connectors-apis.html#libmysqld-restrictions">23.7.2 組み込み MySQL サーバーを使用する場合の制限</a></span></dt><dt><span class="section"><a href="connectors-apis.html#libmysqld-options">23.7.3 組み込みサーバーとオプション</a></span></dt><dt><span class="section"><a href="connectors-apis.html#libmysqld-example">23.7.4 組み込みサーバーの例</a></span></dt></dl></dd><dt><span class="section"><a href="connectors-apis.html#c-api">23.8 MySQL C API</a></span></dt><dd><dl><dt><span class="section"><a href="connectors-apis.html#c-api-implementations">23.8.1 MySQL C API の実装</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-multiple-installations">23.8.2 MySQL サーバーと MySQL Connector/C の同時インストール</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-example-programs">23.8.3 C API クライアントプログラムの例</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-building-running-clients">23.8.4 C API クライアントプログラムの構築と実行</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-data-structures">23.8.5 C API データ構造</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-function-overview">23.8.6 C API 関数の概要</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-functions">23.8.7 C API 関数の説明</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-prepared-statements">23.8.8 C API プリペアドステートメント</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-prepared-statement-data-structures">23.8.9 C API プリペアドステートメントデータ構造</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-prepared-statement-function-overview">23.8.10 C API プリペアドステートメント関数の概要</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-prepared-statement-functions">23.8.11 C API プリペアドステートメント関数の説明</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-thread-functions">23.8.12 C API スレッド関数の説明</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-embedded-server-functions">23.8.13 C API 組み込みサーバー関数の説明</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-plugin-functions">23.8.14 C API クライアントプラグイン関数</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-problems">23.8.15 C API を使用する場合の一般的な質問と問題</a></span></dt><dt><span class="section"><a href="connectors-apis.html#auto-reconnect">23.8.16 自動再接続動作の制御</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-multiple-queries">23.8.17 複数ステートメント実行の C API サポート</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-prepared-statement-problems">23.8.18 C API プリペアドステートメントの問題</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-prepared-statement-date-handling">23.8.19 C API プリペアドステートメントの日時値の処理</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-prepared-call-statements">23.8.20 C API のプリペアド CALL ステートメントのサポート</a></span></dt></dl></dd><dt><span class="section"><a href="connectors-apis.html#apis-php-info">23.9 MySQL PHP API</a></span></dt><dt><span class="section"><a href="connectors-apis.html#apis-perl">23.10 MySQL Perl API</a></span></dt><dt><span class="section"><a href="connectors-apis.html#apis-python">23.11 MySQL Python API</a></span></dt><dt><span class="section"><a href="connectors-apis.html#apis-ruby">23.12 MySQL Ruby API</a></span></dt><dd><dl><dt><span class="section"><a href="connectors-apis.html#apis-ruby-mysqlruby">23.12.1 MySQL/Ruby API</a></span></dt><dt><span class="section"><a href="connectors-apis.html#apis-ruby-rubymysql">23.12.2 Ruby/MySQL API</a></span></dt></dl></dd><dt><span class="section"><a href="connectors-apis.html#apis-tcl">23.13 MySQL Tcl API</a></span></dt><dt><span class="section"><a href="connectors-apis.html#apis-eiffel">23.14 MySQL Eiffel ラッパー</a></span></dt></dl></div><a class="indexterm" name="idm139979003893344"></a><a class="indexterm" name="idm139979003892032"></a><a class="indexterm" name="idm139979003890688"></a><a class="indexterm" name="idm139979003889344"></a><a class="indexterm" name="idm139979003888000"></a><a class="indexterm" name="idm139979003886656"></a><a class="indexterm" name="idm139979003885312"></a><a class="indexterm" name="idm139979003883968"></a><a class="indexterm" name="idm139979003882624"></a><a class="indexterm" name="idm139979003881136"></a><a class="indexterm" name="idm139979003879968"></a><a class="indexterm" name="idm139979003878624"></a><a class="indexterm" name="idm139979003877104"></a><a class="indexterm" name="idm139979003875712"></a><a class="indexterm" name="idm139979003873792"></a><a class="indexterm" name="idm139979003871760"></a><p>
    MySQL Connector はクライアントプログラムに MySQL サーバーへの接続を提供します。API は MySQL プロトコルおよび MySQL リソースへの低レベルアクセスを提供します。Connector と API のどちらも、ODBC、Java (JDBC)、Perl、Python、PHP、Ruby、およびネイティブ C と組み込み MySQL インスタンスなどのほかの言語や環境から、MySQL ステートメントに接続し、実行することができます。
  </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
      Connector バージョン番号は MySQL Server バージョン番号と関係がありません。<a class="xref" href="connectors-apis.html#connectors-apis-versions" title="表 23.2 MySQL Connector のバージョンと MySQL Server のバージョン">表23.2「MySQL Connector のバージョンと MySQL Server のバージョン」</a>を参照してください。
    </p></div><h2><a name="idm139979003866832"></a>MySQL Connector</h2><p>
    Oracle では多数のコネクタを開発しています。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <a class="ulink" href="http://dev.mysql.com/doc/connector-odbc/en/index.html" target="_top">Connector/ODBC</a> は ODBC (Open Database Connectivity) API を使用して、MySQL に接続するためのドライバサポートを提供します。サポートは、Windows、Unix、および OS X プラットフォームからの ODBC 接続で使用できます。
      </p></li><li class="listitem"><p>
        <a class="ulink" href="http://dev.mysql.com/doc/connector-net/en/index.html" target="_top">Connector/Net</a> により、開発者は MySQL に接続する .NET アプリケーションを作成できます。Connector/Net は完全に機能する ADO.NET インタフェースを実装し、ADO.NET 対応ツールで使用するためのサポートを提供します。Connector/Net を使用するアプリケーションは、サポートされる任意の .NET 言語で書くことができます。
      </p><p>
        MySQL <a class="ulink" href="http://dev.mysql.com/doc/connector-net/en/connector-net-visual-studio.html" target="_top">Visual Studio Plugin</a> は Connector/Net および Visual Studio 2005 と連携します。このプラグインは MySQL DDEX プロバイダであり、これは Visual Studio で使用可能なスキーマおよびデータ操作ツールを使用して、MySQL データベース内にオブジェクトを作成し、編集できることを意味します。
      </p></li><li class="listitem"><p>
        <a class="ulink" href="http://dev.mysql.com/doc/connector-j/en/index.html" target="_top">Connector/J</a> は標準 JDBC (Java Database Connectivity) API を使用して、Java アプリケーションから、MySQL に接続するためのドライバサポートを提供します。
      </p></li><li class="listitem"><p>
        <a class="ulink" href="http://dev.mysql.com/doc/connector-python/en/index.html" target="_top">Connector/Python</a> は <a class="ulink" href="http://www.python.org/dev/peps/pep-0249/" target="_top">Python DB API バージョン 2.0</a> に準拠する API を使用して、Python アプリケーションから、MySQL に接続するためのドライバサポートを提供します。追加の Python モジュールまたは MySQL クライアントライブラリは必要ありません。
      </p></li><li class="listitem"><p>
        <a class="ulink" href="http://dev.mysql.com/doc/connector-cpp/en/index.html" target="_top">Connector/C++</a> により、C++ アプリケーションは MySQL に接続できます。
      </p></li><li class="listitem"><p>
        <a class="ulink" href="http://dev.mysql.com/doc/connector-c/en/index.html" target="_top">Connector/C</a> は C アプリケーションに使用される、MySQL クライアントライブラリ (<code class="literal">libmysqlclient</code>) のスタンドアロンの代替です。
      </p></li></ul></div><h2><a name="idm139979003850400"></a>MySQL C API</h2><p>
    C アプリケーション内で、MySQL をネイティブに使用することへの直接のアクセスには、2 つの方法があります。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <a class="link" href="connectors-apis.html#c-api" title="23.8 MySQL C API">C API</a> は、<code class="literal">libmysqlclient</code> クライアントライブラリ経由で、MySQL クライアント/サーバープロトコルへの低レベルアクセスを提供します。これは、MySQL サーバーのインスタンスに接続するために使用する主な方法で、MySQL コマンド行クライアントと、ここで詳しく説明している多くの MySQL Connector およびサードパーティー API のどちらにも使用されています。
      </p><p>
        <code class="literal">libmysqlclient</code> は MySQL 配布および MySQL Connector/C 配布に含まれています。
      </p></li><li class="listitem"><p>
        <code class="literal">libmysqld</code> は MySQL サーバーのインスタンスを C アプリケーションに組み込むことができる組み込み MySQL サーバーライブラリです。
      </p><p>
        <code class="literal">libmysqld</code> は MySQL 配布に含まれますが、MySQL Connector/C 配布には含まれていません。
      </p></li></ul></div><p>
    <a class="xref" href="connectors-apis.html#c-api-implementations" title="23.8.1 MySQL C API の実装">セクション23.8.1「MySQL C API の実装」</a>も参照してください。
  </p><p>
    C アプリケーションから MySQL にアクセスするか、この章の Connector や API でサポートされていない言語で、MySQL へのインタフェースを構築するには、<a class="link" href="connectors-apis.html#c-api" title="23.8 MySQL C API">C API</a> から始めます。このプロセスに役立つ、多くのプログラマ向けユーティリティーがあります。<a class="xref" href="programs.html#programs-development" title="4.7 MySQL プログラム開発ユーティリティー">セクション4.7「MySQL プログラム開発ユーティリティー」</a>を参照してください。
  </p><h2><a name="idm139979003837360"></a>サードパーティー MySQL API</h2><p>
    この章で説明している残りの API は、特定のアプリケーション言語から MySQL へのインタフェースを提供します。これらのサードパーティーソリューションは Oracle で開発されていないか、サポートされていません。それらの使用と機能に関する基本情報は、参考目的でのみここで提供しています。
  </p><p>
    すべてのサードパーティー言語 API は、<code class="literal">libmysqlclient</code> を使用するか、または <em class="firstterm">ネイティブドライバ</em>を実装するか、2 つの方法のいずれかを使用して開発されています。2 つのソリューションには異なるメリットがあります。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <span class="emphasis"><em><code class="literal">libmysqlclient</code></em></span> は MySQL クライアントアプリケーションと同じライブラリを使用するため、MySQL と完全に互換性があります。ただし、機能セットは、<code class="literal">libmysqlclient</code> から公開された実装とインタフェースに制限され、データがネイティブ言語と MySQL API コンポーネント間でコピーされるため、パフォーマンスが低下することがあります。
      </p></li><li class="listitem"><p>
        <span class="emphasis"><em>ネイティブドライバ</em></span>はホスト言語または環境内に完全に収まる MySQL ネットワークプロトコルの実装です。ネイティブドライバはコンポーネント間でのデータのコピーが少ないため高速であり、標準 MySQL API によって使用できない高度な機能を提供できます。さらに、ネイティブドライバコンポーネントの構築には、MySQL クライアントライブラリのコピーが必要ないため、ネイティブドライバは、エンドユーザーにとって構築とデプロイが簡単です。
      </p></li></ul></div><p>
    <a class="xref" href="connectors-apis.html#connectors-apis-summary" title="表 23.1 MySQL API およびインタフェース">表23.1「MySQL API およびインタフェース」</a>に MySQL で使用可能な多くのライブラリとインタフェースを一覧表示しています。<a class="xref" href="connectors-apis.html#connectors-apis-versions" title="表 23.2 MySQL Connector のバージョンと MySQL Server のバージョン">表23.2「MySQL Connector のバージョンと MySQL Server のバージョン」</a>に、各コネクタがサポートする MySQL サーバーのバージョンを示しています。
  </p><div class="table"><a name="connectors-apis-summary"></a><p class="title"><b>表 23.1 MySQL API およびインタフェース</b></p><div class="table-contents"><table summary="MySQL API およびインタフェース" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th scope="col">環境</th><th scope="col">API</th><th scope="col">型</th><th scope="col">メモ</th></tr></thead><tbody><tr><td scope="row">Ada</td><td>GNU Ada MySQL バインディング</td><td><code class="literal">libmysqlclient</code></td><td><a class="ulink" href="http://gnade.sourceforge.net/" target="_top">GNU Ada 用の MySQL バインディングに関するドキュメント</a>を参照してください。</td></tr><tr><td scope="row">C</td><td>C API</td><td><code class="literal">libmysqlclient</code></td><td><a class="xref" href="connectors-apis.html#c-api" title="23.8 MySQL C API">セクション23.8「MySQL C API」</a>を参照してください。</td></tr><tr><td scope="row">C</td><td>Connector/C</td><td><code class="literal">libmysqlclient</code> の代替</td><td>「<a class="ulink" href="http://dev.mysql.com/doc/connector-c/en/index.html" target="_top">MySQL Connector/C Developer Guide</a>」を参照してください。</td></tr><tr><td scope="row">C++</td><td>Connector/C++</td><td><code class="literal">libmysqlclient</code></td><td>「<a class="ulink" href="http://dev.mysql.com/doc/connector-cpp/en/index.html" target="_top">MySQL Connector/C++ Developer Guide</a>」を参照してください。</td></tr><tr><td scope="row"> </td><td>MySQL++</td><td><code class="literal">libmysqlclient</code></td><td><a class="ulink" href="http://tangentsoft.net/mysql++/doc/" target="_top">MySQL++ の Web サイト</a>を参照してください。</td></tr><tr><td scope="row"> </td><td>MySQL wrapped</td><td><code class="literal">libmysqlclient</code></td><td>「<a class="ulink" href="http://www.alhem.net/project/mysql/" target="_top">MySQL wrapped</a>」を参照してください。</td></tr><tr><td scope="row">Cocoa</td><td>MySQL-Cocoa</td><td><code class="literal">libmysqlclient</code></td><td>Objective-C Cocoa 環境と互換性があります。<a class="ulink" href="http://mysql-cocoa.sourceforge.net/" target="_top">http://mysql-cocoa.sourceforge.net/</a> を参照してください。</td></tr><tr><td scope="row">D</td><td>MySQL for D</td><td><code class="literal">libmysqlclient</code></td><td><a class="ulink" href="http://www.steinmole.de/d/" target="_top">MySQL for D</a> を参照してください。</td></tr><tr><td scope="row">Eiffel</td><td>Eiffel MySQL</td><td><code class="literal">libmysqlclient</code></td><td><a class="xref" href="connectors-apis.html#apis-eiffel" title="23.14 MySQL Eiffel ラッパー">セクション23.14「MySQL Eiffel ラッパー」</a>を参照してください。</td></tr><tr><td scope="row">Erlang</td><td><code class="literal">erlang-mysql-driver</code></td><td><code class="literal">libmysqlclient</code></td><td>「<a class="ulink" href="http://code.google.com/p/erlang-mysql-driver/" target="_top"><code class="literal">erlang-mysql-driver</code></a>」を参照してください。</td></tr><tr><td scope="row">Haskell</td><td>Haskell MySQL バインディング</td><td>ネイティブドライバ</td><td><a class="ulink" href="http://www.serpentine.com/blog/software/mysql/" target="_top">Brian O'Sullivan のピュア Haskell MySQL バインディングに関するドキュメント</a>を参照してください。</td></tr><tr><td scope="row"> </td><td><code class="literal">hsql-mysql</code></td><td><code class="literal">libmysqlclient</code></td><td><a class="ulink" href="http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hsql-mysql-1.7" target="_top">Haskell 用の MySQL ドライバに関するドキュメント</a>を参照してください。</td></tr><tr><td scope="row">Java/JDBC</td><td>Connector/J</td><td>ネイティブドライバ</td><td>「<a class="ulink" href="http://dev.mysql.com/doc/connector-j/en/index.html" target="_top">MySQL Connector/J Developer Guide</a>」を参照してください。</td></tr><tr><td scope="row">Kaya</td><td>MyDB</td><td><code class="literal">libmysqlclient</code></td><td><a class="ulink" href="http://kayalang.org/library/latest/MyDB" target="_top">MyDB に関するドキュメント</a>を参照してください。</td></tr><tr><td scope="row">Lua</td><td>LuaSQL</td><td><code class="literal">libmysqlclient</code></td><td><a class="ulink" href="http://www.keplerproject.org/luasql/" target="_top">LuaSQL</a> に関するドキュメントを参照してください。</td></tr><tr><td scope="row">.NET/Mono</td><td>Connector/Net</td><td>ネイティブドライバ</td><td>「<a class="ulink" href="http://dev.mysql.com/doc/connector-net/en/index.html" target="_top">MySQL Connector/Net Developer Guide</a>」を参照してください。</td></tr><tr><td scope="row">Objective Caml</td><td>OBjective Caml MySQL バインディング</td><td><code class="literal">libmysqlclient</code></td><td><a class="ulink" href="http://raevnos.pennmush.org/code/ocaml-mysql/" target="_top">Objective Caml 用の MySQL バインディングに関するドキュメント</a>を参照してください。</td></tr><tr><td scope="row">Octave</td><td>GNU Octave 用データベースバインディング</td><td><code class="literal">libmysqlclient</code></td><td><a class="ulink" href="http://octave.sourceforge.net/database/index.html" target="_top">GNU Octave 用データベースバインディングに関するドキュメント</a>を参照してください。</td></tr><tr><td scope="row">ODBC</td><td>Connector/ODBC</td><td><code class="literal">libmysqlclient</code></td><td>「<a class="ulink" href="http://dev.mysql.com/doc/connector-odbc/en/index.html" target="_top">MySQL Connector/ODBC Developer Guide</a>」を参照してください。</td></tr><tr><td scope="row">Perl</td><td><code class="literal">DBI</code>/<code class="literal">DBD::mysql</code></td><td><code class="literal">libmysqlclient</code></td><td><a class="xref" href="connectors-apis.html#apis-perl" title="23.10 MySQL Perl API">セクション23.10「MySQL Perl API」</a>を参照してください。</td></tr><tr><td scope="row"> </td><td><code class="literal">Net::MySQL</code></td><td>ネイティブドライバ</td><td>CPAN の「<a class="ulink" href="http://search.cpan.org/dist/Net-MySQL/MySQL.pm" target="_top"><code class="literal">Net::MySQL</code></a>」を参照してください。</td></tr><tr><td scope="row">PHP</td><td><code class="literal">mysql</code>、<code class="literal">ext/mysql</code> インタフェース (非推奨)</td><td><code class="literal">libmysqlclient</code></td><td>「<a class="ulink" href="http://dev.mysql.com/doc/apis-php/en/apis-php-mysql.html" target="_top">Original MySQL API</a>」を参照してください。</td></tr><tr><td scope="row"> </td><td><code class="literal">mysqli</code>、<code class="literal">ext/mysqli</code> インタフェース</td><td><code class="literal">libmysqlclient</code></td><td>「<a class="ulink" href="http://dev.mysql.com/doc/apis-php/en/apis-php-mysqli.html" target="_top">MySQL Improved Extension</a>」を参照してください。</td></tr><tr><td scope="row"> </td><td><code class="literal">PDO_MYSQL</code></td><td><code class="literal">libmysqlclient</code></td><td>「<a class="ulink" href="http://dev.mysql.com/doc/apis-php/en/apis-php-pdo-mysql.html" target="_top">MySQL Functions (PDO_MYSQL)</a>」を参照してください。</td></tr><tr><td scope="row"> </td><td>PDO mysqlnd</td><td>ネイティブドライバ</td><td> </td></tr><tr><td scope="row">Python</td><td>Connector/Python</td><td>ネイティブドライバ</td><td>「<a class="ulink" href="http://dev.mysql.com/doc/connector-python/en/index.html" target="_top">MySQL Connector/Python Developer Guide</a>」を参照してください。</td></tr><tr><td scope="row"> </td><td>MySQLdb</td><td><code class="literal">libmysqlclient</code></td><td><a class="xref" href="connectors-apis.html#apis-python" title="23.11 MySQL Python API">セクション23.11「MySQL Python API」</a>を参照してください。</td></tr><tr><td scope="row">Ruby</td><td>MySQL/Ruby</td><td><code class="literal">libmysqlclient</code></td><td><code class="literal">libmysqlclient</code> を使用します。<a class="xref" href="connectors-apis.html#apis-ruby-mysqlruby" title="23.12.1 MySQL/Ruby API">セクション23.12.1「MySQL/Ruby API」</a>を参照してください。</td></tr><tr><td scope="row"> </td><td>Ruby/MySQL</td><td>ネイティブドライバ</td><td><a class="xref" href="connectors-apis.html#apis-ruby-rubymysql" title="23.12.2 Ruby/MySQL API">セクション23.12.2「Ruby/MySQL API」</a>を参照してください。</td></tr><tr><td scope="row">Scheme</td><td><code class="literal">Myscsh</code></td><td><code class="literal">libmysqlclient</code></td><td><a class="ulink" href="http://www-pu.informatik.uni-tuebingen.de/users/knauel/myscsh/" target="_top"><code class="literal">Myscsh</code> に関するドキュメント</a>を参照してください。</td></tr><tr><td scope="row">SPL</td><td><code class="literal">sql_mysql</code></td><td><code class="literal">libmysqlclient</code></td><td><a class="ulink" href="http://www.clifford.at/spl/spldoc/sql_mysql.html" target="_top">SPL の <code class="literal">sql_mysql</code></a> を参照してください。</td></tr><tr><td scope="row">Tcl</td><td>MySQLtcl</td><td><code class="literal">libmysqlclient</code></td><td><a class="xref" href="connectors-apis.html#apis-tcl" title="23.13 MySQL Tcl API">セクション23.13「MySQL Tcl API」</a>を参照してください。</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="connectors-apis-versions"></a><p class="title"><b>表 23.2 MySQL Connector のバージョンと MySQL Server のバージョン</b></p><div class="table-contents"><table summary="MySQL Connector のバージョンと MySQL Server のバージョン" border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">Connector</th><th scope="col">Connector のバージョン</th><th scope="col">MySQL Server のバージョン</th></tr></thead><tbody><tr><td scope="row">Connector/C</td><td>6.1.0 GA</td><td>5.6、5.5、5.1、5.0、4.1</td></tr><tr><td scope="row">Connector/C++</td><td>1.0.5 GA</td><td>5.6、5.5、5.1</td></tr><tr><td scope="row">Connector/J</td><td>5.1.8</td><td>5.6、5.5、5.1、5.0、4.1</td></tr><tr><td scope="row">Connector/Net</td><td>6.5</td><td>5.6、5.5、5.1、5.0</td></tr><tr><td scope="row">Connector/Net</td><td>6.4</td><td>5.6、5.5、5.1、5.0</td></tr><tr><td scope="row">Connector/Net</td><td>6.3</td><td>5.6、5.5、5.1、5.0</td></tr><tr><td scope="row">Connector/Net</td><td>6.2 (サポートされなくなりました)</td><td>5.6、5.5、5.1、5.0</td></tr><tr><td scope="row">Connector/Net</td><td>6.1 (サポートされなくなりました)</td><td>5.6、5.5、5.1、5.0</td></tr><tr><td scope="row">Connector/Net</td><td>6.0 (サポートされなくなりました)</td><td>5.6、5.5、5.1、5.0</td></tr><tr><td scope="row">Connector/Net</td><td>5.2 (サポートされなくなりました)</td><td>5.6、5.5、5.1、5.0</td></tr><tr><td scope="row">Connector/Net</td><td>1.0 (サポートされなくなりました)</td><td>5.0、4.0</td></tr><tr><td scope="row">Connector/ODBC</td><td>5.1</td><td>5.6、5.5、5.1、5.0、4.1.1+</td></tr><tr><td scope="row">Connector/ODBC</td><td>3.51 (Unicode はサポートされていません)</td><td>5.6、5.5、5.1、5.0、4.1</td></tr></tbody></table></div></div><br class="table-break"><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="connector-odbc-info"></a>23.1 MySQL Connector/ODBC</h2></div></div></div><a class="indexterm" name="idm139979003683904"></a><p>
    MySQL Connector/ODBC のマニュアルは、MySQL リファレンスマニュアルの一部としてではなく、スタンドアロン形式で発行されるようになりました。詳細については、これらのドキュメントを参照してください。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        主要マニュアル: <a class="ulink" href="http://dev.mysql.com/doc/connector-odbc/en/index.html" target="_top">MySQL Connector/ODBC Developer Guide</a>
      </p></li><li class="listitem"><p>
        リリースノート: <a class="ulink" href="http://dev.mysql.com/doc/relnotes/connector-odbc/en/" target="_top">MySQL Connector/ODBC リリースノート</a>
      </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="connector-net-info"></a>23.2 MySQL Connector/Net</h2></div></div></div><a class="indexterm" name="idm139979003676496"></a><p>
    MySQL Connector/Net のマニュアルは、MySQL リファレンスマニュアルの一部としてではなく、スタンドアロン形式で発行されるようになりました。詳細については、これらのドキュメントを参照してください。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        主要マニュアル: <a class="ulink" href="http://dev.mysql.com/doc/connector-net/en/index.html" target="_top">MySQL Connector/Net Developer Guide</a>
      </p></li><li class="listitem"><p>
        リリースノート: <a class="ulink" href="http://dev.mysql.com/doc/relnotes/connector-net/en/" target="_top">MySQL Connector/Net リリースノート</a>
      </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="connector-j-info"></a>23.3 MySQL Connector/J</h2></div></div></div><a class="indexterm" name="idm139979003669024"></a><a class="indexterm" name="idm139979003667712"></a><p>
    MySQL Connector/J のマニュアルは、MySQL リファレンスマニュアルの一部としてではなく、スタンドアロン形式で発行されるようになりました。詳細については、これらのドキュメントを参照してください。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        主要マニュアル: <a class="ulink" href="http://dev.mysql.com/doc/connector-j/en/index.html" target="_top">MySQL Connector/J Developer Guide</a>
      </p></li><li class="listitem"><p>
        リリースノート: <a class="ulink" href="http://dev.mysql.com/doc/relnotes/connector-j/en/" target="_top">MySQL Connector/J リリースノート</a>
      </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="connector-cpp-info"></a>23.4 MySQL Connector/C++</h2></div></div></div><a class="indexterm" name="idm139979003660208"></a><a class="indexterm" name="idm139979003658896"></a><p>
    MySQL Connector/C++ のマニュアルは、MySQL リファレンスマニュアルの一部としてではなく、スタンドアロン形式で発行されるようになりました。詳細については、これらのドキュメントを参照してください。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        主要マニュアル: <a class="ulink" href="http://dev.mysql.com/doc/connector-cpp/en/index.html" target="_top">MySQL Connector/C++ Developer Guide</a>
      </p></li><li class="listitem"><p>
        リリースノート: <a class="ulink" href="http://dev.mysql.com/doc/relnotes/connector-cpp/en/" target="_top">MySQL Connector/C++ リリースノート</a>
      </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="connector-c-info"></a>23.5 MySQL Connector/C</h2></div></div></div><a class="indexterm" name="idm139979003651424"></a><p>
    MySQL Connector/C のマニュアルは、MySQL リファレンスマニュアルの一部としてではなく、スタンドアロン形式で発行されるようになりました。詳細については、これらのドキュメントを参照してください。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        主要マニュアル: <a class="ulink" href="http://dev.mysql.com/doc/connector-c/en/index.html" target="_top">MySQL Connector/C Developer Guide</a>
      </p></li><li class="listitem"><p>
        リリースノート: <a class="ulink" href="http://dev.mysql.com/doc/relnotes/connector-c/en/" target="_top">MySQL Connector/C リリースノート</a>
      </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="connector-python-info"></a>23.6 MySQL Connector/Python</h2></div></div></div><a class="indexterm" name="idm139979003643936"></a><a class="indexterm" name="idm139979003642624"></a><p>
    MySQL Connector/Python のマニュアルは、MySQL リファレンスマニュアルの一部としてではなく、スタンドアロン形式で発行されるようになりました。詳細については、これらのドキュメントを参照してください。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        主要マニュアル: <a class="ulink" href="http://dev.mysql.com/doc/connector-python/en/index.html" target="_top">MySQL Connector/Python Developer Guide</a>
      </p></li><li class="listitem"><p>
        リリースノート: <a class="ulink" href="http://dev.mysql.com/doc/relnotes/connector-python/en/" target="_top">MySQL Connector/Python リリースノート</a>
      </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="libmysqld"></a>23.7 組み込み MySQL サーバーライブラリ libmysqld</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="connectors-apis.html#libmysqld-compiling">23.7.1 libmysqld によるプログラムのコンパイル</a></span></dt><dt><span class="section"><a href="connectors-apis.html#libmysqld-restrictions">23.7.2 組み込み MySQL サーバーを使用する場合の制限</a></span></dt><dt><span class="section"><a href="connectors-apis.html#libmysqld-options">23.7.3 組み込みサーバーとオプション</a></span></dt><dt><span class="section"><a href="connectors-apis.html#libmysqld-example">23.7.4 組み込みサーバーの例</a></span></dt></dl></div><a class="indexterm" name="idm139979003635344"></a><a class="indexterm" name="idm139979003634032"></a><p>
    組み込み MySQL サーバーライブラリは、クライアントアプリケーション内で、完全な機能を備えた MySQL サーバーを実行できるようにします。この主なメリットは組み込みアプリケーションの速度の向上と管理の単純化です。
  </p><p>
    組み込みサーバーライブラリは、C/C++ で書かれている MySQL のクライアント/サーバーバージョンに基づいています。そのため、組み込みサーバーも C/C++ で書かれています。ほかの言語で利用可能な組み込みサーバーはありません。
  </p><p>
    API は組み込み MySQL バージョンとクライアント/サーバーバージョンで同じです。組み込みライブラリを使用するようにスレッドアプリケーションを変更するには、通常次の関数への呼び出しを追加する必要があるだけです。
  </p><div class="table"><a name="refman-apis-libmysqld-mysql-server-library-embeded-functions"></a><p class="title"><b>表 23.3 MySQL 組み込みサーバーライブラリ関数</b></p><div class="table-contents"><table summary="この表は、MySQL 組み込みサーバーライブラリ関数を一覧表示し、関数を呼び出すべきタイミングについて説明しています。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col"><p>
              関数
            </p></th><th scope="col"><p>
              呼び出すタイミング
            </p></th></tr></thead><tbody><tr><td scope="row"><p>
              <code class="literal">mysql_library_init()</code>
            </p></td><td><p>
              ほかの MySQL 関数が呼び出される前、できれば <code class="literal">main()</code> 関数の早期に呼び出します。
            </p></td></tr><tr><td scope="row"><p>
              <code class="literal">mysql_library_end()</code>
            </p></td><td><p>
              プログラムが終了する前に呼び出します。
            </p></td></tr><tr><td scope="row"><p>
              <code class="literal">mysql_thread_init()</code>
            </p></td><td><p>
              MySQL にアクセスする、作成する各スレッド内で呼び出します。
            </p></td></tr><tr><td scope="row"><code class="literal">mysql_thread_end()</code></td><td><code class="literal">pthread_exit()</code> を呼び出す前に、呼び出します。</td></tr></tbody></table></div></div><br class="table-break"><p>
    次に、コードを <code class="filename">libmysqlclient.a</code> の代わりに <code class="filename">libmysqld.a</code> とリンクします。アプリケーションとサーバーライブラリ間のバイナリ互換性を確保するには、常に、サーバーライブラリのコンパイルに使用された同じ一連の MySQL のヘッダーに対してアプリケーションをコンパイルします。たとえば、<code class="literal">libmysqld</code> が MySQL 5.1 ヘッダーに対してコンパイルされていた場合、アプリケーションを MySQL 5.5 ヘッダーに対してコンパイルしないでください。また逆も同様です。
  </p><p>
    <code class="literal">mysql_library_<em class="replaceable"><code>xxx</code></em>()</code> 関数は <code class="filename">libmysqlclient.a</code> にも含まれているため、アプリケーションを正しいライブラリとリンクするだけで、組み込みバージョンとクライアント/サーバーバージョン間の変更が可能です。<a class="xref" href="connectors-apis.html#mysql-library-init" title="23.8.7.40 mysql_library_init()">セクション23.8.7.40「mysql_library_init()」</a>を参照してください。
  </p><p>
    組み込みサーバーとスタンドアロンサーバーの 1 つの違いは、組み込みサーバーの場合、接続のための認証がデフォルトで無効にされていることです。
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="libmysqld-compiling"></a>23.7.1 libmysqld によるプログラムのコンパイル</h3></div></div></div><p>
      組み込みサーバーライブラリ <code class="literal">libmysqld</code> を含むプリコンパイル済みのバイナリ MySQL 配布では、MySQL は、適切なベンダーコンパイラがあればそれを使用して、ライブラリを構築します。
    </p><p>
      自分でソースから MySQL を構築する場合に、<code class="literal">libmysqld</code> ライブラリを取得するには、<code class="option">-DWITH_EMBEDDED_SERVER=1</code> オプションを使用して、MySQL を構成してください。<a class="xref" href="installing.html#source-configuration-options" title="2.9.4 MySQL ソース構成オプション">セクション2.9.4「MySQL ソース構成オプション」</a>を参照してください。
    </p><p>
      プログラムを <code class="literal">libmysqld</code> とリンクさせる場合、システム固有の <code class="literal">pthread</code> ライブラリおよび MySQL サーバーが使用するいくつかのライブラリも含める必要があります。<span class="command"><strong>mysql_config --libmysqld-libs</strong></span> を実行して、ライブラリの完全なリストを取得できます。
    </p><p>
      コードでスレッド関数を直接呼び出さない場合でも、スレッドプログラムをコンパイルし、リンクするための正しいフラグを使用する必要があります。
    </p><p>
      C プログラムをコンパイルして、MySQL サーバーライブラリをプログラムの実行可能バージョンに組み込むために必要なファイルを含めるには、コンパイラは各種ファイルを見つける場所を知る必要があり、プログラムのコンパイル方法についての指示を必要とします。次の例に、GNU C コンパイラ <span class="command"><strong>gcc</strong></span> を使用するものとして、コマンド行からプログラムをコンパイルする方法を示します。
    </p><pre class="programlisting">
gcc mysql_test.c -o mysql_test \
`/usr/local/mysql/bin/mysql_config --include --libmysqld-libs`
</pre><p>
      <span class="command"><strong>gcc</strong></span> コマンドの直後は、C プログラムソースファイルの名前です。その後に、<code class="option">-o</code> オプションを指定して、後続のファイル名が、コンパイラが出力ファイルのコンパイル済みプログラムに指定することになる名前であることを示します。コードの次の行は、コンパイラにインクルードファイルおよびライブラリ、それがコンパイルされるシステムのその他の設定の場所を取得するように伝えます。<span class="command"><strong>mysql_config</strong></span> コマンドは、単一引用符ではなく、逆引用符で囲みます。
    </p><p>
      一部の <span class="command"><strong>gcc</strong></span> 以外のプラットフォームでは、組み込みライブラリは C++ 実行時ライブラリに依存するため、組み込みライブラリに対してリンクすると、シンボルなしエラーが発生することがあります。これを解決するには、C++ コンパイラを使用してリンクするか、リンクコマンド行で、必要なライブラリを明示的に挙げます。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="libmysqld-restrictions"></a>23.7.2 組み込み MySQL サーバーを使用する場合の制限</h3></div></div></div><p>
      組み込みサーバーには次の制限があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ユーザー定義関数 (UDF) なし。
        </p></li><li class="listitem"><p>
          コアダンプへのスタックトレースなし。
        </p></li><li class="listitem"><p>
          これをマスターまたはスレーブ (レプリケーションなし) としてセットアップできません。
        </p></li><li class="listitem"><p>
          著しく大きい結果セットはメモリーの少ないシステムで使用できないことがあります。
        </p></li><li class="listitem"><p>
          ソケットまたは TCP/IP を使用して、外部プロセスから組み込みサーバーに接続することはできません。ただし、ユーザーは中間アプリケーションに接続することができ、それが次にリモートクライアントや外部プロセスに代わって、組み込みサーバーに接続することができます。
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> は組み込みサーバーに再入可能でなく、連続でも同時でも複数の接続に使用することはできません。
        </p></li><li class="listitem"><p>
          イベントスケジューラは使用できません。このため、<code class="literal">event_scheduler</code> システム変数が無効にされます。
        </p></li></ul></div><p>
      これらの制限の一部は、<code class="filename">mysql_embed.h</code> インクルードファイルを編集し、MySQL を再コンパイルすることによって変更できます。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="libmysqld-options"></a>23.7.3 組み込みサーバーとオプション</h3></div></div></div><a class="indexterm" name="idm139979003572832"></a><a class="indexterm" name="idm139979003570720"></a><a class="indexterm" name="idm139979003568656"></a><a class="indexterm" name="idm139979003566736"></a><p>
      <span class="command"><strong>mysqld</strong></span> サーバーデーモンで指定できるすべてのオプションは、組み込みサーバーライブラリと一緒に使用できます。サーバーオプションは、サーバーを初期化する <code class="literal">mysql_library_init()</code> への引数として、配列で指定できます。それらは、<code class="filename">my.cnf</code> のようなオプションファイルに指定することもできます。C プログラムにオプションファイルを指定するには、<code class="option">--defaults-file</code> オプションを <code class="literal">mysql_library_init()</code> 関数の 2 番目の引数の要素の 1 つとして使用します。<code class="literal">mysql_library_init()</code> 関数に関する詳細については、<a class="xref" href="connectors-apis.html#mysql-library-init" title="23.8.7.40 mysql_library_init()">セクション23.8.7.40「mysql_library_init()」</a>を参照してください。
    </p><p>
      オプションファイルを使用すると、クライアント/サーバーアプリケーションと MySQL が組み込まれているものとの間の切り替えを容易にすることができます。共通オプションを <code class="literal">[server]</code> グループの下に置きます。これらは両方の MySQL バージョンによって読み取られます。クライアント/サーバー固有のオプションは <code class="literal">[mysqld]</code> セクションの下に置いてください。組み込み MySQL サーバーライブラリに固有のオプションは <code class="literal">[embedded]</code> セクションに置きます。アプリケーションに固有なオプションは、<code class="literal">[ApplicationName_SERVER]</code> とラベル付けされたセクションの下に置きます。<a class="xref" href="programs.html#option-files" title="4.2.6 オプションファイルの使用">セクション4.2.6「オプションファイルの使用」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="libmysqld-example"></a>23.7.4 組み込みサーバーの例</h3></div></div></div><p>
      これらの 2 つのプログラム例は、Linux または FreeBSD システムを変更せずに、機能するはずです。その他のオペレーティングシステムでは、たいていファイルパスによる小さな変更が必要です。これらの例は、実際のアプリケーションの必要部分である余計なものなしに、問題を理解するために十分な詳細を与えるように設計されています。最初の例は、きわめて単純です。2 番目の例は、いくつかのエラーチェックを伴うやや高度なものです。最初のもののあとに、プログラムをコンパイルするためのコマンド行エントリが続いています。2 つ目のあとには、代わりにコンパイルに使用できる GNU メイクファイルが続いています。
    </p><p>
      <span class="bold"><strong>例 1</strong></span>
    </p><p>
      <code class="filename">test1_libmysqld.c</code>
    </p><pre class="programlisting">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdarg.h&gt;
#include "mysql.h"

MYSQL *mysql;
MYSQL_RES *results;
MYSQL_ROW record;

static char *server_options[] = \
       { "mysql_test", "--defaults-file=my.cnf", NULL };
int num_elements = (sizeof(server_options) / sizeof(char *)) - 1;

static char *server_groups[] = { "libmysqld_server",
                                 "libmysqld_client", NULL };

int main(void)
{
   mysql_library_init(num_elements, server_options, server_groups);
   mysql = mysql_init(NULL);
   mysql_options(mysql, MYSQL_READ_DEFAULT_GROUP, "libmysqld_client");
   mysql_options(mysql, MYSQL_OPT_USE_EMBEDDED_CONNECTION, NULL);

   mysql_real_connect(mysql, NULL,NULL,NULL, "database1", 0,NULL,0);

   mysql_query(mysql, "SELECT column1, column2 FROM table1");

   results = mysql_store_result(mysql);

   while((record = mysql_fetch_row(results))) {
      printf("%s - %s \n", record[0], record[1]);
   }

   mysql_free_result(results);
   mysql_close(mysql);
   mysql_library_end();

   return 0;
}
</pre><p>
      これは、上のプログラムをコンパイルするためのコマンド行です。
    </p><pre class="programlisting">
gcc test1_libmysqld.c -o test1_libmysqld \
 `/usr/local/mysql/bin/mysql_config --include --libmysqld-libs`
</pre><p>
      <span class="bold"><strong>例 2</strong></span>
    </p><p>
      例を試してみるには、MySQL ソースディレクトリと同じレベルで <code class="filename">test2_libmysqld</code> ディレクトリを作成します。<code class="filename">test2_libmysqld.c</code> ソースと <code class="filename">GNUmakefile</code> をこのディレクトリに保存し、<code class="filename">test2_libmysqld</code> ディレクトリ内から GNU <code class="filename">make</code> を実行します。
    </p><p>
      <code class="filename">test2_libmysqld.c</code>
    </p><pre class="programlisting">
/*
 * A simple example client, using the embedded MySQL server library
*/

#include &lt;mysql.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

MYSQL *db_connect(const char *dbname);
void db_disconnect(MYSQL *db);
void db_do_query(MYSQL *db, const char *query);

const char *server_groups[] = {
  "test2_libmysqld_SERVER", "embedded", "server", NULL
};

int
main(int argc, char **argv)
{
  MYSQL *one, *two;

  /* mysql_library_init() must be called before any other mysql
   * functions.
   *
   * You can use mysql_library_init(0, NULL, NULL), and it
   * initializes the server using groups = {
   *   "server", "embedded", NULL
   *  }.
   *
   * In your $HOME/.my.cnf file, you probably want to put:

[test2_libmysqld_SERVER]
language = /path/to/source/of/mysql/sql/share/english

   * You could, of course, modify argc and argv before passing
   * them to this function.  Or you could create new ones in any
   * way you like.  But all of the arguments in argv (except for
   * argv[0], which is the program name) should be valid options
   * for the MySQL server.
   *
   * If you link this client against the normal mysqlclient
   * library, this function is just a stub that does nothing.
   */
  mysql_library_init(argc, argv, (char **)server_groups);

  one = db_connect("test");
  two = db_connect(NULL);

  db_do_query(one, "SHOW TABLE STATUS");
  db_do_query(two, "SHOW DATABASES");

  mysql_close(two);
  mysql_close(one);

  /* This must be called after all other mysql functions */
  mysql_library_end();

  exit(EXIT_SUCCESS);
}

static void
die(MYSQL *db, char *fmt, ...)
{
  va_list ap;
  va_start(ap, fmt);
  vfprintf(stderr, fmt, ap);
  va_end(ap);
  (void)putc('\n', stderr);
  if (db)
    db_disconnect(db);
  exit(EXIT_FAILURE);
}

MYSQL *
db_connect(const char *dbname)
{
  MYSQL *db = mysql_init(NULL);
  if (!db)
    die(db, "mysql_init failed: no memory");
  /*
   * Notice that the client and server use separate group names.
   * This is critical, because the server does not accept the
   * client's options, and vice versa.
   */
  mysql_options(db, MYSQL_READ_DEFAULT_GROUP, "test2_libmysqld_CLIENT");
  if (!mysql_real_connect(db, NULL, NULL, NULL, dbname, 0, NULL, 0))
    die(db, "mysql_real_connect failed: %s", mysql_error(db));

  return db;
}

void
db_disconnect(MYSQL *db)
{
  mysql_close(db);
}

void
db_do_query(MYSQL *db, const char *query)
{
  if (mysql_query(db, query) != 0)
    goto err;

  if (mysql_field_count(db) &gt; 0)
  {
    MYSQL_RES   *res;
    MYSQL_ROW    row, end_row;
    int num_fields;

    if (!(res = mysql_store_result(db)))
      goto err;
    num_fields = mysql_num_fields(res);
    while ((row = mysql_fetch_row(res)))
    {
      (void)fputs("&gt;&gt; ", stdout);
      for (end_row = row + num_fields; row &lt; end_row; ++row)
        (void)printf("%s\t", row ? (char*)*row : "NULL");
      (void)fputc('\n', stdout);
    }
    (void)fputc('\n', stdout);
    mysql_free_result(res);
  }
  else
    (void)printf("Affected rows: %lld\n", mysql_affected_rows(db));

  return;

err:
  die(db, "db_do_query failed: %s [%s]", mysql_error(db), query);
}
</pre><p>
      <code class="filename">GNUmakefile</code>
    </p><pre class="programlisting">
# This assumes the MySQL software is installed in /usr/local/mysql
inc      := /usr/local/mysql/include/mysql
lib      := /usr/local/mysql/lib

# If you have not installed the MySQL software yet, try this instead
#inc      := $(HOME)/mysql-5.6/include
#lib      := $(HOME)/mysql-5.6/libmysqld

CC       := gcc
CPPFLAGS := -I$(inc) -D_THREAD_SAFE -D_REENTRANT
CFLAGS   := -g -W -Wall
LDFLAGS  := -static
# You can change -lmysqld to -lmysqlclient to use the
# client/server library
LDLIBS    = -L$(lib) -lmysqld -lm -ldl -lcrypt

ifneq (,$(shell grep FreeBSD /COPYRIGHT 2&gt;/dev/null))
# FreeBSD
LDFLAGS += -pthread
else
# Assume Linux
LDLIBS += -lpthread
endif

# This works for simple one-file test programs
sources := $(wildcard *.c)
objects := $(patsubst %c,%o,$(sources))
targets := $(basename $(sources))

all: $(targets)

clean:
        rm -f $(targets) $(objects) *.core
</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="c-api"></a>23.8 MySQL C API</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="connectors-apis.html#c-api-implementations">23.8.1 MySQL C API の実装</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-multiple-installations">23.8.2 MySQL サーバーと MySQL Connector/C の同時インストール</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-example-programs">23.8.3 C API クライアントプログラムの例</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-building-running-clients">23.8.4 C API クライアントプログラムの構築と実行</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-data-structures">23.8.5 C API データ構造</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-function-overview">23.8.6 C API 関数の概要</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-functions">23.8.7 C API 関数の説明</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-prepared-statements">23.8.8 C API プリペアドステートメント</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-prepared-statement-data-structures">23.8.9 C API プリペアドステートメントデータ構造</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-prepared-statement-function-overview">23.8.10 C API プリペアドステートメント関数の概要</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-prepared-statement-functions">23.8.11 C API プリペアドステートメント関数の説明</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-thread-functions">23.8.12 C API スレッド関数の説明</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-embedded-server-functions">23.8.13 C API 組み込みサーバー関数の説明</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-plugin-functions">23.8.14 C API クライアントプラグイン関数</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-problems">23.8.15 C API を使用する場合の一般的な質問と問題</a></span></dt><dt><span class="section"><a href="connectors-apis.html#auto-reconnect">23.8.16 自動再接続動作の制御</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-multiple-queries">23.8.17 複数ステートメント実行の C API サポート</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-prepared-statement-problems">23.8.18 C API プリペアドステートメントの問題</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-prepared-statement-date-handling">23.8.19 C API プリペアドステートメントの日時値の処理</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-prepared-call-statements">23.8.20 C API のプリペアド CALL ステートメントのサポート</a></span></dt></dl></div><a class="indexterm" name="idm139979003526608"></a><a class="indexterm" name="idm139979003524464"></a><p>
    C API は、MySQL クライアント/サーバープロトコルへの低レベルアクセスを提供し、C プログラムがデータベースの内容にアクセスできるようにします。C API コードは MySQL とともに配布され、<code class="literal">libmysqlclient</code> ライブラリに実装されています。<a class="xref" href="connectors-apis.html#c-api-implementations" title="23.8.1 MySQL C API の実装">セクション23.8.1「MySQL C API の実装」</a>を参照してください。
  </p><p>
    ほかのほとんどのクライアント API は <code class="literal">libmysqlclient</code> ライブラリを使用して、MySQL サーバーと通信します。(例外は Connector/J および Connector/Net です。)これは、たとえば、ほかのクライアントプログラムによって使用されている多くの同じ環境変数を利用できることを意味します。それらは、ライブラリから参照されているためです。これらの環境変数のリストについては、<a class="xref" href="programs.html#programs-overview" title="4.1 MySQL プログラムの概要">セクション4.1「MySQL プログラムの概要」</a>を参照してください。
  </p><p>
    C API を使用してクライアントプログラムを構築する手順については、<a class="xref" href="connectors-apis.html#c-api-building-clients" title="23.8.4.1 C API クライアントプログラムの構築">セクション23.8.4.1「C API クライアントプログラムの構築」</a>を参照してください。スレッドによるプログラミングについては、<a class="xref" href="connectors-apis.html#c-api-threaded-clients" title="23.8.4.2 C API スレッドクライアントプログラムの作成">セクション23.8.4.2「C API スレッドクライアントプログラムの作成」</a>を参照してください。「サーバー」と「クライアント」を同じプログラムに含む (および外部 MySQL サーバーと通信しない) スタンドアロンアプリケーションを作成するには、<a class="xref" href="connectors-apis.html#libmysqld" title="23.7 組み込み MySQL サーバーライブラリ libmysqld">セクション23.7「組み込み MySQL サーバーライブラリ libmysqld」</a>を参照してください。
  </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
      アップグレード後に、コンパイル済みのクライアントプログラムに、<code class="literal">「コマンドは同期されていません」</code>または予期しないコアダンプなどの問題が発生した場合は、プログラムが古いヘッダーファイルまたはライブラリファイルを使用してコンパイルされた可能性があります。この場合、コンパイルに使用された <code class="filename">mysql.h</code> ファイルおよび <code class="filename">libmysqlclient.a</code> ライブラリの日付をチェックして、それらが新しい MySQL 配布からのものであることを確認します。そうでない場合には、プログラムを新しいヘッダーおよびライブラリで再コンパイルします。ライブラリのメジャーバージョン番号が変更された (<code class="filename">libmysqlclient.so.17</code> から <code class="filename">libmysqlclient.so.18</code> など) 場合に、共有クライアントライブラリに対してコンパイルされているプログラムでも、再コンパイルが必要になる可能性があります。追加の互換性情報については、<a class="xref" href="connectors-apis.html#c-api-running-clients" title="23.8.4.3 C API クライアントプログラムの実行">セクション23.8.4.3「C API クライアントプログラムの実行」</a>を参照してください。
    </p></div><p>
    クライアントは最大の通信バッファーサイズを持ちます。最初に割り当てられるバッファーのサイズ (16K バイト) は最大サイズ (デフォルトで 16M バイト) まで自動的に増やされます。バッファーサイズは、必要に応じてのみ増やされるため、最大制限を単純に増やしても、それ自体で使用されるリソースが増えるわけではありません。このサイズチェックは、主に誤ったステートメントと通信パケットに対する予防措置です。
  </p><p>
    通信バッファーは、単一の SQL ステートメント (クライアントからサーバーへのトラフィックの) と 1 行の返されるデータ (サーバーからクライアントへのトラフィックの) を格納するために十分な大きさがある必要があります。各セッションの通信バッファーは、クエリーまたは行を処理するために、最大制限まで動的に拡大されます。たとえば、16M バイトまでのデータを格納する <code class="literal">BLOB</code> 値がある場合、少なくとも 16M バイトの通信バッファー制限が必要です (サーバーとクライアントの両方で)。クライアントライブラリに組み込まれたデフォルトの最大は 1G バイトですが、サーバーでのデフォルトの最大は 1M バイトです。これを増やすには、サーバー起動時に <code class="literal">max_allowed_packet</code> パラメータの値を変更します。<a class="xref" href="optimization.html#server-parameters" title="8.11.2 サーバーパラメータのチューニング">セクション8.11.2「サーバーパラメータのチューニング」</a>を参照してください。
  </p><p>
    MySQL サーバーは各クエリー後、各通信バッファーを <code class="literal">net_buffer_length</code> バイトに縮小します。クライアントでは、接続に関連付けられたバッファーのサイズは接続がクローズされるまで減らされません。その時点で、クライアントのメモリーが再利用されます。
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-implementations"></a>23.8.1 MySQL C API の実装</h3></div></div></div><p>
      MySQL C API は、C で書かれたクライアントアプリケーションが MySQL サーバーとの通信に使用できる C ベースの API です。クライアントプログラムはコンパイル時に C API ヘッダーを参照し、リンク時に C API ライブラリファイルにリンクします。ライブラリは、アプリケーションがサーバーとどのように通信することを意図しているかに応じて、2 つのバージョンで提供されています。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">libmysqlclient</code>: スタンドアロンサーバープロセスのクライアントとして、ネットワーク接続経由で通信するアプリケーションで使用される、ライブラリのクライアントバージョン。
        </p></li><li class="listitem"><p>
          <code class="literal">libmysqld</code>: アプリケーション自体の中に組み込み MySQL サーバーを含めることを目的としたアプリケーションで使用される、ライブラリの組み込みサーバーバージョン。アプリケーションはその独自のプライベートサーバーインスタンスと通信します。
        </p></li></ul></div><p>
      どちらのライブラリも同じインタフェースを持ちます。C API 呼び出しに関して、アプリケーションは、組み込みサーバーと通信する同じ方法で、スタンドアロンサーバーと通信します。特定のクライアントを、構築時に <code class="literal">libmysqlclient</code> に対してリンクするか、<code class="literal">libmysqld</code> に対してリンクするかに応じて、スタンドアロンまたは組み込みサーバーと通信するように構築できます。
    </p><p>
      C API クライアントプログラムの構築に必要な C API ヘッダーおよびライブラリファイルを取得するには、2 つの方法があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          MySQL サーバー配布をインストールします。サーバー配布には <code class="literal">libmysqlclient</code> と <code class="literal">libmysqld</code> の両方が含まれています。
        </p></li><li class="listitem"><p>
          MySQL Connector/C 配布をインストールします。Connector/C 配布には <code class="literal">libmysqlclient</code> のみ含まれます。それらには <code class="literal">libmysqld</code> は含まれません。
        </p></li></ul></div><p>
      MySQL サーバーと MySQL Connector/C のどちらでも、事前構築された C API ファイルを含むバイナリ配布をインストールするか、ソース配布を使用して、自分で C API ファイルを構築できます。
    </p><p>
      通常、MySQL サーバー配布または MySQL Connector/C 配布のいずれかをインストールし、両方はインストールしません。MySQL サーバーと MySQL Connector/C の同時インストールに伴う問題については、<a class="xref" href="connectors-apis.html#c-api-multiple-installations" title="23.8.2 MySQL サーバーと MySQL Connector/C の同時インストール">セクション23.8.2「MySQL サーバーと MySQL Connector/C の同時インストール」</a>を参照してください。
    </p><p>
      C API クライアントアプリケーションのリンク時に使用するライブラリファイルの名前は、ライブラリの種類と配布が構築されるプラットフォームによって異なります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          Unix (および Unix に類似する) システムで、静的ライブラリは <code class="filename">libmysqlclient.a</code> です。動的ライブラリはほとんどの Unix システムで <code class="filename">libmysqlclient.so</code> および OS X で <code class="filename">libmysqlclient.dylib</code> です。
        </p><p>
          組み込みサーバーライブラリを含む配布の場合、対応するライブラリ名は <code class="literal">libmysqlclient</code> ではなく、<code class="literal">libmysqld</code> から始まります。
        </p></li><li class="listitem"><p>
          Windows では、静的ライブラリは <code class="filename">mysqlclient.lib</code> で、動的ライブラリは <code class="filename">libmysql.dll</code> です。Windows 配布には、動的ライブラリを使用するために必要な静的インポートライブラリの <code class="filename">libmysql.lib</code> も含まれます。
        </p><p>
          組み込みサーバーライブラリを含む配布の場合、対応するライブラリ名は <code class="filename">mysqlserver.lib</code>、<code class="filename">libmysqld.dll</code>、および <code class="filename">libmysqld.lib</code> です。
        </p><p>
          Windows 配布には一連のデバッグライブラリも含まれます。これらは非デバッグライブラリと同じ名前を持ちますが、<code class="filename">lib/debug</code> ライブラリ内に置かれます。デバッグ C ランタイムを使用して構築されたクライアントのコンパイル時には、デバッグライブラリを使用する必要があります。
        </p></li></ul></div><p>
      Unix では、名前に <code class="literal">_r</code> を含むライブラリも見られることがあります。MySQL 5.5 より前では、これらは、非 <code class="literal">_r</code> ライブラリとは別にスレッドセーフ (再入可能) ライブラリとして構築されました。5.5 以降、両方のライブラリが同じになり、<code class="literal">_r</code> 名は、対応する非 <code class="literal">_r</code> 名へのシンボリックリンクになります。<code class="literal">_r</code> ライブラリを使用する必要はありません。たとえば、<span class="command"><strong>mysql_config</strong></span> を使用して、リンカーフラグを取得する場合、スレッドクライアントでも、すべての場合に <span class="command"><strong>mysql_config --libs</strong></span> を使用できます。<span class="command"><strong>mysql_config --libs_r</strong></span> を使用する必要はありません。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-multiple-installations"></a>23.8.2 MySQL サーバーと MySQL Connector/C の同時インストール</h3></div></div></div><p>
      MySQL サーバーと MySQL Connector/C のインストールパッケージは、どちらも MySQL C API クライアントプログラムを構築して実行するために必要なファイルを提供します。このセクションでは、両方の製品を同じシステムにインストールできる場合について説明します。一部のパッケージング形式では、これは競合せずに可能です。ほかの場合は、両方の製品を同時にインストールすることはできません。
    </p><p>
      この説明では、両方の製品に対して類似したパッケージの種類 (たとえば両方の製品に対して RPM パッケージ) を使用することを前提としています。パッケージングの種類間の共存 (一方の製品に対して RPM パッケージを使用し、他方に対して <span class="command"><strong>tar</strong></span> ファイルパッケージを使用するなど) については説明しません。Oracle によって提供されたパッケージとサードパーティーベンダーによって提供されたパッケージの共存についても説明しません。
    </p><p>
      両方の製品をインストールする場合、ヘッダーファイルとライブラリのいずれかのセットを選択するように、開発ツールや実行時環境を調整する必要があることがあります。<a class="xref" href="connectors-apis.html#c-api-building-clients" title="23.8.4.1 C API クライアントプログラムの構築">セクション23.8.4.1「C API クライアントプログラムの構築」</a>および<a class="xref" href="connectors-apis.html#c-api-running-clients" title="23.8.4.3 C API クライアントプログラムの実行">セクション23.8.4.3「C API クライアントプログラムの実行」</a>を参照してください。
    </p><p>
      <span class="command"><strong>tar</strong></span> および Zip ファイルパッケージは、それらのアンパック先のディレクトリの下にインストールされます。たとえば、MySQL サーバーと MySQL Connector/C の <span class="command"><strong>tar</strong></span> パッケージを <code class="filename">/usr/local</code> の下にアンパックでき、それらは競合せずに、個別のディレクトリ名にアンパックされます。
    </p><p>
      Windows MSI インストーラはそれらの独自のインストールディレクトリを使用するため、MySQL サーバーと MySQL Connector/C のインストーラは競合しません。
    </p><p>
      OS X DMG パッケージは、同じ親ディレクトリの下でも、異なるサブディレクトリ内にインストールされるため、競合はありません。例:
    </p><pre class="programlisting">
/usr/local/mysql-5.6.11-osx10.7-x86_64/
/usr/local/mysql-connector-c-6.1.0-osx10.7-x86/
</pre><p>
      Solaris PKG パッケージは、同じ親ディレクトリの下でも、異なるサブディレクトリ内にインストールされるため、競合はありません。例:
    </p><pre class="programlisting">
/opt/mysql/mysql
/opt/mysql/connector-c
</pre><p>
      Solaris MySQL Connector/C インストーラは、<code class="filename">/usr/bin</code> や <code class="filename">/usr/lib</code> などのシステムディレクトリから、インストールディレクトリへのシンボリックリンクを作成しません。それは、インストール後に必要に応じて、手動で行う必要があります。
    </p><p>
      RPM インストールでは、複数の種類の RPM パッケージがあります。MySQL サーバーの <code class="literal">shared</code> および <code class="literal">devel</code> RPM パッケージは対応する MySQL Connector/C RPM パッケージに似ています。MySQL サーバー RPM パッケージと MySQL Connector/C RPM パッケージは、クライアントライブラリ関連ファイルに同じインストールの場所を使用するため、これらの RPM パッケージの種類は共存できません。これは次の条件が当てはまることを意味します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          MySQL サーバー <code class="literal">shared</code> および <code class="literal">devel</code> RPM パッケージがインストールされている場合、それらは C API ヘッダーおよびライブラリを提供し、MySQL Connector/C RPM パッケージをインストールする必要はありません。とにかく MySQL Connector/C パッケージをインストールする場合は、まず対応する MySQL サーバーパッケージを削除する必要があります。
        </p></li><li class="listitem"><p>
          MySQL Connector/C RPM パッケージをすでにインストールしている場合に MySQL サーバー RPM パッケージをインストールするには、まず MySQL Connector/C RPM パッケージを削除する必要があります。
        </p></li></ul></div><p>
      <code class="literal">shared</code> および <code class="literal">devel</code> 以外の MySQL サーバー RPM パッケージは MySQL Connector/C パッケージと競合しないため、MySQL Connector/C がインストールされている場合にもインストールできます。これには <span class="command"><strong>mysqld</strong></span> サーバー自体を含むメインサーバー RPM が含まれます。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-example-programs"></a>23.8.3 C API クライアントプログラムの例</h3></div></div></div><a class="indexterm" name="idm139979003431792"></a><a class="indexterm" name="idm139979003429680"></a><p>
      <span class="command"><strong>mysql</strong></span>、<span class="command"><strong>mysqladmin</strong></span>、および <span class="command"><strong>mysqlshow</strong></span> など、MySQL ソース配布内のクライアントの多くは C で書かれています。C API の使用方法を示す例を探している場合は、これらのクライアントを調べてください。ソース配布を取得して、その <code class="literal">client</code> ディレクトリを調べます。<a class="xref" href="installing.html#getting-mysql" title="2.1.3 MySQL の取得方法">セクション2.1.3「MySQL の取得方法」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-building-running-clients"></a>23.8.4 C API クライアントプログラムの構築と実行</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="connectors-apis.html#c-api-building-clients">23.8.4.1 C API クライアントプログラムの構築</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-threaded-clients">23.8.4.2 C API スレッドクライアントプログラムの作成</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-running-clients">23.8.4.3 C API クライアントプログラムの実行</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-server-client-versions">23.8.4.4 C API サーバーおよびクライアントライブラリのバージョン</a></span></dt></dl></div><p>
      次のセクションでは、C API を使用するクライアントプログラムの構築に関する情報を提供します。トピックには、クライアントのコンパイルとリンク、スレッドクライアントの作成、および実行時の問題のトラブルシューティングが含まれます。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="c-api-building-clients"></a>23.8.4.1 C API クライアントプログラムの構築</h4></div></div></div><a class="indexterm" name="idm139979003419600"></a><a class="indexterm" name="idm139979003417472"></a><a class="indexterm" name="idm139979003416128"></a><a class="indexterm" name="idm139979003414064"></a><p>
        このセクションでは、MySQL C API を使用する C プログラムのコンパイルのガイドラインを提供します。
      </p><h5><a name="idm139979003411328"></a>Unix での MySQL クライアントのコンパイル</h5><a class="indexterm" name="idm139979003410512"></a><a class="indexterm" name="idm139979003408448"></a><p>
        MySQL ヘッダーファイルを使用するクライアントプログラムのコンパイル時に、コンパイラがそれらを見つけることができるように、<code class="option">-I</code> オプションを指定する必要がある場合があります。たとえば、ヘッダーファイルが <code class="literal">/usr/local/mysql/include</code> にインストールされている場合、コンパイルコマンドでこのオプションを使用します。
      </p><pre class="programlisting">
-I/usr/local/mysql/include
</pre><p>
        リンクコマンドで、<code class="option">-lmysqlclient</code> オプションを使用して、MySQL クライアントをリンクする必要があります。リンカーにライブラリを見つける場所を伝えるために、<code class="option">-L</code>オプションを指定する必要がある場合もあります。たとえば、ライブラリが <code class="filename">/usr/local/mysql/lib</code> にインストールされている場合、リンクコマンドでこれらのオプションを使用します。
      </p><pre class="programlisting">
-L/usr/local/mysql/lib -lmysqlclient
</pre><p>
        パス名は、使用しているシステムで異なることがあります。必要に応じて、<code class="option">-I</code> オプションと <code class="option">-L</code> オプションを調整してください。
      </p><p>
        Unix で MySQL プログラムのコンパイルを簡単にするには、<span class="command"><strong>mysql_config</strong></span> スクリプトを使用します。<a class="xref" href="programs.html#mysql-config" title="4.7.2 mysql_config — クライアントのコンパイル用オプションの表示">セクション4.7.2「<span class="command"><strong>mysql_config</strong></span> — クライアントのコンパイル用オプションの表示」</a>を参照してください。
      </p><p>
        <span class="command"><strong>mysql_config</strong></span> は、コンパイルやリンクに必要なオプションを表示します。
      </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>mysql_config --cflags</code></strong>
shell&gt; <strong class="userinput"><code>mysql_config --libs</code></strong>
</pre><p>
        それらのコマンドを実行して、正しいオプションを取得し、それらを手動でコンパイルまたはリンクコマンドに追加できます。または、<span class="command"><strong>mysql_config</strong></span> からの出力を逆引用符を使用して、コマンド行に直接含めます。
      </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>gcc -c `mysql_config --cflags` progname.c</code></strong>
shell&gt; <strong class="userinput"><code>gcc -o progname progname.o `mysql_config --libs`</code></strong>
</pre><h5><a name="idm139979003389056"></a>Microsoft Windows での MySQL クライアントのコンパイル</h5><a class="indexterm" name="idm139979003388208"></a><a class="indexterm" name="idm139979003386144"></a><p>
        ヘッダーおよびライブラリファイルの場所を指定するには、開発環境によって提供されている機能を使用します。
      </p><p>
        Windows で C API クライアントを構築するには、C クライアントライブラリのほか、Windows ws2_32 ソケットライブラリおよび Secur32 セキュリティライブラリにリンクする必要があります。
      </p><p>
        Windows では、コードを動的または静的 C クライアントライブラリとリンクできます。静的ライブラリは <code class="filename">mysqlclient.lib</code> という名前で、動的ライブラリは <code class="filename">libmysql.dll</code> という名前です。さらに、動的ライブラリを使用するために <code class="filename">libmysql.lib</code> 静的インポートライブラリが必要です。
      </p><p>
        静的ライブラリとリンクする場合、これらの状況が満たされていないと、障害が発生する可能性があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            クライアントアプリケーションは、ライブラリをコンパイルするために使用される Visual Studio の同じバージョンでコンパイルする必要があります。
          </p></li><li class="listitem"><p>
            クライアントアプリケーションは <code class="literal">/MT</code> コンパイラオプションを使用して、C ランタイムを静的にリンクしてください。
          </p></li></ul></div><p>
        クライアントアプリケーションがデバッグモードで構築され、静的デバッグ C ランタイムを使用する (<code class="literal">/MTd</code> コンパイラオプション) 場合、<code class="filename">mysqlclient.lib</code> 静的ライブラリが同じオプションを使用して構築されている場合に、それにリンクできます。クライアントアプリケーションが動的 C ランタイムを使用する (<code class="literal">/MD</code> オプション、またはデバッグモードでの <code class="literal">/MDd</code> オプション) 場合、それを <code class="filename">libmysql.dll</code> 動的ライブラリにリンクする必要があります。それは静的クライアントライブラリにリンクできません。
      </p><p>
        リンクオプションについて説明する MSDN ページは、<a class="ulink" href="http://msdn.microsoft.com/en-us/library/2kzt1wy3.aspx" target="_top">http://msdn.microsoft.com/en-us/library/2kzt1wy3.aspx</a> にあります。
      </p><h5><a name="idm139979003368528"></a>MySQL クライアントライブラリへのリンクの問題のトラブルシューティング</h5><a class="indexterm" name="idm139979003367712"></a><a class="indexterm" name="idm139979003365648"></a><a class="indexterm" name="idm139979003363616"></a><a class="indexterm" name="idm139979003361584"></a><a class="indexterm" name="idm139979003359552"></a><p>
        MySQL 5.6 では、MySQL クライアントライブラリに SSL サポートが組み込まれて含まれています。アプリケーションで、リンク時に OpenSSL ライブラリからの <code class="literal">-lssl</code> または <code class="literal">-lcrypto</code> が必要な場合、<code class="literal">-lmysqlclient</code> の前にそれらを指定する必要があります。
      </p><p>
        リンカーが MySQL クライアントライブラリを見つけられない場合、ここに示すような、<code class="literal">mysql_</code> から始まるシンボルの未定義参照エラーを受け取ることがあります。
      </p><pre class="programlisting">
/tmp/ccFKsdPa.o: In function `main':
/tmp/ccFKsdPa.o(.text+0xb): undefined reference to `mysql_init'
/tmp/ccFKsdPa.o(.text+0x31): undefined reference to `mysql_real_connect'
/tmp/ccFKsdPa.o(.text+0x69): undefined reference to `mysql_error'
/tmp/ccFKsdPa.o(.text+0x9a): undefined reference to `mysql_close'
</pre><p>
        この問題は、リンクコマンドの末尾に <code class="literal">-L<em class="replaceable"><code>dir_path</code></em> -lmysqlclient</code> を追加して解決できます。ここで <em class="replaceable"><code>dir_path</code></em> はクライアントライブラリが存在するディレクトリのパス名を表します。正しいディレクトリを判断するには、このコマンドを試してみます。
      </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>mysql_config --libs</code></strong>
</pre><p>
        <span class="command"><strong>mysql_config</strong></span> からの出力に、リンクコマンドに同様に指定すべきほかのライブラリが示されることがあります。コンパイルまたはリンクコマンド内に、逆引用符を使用して、<span class="command"><strong>mysql_config</strong></span> 出力を直接含めることができます。例:
      </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>gcc -o progname progname.o `mysql_config --libs`</code></strong>
</pre><p>
        リンク時に <code class="literal">floor</code> シンボルが未定義であるというエラーが発生した場合、コンパイル/リンク行の末尾に <code class="option">-lm</code> を追加して、数学ライブラリにリンクします。同様に、<code class="literal">connect()</code> などのシステムに存在しているべきほかの関数の未定義参照エラーを受け取った場合は、問題の関数のマニュアルページをチェックして、リンクコマンドに追加すべきライブラリを判断します。
      </p><p>
        システムに存在しない関数の次のような未定義参照エラーを受け取った場合、それは通常 MySQL クライアントライブラリが、使用しているシステムと 100% の互換性がないシステムでコンパイルされたことを意味します。
      </p><pre class="programlisting">
mf_format.o(.text+0x201): undefined reference to `__lxstat'
</pre><p>
        この場合は、最新の MySQL または MySQL Connector/C ソース配布をダウンロードし、自分で MySQL クライアントライブラリをコンパイルしてください。<a class="xref" href="installing.html#source-installation" title="2.9 ソースから MySQL をインストールする">セクション2.9「ソースから MySQL をインストールする」</a>および<a class="ulink" href="http://dev.mysql.com/doc/connector-c/en/index.html" target="_top">MySQL Connector/C Developer Guide</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="c-api-threaded-clients"></a>23.8.4.2 C API スレッドクライアントプログラムの作成</h4></div></div></div><a class="indexterm" name="idm139979003335680"></a><a class="indexterm" name="idm139979003333568"></a><p>
        クライアントライブラリはほとんどスレッドセーフです。最大の問題は、ソケットから読み取られる <code class="filename">net.c</code> 内のサブルーチンが割り込みセーフ (interrupt-safe) でないことです。これは、サーバーへの長い読み取りを中断できる独自のアラームを必要とする可能性があるという考えで行われました。<code class="literal">SIGPIPE</code> 割り込みの割り込みハンドラをインストールする場合、ソケット処理はスレッドセーフであるべきです。
      </p><p>
        接続の終了時のプログラムの中止を避けるため、MySQL は、<code class="literal">mysql_library_init()</code>、<code class="literal">mysql_init()</code>、または <code class="literal">mysql_connect()</code> への最初の呼び出しで <code class="literal">SIGPIPE</code> をブロックします。独自の <code class="literal">SIGPIPE</code> ハンドラを使用するには、まず <code class="literal">mysql_library_init()</code> を呼び出してから、ハンドラをインストールします。
      </p><p>
        <code class="literal">libmysqlclient</code> クライアントライブラリに対するリンク時に、<span class="quote">「<span class="quote">未定義のシンボル</span>」</span>エラーが発生した場合、多くの場合、これはリンク/コンパイルコマンドでスレッドライブラリを含めていなかったためです。
      </p><p>
        クライアントライブラリは接続ごとにスレッドセーフです。2 つのスレッドに、同じ接続を共有させることができますが、次の警告を伴います。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            複数のスレッドは同じ接続で同時に MySQL サーバーにクエリーを送信できません。特に、1 つのスレッドでの <code class="literal">mysql_query()</code> と <code class="literal">mysql_store_result()</code> の呼び出しの間に、ほかのスレッドが同じ接続を使用しないことを確認する必要があります。<code class="literal">mysql_query()</code> および <code class="literal">mysql_store_result()</code> 呼び出しのペアを相互排他ロックで囲む必要があります。<code class="literal">mysql_store_result()</code> が戻ったら、ロックを解除でき、ほかのスレッドが同じ接続をクエリーできます。
          </p><p>
            POSIX スレッドを使用する場合、<code class="literal">pthread_mutex_lock()</code> および <code class="literal">pthread_mutex_unlock()</code> を使用して、相互排他ロックを確立し、解除できます。
          </p></li><li class="listitem"><p>
            多くのスレッドは、<code class="literal">mysql_store_result()</code> によって取得されるさまざまな結果セットにアクセスできます。
          </p></li><li class="listitem"><p>
            <code class="literal">mysql_use_result()</code> を使用するには、結果セットが閉じられるまで、同じ接続を使用しているほかのスレッドがないことを確認する必要があります。ただし、同じ接続を共有するスレッドクライアントが <code class="literal">mysql_store_result()</code> を使用することが実際にもっとも適切です。
          </p></li></ul></div><p>
        MySQL データベースへの接続を作成していないが、MySQL 関数を呼び出しているスレッドがある場合、次のことを知る必要があります。
      </p><p>
        <code class="literal">mysql_init()</code> を呼び出すと、MySQL は、特にデバッグライブラリによって使用されるスレッドのスレッド固有の変数を作成します。スレッドが <code class="literal">mysql_init()</code> を呼び出す前に、MySQL 関数を呼び出した場合、そのスレッドには必要なスレッド固有変数が設定されていないため、遅かれ早かれコアダンプが生成される可能性があります。問題を回避するには、次を実行する必要があります。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            ほかのすべての MySQL 関数の前に <code class="literal">mysql_library_init()</code> を呼び出します。それはスレッドセーフでないため、スレッドが作成される前にそれを呼び出すか、相互排他ロックで呼び出しを保護します。
          </p></li><li class="listitem"><p>
            <code class="literal">mysql_thread_init()</code> が、スレッドハンドラ内の MySQL 関数を呼び出す前の早期に呼び出されるように調整します。<code class="literal">mysql_init()</code> を呼び出すと、それが自動的に <code class="literal">mysql_thread_init()</code> を呼び出します。
          </p></li><li class="listitem"><p>
            スレッド内で、<code class="literal">pthread_exit()</code> を呼び出す前に <code class="literal">mysql_thread_end()</code> を呼び出します。これにより、MySQL スレッド固有変数によって使われたメモリーを解放します。
          </p></li></ol></div><p>
        <code class="literal">mysql_init()</code> に関する先述の注記は、<code class="literal">mysql_init()</code> を呼び出す <code class="literal">mysql_connect()</code> にも適用します。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="c-api-running-clients"></a>23.8.4.3 C API クライアントプログラムの実行</h4></div></div></div><p>
        アップグレード後に、コンパイル済みのクライアントプログラムに、<code class="literal">「コマンドは同期されていません」</code>または予期しないコアダンプなどの問題が発生した場合は、プログラムが古いヘッダーファイルまたはライブラリファイルを使用してコンパイルされた可能性があります。この場合、コンパイルに使用された <code class="filename">mysql.h</code> ファイルおよび <code class="filename">libmysqlclient.a</code> ライブラリの日付をチェックして、それらが新しい MySQL 配布からのものであることを確認します。そうでない場合には、プログラムを新しいヘッダーおよびライブラリで再コンパイルします。ライブラリのメジャーバージョン番号が変更された (<code class="filename">libmysqlclient.so.17</code> から <code class="filename">libmysqlclient.so.18</code> など) 場合に、共有クライアントライブラリに対してコンパイルされているプログラムでも、再コンパイルが必要になる可能性があります。
      </p><p>
        メジャークライアントライブラリバージョンによって互換性が決まります。(たとえば、<code class="literal">libmysqlclient.so.18.1.0</code> の場合、メジャーバージョンは 18 です。)このため、新しいバージョンの MySQL に付属するライブラリは、同じメジャー番号を持つ古いバージョンの簡単に取り換え可能な代替です。メジャーライブラリバージョンが同じであるかぎり、ライブラリをアップグレードでき、古いアプリケーションはそれと連携し続けます。
      </p><p>
        MySQL プログラムを実行しようとすると、実行時に未定義参照エラーが発生することがあります。これらのエラーで <code class="literal">mysql_</code> から始まるシンボルが指定されているか、<code class="literal">libmysqlclient</code> ライブラリが見つからないことを示している場合、それはシステムが共有 <code class="filename">libmysqlclient.so</code> ライブラリを見つけられないことを意味します。この問題の解決方法は、システムにそのライブラリが存在するディレクトリ内で共有ライブラリを検索するように伝えることです。次の方法のうち使用しているシステムに適切な方法を使用します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="filename">libmysqlclient.so</code> が存在するディレクトリのパスを <code class="literal">LD_LIBRARY_PATH</code> または <code class="literal">LD_LIBRARY</code> 環境変数に追加します。
          </p></li><li class="listitem"><p>
            OS X では、<code class="filename">libmysqlclient.dylib</code> が存在するディレクトリのパスを <code class="literal">DYLD_LIBRARY_PATH</code> 環境変数に追加します。
          </p></li><li class="listitem"><p>
            共有ライブラリファイル (<code class="filename">libmysqlclient.so</code> など) を、<code class="filename">/lib</code> などシステムによって検索されるいくつかのディレクトリにコピーし、<code class="literal">ldconfig</code> を実行して、共有ライブラリ情報を更新します。すべての関連ファイルをコピーしてください。共有ライブラリは、代替名を提供するシンボリックリンクを使用して、複数の名前で存在することがあります。
          </p></li></ul></div><p>
        アプリケーションが組み込みサーバーライブラリにリンクされている場合、実行時エラーメッセージに、<code class="literal">libmysqlclient</code> ライブラリではなく、<code class="literal">libmysqld</code> が示されますが、この問題の解決方法は説明したばかりのものと同じです。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="c-api-server-client-versions"></a>23.8.4.4 C API サーバーおよびクライアントライブラリのバージョン</h4></div></div></div><p>
        MySQL サーバーのバージョンの文字列と数値形式は、コンパイル時に <code class="literal">MYSQL_SERVER_VERSION</code> および <code class="literal">MYSQL_VERSION_ID</code> マクロの値として、実行時に <code class="literal">mysql_get_server_info()</code> および <code class="literal">mysql_get_server_version()</code> 関数の値として入手できます。
      </p><p>
        クライアントライブラリのバージョンは MySQL のバージョンです。Connector/C では、これは Connector/C 配布がベースにしている MySQL のバージョンです。このバージョンの文字列と数値形式は、コンパイル時に <code class="literal">MYSQL_SERVER_VERSION</code> および <code class="literal">MYSQL_VERSION_ID</code> マクロの値として、実行時に <code class="literal">mysql_get_client_info()</code> および <code class="literal">mysql_get_client_version()</code> 関数の値として入手できます。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-data-structures"></a>23.8.5 C API データ構造</h3></div></div></div><p>
      このセクションでは、プリペアドステートメントに使用されるもの以外の C API データ構造について説明します。後者に関する情報については、<a class="xref" href="connectors-apis.html#c-api-prepared-statement-data-structures" title="23.8.9 C API プリペアドステートメントデータ構造">セクション23.8.9「C API プリペアドステートメントデータ構造」</a>を参照してください。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="indexterm" name="idm139979003249344"></a> <code class="literal">MYSQL</code>
        </p><p>
          この構造は 1 つのデータベース接続へのハンドルを表します。それはほとんどすべての MySQL 関数に使われます。<code class="literal">MYSQL</code> 構造のコピーを作成しようとしないでください。そのようなコピーが使用可能である保証はありません。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979003244816"></a> <code class="literal">MYSQL_RES</code>
        </p><p>
          この構造は行 (<code class="literal">SELECT</code>、<code class="literal">SHOW</code>、<code class="literal">DESCRIBE</code>、<code class="literal">EXPLAIN</code>) を返すクエリーの結果を表します。クエリーから返される情報は、このセクションの残りの部分で、<span class="emphasis"><em>結果セット</em></span>と呼ばれています。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979003236848"></a> <code class="literal">MYSQL_ROW</code>
        </p><p>
          これは 1 行のデータのタイプセーフな表現です。それは現在カウントされるバイト文字列の配列として実装されています。(フィールド値にバイナリデータが含まれている可能性がある場合、内部でそれらの値に NULL バイトが格納される可能性があるため、これらを NULL 終端文字列として扱うことはできません。)行は <code class="literal">mysql_fetch_row()</code> を呼び出すことによって取得します。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979003231904"></a> <code class="literal">MYSQL_FIELD</code>
        </p><p>
          この構造には、メタデータ (フィールドの名前、型、サイズなどのフィールドに関する情報) が格納されます。そのメンバーについては、このセクションのあとの方でさらに詳しく説明しています。<code class="literal">mysql_fetch_field()</code> を繰り返し呼び出すことによって、フィールドごとに、<code class="literal">MYSQL_FIELD</code> 構造を取得できます。フィールド値はこの構造に含まれません。それらは <code class="literal">MYSQL_ROW</code> 構造に含まれます。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979003225296"></a> <code class="literal">MYSQL_FIELD_OFFSET</code>
        </p><p>
          これは MySQL フィールドリスト内へのオフセットのタイプセーフな表現です。(<code class="literal">mysql_field_seek()</code> で使用されます。)オフセットは行内のゼロから始まるフィールド番号です。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979003220624"></a> <a class="indexterm" name="idm139979003219152"></a> <code class="literal">my_ulonglong</code>
        </p><p>
          行数と <code class="literal">mysql_affected_rows()</code>、<code class="literal">mysql_num_rows()</code>、および <code class="literal">mysql_insert_id()</code> に使用される型。この型は、<code class="literal">0</code> から <code class="literal">1.84e19</code> までの範囲を提供します。
        </p><p>
          一部のシステムでは、型 <code class="literal">my_ulonglong</code> の値を出力しようとしても機能しません。このような値を出力するには、それを <code class="literal">unsigned long</code> に変換して、<code class="literal">%lu</code> 出力形式を使用します。例:
        </p><pre class="programlisting">
printf ("Number of rows: %lu\n",
        (unsigned long) mysql_num_rows(result));
</pre></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979003207056"></a> <a class="indexterm" name="idm139979003205584"></a> <code class="literal">my_bool</code>
        </p><p>
          true (ゼロ以外) または false (ゼロ) の値のブール型。
        </p></li></ul></div><p>
      <code class="literal">MYSQL_FIELD</code> 構造には、次のリストに説明するメンバーが格納されます。この定義は、<code class="literal">SELECT</code> ステートメントによって生成されるものなど、主に結果セットのカラムに適用します。MySQL 5.6 で、<code class="literal">MYSQL_FIELD</code> 構造は、プリペアド <code class="literal">CALL</code> ステートメントを使用して実行されたストアドプロシージャーから返される <code class="literal">OUT</code> および <code class="literal">INOUT</code> パラメータのメタデータを提供するためにも使用されます。そのようなパラメータでは、構造メンバーの一部はカラム値の意味と異なる意味を持ちます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">char * name</code>
        </p><p>
          NULL 終端文字列としてのフィールドの名前。フィールドに <code class="literal">AS</code> 句によってエイリアスが与えられている場合、<code class="literal">name</code> の値はエイリアスになります。プロシージャーパラメータの場合は、パラメータ名。
        </p></li><li class="listitem"><p>
          <code class="literal">char * org_name</code>
        </p><p>
          NULL 終端文字列としてのフィールドの名前。エイリアスは無視されます。式の場合、値は空の文字列です。プロシージャーパラメータの場合は、パラメータ名。
        </p></li><li class="listitem"><p>
          <code class="literal">char * table</code>
        </p><p>
          このフィールドが計算されるフィールドでない場合、それを格納するテーブルの名前。計算されるフィールドの場合、<code class="literal">table</code> 値は空の文字列です。カラムがビューから選択される場合、<code class="literal">table</code> はそのビューを指定します。テーブルまたはビューに <code class="literal">AS</code> 句によってエイリアスが与えられている場合、<code class="literal">table</code> の値はエイリアスになります。<code class="literal">UNION</code> の場合、値は空の文字列です。プロシージャーパラメータの場合はプロシージャー名。
        </p></li><li class="listitem"><p>
          <code class="literal">char * org_table</code>
        </p><p>
          NULL 終端文字列としてのテーブルの名前。エイリアスは無視されます。カラムがビューから選択される場合、<code class="literal">org_table</code> はそのビューを指定します。<code class="literal">UNION</code> の場合、値は空の文字列です。プロシージャーパラメータの場合はプロシージャー名。
        </p></li><li class="listitem"><p>
          <code class="literal">char * db</code>
        </p><p>
          NULL 終端文字列としてのフィールドの取得元のデータベースの名前。フィールドが計算されるフィールドである場合、<code class="literal">db</code> は空の文字列になります。<code class="literal">UNION</code> の場合、値は空の文字列です。プロシージャーパラメータの場合は、プロシージャーを格納するデータベースの名前。
        </p></li><li class="listitem"><p>
          <code class="literal">char * catalog</code>
        </p><p>
          カタログ名。この値は常に <code class="literal">"def"</code> です。
        </p></li><li class="listitem"><p>
          <code class="literal">char * def</code>
        </p><p>
          NULL 終端文字列としてのこのフィールドのデフォルト値。これは <code class="literal">mysql_list_fields()</code> を使用する場合にのみ設定します。
        </p></li><li class="listitem"><p>
          <code class="literal">unsigned long length</code>
        </p><p>
          フィールドの幅。これはバイト単位での表示の長さに対応します。
        </p><p>
          サーバーは結果セットを生成する前に、<code class="literal">length</code> 値を判断するため、これは、結果セットに対するクエリーによって生成される実際の値を前もって知ることなく、結果カラムの可能性のある最大値を保持できる、データ型に必要な最小の長さになります。
        </p></li><li class="listitem"><p>
          <code class="literal">unsigned long max_length</code>
        </p><p>
          結果セットのフィールドの最大幅 (結果セット内の実際の行の最大長フィールド値のバイト単位での長さ)。<code class="literal">mysql_store_result()</code> または <code class="literal">mysql_list_fields()</code> を使用した場合、これにはフィールドの最大長が含まれます。<code class="literal">mysql_use_result()</code> を使用した場合、この変数の値はゼロになります。
        </p><p>
          <code class="literal">max_length</code> の値は、結果セット内の値の文字列表現の長さになります。たとえば、<code class="literal">FLOAT</code> カラムを取得し、<span class="quote">「<span class="quote">最大幅</span>」</span>の値が <code class="literal">-12.345</code> である場合、<code class="literal">max_length</code> は 7 (<code class="literal">'-12.345'</code> の長さ) となります。
        </p><p>
          プリペアドステートメントを使用している場合、バイナリプロトコルでは、値の長さが結果セット内の値の型によって異なるため、<code class="literal">max_length</code> はデフォルトで設定されません。(<a class="xref" href="connectors-apis.html#c-api-prepared-statement-data-structures" title="23.8.9 C API プリペアドステートメントデータ構造">セクション23.8.9「C API プリペアドステートメントデータ構造」</a>を参照してください。)とにかく <code class="literal">max_length</code> 値が必要な場合、<code class="literal">mysql_stmt_attr_set()</code> で <code class="literal">STMT_ATTR_UPDATE_MAX_LENGTH</code> オプションを有効にすると、<code class="literal">mysql_stmt_store_result()</code> を呼び出したときにその長さが設定されます。(<a class="xref" href="connectors-apis.html#mysql-stmt-attr-set" title="23.8.11.3 mysql_stmt_attr_set()">セクション23.8.11.3「mysql_stmt_attr_set()」</a>および<a class="xref" href="connectors-apis.html#mysql-stmt-store-result" title="23.8.11.28 mysql_stmt_store_result()">セクション23.8.11.28「mysql_stmt_store_result()」</a>を参照してください。) 
        </p></li><li class="listitem"><p>
          <code class="literal">unsigned int name_length</code>
        </p><p>
          <code class="literal">name</code> の長さ。
        </p></li><li class="listitem"><p>
          <code class="literal">unsigned int org_name_length</code>
        </p><p>
          <code class="literal">org_name</code> の長さ。
        </p></li><li class="listitem"><p>
          <code class="literal">unsigned int table_length</code>
        </p><p>
          <code class="literal">table</code> の長さ。
        </p></li><li class="listitem"><p>
          <code class="literal">unsigned int org_table_length</code>
        </p><p>
          <code class="literal">org_table</code> の長さ。
        </p></li><li class="listitem"><p>
          <code class="literal">unsigned int db_length</code>
        </p><p>
          <code class="literal">db</code> の長さ。
        </p></li><li class="listitem"><p>
          <code class="literal">unsigned int catalog_length</code>
        </p><p>
          <code class="literal">catalog</code> の長さ。
        </p></li><li class="listitem"><p>
          <code class="literal">unsigned int def_length</code>
        </p><p>
          <code class="literal">def</code> の長さ。
        </p></li><li class="listitem"><p>
          <code class="literal">unsigned int flags</code>
        </p><p>
          フィールドを説明するビットフラグ。<code class="literal">flags</code> 値は、次の表に示すゼロ以上のビットセットを持つ可能性があります。
        </p><div class="informaltable"><table summary="この表はビットフラグ値を一覧表示し、各フラグについて説明します。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">フラグ値</th><th scope="col">フラグの説明</th></tr></thead><tbody><tr><td scope="row"><code class="literal">NOT_NULL_FLAG</code></td><td>フィールドは <code class="literal">NULL</code> にできません</td></tr><tr><td scope="row"><code class="literal">PRI_KEY_FLAG</code></td><td>フィールドは主キーの一部です</td></tr><tr><td scope="row"><code class="literal">UNIQUE_KEY_FLAG</code></td><td>フィールドは一意のキーの一部です</td></tr><tr><td scope="row"><code class="literal">MULTIPLE_KEY_FLAG</code></td><td>フィールドは一意でないキーの一部です</td></tr><tr><td scope="row"><code class="literal">UNSIGNED_FLAG</code></td><td>フィールドは <code class="literal">UNSIGNED</code> 属性を持ちます</td></tr><tr><td scope="row"><code class="literal">ZEROFILL_FLAG</code></td><td>フィールドは <code class="literal">ZEROFILL</code> 属性を持ちます</td></tr><tr><td scope="row"><code class="literal">BINARY_FLAG</code></td><td>フィールドは <code class="literal">BINARY</code> 属性を持ちます</td></tr><tr><td scope="row"><code class="literal">AUTO_INCREMENT_FLAG</code></td><td>フィールドは <code class="literal">AUTO_INCREMENT</code> 属性を持ちます</td></tr><tr><td scope="row"><code class="literal">ENUM_FLAG</code></td><td>フィールドは <code class="literal">ENUM</code> です</td></tr><tr><td scope="row"><code class="literal">SET_FLAG</code></td><td>フィールドは <code class="literal">SET</code> です</td></tr><tr><td scope="row"><code class="literal">BLOB_FLAG</code></td><td>フィールドは <code class="literal">BLOB</code> または <code class="literal">TEXT</code> (非推奨) です</td></tr><tr><td scope="row"><code class="literal">TIMESTAMP_FLAG</code></td><td>フィールドは <code class="literal">TIMESTAMP</code> (非推奨) です</td></tr><tr><td scope="row"><code class="literal">NUM_FLAG</code></td><td>フィールドは数値です。表のあとの補注を参照してください</td></tr><tr><td scope="row"><code class="literal">NO_DEFAULT_VALUE_FLAG</code></td><td>フィールドにはデフォルト値がありません。表のあとの補注を参照してください</td></tr></tbody></table></div><p>
          これらのフラグの一部はデータ型情報を示し、後述する <code class="literal">field-&gt;type</code> メンバーの <code class="literal">MYSQL_TYPE_<em class="replaceable"><code>xxx</code></em></code> 値によって置き換えられるか、一緒に使用されます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">BLOB</code> または <code class="literal">TIMESTAMP</code> 値をチェックするには、<code class="literal">type</code> が <code class="literal">MYSQL_TYPE_BLOB</code> であるか、または <code class="literal">MYSQL_TYPE_TIMESTAMP</code> であるかをチェックします。(<code class="literal">BLOB_FLAG</code> および <code class="literal">TIMESTAMP_FLAG</code> フラグは必要ありません。)
            </p></li><li class="listitem"><p>
              <code class="literal">ENUM</code> および <code class="literal">SET</code> 値は文字列として返されます。これらについては、<code class="literal">type</code> 値が <code class="literal">MYSQL_TYPE_STRING</code> で、<code class="literal">flags</code> 値に <code class="literal">ENUM_FLAG</code> または <code class="literal">SET_FLAG</code> フラグが設定されていることを確認します。
            </p></li></ul></div><p>
          <code class="literal">NUM_FLAG</code> はカラムが数値であることを示します。これには、<code class="literal">MYSQL_TYPE_DECIMAL</code>、<code class="literal">MYSQL_TYPE_NEWDECIMAL</code>、<code class="literal">MYSQL_TYPE_TINY</code>、<code class="literal">MYSQL_TYPE_SHORT</code>、<code class="literal">MYSQL_TYPE_LONG</code>、<code class="literal">MYSQL_TYPE_FLOAT</code>、<code class="literal">MYSQL_TYPE_DOUBLE</code>、<code class="literal">MYSQL_TYPE_NULL</code>、<code class="literal">MYSQL_TYPE_LONGLONG</code>、<code class="literal">MYSQL_TYPE_INT24</code>、および <code class="literal">MYSQL_TYPE_YEAR</code> の型のカラムが含まれます。
        </p><p>
          <code class="literal">NO_DEFAULT_VALUE_FLAG</code> は、カラムの定義に <code class="literal">DEFAULT</code> 句がないことを示しています。これは <code class="literal">NULL</code> カラム (そのようなカラムは <code class="literal">NULL</code> のデフォルトを持つため) または <code class="literal">AUTO_INCREMENT</code> カラム (これは暗黙的なデフォルト値を持ちます) には適用されません。
        </p><p>
          次の例に <code class="literal">flags</code> 値の一般的な使用を示します。
        </p><pre class="programlisting">
if (field-&gt;flags &amp; NOT_NULL_FLAG)
    printf("Field cannot be null\n");
</pre><p>
          次の表に示す便利なマクロを使用して、<code class="literal">flags</code> 値のブールステータスを判断できます。
        </p><div class="informaltable"><table summary="この表はフラグステータス値を一覧表示し、それぞれについて説明します。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">フラグのステータス</th><th scope="col">説明</th></tr></thead><tbody><tr><td scope="row"><code class="literal">IS_NOT_NULL(flags)</code></td><td>このフィールドが <code class="literal">NOT NULL</code> と定義されている場合は true</td></tr><tr><td scope="row"><code class="literal">IS_PRI_KEY(flags)</code></td><td>このフィールドが主キーである場合は true</td></tr><tr><td scope="row"><code class="literal">IS_BLOB(flags)</code></td><td>このフィールドが <code class="literal">BLOB</code> または <code class="literal">TEXT</code> (非推奨、代わりに <code class="literal">field-&gt;type</code> をテストしてください) の場合は true</td></tr></tbody></table></div></li><li class="listitem"><p>
          <code class="literal">unsigned int decimals</code>
        </p><p>
          数値フィールドの小数点以下の桁数および (MySQL 5.6.4 以降) 時間フィールドの小数秒の精度。
        </p></li><li class="listitem"><p>
          <code class="literal">unsigned int charsetnr</code>
        </p><p>
          フィールドの文字セット/照合順序ペアを示す ID 番号。
        </p><p>
          通常、結果セットの文字値は、<code class="literal">character_set_results</code> システム変数で示された文字セットに変換されます。この場合、<code class="literal">charsetnr</code> はその変数で示された文字セットに対応します。文字セットの変換は <code class="literal">character_set_results</code> を <code class="literal">NULL</code> に設定することによってサポートできます。この場合、<code class="literal">charsetnr</code> は元のテーブルカラムまたは式の文字セットに対応します。<a class="xref" href="globalization.html#charset-connection" title="10.1.4 接続文字セットおよび照合順序">セクション10.1.4「接続文字セットおよび照合順序」</a>も参照してください。
        </p><p>
          文字列データ型のバイナリおよび非バイナリデータを区別するには、<code class="literal">charsetnr</code> 値が 63 であるかどうかをチェックします。その場合、文字セットは <code class="literal">binary</code> で、これは非バイナリデータではなく、バイナリを示します。これにより、<code class="literal">BINARY</code> と <code class="literal">CHAR</code>、<code class="literal">VARBINARY</code> と <code class="literal">VARCHAR</code>、および <code class="literal">BLOB</code> 型と <code class="literal">TEXT</code> 型を区別できます。
        </p><p>
          <code class="literal">charsetnr</code> 値は <code class="literal">SHOW COLLATION</code> ステートメントの <code class="literal">Id</code> カラムまたは <code class="literal">INFORMATION_SCHEMA</code> <code class="literal">COLLATIONS</code> テーブルの <code class="literal">ID</code> カラムに表示される値と同じです。それらの情報ソースを使用して、特定の <code class="literal">charsetnr</code> 値がどの文字セットと照合順序を示しているかを確認できます。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW COLLATION WHERE Id = 63;</code></strong>
+-----------+---------+----+---------+----------+---------+
| Collation | Charset | Id | Default | Compiled | Sortlen |
+-----------+---------+----+---------+----------+---------+
| binary    | binary  | 63 | Yes     | Yes      |       1 |
+-----------+---------+----+---------+----------+---------+

mysql&gt; <strong class="userinput"><code>SELECT COLLATION_NAME, CHARACTER_SET_NAME</code></strong>
    -&gt; <strong class="userinput"><code>FROM INFORMATION_SCHEMA.COLLATIONS WHERE ID = 33;</code></strong>
+-----------------+--------------------+
| COLLATION_NAME  | CHARACTER_SET_NAME |
+-----------------+--------------------+
| utf8_general_ci | utf8               |
+-----------------+--------------------+
</pre></li><li class="listitem"><p>
          <code class="literal">enum enum_field_types type</code>
        </p><p>
          フィールドの型。<code class="literal">type</code> 値は次の表に示す <code class="literal">MYSQL_TYPE_</code> シンボルのいずれかになります。
        </p><div class="informaltable"><table summary="この表では、MYSQL_TYPE_ 値を一覧表示し、各型について説明します。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">型の値</th><th scope="col">型の説明</th></tr></thead><tbody><tr><td scope="row"><code class="literal">MYSQL_TYPE_TINY</code></td><td><code class="literal">TINYINT</code> フィールド</td></tr><tr><td scope="row"><code class="literal">MYSQL_TYPE_SHORT</code></td><td><code class="literal">SMALLINT</code> フィールド</td></tr><tr><td scope="row"><code class="literal">MYSQL_TYPE_LONG</code></td><td><code class="literal">INTEGER</code> フィールド</td></tr><tr><td scope="row"><code class="literal">MYSQL_TYPE_INT24</code></td><td><code class="literal">MEDIUMINT</code> フィールド</td></tr><tr><td scope="row"><code class="literal">MYSQL_TYPE_LONGLONG</code></td><td><code class="literal">BIGINT</code> フィールド</td></tr><tr><td scope="row"><code class="literal">MYSQL_TYPE_DECIMAL</code></td><td><code class="literal">DECIMAL</code> または <code class="literal">NUMERIC</code> フィールド</td></tr><tr><td scope="row"><code class="literal">MYSQL_TYPE_NEWDECIMAL</code></td><td>高精度計算 <code class="literal">DECIMAL</code> または <code class="literal">NUMERIC</code></td></tr><tr><td scope="row"><code class="literal">MYSQL_TYPE_FLOAT</code></td><td><code class="literal">FLOAT</code> フィールド</td></tr><tr><td scope="row"><code class="literal">MYSQL_TYPE_DOUBLE</code></td><td><code class="literal">DOUBLE</code> または <code class="literal">REAL</code> フィールド</td></tr><tr><td scope="row"><code class="literal">MYSQL_TYPE_BIT</code></td><td><code class="literal">BIT</code> フィールド</td></tr><tr><td scope="row"><code class="literal">MYSQL_TYPE_TIMESTAMP</code></td><td><code class="literal">TIMESTAMP</code> フィールド</td></tr><tr><td scope="row"><code class="literal">MYSQL_TYPE_DATE</code></td><td><code class="literal">DATE</code> フィールド</td></tr><tr><td scope="row"><code class="literal">MYSQL_TYPE_TIME</code></td><td><code class="literal">TIME</code> フィールド</td></tr><tr><td scope="row"><code class="literal">MYSQL_TYPE_DATETIME</code></td><td><code class="literal">DATETIME</code> フィールド</td></tr><tr><td scope="row"><code class="literal">MYSQL_TYPE_YEAR</code></td><td><code class="literal">YEAR</code> フィールド</td></tr><tr><td scope="row"><code class="literal">MYSQL_TYPE_STRING</code></td><td><code class="literal">CHAR</code> または <code class="literal">BINARY</code> フィールド</td></tr><tr><td scope="row"><code class="literal">MYSQL_TYPE_VAR_STRING</code></td><td><code class="literal">VARCHAR</code> または <code class="literal">VARBINARY</code> フィールド</td></tr><tr><td scope="row"><code class="literal">MYSQL_TYPE_BLOB</code></td><td><code class="literal">BLOB</code> または <code class="literal">TEXT</code> フィールド (<code class="literal">max_length</code> を使用して最大長を判断します)</td></tr><tr><td scope="row"><code class="literal">MYSQL_TYPE_SET</code></td><td><code class="literal">SET</code> フィールド</td></tr><tr><td scope="row"><code class="literal">MYSQL_TYPE_ENUM</code></td><td><code class="literal">ENUM</code> フィールド</td></tr><tr><td scope="row"><code class="literal">MYSQL_TYPE_GEOMETRY</code></td><td>空間フィールド</td></tr><tr><td scope="row"><code class="literal">MYSQL_TYPE_NULL</code></td><td><code class="literal">NULL</code> 型フィールド</td></tr></tbody></table></div><p>
          <code class="literal">MYSQL_TYPE_TIME2</code>、<code class="literal">MYSQL_TYPE_DATETIME2</code>、および <code class="literal">MYSQL_TYPE_TIMESTAMP2</code> タイプコードはサーバー側でのみ使用されます。クライアントは、<code class="literal">MYSQL_TYPE_TIME</code>、<code class="literal">MYSQL_TYPE_DATETIME</code>、および <code class="literal">MYSQL_TYPE_TIMESTAMP</code> コードを参照します。
        </p><p>
          <code class="literal">IS_NUM()</code> マクロを使用して、フィールドが数値型を持つかどうかをテストできます。<code class="literal">type</code> 値を <code class="literal">IS_NUM()</code> に渡すと、それはフィールドが数値である場合、TRUE と評価します。
        </p><pre class="programlisting">
if (IS_NUM(field-&gt;type))
    printf("Field is numeric\n");
</pre><p>
          <code class="literal">ENUM</code> および <code class="literal">SET</code> 値は文字列として返されます。これらについては、<code class="literal">type</code> 値が <code class="literal">MYSQL_TYPE_STRING</code> で、<code class="literal">flags</code> 値に <code class="literal">ENUM_FLAG</code> または <code class="literal">SET_FLAG</code> フラグが設定されていることを確認します。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-function-overview"></a>23.8.6 C API 関数の概要</h3></div></div></div><a class="indexterm" name="idm139979002927728"></a><a class="indexterm" name="idm139979002925616"></a><p>
      C API で使用可能な関数について、ここで概要を説明し、あとのセクションで詳しく説明します。<a class="xref" href="connectors-apis.html#c-api-functions" title="23.8.7 C API 関数の説明">セクション23.8.7「C API 関数の説明」</a>を参照してください。
    </p><div class="table"><a name="idm139979002922304"></a><p class="title"><b>表 23.4 C API 関数名と説明</b></p><div class="table-contents"><table summary="C API 関数名と説明" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">関数</th><th scope="col">説明</th></tr></thead><tbody><tr><td scope="row"><code class="literal">my_init()</code></td><td>グローバル変数とスレッドセーフプログラムのスレッドハンドラを初期化します</td></tr><tr><td scope="row"><code class="literal">mysql_affected_rows()</code></td><td>最後の <code class="literal">UPDATE</code>、<code class="literal">DELETE</code>、または <code class="literal">INSERT</code> クエリーによって変更/削除/挿入された行数を返します</td></tr><tr><td scope="row"><code class="literal">mysql_autocommit()</code></td><td>自動コミットモードのオン/オフを切り替えます</td></tr><tr><td scope="row"><code class="literal">mysql_change_user()</code></td><td>開いている接続のユーザーおよびデータベースを変更します</td></tr><tr><td scope="row"><code class="literal">mysql_character_set_name()</code></td><td>現在の接続のデフォルトの文字セット名を返します</td></tr><tr><td scope="row"><code class="literal">mysql_client_find_plugin()</code></td><td>プラグインへのポインタを返します</td></tr><tr><td scope="row"><code class="literal">mysql_client_register_plugin()</code></td><td>プラグインを登録します</td></tr><tr><td scope="row"><code class="literal">mysql_close()</code></td><td>サーバー接続を閉じます</td></tr><tr><td scope="row"><code class="literal">mysql_commit()</code></td><td>トランザクションをコミットします</td></tr><tr><td scope="row"><code class="literal">mysql_connect()</code></td><td>MySQL サーバーに接続します (この関数は非推奨です。代わりに <code class="literal">mysql_real_connect()</code> を使用してください)</td></tr><tr><td scope="row"><code class="literal">mysql_create_db()</code></td><td>データベースを作成します (この関数は非推奨です。代わりに SQL ステートメント <code class="literal">CREATE DATABASE</code> を使用してください)</td></tr><tr><td scope="row"><code class="literal">mysql_data_seek()</code></td><td>クエリー結果セット内の任意の行番号にシークします</td></tr><tr><td scope="row"><code class="literal">mysql_debug()</code></td><td>指定された文字列で <code class="literal">DBUG_PUSH</code> を実行します</td></tr><tr><td scope="row"><code class="literal">mysql_drop_db()</code></td><td>データベースを削除します (この関数は非推奨です。代わりに SQL ステートメント <code class="literal">DROP DATABASE</code> を使用してください)</td></tr><tr><td scope="row"><code class="literal">mysql_dump_debug_info()</code></td><td>サーバーにデバッグ情報をログに書き込ませます</td></tr><tr><td scope="row"><code class="literal">mysql_eof()</code></td><td>結果セットの最後の行が読み取られているかどうかを判断します (この関数は非推奨です。代わりに <code class="literal">mysql_errno()</code> または <code class="literal">mysql_error()</code> を使用できます)</td></tr><tr><td scope="row"><code class="literal">mysql_errno()</code></td><td>最近呼び出された MySQL 関数のエラー番号を返します</td></tr><tr><td scope="row"><code class="literal">mysql_error()</code></td><td>最近呼び出された MySQL 関数のエラーメッセージを返します</td></tr><tr><td scope="row"><code class="literal">mysql_escape_string()</code></td><td>SQL ステートメントで使用するために文字列内の特殊文字をエスケープします</td></tr><tr><td scope="row"><code class="literal">mysql_fetch_field()</code></td><td>次のテーブルフィールドの型を返します</td></tr><tr><td scope="row"><code class="literal">mysql_fetch_field_direct()</code></td><td>フィールド番号を指定して、テーブルフィールドの型を返します</td></tr><tr><td scope="row"><code class="literal">mysql_fetch_fields()</code></td><td>すべてのフィールド構造の配列を返します</td></tr><tr><td scope="row"><code class="literal">mysql_fetch_lengths()</code></td><td>現在の行内のすべてのカラムの長さを返します</td></tr><tr><td scope="row"><code class="literal">mysql_fetch_row()</code></td><td>結果セットから次の行をフェッチします</td></tr><tr><td scope="row"><code class="literal">mysql_field_count()</code></td><td>最近のステートメントの結果カラムの数を返します</td></tr><tr><td scope="row"><code class="literal">mysql_field_seek()</code></td><td>指定したカラムにカラムカーソルを置きます</td></tr><tr><td scope="row"><code class="literal">mysql_field_tell()</code></td><td>最後の <code class="literal">mysql_fetch_field()</code> に使用されたフィールドカーソルの位置を返します</td></tr><tr><td scope="row"><code class="literal">mysql_free_result()</code></td><td>結果セットに使用されたメモリーを解放します</td></tr><tr><td scope="row"><code class="literal">mysql_get_character_set_info()</code></td><td>デフォルトの文字セットに関する情報を返します</td></tr><tr><td scope="row"><code class="literal">mysql_get_client_info()</code></td><td>クライアントバージョン情報を文字列として返します</td></tr><tr><td scope="row"><code class="literal">mysql_get_client_version()</code></td><td>クライアントバージョン情報を整数として返します</td></tr><tr><td scope="row"><code class="literal">mysql_get_host_info()</code></td><td>接続を説明する文字列を返します</td></tr><tr><td scope="row"><code class="literal">mysql_get_proto_info()</code></td><td>接続によって使用されたプロトコルバージョンを返します</td></tr><tr><td scope="row"><code class="literal">mysql_get_server_info()</code></td><td>サーバーバージョン番号を返します</td></tr><tr><td scope="row"><code class="literal">mysql_get_server_version()</code></td><td>サーバーのバージョン番号を整数として返します</td></tr><tr><td scope="row"><code class="literal">mysql_get_ssl_cipher()</code></td><td>現在の SSL 暗号を返します</td></tr><tr><td scope="row"><code class="literal">mysql_hex_string()</code></td><td>文字列を 16 進形式でエンコードします</td></tr><tr><td scope="row"><code class="literal">mysql_info()</code></td><td>最近実行されたクエリーに関する情報を返します</td></tr><tr><td scope="row"><code class="literal">mysql_init()</code></td><td><code class="literal">MYSQL</code> 構造を取得するか初期化します</td></tr><tr><td scope="row"><code class="literal">mysql_insert_id()</code></td><td>前のクエリーによって <code class="literal">AUTO_INCREMENT</code> カラムに対して生成された ID を返します</td></tr><tr><td scope="row"><code class="literal">mysql_kill()</code></td><td>指定されたスレッドを強制終了します</td></tr><tr><td scope="row"><code class="literal">mysql_library_end()</code></td><td>MySQL C API ライブラリをファイナライズします</td></tr><tr><td scope="row"><code class="literal">mysql_library_init()</code></td><td>MySQL C API ライブラリを初期化します</td></tr><tr><td scope="row"><code class="literal">mysql_list_dbs()</code></td><td>単純な正規表現に一致するデータベース名を返します</td></tr><tr><td scope="row"><code class="literal">mysql_list_fields()</code></td><td>単純な正規表現に一致するフィールド名を返します</td></tr><tr><td scope="row"><code class="literal">mysql_list_processes()</code></td><td>現在のサーバースレッドのリストを返します。</td></tr><tr><td scope="row"><code class="literal">mysql_list_tables()</code></td><td>単純な正規表現に一致するテーブル名を返します</td></tr><tr><td scope="row"><code class="literal">mysql_load_plugin()</code></td><td>プラグインをロードします</td></tr><tr><td scope="row"><code class="literal">mysql_load_plugin_v()</code></td><td>プラグインをロードします</td></tr><tr><td scope="row"><code class="literal">mysql_more_results()</code></td><td>それ以上の結果が存在するかどうかをチェックします</td></tr><tr><td scope="row"><code class="literal">mysql_next_result()</code></td><td>複数結果の実行での次の結果を返すか、初期化します</td></tr><tr><td scope="row"><code class="literal">mysql_num_fields()</code></td><td>結果セット内のカラムの数を返します</td></tr><tr><td scope="row"><code class="literal">mysql_num_rows()</code></td><td>結果セット内の行数を返します</td></tr><tr><td scope="row"><code class="literal">mysql_options()</code></td><td><code class="literal">mysql_real_connect()</code> の接続オプションを設定します</td></tr><tr><td scope="row"><code class="literal">mysql_options4()</code></td><td><code class="literal">mysql_real_connect()</code> の接続オプションを設定します</td></tr><tr><td scope="row"><code class="literal">mysql_ping()</code></td><td>サーバーへの接続が動作しているかどうかをチェックし、必要に応じて再接続します</td></tr><tr><td scope="row"><code class="literal">mysql_plugin_options()</code></td><td>プラグインオプションを設定します</td></tr><tr><td scope="row"><code class="literal">mysql_query()</code></td><td>NULL 終端文字列として指定された SQL クエリーを実行します</td></tr><tr><td scope="row"><code class="literal">mysql_real_connect()</code></td><td>MySQL サーバーに接続します</td></tr><tr><td scope="row"><code class="literal">mysql_real_escape_string()</code></td><td>SQL ステートメントで使用するために文字列内の特殊文字をエスケープし、接続の現在の文字セットを考慮します</td></tr><tr><td scope="row"><code class="literal">mysql_real_query()</code></td><td>カウントされる文字列として指定された SQL クエリーを実行します</td></tr><tr><td scope="row"><code class="literal">mysql_refresh()</code></td><td>テーブルおよびキャッシュをフラッシュするか、リセットします</td></tr><tr><td scope="row"><code class="literal">mysql_reload()</code></td><td>サーバーに付与テーブルをリロードするように伝えます</td></tr><tr><td scope="row"><code class="literal">mysql_rollback()</code></td><td>トランザクションをロールバックします</td></tr><tr><td scope="row"><code class="literal">mysql_row_seek()</code></td><td><code class="literal">mysql_row_tell()</code> から返される値を使用して、結果セット内の行オフセットにシークします</td></tr><tr><td scope="row"><code class="literal">mysql_row_tell()</code></td><td>行カーソル位置を返します</td></tr><tr><td scope="row"><code class="literal">mysql_select_db()</code></td><td>データベースを選択します</td></tr><tr><td scope="row"><code class="literal">mysql_server_end()</code></td><td>MySQL C API ライブラリをファイナライズします</td></tr><tr><td scope="row"><code class="literal">mysql_server_init()</code></td><td>MySQL C API ライブラリを初期化します</td></tr><tr><td scope="row"><code class="literal">mysql_set_character_set()</code></td><td>現在の接続のデフォルトの文字セットを設定します</td></tr><tr><td scope="row"><code class="literal">mysql_set_local_infile_default()</code></td><td><code class="literal">LOAD DATA LOCAL INFILE</code> ハンドラコールバックをそれらのデフォルト値に設定します</td></tr><tr><td scope="row"><code class="literal">mysql_set_local_infile_handler()</code></td><td>アプリケーション固有の <code class="literal">LOAD DATA LOCAL INFILE</code> ハンドラコールバックをインストールします</td></tr><tr><td scope="row"><code class="literal">mysql_set_server_option()</code></td><td>接続のオプション (<code class="literal">multi-statements</code> など) を設定します。</td></tr><tr><td scope="row"><code class="literal">mysql_sqlstate()</code></td><td>最後のエラーの SQLSTATE エラーコードを返します</td></tr><tr><td scope="row"><code class="literal">mysql_shutdown()</code></td><td>データベースサーバーをシャットダウンします</td></tr><tr><td scope="row"><code class="literal">mysql_ssl_set()</code></td><td>サーバーへの SSL 接続の確立を準備します</td></tr><tr><td scope="row"><code class="literal">mysql_stat()</code></td><td>サーバーステータスを文字列として返します</td></tr><tr><td scope="row"><code class="literal">mysql_store_result()</code></td><td>クライアントへの完全な結果セットを取得します</td></tr><tr><td scope="row"><code class="literal">mysql_thread_end()</code></td><td>スレッドハンドラをファイナライズします</td></tr><tr><td scope="row"><code class="literal">mysql_thread_id()</code></td><td>現在のスレッド ID を返します</td></tr><tr><td scope="row"><code class="literal">mysql_thread_init()</code></td><td>スレッドハンドラを初期化します</td></tr><tr><td scope="row"><code class="literal">mysql_thread_safe()</code></td><td>クライアントがスレッドセーフとしてコンパイルされた場合に 1 を返します</td></tr><tr><td scope="row"><code class="literal">mysql_use_result()</code></td><td>行ごとの結果セットの取得を開始します</td></tr><tr><td scope="row"><code class="literal">mysql_warning_count()</code></td><td>以前の SQL ステートメントの警告カウントを返します</td></tr></tbody></table></div></div><br class="table-break"><p>
      アプリケーションプログラムでは、MySQL との対話にこの概要を使用してください。
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          <code class="literal">mysql_library_init()</code> を呼び出して、MySQL ライブラリを初期化します。この関数は、<code class="literal">libmysqlclient</code> C クライアントライブラリと <code class="literal">libmysqld</code> 組み込みサーバーライブラリのどちらにも存在するため、<code class="option">-libmysqlclient</code> フラグでリンクして、通常のクライアントプログラムを構築するか、または <code class="option">-libmysqld</code> フラグでリンクして、組み込みサーバーアプリケーションを構築するかどうかに関係なく使われます。
        </p></li><li class="listitem"><p>
          <code class="literal">mysql_init()</code> を呼び出して、接続ハンドラを初期化し、<code class="literal">mysql_real_connect()</code> を呼び出して、サーバーに接続します。
        </p></li><li class="listitem"><p>
          SQL ステートメントを発行して、それらの結果を処理します。(次の説明で、これを行う方法に関する詳細を提供します。)
        </p></li><li class="listitem"><p>
          <code class="literal">mysql_close()</code> を呼び出して、MySQL サーバーへの接続をクローズします。
        </p></li><li class="listitem"><p>
          <code class="literal">mysql_library_end()</code> を呼び出して、MySQL ライブラリの使用を終了します。
        </p></li></ol></div><p>
      <code class="literal">mysql_library_init()</code> と <code class="literal">mysql_library_end()</code> の呼び出しの目的は、MySQL ライブラリの正しい初期化とファイナライズを提供することです。クライアントライブラリとリンクされたアプリケーションでは、それらは改善されたメモリー管理を提供します。<code class="literal">mysql_library_end()</code> を呼び出さない場合、メモリーのブロックは割り当てられたままになります。(これによって、アプリケーションによって使用されるメモリーの量は増えませんが、何らかのメモリーリーク検出ツールがそれに関して報告します。)組み込みサーバーとリンクされたアプリケーションでは、これらの呼び出しはサーバーを起動および停止します。
    </p><p>
      非マルチスレッド環境では、<code class="literal">mysql_init()</code> が必要に応じて自動的に <code class="literal">mysql_library_init()</code> を呼び出すため、この呼び出しを省略できます。ただし、<code class="literal">mysql_library_init()</code> はマルチスレッド環境でスレッドセーフでないため、<code class="literal">mysql_library_init()</code> を呼び出す <code class="literal">mysql_init()</code> もスレッドセーフでありません。スレッドを生成する前に <code class="literal">mysql_library_init()</code> を呼び出すか、さもなければ <code class="literal">mysql_library_init()</code> を呼び出すか、<code class="literal">mysql_init()</code> 経由で間接的に呼び出すかに関係なく、相互排他ロックを使用して、呼び出しを保護します。これは、ほかのすべてのクライアントライブラリ呼び出しの前に実行すべきです。
    </p><p>
      サーバーに接続するには、<code class="literal">mysql_init()</code> を呼び出して、接続ハンドラを初期化し、次にそのハンドラで (ホスト名、ユーザー名、およびパスワードなどのその他の情報とともに) <code class="literal">mysql_real_connect()</code> を呼び出します。接続時に、<code class="literal">mysql_real_connect()</code> は、<code class="literal">reconnect</code> フラグ (<code class="literal">MYSQL</code> 構造の一部) を、5.0.3 より古い API のバージョンでは <code class="literal">1</code> の値、または新しいバージョンでは <code class="literal">0</code> に設定します。このフラグの <code class="literal">1</code> の値は、切断された接続のためにステートメントを実行できない場合、諦める前にサーバーに再接続しようとすることを示します。<code class="literal">mysql_options()</code> に <code class="literal">MYSQL_OPT_RECONNECT</code> オプションを使用して、再接続動作を制御できます。接続を終了した場合、<code class="literal">mysql_close()</code> を呼び出して、それを終了させます。
    </p><p>
      接続がアクティブである間に、クライアントは <code class="literal">mysql_query()</code> または <code class="literal">mysql_real_query()</code> を使用して、SQL ステートメントをサーバーに送信できます。2 つの違いは、<code class="literal">mysql_query()</code> では、クエリーが NULL 終端文字列として指定されることを期待しますが、<code class="literal">mysql_real_query()</code> ではカウントされる文字列を期待することです。文字列にバイナリデータ (NULL バイトを含む可能性のある) が含まれている場合、<code class="literal">mysql_real_query()</code> を使用する必要があります。
    </p><p>
      <code class="literal">SELECT</code> 以外の各クエリー (<code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、<code class="literal">DELETE</code> など) では、<code class="literal">mysql_affected_rows()</code> を呼び出すことによって、変更された (影響を受けた) 行数を調べることができます。
    </p><p>
      <code class="literal">SELECT</code> クエリーでは、選択された行を結果セットとして取得します。(一部のステートメントは、行を返すという点で、<code class="literal">SELECT</code> に似ていることに注目してください。これらには <code class="literal">SHOW</code>、<code class="literal">DESCRIBE</code>、および <code class="literal">EXPLAIN</code> が含まれます。これらのステートメントを <code class="literal">SELECT</code> ステートメントと同じように扱います。)
    </p><p>
      クライアントが結果セットを処理する方法は 2 つあります。1 つの方法は、<code class="literal">mysql_store_result()</code> を呼び出して、結果セット全体を一度に取得することです。この関数はサーバーからクエリーによって返されたすべての行を取得して、それらをクライアントに格納します。2 つ目の方法は、クライアントが <code class="literal">mysql_use_result()</code> を呼び出して、行ごとに結果セットの取得を開始することです。この関数は取得を初期化しますが、実際にサーバーから行を取得しません。
    </p><p>
      どちらの場合も、<code class="literal">mysql_fetch_row()</code> を呼び出して、行にアクセスします。<code class="literal">mysql_store_result()</code> では、<code class="literal">mysql_fetch_row()</code> は、以前にサーバーからフェッチされた行にアクセスします。<code class="literal">mysql_use_result()</code> では、<code class="literal">mysql_fetch_row()</code> はサーバーから実際に行を取得します。<code class="literal">mysql_fetch_lengths()</code> を呼び出すことによって、各行内のデータのサイズに関する情報を入手できます。
    </p><p>
      結果セットの処理を終了したら、<code class="literal">mysql_free_result()</code> を呼び出して、それに使用されたメモリーを解放します。
    </p><p>
      2 つの取得メカニズムは補完的です。各クライアントアプリケーションにもっとも適切なアプローチを選択してください。実際には、クライアントは <code class="literal">mysql_store_result()</code> をより一般的に使用する傾向があります。
    </p><p>
      <code class="literal">mysql_store_result()</code> の利点は、行がすべてクライアントにフェッチされているため、行に順次アクセスできるだけでなく、<code class="literal">mysql_data_seek()</code> または <code class="literal">mysql_row_seek()</code> を使用して、結果セット内を前後に移動して、結果セット内の現在の行の位置を変更できることです。<code class="literal">mysql_num_rows()</code> を呼び出すことによって、そこに存在している行の数を知ることもできます。一方、大きな結果セットに対する <code class="literal">mysql_store_result()</code> のメモリー要件はきわめて高くなることがあるため、メモリー不足状況が発生する可能性が高くなります。
    </p><p>
      <code class="literal">mysql_use_result()</code> の利点は、一度に 1 行しか保持しないため、クライアントが結果セットのために必要とするメモリーが少なくなることです (さらに割り当てのオーバーヘッドが少ないため、<code class="literal">mysql_use_result()</code> の方が高速になる可能性があります)。欠点は、サーバーの動作の停止を避けるため、各行を迅速に処理する必要があり、結果セット内の行にランダムアクセスできず (行に順次アクセスしかできません)、結果セット内の行数がそれらをすべて取得するまで不明であることです。さらに、取得の途中で探していた情報が見つかったと判断しても、すべての行を取得する<span class="emphasis"><em>必要があります</em></span>。
    </p><p>
      API により、クライアントは、ステートメントが <code class="literal">SELECT</code> であるかどうかを知ることなく、適切にステートメントに応答できます (必要に応じて行を取得します)。これを行うには、各 <code class="literal">mysql_query()</code> (または <code class="literal">mysql_real_query()</code>) のあとに、<code class="literal">mysql_store_result()</code> を呼び出します。結果セットの呼び出しが成功すると、ステートメントは <code class="literal">SELECT</code> であったため、行を読み取ることができます。結果セットの呼び出しが失敗した場合は、<code class="literal">mysql_field_count()</code> を呼び出して、結果が実際に期待したものであったかどうかを判断します。<code class="literal">mysql_field_count()</code> がゼロを返す場合、ステートメントはデータを返しておらず (それは <code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、<code class="literal">DELETE</code> などであったことを示す)、行を返すことが期待されていません。<code class="literal">mysql_field_count()</code> がゼロ以外の場合、ステートメントは行を返しているべきですが、返していません。これはステートメントが失敗した <code class="literal">SELECT</code> であったことを示します。これを実行できる方法の例については、<code class="literal">mysql_field_count()</code> の説明を参照してください。
    </p><p>
      <code class="literal">mysql_store_result()</code> と <code class="literal">mysql_use_result()</code> のどちらも結果セットを構成するフィールドに関する情報 (フィールド数、それらの名前と型など) を取得できます。<code class="literal">mysql_fetch_field()</code> を繰り返し呼び出すか、または行内のフィールド番号ごとに <code class="literal">mysql_fetch_field_direct()</code> を呼び出すことによって、行内のフィールド情報に順次にアクセスできます。<code class="literal">mysql_field_seek()</code> を呼び出すことによって、現在のフィールドカーソル位置を変更できます。フィールドカーソルを設定すると <code class="literal">mysql_fetch_field()</code> へのその後の呼び出しに影響します。<code class="literal">mysql_fetch_fields()</code> を呼び出すことによって、フィールドの情報をすべて一度に取得することもできます。
    </p><p>
      エラーを検出して報告するために、MySQL は <code class="literal">mysql_errno()</code> 関数および <code class="literal">mysql_error()</code> 関数によって、エラー情報へのアクセスを提供します。これらは最近呼び出された成功または失敗した可能性のある関数のエラーコードやエラーメッセージを返すため、エラーが発生した時期とそれが何であったかを判断できます。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-functions"></a>23.8.7 C API 関数の説明</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="connectors-apis.html#mysql-affected-rows">23.8.7.1 mysql_affected_rows()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-autocommit">23.8.7.2 mysql_autocommit()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-change-user">23.8.7.3 mysql_change_user()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-character-set-name">23.8.7.4 mysql_character_set_name()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-close">23.8.7.5 mysql_close()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-commit">23.8.7.6 mysql_commit()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-connect">23.8.7.7 mysql_connect()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-create-db">23.8.7.8 mysql_create_db()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-data-seek">23.8.7.9 mysql_data_seek()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-debug">23.8.7.10 mysql_debug()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-drop-db">23.8.7.11 mysql_drop_db()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-dump-debug-info">23.8.7.12 mysql_dump_debug_info()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-eof">23.8.7.13 mysql_eof()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-errno">23.8.7.14 mysql_errno()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-error">23.8.7.15 mysql_error()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-escape-string">23.8.7.16 mysql_escape_string()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-fetch-field">23.8.7.17 mysql_fetch_field()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-fetch-field-direct">23.8.7.18 mysql_fetch_field_direct()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-fetch-fields">23.8.7.19 mysql_fetch_fields()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-fetch-lengths">23.8.7.20 mysql_fetch_lengths()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-fetch-row">23.8.7.21 mysql_fetch_row()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-field-count">23.8.7.22 mysql_field_count()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-field-seek">23.8.7.23 mysql_field_seek()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-field-tell">23.8.7.24 mysql_field_tell()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-free-result">23.8.7.25 mysql_free_result()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-get-character-set-info">23.8.7.26 mysql_get_character_set_info()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-get-client-info">23.8.7.27 mysql_get_client_info()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-get-client-version">23.8.7.28 mysql_get_client_version()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-get-host-info">23.8.7.29 mysql_get_host_info()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-get-proto-info">23.8.7.30 mysql_get_proto_info()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-get-server-info">23.8.7.31 mysql_get_server_info()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-get-server-version">23.8.7.32 mysql_get_server_version()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-get-ssl-cipher">23.8.7.33 mysql_get_ssl_cipher()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-hex-string">23.8.7.34 mysql_hex_string()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-info">23.8.7.35 mysql_info()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-init">23.8.7.36 mysql_init()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-insert-id">23.8.7.37 mysql_insert_id()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-kill">23.8.7.38 mysql_kill()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-library-end">23.8.7.39 mysql_library_end()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-library-init">23.8.7.40 mysql_library_init()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-list-dbs">23.8.7.41 mysql_list_dbs()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-list-fields">23.8.7.42 mysql_list_fields()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-list-processes">23.8.7.43 mysql_list_processes()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-list-tables">23.8.7.44 mysql_list_tables()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-more-results">23.8.7.45 mysql_more_results()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-next-result">23.8.7.46 mysql_next_result()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-num-fields">23.8.7.47 mysql_num_fields()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-num-rows">23.8.7.48 mysql_num_rows()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-options">23.8.7.49 mysql_options()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-options4">23.8.7.50 mysql_options4()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-ping">23.8.7.51 mysql_ping()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-query">23.8.7.52 mysql_query()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-real-connect">23.8.7.53 mysql_real_connect()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-real-escape-string">23.8.7.54 mysql_real_escape_string()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-real-query">23.8.7.55 mysql_real_query()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-refresh">23.8.7.56 mysql_refresh()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-reload">23.8.7.57 mysql_reload()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-rollback">23.8.7.58 mysql_rollback()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-row-seek">23.8.7.59 mysql_row_seek()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-row-tell">23.8.7.60 mysql_row_tell()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-select-db">23.8.7.61 mysql_select_db()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-set-character-set">23.8.7.62 mysql_set_character_set()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-set-local-infile-default">23.8.7.63 mysql_set_local_infile_default()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-set-local-infile-handler">23.8.7.64 mysql_set_local_infile_handler()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-set-server-option">23.8.7.65 mysql_set_server_option()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-shutdown">23.8.7.66 mysql_shutdown()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-sqlstate">23.8.7.67 mysql_sqlstate()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-ssl-set">23.8.7.68 mysql_ssl_set()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-stat">23.8.7.69 mysql_stat()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-store-result">23.8.7.70 mysql_store_result()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-thread-id">23.8.7.71 mysql_thread_id()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-use-result">23.8.7.72 mysql_use_result()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-warning-count">23.8.7.73 mysql_warning_count()</a></span></dt></dl></div><p>
      ここの説明で、<code class="literal">NULL</code> のパラメータまたは戻り値は、MySQL <code class="literal">NULL</code> 値ではなく、C プログラミング言語の意味での <code class="literal">NULL</code> を意味します。
    </p><p>
      値を返す関数は一般にポインタまたは整数を返します。ほかに指定がないかぎり、ポインタを返す関数は、成功を示す <code class="literal">NULL</code> 以外の値またはエラーを示す <code class="literal">NULL</code> 値を返し、整数を返す関数は成功を示すゼロまたはエラーを示すゼロ以外を返します。<span class="quote">「<span class="quote">ゼロ以外</span>」</span>はそれだけを意味します。関数の説明にほかに指示がないかぎり、ゼロ以外の値に対してテストしないでください。
    </p><pre class="programlisting">
if (result)                   /* correct */
    ... error ...

if (result &lt; 0)               /* incorrect */
    ... error ...

if (result == -1)             /* incorrect */
    ... error ...
</pre><p>
      関数がエラーを返す場合、関数の説明の<span class="bold"><strong>「エラー」</strong></span>サブセクションに、可能性のあるエラーの種類を一覧表示しています。<code class="literal">mysql_errno()</code> を呼び出すことによって、これらのうちどれが発生したかを知ることができます。<code class="literal">mysql_error()</code> を呼び出すことによって、エラーの文字列表現を取得できます。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-affected-rows"></a>23.8.7.1 mysql_affected_rows()</h4></div></div></div><a class="indexterm" name="idm139979002614080"></a><p>
        <code class="literal">my_ulonglong mysql_affected_rows(MYSQL *mysql)</code>
      </p><h5><a name="idm139979002611520"></a>説明</h5><p>
        <code class="literal">mysql_affected_rows()</code> は、<code class="literal">mysql_query()</code> または <code class="literal">mysql_real_query()</code> によるステートメントの実行直後に呼び出すことができます。それは、最後のステートメントが <code class="literal">UPDATE</code>、<code class="literal">DELETE</code>、または <code class="literal">INSERT</code> であった場合に、それによって変更、削除、または挿入された行数を返します。<code class="literal">SELECT</code> ステートメントの場合、<code class="literal">mysql_affected_rows()</code> は <code class="literal">mysql_num_rows()</code> のように動作します。
      </p><p>
        <code class="literal">UPDATE</code> ステートメントの場合、デフォルトで影響を受けた行の値は実際に変更された行の数です。<span class="command"><strong>mysqld</strong></span> への接続時に <code class="literal">CLIENT_FOUND_ROWS</code> フラグを <code class="literal">mysql_real_connect()</code> に指定した場合、影響を受けた行の値は<span class="quote">「<span class="quote">見つかった</span>」</span>、つまり <code class="literal">WHERE</code> 句に一致した行数です。
      </p><p>
        <code class="literal">REPLACE</code> ステートメントの場合、影響を受けた行の値は、新しい行が古い行に置き換わった場合 2 です。この場合、重複が削除されたあとに行が挿入されたためです。
      </p><p>
        <code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> ステートメントの場合、行ごとの影響を受けた行の値は、その行が新しい行として挿入された場合は 1、既存の行が更新された場合は 2、既存の行がその現在の値に設定された場合は 0 です。<code class="literal">CLIENT_FOUND_ROWS</code> フラグを指定した場合、影響を受けた行の値は、既存の行がその現在の値に設定された場合は (0 ではなく) 1 になります。
      </p><p>
        ストアドプロシージャーの <code class="literal">CALL</code> ステートメントに続く <code class="literal">mysql_affected_rows()</code> は、プロシージャー内の最後に実行されたステートメントに対して返す値か、またはそのステートメントが <code class="literal">-1</code> を返す場合は <code class="literal">0</code> を返します。プロシージャー内で、SQL レベルで <code class="literal">ROW_COUNT()</code> を使用して、個々のステートメントの影響を受けた行の値を取得できます。
      </p><p>
        MySQL 5.6 では、<code class="literal">mysql_affected_rows()</code> はより幅広いステートメントに対して有効な値を返します。詳細については、<a class="xref" href="functions.html#information-functions" title="12.14 情報関数">セクション12.14「情報関数」</a> の <code class="literal">ROW_COUNT()</code> の説明を参照してください。
      </p><h5><a name="idm139979002580784"></a>戻り値</h5><p>
        ゼロより大きい整数は影響を受けたか、取得された行の数を示します。ゼロは、<code class="literal">UPDATE</code> ステートメントに対してレコードが更新されなかったか、クエリー内の <code class="literal">WHERE</code> 句に一致した行がなかったか、クエリーがまだ実行されていないことを示します。-1 は、クエリーがエラーを返したか、<code class="literal">SELECT</code> クエリーの場合に、<code class="literal">mysql_store_result()</code> を呼び出す前に、<code class="literal">mysql_affected_rows()</code> が呼び出されたことを示します。
      </p><p>
        <code class="literal">mysql_affected_rows()</code> は符号なし値を返すため、戻り値を <code class="literal">(my_ulonglong)-1</code> (または同等である <code class="literal">(my_ulonglong)~0</code>) と比較することによって、-1 をチェックできます。
      </p><h5><a name="idm139979002571040"></a>エラー</h5><p>
        なし。
      </p><h5><a name="idm139979002569904"></a>例</h5><pre class="programlisting">
char *stmt = "UPDATE products SET cost=cost*1.25
              WHERE group=10";
mysql_query(&amp;mysql,stmt);
printf("%ld products updated",
       (long) mysql_affected_rows(&amp;mysql));
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-autocommit"></a>23.8.7.2 mysql_autocommit()</h4></div></div></div><a class="indexterm" name="idm139979002567184"></a><p>
        <code class="literal">my_bool mysql_autocommit(MYSQL *mysql, my_bool mode)</code>
      </p><h5><a name="idm139979002564624"></a>説明</h5><p>
        <code class="literal">mode</code> が 1 の場合、自動コミットモードをオンに、<code class="literal">mode</code> が 0 の場合、オフに設定します。
      </p><h5><a name="idm139979002561904"></a>戻り値</h5><p>
        成功の場合はゼロ。エラーが発生した場合、ゼロ以外。
      </p><h5><a name="idm139979002560640"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-change-user"></a>23.8.7.3 mysql_change_user()</h4></div></div></div><a class="indexterm" name="idm139979002558336"></a><p>
        <code class="literal">my_bool mysql_change_user(MYSQL *mysql, const char *user, const char *password, const char *db)</code>
      </p><h5><a name="idm139979002555728"></a>説明</h5><p>
        ユーザーを変更して、<code class="literal">db</code> で指定されたデータベースが、<code class="literal">mysql</code> で指定された接続でのデフォルト (現在) のデータベースになるようにします。その後のクエリーで、このデータベースは明示的なデータベース指定子を含まないテーブル参照のデフォルトになります。
      </p><p>
        <code class="literal">mysql_change_user()</code> は接続されたユーザーを認証できなかったか、データベースを使用する権限を持たない場合に失敗します。この場合、ユーザーとデータベースは変更されません。
      </p><p>
        デフォルトのデータベースが必要ない場合は、<code class="literal">NULL</code> の <code class="literal">db</code> パラメータを渡します。
      </p><p>
        この関数は、新しい接続を確立し、再認証されたかのように、セッションの状態をリセットします。(<a class="xref" href="connectors-apis.html#auto-reconnect" title="23.8.16 自動再接続動作の制御">セクション23.8.16「自動再接続動作の制御」</a>を参照してください。)それは常に、アクティブなトランザクションの <code class="literal">ROLLBACK</code> を実行し、すべての一時テーブルを閉じて削除し、ロックされているすべてのテーブルのロックを解除します。セッションシステム変数が、対応するグローバルシステム変数の値にリセットされます。プリペアドステートメントが解放され、<code class="literal">HANDLER</code> 変数が閉じられます。<code class="literal">GET_LOCK()</code> によって取得されたロックが解放されます。これらの効果は、ユーザーが変更しなかった場合でも発生します。
      </p><h5><a name="idm139979002543088"></a>戻り値</h5><p>
        成功の場合はゼロ。エラーが発生した場合、ゼロ以外。
      </p><h5><a name="idm139979002541824"></a>エラー</h5><p>
        <code class="literal">mysql_real_connect()</code> から取得する可能性があるものに加えて:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_COMMANDS_OUT_OF_SYNC</code>
          </p><p>
            コマンドが正しくない順番で実行されました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_GONE_ERROR</code>
          </p><p>
            MySQL サーバーが存在しなくなりました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_LOST</code>
          </p><p>
            サーバーへの接続がクエリー中に失われました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_UNKNOWN_ERROR</code>
          </p><p>
            不明なエラーが発生しました。
          </p></li><li class="listitem"><p>
            <code class="literal">ER_UNKNOWN_COM_ERROR</code>
          </p><p>
            MySQL サーバーはこのコマンドを実装しません (古いサーバーの可能性があります)。
          </p></li><li class="listitem"><p>
            <code class="literal">ER_ACCESS_DENIED_ERROR</code>
          </p><p>
            ユーザーまたはパスワードが誤っています。
          </p></li><li class="listitem"><p>
            <code class="literal">ER_BAD_DB_ERROR</code>
          </p><p>
            データベースが存在していません。
          </p></li><li class="listitem"><p>
            <code class="literal">ER_DBACCESS_DENIED_ERROR</code>
          </p><p>
            ユーザーはデータベースに対するアクセス権を持っていませんでした。
          </p></li><li class="listitem"><p>
            <code class="literal">ER_WRONG_DB_NAME</code>
          </p><p>
            データベース名が長すぎます。
          </p></li></ul></div><h5><a name="idm139979002518496"></a>例</h5><pre class="programlisting">
if (mysql_change_user(&amp;mysql, "user", "password", "new_database"))
{
   fprintf(stderr, "Failed to change user.  Error: %s\n",
           mysql_error(&amp;mysql));
}
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-character-set-name"></a>23.8.7.4 mysql_character_set_name()</h4></div></div></div><a class="indexterm" name="idm139979002515568"></a><p>
        <code class="literal">const char *mysql_character_set_name(MYSQL *mysql)</code>
      </p><h5><a name="idm139979002512976"></a>説明</h5><p>
        現在の接続のデフォルトの文字セット名を返します。
      </p><h5><a name="idm139979002511712"></a>戻り値</h5><p>
        デフォルトの文字セット名
      </p><h5><a name="idm139979002510512"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-close"></a>23.8.7.5 mysql_close()</h4></div></div></div><a class="indexterm" name="idm139979002508208"></a><p>
        <code class="literal">void mysql_close(MYSQL *mysql)</code>
      </p><h5><a name="idm139979002505664"></a>説明</h5><p>
        以前にオープンされた接続をクローズします。<code class="literal">mysql_close()</code> は、<code class="literal">mysql</code> によって指示された接続ハンドルが <code class="literal">mysql_init()</code> または <code class="literal">mysql_connect()</code> によって自動的に割り当てられている場合に、そのハンドルの割り当ても解除します。
      </p><h5><a name="idm139979002500416"></a>戻り値</h5><p>
        なし。
      </p><h5><a name="idm139979002499280"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-commit"></a>23.8.7.6 mysql_commit()</h4></div></div></div><a class="indexterm" name="idm139979002496976"></a><p>
        <code class="literal">my_bool mysql_commit(MYSQL *mysql)</code>
      </p><h5><a name="idm139979002494432"></a>説明</h5><p>
        現在のトランザクションをコミットします。
      </p><p>
        この関数のアクションは、<code class="literal">completion_type</code> システム変数の値に影響を受けます。特に、<code class="literal">completion_type</code> の値が <code class="literal">RELEASE</code> (または 2) の場合、トランザクションの終了後、サーバーは解放を実行し、クライアント接続を閉じます。クライアントプログラムから <code class="literal">mysql_close()</code> を呼び出して、クライアント側から接続をクローズします。
      </p><h5><a name="idm139979002488368"></a>戻り値</h5><p>
        成功の場合はゼロ。エラーが発生した場合、ゼロ以外。
      </p><h5><a name="idm139979002487104"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-connect"></a>23.8.7.7 mysql_connect()</h4></div></div></div><a class="indexterm" name="idm139979002484800"></a><p>
        <code class="literal">MYSQL *mysql_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd)</code>
      </p><h5><a name="idm139979002482192"></a>説明</h5><p>
        この関数は非推奨です。代わりに <code class="literal">mysql_real_connect()</code> を使用します。
      </p><p>
        <code class="literal">mysql_connect()</code> は<code class="literal">ホスト</code>で実行している MySQL データベースエンジンへの接続を確立します。<code class="literal">mysql_connect()</code> は、<code class="literal">mysql_get_client_info()</code> を除き、ほかのすべての API 関数を実行する前に正常に完了している必要があります。
      </p><p>
        パラメータの意味は、接続パラメータを <code class="literal">NULL</code> にできることを除き、<code class="literal">mysql_real_connect()</code> の対応するパラメータの場合と同じです。この場合、C API は、自動的に接続構造にメモリーを割り当て、<code class="literal">mysql_close()</code> が呼び出されると、それを解放します。このアプローチの短所は、接続が失敗した場合にエラーメッセージを取得できないことです。(<code class="literal">mysql_errno()</code> または <code class="literal">mysql_error()</code> から、エラー情報を得るには、有効な <code class="literal">MYSQL</code> ポインタを提供する必要があります。)
      </p><h5><a name="idm139979002468016"></a>戻り値</h5><p>
        <code class="literal">mysql_real_connect()</code> の場合と同じ。
      </p><h5><a name="idm139979002465904"></a>エラー</h5><p>
        <code class="literal">mysql_real_connect()</code> の場合と同じ。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-create-db"></a>23.8.7.8 mysql_create_db()</h4></div></div></div><a class="indexterm" name="idm139979002462624"></a><p>
        <code class="literal">int mysql_create_db(MYSQL *mysql, const char *db)</code>
      </p><h5><a name="idm139979002460064"></a>説明</h5><p>
        <code class="literal">db</code> パラメータによって指定されたデータベースを作成します。
      </p><p>
        この関数は非推奨です。代わりに、<code class="literal">mysql_query()</code> を使用して、SQL <code class="literal">CREATE DATABASE</code> ステートメントを発行することをお勧めします。
      </p><h5><a name="idm139979002454768"></a>戻り値</h5><p>
        成功の場合はゼロ。エラーが発生した場合、ゼロ以外。
      </p><h5><a name="idm139979002453504"></a>エラー</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_COMMANDS_OUT_OF_SYNC</code>
          </p><p>
            コマンドが正しくない順番で実行されました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_GONE_ERROR</code>
          </p><p>
            MySQL サーバーが存在しなくなりました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_LOST</code>
          </p><p>
            サーバーへの接続がクエリー中に失われました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_UNKNOWN_ERROR</code>
          </p><p>
            不明なエラーが発生しました。
          </p></li></ul></div><h5><a name="idm139979002443280"></a>例</h5><pre class="programlisting">
if(mysql_create_db(&amp;mysql, "my_database"))
{
   fprintf(stderr, "Failed to create new database.  Error: %s\n",
           mysql_error(&amp;mysql));
}
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-data-seek"></a>23.8.7.9 mysql_data_seek()</h4></div></div></div><a class="indexterm" name="idm139979002440432"></a><p>
        <code class="literal">void mysql_data_seek(MYSQL_RES *result, my_ulonglong offset)</code>
      </p><h5><a name="idm139979002437856"></a>説明</h5><p>
        クエリー結果セット内の任意の行にシークします。<code class="literal">offset</code> 値は行番号です。<code class="literal">0</code> から <code class="literal">mysql_num_rows(result)-1</code> までの範囲の値を指定します。
      </p><p>
        この関数は、結果セット構造にクエリーの結果全体を格納する必要があるため、<code class="literal">mysql_data_seek()</code> は、<code class="literal">mysql_use_result()</code> ではなく、<code class="literal">mysql_store_result()</code> とのみ一緒に使用できます。
      </p><h5><a name="idm139979002430368"></a>戻り値</h5><p>
        なし。
      </p><h5><a name="idm139979002429232"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-debug"></a>23.8.7.10 mysql_debug()</h4></div></div></div><a class="indexterm" name="idm139979002426928"></a><p>
        <code class="literal">void mysql_debug(const char *debug)</code>
      </p><h5><a name="idm139979002424384"></a>説明</h5><p>
        指定された文字列で <code class="literal">DBUG_PUSH</code> を実行します。<code class="literal">mysql_debug()</code> は Fred Fish デバッグライブラリを使用します。この関数を使うには、デバッグをサポートするように、クライアントライブラリをコンパイルする必要があります。<a class="xref" href="extending-mysql.html#dbug-package" title="24.4.3 DBUG パッケージ">セクション24.4.3「DBUG パッケージ」</a>を参照してください。
      </p><h5><a name="idm139979002420336"></a>戻り値</h5><p>
        なし。
      </p><h5><a name="idm139979002419232"></a>エラー</h5><p>
        なし。
      </p><h5><a name="idm139979002418096"></a>例</h5><p>
        ここに示す呼び出しによって、クライアントライブラリに、クライアントマシンの <code class="filename">/tmp/client.trace</code> 内にトレースファイルを生成させます。
      </p><pre class="programlisting">
mysql_debug("d:t:O,/tmp/client.trace");
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-drop-db"></a>23.8.7.11 mysql_drop_db()</h4></div></div></div><a class="indexterm" name="idm139979002414048"></a><p>
        <code class="literal">int mysql_drop_db(MYSQL *mysql, const char *db)</code>
      </p><h5><a name="idm139979002411488"></a>説明</h5><p>
        <code class="literal">db</code> パラメータによって指定されたデータベースを削除します。
      </p><p>
        この関数は非推奨です。代わりに、<code class="literal">mysql_query()</code> を使用して、SQL <code class="literal">DROP DATABASE</code> ステートメントを発行することをお勧めします。
      </p><h5><a name="idm139979002406192"></a>戻り値</h5><p>
        成功の場合はゼロ。エラーが発生した場合、ゼロ以外。
      </p><h5><a name="idm139979002404928"></a>エラー</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_COMMANDS_OUT_OF_SYNC</code>
          </p><p>
            コマンドが正しくない順番で実行されました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_GONE_ERROR</code>
          </p><p>
            MySQL サーバーが存在しなくなりました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_LOST</code>
          </p><p>
            サーバーへの接続がクエリー中に失われました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_UNKNOWN_ERROR</code>
          </p><p>
            不明なエラーが発生しました。
          </p></li></ul></div><h5><a name="idm139979002394704"></a>例</h5><pre class="programlisting">
if(mysql_drop_db(&amp;mysql, "my_database"))
  fprintf(stderr, "Failed to drop the database: Error: %s\n",
          mysql_error(&amp;mysql));
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-dump-debug-info"></a>23.8.7.12 mysql_dump_debug_info()</h4></div></div></div><a class="indexterm" name="idm139979002391888"></a><p>
        <code class="literal">int mysql_dump_debug_info(MYSQL *mysql)</code>
      </p><h5><a name="idm139979002389328"></a>説明</h5><p>
        サーバーにデバッグ情報をエラーログに書き込むように指示します。接続されたユーザーは <code class="literal">SUPER</code> 権限を持っている必要があります。
      </p><h5><a name="idm139979002386880"></a>戻り値</h5><p>
        成功の場合はゼロ。エラーが発生した場合、ゼロ以外。
      </p><h5><a name="idm139979002385616"></a>エラー</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_COMMANDS_OUT_OF_SYNC</code>
          </p><p>
            コマンドが正しくない順番で実行されました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_GONE_ERROR</code>
          </p><p>
            MySQL サーバーが存在しなくなりました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_LOST</code>
          </p><p>
            サーバーへの接続がクエリー中に失われました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_UNKNOWN_ERROR</code>
          </p><p>
            不明なエラーが発生しました。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-eof"></a>23.8.7.13 mysql_eof()</h4></div></div></div><a class="indexterm" name="idm139979002374224"></a><p>
        <code class="literal">my_bool mysql_eof(MYSQL_RES *result)</code>
      </p><h5><a name="idm139979002371680"></a>説明</h5><p>
        この関数は非推奨です。代わりに <code class="literal">mysql_errno()</code> または <code class="literal">mysql_error()</code> を使用できます。
      </p><p>
        <code class="literal">mysql_eof()</code> は結果セットの最後の行が読み取られているかどうかを判断します。
      </p><p>
        <code class="literal">mysql_store_result()</code> への成功した呼び出しから結果セットを取得する場合、クライアントは 1 回の操作でセット全体を受け取ります。この場合、<code class="literal">mysql_fetch_row()</code> からの <code class="literal">NULL</code> の戻り値は常に、結果セットの終わりに達したため、<code class="literal">mysql_eof()</code> を呼び出す必要がないことを意味します。<code class="literal">mysql_store_result()</code> と一緒に使うと、<code class="literal">mysql_eof()</code> は常に true を返します。
      </p><p>
        一方、<code class="literal">mysql_use_result()</code> を使用して、結果セットの取得を開始する場合、<code class="literal">mysql_fetch_row()</code> を繰り返し呼び出すと、セットの行がサーバーから 1 つずつ取得されます。このプロセス中に接続でエラーが発生する可能性があるため、<code class="literal">mysql_fetch_row()</code> からの <code class="literal">NULL</code> の戻り値は、必ずしも結果セットの終わりに正常に達したことを意味するとはかぎりません。この場合、<code class="literal">mysql_eof()</code> を使用して、何が発生したかを判断できます。<code class="literal">mysql_eof()</code> は、結果セットの終わりに達した場合にゼロ以外の値を返し、エラーが発生した場合にゼロを返します。
      </p><p>
        歴史的に、<code class="literal">mysql_eof()</code> は、標準 MySQL エラー関数の <code class="literal">mysql_errno()</code> や <code class="literal">mysql_error()</code> より前から存在しています。それらのエラー関数は同じ情報を提供するため、非推奨である <code class="literal">mysql_eof()</code> よりそれらの使用が優先されます。(実際、それらはより多くの情報を提供します。エラー関数はエラーが発生するとその理由を示すのに対して、<code class="literal">mysql_eof()</code> はブール値しか返さないためです。)
      </p><h5><a name="idm139979002346016"></a>戻り値</h5><p>
        成功の場合はゼロ。結果セットの終わりに達した場合はゼロ以外。
      </p><h5><a name="idm139979002344720"></a>エラー</h5><p>
        なし。
      </p><h5><a name="idm139979002343584"></a>例</h5><p>
        次の例は、<code class="literal">mysql_eof()</code> の使用方法を示しています。
      </p><pre class="programlisting">
mysql_query(&amp;mysql,"SELECT * FROM some_table");
result = mysql_use_result(&amp;mysql);
while((row = mysql_fetch_row(result)))
{
    // do something with data
}
if(!mysql_eof(result))  // mysql_fetch_row() failed due to an error
{
    fprintf(stderr, "Error: %s\n", mysql_error(&amp;mysql));
}
</pre><p>
        ただし、標準 MySQL エラー関数で同じ効果を達成できます。
      </p><pre class="programlisting">
mysql_query(&amp;mysql,"SELECT * FROM some_table");
result = mysql_use_result(&amp;mysql);
while((row = mysql_fetch_row(result)))
{
    // do something with data
}
if(mysql_errno(&amp;mysql))  // mysql_fetch_row() failed due to an error
{
    fprintf(stderr, "Error: %s\n", mysql_error(&amp;mysql));
}
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-errno"></a>23.8.7.14 mysql_errno()</h4></div></div></div><a class="indexterm" name="idm139979002336960"></a><p>
        <code class="literal">unsigned int mysql_errno(MYSQL *mysql)</code>
      </p><h5><a name="idm139979002334416"></a>説明</h5><p>
        <code class="literal">mysql</code> で指定された接続に対し、<code class="literal">mysql_errno()</code> は、成功したか失敗した可能性のある最近呼び出された API 関数のエラーコードを返します。ゼロの戻り値はエラーが発生しなかったことを意味します。クライアントのエラーメッセージ番号は、MySQL <code class="filename">errmsg.h</code> ヘッダーファイルに一覧表示されています。サーバーのエラーメッセージ番号は、<code class="filename">mysqld_error.h</code> に一覧表示されています。エラーは<a class="xref" href="error-handling.html" title="付録 B エラー、エラーコード、および一般的な問題">付録B <i>エラー、エラーコード、および一般的な問題</i></a>にも一覧表示しています。
      </p><p>
        <code class="literal">mysql_fetch_row()</code> のような一部の関数は成功した場合に、<code class="literal">mysql_errno()</code> を設定しません。
      </p><p>
        原則として、サーバーに情報を求める必要があるすべての関数は、成功した場合に <code class="literal">mysql_errno()</code> をリセットします。
      </p><p>
        <code class="literal">mysql_errno()</code> によって返される MySQL 固有のエラー番号は、<code class="literal">mysql_sqlstate()</code> によって返される SQLSTATE 値とは異なります。たとえば、<span class="command"><strong>mysql</strong></span> クライアントプログラムは、次の形式を使用してエラーを表示します。ここで、<code class="literal">1146</code> は <code class="literal">mysql_errno()</code> 値で、<code class="literal">'42S02'</code> は対応する <code class="literal">mysql_sqlstate()</code> 値です。
      </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>SELECT * FROM no_such_table;</code></strong>
ERROR 1146 (42S02): Table 'test.no_such_table' doesn't exist
</pre><h5><a name="idm139979002315920"></a>戻り値</h5><p>
        最後の <code class="literal">mysql_<em class="replaceable"><code>xxx</code></em>()</code> 呼び出しが失敗した場合は、そのエラーコード値。ゼロはエラーが発生しなかったことを意味します。
      </p><h5><a name="idm139979002313424"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-error"></a>23.8.7.15 mysql_error()</h4></div></div></div><a class="indexterm" name="idm139979002311120"></a><p>
        <code class="literal">const char *mysql_error(MYSQL *mysql)</code>
      </p><h5><a name="idm139979002308576"></a>説明</h5><p>
        <code class="literal">mysql</code> で指定された接続に対し、<code class="literal">mysql_error()</code> は、最近呼び出されて失敗した API 関数のエラーメッセージを含む、NULL 終端文字列を返します。関数が失敗しなかった場合、<code class="literal">mysql_error()</code> の戻り値は前のエラーか、またはエラーがないことを示す空の文字列になります。
      </p><p>
        原則として、サーバーに情報を求める必要があるすべての関数は、成功した場合に <code class="literal">mysql_error()</code> をリセットします。
      </p><p>
        <code class="literal">mysql_error()</code> をリセットする関数の場合、これらの 2 つのテストのどちらかを使用して、エラーをチェックできます。
      </p><pre class="programlisting">
if(*mysql_error(&amp;mysql))
{
  // an error occurred
}

if(mysql_error(&amp;mysql)[0])
{
  // an error occurred
}
</pre><p>
        クライアントエラーメッセージの言語は、MySQL クライアントライブラリを再コンパイルすることによって変更できます。現在、数種類の言語のエラーメッセージを選択できます。<a class="xref" href="globalization.html#error-message-language" title="10.2 エラーメッセージ言語の設定">セクション10.2「エラーメッセージ言語の設定」</a>を参照してください。
      </p><h5><a name="idm139979002298384"></a>戻り値</h5><p>
        エラーを説明する NULL 終端文字列。エラーが発生しなかった場合は空の文字列。
      </p><h5><a name="idm139979002297072"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-escape-string"></a>23.8.7.16 mysql_escape_string()</h4></div></div></div><a class="indexterm" name="idm139979002294768"></a><p>
        代わりに <code class="literal">mysql_real_escape_string()</code> を使用してください。
      </p><p>
        この関数は、<code class="literal">mysql_real_escape_string()</code> がその最初の引数として、接続ハンドラをとり、文字列を現在の文字セットに従ってエスケープすることを除き、<code class="literal">mysql_real_escape_string()</code> と同じです。<code class="literal">mysql_escape_string()</code> は接続引数をとらず、現在の文字セットを考慮しません。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-fetch-field"></a>23.8.7.17 mysql_fetch_field()</h4></div></div></div><a class="indexterm" name="idm139979002286704"></a><p>
        <code class="literal">MYSQL_FIELD *mysql_fetch_field(MYSQL_RES *result)</code>
      </p><h5><a name="idm139979002284144"></a>説明</h5><p>
        <code class="literal">MYSQL_FIELD</code> 構造として設定された結果セットの 1 つのカラムの定義を返します。この関数を繰り返し呼び出して、結果セット内のすべてのカラムに関する情報を取得します。それ以上残っているフィールドがなくなると、<code class="literal">mysql_fetch_field()</code> は <code class="literal">NULL</code> を返します。
      </p><p>
        新しい <code class="literal">SELECT</code> クエリーを実行するたびに、<code class="literal">mysql_fetch_field()</code> はリセットされて、最初のフィールドに関する情報を返します。<code class="literal">mysql_fetch_field()</code> によって返されるフィールドは、<code class="literal">mysql_field_seek()</code> への呼び出しによっても影響を受けます。
      </p><p>
        <code class="literal">mysql_query()</code> を呼び出して、テーブルに対する <code class="literal">SELECT</code> を実行したが、<code class="literal">mysql_store_result()</code> を呼び出さなかった場合、<code class="literal">mysql_fetch_field()</code> を呼び出して、<code class="literal">BLOB</code> フィールドの長さを求めると、MySQL はデフォルト BLOB の長さ (8K バイト) を返します。(MySQL は <code class="literal">BLOB</code> の最大長を知らないため、8K バイトのサイズが選択されます。これはいずれ構成可能にされます。)結果セットを取得したら、<code class="literal">field-&gt;max_length</code> には、特定のクエリー内のこのカラムの最大値の長さが格納されます。
      </p><h5><a name="idm139979002267200"></a>戻り値</h5><p>
        現在のカラムの <code class="literal">MYSQL_FIELD</code> 構造。カラムが残っていない場合は <code class="literal">NULL</code>。
      </p><h5><a name="idm139979002264528"></a>エラー</h5><p>
        なし。
      </p><h5><a name="idm139979002263392"></a>例</h5><pre class="programlisting">
MYSQL_FIELD *field;

while((field = mysql_fetch_field(result)))
{
    printf("field name %s\n", field-&gt;name);
}
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-fetch-field-direct"></a>23.8.7.18 mysql_fetch_field_direct()</h4></div></div></div><a class="indexterm" name="idm139979002260608"></a><p>
        <code class="literal">MYSQL_FIELD *mysql_fetch_field_direct(MYSQL_RES *result, unsigned int fieldnr)</code>
      </p><h5><a name="idm139979002257984"></a>説明</h5><p>
        結果セット内のカラムのフィールド番号 <code class="literal">fieldnr</code> を指定すると、そのカラムのフィールド定義が <code class="literal">MYSQL_FIELD</code> 構造として返されます。この関数を使用して、任意のカラムの定義を取得します。0 から <code class="literal">mysql_num_fields(result)-1</code> までの範囲で、<code class="literal">fieldnr</code> の値を指定します。
      </p><h5><a name="idm139979002253184"></a>戻り値</h5><p>
        指定したカラムの <code class="literal">MYSQL_FIELD</code> 構造。
      </p><h5><a name="idm139979002251296"></a>エラー</h5><p>
        なし。
      </p><h5><a name="idm139979002250160"></a>例</h5><pre class="programlisting">
unsigned int num_fields;
unsigned int i;
MYSQL_FIELD *field;

num_fields = mysql_num_fields(result);
for(i = 0; i &lt; num_fields; i++)
{
    field = mysql_fetch_field_direct(result, i);
    printf("Field %u is %s\n", i, field-&gt;name);
}
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-fetch-fields"></a>23.8.7.19 mysql_fetch_fields()</h4></div></div></div><a class="indexterm" name="idm139979002247152"></a><p>
        <code class="literal">MYSQL_FIELD *mysql_fetch_fields(MYSQL_RES *result)</code>
      </p><h5><a name="idm139979002244592"></a>説明</h5><p>
        結果セットのすべての <code class="literal">MYSQL_FIELD</code> 構造の配列を返します。各構造は、結果セットの 1 つのカラムのフィールドの定義を示します。
      </p><h5><a name="idm139979002242448"></a>戻り値</h5><p>
        結果セットのすべてのカラムの <code class="literal">MYSQL_FIELD</code> 構造の配列。
      </p><h5><a name="idm139979002240496"></a>エラー</h5><p>
        なし。
      </p><h5><a name="idm139979002239360"></a>例</h5><pre class="programlisting">
unsigned int num_fields;
unsigned int i;
MYSQL_FIELD *fields;

num_fields = mysql_num_fields(result);
fields = mysql_fetch_fields(result);
for(i = 0; i &lt; num_fields; i++)
{
   printf("Field %u is %s\n", i, fields[i].name);
}
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-fetch-lengths"></a>23.8.7.20 mysql_fetch_lengths()</h4></div></div></div><a class="indexterm" name="idm139979002236592"></a><p>
        <code class="literal">unsigned long *mysql_fetch_lengths(MYSQL_RES *result)</code>
      </p><h5><a name="idm139979002234032"></a>説明</h5><p>
        結果セット内の現在の行のカラムの長さを返します。フィールド値をコピーする予定がある場合、この長さ情報は、<code class="literal">strlen()</code> の呼び出しを避けることができるため、最適化にも役立ちます。さらに、結果セットにバイナリデータが含まれている場合、<code class="literal">strlen()</code> は NULL 文字を含むフィールドについて誤った結果を返すため、この関数を使用して、データのサイズを判断する<span class="bold"><strong>必要があります</strong></span>。
      </p><p>
        空のカラムおよび <code class="literal">NULL</code> 値を含むカラムの長さはゼロです。これらの 2 つのケースを区別する方法を確認するには、<code class="literal">mysql_fetch_row()</code> の説明を参照してください。
      </p><h5><a name="idm139979002227344"></a>戻り値</h5><p>
        各カラム (終端の NULL 文字を含まない) のサイズを表す符号なし long 整数の配列。エラーが発生した場合は <code class="literal">NULL</code>。
      </p><h5><a name="idm139979002225232"></a>エラー</h5><p>
        <code class="literal">mysql_fetch_lengths()</code> は結果セットの現在の行に対してのみ有効です。それを <code class="literal">mysql_fetch_row()</code> を呼び出す前または結果内のすべての行を取得したあとに呼び出すと、それは <code class="literal">NULL</code> を返します。
      </p><h5><a name="idm139979002221088"></a>例</h5><pre class="programlisting">
MYSQL_ROW row;
unsigned long *lengths;
unsigned int num_fields;
unsigned int i;

row = mysql_fetch_row(result);
if (row)
{
    num_fields = mysql_num_fields(result);
    lengths = mysql_fetch_lengths(result);
    for(i = 0; i &lt; num_fields; i++)
    {
         printf("Column %u is %lu bytes in length.\n",
                i, lengths[i]);
    }
}
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-fetch-row"></a>23.8.7.21 mysql_fetch_row()</h4></div></div></div><a class="indexterm" name="idm139979002218096"></a><p>
        <code class="literal">MYSQL_ROW mysql_fetch_row(MYSQL_RES *result)</code>
      </p><h5><a name="idm139979002215536"></a>説明</h5><p>
        結果セットの次の行を取得します。<code class="literal">mysql_store_result()</code> のあとで使用すると、<code class="literal">mysql_fetch_row()</code> は、それ以上取得する行がない場合に、<code class="literal">NULL</code> を返します。<code class="literal">mysql_use_result()</code> のあとで使用すると、<code class="literal">mysql_fetch_row()</code> は、それ以上取得する行がないか、エラーが発生した場合に <code class="literal">NULL</code> を返します。
      </p><p>
        行内の値の数は <code class="literal">mysql_num_fields(result)</code> によって指定されます。<code class="literal">row</code> が <code class="literal">mysql_fetch_row()</code> への呼び出しからの戻り値を保持している場合、その値へのポインタは、<code class="literal">row[0]</code> から <code class="literal">row[mysql_num_fields(result)-1]</code> までとしてアクセスされます。行内の <code class="literal">NULL</code> 値は <code class="literal">NULL</code> ポインタによって示されます。
      </p><p>
        行内のフィールド値の長さは、<code class="literal">mysql_fetch_lengths()</code> を呼び出すことによって取得できます。空のフィールドと <code class="literal">NULL</code> を含むフィールドはどちらも長さが 0 です。これらを区別するには、フィールド値のポインタをチェックします。ポインタが <code class="literal">NULL</code> である場合、フィールドは <code class="literal">NULL</code> です。そうでない場合、フィールドは空です。
      </p><h5><a name="idm139979002197776"></a>戻り値</h5><p>
        次の行の <code class="literal">MYSQL_ROW</code> 構造。それ以上取得する行がないか、エラーが発生した場合は <code class="literal">NULL</code>。
      </p><h5><a name="idm139979002195040"></a>エラー</h5><p>
        <code class="literal">mysql_fetch_row()</code> の呼び出しと呼び出しの間に、エラーはリセットされません。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_SERVER_LOST</code>
          </p><p>
            サーバーへの接続がクエリー中に失われました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_UNKNOWN_ERROR</code>
          </p><p>
            不明なエラーが発生しました。
          </p></li></ul></div><h5><a name="idm139979002187856"></a>例</h5><pre class="programlisting">
MYSQL_ROW row;
unsigned int num_fields;
unsigned int i;

num_fields = mysql_num_fields(result);
while ((row = mysql_fetch_row(result)))
{
   unsigned long *lengths;
   lengths = mysql_fetch_lengths(result);
   for(i = 0; i &lt; num_fields; i++)
   {
       printf("[%.*s] ", (int) lengths[i],
              row[i] ? row[i] : "NULL");
   }
   printf("\n");
}
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-field-count"></a>23.8.7.22 mysql_field_count()</h4></div></div></div><a class="indexterm" name="idm139979002184880"></a><p>
        <code class="literal">unsigned int mysql_field_count(MYSQL *mysql)</code>
      </p><h5><a name="idm139979002182320"></a>説明</h5><p>
        接続での最近のクエリーのカラムの数を返します。
      </p><p>
        この関数を通常使用するときは、<code class="literal">mysql_store_result()</code> が <code class="literal">NULL</code> を返した (および、そのために結果セットポインタがない) ときです。この場合、<code class="literal">mysql_field_count()</code> を呼び出して、<code class="literal">mysql_store_result()</code> が空でない結果を生成しているかどうかを判断できます。これにより、クライアントプログラムは、クエリーが <code class="literal">SELECT</code> (または <code class="literal">SELECT</code> に似た) ステートメントであったかどうかを知らなくても、正しいアクションをとることができます。ここに示す例では、これを実行する方法を説明しています。
      </p><p>
        <a class="xref" href="connectors-apis.html#null-mysql-store-result" title="23.8.15.1 mysql_query() が成功を返したあとに mysql_store_result() が NULL を返すことがあるのはなぜか">セクション23.8.15.1「mysql_query() が成功を返したあとに mysql_store_result() が NULL を返すことがあるのはなぜか」</a>を参照してください。
      </p><h5><a name="idm139979002172608"></a>戻り値</h5><p>
        結果セット内のカラムの数を表す符号なし整数。
      </p><h5><a name="idm139979002171392"></a>エラー</h5><p>
        なし。
      </p><h5><a name="idm139979002170256"></a>例</h5><pre class="programlisting">
MYSQL_RES *result;
unsigned int num_fields;
unsigned int num_rows;

if (mysql_query(&amp;mysql,query_string))
{
    // error
}
else // query succeeded, process any data returned by it
{
    result = mysql_store_result(&amp;mysql);
    if (result)  // there are rows
    {
        num_fields = mysql_num_fields(result);
        // retrieve rows, then call mysql_free_result(result)
    }
    else  // mysql_store_result() returned nothing; should it have?
    {
        if(mysql_field_count(&amp;mysql) == 0)
        {
            // query does not return data
            // (it was not a SELECT)
            num_rows = mysql_affected_rows(&amp;mysql);
        }
        else // mysql_store_result() should have returned data
        {
            fprintf(stderr, "Error: %s\n", mysql_error(&amp;mysql));
        }
    }
}
</pre><p>
        代替方法は <code class="literal">mysql_field_count(&amp;mysql)</code> 呼び出しを <code class="literal">mysql_errno(&amp;mysql)</code> で置き換えることです。この場合、<code class="literal">mysql_field_count()</code> の値から、ステートメントが <code class="literal">SELECT</code> であったかどうかを推定するのではなく、<code class="literal">mysql_store_result()</code> から直接、エラーをチェックします。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-field-seek"></a>23.8.7.23 mysql_field_seek()</h4></div></div></div><a class="indexterm" name="idm139979002160432"></a><p>
        <code class="literal">MYSQL_FIELD_OFFSET mysql_field_seek(MYSQL_RES *result, MYSQL_FIELD_OFFSET offset)</code>
      </p><h5><a name="idm139979002157840"></a>説明</h5><p>
        フィールドカーソルを、指定されたオフセットに設定します。<code class="literal">mysql_fetch_field()</code> への次の呼び出しは、そのオフセットに関連付けられているカラムのフィールド定義を取得します。
      </p><p>
        行の先頭にシークするには、ゼロの <code class="literal">offset</code> 値を渡します。
      </p><h5><a name="idm139979002154016"></a>戻り値</h5><p>
        フィールドカーソルの以前の値。
      </p><h5><a name="idm139979002152800"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-field-tell"></a>23.8.7.24 mysql_field_tell()</h4></div></div></div><a class="indexterm" name="idm139979002150496"></a><p>
        <code class="literal">MYSQL_FIELD_OFFSET mysql_field_tell(MYSQL_RES *result)</code>
      </p><h5><a name="idm139979002147936"></a>説明</h5><p>
        最後の <code class="literal">mysql_fetch_field()</code> に使用されたフィールドカーソルの位置を返します。この値は <code class="literal">mysql_field_seek()</code> への引数として使用できます。
      </p><h5><a name="idm139979002144592"></a>戻り値</h5><p>
        フィールドカーソルの現在のオフセット。
      </p><h5><a name="idm139979002143360"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-free-result"></a>23.8.7.25 mysql_free_result()</h4></div></div></div><a class="indexterm" name="idm139979002141056"></a><p>
        <code class="literal">void mysql_free_result(MYSQL_RES *result)</code>
      </p><h5><a name="idm139979002138496"></a>説明</h5><p>
        <code class="literal">mysql_store_result()</code>、<code class="literal">mysql_use_result()</code>、<code class="literal">mysql_list_dbs()</code> などによって結果セットに割り当てられたメモリーを解放します。結果セットの処理が終了したら、<code class="literal">mysql_free_result()</code> を呼び出して、それが使用しているメモリーを解放する必要があります。
      </p><p>
        それを解放したあとに、結果セットにアクセスしようとしないでください。
      </p><h5><a name="idm139979002132368"></a>戻り値</h5><p>
        なし。
      </p><h5><a name="idm139979002131232"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-get-character-set-info"></a>23.8.7.26 mysql_get_character_set_info()</h4></div></div></div><a class="indexterm" name="idm139979002128880"></a><p>
        <code class="literal">void mysql_get_character_set_info(MYSQL *mysql, MY_CHARSET_INFO *cs)</code>
      </p><h5><a name="idm139979002126272"></a>説明</h5><p>
        この関数はデフォルトのクライアント文字セットに関する情報を提供します。デフォルトの文字セットは <code class="literal">mysql_set_character_set()</code> 関数で変更できます。
      </p><h5><a name="idm139979002123808"></a>例</h5><p>
        この例に、<code class="literal">MY_CHARSET_INFO</code> 構造の使用可能なフィールドを示します。
      </p><pre class="programlisting">
if (!mysql_set_character_set(&amp;mysql, "utf8"))
{
    MY_CHARSET_INFO cs;
    mysql_get_character_set_info(&amp;mysql, &amp;cs);
    printf("character set information:\n");
    printf("character set+collation number: %d\n", cs.number);
    printf("character set name: %s\n", cs.name);
    printf("collation name: %s\n", cs.csname);
    printf("comment: %s\n", cs.comment);
    printf("directory: %s\n", cs.dir);
    printf("multi byte character min. length: %d\n", cs.mbminlen);
    printf("multi byte character max. length: %d\n", cs.mbmaxlen);
}
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-get-client-info"></a>23.8.7.27 mysql_get_client_info()</h4></div></div></div><a class="indexterm" name="idm139979002118592"></a><p>
        <code class="literal">const char *mysql_get_client_info(void)</code>
      </p><h5><a name="idm139979002116032"></a>説明</h5><p>
        <code class="literal">"5.6.23"</code> など、MySQL クライアントライブラリバージョンを表す文字列を返します。
      </p><p>
        この関数値は MySQL バージョンです。Connector/C では、これは Connector/C 配布がベースにしている MySQL のバージョンです。詳細については、<a class="xref" href="connectors-apis.html#c-api-server-client-versions" title="23.8.4.4 C API サーバーおよびクライアントライブラリのバージョン">セクション23.8.4.4「C API サーバーおよびクライアントライブラリのバージョン」</a>を参照してください。
      </p><h5><a name="idm139979002112416"></a>戻り値</h5><p>
        MySQL クライアントライブラリバージョンを表す文字列。
      </p><h5><a name="idm139979002111152"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-get-client-version"></a>23.8.7.28 mysql_get_client_version()</h4></div></div></div><a class="indexterm" name="idm139979002108800"></a><p>
        <code class="literal">unsigned long mysql_get_client_version(void)</code>
      </p><h5><a name="idm139979002106208"></a>説明</h5><p>
        MySQL クライアントライブラリバージョンを表す整数を返します。値の形式は <code class="literal">XYYZZ</code> であり、ここで <code class="literal">X</code> はメジャーバージョン、<code class="literal">YY</code> はリリースレベル (またはマイナーバージョン)、および <code class="literal">ZZ</code> はリリースレベル内のサブバージョンです。
      </p><pre class="programlisting">
major_version*10000 + release_level*100 + sub_version
</pre><p>
        たとえば、<code class="literal">"5.6.23"</code> は <code class="literal">50623</code> と返されます。
      </p><p>
        この関数値は MySQL バージョンです。Connector/C では、これは Connector/C 配布がベースにしている MySQL のバージョンです。詳細については、<a class="xref" href="connectors-apis.html#c-api-server-client-versions" title="23.8.4.4 C API サーバーおよびクライアントライブラリのバージョン">セクション23.8.4.4「C API サーバーおよびクライアントライブラリのバージョン」</a>を参照してください。
      </p><h5><a name="idm139979002097552"></a>戻り値</h5><p>
        MySQL クライアントライブラリバージョンを表す整数。
      </p><h5><a name="idm139979002096288"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-get-host-info"></a>23.8.7.29 mysql_get_host_info()</h4></div></div></div><a class="indexterm" name="idm139979002093984"></a><p>
        <code class="literal">const char *mysql_get_host_info(MYSQL *mysql)</code>
      </p><h5><a name="idm139979002091408"></a>説明</h5><p>
        サーバーホスト名を含む使用している接続の種類を示す文字列を返します。
      </p><h5><a name="idm139979002090080"></a>戻り値</h5><p>
        サーバーホスト名および接続の種類を表す文字列。
      </p><h5><a name="idm139979002088816"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-get-proto-info"></a>23.8.7.30 mysql_get_proto_info()</h4></div></div></div><a class="indexterm" name="idm139979002086512"></a><p>
        <code class="literal">unsigned int mysql_get_proto_info(MYSQL *mysql)</code>
      </p><h5><a name="idm139979002083936"></a>説明</h5><p>
        現在の接続で使用されているプロトコルのバージョンを返します。
      </p><h5><a name="idm139979002082640"></a>戻り値</h5><p>
        現在の接続で使用されているプロトコルのバージョンを表す符号なし整数。
      </p><h5><a name="idm139979002081312"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-get-server-info"></a>23.8.7.31 mysql_get_server_info()</h4></div></div></div><a class="indexterm" name="idm139979002079008"></a><p>
        <code class="literal">const char *mysql_get_server_info(MYSQL *mysql)</code>
      </p><h5><a name="idm139979002076432"></a>説明</h5><p>
        <code class="literal">"5.6.23"</code> など、MySQL サーバーバージョンを表す文字列を返します。
      </p><h5><a name="idm139979002074480"></a>戻り値</h5><p>
        MySQL サーバーバージョンを表す文字列。
      </p><h5><a name="idm139979002073248"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-get-server-version"></a>23.8.7.32 mysql_get_server_version()</h4></div></div></div><a class="indexterm" name="idm139979002070896"></a><p>
        <code class="literal">unsigned long mysql_get_server_version(MYSQL *mysql)</code>
      </p><h5><a name="idm139979002068304"></a>説明</h5><p>
        MySQL サーバーバージョンを表す整数を返します。値の形式は <code class="literal">XYYZZ</code> であり、ここで <code class="literal">X</code> はメジャーバージョン、<code class="literal">YY</code> はリリースレベル (またはマイナーバージョン)、および <code class="literal">ZZ</code> はリリースレベル内のサブバージョンです。
      </p><pre class="programlisting">
major_version*10000 + release_level*100 + sub_version
</pre><p>
        たとえば、<code class="literal">"5.6.23"</code> は <code class="literal">50623</code> と返されます。
      </p><p>
        この関数は、クライアントプログラムで、何らかのバージョン固有のサーバー機能が存在するかどうかを判断するために役立ちます。
      </p><h5><a name="idm139979002060448"></a>戻り値</h5><p>
        MySQL サーバーバージョンを表す整数。
      </p><h5><a name="idm139979002059232"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-get-ssl-cipher"></a>23.8.7.33 mysql_get_ssl_cipher()</h4></div></div></div><a class="indexterm" name="idm139979002056976"></a><p>
        <code class="literal">const char *mysql_get_ssl_cipher(MYSQL *mysql)</code>
      </p><h5><a name="idm139979002054400"></a>説明</h5><p>
        <code class="literal">mysql_get_ssl_cipher()</code> はサーバーへの指定された接続で使用される SSL 暗号を返します。<code class="literal">mysql</code> は <code class="literal">mysql_init()</code> から返される接続ハンドラです。
      </p><h5><a name="idm139979002050368"></a>戻り値</h5><p>
        接続に使われる SSL 暗号を指定する文字列、または暗号が使われていない場合は <code class="literal">NULL</code>。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-hex-string"></a>23.8.7.34 mysql_hex_string()</h4></div></div></div><a class="indexterm" name="idm139979002047152"></a><p>
        <code class="literal">unsigned long mysql_hex_string(char *to, const char *from, unsigned long length)</code>
      </p><h5><a name="idm139979002044560"></a>説明</h5><p>
        この関数は、SQL ステートメントで使用できる正当な SQL 文字列を作成するために使われます。<a class="xref" href="language-structure.html#string-literals" title="9.1.1 文字列リテラル">セクション9.1.1「文字列リテラル」</a>を参照してください。
      </p><p>
        <code class="literal">from</code> 内の文字列は、各文字が 2 桁の 16 進数としてエンコードされた 16 進形式にエンコードされます。結果は <code class="literal">to</code> に置かれ、終端の NULL バイトが付加されます。
      </p><p>
        <code class="literal">from</code> によって指示される文字列は、<code class="literal">length</code> バイトの長さである必要があります。<code class="literal">to</code> バッファーを少なくとも <code class="literal">length*2+1</code> バイト長になるように割り当てる必要があります。<code class="literal">mysql_hex_string()</code> が戻ると、<code class="literal">to</code> の内容は NULL 終端文字列になっています。戻り値は、終端の NULL 文字を含まない、エンコードされた文字列の長さです。
      </p><p>
        戻り値は <code class="literal">0x<em class="replaceable"><code>value</code></em></code> または <code class="literal">X'<em class="replaceable"><code>value</code></em>'</code> 形式を使用して、SQL ステートメントに配置できます。ただし、戻り値には、<code class="literal">0x</code> または <code class="literal">X'...'</code> は含まれません。呼び出し元は、要求されたものをなんでも提供する必要があります。
      </p><h5><a name="idm139979002030368"></a>例</h5><pre class="programlisting">
char query[1000],*end;

end = strmov(query,"INSERT INTO test_table values(");
end = strmov(end,"0x");
end += mysql_hex_string(end,"What is this",12);
end = strmov(end,",0x");
end += mysql_hex_string(end,"binary data: \0\r\n",16);
*end++ = ')';

if (mysql_real_query(&amp;mysql,query,(unsigned int) (end - query)))
{
   fprintf(stderr, "Failed to insert row, Error: %s\n",
           mysql_error(&amp;mysql));
}
</pre><p>
        例で使用している <code class="literal">strmov()</code> 関数は、<code class="literal">libmysqlclient</code> ライブラリに含まれ、<code class="literal">strcpy()</code> のように機能しますが、最初のパラメータの終端の NULL へのポインタを返します。
      </p><h5><a name="idm139979002025552"></a>戻り値</h5><p>
        <code class="literal">to</code> に置かれた、終端の NULL 文字を含まない値の長さ。
      </p><h5><a name="idm139979002023648"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-info"></a>23.8.7.35 mysql_info()</h4></div></div></div><a class="indexterm" name="idm139979002021392"></a><p>
        <code class="literal">const char *mysql_info(MYSQL *mysql)</code>
      </p><h5><a name="idm139979002018848"></a>説明</h5><p>
        最近実行されたステートメント、ただしここに示すステートメントのみに関する情報を提供する文字列を取得します。ほかのステートメントに対しては、<code class="literal">mysql_info()</code> は <code class="literal">NULL</code> を返します。ここで説明するように、文字列の書式はステートメントの種類によって変わります。数字は一例にすぎず、文字列にはステートメントに適切な値が含まれます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">INSERT INTO ... SELECT ...</code>
          </p><p>
            文字列の書式: <code class="literal">レコード数: 100 重複: 0 警告: 0</code>
          </p></li><li class="listitem"><p>
            <code class="literal">INSERT INTO ... VALUES (...),(...),(...)...</code>
          </p><p>
            文字列の書式: <code class="literal">レコード数: 3 重複: 0 警告: 0</code>
          </p></li><li class="listitem"><p>
            <code class="literal">LOAD DATA INFILE ...</code>
          </p><p>
            文字列の書式: <code class="literal">レコード数: 1 削除: 0 スキップ: 0 警告: 0</code>
          </p></li><li class="listitem"><p>
            <code class="literal">ALTER TABLE</code>
          </p><p>
            文字列の書式: <code class="literal">レコード数: 3 重複: 0 警告: 0</code>
          </p></li><li class="listitem"><p>
            <code class="literal">UPDATE</code>
          </p><p>
            文字列の書式: <code class="literal">該当した行: 40 変更: 40 警告: 0</code>
          </p></li></ul></div><p>
        <code class="literal">mysql_info()</code> は <code class="literal">INSERT ... VALUES</code> ステートメントの複数行形式に対してのみ、<code class="literal">NULL</code> 以外の値を返します (つまり、複数値のリストが指定されている場合のみ)。
      </p><h5><a name="idm139979001996240"></a>戻り値</h5><p>
        最近実行されたステートメントに関する追加情報を表す文字列。ステートメントに対する情報を使用できない場合は <code class="literal">NULL</code>。
      </p><h5><a name="idm139979001994096"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-init"></a>23.8.7.36 mysql_init()</h4></div></div></div><a class="indexterm" name="idm139979001991792"></a><p>
        <code class="literal">MYSQL *mysql_init(MYSQL *mysql)</code>
      </p><h5><a name="idm139979001989248"></a>説明</h5><p>
        <code class="literal">mysql_real_connect()</code> に適切な <code class="literal">MYSQL</code> オブジェクトを割り当てるか初期化します。<code class="literal">mysql</code> が <code class="literal">NULL</code> ポインタである場合、関数は新しいオブジェクトを割り当てて、初期化して返します。そうでない場合、オブジェクトは初期化され、オブジェクトのアドレスが返されます。<code class="literal">mysql_init()</code> が新しいオブジェクトを割り当てた場合、それは、<code class="literal">mysql_close()</code> が呼び出され、接続がクローズされると解放されます。
      </p><p>
        非マルチスレッド環境では、<code class="literal">mysql_init()</code> は、必要に応じて自動的に <code class="literal">mysql_library_init()</code> を呼び出します。ただし、<code class="literal">mysql_library_init()</code> はマルチスレッド環境でスレッドセーフでないため、<code class="literal">mysql_init()</code> もスレッドセーフでありません。<code class="literal">mysql_init()</code> を呼び出す前に、スレッドの生成前に <code class="literal">mysql_library_init()</code> を呼び出すか、または相互排他ロックを使用して、<code class="literal">mysql_library_init()</code> 呼び出しを保護します。これは、ほかのすべてのクライアントライブラリ呼び出しの前に実行すべきです。
      </p><h5><a name="idm139979001973904"></a>戻り値</h5><p>
        初期化された <code class="literal">MYSQL*</code> ハンドル。新しいオブジェクトを割り当てるために十分なメモリーがなかった場合は <code class="literal">NULL</code>。
      </p><h5><a name="idm139979001971088"></a>エラー</h5><p>
        メモリーが不十分な場合、<code class="literal">NULL</code> が返されます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-insert-id"></a>23.8.7.37 mysql_insert_id()</h4></div></div></div><a class="indexterm" name="idm139979001968016"></a><p>
        <code class="literal">my_ulonglong mysql_insert_id(MYSQL *mysql)</code>
      </p><h5><a name="idm139979001965456"></a>説明</h5><p>
        前の <code class="literal">INSERT</code> または <code class="literal">UPDATE</code> ステートメントによって、<code class="literal">AUTO_INCREMENT</code> カラムに生成された値を返します。この関数は、<code class="literal">AUTO_INCREMENT</code> フィールドを含むテーブルへの <code class="literal">INSERT</code> ステートメントを実行したか、<code class="literal">INSERT</code> または <code class="literal">UPDATE</code> を使用して、<code class="literal">LAST_INSERT_ID(<em class="replaceable"><code>expr</code></em>)</code> によってカラム値を設定した後に使用します。
      </p><p>
        <code class="literal">mysql_insert_id()</code> の戻り値は、次のいずれかの条件で、明示的に更新されないかぎり、常にゼロです。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            値を <code class="literal">AUTO_INCREMENT</code> カラムに格納する <code class="literal">INSERT</code> ステートメント。これは値が、特殊な値 <code class="literal">NULL</code> や <code class="literal">0</code> をカラムに格納することによって自動的に生成されるか、明示的な特殊でない値であるかに関係なく当てはまります。
          </p></li><li class="listitem"><p>
            複数行の <code class="literal">INSERT</code> ステートメントの場合、<code class="literal">mysql_insert_id()</code> は、最初に正常に挿入された、自動生成された <code class="literal">AUTO_INCREMENT</code> 値を返します。
          </p><p>
            正常に挿入された行がない場合、<code class="literal">mysql_insert_id()</code> は 0 を返します。
          </p></li><li class="listitem"><p>
            <code class="literal">INSERT ... SELECT</code> ステートメントが実行され、正常に挿入された自動生成された値がない場合、<code class="literal">mysql_insert_id()</code> は最後に挿入された行の ID を返します。
          </p></li><li class="listitem"><p>
            <code class="literal">INSERT ... SELECT</code> ステートメントで <code class="literal">LAST_INSERT_ID(<em class="replaceable"><code>expr</code></em>)</code> を使用した場合、<code class="literal">mysql_insert_id()</code> は <em class="replaceable"><code>expr</code></em> を返します。
          </p></li><li class="listitem"><p>
            <code class="literal">LAST_INSERT_ID(<em class="replaceable"><code>expr</code></em>)</code> を任意のカラムに挿入するか、または任意のカラムを <code class="literal">LAST_INSERT_ID(<em class="replaceable"><code>expr</code></em>)</code> に更新することによって、<code class="literal">AUTO_INCREMENT</code> 値を生成するステートメントを <code class="literal">INSERT</code> します。
          </p></li><li class="listitem"><p>
            前のステートメントがエラーを返した場合、<code class="literal">mysql_insert_id()</code> の値は未定義になります。
          </p></li></ul></div><p>
        <code class="literal">mysql_insert_id()</code> の戻り値は、次のシーケンスに簡略化できます。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            <code class="literal">AUTO_INCREMENT</code> カラムがあり、自動的に生成された値が正常に挿入された場合、それらの最初の値を返します。
          </p></li><li class="listitem"><p>
            ステートメントで <code class="literal">LAST_INSERT_ID(<em class="replaceable"><code>expr</code></em>)</code> が行われた場合、影響を受けるテーブルに <code class="literal">AUTO_INCREMENT</code> カラムがあった場合でも、<em class="replaceable"><code>expr</code></em> を返します。
          </p></li><li class="listitem"><p>
            戻り値は使用されたステートメントによって変わります。<code class="literal">INSERT</code> ステートメントのあとに呼び出された場合:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                テーブルに <code class="literal">AUTO_INCREMENT</code> カラムがあり、テーブルに正常に挿入されたこのカラムのいくつかの明示的な値があった場合、最後の明示的な値を返します。
              </p></li></ul></div><p>
            <code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> ステートメントのあとに呼び出された場合:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                テーブルに <code class="literal">AUTO_INCREMENT</code> カラムがあり、テーブルにいくつかの明示的な正常に挿入された値またはいくつかの更新された値があった場合、最後に挿入されたか、または更新された値を返します。
              </p></li></ul></div></li></ol></div><p>
        前のステートメントが <code class="literal">AUTO_INCREMENT</code> 値を使用していない場合、<code class="literal">mysql_insert_id()</code> は <code class="literal">0</code> を返します。値をあとのために保存する必要がある場合、値を生成するステートメントの直後に <code class="literal">mysql_insert_id()</code> を呼び出してください。
      </p><p>
        <code class="literal">mysql_insert_id()</code> の値は、現在のクライアント接続内で発行されたステートメントによってのみ影響を受けます。それは、ほかのクライアントによって発行されたステートメントに影響を受けません。
      </p><p>
        <code class="literal">LAST_INSERT_ID()</code> SQL 関数は、正常に挿入された、最初に自動生成された値を格納します。<code class="literal">LAST_INSERT_ID()</code> の値はサーバーで保持されるため、この関数はステートメント間でリセットされません。<code class="literal">mysql_insert_id()</code> とのもう 1 つの違いは、<code class="literal">AUTO_INCREMENT</code> カラムを特定の特殊でない値に設定した場合に、<code class="literal">LAST_INSERT_ID()</code> が更新されないことです。<a class="xref" href="functions.html#information-functions" title="12.14 情報関数">セクション12.14「情報関数」</a>を参照してください。
      </p><p>
        <code class="literal">mysql_insert_id()</code> は、<code class="literal">AUTO_INCREMENT</code> 値を生成するストアドプロシージャーの <code class="literal">CALL</code> ステートメントのあとに、<code class="literal">0</code> を返します。この場合、<code class="literal">mysql_insert_id()</code> が <code class="literal">CALL</code> に適用され、プロシージャー内のステートメントには適用されないためです。プロシージャー内で、<code class="literal">LAST_INSERT_ID()</code> を SQL レベルで使用して、<code class="literal">AUTO_INCREMENT</code> 値を取得できます。
      </p><p>
        <code class="literal">LAST_INSERT_ID()</code> と <code class="literal">mysql_insert_id()</code> の違いの理由は、<code class="literal">LAST_INSERT_ID()</code> がスクリプトで使いやすく、<code class="literal">mysql_insert_id()</code> は <code class="literal">AUTO_INCREMENT</code> カラムに起こったことに関してより正確な情報を提供しようとすることです。
      </p><h5><a name="idm139979001886080"></a>戻り値</h5><p>
        先述の説明で示しています。
      </p><h5><a name="idm139979001884880"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-kill"></a>23.8.7.38 mysql_kill()</h4></div></div></div><a class="indexterm" name="idm139979001882576"></a><p>
        <code class="literal">int mysql_kill(MYSQL *mysql, unsigned long pid)</code>
      </p><h5><a name="idm139979001880016"></a>説明</h5><p>
        サーバーに、<code class="literal">pid</code> で指定されたスレッドを強制終了するように求めます。
      </p><p>
        この関数は非推奨です。代わりに SQL <code class="literal">KILL</code> ステートメントを発行するために、<code class="literal">mysql_query()</code> を使用することをお勧めします。
      </p><p>
        <code class="literal">mysql_kill()</code> は 32 ビットより大きい値を処理できませんが、MySQL 5.6.9 以降、誤ったスレッドの強制終了に対して保護するため、これらの場合にエラーを返します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            32 ビットより大きい ID が指定された場合、<code class="literal">mysql_kill()</code> は <code class="literal">CR_INVALID_CONN_HANDLE</code> エラーを返します。
          </p></li><li class="listitem"><p>
            サーバーの内部スレッド ID カウンタが 32 ビットより大きい値に達したら、それは <code class="literal">mysql_kill()</code> のすべての呼び出しに対して、<code class="literal">ER_DATA_OUT_OF_RANGE</code> エラーを返し、<code class="literal">mysql_kill()</code> が失敗します。
          </p></li></ul></div><h5><a name="idm139979001865360"></a>戻り値</h5><p>
        成功の場合はゼロ。エラーが発生した場合、ゼロ以外。
      </p><h5><a name="idm139979001864096"></a>エラー</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_COMMANDS_OUT_OF_SYNC</code>
          </p><p>
            コマンドが正しくない順番で実行されました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_INVALID_CONN_HANDLE</code>
          </p><p>
            <code class="literal">pid</code> が 32 ビットより大きいです。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_GONE_ERROR</code>
          </p><p>
            MySQL サーバーが存在しなくなりました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_LOST</code>
          </p><p>
            サーバーへの接続がクエリー中に失われました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_UNKNOWN_ERROR</code>
          </p><p>
            不明なエラーが発生しました。
          </p></li><li class="listitem"><p>
            <code class="literal">ER_DATA_OUT_OF_RANGE</code>
          </p><p>
            サーバーの内部スレッド ID カウンタが 32 ビットより大きい値に達しており、その時点で、それはすべての <code class="literal">mysql_kill()</code> の呼び出しを拒否します。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-library-end"></a>23.8.7.39 mysql_library_end()</h4></div></div></div><a class="indexterm" name="idm139979001846288"></a><p>
        <code class="literal">void mysql_library_end(void)</code>
      </p><h5><a name="idm139979001843744"></a>説明</h5><p>
        この関数は MySQL ライブラリをファイナライズします。ライブラリの使用を終了したとき (サーバーからの切断後など) に、呼び出します。呼び出しによって行われるアクションは、アプリケーションが MySQL クライアントライブラリにリンクされているか、または MySQL 組み込みサーバーライブラリにリンクされているかによって異なります。<code class="option">-lmysqlclient</code> フラグを使用して、<code class="literal">libmysqlclient</code> ライブラリに対してリンクされたクライアントプログラムの場合、<code class="literal">mysql_library_end()</code> は、何らかのメモリー管理を実行して、クリーンアップします。<code class="option">-lmysqld</code> フラグを使用して、<code class="literal">libmysqld</code> ライブラリに対してリンクされた組み込みサーバーアプリケーションの場合、<code class="literal">mysql_library_end()</code> は、組み込みサーバーをシャットダウンしてから、クリーンアップします。
      </p><p>
        使用方法については、<a class="xref" href="connectors-apis.html#c-api-function-overview" title="23.8.6 C API 関数の概要">セクション23.8.6「C API 関数の概要」</a>および<a class="xref" href="connectors-apis.html#mysql-library-init" title="23.8.7.40 mysql_library_init()">セクション23.8.7.40「mysql_library_init()」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-library-init"></a>23.8.7.40 mysql_library_init()</h4></div></div></div><a class="indexterm" name="idm139979001833872"></a><p>
        <code class="literal">int mysql_library_init(int argc, char **argv, char **groups)</code>
      </p><h5><a name="idm139979001831296"></a>説明</h5><p>
        アプリケーションが通常のクライアントプログラムであるか、組み込みサーバーを使用するかに関係なく、この関数は、ほかのすべての MySQL 関数を呼び出す前に、MySQL ライブラリを初期化するために呼び出します。アプリケーションで組み込みサーバーを使用している場合、この呼び出しによってサーバーを起動し、そのサーバーが使用するすべてのサブシステム (<code class="literal">mysys</code>、<code class="literal">InnoDB</code> など) を初期化します。
      </p><p>
        アプリケーションが MySQL ライブラリの使用を終了したら、<code class="literal">mysql_library_end()</code> を呼び出してクリーンアップします。<a class="xref" href="connectors-apis.html#mysql-library-end" title="23.8.7.39 mysql_library_end()">セクション23.8.7.39「mysql_library_end()」</a>を参照してください。
      </p><p>
        アプリケーションが通常のクライアントとして動作するか、または組み込みサーバーを使用するかどうかの選択は、リンク時に、最終の実行可能ファイルを生成するために、<code class="literal">libmysqlclient</code> ライブラリを使用するか、<code class="literal">libmysqld</code> ライブラリを使用するかによって異なります。追加情報については、<a class="xref" href="connectors-apis.html#c-api-function-overview" title="23.8.6 C API 関数の概要">セクション23.8.6「C API 関数の概要」</a>を参照してください。
      </p><p>
        非マルチスレッド環境では、<code class="literal">mysql_init()</code> が必要に応じて自動的に <code class="literal">mysql_library_init()</code> を呼び出すため、この呼び出しを省略できます。ただし、<code class="literal">mysql_library_init()</code> はマルチスレッド環境でスレッドセーフでないため、<code class="literal">mysql_library_init()</code> を呼び出す <code class="literal">mysql_init()</code> もスレッドセーフでありません。スレッドを生成する前に <code class="literal">mysql_library_init()</code> を呼び出すか、さもなければ <code class="literal">mysql_library_init()</code> を呼び出すか、<code class="literal">mysql_init()</code> 経由で間接的に呼び出すかに関係なく、相互排他ロックを使用して、呼び出しを保護します。これは、ほかのすべてのクライアントライブラリの呼び出しの前に実行してください。
      </p><p>
        <code class="literal">argc</code> および <code class="literal">argv</code> 引数は <code class="literal">main()</code> への引数に似ており、組み込みサーバーにオプションを渡すことができます。便宜上、サーバーへのコマンド行引数がない場合、<code class="literal">argc</code> を <code class="literal">0</code> (ゼロ) にできます。これは、通常の (組み込みでない) クライアントとしてのみ使用することを目的としたアプリケーションの通常のケースであり、呼び出しは一般に <code class="literal">mysql_library_init(0, NULL, NULL)</code> と書かれます。
      </p><pre class="programlisting">
#include &lt;mysql.h&gt;
#include &lt;stdlib.h&gt;

int main(void) {
  if (mysql_library_init(0, NULL, NULL)) {
    fprintf(stderr, "could not initialize MySQL library\n");
    exit(1);
  }

  /* Use any MySQL API functions here */

  mysql_library_end();

  return EXIT_SUCCESS;
}
</pre><p>
        引数が渡される (<code class="literal">argc</code> が <code class="literal">0</code> より大きい) と、<code class="literal">argv</code> の最初の要素は無視されます (それには一般にプログラム名が格納されています)。<code class="literal">mysql_library_init()</code> は引数のコピーを作成するため、呼び出し後 <code class="literal">argv</code> または <code class="literal">groups</code> を破棄しても安全です。
      </p><p>
        組み込みアプリケーションの場合、組み込みサーバーを起動せずに、外部サーバーに接続する場合、<code class="literal">argc</code> に負の値を指定する必要があります。
      </p><p>
        <code class="literal">groups</code> 引数は、オプションの読み取り元のオプションファイル内のグループを示す文字列の配列です。<a class="xref" href="programs.html#option-files" title="4.2.6 オプションファイルの使用">セクション4.2.6「オプションファイルの使用」</a>を参照してください。配列の最終エントリを <code class="literal">NULL</code> にします。便宜上、<code class="literal">groups</code> 引数自体が <code class="literal">NULL</code> である場合、デフォルトで <code class="literal">[server]</code> グループと <code class="literal">[embedded]</code> グループが使われます。
      </p><pre class="programlisting">
#include &lt;mysql.h&gt;
#include &lt;stdlib.h&gt;

static char *server_args[] = {
  "this_program",       /* this string is not used */
  "--datadir=.",
  "--key_buffer_size=32M"
};
static char *server_groups[] = {
  "embedded",
  "server",
  "this_program_SERVER",
  (char *)NULL
};

int main(void) {
  if (mysql_library_init(sizeof(server_args) / sizeof(char *),
                        server_args, server_groups)) {
    fprintf(stderr, "could not initialize MySQL library\n");
    exit(1);
  }

  /* Use any MySQL API functions here */

  mysql_library_end();

  return EXIT_SUCCESS;
}
</pre><h5><a name="idm139979001791184"></a>戻り値</h5><p>
        成功の場合はゼロ。エラーが発生した場合、ゼロ以外。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-list-dbs"></a>23.8.7.41 mysql_list_dbs()</h4></div></div></div><a class="indexterm" name="idm139979001788752"></a><p>
        <code class="literal">MYSQL_RES *mysql_list_dbs(MYSQL *mysql, const char *wild)</code>
      </p><h5><a name="idm139979001786176"></a>説明</h5><p>
        <code class="literal">wild</code> パラメータによって指定された簡単な正規表現に一致するサーバー上のデータベース名から構成される結果セットを返します。<code class="literal">wild</code> にはワイルドカード文字 <span class="quote">「<span class="quote"><code class="literal">%</code></span>」</span> または <span class="quote">「<span class="quote"><code class="literal">_</code></span>」</span> を含めることができ、またはすべてのデータベースに一致する <code class="literal">NULL</code> ポインタにできます。<code class="literal">mysql_list_dbs()</code> の呼び出しは、クエリー <code class="literal">SHOW DATABASES [LIKE <em class="replaceable"><code>wild</code></em>]</code> の実行に似ています。
      </p><p>
        <code class="literal">mysql_free_result()</code> によって結果セットを解放する必要があります。
      </p><h5><a name="idm139979001776976"></a>戻り値</h5><p>
        成功した場合は <code class="literal">MYSQL_RES</code> 結果セット。エラーが発生した場合は <code class="literal">NULL</code>。
      </p><h5><a name="idm139979001774288"></a>エラー</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_COMMANDS_OUT_OF_SYNC</code>
          </p><p>
            コマンドが正しくない順番で実行されました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_OUT_OF_MEMORY</code>
          </p><p>
            メモリー不足。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_GONE_ERROR</code>
          </p><p>
            MySQL サーバーが存在しなくなりました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_LOST</code>
          </p><p>
            サーバーへの接続がクエリー中に失われました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_UNKNOWN_ERROR</code>
          </p><p>
            不明なエラーが発生しました。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-list-fields"></a>23.8.7.42 mysql_list_fields()</h4></div></div></div><a class="indexterm" name="idm139979001760672"></a><p>
        <code class="literal">MYSQL_RES *mysql_list_fields(MYSQL *mysql, const char *table, const char *wild)</code>
      </p><h5><a name="idm139979001758080"></a>説明</h5><p>
        <code class="literal">wild</code> パラメータによって指定された簡単な正規表現に一致する、指定されたテーブル内のカラムに関する情報をメタデータで提供する空の結果セットを返します。<code class="literal">wild</code> にはワイルドカード文字 <span class="quote">「<span class="quote"><code class="literal">%</code></span>」</span> または <span class="quote">「<span class="quote"><code class="literal">_</code></span>」</span> を含めることができ、またはすべてのフィールドに一致する <code class="literal">NULL</code> ポインタにできます。<code class="literal">mysql_list_fields()</code> の呼び出しは、クエリー <code class="literal">SHOW COLUMNS FROM <em class="replaceable"><code>tbl_name</code></em> [LIKE <em class="replaceable"><code>wild</code></em>]</code> の実行と似ています。
      </p><p>
        <code class="literal">mysql_list_fields()</code> の代わりに <code class="literal">SHOW COLUMNS FROM <em class="replaceable"><code>tbl_name</code></em></code> を使用することをお勧めします。
      </p><p>
        <code class="literal">mysql_free_result()</code> によって結果セットを解放する必要があります。
      </p><h5><a name="idm139979001745872"></a>戻り値</h5><p>
        成功した場合は <code class="literal">MYSQL_RES</code> 結果セット。エラーが発生した場合は <code class="literal">NULL</code>。
      </p><h5><a name="idm139979001743184"></a>エラー</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_COMMANDS_OUT_OF_SYNC</code>
          </p><p>
            コマンドが正しくない順番で実行されました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_GONE_ERROR</code>
          </p><p>
            MySQL サーバーが存在しなくなりました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_LOST</code>
          </p><p>
            サーバーへの接続がクエリー中に失われました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_UNKNOWN_ERROR</code>
          </p><p>
            不明なエラーが発生しました。
          </p></li></ul></div><h5><a name="idm139979001732960"></a>例</h5><pre class="programlisting">
int i;
MYSQL_RES *tbl_cols = mysql_list_fields(mysql, "mytbl", "f%");

unsigned int field_cnt = mysql_num_fields(tbl_cols);
printf("Number of columns: %d\n", field_cnt);

for (i=0; i &lt; field_cnt; ++i)
{
  /* col describes i-th column of the table */
  MYSQL_FIELD *col = mysql_fetch_field_direct(tbl_cols, i);
  printf ("Column %d: %s\n", i, col-&gt;name);
}
mysql_free_result(tbl_cols);
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-list-processes"></a>23.8.7.43 mysql_list_processes()</h4></div></div></div><a class="indexterm" name="idm139979001729616"></a><p>
        <code class="literal">MYSQL_RES *mysql_list_processes(MYSQL *mysql)</code>
      </p><h5><a name="idm139979001727040"></a>説明</h5><p>
        現在のサーバースレッドについて説明する結果セットを返します。これは、<span class="command"><strong>mysqladmin processlist</strong></span> または <code class="literal">SHOW PROCESSLIST</code> クエリーによって報告されるものと同じ種類の情報です。
      </p><p>
        <code class="literal">mysql_free_result()</code> によって結果セットを解放する必要があります。
      </p><h5><a name="idm139979001722352"></a>戻り値</h5><p>
        成功した場合は <code class="literal">MYSQL_RES</code> 結果セット。エラーが発生した場合は <code class="literal">NULL</code>。
      </p><h5><a name="idm139979001719664"></a>エラー</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_COMMANDS_OUT_OF_SYNC</code>
          </p><p>
            コマンドが正しくない順番で実行されました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_GONE_ERROR</code>
          </p><p>
            MySQL サーバーが存在しなくなりました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_LOST</code>
          </p><p>
            サーバーへの接続がクエリー中に失われました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_UNKNOWN_ERROR</code>
          </p><p>
            不明なエラーが発生しました。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-list-tables"></a>23.8.7.44 mysql_list_tables()</h4></div></div></div><a class="indexterm" name="idm139979001708272"></a><p>
        <code class="literal">MYSQL_RES *mysql_list_tables(MYSQL *mysql, const char *wild)</code>
      </p><h5><a name="idm139979001705696"></a>説明</h5><p>
        <code class="literal">wild</code> パラメータによって指定された簡単な正規表現に一致する、現在のデータベース内のテーブル名から構成される結果セットを返します。<code class="literal">wild</code> にはワイルドカード文字 <span class="quote">「<span class="quote"><code class="literal">%</code></span>」</span> または <span class="quote">「<span class="quote"><code class="literal">_</code></span>」</span> を含めることができ、またはすべてのテーブルに一致する <code class="literal">NULL</code> ポインタにできます。<code class="literal">mysql_list_tables()</code> の呼び出しは、クエリー <code class="literal">SHOW TABLES [LIKE <em class="replaceable"><code>wild</code></em>]</code> の実行に似ています。
      </p><p>
        <code class="literal">mysql_free_result()</code> によって結果セットを解放する必要があります。
      </p><h5><a name="idm139979001696496"></a>戻り値</h5><p>
        成功した場合は <code class="literal">MYSQL_RES</code> 結果セット。エラーが発生した場合は <code class="literal">NULL</code>。
      </p><h5><a name="idm139979001693808"></a>エラー</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_COMMANDS_OUT_OF_SYNC</code>
          </p><p>
            コマンドが正しくない順番で実行されました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_GONE_ERROR</code>
          </p><p>
            MySQL サーバーが存在しなくなりました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_LOST</code>
          </p><p>
            サーバーへの接続がクエリー中に失われました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_UNKNOWN_ERROR</code>
          </p><p>
            不明なエラーが発生しました。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-more-results"></a>23.8.7.45 mysql_more_results()</h4></div></div></div><a class="indexterm" name="idm139979001682464"></a><p>
        <code class="literal">my_bool mysql_more_results(MYSQL *mysql)</code>
      </p><h5><a name="idm139979001679904"></a>説明</h5><p>
        この関数は、単一のステートメント文字列として指定された複数のステートメントを実行する場合、または複数の結果セットを返すことがある <code class="literal">CALL</code> ステートメントを実行する場合に使用します。
      </p><p>
        現在実行されているステートメントから、それ以上の結果が存在する場合、<code class="literal">mysql_more_results()</code> は true になり、この場合、アプリケーションは <code class="literal">mysql_next_result()</code> を呼び出して、結果をフェッチする必要があります。
      </p><h5><a name="idm139979001674432"></a>戻り値</h5><p>
        それ以上の結果が存在する場合は、<code class="literal">TRUE</code> (1)。それ以上の結果が存在しない場合は <code class="literal">FALSE</code> (0)。
      </p><p>
        ほとんどの場合、代わりに <code class="literal">mysql_next_result()</code> を呼び出して、それ以上の結果が存在しており、その場合に取得を開始するかどうかをテストできます。
      </p><p>
        <a class="xref" href="connectors-apis.html#c-api-multiple-queries" title="23.8.17 複数ステートメント実行の C API サポート">セクション23.8.17「複数ステートメント実行の C API サポート」</a>および<a class="xref" href="connectors-apis.html#mysql-next-result" title="23.8.7.46 mysql_next_result()">セクション23.8.7.46「mysql_next_result()」</a>を参照してください。
      </p><h5><a name="idm139979001667952"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-next-result"></a>23.8.7.46 mysql_next_result()</h4></div></div></div><a class="indexterm" name="idm139979001665728"></a><p>
        <code class="literal">int mysql_next_result(MYSQL *mysql)</code>
      </p><h5><a name="idm139979001663184"></a>説明</h5><p>
        この関数は、単一のステートメント文字列として指定された複数のステートメントを実行する場合、または複数の結果セットを返すことがある <code class="literal">CALL</code> ステートメントを使用して、ストアドプロシージャーを実行する場合に使用します。
      </p><p>
        <code class="literal">mysql_next_result()</code> は次のステートメント結果を読み取り、それ以上の結果が存在するかどうかを示すステータスを返します。<code class="literal">mysql_next_result()</code> がエラーを返した場合、それ以上の結果はありません。
      </p><p>
        <code class="literal">mysql_next_result()</code> の各呼び出しの前に、現在のステートメントが結果セットを返した (結果のステータスだけでなく) ステートメントである場合、そのステートメントに対して <code class="literal">mysql_free_result()</code> を呼び出す必要があります。
      </p><p>
        <code class="literal">mysql_next_result()</code> を呼び出したあとの接続の状態は、次のステートメントに対し、<code class="literal">mysql_real_query()</code> または <code class="literal">mysql_query()</code> を呼び出した場合のようになります。このことは、<code class="literal">mysql_store_result()</code>、<code class="literal">mysql_warning_count()</code>、<code class="literal">mysql_affected_rows()</code> などを呼び出すことができることを意味します。
      </p><p>
        プログラムで <code class="literal">CALL</code> ステートメントを使用して、ストアドプロシージャーを実行する場合、<code class="literal">CLIENT_MULTI_RESULTS</code> フラグが有効になっている必要があります。これは、各 <code class="literal">CALL</code> によって、プロシージャー内で実行されるステートメントによって返される可能性のある結果セットに加えて、呼び出しステータスを示すための結果が返されるためです。<code class="literal">CALL</code> は複数の結果を返すことができるため、<code class="literal">mysql_next_result()</code> を呼び出すループを使用して、それらを処理し、それ以上の結果があるかどうかを判断します。
      </p><p>
        <code class="literal">CLIENT_MULTI_RESULTS</code> は、<code class="literal">mysql_real_connect()</code> を呼び出すときに、<code class="literal">CLIENT_MULTI_RESULTS</code> フラグ自体を渡すことによって明示的に、または <code class="literal">CLIENT_MULTI_STATEMENTS</code> を渡すことによって暗黙的に有効にする (これによって <code class="literal">CLIENT_MULTI_RESULTS</code> も有効になります) ことができます。MySQL 5.6 では、<code class="literal">CLIENT_MULTI_RESULTS</code> はデフォルトで有効にされています。
      </p><p>
        <code class="literal">mysql_more_results()</code> を呼び出して、それ以上の結果があるかどうかをテストすることもできます。ただし、この関数は接続の状態を変更しないため、それが true を返した場合は、さらに <code class="literal">mysql_next_result()</code> を呼び出して、次の結果に進む必要があります。
      </p><p>
        <code class="literal">mysql_next_result()</code> の使用方法を示す例については、<a class="xref" href="connectors-apis.html#c-api-multiple-queries" title="23.8.17 複数ステートメント実行の C API サポート">セクション23.8.17「複数ステートメント実行の C API サポート」</a>を参照してください。
      </p><h5><a name="idm139979001631184"></a>戻り値</h5><div class="informaltable"><table summary="この表では、mysql_next_result() の戻り値を一覧表示し、それぞれについて説明します。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">戻り値</th><th scope="col">説明</th></tr></thead><tbody><tr><td scope="row">0</td><td>成功し、それ以上の結果が存在します</td></tr><tr><td scope="row">-1</td><td>成功し、それ以上の結果が存在しません</td></tr><tr><td scope="row">0 より大きい</td><td>エラーが発生しました</td></tr></tbody></table></div><h5><a name="idm139979001620928"></a>エラー</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_COMMANDS_OUT_OF_SYNC</code>
          </p><p>
            コマンドが正しくない順番で実行されました。たとえば、前の結果セットに対して <code class="literal">mysql_use_result()</code> を呼び出していなかった場合。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_GONE_ERROR</code>
          </p><p>
            MySQL サーバーが存在しなくなりました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_LOST</code>
          </p><p>
            サーバーへの接続がクエリー中に失われました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_UNKNOWN_ERROR</code>
          </p><p>
            不明なエラーが発生しました。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-num-fields"></a>23.8.7.47 mysql_num_fields()</h4></div></div></div><a class="indexterm" name="idm139979001608368"></a><a class="indexterm" name="idm139979001607024"></a><p>
        <code class="literal">unsigned int mysql_num_fields(MYSQL_RES *result)</code>
      </p><p>
        代わりに <code class="literal">MYSQL*</code> 引数を渡すには、<code class="literal">unsigned int mysql_field_count(MYSQL *mysql)</code> を使用します。
      </p><h5><a name="idm139979001602464"></a>説明</h5><p>
        結果セット内のカラムの数を返します。
      </p><p>
        結果セットまたは接続ハンドルへのいずれかのポインタからカラムの数を取得できます。接続ハンドルは、<code class="literal">mysql_store_result()</code> または <code class="literal">mysql_use_result()</code> が <code class="literal">NULL</code> を返した (そのため、結果セットポインタがない) 場合に使用します。この場合、<code class="literal">mysql_field_count()</code> を呼び出して、<code class="literal">mysql_store_result()</code> が空でない結果を生成しているかどうかを判断できます。これにより、クライアントプログラムは、クエリーが <code class="literal">SELECT</code> (または <code class="literal">SELECT</code> に似た) ステートメントであったかどうかを知らなくても、正しいアクションをとることができます。ここに示す例では、これを実行する方法を説明しています。
      </p><p>
        <a class="xref" href="connectors-apis.html#null-mysql-store-result" title="23.8.15.1 mysql_query() が成功を返したあとに mysql_store_result() が NULL を返すことがあるのはなぜか">セクション23.8.15.1「mysql_query() が成功を返したあとに mysql_store_result() が NULL を返すことがあるのはなぜか」</a>を参照してください。
      </p><h5><a name="idm139979001591776"></a>戻り値</h5><p>
        結果セット内のカラムの数を表す符号なし整数。
      </p><h5><a name="idm139979001590560"></a>エラー</h5><p>
        なし。
      </p><h5><a name="idm139979001589424"></a>例</h5><pre class="programlisting">
MYSQL_RES *result;
unsigned int num_fields;
unsigned int num_rows;

if (mysql_query(&amp;mysql,query_string))
{
    // error
}
else // query succeeded, process any data returned by it
{
    result = mysql_store_result(&amp;mysql);
    if (result)  // there are rows
    {
        num_fields = mysql_num_fields(result);
        // retrieve rows, then call mysql_free_result(result)
    }
    else  // mysql_store_result() returned nothing; should it have?
    {
        if (mysql_errno(&amp;mysql))
        {
           fprintf(stderr, "Error: %s\n", mysql_error(&amp;mysql));
        }
        else if (mysql_field_count(&amp;mysql) == 0)
        {
            // query does not return data
            // (it was not a SELECT)
            num_rows = mysql_affected_rows(&amp;mysql);
        }
    }
}
</pre><p>
        代替の方法 (クエリーが結果セットを返すべきであったことがわかっている場合) は、<code class="literal">mysql_errno(&amp;mysql)</code> 呼び出しを <code class="literal">mysql_field_count(&amp;mysql)</code> が 0 を返しているかどうかのチェックで置き換えることです。これは、何か異常があった場合にのみ発生します。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-num-rows"></a>23.8.7.48 mysql_num_rows()</h4></div></div></div><a class="indexterm" name="idm139979001582656"></a><p>
        <code class="literal">my_ulonglong mysql_num_rows(MYSQL_RES *result)</code>
      </p><h5><a name="idm139979001580096"></a>説明</h5><p>
        結果セット内の行数を返します。
      </p><p>
        <code class="literal">mysql_num_rows()</code> の使用は、結果セットを返すために、<code class="literal">mysql_store_result()</code> を使用するか、<code class="literal">mysql_use_result()</code> を使用するかによって異なります。<code class="literal">mysql_store_result()</code> を使用すると、<code class="literal">mysql_num_rows()</code> はただちに呼び出されることがあります。<code class="literal">mysql_use_result()</code> を使用すると、<code class="literal">mysql_num_rows()</code> は、結果セット内のすべての行が取得されるまで、正しい値を返しません。
      </p><p>
        <code class="literal">mysql_num_rows()</code> は <code class="literal">SELECT</code> などの結果セットを返すステートメントと一緒に使用することを目的としています。<code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、または <code class="literal">DELETE</code> などのステートメントでは、影響を受けた行の数を <code class="literal">mysql_affected_rows()</code> で取得できます。
      </p><h5><a name="idm139979001564256"></a>戻り値</h5><p>
        結果セット内の行数。
      </p><h5><a name="idm139979001563072"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-options"></a>23.8.7.49 mysql_options()</h4></div></div></div><a class="indexterm" name="idm139979001560816"></a><p>
        <code class="literal">int mysql_options(MYSQL *mysql, enum mysql_option option, const void *arg)</code>
      </p><h5><a name="idm139979001558224"></a>説明</h5><p>
        追加の接続オプションを設定し、接続の動作に影響を与えるために使うことができます。この関数を複数回呼び出して、複数のオプションを設定できます。
      </p><p>
        <code class="literal">mysql_init()</code> のあとと <code class="literal">mysql_connect()</code> または <code class="literal">mysql_real_connect()</code> の前に <code class="literal">mysql_options()</code> を呼び出します。
      </p><p>
        <code class="literal">option</code> 引数は、設定するオプションです。<code class="literal">arg</code> 引数はそのオプションの値です。オプションが整数の場合、<code class="literal">arg</code> 引数として、整数の値へのポインタを指定します。
      </p><p>
        次のリストに、可能なオプション、それらの効果、および各オプションの <code class="literal">arg</code> の使用方法を示します。オプションのいくつかは、アプリケーションが <code class="literal">libmysqld</code> 組み込みサーバーライブラリに対してリンクされている場合にのみ適用され、<code class="literal">libmysqlclient</code> クライアントライブラリに対してリンクされているアプリケーションには使用されません。<code class="literal">arg</code> が使用されないことを示すオプションの説明では、その値は関係ありません。慣例として 0 を渡します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">MYSQL_DEFAULT_AUTH</code> (引数の型: <code class="literal">char *</code>)
          </p><p>
            使用する認証プラグインの名前。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_ENABLE_CLEARTEXT_PLUGIN</code> (引数の型: <code class="literal">my_bool *</code>)
          </p><p>
            <code class="literal">mysql_clear_password</code> 平文認証プラグインを有効にします。(<a class="xref" href="security.html#cleartext-authentication-plugin" title="6.3.8.7 クライアント側のクリアテキスト認証プラグイン">セクション6.3.8.7「クライアント側のクリアテキスト認証プラグイン」</a>を参照してください。)このオプションは MySQL 5.6.7 で追加されました。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_INIT_COMMAND</code> (引数の型: <code class="literal">char *</code>)
          </p><p>
            MySQL サーバーへの接続時に実行する SQL ステートメント。再接続が行われる場合に自動的に再実行されます。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_OPT_BIND</code> (引数: <code class="literal">char *</code>)
          </p><p>
            サーバーに接続するためのネットワークインタフェース。これはクライアントホストに複数のネットワークインタフェースがある場合に使用されます。引数はホスト名または IP アドレス (文字列として指定) です。このオプションは MySQL 5.6.1 で追加されました。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_OPT_CAN_HANDLE_EXPIRED_PASSWORDS</code> (引数の型: <code class="literal">my_bool *</code>)
          </p><p>
            クライアントが期限切れのパスワードを処理できるかどうかを示します。詳細については、<a class="xref" href="security.html#password-expiration-sandbox-mode" title="6.3.6 パスワードの期限切れとサンドボックスモード">セクション6.3.6「パスワードの期限切れとサンドボックスモード」</a>を参照してください。このオプションは MySQL 5.6.10 で追加されました。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_OPT_COMPRESS</code> (引数: 使用なし)
          </p><p>
            圧縮されたクライアント/サーバープロトコルを使用します。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_OPT_CONNECT_ATTR_DELETE</code> (引数の型: <code class="literal">char *</code>)
          </p><p>
            キー名を指定すると、このオプションは、接続時にサーバーに渡される現在の接続属性のセットから、キー/値ペアを削除します。引数はこのキーを指定する NULL 終端文字列へのポインタです。既存のキーとのキー名の比較は大文字と小文字が区別されます。
          </p><p>
            <code class="literal">mysql_options4()</code> 関数の説明の <code class="literal">MYSQL_OPT_CONNECT_ATTR_ADD</code> オプションの説明に加えて、<code class="literal">MYSQL_OPT_CONNECT_ATTR_RESET</code> オプションの説明も参照してください。この関数の説明には、使用例も含まれています。これらのオプションは MySQL 5.6.6 で追加されました。
          </p><p>
            接続属性は、<code class="literal">session_connect_attrs</code> および <code class="literal">session_account_connect_attrs</code> パフォーマンススキーマテーブル経由で公開されます。<a class="xref" href="performance-schema.html#performance-schema-connection-attribute-tables" title="22.9.8 パフォーマンススキーマ接続属性テーブル">セクション22.9.8「パフォーマンススキーマ接続属性テーブル」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_OPT_CONNECT_ATTR_RESET</code> (引数は使用されません)
          </p><p>
            このオプションは、接続時にサーバーに渡される現在の接続属性のセットをリセット (クリア) します。
          </p><p>
            <code class="literal">mysql_options4()</code> 関数の説明の <code class="literal">MYSQL_OPT_CONNECT_ATTR_ADD</code> オプションの説明に加えて、<code class="literal">MYSQL_OPT_CONNECT_ATTR_DELETE</code> オプションの説明も参照してください。この関数の説明には、使用例も含まれています。これらのオプションは MySQL 5.6.6 で追加されました。
          </p><p>
            接続属性は、<code class="literal">session_connect_attrs</code> および <code class="literal">session_account_connect_attrs</code> パフォーマンススキーマテーブル経由で公開されます。<a class="xref" href="performance-schema.html#performance-schema-connection-attribute-tables" title="22.9.8 パフォーマンススキーマ接続属性テーブル">セクション22.9.8「パフォーマンススキーマ接続属性テーブル」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_OPT_CONNECT_TIMEOUT</code> (引数の型: <code class="literal">unsigned int *</code>)
          </p><p>
            秒単位の接続タイムアウト。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_OPT_GUESS_CONNECTION</code> (引数は使用されません)
          </p><p>
            <code class="literal">libmysqld</code> 組み込みサーバーライブラリに対してリンクされたアプリケーションの場合、これにより、ライブラリは組み込みサーバーを使用するか、リモートサーバーを使用するかを推測できます。<span class="quote">「<span class="quote">推測</span>」</span>とは、ホスト名が設定されていて、<code class="literal">localhost</code> でない場合、リモートサーバーを使用することを意味します。この動作はデフォルトです。<code class="literal">MYSQL_OPT_USE_EMBEDDED_CONNECTION</code> および <code class="literal">MYSQL_OPT_USE_REMOTE_CONNECTION</code> を使用して、それをオーバーライドできます。このオプションは、<code class="literal">libmysqlclient</code> クライアントライブラリに対してリンクされたアプリケーションに対しては無視されます。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_OPT_LOCAL_INFILE</code> (引数の型: <code class="literal">unsigned int</code> へのオプションのポインタ)
          </p><p>
            ポインタが指定されていないか、ポインタがゼロ以外の値を持つ <code class="literal">unsigned int</code> を指している場合、<code class="literal">LOAD LOCAL INFILE</code> ステートメントが有効にされます。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_OPT_NAMED_PIPE</code> (引数: 使用されません)
          </p><p>
            MySQL サーバーが名前付きパイプ接続を許可する場合に、Windows でサーバーに接続するために、名前付きパイプを使用します。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_OPT_PROTOCOL</code> (引数の型: <code class="literal">unsigned int *</code>)
          </p><p>
            使用するプロトコルの種類。<code class="filename">mysql.h</code> に定義されている <code class="literal">mysql_protocol_type</code> の列挙値のいずれかを指定します。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_OPT_READ_TIMEOUT</code> (引数の型: <code class="literal">unsigned int *</code>)
          </p><p>
            サーバーからの読み取りの試みごとの秒単位でのタイムアウト。必要に応じて再試行があるため、実際の合計タイムアウト値は、オプションの値の 3 倍です。10 分の TCP/IP <code class="literal">Close_Wait_Timeout</code> 値より早く、失われた接続を検出できるように値を設定できます。
          </p><p>
            このタイムアウトの実装は、すべてのプラットフォームで使用できるとは限らないメカニズムを使用しています。そのようなプラットフォームでは、読み取り呼び出しを発行するクライアントが、特定の環境において、タイムアウトせずに待機することがあります。たとえば、サーバーが<span class="quote">「<span class="quote">ディスク領域不足</span>」</span>状況がクリアされるまで待機しているために応答しない場合、クライアントはタイムアウトしない可能性があります。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_OPT_RECONNECT</code> (引数の型: <code class="literal">my_bool *</code>)
          </p><p>
            接続が失われていることが検出された場合に、サーバーへの自動再接続を有効または無効にします。再接続はデフォルトでオフにされますが、このオプションは明示的に再接続動作を設定する方法を提供します。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_OPT_SSL_CA</code> (引数の型: <code class="literal">char *</code>)
          </p><p>
            信頼された SSL CA のリストを含むファイルへのパス。このオプションは MySQL 5.6.3 で追加されました。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_OPT_SSL_CAPATH</code> (引数の型: <code class="literal">char *</code>)
          </p><p>
            PEM 形式の信頼された SSL CA 証明書を格納するディレクトリのパス。このオプションは MySQL 5.6.3 で追加されました。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_OPT_SSL_CERT</code> (引数の型: <code class="literal">char *</code>)
          </p><p>
            セキュアな接続を確立するために使用する SSL 証明書ファイルの名前。このオプションは MySQL 5.6.3 で追加されました。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_OPT_SSL_CIPHER</code> (引数の型: <code class="literal">char *</code>)
          </p><p>
            SSL 暗号化に使用する許可されている暗号のリスト。このオプションは MySQL 5.6.3 で追加されました。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_OPT_SSL_CRL</code> (引数の型: <code class="literal">char *</code>)
          </p><p>
            PEM 形式での証明書失効リストを含むファイルへのパス。このオプションは MySQL 5.6.3 で追加されました。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_OPT_SSL_CRLPATH</code> (引数の型: <code class="literal">char *</code>)
          </p><p>
            PEM 形式での証明書失効リストを含むファイルを格納するディレクトリへのパス。このオプションは MySQL 5.6.3 で追加されました。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_OPT_SSL_KEY</code> (引数の型: <code class="literal">char *</code>)
          </p><p>
            セキュアな接続を確立するために使用する SSL 鍵ファイルの名前。このオプションは MySQL 5.6.3 で追加されました。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_OPT_SSL_VERIFY_SERVER_CERT</code> (引数の型: <code class="literal">my_bool *</code>)
          </p><p>
            サーバーの証明書内のサーバーの一般名値の、サーバーへの接続時に使用されるホスト名に対する検証を有効または無効にします。不一致があった場合、接続は拒否されます。この機能は、中間者攻撃を防ぐために使用できます。検証はデフォルトで無効です。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_OPT_USE_EMBEDDED_CONNECTION</code> (引数: 使用されません)
          </p><p>
            <code class="literal">libmysqld</code> 組み込みサーバーライブラリに対してリンクされたアプリケーションの場合、これにより、接続に組み込みサーバーの使用が強制されます。このオプションは、<code class="literal">libmysqlclient</code> クライアントライブラリに対してリンクされたアプリケーションに対しては無視されます。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_OPT_USE_REMOTE_CONNECTION</code> (引数: 使用されません)
          </p><p>
            <code class="literal">libmysqld</code> 組み込みサーバーライブラリに対してリンクされたアプリケーションの場合、これにより、接続にリモートサーバーの使用が強制されます。このオプションは、<code class="literal">libmysqlclient</code> クライアントライブラリに対してリンクされたアプリケーションに対しては無視されます。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_OPT_USE_RESULT</code> (引数: 使用されません)
          </p><p>
            このオプションは使用されません。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_OPT_WRITE_TIMEOUT</code> (引数の型: <code class="literal">unsigned int *</code>)
          </p><p>
            サーバーへの書き込みの試みごとの秒単位でのタイムアウト。必要に応じて再試行があるため、実際の合計タイムアウト値は、オプションの値の 2 倍です。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_PLUGIN_DIR</code> (引数の型: <code class="literal">char *</code>)
          </p><p>
            クライアントプラグインを検索するディレクトリ。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_READ_DEFAULT_FILE</code> (引数の型: <code class="literal">char *</code>)
          </p><p>
            <code class="filename">my.cnf</code> の代わりに、指定したオプションファイルからオプションを読み取ります。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_READ_DEFAULT_GROUP</code> (引数の型: <code class="literal">char *</code>)
          </p><p>
            <code class="filename">my.cnf</code> の指定したグループまたは <code class="literal">MYSQL_READ_DEFAULT_FILE</code> によって指定されたファイルから、オプションを読み取ります。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_REPORT_DATA_TRUNCATION</code> (引数の型: <code class="literal">my_bool *</code>)
          </p><p>
            <code class="literal">MYSQL_BIND</code> 構造の <code class="literal">error</code> メンバーを使用して、プリペアドステートメントのデータ切り捨てエラーのレポートを有効または無効にします。(デフォルト: 有効。)
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_SECURE_AUTH</code> (引数の型: <code class="literal">my_bool *</code>)
          </p><p>
            MySQL 4.1.1 以降で使用されているパスワードハッシュをサポートしていないサーバーに接続するかどうか。MySQL 5.6.7 以降、このオプションはデフォルトで有効にされています。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_SERVER_PUBLIC_KEY</code> (引数の型: <code class="literal">char *</code>)
          </p><p>
            サーバー RSA 公開鍵を含むファイルへのパス名。ファイルは PEM 形式である必要があります。公開鍵は、<code class="literal">sha256_password</code> プラグインによって認証するアカウントを使用して、サーバーへの接続を作成するためのクライアントパスワードの RSA 暗号化に使用されます。このオプションは、そのプラグインによって認証しないクライアントアカウントに対しては無視されます。さらに、クライアントが SSL 接続を使用して、サーバーに接続する場合のように、パスワード暗号化が必要でない場合も無視されます。
          </p><p>
            サーバーは必要に応じて公開鍵をクライアントに送信するため、RSA パスワードの暗号化が行われるように、このオプションを使う必要はありません。そうすることで、サーバーは鍵を送信する必要がないため、効率が向上します。
          </p><p>
            RSA 公開鍵の取得方法を含め、<code class="literal">sha256_password</code> プラグインの使用に関する追加の説明については、<a class="xref" href="security.html#sha256-authentication-plugin" title="6.3.8.4 SHA-256 認証プラグイン">セクション6.3.8.4「SHA-256 認証プラグイン」</a>を参照してください。
          </p><p>
            このオプションは MySQL 5.6.6 で追加されました。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_SET_CHARSET_DIR</code> (引数の型: <code class="literal">char *</code>)
          </p><p>
            文字セット定義ファイルを格納するディレクトリのパス名。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_SET_CHARSET_NAME</code> (引数の型: <code class="literal">char *</code>)
          </p><p>
            デフォルトの文字セットとして使用する文字セットの名前。引数を <code class="literal">MYSQL_AUTODETECT_CHARSET_NAME</code> にして、オペレーティングシステム設定に基づいて、文字セットを自動検出させることができます (<a class="xref" href="globalization.html#charset-connection" title="10.1.4 接続文字セットおよび照合順序">セクション10.1.4「接続文字セットおよび照合順序」</a>を参照してください)。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_SET_CLIENT_IP</code> (引数の型: <code class="literal">char *</code>)
          </p><p>
            <code class="literal">libmysqld</code> 組み込みサーバーライブラリに対してリンクされたアプリケーションの場合 (<code class="literal">libmysqld</code> が認証サポート付きでコンパイルされている場合)、これは、ユーザーが認証のために指定された IP アドレス (文字列として指定) から接続しているとみなされることを意味します。このオプションは、<code class="literal">libmysqlclient</code> クライアントライブラリに対してリンクされたアプリケーションに対しては無視されます。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_SHARED_MEMORY_BASE_NAME</code> (引数の型: <code class="literal">char *</code>)
          </p><p>
            サーバーが共有メモリー接続をサポートしている場合、Windows 上のサーバーとの通信のための共有メモリーオブジェクトの名前。接続先の <span class="command"><strong>mysqld</strong></span> サーバーに使用されている <code class="option">--shared-memory-base-name</code> オプションと同じ値を指定します。
          </p></li></ul></div><p>
        <code class="literal">MYSQL_READ_DEFAULT_FILE</code> または <code class="literal">MYSQL_READ_DEFAULT_GROUP</code> を使用する場合、<code class="literal">client</code> グループが常に読み取られます。
      </p><p>
        オプションファイル内の指定されたグループには、次のオプションが含まれることがあります。
      </p><div class="informaltable"><table summary="この表では、オプションファイル内に存在する可能性のあるオプションを一覧表示し、各オプションについて説明します。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">オプション</th><th scope="col">説明</th></tr></thead><tbody><tr><td scope="row"><code class="literal">character-sets-dir=<em class="replaceable"><code>path</code></em></code></td><td>文字セットがインストールされているディレクトリ。</td></tr><tr><td scope="row"><code class="literal">compress</code></td><td>圧縮されたクライアント/サーバープロトコルを使用します。</td></tr><tr><td scope="row"><code class="literal">connect-timeout=<em class="replaceable"><code>seconds</code></em></code></td><td>秒単位の接続タイムアウト。Linux では、このタイムアウトはサーバーからの最初の回答を待機する場合にも使います。</td></tr><tr><td scope="row"><code class="literal">database=<em class="replaceable"><code>db_name</code></em></code></td><td>接続コマンドにデータベースが指定されていなかった場合、このデータベースに接続します。</td></tr><tr><td scope="row"><code class="literal">debug</code></td><td>デバッグオプション。</td></tr><tr><td scope="row"><code class="literal">default-character-set=<em class="replaceable"><code>charset_name</code></em></code></td><td>使用するデフォルトの文字セット。</td></tr><tr><td scope="row"><code class="literal">disable-local-infile</code></td><td><code class="literal">LOAD DATA LOCAL</code> の使用を無効にします。</td></tr><tr><td scope="row"><code class="literal">enable-cleartext-plugin</code></td><td><code class="literal">mysql_clear_password</code> 平文認証プラグインを有効にします。MySQL 5.6.7 で追加されました。</td></tr><tr><td scope="row"><code class="literal">host=<em class="replaceable"><code>host_name</code></em></code></td><td>デフォルトのホスト名。</td></tr><tr><td scope="row"><code class="literal">init-command=<em class="replaceable"><code>stmt</code></em></code></td><td>MySQL サーバーへの接続時に実行するステートメント。再接続が行われる場合に自動的に再実行されます。</td></tr><tr><td scope="row"><code class="literal">interactive-timeout=<em class="replaceable"><code>seconds</code></em></code></td><td><code class="literal">mysql_real_connect()</code> に <code class="literal">CLIENT_INTERACTIVE</code> を指定する場合と同じ。<a class="xref" href="connectors-apis.html#mysql-real-connect" title="23.8.7.53 mysql_real_connect()">セクション23.8.7.53「mysql_real_connect()」</a>を参照してください。</td></tr><tr><td scope="row"><code class="literal">local-infile[={0|1}]</code></td><td>引数がないか、ゼロ以外の引数の場合、<code class="literal">LOAD DATA LOCAL</code> の使用を有効にします。それ以外の場合は無効にします。</td></tr><tr><td scope="row"><code class="literal">max_allowed_packet=<em class="replaceable"><code>bytes</code></em></code></td><td>クライアントがサーバーから読み取ることができるパケットの最大サイズ。</td></tr><tr><td scope="row"><code class="literal">multi-queries</code>、<code class="literal">multi-results</code></td><td>複数ステートメントの実行またはストアドプロシージャーからの複数の結果セットを可能にします。</td></tr><tr><td scope="row"><code class="literal">multi-statements</code></td><td>クライアントが複数のステートメントを単一の文字列 (<span class="quote">「<span class="quote"><code class="literal">;</code></span>」</span> で区切られた) で送信できるようにします。</td></tr><tr><td scope="row"><code class="literal">password=<em class="replaceable"><code>password</code></em></code></td><td>デフォルトパスワード。</td></tr><tr><td scope="row"><code class="literal">pipe</code></td><td>Windows で MySQL サーバーに接続するために、名前付きパイプを使用します。</td></tr><tr><td scope="row"><code class="literal">port=<em class="replaceable"><code>port_num</code></em></code></td><td>デフォルトのポート番号。</td></tr><tr><td scope="row"><code class="literal">protocol={TCP|SOCKET|PIPE|MEMORY}</code></td><td>サーバーに接続する場合に使用するプロトコル。</td></tr><tr><td scope="row"><code class="literal">return-found-rows</code></td><td><code class="literal">UPDATE</code> を使う場合、更新された行の代わりに見つかった行を返すように、<code class="literal">mysql_info()</code> に伝えます。</td></tr><tr><td scope="row"><code class="literal">shared-memory-base-name=<em class="replaceable"><code>name</code></em></code></td><td>サーバーに接続するために使用する共有メモリー名。</td></tr><tr><td scope="row"><code class="literal">socket=<em class="replaceable"><code>path</code></em></code></td><td>デフォルトのソケットファイル。</td></tr><tr><td scope="row"><code class="literal">ssl-ca=<em class="replaceable"><code>file_name</code></em></code></td><td>認証局ファイル。</td></tr><tr><td scope="row"><code class="literal">ssl-capath=<em class="replaceable"><code>path</code></em></code></td><td>認証局ディレクトリ。</td></tr><tr><td scope="row"><code class="literal">ssl-cert=<em class="replaceable"><code>file_name</code></em></code></td><td>証明書ファイル。</td></tr><tr><td scope="row"><code class="literal">ssl-cipher=<em class="replaceable"><code>cipher_list</code></em></code></td><td>許容される SSL 暗号。</td></tr><tr><td scope="row"><code class="literal">ssl-key=<em class="replaceable"><code>file_name</code></em></code></td><td>鍵ファイル。</td></tr><tr><td scope="row"><code class="literal">timeout=<em class="replaceable"><code>seconds</code></em></code></td><td><code class="literal">connect-timeout</code> に似ています。</td></tr><tr><td scope="row"><code class="literal">user</code></td><td>デフォルトユーザー。</td></tr></tbody></table></div><p>
        <code class="literal">timeout</code> は <code class="literal">connect-timeout</code> によって置き換えられましたが、<code class="literal">timeout</code> は下位互換性のため、MySQL 5.6 で引き続きサポートされています。
      </p><p>
        MySQL プログラムによって使用されるオプションファイルの詳細については、<a class="xref" href="programs.html#option-files" title="4.2.6 オプションファイルの使用">セクション4.2.6「オプションファイルの使用」</a>を参照してください。
      </p><h5><a name="idm139979001319488"></a>戻り値</h5><p>
        成功の場合はゼロ。不明なオプションを指定した場合はゼロ以外。
      </p><h5><a name="idm139979001318224"></a>例</h5><p>
        次の <code class="literal">mysql_options()</code> 呼び出しは、クライアント/サーバープロトコルでの圧縮の使用を要求し、オプションファイルの <code class="literal">[odbc]</code> グループからオプションを読み取らせ、トランザクション自動コミットモードを無効にします。
      </p><pre class="programlisting">
MYSQL mysql;

mysql_init(&amp;mysql);
mysql_options(&amp;mysql,MYSQL_OPT_COMPRESS,0);
mysql_options(&amp;mysql,MYSQL_READ_DEFAULT_GROUP,"odbc");
mysql_options(&amp;mysql,MYSQL_INIT_COMMAND,"SET autocommit=0");
if (!mysql_real_connect(&amp;mysql,"host","user","passwd","database",0,NULL,0))
{
    fprintf(stderr, "Failed to connect to database: Error: %s\n",
          mysql_error(&amp;mysql));
}
</pre><p>
        このコードは、クライアントが圧縮されたクライアント/サーバープロトコルを使用し、<code class="filename">my.cnf</code> ファイルの <code class="literal">odbc</code> セクションから追加のオプションを読み取ります。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-options4"></a>23.8.7.50 mysql_options4()</h4></div></div></div><a class="indexterm" name="idm139979001310256"></a><p>
        <code class="literal">int mysql_options4(MYSQL *mysql, enum mysql_option option, const void *arg1, const void *arg2)</code>
      </p><h5><a name="idm139979001307648"></a>説明</h5><p>
        <code class="literal">mysql_options4()</code> は <code class="literal">mysql_options()</code> と似ていますが、追加の 4 番目の引数があり、2 番目の引数に指定されたオプションに 2 つの値を渡せるようにしています。この関数は、MySQL 5.6.6 で追加されました。
      </p><p>
        次のリストに許可されるオプション、それらの効果、および <code class="literal">arg1</code> と <code class="literal">arg2</code> の使用方法について説明します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">MYSQL_OPT_CONNECT_ATTR_ADD</code> (引数の型: <code class="literal">char *, char *</code>)
          </p><p>
            このオプションは、接続時にサーバーに渡される現在の接続属性のセットに、鍵/値ペアを追加します。どちらの引数も NULL 終端文字列へのポインタです。最初と 2 番目の文字列は、鍵と値をそれぞれ示します。現在の接続属性のセットに、鍵がすでに存在する場合、エラーが発生します。既存のキーとのキー名の比較は大文字と小文字が区別されます。
          </p><p>
            下線 (<code class="literal">_</code>) で始まる鍵名は、内部使用のために予約されているため、アプリケーションプログラムで使用しないでください。
          </p><p>
            <code class="literal">mysql_options()</code> 関数の説明の <code class="literal">MYSQL_OPT_CONNECT_ATTR_RESET</code> <code class="literal">MYSQL_OPT_CONNECT_ATTR_DELETE</code> オプションの説明も参照してください。
          </p><p>
            接続属性は、<code class="literal">session_connect_attrs</code> および <code class="literal">session_account_connect_attrs</code> パフォーマンススキーマテーブル経由で公開されます。<a class="xref" href="performance-schema.html#performance-schema-connection-attribute-tables" title="22.9.8 パフォーマンススキーマ接続属性テーブル">セクション22.9.8「パフォーマンススキーマ接続属性テーブル」</a>を参照してください。
          </p></li></ul></div><h5><a name="idm139979001290656"></a>戻り値</h5><p>
        成功の場合はゼロ。不明なオプションを指定した場合はゼロ以外。
      </p><h5><a name="idm139979001289360"></a>例</h5><p>
        この例は、接続属性を指定する呼び出しを示しています。
      </p><pre class="programlisting">
MYSQL mysql;

mysql_init(&amp;mysql);
mysql_options(&amp;mysql,MYSQL_OPT_CONNECT_ATTR_RESET, 0);
mysql_options4(&amp;mysql,MYSQL_OPT_CONNECT_ATTR_ADD, "key1", "value1");
mysql_options4(&amp;mysql,MYSQL_OPT_CONNECT_ATTR_ADD, "key2", "value2");
mysql_options4(&amp;mysql,MYSQL_OPT_CONNECT_ATTR_ADD, "key3", "value3");
mysql_options(&amp;mysql,MYSQL_OPT_CONNECT_ATTR_DELETE, "key1");
if (!mysql_real_connect(&amp;mysql,"host","user","passwd","database",0,NULL,0))
{
    fprintf(stderr, "Failed to connect to database: Error: %s\n",
        mysql_error(&amp;mysql));
}
mysql_options(&amp;mysql,MYSQL_OPT_CONNECT_ATTR_RESET, 0);
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-ping"></a>23.8.7.51 mysql_ping()</h4></div></div></div><a class="indexterm" name="idm139979001285008"></a><p>
        <code class="literal">int mysql_ping(MYSQL *mysql)</code>
      </p><h5><a name="idm139979001282464"></a>説明</h5><p>
        サーバーへの接続が機能しているかどうかをチェックします。接続が切断され、自動再接続が有効にされている場合、再接続の試みが行われます。接続が切断し、自動再接続が無効にされている場合、<code class="literal">mysql_ping()</code> はエラーを返します。
      </p><p>
        自動再接続はデフォルトで無効にされています。それを有効にするには、<code class="literal">MYSQL_OPT_RECONNECT</code> オプションを使用して <code class="literal">mysql_options()</code> を呼び出します。詳細については、<a class="xref" href="connectors-apis.html#mysql-options" title="23.8.7.49 mysql_options()">セクション23.8.7.49「mysql_options()」</a>を参照してください。
      </p><p>
        <code class="literal">mysql_ping()</code> は、長い間アイドルのままでいるクライアントで、サーバーが接続を閉じているかどうかをチェックし、必要に応じて再接続するために使用できます。
      </p><p>
        <code class="literal">mysql_ping()</code> が再接続させる場合、その明示的な兆候はありません。再接続が行われるかどうかを判断するには、<code class="literal">mysql_ping()</code> を呼び出す前に <code class="literal">mysql_thread_id()</code> を呼び出して、元の接続識別子を取得してから、再度 <code class="literal">mysql_thread_id()</code> を呼び出して、識別子が変更されているかどうかを確認します。
      </p><p>
        再接続が行われた場合、接続の一部の特性がリセットされます。これらの特性の詳細については、<a class="xref" href="connectors-apis.html#auto-reconnect" title="23.8.16 自動再接続動作の制御">セクション23.8.16「自動再接続動作の制御」</a>を参照してください。
      </p><h5><a name="idm139979001268464"></a>戻り値</h5><p>
        サーバーへの接続がアクティブである場合はゼロ。エラーが発生した場合、ゼロ以外。ゼロ以外の戻り値は、MySQL サーバー自体が停止しているかどうかを示していません。ネットワークの問題などのその他の理由で接続が切断している可能性があります。
      </p><h5><a name="idm139979001266784"></a>エラー</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_COMMANDS_OUT_OF_SYNC</code>
          </p><p>
            コマンドが正しくない順番で実行されました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_GONE_ERROR</code>
          </p><p>
            MySQL サーバーが存在しなくなりました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_UNKNOWN_ERROR</code>
          </p><p>
            不明なエラーが発生しました。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-query"></a>23.8.7.52 mysql_query()</h4></div></div></div><a class="indexterm" name="idm139979001257744"></a><p>
        <code class="literal">int mysql_query(MYSQL *mysql, const char *stmt_str)</code>
      </p><h5><a name="idm139979001255184"></a>説明</h5><p>
        NULL 終端文字列 <code class="literal">stmt_str</code> によって指示される SQL ステートメントを実行します。通常、文字列は終端のセミコロン (<span class="quote">「<span class="quote"><code class="literal">;</code></span>」</span>) または <code class="literal">\g</code> を含まない単一の SQL ステートメントから構成されている必要があります。複数ステートメントの実行が有効にされている場合、文字列には、セミコロンで区切られた複数のステートメントを含めることができます。<a class="xref" href="connectors-apis.html#c-api-multiple-queries" title="23.8.17 複数ステートメント実行の C API サポート">セクション23.8.17「複数ステートメント実行の C API サポート」</a>を参照してください。
      </p><p>
        バイナリデータを含むステートメントには、<code class="literal">mysql_query()</code> を使うことはできません。代わりに、<code class="literal">mysql_real_query()</code> を使う必要があります。(バイナリデータには、<code class="literal">mysql_query()</code> がステートメント文字列の終端と解釈する <span class="quote">「<span class="quote"><code class="literal">\0</code></span>」</span> 文字が含まれることがあります。)
      </p><p>
        ステートメントが結果セットを返すかどうかを知りたい場合は、<code class="literal">mysql_field_count()</code> を使用してこれをチェックできます。<a class="xref" href="connectors-apis.html#mysql-field-count" title="23.8.7.22 mysql_field_count()">セクション23.8.7.22「mysql_field_count()」</a>を参照してください。
      </p><h5><a name="idm139979001243120"></a>戻り値</h5><p>
        成功の場合はゼロ。エラーが発生した場合、ゼロ以外。
      </p><h5><a name="idm139979001241888"></a>エラー</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_COMMANDS_OUT_OF_SYNC</code>
          </p><p>
            コマンドが正しくない順番で実行されました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_GONE_ERROR</code>
          </p><p>
            MySQL サーバーが存在しなくなりました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_LOST</code>
          </p><p>
            サーバーへの接続がクエリー中に失われました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_UNKNOWN_ERROR</code>
          </p><p>
            不明なエラーが発生しました。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-real-connect"></a>23.8.7.53 mysql_real_connect()</h4></div></div></div><a class="indexterm" name="idm139979001230544"></a><p>
        <code class="literal">MYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd, const char *db, unsigned int port, const char *unix_socket, unsigned long client_flag)</code>
      </p><h5><a name="idm139979001227856"></a>説明</h5><p>
        <code class="literal">mysql_real_connect()</code> は<code class="literal">ホスト</code>で実行している MySQL データベースエンジンへの接続の確立を試みます。<code class="literal">mysql_real_connect()</code> は、有効な <code class="literal">MYSQL</code> 接続ハンドル構造を必要とするほかの任意の API 関数を実行する前に、正常に完了している必要があります。
      </p><p>
        パラメータは次のように指定します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            最初のパラメータで、既存の <code class="literal">MYSQL</code> 構造のアドレスを指定します。<code class="literal">mysql_real_connect()</code> を呼び出す前に、<code class="literal">mysql_init()</code> を呼び出して、<code class="literal">MYSQL</code> 構造を初期化します。<code class="literal">mysql_options()</code> の呼び出しによって、多くの接続オプションを変更できます。<a class="xref" href="connectors-apis.html#mysql-options" title="23.8.7.49 mysql_options()">セクション23.8.7.49「mysql_options()」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">host</code> の値は、ホスト名または IP アドレスを指定できます。<code class="literal">host</code> が <code class="literal">NULL</code> か、文字列 <code class="literal">"localhost"</code> である場合、ローカルホストへの接続とみなされます。Windows では、サーバーで共有メモリー接続が有効にされている場合、クライアントは共有メモリー接続を使用して接続します。そうでない場合は、TCP/IP が使用されます。Unix では、クライアントは Unix ソケットファイルを使用して接続します。ローカル接続では、<code class="literal">mysql_options()</code> への <code class="literal">MYSQL_OPT_PROTOCOL</code> または <code class="literal">MYSQL_OPT_NAMED_PIPE</code> オプションで使用する接続の種類にも影響を与えることができます。接続の種類がサーバーでサポートされている必要があります。Windows での <code class="literal">"."</code> の <code class="literal">host</code> 値では、サーバーで名前付きパイプ接続が有効にされている場合、クライアントは名前付きパイプを使用して接続します。名前付きパイプ接続が有効にされていない場合は、エラーが発生します。
          </p></li><li class="listitem"><p>
            <code class="literal">user</code> パラメータにはユーザーの MySQL ログイン ID が含まれます。<code class="literal">user</code> が <code class="literal">NULL</code> かまたは空の文字列 <code class="literal">""</code> である場合、現在のユーザーが想定されます。Unix では、これは現在のログイン名です。Windows ODBC では、現在のユーザー名を明示的に指定する必要があります。<a class="xref" href="connectors-apis.html" title="第 23 章 Connector および API">第23章「<i>Connector および API</i>」</a>の Connector/ODBC のセクションを参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">passwd</code>パラメータには、<code class="literal">user</code> のパスワードが含まれます。<code class="literal">passwd</code> が <code class="literal">NULL</code> である場合、ブランク (空) のパスワードフィールドを持つユーザーの <code class="literal">user</code> テーブル内のエントリのみが一致をチェックされます。これにより、データベース管理者は、ユーザーがパスワードを指定しているかどうかに応じて、ユーザーが異なる権限を取得するような MySQL 権限システムをセットアップできます。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              <code class="literal">mysql_real_connect()</code> を呼び出す前に、パスワードを暗号化しようとしないでください。パスワードの暗号化はクライアント API によって自動的に処理されます。
            </p></div></li><li class="listitem"><p>
            <code class="literal">user</code> および <code class="literal">passwd</code> パラメータは、<code class="literal">MYSQL</code> オブジェクトに構成されている文字セットを使用します。デフォルトでこれは <code class="literal">latin1</code> ですが、接続の前に <code class="literal">mysql_options(mysql, MYSQL_SET_CHARSET_NAME, "<em class="replaceable"><code>charset_name</code></em>")</code> を呼び出すことによって変更できます。
          </p></li><li class="listitem"><p>
            <code class="literal">db</code> はデータベース名です。<code class="literal">db</code> が <code class="literal">NULL</code> でない場合、接続はデフォルトのデータベースをこの値に設定します。
          </p></li><li class="listitem"><p>
            <code class="literal">port</code> が 0 でない場合、値は TCP/IP 接続のポート番号として使用されます。<code class="literal">host</code> パラメータによって、接続の種類が決まります。
          </p></li><li class="listitem"><p>
            <code class="literal">unix_socket</code> が <code class="literal">NULL</code> でない場合、文字列は使用するソケットまたは名前付きパイプを指定します。<code class="literal">host</code> パラメータによって、接続の種類が決まります。
          </p></li><li class="listitem"><p>
            <code class="literal">client_flag</code> の値は通常 0 ですが、特定の機能を有効にするために、次のフラグの組み合わせに設定できます。
          </p><div class="informaltable"><table summary="この表では、フラグ名を一覧表示し、それぞれについて説明します。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">フラグ名</th><th scope="col">フラグの説明</th></tr></thead><tbody><tr><td scope="row"><code class="literal">CAN_HANDLE_EXPIRED_PASSWORDS</code></td><td>クライアントは期限切れのパスワードを処理できます。詳細については、<a class="xref" href="security.html#password-expiration-sandbox-mode" title="6.3.6 パスワードの期限切れとサンドボックスモード">セクション6.3.6「パスワードの期限切れとサンドボックスモード」</a>を参照してください。このオプションは MySQL 5.6.10 で追加されました。</td></tr><tr><td scope="row"><code class="literal">CLIENT_COMPRESS</code></td><td>圧縮プロトコルを使用します。</td></tr><tr><td scope="row"><code class="literal">CLIENT_FOUND_ROWS</code></td><td>変更された行の数ではなく、見つかった (一致した) 行の数を返します。</td></tr><tr><td scope="row"><code class="literal">CLIENT_IGNORE_SIGPIPE</code></td><td>クライアントライブラリの <code class="literal">SIGPIPE</code> シグナルハンドラのインストールを妨げます。これは、アプリケーションがすでにインストールしているハンドラとの競合を避けるために使用できます。</td></tr><tr><td scope="row"><code class="literal">CLIENT_IGNORE_SPACE</code></td><td>関数名のあとのスペースを許可します。すべての関数名を予約語にします。</td></tr><tr><td scope="row"><code class="literal">CLIENT_INTERACTIVE</code></td><td>接続を閉じるまで、<code class="literal">interactive_timeout</code> 秒 (<code class="literal">wait_timeout</code> 秒ではなく) の非アクティブを許可します。クライアントのセッション <code class="literal">wait_timeout</code> 変数は、セッション <code class="literal">interactive_timeout</code> 変数の値に設定されます。</td></tr><tr><td scope="row"><code class="literal">CLIENT_LOCAL_FILES</code></td><td><code class="literal">LOAD DATA LOCAL</code> 処理を有効にします。</td></tr><tr><td scope="row"><code class="literal">CLIENT_MULTI_RESULTS</code></td><td>サーバーに、クライアントは複数ステートメントの実行またはストアドプロシージャーからの複数の結果セットを処理できることを伝えます。<code class="literal">CLIENT_MULTI_STATEMENTS</code> が有効にされている場合、このフラグは自動的に有効にされます。このフラグの詳細については、この表のあとにある注記を参照してください。</td></tr><tr><td scope="row"><code class="literal">CLIENT_MULTI_STATEMENTS</code></td><td>サーバーに、クライアントは単一の文字列 (<span class="quote">「<span class="quote"><code class="literal">;</code></span>」</span> で区切られた) で複数のステートメントを送信する可能性があることを伝えます。このフラグが設定されていない場合、複数ステートメントの実行は無効になります。このフラグの詳細については、この表のあとにある注記を参照してください。</td></tr><tr><td scope="row"><code class="literal">CLIENT_NO_SCHEMA</code></td><td><em class="replaceable"><code>db_name.tbl_name.col_name</code></em> 構文を許可しません。これは ODBC 用です。ユーザーがその構文を使用した場合、パーサーにエラーを生成させます。これは特定の ODBC プログラムでバグのトラップに役立ちます。</td></tr><tr><td scope="row"><code class="literal">CLIENT_ODBC</code></td><td>使用されません。</td></tr><tr><td scope="row"><code class="literal">CLIENT_SSL</code></td><td>SSL (暗号化プロトコル) を使います。アプリケーションプログラム内にこのオプションを設定しないでください。それはクライアントライブラリに内部で設定されます。代わりに、<code class="literal">mysql_real_connect()</code> を呼び出す前に、<code class="literal">mysql_ssl_set()</code> を使用します。</td></tr><tr><td scope="row"><code class="literal">CLIENT_REMEMBER_OPTIONS</code></td><td><code class="literal">mysql_options()</code> への呼び出しに指定したオプションを覚えておきます。このオプションを使用しないと、<code class="literal">mysql_real_connect()</code> が失敗した場合、再度接続を試みる前に、<code class="literal">mysql_options()</code> 呼び出しを繰り返す必要があります。このオプションを使用すると、<code class="literal">mysql_options()</code> 呼び出しを繰り返す必要がありません。</td></tr></tbody></table></div></li></ul></div><p>
        プログラムで <code class="literal">CALL</code> ステートメントを使用して、ストアドプロシージャーを実行する場合、<code class="literal">CLIENT_MULTI_RESULTS</code> フラグが有効になっている必要があります。これは、各 <code class="literal">CALL</code> によって、プロシージャー内で実行されるステートメントによって返される可能性のある結果セットに加えて、呼び出しステータスを示すための結果が返されるためです。<code class="literal">CALL</code> は複数の結果を返すことができるため、<code class="literal">mysql_next_result()</code> を呼び出すループを使用して、それらを処理し、それ以上の結果があるかどうかを判断します。
      </p><p>
        <code class="literal">CLIENT_MULTI_RESULTS</code> は、<code class="literal">mysql_real_connect()</code> を呼び出すときに、<code class="literal">CLIENT_MULTI_RESULTS</code> フラグ自体を渡すことによって明示的に、または <code class="literal">CLIENT_MULTI_STATEMENTS</code> を渡すことによって暗黙的に有効にする (これによって <code class="literal">CLIENT_MULTI_RESULTS</code> も有効になります) ことができます。MySQL 5.6 では、<code class="literal">CLIENT_MULTI_RESULTS</code> はデフォルトで有効にされています。
      </p><p>
        <code class="literal">CLIENT_MULTI_STATEMENTS</code> または <code class="literal">CLIENT_MULTI_RESULTS</code> を有効にした場合、それ以上の結果があるかどうかを判断するために <code class="literal">mysql_next_result()</code> を呼び出すループを使用して、<code class="literal">mysql_query()</code> または <code class="literal">mysql_real_query()</code> へのすべての呼び出しの結果を処理します。例については、<a class="xref" href="connectors-apis.html#c-api-multiple-queries" title="23.8.17 複数ステートメント実行の C API サポート">セクション23.8.17「複数ステートメント実行の C API サポート」</a>を参照してください。
      </p><p>
        一部のパラメータでは、<code class="literal">mysql_real_connect()</code> 呼び出しでの明示的な値からでなく、オプションファイルから値を取得させることができます。これを行うには、<code class="literal">mysql_real_connect()</code> を呼び出す前に、<code class="literal">MYSQL_READ_DEFAULT_FILE</code> または <code class="literal">MYSQL_READ_DEFAULT_GROUP</code> オプションを使用して、<code class="literal">mysql_options()</code> を呼び出します。その後、オプションファイルから読み取られるパラメータごとに、<code class="literal">mysql_real_connect()</code> の呼び出しで、<span class="quote">「<span class="quote">no-value</span>」</span> 値を指定します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">host</code> に対して、<code class="literal">NULL</code> または空の文字列 (<code class="literal">""</code>) の値を指定します。
          </p></li><li class="listitem"><p>
            <code class="literal">user</code> に対して、<code class="literal">NULL</code> または空の文字列の値を指定します。
          </p></li><li class="listitem"><p>
            <code class="literal">passwd</code> に対して、<code class="literal">NULL</code> の値を指定します。(パスワードの場合、<code class="literal">mysql_real_connect()</code> 呼び出しの空の文字列の値は、オプションファイルでオーバーライドできません。空の文字列は、MySQL アカウントが空のパスワードを持つ必要があることを明示的に示しているためです。)
          </p></li><li class="listitem"><p>
            <code class="literal">db</code> に対して、<code class="literal">NULL</code> または空の文字列の値を指定します。
          </p></li><li class="listitem"><p>
            <code class="literal">port</code> に対して、0 の値を指定します。
          </p></li><li class="listitem"><p>
            <code class="literal">unix_socket</code> に対して、<code class="literal">NULL</code> の値を指定します。
          </p></li></ul></div><p>
        パラメータのオプションファイルに値が見つからない場合、このセクションの前のほうの説明で示したように、そのデフォルト値が使われます。
      </p><h5><a name="idm139979001092864"></a>戻り値</h5><p>
        接続が成功した場合は <code class="literal">MYSQL*</code> 接続ハンドル、接続が成功しなかった場合は <code class="literal">NULL</code>。接続が成功した場合、戻り値は最初のパラメータの値と同じになります。
      </p><h5><a name="idm139979001090048"></a>エラー</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_CONN_HOST_ERROR</code>
          </p><p>
            MySQL サーバーへの接続に失敗しました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_CONNECTION_ERROR</code>
          </p><p>
            ローカル MySQL サーバーへの接続に失敗しました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_IPSOCK_ERROR</code>
          </p><p>
            IP ソケットの作成に失敗しました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_OUT_OF_MEMORY</code>
          </p><p>
            メモリー不足。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SOCKET_CREATE_ERROR</code>
          </p><p>
            Unix ソケットの作成に失敗しました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_UNKNOWN_HOST</code>
          </p><p>
            ホスト名の IP アドレスの検出に失敗しました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_VERSION_ERROR</code>
          </p><p>
            異なるプロトコルバージョンを使用するクライアントライブラリによるサーバーへの接続の試みから発生したプロトコルの不一致。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_NAMEDPIPEOPEN_ERROR</code>
          </p><p>
            Windows で名前付きパイプの作成に失敗しました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_NAMEDPIPEWAIT_ERROR</code>
          </p><p>
            Windows で名前付きパイプの待機に失敗しました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_NAMEDPIPESETSTATE_ERROR</code>
          </p><p>
            Windows でパイプハンドラの取得に失敗しました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_LOST</code>
          </p><p>
            <code class="literal">connect_timeout</code> &gt; 0 で、サーバーに接続するために <code class="literal">connect_timeout</code> 秒より長くかかった場合、または <code class="literal">init-command</code> の実行中にサーバーが停止した場合。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_ALREADY_CONNECTED</code>
          </p><p>
            <code class="literal">MYSQL</code> 接続ハンドルはすでに接続されています。
          </p></li></ul></div><h5><a name="idm139979001057808"></a>例</h5><pre class="programlisting">
MYSQL mysql;

mysql_init(&amp;mysql);
mysql_options(&amp;mysql,MYSQL_READ_DEFAULT_GROUP,"your_prog_name");
if (!mysql_real_connect(&amp;mysql,"host","user","passwd","database",0,NULL,0))
{
    fprintf(stderr, "Failed to connect to database: Error: %s\n",
          mysql_error(&amp;mysql));
}
</pre><p>
        <code class="literal">mysql_options()</code> を使用することで、MySQL ライブラリは、だれかが MySQL を標準でない方法でセットアップした場合でも、プログラムが動作するようにする <code class="filename">my.cnf</code> ファイル内の <code class="literal">[client]</code> および <code class="literal">[your_prog_name]</code> セクションを読み取ります。
      </p><p>
        接続時に、<code class="literal">mysql_real_connect()</code> は、<code class="literal">reconnect</code> フラグ (<code class="literal">MYSQL</code> 構造の一部) を、5.0.3 より古い API のバージョンでは <code class="literal">1</code> の値、以降のバージョンでは <code class="literal">0</code> の値に設定してください。このフラグの <code class="literal">1</code> の値は、切断された接続のためにステートメントを実行できない場合、諦める前にサーバーに再接続しようとすることを示します。<code class="literal">mysql_options()</code> に <code class="literal">MYSQL_OPT_RECONNECT</code> オプションを使用して、再接続動作を制御できます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-real-escape-string"></a>23.8.7.54 mysql_real_escape_string()</h4></div></div></div><a class="indexterm" name="idm139979001043040"></a><p>
        <code class="literal">unsigned long mysql_real_escape_string(MYSQL *mysql, char *to, const char *from, unsigned long length)</code>
      </p><p>
        <code class="literal">mysql</code> は有効な開いている接続でなければなりません。エスケープはサーバーで使用されている文字セットによって異なるため、これが必要です。
      </p><h5><a name="idm139979001038912"></a>説明</h5><p>
        この関数は、SQL ステートメントで使用できる正当な SQL 文字列を作成するために使われます。<a class="xref" href="language-structure.html#string-literals" title="9.1.1 文字列リテラル">セクション9.1.1「文字列リテラル」</a>を参照してください。
      </p><a class="indexterm" name="idm139979001036944"></a><p>
        <code class="literal">from</code> 内の文字列は、接続の現在の文字セットを考慮して、エスケープされた SQL 文字列にエンコードされます。結果は <code class="literal">to</code> に置かれ、終端の NULL バイトが付加されます。エンコードされる文字は <span class="quote">「<span class="quote"><code class="literal">\</code></span>」</span>、<span class="quote">「<span class="quote"><code class="literal">'</code></span>」</span>、<span class="quote">「<span class="quote"><code class="literal">"</code></span>」</span>、<code class="literal">NUL</code> (ASCII 0)、<span class="quote">「<span class="quote"><code class="literal">\n</code></span>」</span>、<span class="quote">「<span class="quote"><code class="literal">\r</code></span>」</span>、および Control+Z です。厳密に言うと、MySQL では、クエリー内の文字列に引用符を付けるために使われるバックスラッシュと引用文字がエスケープされることのみを必要とします。<code class="literal">mysql_real_escape_string()</code> は、ほかの文字をログファイル内で読みやすくするために引用符で囲みます。比較については、<a class="xref" href="language-structure.html#string-literals" title="9.1.1 文字列リテラル">セクション9.1.1「文字列リテラル」</a>および<a class="xref" href="functions.html#string-functions" title="12.5 文字列関数">セクション12.5「文字列関数」</a>のリテラル文字列と <code class="literal">QUOTE()</code> SQL 関数の引用符使用のルールを参照してください。
      </p><p>
        <code class="literal">from</code> によって指示される文字列は、<code class="literal">length</code> バイトの長さである必要があります。<code class="literal">to</code> バッファーを少なくとも <code class="literal">length*2+1</code> バイト長になるように割り当てる必要があります。(最悪の場合、各文字を 2 バイトを使用してエンコードする必要がある可能性があるため、終端の NULL バイト分の空きが必要です。)<code class="literal">mysql_real_escape_string()</code> が戻ったときの <code class="literal">to</code> の内容は NULL 終端文字列です。戻り値は、終端の NULL 文字を含まない、エンコードされた文字列の長さです。
      </p><p>
        接続の文字セットを変更する必要がある場合、<code class="literal">SET NAMES</code> (または <code class="literal">SET CHARACTER SET</code>) ステートメントを実行するのではなく、<code class="literal">mysql_set_character_set()</code> 関数を使用します。<code class="literal">mysql_set_character_set()</code> は、<code class="literal">SET NAMES</code> と同じように機能しますが、<code class="literal">SET NAMES</code> では影響を与えない <code class="literal">mysql_real_escape_string()</code> で使用される文字セットにも影響を与えます。
      </p><h5><a name="idm139979001011728"></a>例</h5><pre class="programlisting">
char query[1000],*end;

end = strmov(query,"INSERT INTO test_table values(");
*end++ = '\'';
end += mysql_real_escape_string(&amp;mysql, end,"What is this",12);
*end++ = '\'';
*end++ = ',';
*end++ = '\'';
end += mysql_real_escape_string(&amp;mysql, end,"binary data: \0\r\n",16);
*end++ = '\'';
*end++ = ')';

if (mysql_real_query(&amp;mysql,query,(unsigned int) (end - query)))
{
   fprintf(stderr, "Failed to insert row, Error: %s\n",
           mysql_error(&amp;mysql));
}
</pre><p>
        例で使用している <code class="literal">strmov()</code> 関数は、<code class="literal">libmysqlclient</code> ライブラリに含まれ、<code class="literal">strcpy()</code> のように機能しますが、最初のパラメータの終端の NULL へのポインタを返します。
      </p><h5><a name="idm139979001006768"></a>戻り値</h5><p>
        <code class="literal">to</code> に置かれた、終端の NULL 文字を含まない値の長さ。
      </p><h5><a name="idm139979001004864"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-real-query"></a>23.8.7.55 mysql_real_query()</h4></div></div></div><a class="indexterm" name="idm139979001002560"></a><p>
        <code class="literal">int mysql_real_query(MYSQL *mysql, const char *stmt_str, unsigned long length)</code>
      </p><h5><a name="idm139979000999968"></a>説明</h5><p>
        <code class="literal">length</code> バイト長の文字列 <code class="literal">stmt_str</code> によって指示された SQL ステートメントを実行します。通常、文字列は終端のセミコロン (<span class="quote">「<span class="quote"><code class="literal">;</code></span>」</span>) または <code class="literal">\g</code> を含まない単一の SQL ステートメントから構成されている必要があります。複数ステートメントの実行が有効にされている場合、文字列には、セミコロンで区切られた複数のステートメントを含めることができます。<a class="xref" href="connectors-apis.html#c-api-multiple-queries" title="23.8.17 複数ステートメント実行の C API サポート">セクション23.8.17「複数ステートメント実行の C API サポート」</a>を参照してください。
      </p><p>
        バイナリデータを含むステートメントには、<code class="literal">mysql_query()</code> を使うことはできません。代わりに、<code class="literal">mysql_real_query()</code> を使う必要があります。(バイナリデータには、<code class="literal">mysql_query()</code> がステートメント文字列の終端と解釈する <span class="quote">「<span class="quote"><code class="literal">\0</code></span>」</span> 文字が含まれることがあります。)さらに、<code class="literal">mysql_real_query()</code> はステートメント文字列に対して <code class="literal">strlen()</code> を呼び出さないため、<code class="literal">mysql_query()</code> より高速です。
      </p><p>
        ステートメントが結果セットを返すかどうかを知りたい場合は、<code class="literal">mysql_field_count()</code> を使用してこれをチェックできます。<a class="xref" href="connectors-apis.html#mysql-field-count" title="23.8.7.22 mysql_field_count()">セクション23.8.7.22「mysql_field_count()」</a>を参照してください。
      </p><h5><a name="idm139979000984416"></a>戻り値</h5><p>
        成功の場合はゼロ。エラーが発生した場合、ゼロ以外。
      </p><h5><a name="idm139979000983184"></a>エラー</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_COMMANDS_OUT_OF_SYNC</code>
          </p><p>
            コマンドが正しくない順番で実行されました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_GONE_ERROR</code>
          </p><p>
            MySQL サーバーが存在しなくなりました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_LOST</code>
          </p><p>
            サーバーへの接続がクエリー中に失われました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_UNKNOWN_ERROR</code>
          </p><p>
            不明なエラーが発生しました。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-refresh"></a>23.8.7.56 mysql_refresh()</h4></div></div></div><a class="indexterm" name="idm139979000971792"></a><p>
        <code class="literal">int mysql_refresh(MYSQL *mysql, unsigned int options)</code>
      </p><h5><a name="idm139979000969232"></a>説明</h5><p>
        この関数はテーブルまたはキャッシュをフラッシュするか、レプリケーションサーバー情報をリセットします。接続されたユーザーは <code class="literal">RELOAD</code> 権限を持つ必要があります。
      </p><p>
        <code class="literal">options</code> 引数は次の値の任意の組み合わせから構成されるビットマスクです。複数の値をまとめて OR をとり、単一の呼び出しで複数の操作を実行できます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">REFRESH_GRANT</code>
          </p><p>
            <code class="literal">FLUSH PRIVILEGES</code> などの付与テーブルをリフレッシュします。
          </p></li><li class="listitem"><p>
            <code class="literal">REFRESH_LOG</code>
          </p><p>
            <code class="literal">FLUSH LOGS</code> のように、ログをフラッシュします。
          </p></li><li class="listitem"><p>
            <code class="literal">REFRESH_TABLES</code>
          </p><p>
            <code class="literal">FLUSH TABLES</code> のように、テーブルキャッシュをフラッシュします。
          </p></li><li class="listitem"><p>
            <code class="literal">REFRESH_HOSTS</code>
          </p><p>
            <code class="literal">FLUSH HOSTS</code> のように、ホストキャッシュをフラッシュします。
          </p></li><li class="listitem"><p>
            <code class="literal">REFRESH_STATUS</code>
          </p><p>
            <code class="literal">FLUSH STATUS</code> のように、ステータス変数をリセットします。
          </p></li><li class="listitem"><p>
            <code class="literal">REFRESH_THREADS</code>
          </p><p>
            スレッドキャッシュをフラッシュします。
          </p></li><li class="listitem"><p>
            <code class="literal">REFRESH_SLAVE</code>
          </p><p>
            スレーブレプリケーションサーバーで、<code class="literal">RESET SLAVE</code> のように、マスターサーバー情報をリセットし、スレーブを再起動します。
          </p></li><li class="listitem"><p>
            <code class="literal">REFRESH_MASTER</code>
          </p><p>
            マスターレプリケーションサーバーで、<code class="literal">RESET MASTER</code> のように、バイナリログインデックスに示されているバイナリログファイルを削除し、インデックスファイルを切り捨てます。
          </p></li></ul></div><h5><a name="idm139979000940080"></a>戻り値</h5><p>
        成功の場合はゼロ。エラーが発生した場合、ゼロ以外。
      </p><h5><a name="idm139979000938816"></a>エラー</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_COMMANDS_OUT_OF_SYNC</code>
          </p><p>
            コマンドが正しくない順番で実行されました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_GONE_ERROR</code>
          </p><p>
            MySQL サーバーが存在しなくなりました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_LOST</code>
          </p><p>
            サーバーへの接続がクエリー中に失われました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_UNKNOWN_ERROR</code>
          </p><p>
            不明なエラーが発生しました。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-reload"></a>23.8.7.57 mysql_reload()</h4></div></div></div><a class="indexterm" name="idm139979000927424"></a><p>
        <code class="literal">int mysql_reload(MYSQL *mysql)</code>
      </p><h5><a name="idm139979000924880"></a>説明</h5><p>
        MySQL サーバーに付与テーブルをリロードするように求めます。接続されたユーザーは <code class="literal">RELOAD</code> 権限を持つ必要があります。
      </p><p>
        この関数は非推奨です。代わりに、<code class="literal">mysql_query()</code> を使用して、SQL <code class="literal">FLUSH PRIVILEGES</code> ステートメントを発行することをお勧めします。
      </p><h5><a name="idm139979000918816"></a>戻り値</h5><p>
        成功の場合はゼロ。エラーが発生した場合、ゼロ以外。
      </p><h5><a name="idm139979000917552"></a>エラー</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_COMMANDS_OUT_OF_SYNC</code>
          </p><p>
            コマンドが正しくない順番で実行されました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_GONE_ERROR</code>
          </p><p>
            MySQL サーバーが存在しなくなりました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_LOST</code>
          </p><p>
            サーバーへの接続がクエリー中に失われました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_UNKNOWN_ERROR</code>
          </p><p>
            不明なエラーが発生しました。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-rollback"></a>23.8.7.58 mysql_rollback()</h4></div></div></div><a class="indexterm" name="idm139979000906160"></a><p>
        <code class="literal">my_bool mysql_rollback(MYSQL *mysql)</code>
      </p><h5><a name="idm139979000903616"></a>説明</h5><p>
        現在のトランザクションをロールバックします。
      </p><p>
        この関数のアクションは、<code class="literal">completion_type</code> システム変数の値に影響を受けます。特に、<code class="literal">completion_type</code> の値が <code class="literal">RELEASE</code> (または 2) の場合、トランザクションの終了後、サーバーは解放を実行し、クライアント接続を閉じます。クライアントプログラムから <code class="literal">mysql_close()</code> を呼び出して、クライアント側から接続をクローズします。
      </p><h5><a name="idm139979000897552"></a>戻り値</h5><p>
        成功の場合はゼロ。エラーが発生した場合、ゼロ以外。
      </p><h5><a name="idm139979000896288"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-row-seek"></a>23.8.7.59 mysql_row_seek()</h4></div></div></div><a class="indexterm" name="idm139979000893984"></a><p>
        <code class="literal">MYSQL_ROW_OFFSET mysql_row_seek(MYSQL_RES *result, MYSQL_ROW_OFFSET offset)</code>
      </p><h5><a name="idm139979000891392"></a>説明</h5><p>
        クエリー結果セットの任意の行に行カーソルを設定します。<code class="literal">offset</code> 値は、一般に <code class="literal">mysql_row_tell()</code> または <code class="literal">mysql_row_seek()</code> から返される値である行オフセットです。この値は行番号ではありません。番号によって結果セット内の行にシークするには、代わりに <code class="literal">mysql_data_seek()</code> を使用します。
      </p><p>
        この関数は、結果セット構造にクエリーの結果全体を格納することを必要とするため、<code class="literal">mysql_row_seek()</code> は、<code class="literal">mysql_use_result()</code> とではなく、<code class="literal">mysql_store_result()</code> と一緒にのみ使用できます。
      </p><h5><a name="idm139979000882272"></a>戻り値</h5><p>
        行カーソルの前の値。この値は、<code class="literal">mysql_row_seek()</code> への後続の呼び出しに渡すことができます。
      </p><h5><a name="idm139979000879952"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-row-tell"></a>23.8.7.60 mysql_row_tell()</h4></div></div></div><a class="indexterm" name="idm139979000877648"></a><p>
        <code class="literal">MYSQL_ROW_OFFSET mysql_row_tell(MYSQL_RES *result)</code>
      </p><h5><a name="idm139979000875088"></a>説明</h5><p>
        最後の <code class="literal">mysql_fetch_row()</code> の行カーソルの現在の位置を返します。この値は、<code class="literal">mysql_row_seek()</code> への引数として使うことができます。
      </p><p>
        <code class="literal">mysql_row_tell()</code> は、<code class="literal">mysql_use_result()</code> のあとではなく、<code class="literal">mysql_store_result()</code> のあとにのみ使用します。
      </p><h5><a name="idm139979000868288"></a>戻り値</h5><p>
        行カーソルの現在のオフセット。
      </p><h5><a name="idm139979000867072"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-select-db"></a>23.8.7.61 mysql_select_db()</h4></div></div></div><a class="indexterm" name="idm139979000864768"></a><p>
        <code class="literal">int mysql_select_db(MYSQL *mysql, const char *db)</code>
      </p><h5><a name="idm139979000862208"></a>説明</h5><p>
        <code class="literal">db</code> で指定されたデータベースを、<code class="literal">mysql</code> で指定された接続で、デフォルトの (現在の) データベースにさせます。その後のクエリーで、このデータベースは明示的なデータベース指定子を含まないテーブル参照のデフォルトになります。
      </p><p>
        データベースに使用する権限を持っているとして、接続されたユーザーを認証できないかぎり、<code class="literal">mysql_select_db()</code> は失敗します。
      </p><h5><a name="idm139979000857424"></a>戻り値</h5><p>
        成功の場合はゼロ。エラーが発生した場合、ゼロ以外。
      </p><h5><a name="idm139979000856160"></a>エラー</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_COMMANDS_OUT_OF_SYNC</code>
          </p><p>
            コマンドが正しくない順番で実行されました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_GONE_ERROR</code>
          </p><p>
            MySQL サーバーが存在しなくなりました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_LOST</code>
          </p><p>
            サーバーへの接続がクエリー中に失われました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_UNKNOWN_ERROR</code>
          </p><p>
            不明なエラーが発生しました。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-set-character-set"></a>23.8.7.62 mysql_set_character_set()</h4></div></div></div><a class="indexterm" name="idm139979000844720"></a><p>
        <code class="literal">int mysql_set_character_set(MYSQL *mysql, const char *csname)</code>
      </p><h5><a name="idm139979000842144"></a>説明</h5><p>
        この関数は現在の接続のデフォルトの文字セットを設定するために使用します。文字列 <code class="literal">csname</code> は有効な文字セット名を指定します。接続の照合順序は文字セットのデフォルトの照合順序になります。この関数は <code class="literal">SET NAMES</code> ステートメントのように機能しますが、<code class="literal">mysql-&gt;charset</code> の値も設定するため、<code class="literal">mysql_real_escape_string()</code> によって使用される文字セットに影響を与えます
      </p><h5><a name="idm139979000837056"></a>戻り値</h5><p>
        成功の場合はゼロ。エラーが発生した場合、ゼロ以外。
      </p><h5><a name="idm139979000835792"></a>例</h5><pre class="programlisting">
MYSQL mysql;

mysql_init(&amp;mysql);
if (!mysql_real_connect(&amp;mysql,"host","user","passwd","database",0,NULL,0))
{
    fprintf(stderr, "Failed to connect to database: Error: %s\n",
          mysql_error(&amp;mysql));
}

if (!mysql_set_character_set(&amp;mysql, "utf8"))
{
    printf("New client character set: %s\n",
           mysql_character_set_name(&amp;mysql));
}
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-set-local-infile-default"></a>23.8.7.63 mysql_set_local_infile_default()</h4></div></div></div><a class="indexterm" name="idm139979000832576"></a><a class="indexterm" name="idm139979000831200"></a><p>
        <code class="literal">void mysql_set_local_infile_default(MYSQL *mysql);</code>
      </p><h5><a name="idm139979000828608"></a>説明</h5><p>
        <code class="literal">LOAD LOCAL DATA INFILE</code> ハンドラコールバック関数を、C クライアントライブラリによって内部で使用されるデフォルトに設定します。<code class="literal">mysql_set_local_infile_handler()</code> が呼び出されなかったか、その各コールバックに対して有効な関数を提供しない場合、ライブラリはこの関数を自動的に呼び出します。
      </p><h5><a name="idm139979000825152"></a>戻り値</h5><p>
        なし。
      </p><h5><a name="idm139979000824016"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-set-local-infile-handler"></a>23.8.7.64 mysql_set_local_infile_handler()</h4></div></div></div><p>
        <code class="literal">void mysql_set_local_infile_handler(MYSQL *mysql, int (*local_infile_init)(void **, const char *, void *), int (*local_infile_read)(void *, char *, unsigned int), void (*local_infile_end)(void *), int (*local_infile_error)(void *, char*, unsigned int), void *userdata);</code>
      </p><h5><a name="idm139979000820224"></a>説明</h5><p>
        この関数は <code class="literal">LOAD DATA LOCAL INFILE</code> ステートメントの実行中に使用されるコールバックをインストールします。それにより、アプリケーションプログラムは、ローカル (クライアント側) データファイルの読み取りを制御できます。引数は、接続ハンドラ、コールバック関数への一連のポインタ、およびコールバックが情報を共有するために使用できるデータ領域へのポインタです。
      </p><p>
        <code class="literal">mysql_set_local_infile_handler()</code> を使うには、次のコールバック関数を書く必要があります。
      </p><pre class="programlisting">
int
local_infile_init(void **ptr, const char *filename, void *userdata);
</pre><p>
        初期化関数。これは、必要な設定を実行する、データファイルを開く、データ構造を割り当てるなどのために 1 回呼び出されます。最初の <code class="literal">void**</code> 引数はポインタへのポインタです。ほかの各コールバックに渡される値へのポインタ (つまり、<code class="literal">*ptr</code>) を設定できます (<code class="literal">void*</code> として)。コールバックは、この指示先の値を使用して、状態情報を保守できます。<code class="literal">userdata</code> 引数は <code class="literal">mysql_set_local_infile_handler()</code> に渡される同じ値です。
      </p><p>
        初期化関数が成功の場合はゼロを返し、エラーの場合はゼロ以外を返すようにします。
      </p><pre class="programlisting">
int
local_infile_read(void *ptr, char *buf, unsigned int buf_len);
</pre><p>
        データ読み取り関数。これはデータファイルを読み取るために繰り返し呼び出されます。<code class="literal">buf</code> は、読み取られたデータを格納するバッファーを指示し、<code class="literal">buf_len</code> はコールバックが読み取り、バッファーに格納できる最大バイト数です。(それより少ないバイトを読み取ることはできますが、それより多くのバイトを読み取るべきではありません。)
      </p><p>
        戻り値は読み取ったバイト数で、それ以上のデータを読み取ることができなかった場合はゼロです (これは EOF を示します)。エラーが発生した場合、ゼロ未満の値を返します。
      </p><pre class="programlisting">
void
local_infile_end(void *ptr)
</pre><p>
        終了関数。これは、<code class="literal">local_infile_read()</code> がゼロ (EOF) またはエラーを返したあとに 1 回呼び出されます。この関数内では、<code class="literal">local_infile_init()</code> によって割り当てられたメモリーの割り当てを解除し、必要なほかのクリーンアップを実行します。それは、初期化関数がエラーを返した場合でも呼び出されます。
      </p><pre class="programlisting">
int
local_infile_error(void *ptr,
                   char *error_msg,
                   unsigned int error_msg_len);
</pre><p>
        エラー処理関数。これは、ほかのいずれかの関数がエラーを返した場合に、ユーザーに返すテキストのエラーメッセージを取得するために呼び出されます。<code class="literal">error_msg</code> はメッセージが書き込まれるバッファーを指示し、<code class="literal">error_msg_len</code> はバッファーの長さです。最大 <code class="literal">error_msg_len</code>−1 バイト長で、NULL 終端文字列としてメッセージを書き込みます。
      </p><p>
        戻り値はエラー番号です。
      </p><p>
        一般に、ほかのコールバックは <code class="literal">ptr</code> によって指示されるデータ構造にエラーメッセージを格納するため、<code class="literal">local_infile_error()</code> はそこから <code class="literal">error_msg</code> にメッセージをコピーできます。
      </p><p>
        C コードで <code class="literal">mysql_set_local_infile_handler()</code> を呼び出し、ポインタをコールバック関数に渡したあとに、<code class="literal">LOAD DATA LOCAL INFILE</code>ステートメントを発行できます (たとえば、<code class="literal">mysql_query()</code> を使用して)。クライアントライブラリは自動的にコールバックを呼び出します。<code class="literal">LOAD DATA LOCAL INFILE</code> は、<code class="literal">local_infile_init()</code> コールバックに 2 番目のパラメータとして渡されます。
      </p><h5><a name="idm139979000787600"></a>戻り値</h5><p>
        なし。
      </p><h5><a name="idm139979000786464"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-set-server-option"></a>23.8.7.65 mysql_set_server_option()</h4></div></div></div><a class="indexterm" name="idm139979000784112"></a><p>
        <code class="literal">int mysql_set_server_option(MYSQL *mysql, enum enum_mysql_set_option option)</code>
      </p><h5><a name="idm139979000781520"></a>説明</h5><p>
        接続のオプションを有効または無効にします。<code class="literal">option</code> には次のいずれかの値を指定できます。
      </p><div class="informaltable"><table summary="この表は、mysql_set_server_option() のオプションを一覧表示し、各オプションについて説明します。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">オプション</th><th scope="col">説明</th></tr></thead><tbody><tr><td scope="row"><code class="literal">MYSQL_OPTION_MULTI_STATEMENTS_ON</code></td><td>複数ステートメントのサポートを有効にします</td></tr><tr><td scope="row"><code class="literal">MYSQL_OPTION_MULTI_STATEMENTS_OFF</code></td><td>複数ステートメントのサポートを無効にします</td></tr></tbody></table></div><p>
        複数ステートメントのサポートを有効にする場合、<code class="literal">mysql_next_result()</code> を呼び出すループを使用して、それ以上の結果があるかどうかを判断することによって、<code class="literal">mysql_query()</code> または <code class="literal">mysql_real_query()</code> への呼び出しからの結果を取得してください。例については、<a class="xref" href="connectors-apis.html#c-api-multiple-queries" title="23.8.17 複数ステートメント実行の C API サポート">セクション23.8.17「複数ステートメント実行の C API サポート」</a>を参照してください。
      </p><p>
        <code class="literal">MYSQL_OPTION_MULTI_STATEMENTS_ON</code> による複数ステートメントのサポートの有効化は、<code class="literal">CLIENT_MULTI_STATEMENTS</code> フラグを <code class="literal">mysql_real_connect()</code> に渡すことによって、それを有効化する場合とまったく同じ効果を持つわけではありません。<code class="literal">CLIENT_MULTI_STATEMENTS</code> は <code class="literal">CLIENT_MULTI_RESULTS</code> も有効にします。プログラムで <code class="literal">CALL</code> SQL ステートメントを使用している場合、複数結果のサポートを有効にする必要があります。これは、<code class="literal">MYSQL_OPTION_MULTI_STATEMENTS_ON</code> だけでは、<code class="literal">CALL</code> の使用を許可するのに不十分であることを意味します。
      </p><h5><a name="idm139979000757664"></a>戻り値</h5><p>
        成功の場合はゼロ。エラーが発生した場合、ゼロ以外。
      </p><h5><a name="idm139979000756400"></a>エラー</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_COMMANDS_OUT_OF_SYNC</code>
          </p><p>
            コマンドが正しくない順番で実行されました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_GONE_ERROR</code>
          </p><p>
            MySQL サーバーが存在しなくなりました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_LOST</code>
          </p><p>
            サーバーへの接続がクエリー中に失われました。
          </p></li><li class="listitem"><p>
            <code class="literal">ER_UNKNOWN_COM_ERROR</code>
          </p><p>
            サーバーは <code class="literal">mysql_set_server_option()</code> をサポートしていなかった (これはサーバーが 4.1.1 より古い場合) か、または設定しようとしたオプションをサポートしていませんでした。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-shutdown"></a>23.8.7.66 mysql_shutdown()</h4></div></div></div><a class="indexterm" name="idm139979000743680"></a><p>
        <code class="literal">int mysql_shutdown(MYSQL *mysql, enum mysql_enum_shutdown_level shutdown_level)</code>
      </p><h5><a name="idm139979000741088"></a>説明</h5><p>
        データベースサーバーにシャットダウンするように求めます。接続されたユーザーは <code class="literal">SHUTDOWN</code> 権限を持っている必要があります。MySQL 5.6 サーバーは 1 種類のシャットダウンしかサポートしていません。<code class="literal">shutdown_level</code> は <code class="literal">SHUTDOWN_DEFAULT</code> と等しい必要があります。目的のレベルを選択できるようにするため、追加のシャットダウンレベルが計画されています。古いバージョンの <code class="literal">libmysqlclient</code> ヘッダーや呼び出し <code class="literal">mysql_shutdown()</code> でコンパイルされた、ダイナミックリンクされた実行可能ファイルは、古い <code class="literal">libmysqlclient</code> ダイナミックライブラリと一緒に使用する必要があります。
      </p><p>
        シャットダウンプロセスについては、<a class="xref" href="server-administration.html#server-shutdown" title="5.1.12 シャットダウンプロセス">セクション5.1.12「シャットダウンプロセス」</a>で説明しています。
      </p><h5><a name="idm139979000732592"></a>戻り値</h5><p>
        成功の場合はゼロ。エラーが発生した場合、ゼロ以外。
      </p><h5><a name="idm139979000731360"></a>エラー</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_COMMANDS_OUT_OF_SYNC</code>
          </p><p>
            コマンドが正しくない順番で実行されました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_GONE_ERROR</code>
          </p><p>
            MySQL サーバーが存在しなくなりました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_LOST</code>
          </p><p>
            サーバーへの接続がクエリー中に失われました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_UNKNOWN_ERROR</code>
          </p><p>
            不明なエラーが発生しました。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-sqlstate"></a>23.8.7.67 mysql_sqlstate()</h4></div></div></div><a class="indexterm" name="idm139979000719968"></a><p>
        <code class="literal">const char *mysql_sqlstate(MYSQL *mysql)</code>
      </p><h5><a name="idm139979000717408"></a>説明</h5><p>
        最近実行した SQL ステートメントに対する SQLSTATE エラーコードを含む、NULL 終端文字列を返します。エラーコードは 5 つの文字から構成されます。<code class="literal">'00000'</code> は<span class="quote">「<span class="quote">エラーなし</span>」</span>を意味します。値は ANSI SQL と ODBC によって規定されています。可能な値のリストについては、<a class="xref" href="error-handling.html" title="付録 B エラー、エラーコード、および一般的な問題">付録B <i>エラー、エラーコード、および一般的な問題</i></a>を参照してください。
      </p><p>
        <code class="literal">mysql_sqlstate()</code> によって返される SQLSTATE 値は、<code class="literal">mysql_errno()</code> によって返される MySQL 固有のエラー番号とは異なります。たとえば、<span class="command"><strong>mysql</strong></span> クライアントプログラムは、次の形式を使用してエラーを表示します。ここで、<code class="literal">1146</code> は <code class="literal">mysql_errno()</code> 値で、<code class="literal">'42S02'</code> は対応する <code class="literal">mysql_sqlstate()</code> 値です。
      </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>SELECT * FROM no_such_table;</code></strong>
ERROR 1146 (42S02): Table 'test.no_such_table' doesn't exist
</pre><p>
        すべての MySQL エラー番号が SQLSTATE エラーコードにマップされるわけではありません。値 <code class="literal">'HY000'</code> (一般エラー) がマップされていないエラー番号に使われます。
      </p><p>
        <code class="literal">mysql_real_connect()</code> が失敗したあとに <code class="literal">mysql_sqlstate()</code> を呼び出した場合、<code class="literal">mysql_sqlstate()</code> は有益な値を返さないことがあります。たとえば、これは、ホストがサーバーによってブロックされ、SQLSTATE 値がクライアントに送信されることなく、接続が閉じられた場合に発生します。
      </p><h5><a name="idm139979000699936"></a>戻り値</h5><p>
        SQLSTATE エラーコードを含む NULL 終端文字列。
      </p><h5><a name="idm139979000698688"></a>関連項目</h5><p>
         <a class="xref" href="connectors-apis.html#mysql-errno" title="23.8.7.14 mysql_errno()">セクション23.8.7.14「mysql_errno()」</a>、<a class="xref" href="connectors-apis.html#mysql-error" title="23.8.7.15 mysql_error()">セクション23.8.7.15「mysql_error()」</a>、および<a class="xref" href="connectors-apis.html#mysql-stmt-sqlstate" title="23.8.11.27 mysql_stmt_sqlstate()">セクション23.8.11.27「mysql_stmt_sqlstate()」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-ssl-set"></a>23.8.7.68 mysql_ssl_set()</h4></div></div></div><a class="indexterm" name="idm139979000694160"></a><p>
        <code class="literal">my_bool mysql_ssl_set(MYSQL *mysql, const char *key, const char *cert, const char *ca, const char *capath, const char *cipher)</code>
      </p><h5><a name="idm139979000691520"></a>説明</h5><p>
        <code class="literal">mysql_ssl_set()</code> は SSL を使ったセキュアな接続を確立するために使用します。それは <code class="literal">mysql_real_connect()</code> の前に呼び出す必要があります。
      </p><p>
        クライアントライブラリで SSL のサポートが有効にされていないかぎり、<code class="literal">mysql_ssl_set()</code> は何も行いません。
      </p><p>
        <code class="literal">mysql</code> は <code class="literal">mysql_init()</code> から返される接続ハンドラです。ほかのパラメータは次のように指定されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">key</code> は鍵ファイルへのパス名です。
          </p></li><li class="listitem"><p>
            <code class="literal">cert</code> は証明書ファイルへのパス名です。
          </p></li><li class="listitem"><p>
            <code class="literal">ca</code> は認証局ファイルへのパス名です。
          </p></li><li class="listitem"><p>
            <code class="literal">capath</code> は PEM 形式の信頼された SSL CA 証明書を格納するディレクトリのパス名です。
          </p></li><li class="listitem"><p>
            <code class="literal">cipher</code> は SSL 暗号化に使用する許可される暗号のリストです。
          </p></li></ul></div><p>
        未使用の SSL パラメータはすべて <code class="literal">NULL</code> として指定できます。
      </p><h5><a name="idm139979000674432"></a>戻り値</h5><p>
        この関数は常に <code class="literal">0</code> を返します。SSL の設定が正しくない場合、接続を試みると、<code class="literal">mysql_real_connect()</code> はエラーを返します。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stat"></a>23.8.7.69 mysql_stat()</h4></div></div></div><a class="indexterm" name="idm139979000670224"></a><p>
        <code class="literal">const char *mysql_stat(MYSQL *mysql)</code>
      </p><h5><a name="idm139979000667680"></a>説明</h5><p>
        <span class="command"><strong>mysqladmin status</strong></span> コマンドによって提供されているものと似た情報を含む文字列を返します。これには、秒単位での稼働時間と実行中のスレッド、質問、再ロード、および開いているテーブルの数が含まれます。
      </p><h5><a name="idm139979000665360"></a>戻り値</h5><p>
        サーバーのステータスを説明する文字列。エラーが発生した場合は <code class="literal">NULL</code>。
      </p><h5><a name="idm139979000663344"></a>エラー</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_COMMANDS_OUT_OF_SYNC</code>
          </p><p>
            コマンドが正しくない順番で実行されました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_GONE_ERROR</code>
          </p><p>
            MySQL サーバーが存在しなくなりました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_LOST</code>
          </p><p>
            サーバーへの接続がクエリー中に失われました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_UNKNOWN_ERROR</code>
          </p><p>
            不明なエラーが発生しました。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-store-result"></a>23.8.7.70 mysql_store_result()</h4></div></div></div><a class="indexterm" name="idm139979000651952"></a><p>
        <code class="literal">MYSQL_RES *mysql_store_result(MYSQL *mysql)</code>
      </p><h5><a name="idm139979000649392"></a>説明</h5><p>
        <code class="literal">mysql_query()</code> または <code class="literal">mysql_real_query()</code> を呼び出したあとに、結果セットを正常に生成するすべてのステートメント (<code class="literal">SELECT</code>、<code class="literal">SHOW</code>、<code class="literal">DESCRIBE</code>、<code class="literal">EXPLAIN</code>、<code class="literal">CHECK TABLE</code> など) に対して、<code class="literal">mysql_store_result()</code> または <code class="literal">mysql_use_result()</code> を呼び出す必要があります。結果セットの処理を終了したら、<code class="literal">mysql_free_result()</code> も呼び出す必要があります。
      </p><p>
        ほかのステートメントに対して、<code class="literal">mysql_store_result()</code> または <code class="literal">mysql_use_result()</code> を呼び出す必要はありませんが、あらゆるケースで <code class="literal">mysql_store_result()</code> を呼び出しても、それは何の害も及ぼしたり、顕著なパフォーマンスの低下を招いたりすることはありません。<code class="literal">mysql_store_result()</code> がゼロ以外の値を返すかどうかをチェックすることによって、ステートメントに結果セットがあるかどうかを検出できます (これについてはあとで詳しく説明しています)。
      </p><p>
        複数ステートメントのサポートを有効にする場合、<code class="literal">mysql_next_result()</code> を呼び出すループを使用して、それ以上の結果があるかどうかを判断することによって、<code class="literal">mysql_query()</code> または <code class="literal">mysql_real_query()</code> への呼び出しからの結果を取得してください。例については、<a class="xref" href="connectors-apis.html#c-api-multiple-queries" title="23.8.17 複数ステートメント実行の C API サポート">セクション23.8.17「複数ステートメント実行の C API サポート」</a>を参照してください。
      </p><p>
        ステートメントが結果セットを返すかどうかを知る必要がある場合は、<code class="literal">mysql_field_count()</code> を使ってこれをチェックできます。<a class="xref" href="connectors-apis.html#mysql-field-count" title="23.8.7.22 mysql_field_count()">セクション23.8.7.22「mysql_field_count()」</a>を参照してください。
      </p><p>
        <code class="literal">mysql_store_result()</code> はクライアントへのクエリーの結果全体を読み取り、<code class="literal">MYSQL_RES</code> 構造を割り当て、この構造に結果を配置します。
      </p><p>
        ステートメントが結果セットを返さなかった場合 (たとえば、それが <code class="literal">INSERT</code> ステートメントであった場合)、<code class="literal">mysql_store_result()</code> は NULL ポインタを返します。
      </p><p>
        <code class="literal">mysql_store_result()</code> は結果セットの読み取りに失敗した場合も、NULL ポインタを返します。<code class="literal">mysql_error()</code> が空でない文字列を返すか、<code class="literal">mysql_errno()</code> がゼロ以外を返すか、または <code class="literal">mysql_field_count()</code> がゼロを返すかどうかをチェックすることによって、エラーが発生したかどうかをチェックできます。
      </p><p>
        返される行がない場合、空の結果セットが返されます。(空の結果セットは戻り値としての NULL ポインタとは異なります。)
      </p><p>
        <code class="literal">mysql_store_result()</code> を呼び出し、NULL ポインタでない結果が返されたあとに、<code class="literal">mysql_num_rows()</code> を呼び出して、結果セット内にある行数を調べることができます。
      </p><p>
        <code class="literal">mysql_fetch_row()</code> を呼び出して、結果セットから行をフェッチしたり、<code class="literal">mysql_row_seek()</code> と <code class="literal">mysql_row_tell()</code> を呼び出して、結果セット内の現在の行の位置を取得または設定したりできます。
      </p><p>
        <a class="xref" href="connectors-apis.html#null-mysql-store-result" title="23.8.15.1 mysql_query() が成功を返したあとに mysql_store_result() が NULL を返すことがあるのはなぜか">セクション23.8.15.1「mysql_query() が成功を返したあとに mysql_store_result() が NULL を返すことがあるのはなぜか」</a>を参照してください。
      </p><h5><a name="idm139979000607296"></a>戻り値</h5><p>
        結果を含む <code class="literal">MYSQL_RES</code> 結果構造。エラーが発生した場合は <code class="literal">NULL</code> (0)。
      </p><h5><a name="idm139979000604656"></a>エラー</h5><p>
        <code class="literal">mysql_store_result()</code> は成功した場合に、<code class="literal">mysql_error()</code> と <code class="literal">mysql_errno()</code> をリセットします。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_COMMANDS_OUT_OF_SYNC</code>
          </p><p>
            コマンドが正しくない順番で実行されました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_OUT_OF_MEMORY</code>
          </p><p>
            メモリー不足。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_GONE_ERROR</code>
          </p><p>
            MySQL サーバーが存在しなくなりました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_LOST</code>
          </p><p>
            サーバーへの接続がクエリー中に失われました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_UNKNOWN_ERROR</code>
          </p><p>
            不明なエラーが発生しました。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-thread-id"></a>23.8.7.71 mysql_thread_id()</h4></div></div></div><a class="indexterm" name="idm139979000587584"></a><p>
        <code class="literal">unsigned long mysql_thread_id(MYSQL *mysql)</code>
      </p><h5><a name="idm139979000585024"></a>説明</h5><p>
        現在の接続のスレッド ID を返します。この値は、<code class="literal">mysql_kill()</code> への引数として使用して、スレッドを強制終了できます。
      </p><p>
        接続が失われ、<code class="literal">mysql_ping()</code> によって再接続した場合、スレッド ID が変わります。これは、スレッド ID を取得して、あとのためにそれを格納すべきでないことを意味します。必要に応じて、それを取得すべきです。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          スレッド ID が 32 ビットより大きくなった (一部のシステムで発生する可能性があります) 場合、この関数は正常に機能しません。<code class="literal">mysql_thread_id()</code> の問題を避けるには、それを使用しないでください。接続 ID を取得するには、<code class="literal">SELECT CONNECTION_ID()</code> クエリーを実行して、結果を取得します。
        </p></div><h5><a name="idm139979000577504"></a>戻り値</h5><p>
        現在の接続のスレッド ID。
      </p><h5><a name="idm139979000576304"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-use-result"></a>23.8.7.72 mysql_use_result()</h4></div></div></div><a class="indexterm" name="idm139979000574000"></a><p>
        <code class="literal">MYSQL_RES *mysql_use_result(MYSQL *mysql)</code>
      </p><h5><a name="idm139979000571440"></a>説明</h5><p>
        <code class="literal">mysql_query()</code> または <code class="literal">mysql_real_query()</code> を呼び出したあとに、結果セットを正常に生成するすべてのステートメント (<code class="literal">SELECT</code>、<code class="literal">SHOW</code>、<code class="literal">DESCRIBE</code>、<code class="literal">EXPLAIN</code>、<code class="literal">CHECK TABLE</code> など) に対して、<code class="literal">mysql_store_result()</code> または <code class="literal">mysql_use_result()</code> を呼び出す必要があります。結果セットの処理を終了したら、<code class="literal">mysql_free_result()</code> も呼び出す必要があります。
      </p><p>
        <code class="literal">mysql_use_result()</code> は結果セットの取得を開始しますが、<code class="literal">mysql_store_result()</code> のように、実際に結果セットをクライアントに読み込みません。代わりに、<code class="literal">mysql_fetch_row()</code> への呼び出しを行うことによって、各行を個別に取得する必要があります。これは、クエリーの結果を一時テーブルやローカルバッファーに保存することなく、サーバーから直接読み取ります。これは、<code class="literal">mysql_store_result()</code> よりいくぶん高速で、使用するメモリーがはるかに少なくなります。クライアントは現在の行と <code class="literal">max_allowed_packet</code> バイトまで拡大する可能性のある通信バッファーにのみメモリーを割り当てます。
      </p><p>
        一方、クライアント側で、各行について大量の処理を行う場合またはユーザーが <code class="literal">^S</code> (スクロール停止) を入力する可能性のある画面に出力が送信される場合は、<code class="literal">mysql_use_result()</code> を使用しないでください。これはサーバーを拘束し、ほかのスレッドが、データのフェッチ元のテーブルを更新するのを妨げます。
      </p><p>
        <code class="literal">mysql_use_result()</code> を使う場合は、<code class="literal">NULL</code> 値が返されるまで <code class="literal">mysql_fetch_row()</code> を実行する必要があり、そうしないと、次のクエリーの結果セットの一部として、フェッチされていない行が返されます。この実行を忘れると、C API によって、エラー<code class="literal">「コマンドは同期されていません。このコマンドは現在実行できません」</code>が生成されます。
      </p><p>
        <code class="literal">mysql_data_seek()</code>、<code class="literal">mysql_row_seek()</code>、<code class="literal">mysql_row_tell()</code>、<code class="literal">mysql_num_rows()</code>、または <code class="literal">mysql_affected_rows()</code> を <code class="literal">mysql_use_result()</code> から返される結果と一緒に使用できません。また、<code class="literal">mysql_use_result()</code> が終了するまで、ほかのクエリーを発行することもできません。(ただし、すべての行をフェッチしたあとに、<code class="literal">mysql_num_rows()</code> はフェッチした行数を正確に返します。)
      </p><p>
        結果セットの処理を終了したら、<code class="literal">mysql_free_result()</code> を呼び出す必要があります。
      </p><p>
        <code class="literal">libmysqld</code> 組み込みサーバーを使用する場合、<code class="literal">mysql_free_result()</code> が呼び出されるまで、取得される各行によって、メモリーの使用量が徐々に増加するため、メモリーのメリットが本質的に失われます。
      </p><h5><a name="idm139979000533072"></a>戻り値</h5><p>
        <code class="literal">MYSQL_RES</code>結果構造。エラーが発生した場合は <code class="literal">NULL</code>。
      </p><h5><a name="idm139979000530528"></a>エラー</h5><p>
        <code class="literal">mysql_use_result()</code> は成功すると、<code class="literal">mysql_error()</code> と <code class="literal">mysql_errno()</code> をリセットします。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_COMMANDS_OUT_OF_SYNC</code>
          </p><p>
            コマンドが正しくない順番で実行されました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_OUT_OF_MEMORY</code>
          </p><p>
            メモリー不足。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_GONE_ERROR</code>
          </p><p>
            MySQL サーバーが存在しなくなりました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_LOST</code>
          </p><p>
            サーバーへの接続がクエリー中に失われました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_UNKNOWN_ERROR</code>
          </p><p>
            不明なエラーが発生しました。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-warning-count"></a>23.8.7.73 mysql_warning_count()</h4></div></div></div><a class="indexterm" name="idm139979000513520"></a><p>
        <code class="literal">unsigned int mysql_warning_count(MYSQL *mysql)</code>
      </p><h5><a name="idm139979000510960"></a>説明</h5><p>
        前の SQL ステートメントの実行中に生成されたエラー、警告、および注意事項の数を返します。
      </p><h5><a name="idm139979000508736"></a>戻り値</h5><p>
        警告カウント。
      </p><h5><a name="idm139979000507568"></a>エラー</h5><p>
        なし。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-prepared-statements"></a>23.8.8 C API プリペアドステートメント</h3></div></div></div><a class="indexterm" name="idm139979000505040"></a><p>
      MySQL クライアント/サーバープロトコルはプリペアドステートメントの使用を規定します。この機能は、<code class="literal">mysql_stmt_init()</code> 初期化関数によって返される <code class="literal">MYSQL_STMT</code> ステートメントハンドラデータ構造を使用します。プリペアド実行はステートメントを複数回実行するための効率的な方法です。ステートメントはまずその実行を準備するために解析されます。その後、初期化関数によって返されるステートメントハンドルを使用して、1 回または複数回実行されます。
    </p><p>
      プリペアド実行は、主にクエリーが 1 回しか解析されないため、複数回実行されるステートメントの場合に、直接実行より高速になります。直接実行の場合、クエリーは実行されるたびに解析されます。さらに、プリペアド実行は、プリペアドステートメントの実行ごとに、パラメータにデータを送信する必要があるだけであるため、ネットワークトラフィックの削減も実現できます。
    </p><p>
      プリペアドステートメントは、状況によっては、パフォーマンスの向上をもたらさない場合があります。最善の結果を得るため、プリペアドステートメントと非プリペアドステートメントの両方でアプリケーションをテストし、最高のパフォーマンスを発揮するものを選択してください。
    </p><p>
      プリペアドステートメントのもう 1 つの利点は、それがクライアントとサーバー間のデータ転送の効率を向上するバイナリプロトコルを使用することです。
    </p><p>
      プリペアドステートメントとして使用できる SQL ステートメントのリストについては、<a class="xref" href="sql-syntax.html#sql-syntax-prepared-statements" title="13.5 準備済みステートメントのための SQL 構文">セクション13.5「準備済みステートメントのための SQL 構文」</a>を参照してください。
    </p><p>
      プリペアドステートメントによって参照されているテーブルやビューのメタデータの変更が検出され、それが次に実行されるときに、ステートメントが自動再準備されます。詳細については、<a class="xref" href="optimization.html#statement-caching" title="8.9.4 プリペアドステートメントおよびストアドプログラムのキャッシュ">セクション8.9.4「プリペアドステートメントおよびストアドプログラムのキャッシュ」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-prepared-statement-data-structures"></a>23.8.9 C API プリペアドステートメントデータ構造</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="connectors-apis.html#c-api-prepared-statement-type-codes">23.8.9.1 C API プリペアドステートメントタイプコード</a></span></dt><dt><span class="section"><a href="connectors-apis.html#c-api-prepared-statement-type-conversions">23.8.9.2 C API プリペアドステートメント型変換</a></span></dt></dl></div><p>
      プリペアドステートメントはいくつかのデータ構造を使用します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ステートメントハンドルを取得するには、<code class="literal">MYSQL</code> 接続ハンドラを <code class="literal">mysql_stmt_init()</code> に渡します。これは、<code class="literal">MYSQL_STMT</code> データ構造へポインタを返します。この構造は、ステートメントのその後の処理に使用されます。ステートメントの準備を指定するには、<code class="literal">MYSQL_STMT</code> ポインタとステートメント文字列を <code class="literal">mysql_stmt_prepare()</code> に渡します。
        </p></li><li class="listitem"><p>
          プリペアドステートメントの入力パラメータを提供するには、<code class="literal">MYSQL_BIND</code> 構造を設定して、それらを <code class="literal">mysql_stmt_bind_param()</code> に渡します。出力カラム値を受け取るには、<code class="literal">MYSQL_BIND</code> 構造を設定し、それらを <code class="literal">mysql_stmt_bind_result()</code> に渡します。
        </p></li><li class="listitem"><p>
          <code class="literal">MYSQL_TIME</code> 構造は両方向で時間データを転送するために使われます。
        </p></li></ul></div><p>
      次の説明では、プリペアドステートメントのデータ型を詳しく示します。それらの使用方法の例については、<a class="xref" href="connectors-apis.html#mysql-stmt-execute" title="23.8.11.10 mysql_stmt_execute()">セクション23.8.11.10「mysql_stmt_execute()」</a>および<a class="xref" href="connectors-apis.html#mysql-stmt-fetch" title="23.8.11.11 mysql_stmt_fetch()">セクション23.8.11.11「mysql_stmt_fetch()」</a>を参照してください。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="indexterm" name="idm139979000477312"></a> <code class="literal">MYSQL_STMT</code>
        </p><p>
          この構造は、プリペアドステートメントのハンドルです。ハンドルを作成するには、<code class="literal">mysql_stmt_init()</code> を呼び出します。これは、<code class="literal">MYSQL_STMT</code> へのポインタを返します。ハンドルは、<code class="literal">mysql_stmt_close()</code> でクローズする (その時点でハンドルが無効になります) まで、その後のすべてのステートメントの操作に使われます。
        </p><p>
          <code class="literal">MYSQL_STMT</code> 構造にはアプリケーションで使用することを意図されたメンバーがありません。アプリケーションでは、<code class="literal">MYSQL_STMT</code> 構造をコピーしようとしないでください。そのようなコピーが使用可能である保証はありません。
        </p><p>
          複数のステートメントハンドルを単一の接続に関連付けることができます。ハンドル数の制限は、使用可能なシステムリソースによって異なります。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979000467472"></a> <code class="literal">MYSQL_BIND</code>
        </p><p>
          この構造は、ステートメントの入力 (サーバーに送信されるデータ値) と出力 (サーバーから返される結果値) の両方に使用されます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              入力の場合は、<code class="literal">mysql_stmt_bind_param()</code> で <code class="literal">MYSQL_BIND</code> 構造を使用して、パラメータデータ値を <code class="literal">mysql_stmt_execute()</code> で使用するために、バッファーにバインドします。
            </p></li><li class="listitem"><p>
              出力の場合は、<code class="literal">mysql_stmt_bind_result()</code> で <code class="literal">MYSQL_BIND</code> 構造を使用して、<code class="literal">mysql_stmt_fetch()</code> によって行のフェッチで使用するために、バッファーを結果セットカラムにバインドします。
            </p></li></ul></div><p>
          <code class="literal">MYSQL_BIND</code> 構造を使用するには、その内容をゼロにして初期化してから、そのメンバーを適切に設定します。たとえば、3 つの <code class="literal">MYSQL_BIND</code> 構造の配列を宣言し、初期化するには、このコードを使用します。
        </p><pre class="programlisting">
MYSQL_BIND bind[3];
memset(bind, 0, sizeof(bind));
</pre><p>
          <code class="literal">MYSQL_BIND</code> 構造には、アプリケーションプログラムによって使用するための次のメンバーが含まれます。いくつかのメンバーに対して使用する方法は、構造が入力に使われるか、出力に使われるかによって異なります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">enum enum_field_types buffer_type</code>
            </p><p>
              バッファーの種類。このメンバーは、ステートメントパラメータまたは結果セットカラムにバインドされている C 言語変数のデータ型を示します。入力の場合、<code class="literal">buffer_type</code> はサーバーに送信される値を格納する変数の型を示します。出力の場合、それはサーバーから受け取った値を格納すべき変数の型を示します。許可される <code class="literal">buffer_type</code> 値については、<a class="xref" href="connectors-apis.html#c-api-prepared-statement-type-codes" title="23.8.9.1 C API プリペアドステートメントタイプコード">セクション23.8.9.1「C API プリペアドステートメントタイプコード」</a>を参照してください。
            </p></li><li class="listitem"><p>
              <code class="literal">void *buffer</code>
            </p><p>
              データの転送に使用されるバッファーへのポインタ。これは C 言語変数のアドレスです。
            </p><p>
              入力の場合、<code class="literal">buffer</code> はステートメントパラメータのデータ値を格納する変数へのポインタです。<code class="literal">mysql_stmt_execute()</code> を呼び出すと、MySQL は、ステートメント内の対応するパラメータマーカー (ステートメント文字列内に <code class="literal">?</code> で指定される) の代わりに変数に格納されている値を使用します。
            </p><p>
              出力の場合、<code class="literal">buffer</code> は結果セットカラム値を返すための変数へのポインタです。<code class="literal">mysql_stmt_fetch()</code> を呼び出すと、MySQL は結果セットの現在の行からのカラム値をこの変数に保存します。呼び出しが戻ると、値にアクセスできます。
            </p><p>
              MySQL が、クライアント側の C 言語値とサーバー側の SQL 値間の型変換を実行する必要性を最小にするには、対応する SQL 値の型に似た型を持つ C 変数を使用します。
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                  数値データ型の場合、<code class="literal">buffer</code> は正しい数値 C 型の変数を指すべきです。整数変数 (これは単一バイト値の場合に <code class="literal">char</code> または大きな値の場合に整数型を指定できます) の場合、後述する <code class="literal">is_unsigned</code> メンバーを設定して、変数が <code class="literal">unsigned</code> 属性を持つかどうかも指定してください。
                </p></li><li class="listitem"><p>
                  文字 (非バイナリ) およびバイナリ文字列データ型の場合、<code class="literal">buffer</code> は文字バッファーを指すようにしてください。
                </p></li><li class="listitem"><p>
                  日付および時間データ型の場合、<code class="literal">buffer</code> は <code class="literal">MYSQL_TIME</code> 構造を指すようにしてください。
                </p></li></ul></div><p>
              C 型と SQL 型間のマッピングに関するガイドラインと型変換に関する注意事項については、<a class="xref" href="connectors-apis.html#c-api-prepared-statement-type-codes" title="23.8.9.1 C API プリペアドステートメントタイプコード">セクション23.8.9.1「C API プリペアドステートメントタイプコード」</a>および<a class="xref" href="connectors-apis.html#c-api-prepared-statement-type-conversions" title="23.8.9.2 C API プリペアドステートメント型変換">セクション23.8.9.2「C API プリペアドステートメント型変換」</a>を参照してください。
            </p></li><li class="listitem"><p>
              <code class="literal">unsigned long buffer_length</code>
            </p><p>
              <code class="literal">*buffer</code> のバイト単位での実際のサイズ。これはバッファーに格納できるデータの最大量を示します。文字およびバイナリ C データの場合、<code class="literal">buffer_length</code> 値は、入力値を指定する <code class="literal">mysql_stmt_bind_param()</code> と一緒に使用したときに、<code class="literal">*buffer</code> の長さ、または <code class="literal">mysql_stmt_bind_result()</code> と一緒に使用したときに、バッファーにフェッチできる出力データバイトの最大数を指定します。
            </p></li><li class="listitem"><p>
              <code class="literal">unsigned long *length</code>
            </p><p>
              <code class="literal">*buffer</code> に格納されたデータの実際のバイト数を示す <code class="literal">unsigned long</code> 変数へのポインタ。<code class="literal">length</code> は文字またはバイナリ C データに対して使われます。
            </p><p>
              入力パラメータデータバインディングの場合、<code class="literal">*buffer</code> に格納されるパラメータ値の実際の長さを示すように <code class="literal">*length</code> を設定します。これは <code class="literal">mysql_stmt_execute()</code> で使用されます。
            </p><p>
              出力値バインディングの場合、<code class="literal">mysql_stmt_fetch()</code> を呼び出したときに、MySQL によって <code class="literal">*length</code> が設定されます。<code class="literal">mysql_stmt_fetch()</code> の戻り値によって、長さの解釈方法が決まります。
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                  戻り値が 0 の場合、<code class="literal">*length</code> はパラメータ値の実際の長さを示します。
                </p></li><li class="listitem"><p>
                  戻り値が <code class="literal">MYSQL_DATA_TRUNCATED</code> の場合、<code class="literal">*length</code> はパラメータ値の切り捨てされていない長さを示します。この場合、<code class="literal">*length</code> と <code class="literal">buffer_length</code> の最小は、値の実際の長さを示します。
                </p></li></ul></div><p>
              <code class="literal">buffer_type</code> 値によって、データ値の長さが決まるため、<code class="literal">length</code> は数値および時間データ型に対しては無視されます。
            </p><p>
              戻り値の長さをフェッチする前に判断する必要がある場合は、いくつかの戦略について、<a class="xref" href="connectors-apis.html#mysql-stmt-fetch" title="23.8.11.11 mysql_stmt_fetch()">セクション23.8.11.11「mysql_stmt_fetch()」</a>を参照してください。
            </p></li><li class="listitem"><p>
              <code class="literal">my_bool *is_null</code>
            </p><p>
              このメンバーは、値が <code class="literal">NULL</code> の場合に true で、それが <code class="literal">NULL</code> でない場合に false である <code class="literal">my_bool</code> 変数を指示します。入力では、<code class="literal">*is_null</code> を true に設定して、ステートメントパラメータとして <code class="literal">NULL</code> 値を渡していることを示します。
            </p><p>
              <code class="literal">is_null</code> はブール型スカラーへの<span class="emphasis"><em>ポインタ</em></span>で、<code class="literal">NULL</code> 値の指定方法の柔軟性を提供します。
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                  データ値が常に <code class="literal">NULL</code> である場合、カラムのバインド時に、<code class="literal">buffer_type</code> 値として <code class="literal">MYSQL_TYPE_NULL</code> を使用します。<code class="literal">is_null</code> を含むほかの <code class="literal">MYSQL_BIND</code> メンバーは重要ではありません。
                </p></li><li class="listitem"><p>
                  データ値が常に <code class="literal">NOT NULL</code> である場合は、<code class="literal">is_null = (my_bool*) 0</code> を設定し、バインドする変数に適切にほかのメンバーを設定します。
                </p></li><li class="listitem"><p>
                  ほかのすべての場合に、ほかのメンバーを適切に設定し、<code class="literal">is_null</code> に <code class="literal">my_bool</code> 変数のアドレスを設定します。実行と実行の間に、その変数の値を true または false に適切に設定して、対応するデータ値がそれぞれ <code class="literal">NULL</code> であるか、<code class="literal">NOT NULL</code> であるかを示します。
                </p></li></ul></div><p>
              出力の場合、行をフェッチすると、MySQL は、ステートメントから返された結果セットカラム値が <code class="literal">NULL</code> であるかどうかに従って、<code class="literal">is_null</code> で指示されている値を true または false に設定します。
            </p></li><li class="listitem"><p>
              <code class="literal">my_bool is_unsigned</code>
            </p><p>
              このメンバーは、<code class="literal">unsigned</code> (<code class="literal">char</code>、<code class="literal">short int</code>、<code class="literal">int</code>、<code class="literal">long long int</code>) を指定できるデータ型を持つ C 変数に適用されます。<code class="literal">buffer</code> によって指示されている変数が <code class="literal">unsigned</code> の場合は、<code class="literal">is_unsigned</code> を true に設定し、それ以外の場合は false に設定します。たとえば、<code class="literal">signed char</code> 変数を <code class="literal">buffer</code> にバインドする場合、<code class="literal">MYSQL_TYPE_TINY</code> のタイプコードを指定し、<code class="literal">is_unsigned</code> を false に設定します。代わりに <code class="literal">unsigned char</code> をバインドする場合、タイプコードは同じですが、<code class="literal">is_unsigned</code> を true にしてください。(<code class="literal">char</code> の場合、それは符号付きか符号なしか定義されないため、<code class="literal">signed char</code> や <code class="literal">unsigned char</code> を使用して、符号の有無を明示することをお勧めします。)
            </p><p>
              <code class="literal">is_unsigned</code> はクライアント側の C 言語変数のみに適用されます。それはサーバー側の対応する SQL 値の符号の有無については何も示しません。たとえば、<code class="literal">int</code> 変数を使用して、<code class="literal">BIGINT UNSIGNED</code> カラムの値を提供する場合、<code class="literal">int</code> は符号付きの型であるため、<code class="literal">is_unsigned</code> は false にすべきです。<code class="literal">unsigned int</code> 変数を使用して、<code class="literal">BIGINT</code> カラムの値を提供する場合、<code class="literal">unsigned int</code> は符号なしの型であるため、<code class="literal">is_unsigned</code> を true にすべきです。MySQL は符号付きの値と符号なしの値で、両方向で正しい変換を実行しますが、切り捨てが発生した場合、警告が生成されます。
            </p></li><li class="listitem"><p>
              <code class="literal">my_bool *error</code>
            </p><p>
              出力の場合、このメンバーを <code class="literal">my_bool</code> 変数を指すように設定し、行のフェッチ操作のあとに、そこに格納されるパラメータの切り捨て情報を保持します。切り捨てのレポートを有効にすると、<code class="literal">mysql_stmt_fetch()</code> は <code class="literal">MYSQL_DATA_TRUNCATED</code> を返し、切り捨てが発生したパラメータの <code class="literal">MYSQL_BIND</code> 構造で、<code class="literal">*error</code> が true になります。切り捨ては、符号または桁落ち、または文字列が長すぎてカラムに収まらなかったことを示します。切り捨てのレポートはデフォルトで有効ですが、<code class="literal">MYSQL_REPORT_DATA_TRUNCATION</code> オプションを使用して <code class="literal">mysql_options()</code> を呼び出すことによって制御できます。
            </p></li></ul></div></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979000342784"></a> <code class="literal">MYSQL_TIME</code>
        </p><p>
          この構造は、<code class="literal">DATE</code>、<code class="literal">TIME</code>、<code class="literal">DATETIME</code>、および <code class="literal">TIMESTAMP</code> データを直接サーバーと送受信するために使われます。<code class="literal">buffer</code> メンバーを <code class="literal">MYSQL_TIME</code> 構造を指すように設定し、<code class="literal">MYSQL_BIND</code> 構造の <code class="literal">buffer_type</code> メンバーをいずれかの時間型 (<code class="literal">MYSQL_TYPE_TIME</code>、<code class="literal">MYSQL_TYPE_DATE</code>、<code class="literal">MYSQL_TYPE_DATETIME</code>、<code class="literal">MYSQL_TYPE_TIMESTAMP</code>) に設定します。
        </p><p>
          <code class="literal">MYSQL_TIME</code> 構造には、次の表に示すメンバーが格納されます。
        </p><div class="informaltable"><table summary="この表は、MYSQL_TIME 構造のメンバーを一覧表示し、各メンバーについて説明します。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">メンバー</th><th scope="col">説明</th></tr></thead><tbody><tr><td scope="row"><code class="literal">unsigned int year</code></td><td>年</td></tr><tr><td scope="row"><code class="literal">unsigned int month</code></td><td>月</td></tr><tr><td scope="row"><code class="literal">unsigned int day</code></td><td>日</td></tr><tr><td scope="row"><code class="literal">unsigned int hour</code></td><td>時間</td></tr><tr><td scope="row"><code class="literal">unsigned int minute</code></td><td>分</td></tr><tr><td scope="row"><code class="literal">unsigned int second</code></td><td>秒</td></tr><tr><td scope="row"><code class="literal">my_bool neg</code></td><td>時間が負であるかどうかを示すブールフラグ</td></tr><tr><td scope="row"><code class="literal">unsigned long second_part</code></td><td>ミリ秒単位での秒の小数部 (MySQL 5.6.4 より前では未使用)</td></tr></tbody></table></div><p>
          時間値の指定された型に適用する <code class="literal">MYSQL_TIME</code> 構造の部分のみが使われます。<code class="literal">year</code>、<code class="literal">month</code>、および <code class="literal">day</code> 要素は、<code class="literal">DATE</code>、<code class="literal">DATETIME</code>、および <code class="literal">TIMESTAMP</code> 値に使用されます。<code class="literal">hour</code>、<code class="literal">minute</code>、および <code class="literal">second</code> 要素は、<code class="literal">TIME</code>、<code class="literal">DATETIME</code>、および <code class="literal">TIMESTAMP</code> 値に使用されます。<a class="xref" href="connectors-apis.html#c-api-prepared-statement-date-handling" title="23.8.19 C API プリペアドステートメントの日時値の処理">セクション23.8.19「C API プリペアドステートメントの日時値の処理」</a>を参照してください。
        </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="c-api-prepared-statement-type-codes"></a>23.8.9.1 C API プリペアドステートメントタイプコード</h4></div></div></div><a class="indexterm" name="idm139979000295952"></a><a class="indexterm" name="idm139979000293712"></a><p>
        <code class="literal">MYSQL_BIND</code> 構造の <code class="literal">buffer_type</code> メンバーは、ステートメントパラメータまたは結果セットカラムにバインドされている C 言語変数のデータ型を示します。入力の場合、<code class="literal">buffer_type</code> はサーバーに送信される値を格納する変数の型を示します。出力の場合、それはサーバーから受け取った値を格納すべき変数の型を示します。
      </p><p>
        次の表に、サーバーに送信される入力値に対して、<code class="literal">MYSQL_BIND</code> 構造の <code class="literal">buffer_type</code> メンバーに許可される値を示します。表に、使用できる C 変数型、対応するタイプコード、および提供された値を変換なしで使用できる SQL データ型を示します。バインドする C 言語変数のデータ型に従って、<code class="literal">buffer_type</code> 値を選択します。整数型の場合、<code class="literal">is_unsigned</code> メンバーも設定して、変数が符号付きか符号なしかを示してください。
      </p><div class="informaltable"><table summary="この表は、C 型入力変数、対応する buffer_type 値、および提供された値を変換なしで使用できる SQL データ型を一覧表示しています。" border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">入力変数 C 型</th><th scope="col"><code class="literal">buffer_type</code> 値</th><th scope="col">宛先の値の SQL 型</th></tr></thead><tbody><tr><td scope="row"><code class="literal">signed char</code></td><td><code class="literal">MYSQL_TYPE_TINY</code></td><td><code class="literal">TINYINT</code></td></tr><tr><td scope="row"><code class="literal">short int</code></td><td><code class="literal">MYSQL_TYPE_SHORT</code></td><td><code class="literal">SMALLINT</code></td></tr><tr><td scope="row"><code class="literal">int</code></td><td><code class="literal">MYSQL_TYPE_LONG</code></td><td><code class="literal">INT</code></td></tr><tr><td scope="row"><code class="literal">long long int</code></td><td><code class="literal">MYSQL_TYPE_LONGLONG</code></td><td><code class="literal">BIGINT</code></td></tr><tr><td scope="row"><code class="literal">float</code></td><td><code class="literal">MYSQL_TYPE_FLOAT</code></td><td><code class="literal">FLOAT</code></td></tr><tr><td scope="row"><code class="literal">double</code></td><td><code class="literal">MYSQL_TYPE_DOUBLE</code></td><td><code class="literal">DOUBLE</code></td></tr><tr><td scope="row"><code class="literal">MYSQL_TIME</code></td><td><code class="literal">MYSQL_TYPE_TIME</code></td><td><code class="literal">TIME</code></td></tr><tr><td scope="row"><code class="literal">MYSQL_TIME</code></td><td><code class="literal">MYSQL_TYPE_DATE</code></td><td><code class="literal">DATE</code></td></tr><tr><td scope="row"><code class="literal">MYSQL_TIME</code></td><td><code class="literal">MYSQL_TYPE_DATETIME</code></td><td><code class="literal">DATETIME</code></td></tr><tr><td scope="row"><code class="literal">MYSQL_TIME</code></td><td><code class="literal">MYSQL_TYPE_TIMESTAMP</code></td><td><code class="literal">TIMESTAMP</code></td></tr><tr><td scope="row"><code class="literal">char[]</code></td><td><code class="literal">MYSQL_TYPE_STRING</code></td><td><code class="literal">TEXT</code>、<code class="literal">CHAR</code>、<code class="literal">VARCHAR</code></td></tr><tr><td scope="row"><code class="literal">char[]</code></td><td><code class="literal">MYSQL_TYPE_BLOB</code></td><td><code class="literal">BLOB</code>、<code class="literal">BINARY</code>、<code class="literal">VARBINARY</code></td></tr><tr><td scope="row"> </td><td><code class="literal">MYSQL_TYPE_NULL</code></td><td><code class="literal">NULL</code></td></tr></tbody></table></div><p>
        <a class="xref" href="connectors-apis.html#c-api-prepared-statement-data-structures" title="23.8.9 C API プリペアドステートメントデータ構造">セクション23.8.9「C API プリペアドステートメントデータ構造」</a>で、<code class="literal">is_null</code> メンバーの説明に示されているように、<code class="literal">MYSQL_TYPE_NULL</code> を使用します。
      </p><p>
        入力文字列データの場合、値が文字 (非バイナリ) であるか、バイナリ文字列であるかによって、<code class="literal">MYSQL_TYPE_STRING</code> または <code class="literal">MYSQL_TYPE_BLOB</code> を使用します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">MYSQL_TYPE_STRING</code> は文字入力の文字列データを示します。この値は、<code class="literal">character_set_client</code> システム変数によって示される文字セットに含まれるものとみなされます。サーバーが値を異なる文字セットでカラムに格納する場合、値をその文字セットに変換します。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_TYPE_BLOB</code> はバイナリ入力文字列データを示します。この値は <code class="literal">binary</code> 文字セットを持つものとして扱われます。つまり、それは、バイト文字列として扱われ、変換は行われません。
          </p></li></ul></div><p>
        次の表に、サーバーから受信される出力値の <code class="literal">MYSQL_BIND</code> 構造の <code class="literal">buffer_type</code> メンバーの許可される値を示します。表には、受信された値の SQL 型、そのような値の結果セットメタデータに含まれる対応するタイプコード、および変換なしで SQL 値を受信するために <code class="literal">MYSQL_BIND</code> 構造にバインドする推奨される C 言語データ型を示します。バインドする C 言語変数のデータ型に従って、<code class="literal">buffer_type</code> 値を選択します。整数型の場合、<code class="literal">is_unsigned</code> メンバーも設定して、変数が符号付きか符号なしかを示してください。
      </p><div class="informaltable"><table summary="この表は受信した値の SQL 型、対応する buffer_type 値、および推奨される C データ型出力変数を示します。" border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">受信した値の SQL 型</th><th scope="col"><code class="literal">buffer_type</code> 値</th><th scope="col">出力変数 C 型</th></tr></thead><tbody><tr><td scope="row"><code class="literal">TINYINT</code></td><td><code class="literal">MYSQL_TYPE_TINY</code></td><td><code class="literal">signed char</code></td></tr><tr><td scope="row"><code class="literal">SMALLINT</code></td><td><code class="literal">MYSQL_TYPE_SHORT</code></td><td><code class="literal">short int</code></td></tr><tr><td scope="row"><code class="literal">MEDIUMINT</code></td><td><code class="literal">MYSQL_TYPE_INT24</code></td><td><code class="literal">int</code></td></tr><tr><td scope="row"><code class="literal">INT</code></td><td><code class="literal">MYSQL_TYPE_LONG</code></td><td><code class="literal">int</code></td></tr><tr><td scope="row"><code class="literal">BIGINT</code></td><td><code class="literal">MYSQL_TYPE_LONGLONG</code></td><td><code class="literal">long long int</code></td></tr><tr><td scope="row"><code class="literal">FLOAT</code></td><td><code class="literal">MYSQL_TYPE_FLOAT</code></td><td><code class="literal">float</code></td></tr><tr><td scope="row"><code class="literal">DOUBLE</code></td><td><code class="literal">MYSQL_TYPE_DOUBLE</code></td><td><code class="literal">double</code></td></tr><tr><td scope="row"><code class="literal">DECIMAL</code></td><td><code class="literal">MYSQL_TYPE_NEWDECIMAL</code></td><td><code class="literal">char[]</code></td></tr><tr><td scope="row"><code class="literal">YEAR</code></td><td><code class="literal">MYSQL_TYPE_SHORT</code></td><td><code class="literal">short int</code></td></tr><tr><td scope="row"><code class="literal">TIME</code></td><td><code class="literal">MYSQL_TYPE_TIME</code></td><td><code class="literal">MYSQL_TIME</code></td></tr><tr><td scope="row"><code class="literal">DATE</code></td><td><code class="literal">MYSQL_TYPE_DATE</code></td><td><code class="literal">MYSQL_TIME</code></td></tr><tr><td scope="row"><code class="literal">DATETIME</code></td><td><code class="literal">MYSQL_TYPE_DATETIME</code></td><td><code class="literal">MYSQL_TIME</code></td></tr><tr><td scope="row"><code class="literal">TIMESTAMP</code></td><td><code class="literal">MYSQL_TYPE_TIMESTAMP</code></td><td><code class="literal">MYSQL_TIME</code></td></tr><tr><td scope="row"><code class="literal">CHAR</code>、<code class="literal">BINARY</code></td><td><code class="literal">MYSQL_TYPE_STRING</code></td><td><code class="literal">char[]</code></td></tr><tr><td scope="row"><code class="literal">VARCHAR</code>、<code class="literal">VARBINARY</code></td><td><code class="literal">MYSQL_TYPE_VAR_STRING</code></td><td><code class="literal">char[]</code></td></tr><tr><td scope="row"><code class="literal">TINYBLOB</code>、<code class="literal">TINYTEXT</code></td><td><code class="literal">MYSQL_TYPE_TINY_BLOB</code></td><td><code class="literal">char[]</code></td></tr><tr><td scope="row"><code class="literal">BLOB</code>、<code class="literal">TEXT</code></td><td><code class="literal">MYSQL_TYPE_BLOB</code></td><td><code class="literal">char[]</code></td></tr><tr><td scope="row"><code class="literal">MEDIUMBLOB</code>、<code class="literal">MEDIUMTEXT</code></td><td><code class="literal">MYSQL_TYPE_MEDIUM_BLOB</code></td><td><code class="literal">char[]</code></td></tr><tr><td scope="row"><code class="literal">LONGBLOB</code>、<code class="literal">LONGTEXT</code></td><td><code class="literal">MYSQL_TYPE_LONG_BLOB</code></td><td><code class="literal">char[]</code></td></tr><tr><td scope="row"><code class="literal">BIT</code></td><td><code class="literal">MYSQL_TYPE_BIT</code></td><td><code class="literal">char[]</code></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="c-api-prepared-statement-type-conversions"></a>23.8.9.2 C API プリペアドステートメント型変換</h4></div></div></div><a class="indexterm" name="idm139979000140896"></a><a class="indexterm" name="idm139979000138720"></a><p>
        プリペアドステートメントは、クライアント側で、サーバー側の SQL 値に対応する C 言語変数を使用して、クライアントとサーバー間でデータを転送します。クライアント側の C 変数型とサーバー側の対応する SQL 値型間に不一致がある場合、MySQL は両方向で暗黙的な型変換を実行します。
      </p><p>
        MySQL はサーバー側の SQL 値に対するタイプコードを認識しています。<code class="literal">MYSQL_BIND</code> 構造内の <code class="literal">buffer_type</code> 値は、クライアント側の値を保持する C 変数のタイプコードを示します。2 つのコードはまとめて、実行する必要がある変換がある場合に、それを MySQL に伝えます。次にいくつかの例を示します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">int</code> 変数で <code class="literal">MYSQL_TYPE_LONG</code> を使用して、<code class="literal">FLOAT</code> カラムに格納される整数値をサーバーに渡した場合、MySQL はその値を格納する前に浮動小数点形式に変換します。
          </p></li><li class="listitem"><p>
            SQL <code class="literal">MEDIUMINT</code> カラム値をフェッチするが、<code class="literal">MYSQL_TYPE_LONGLONG</code> の <code class="literal">buffer_type</code> 値を指定し、宛先バッファーとして、型 <code class="literal">long long int</code> の C 変数を使用した場合、MySQL は、<code class="literal">long long int</code> (8 バイト変数) に格納するために、<code class="literal">MEDIUMINT</code> 値 (これは 8 バイト未満を必要とする) を変換します。
          </p></li><li class="listitem"><p>
            255 の値を含む数値カラムを <code class="literal">char[4]</code> 文字配列にフェッチし、<code class="literal">MYSQL_TYPE_STRING</code> の <code class="literal">buffer_type</code> 値を指定した場合、配列内の結果の値は 4 バイト文字列 <code class="literal">'255\0'</code> になります。
          </p></li><li class="listitem"><p>
            MySQL は元のサーバー側値の文字列表現として <code class="literal">DECIMAL</code> 値を返します。そのため、対応する C 型は <code class="literal">char[]</code> です。たとえば、<code class="literal">12.345</code> はクライアントに <code class="literal">'12.345'</code> として返されます。<code class="literal">MYSQL_TYPE_NEWDECIMAL</code> を指定し、文字列バッファーを <code class="literal">MYSQL_BIND</code> 構造にバインドすると、<code class="literal">mysql_stmt_fetch()</code> は変換なしで値を文字列としてバッファーに格納します。代わりに、数値変数とタイプコードを指定した場合、<code class="literal">mysql_stmt_fetch()</code> は文字列形式 <code class="literal">DECIMAL</code> 値を数値形式に変換します。
          </p></li><li class="listitem"><p>
            <code class="literal">MYSQL_TYPE_BIT</code> タイプコードでは、<code class="literal">BIT</code> 値が文字列バッファーに返されます。そのため、対応する C 型は <code class="literal">char[]</code> です。値はクライアント側での解釈を必要とするビット文字列を表します。扱いやすい型として値を返すため、次のいずれかの式の型を使用して、値を整数にキャストさせることができます。
          </p><pre class="programlisting">
SELECT bit_col + 0 FROM t
SELECT CAST(bit_col AS UNSIGNED) FROM t
</pre><p>
            値を取得するには、値を保持するために十分な大きさの整数変数をバインドし、適切な対応する整数タイプコードを指定します。
          </p></li></ul></div><p>
        カラム値のフェッチに使用される <code class="literal">MYSQL_BIND</code> 構造に変数をバインドする前に、結果セットの各カラムのタイプコードをチェックできます。これは、型変換を避けるために使用するもっともよい変数型を判断する場合、望ましいと考えられます。タイプコードを取得するには、<code class="literal">mysql_stmt_execute()</code> によって、プリペアドステートメントを実行したあとに、<code class="literal">mysql_stmt_result_metadata()</code> を呼び出します。メタデータは、<a class="xref" href="connectors-apis.html#mysql-stmt-result-metadata" title="23.8.11.23 mysql_stmt_result_metadata()">セクション23.8.11.23「mysql_stmt_result_metadata()」</a>および<a class="xref" href="connectors-apis.html#c-api-data-structures" title="23.8.5 C API データ構造">セクション23.8.5「C API データ構造」</a>で説明しているように、結果セットのタイプコードへのアクセスを提供します。
      </p><p>
        サーバーから返される結果セット内の出力文字列にバイナリデータが含まれているか、非バイナリデータが含まれているかを確認するには、結果セットメタデータの <code class="literal">charsetnr</code> 値が 63 であるかどうかをチェックします (<a class="xref" href="connectors-apis.html#c-api-data-structures" title="23.8.5 C API データ構造">セクション23.8.5「C API データ構造」</a>を参照してください)。その場合、文字セットは <code class="literal">binary</code> で、これは非バイナリデータではなく、バイナリを示します。これにより、<code class="literal">BINARY</code> と <code class="literal">CHAR</code>、<code class="literal">VARBINARY</code> と <code class="literal">VARCHAR</code>、および <code class="literal">BLOB</code> 型と <code class="literal">TEXT</code> 型を区別できます。
      </p><p>
        <code class="literal">MYSQL_FIELD</code> カラムメタデータ構造の <code class="literal">max_length</code> メンバーを設定させる場合 (<code class="literal">mysql_stmt_attr_set()</code> を呼び出すことによって)、結果セットの <code class="literal">max_length</code> 値が、バイナリ表現の長さではなく、結果値の最長の文字列表現の長さを示すことに注意してください。つまり、<code class="literal">max_length</code> は必ずしも、プリペアドステートメントに使用されるバイナリプロトコルによって値をフェッチするために必要なバッファーのサイズに対応していません。値をフェッチする変数の型に従って、バッファーのサイズを選択します。たとえば、値 -128 を格納する <code class="literal">TINYINT</code> カラムは、4 の <code class="literal">max_length</code> 値を持つ可能性があります。ただし、<code class="literal">TINYINT</code> 値のバイナリ表現は、ストレージに 1 バイトしか必要としないため、値を格納する <code class="literal">signed char</code> 変数を提供し、値が符号付きであることを示す <code class="literal">is_unsigned</code> を設定できます。
      </p><p>
        プリペアドステートメントによって参照されているテーブルやビューのメタデータの変更が検出され、それが次に実行されるときに、ステートメントが自動再準備されます。詳細については、<a class="xref" href="optimization.html#statement-caching" title="8.9.4 プリペアドステートメントおよびストアドプログラムのキャッシュ">セクション8.9.4「プリペアドステートメントおよびストアドプログラムのキャッシュ」</a>を参照してください。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-prepared-statement-function-overview"></a>23.8.10 C API プリペアドステートメント関数の概要</h3></div></div></div><a class="indexterm" name="idm139979000076720"></a><a class="indexterm" name="idm139979000074576"></a><p>
      プリペアドステートメントの処理に使用可能な関数の概要をここで示し、あとのセクションで詳しく説明します。<a class="xref" href="connectors-apis.html#c-api-prepared-statement-functions" title="23.8.11 C API プリペアドステートメント関数の説明">セクション23.8.11「C API プリペアドステートメント関数の説明」</a>を参照してください。
    </p><div class="informaltable"><table summary="この表は、C API プリペアドステートメント処理に使用可能な関数を一覧表示し、各関数について説明します。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">関数</th><th scope="col">説明</th></tr></thead><tbody><tr><td scope="row"><code class="literal">mysql_stmt_affected_rows()</code></td><td>プリペアド <code class="literal">UPDATE</code>、<code class="literal">DELETE</code>、または <code class="literal">INSERT</code> ステートメントによって変更、削除、挿入された行数を返します</td></tr><tr><td scope="row"><code class="literal">mysql_stmt_attr_get()</code></td><td>プリペアドステートメントの属性の値を取得します</td></tr><tr><td scope="row"><code class="literal">mysql_stmt_attr_set()</code></td><td>プリペアドステートメントの属性を設定します</td></tr><tr><td scope="row"><code class="literal">mysql_stmt_bind_param()</code></td><td>アプリケーションデータバッファーをプリペアド SQL ステートメントのパラメータマーカーに関連付けます</td></tr><tr><td scope="row"><code class="literal">mysql_stmt_bind_result()</code></td><td>アプリケーションデータバッファーを結果セット内のカラムに関連付けます</td></tr><tr><td scope="row"><code class="literal">mysql_stmt_close()</code></td><td>プリペアドステートメントによって使用されているメモリーを解放します</td></tr><tr><td scope="row"><code class="literal">mysql_stmt_data_seek()</code></td><td>ステートメント結果セット内の任意の行番号にシークします</td></tr><tr><td scope="row"><code class="literal">mysql_stmt_errno()</code></td><td>最後のステートメント実行のエラー番号を返します</td></tr><tr><td scope="row"><code class="literal">mysql_stmt_error()</code></td><td>最後のステートメント実行のエラーメッセージを返します</td></tr><tr><td scope="row"><code class="literal">mysql_stmt_execute()</code></td><td>プリペアドステートメントを実行します</td></tr><tr><td scope="row"><code class="literal">mysql_stmt_fetch()</code></td><td>結果セットから次のデータの行をフェッチし、バインドされたすべてのカラムのデータを返します</td></tr><tr><td scope="row"><code class="literal">mysql_stmt_fetch_column()</code></td><td>結果セットの現在の行の 1 つのカラムのデータをフェッチします</td></tr><tr><td scope="row"><code class="literal">mysql_stmt_field_count()</code></td><td>最近のステートメントの結果カラムの数を返します</td></tr><tr><td scope="row"><code class="literal">mysql_stmt_free_result()</code></td><td>ステートメントハンドルに割り当てられているリソースを解放します</td></tr><tr><td scope="row"><code class="literal">mysql_stmt_init()</code></td><td><code class="literal">MYSQL_STMT</code> 構造にメモリーを割り当て、それを初期化します</td></tr><tr><td scope="row"><code class="literal">mysql_stmt_insert_id()</code></td><td>プリペアドステートメントによって <code class="literal">AUTO_INCREMENT</code> カラムに対して生成された ID を返します</td></tr><tr><td scope="row"><code class="literal">mysql_stmt_next_result()</code></td><td>複数結果の実行での次の結果を返すか、初期化します</td></tr><tr><td scope="row"><code class="literal">mysql_stmt_num_rows()</code></td><td>バッファーされたステートメント結果セットから行カウントを返します</td></tr><tr><td scope="row"><code class="literal">mysql_stmt_param_count()</code></td><td>プリペアドステートメント内のパラメータの数を返します。</td></tr><tr><td scope="row"><code class="literal">mysql_stmt_param_metadata()</code></td><td>(結果セットの形式でパラメータメタデータを返します) 現在、この関数は何も実行しません</td></tr><tr><td scope="row"><code class="literal">mysql_stmt_prepare()</code></td><td>SQL ステートメント文字列の実行を準備します</td></tr><tr><td scope="row"><code class="literal">mysql_stmt_reset()</code></td><td>サーバー内のステートメントバッファーをリセットします</td></tr><tr><td scope="row"><code class="literal">mysql_stmt_result_metadata()</code></td><td>結果セットの形式でプリペアドステートメントメタデータを返します</td></tr><tr><td scope="row"><code class="literal">mysql_stmt_row_seek()</code></td><td><code class="literal">mysql_stmt_row_tell()</code> から返される値を使用して、ステートメント結果セット内の行オフセットにシークします。</td></tr><tr><td scope="row"><code class="literal">mysql_stmt_row_tell()</code></td><td>ステートメント行カーソル位置を返します</td></tr><tr><td scope="row"><code class="literal">mysql_stmt_send_long_data()</code></td><td>長いデータをまとめてサーバーに送信します</td></tr><tr><td scope="row"><code class="literal">mysql_stmt_sqlstate()</code></td><td>最後のステートメント実行の SQLSTATE エラーコードを返します</td></tr><tr><td scope="row"><code class="literal">mysql_stmt_store_result()</code></td><td>クライアントへの完全な結果セットを取得します</td></tr></tbody></table></div><p>
      <code class="literal">mysql_stmt_init()</code> を呼び出して、ステートメントハンドルを作成し、次に<code class="literal">mysql_stmt_prepare()</code> を呼び出して、ステートメント文字列を準備し、<code class="literal">mysql_stmt_bind_param()</code> を呼び出してパラメータデータを提供し、<code class="literal">mysql_stmt_execute()</code> を呼び出して、ステートメントを実行します。<code class="literal">mysql_stmt_bind_param()</code> によって提供される各バッファー内のパラメータ値を変更することによって、<code class="literal">mysql_stmt_execute()</code> を繰り返すことができます。
    </p><p>
      <code class="literal">mysql_stmt_send_long_data()</code> を使用して、テキストやバイナリデータをまとめてサーバーに送信できます。<a class="xref" href="connectors-apis.html#mysql-stmt-send-long-data" title="23.8.11.26 mysql_stmt_send_long_data()">セクション23.8.11.26「mysql_stmt_send_long_data()」</a>を参照してください。
    </p><p>
      ステートメントが <code class="literal">SELECT</code> または結果セットを生成するその他のステートメントである場合、<code class="literal">mysql_stmt_prepare()</code> は、<code class="literal">mysql_stmt_result_metadata()</code> によって、<code class="literal">MYSQL_RES</code> 結果セットの形式で、結果セットメタデータ情報も返します。
    </p><p>
      <code class="literal">mysql_stmt_fetch()</code> が自動的に結果バッファーにデータを返すように、<code class="literal">mysql_stmt_bind_result()</code> を使用して、それらのバッファーを提供できます。これは行単位のフェッチです。
    </p><p>
      ステートメントの実行が完了したら、<code class="literal">mysql_stmt_close()</code> を使用してステートメントハンドルをクローズして、それに関連付けられているすべてのリソースを解放できるようにします。
    </p><p>
      <code class="literal">mysql_stmt_result_metadata()</code> を呼び出すことによって、<code class="literal">SELECT</code> ステートメントの結果セットメタデータを取得した場合、<code class="literal">mysql_free_result()</code> を使用してメタデータも解放してください。
    </p><h4><a name="idm139978999983152"></a>実行ステップ</h4><p>
      ステートメントを準備して実行するには、アプリケーションはこれらのステップに従います。
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          <code class="literal">mysql_stmt_init()</code> によってプリペアドステートメントハンドルを作成します。サーバーでステートメントを準備するには、<code class="literal">mysql_stmt_prepare()</code> を呼び出して、それに SQL ステートメントを格納する文字列を渡します。
        </p></li><li class="listitem"><p>
          ステートメントが結果セットを生成する場合、<code class="literal">mysql_stmt_result_metadata()</code> を呼び出して、結果セットメタデータを取得します。このメタデータは、クエリーによって返される行を格納するものとは別のものですが、それ自体が結果セットの形式になります。メタデータ結果セットは、結果に存在するカラム数を示し、各カラムに関する情報を含んでいます。
        </p></li><li class="listitem"><p>
          <code class="literal">mysql_stmt_bind_param()</code> を使用して、パラメータの値を設定します。すべてのパラメータを設定する必要があります。そうしないと、ステートメント実行がエラーを返すか、予期しない結果を生成します。
        </p></li><li class="listitem"><p>
          <code class="literal">mysql_stmt_execute()</code> を呼び出してステートメントを実行します。
        </p></li><li class="listitem"><p>
          ステートメントが結果セットを生成する場合、<code class="literal">mysql_stmt_bind_result()</code> を呼び出すことによって、行値を取得するために使用するデータバッファーをバインドします。
        </p></li><li class="listitem"><p>
          <code class="literal">mysql_stmt_fetch()</code> を繰り返し呼び出すことによって、それ以上の行が見つからなくなるまで、行ごとにデータをバッファーにフェッチします。
        </p></li><li class="listitem"><p>
          パラメータ値を変更してステートメントを再実行することによって、必要に応じて、ステップ 3 から 6 を繰り返します。
        </p></li></ol></div><p>
      <code class="literal">mysql_stmt_prepare()</code> が呼び出されると、MySQL クライアント/サーバープロトコルはこれらのアクションを実行します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          サーバーはステートメントを解析し、ステートメント ID を割り当てて、クライアントに正常ステータスを返送します。さらに、それが結果セット指向のステートメントである場合に、パラメータの合計数、カラムカウント、およびそのメタデータも送信します。この呼び出し中に、サーバーによって、ステートメントのすべての構文とセマンティクスがチェックされます。
        </p></li><li class="listitem"><p>
          サーバーがそのステートメントのプール内からステートメントを識別できるように、クライアントはその後の操作にこのステートメント ID を使用します。
        </p></li></ul></div><p>
      <code class="literal">mysql_stmt_execute()</code> が呼び出されると、MySQL クライアント/サーバープロトコルはこれらのアクションを実行します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          クライアントはステートメントハンドルを使用して、サーバーにパラメータデータを送信します。
        </p></li><li class="listitem"><p>
          サーバーは、クライアントによって提供された ID を使用してステートメントを識別し、パラメータマーカーを新しく提供されたデータで置換して、ステートメントを実行します。ステートメントが結果セットを生成する場合、サーバーはクライアントにデータを返送します。そうでない場合、正常ステータスと変更、削除、または挿入された行数を送信します。
        </p></li></ul></div><p>
      <code class="literal">mysql_stmt_fetch()</code> が呼び出されると、MySQL クライアント/サーバープロトコルはこれらのアクションを実行します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          クライアントは結果セットの現在の行からデータを読み取り、必要な変換を行なって、それをアプリケーションデータバッファーに配置します。アプリケーションバッファーの型が、サーバーから返されるフィールドの型のそれと同じである場合、変換は簡単です。
        </p></li></ul></div><p>
      エラーが発生した場合、<code class="literal">mysql_stmt_errno()</code>、<code class="literal">mysql_stmt_error()</code>、および <code class="literal">mysql_stmt_sqlstate()</code> をそれぞれ使用して、ステートメントエラー番号、エラーメッセージ、および SQLSTATE コードを取得できます。
    </p><h4><a name="idm139978999949168"></a>プリペアドステートメントのロギング</h4><p>
      <code class="literal">mysql_stmt_prepare()</code> と <code class="literal">mysql_stmt_execute()</code> C API 関数によって実行されたプリペアドステートメントに対して、サーバーは一般クエリーログに <code class="literal">Prepare</code> および <code class="literal">Execute</code> 行を書き込むため、ステートメントが準備され、実行されたタイミングがわかります。
    </p><p>
      次のようにステートメントを準備して実行するものとします。
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          <code class="literal">mysql_stmt_prepare()</code> を呼び出して、ステートメント文字列 <code class="literal">"SELECT ?"</code> を準備します。
        </p></li><li class="listitem"><p>
          <code class="literal">mysql_stmt_bind_param()</code> を呼び出して、値 <code class="literal">3</code> をプリペアドステートメント内のパラメータにバインドします。
        </p></li><li class="listitem"><p>
          <code class="literal">mysql_stmt_execute()</code> を呼び出して、プリペアドステートメントを実行します。
        </p></li></ol></div><p>
      以前の呼び出しの結果として、サーバーは一般クエリーログに次の行を書き込みます。
    </p><pre class="programlisting">
Prepare  [1] SELECT ?
Execute  [1] SELECT 3
</pre><p>
      ログ内の各 <code class="literal">Prepare</code> および <code class="literal">Execute</code> 行は、<code class="literal">[<em class="replaceable"><code>N</code></em>]</code> ステートメント識別子でタグ付けされるため、ログに記録されているプリペアドステートメントを追跡できます。<em class="replaceable"><code>N</code></em> は正の整数です。クライアントに、同時にアクティブな複数のプリペアドステートメントがある場合、<em class="replaceable"><code>N</code></em> は 1 より大きくなる可能性があります。<code class="literal">?</code> パラメータのデータ値の置換後、各 <code class="literal">Execute</code> 行にプリペアドステートメントが示されます。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-prepared-statement-functions"></a>23.8.11 C API プリペアドステートメント関数の説明</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="connectors-apis.html#mysql-stmt-affected-rows">23.8.11.1 mysql_stmt_affected_rows()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-stmt-attr-get">23.8.11.2 mysql_stmt_attr_get()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-stmt-attr-set">23.8.11.3 mysql_stmt_attr_set()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-stmt-bind-param">23.8.11.4 mysql_stmt_bind_param()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-stmt-bind-result">23.8.11.5 mysql_stmt_bind_result()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-stmt-close">23.8.11.6 mysql_stmt_close()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-stmt-data-seek">23.8.11.7 mysql_stmt_data_seek()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-stmt-errno">23.8.11.8 mysql_stmt_errno()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-stmt-error">23.8.11.9 mysql_stmt_error()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-stmt-execute">23.8.11.10 mysql_stmt_execute()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-stmt-fetch">23.8.11.11 mysql_stmt_fetch()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-stmt-fetch-column">23.8.11.12 mysql_stmt_fetch_column()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-stmt-field-count">23.8.11.13 mysql_stmt_field_count()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-stmt-free-result">23.8.11.14 mysql_stmt_free_result()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-stmt-init">23.8.11.15 mysql_stmt_init()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-stmt-insert-id">23.8.11.16 mysql_stmt_insert_id()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-stmt-next-result">23.8.11.17 mysql_stmt_next_result()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-stmt-num-rows">23.8.11.18 mysql_stmt_num_rows()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-stmt-param-count">23.8.11.19 mysql_stmt_param_count()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-stmt-param-metadata">23.8.11.20 mysql_stmt_param_metadata()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-stmt-prepare">23.8.11.21 mysql_stmt_prepare()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-stmt-reset">23.8.11.22 mysql_stmt_reset()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-stmt-result-metadata">23.8.11.23 mysql_stmt_result_metadata()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-stmt-row-seek">23.8.11.24 mysql_stmt_row_seek()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-stmt-row-tell">23.8.11.25 mysql_stmt_row_tell()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-stmt-send-long-data">23.8.11.26 mysql_stmt_send_long_data()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-stmt-sqlstate">23.8.11.27 mysql_stmt_sqlstate()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-stmt-store-result">23.8.11.28 mysql_stmt_store_result()</a></span></dt></dl></div><p>
      クエリーを準備して実行するには、次のセクションで詳しく説明している関数を使用します。
    </p><p>
      <code class="literal">MYSQL_STMT</code> 構造で動作するすべての関数はプリフィクス <code class="literal">mysql_stmt_</code> で始まります。
    </p><p>
      <code class="literal">MYSQL_STMT</code> ハンドルを作成するには、<code class="literal">mysql_stmt_init()</code> 関数を使用します。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-affected-rows"></a>23.8.11.1 mysql_stmt_affected_rows()</h4></div></div></div><a class="indexterm" name="idm139978999920688"></a><p>
        <code class="literal">my_ulonglong mysql_stmt_affected_rows(MYSQL_STMT *stmt)</code>
      </p><h5><a name="idm139978999918096"></a>説明</h5><p>
        <code class="literal">mysql_stmt_affected_rows()</code> は、<code class="literal">mysql_stmt_execute()</code> によるステートメントの実行直後に呼び出すことができます。それはプリペアドステートメントを除けば <code class="literal">mysql_affected_rows()</code> に似ています。この関数によって返される影響を受ける行の値の説明については、<a class="xref" href="connectors-apis.html#mysql-affected-rows" title="23.8.7.1 mysql_affected_rows()">セクション23.8.7.1「mysql_affected_rows()」</a>を参照してください。
      </p><h5><a name="idm139978999912832"></a>エラー</h5><p>
        なし。
      </p><h5><a name="idm139978999911728"></a>例</h5><p>
        <a class="xref" href="connectors-apis.html#mysql-stmt-execute" title="23.8.11.10 mysql_stmt_execute()">セクション23.8.11.10「mysql_stmt_execute()」</a>の例を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-attr-get"></a>23.8.11.2 mysql_stmt_attr_get()</h4></div></div></div><a class="indexterm" name="idm139978999908784"></a><p>
        <code class="literal">my_bool mysql_stmt_attr_get(MYSQL_STMT *stmt, enum enum_stmt_attr_type option, void *arg)</code>
      </p><h5><a name="idm139978999906160"></a>説明</h5><p>
        ステートメント属性の現在の値を取得するために使用できます。
      </p><p>
        <code class="literal">option</code> 引数は取得するオプションです。<code class="literal">arg</code> はオプション値を含む変数を指すようにするべきです。オプションが整数の場合、<code class="literal">arg</code> は整数の値を指すべきです。
      </p><p>
        オプションとオプションの型のリストについては、<a class="xref" href="connectors-apis.html#mysql-stmt-attr-set" title="23.8.11.3 mysql_stmt_attr_set()">セクション23.8.11.3「mysql_stmt_attr_set()」</a>を参照してください。
      </p><h5><a name="idm139978999900736"></a>戻り値</h5><p>
        成功の場合はゼロ。<code class="literal">option</code> が不明な場合はゼロ以外。
      </p><h5><a name="idm139978999898800"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-attr-set"></a>23.8.11.3 mysql_stmt_attr_set()</h4></div></div></div><a class="indexterm" name="idm139978999896544"></a><p>
        <code class="literal">my_bool mysql_stmt_attr_set(MYSQL_STMT *stmt, enum enum_stmt_attr_type option, const void *arg)</code>
      </p><h5><a name="idm139978999893920"></a>説明</h5><p>
        プリペアドステートメントの動作に影響を与えるために使用できます。この関数を複数回呼び出して、複数のオプションを設定できます。
      </p><p>
        <code class="literal">option</code> 引数は、設定するオプションです。<code class="literal">arg</code> 引数はオプションの値です。<code class="literal">arg</code> は、目的の属性値に設定される変数を指すべきです。変数の型は次の表に示すようなものになります。
      </p><p>
        次の表に可能な <code class="literal">option</code> 値を示します。
      </p><div class="informaltable"><table summary="この表は mysql_stmt_attr_set() オプションの値を、各オプションの引数型と関数とともに一覧表示しています。" border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">オプション</th><th scope="col">引数型</th><th scope="col">関数</th></tr></thead><tbody><tr><td scope="row"><code class="literal">STMT_ATTR_UPDATE_MAX_LENGTH</code></td><td><code class="literal">my_bool *</code></td><td>1 に設定されている場合、<code class="literal">mysql_stmt_store_result()</code> によってメタデータ <code class="literal">MYSQL_FIELD-&gt;max_length</code> 値が更新されます。</td></tr><tr><td scope="row"><code class="literal">STMT_ATTR_CURSOR_TYPE</code></td><td><code class="literal">unsigned long *</code></td><td><code class="literal">mysql_stmt_execute()</code> が呼び出されたときにステートメントに対して開くカーソルの型。<code class="literal">*arg</code> は <code class="literal">CURSOR_TYPE_NO_CURSOR</code> (デフォルト) または <code class="literal">CURSOR_TYPE_READ_ONLY</code> を指定できます。</td></tr><tr><td scope="row"><code class="literal">STMT_ATTR_PREFETCH_ROWS</code></td><td><code class="literal">unsigned long *</code></td><td>カーソルの使用時に、サーバーからフェッチする行数。<code class="literal">*arg</code> は 1 から <code class="literal">unsigned long</code> の最大値の範囲で指定できます。デフォルトは 1 です。</td></tr></tbody></table></div><p>
        <code class="literal">CURSOR_TYPE_READ_ONLY</code> で <code class="literal">STMT_ATTR_CURSOR_TYPE</code> オプションを使用する場合、<code class="literal">mysql_stmt_execute()</code> を呼び出すと、ステートメントに対して、カーソルが開かれます。前の <code class="literal">mysql_stmt_execute()</code> 呼び出しからの開いているカーソルがすでに存在する場合、それは新しいカーソルを開く前にカーソルを閉じます。<code class="literal">mysql_stmt_reset()</code> もステートメントの再実行を準備する前に、開いているカーソルを閉じます。<code class="literal">mysql_stmt_free_result()</code> はすべての開いているカーソルを閉じます。
      </p><p>
        プリペアドステートメントに対してカーソルを開く場合、<code class="literal">mysql_stmt_store_result()</code> は結果セットをクライアント側にバッファーさせるため、必要ありません。
      </p><h5><a name="idm139978999858752"></a>戻り値</h5><p>
        成功の場合はゼロ。<code class="literal">option</code> が不明な場合はゼロ以外。
      </p><h5><a name="idm139978999856784"></a>エラー</h5><p>
        なし。
      </p><h5><a name="idm139978999855648"></a>例</h5><p>
        次の例は、プリペアドステートメントに対してカーソルを開き、一度にフェッチする行数を 5 に設定します。
      </p><pre class="programlisting">
MYSQL_STMT *stmt;
int rc;
unsigned long type;
unsigned long prefetch_rows = 5;

stmt = mysql_stmt_init(mysql);
type = (unsigned long) CURSOR_TYPE_READ_ONLY;
rc = mysql_stmt_attr_set(stmt, STMT_ATTR_CURSOR_TYPE, (void*) &amp;type);
/* ... check return value ... */
rc = mysql_stmt_attr_set(stmt, STMT_ATTR_PREFETCH_ROWS,
                         (void*) &amp;prefetch_rows);
/* ... check return value ... */
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-bind-param"></a>23.8.11.4 mysql_stmt_bind_param()</h4></div></div></div><a class="indexterm" name="idm139978999851952"></a><p>
        <code class="literal">my_bool mysql_stmt_bind_param(MYSQL_STMT *stmt, MYSQL_BIND *bind)</code>
      </p><h5><a name="idm139978999849360"></a>説明</h5><p>
        <code class="literal">mysql_stmt_bind_param()</code> は、<code class="literal">mysql_stmt_prepare()</code> に渡された SQL ステートメント内のパラメータマーカーに入力データをバインドするために使用します。それは <code class="literal">MYSQL_BIND</code> 構造を使用して、データを提供します。<code class="literal">bind</code> は <code class="literal">MYSQL_BIND</code> 構造の配列のアドレスです。クライアントライブラリは、配列に、クエリーに存在する <code class="literal">?</code> パラメータマーカーごとに 1 つの要素が含まれることを期待します。
      </p><p>
        次のステートメントを準備するとします。
      </p><pre class="programlisting">
INSERT INTO mytbl VALUES(?,?,?)
</pre><p>
        パラメータをバインドする場合、<code class="literal">MYSQL_BIND</code> 構造の配列は、3 つの要素が含まれている必要があり、このように宣言できます。
      </p><pre class="programlisting">
MYSQL_BIND bind[3];
</pre><p>
        <a class="xref" href="connectors-apis.html#c-api-prepared-statement-data-structures" title="23.8.9 C API プリペアドステートメントデータ構造">セクション23.8.9「C API プリペアドステートメントデータ構造」</a>に、各 <code class="literal">MYSQL_BIND</code> 要素のメンバーおよび入力値を提供するためにそれらを設定する方法について説明しています。
      </p><h5><a name="idm139978999837104"></a>戻り値</h5><p>
        成功の場合はゼロ。エラーが発生した場合、ゼロ以外。
      </p><h5><a name="idm139978999835840"></a>エラー</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_UNSUPPORTED_PARAM_TYPE</code>
          </p><p>
            変換はサポートされていません。<code class="literal">buffer_type</code> 値は無効か、サポートされるいずれの型でもない可能性があります。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_OUT_OF_MEMORY</code>
          </p><p>
            メモリー不足。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_UNKNOWN_ERROR</code>
          </p><p>
            不明なエラーが発生しました。
          </p></li></ul></div><h5><a name="idm139978999827120"></a>例</h5><p>
        <a class="xref" href="connectors-apis.html#mysql-stmt-execute" title="23.8.11.10 mysql_stmt_execute()">セクション23.8.11.10「mysql_stmt_execute()」</a>の例を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-bind-result"></a>23.8.11.5 mysql_stmt_bind_result()</h4></div></div></div><a class="indexterm" name="idm139978999824192"></a><p>
        <code class="literal">my_bool mysql_stmt_bind_result(MYSQL_STMT *stmt, MYSQL_BIND *bind)</code>
      </p><h5><a name="idm139978999821616"></a>説明</h5><p>
        <code class="literal">mysql_stmt_bind_result()</code> は、結果セット内の出力カラムをデータバッファーおよび長さバッファーに関連付ける (つまりバインドする) ために使用します。<code class="literal">mysql_stmt_fetch()</code> がデータをフェッチするために呼び出されると、MySQL クライアント/サーバープロトコルはバインドされたカラムのデータを、指定されたバッファーに配置します。
      </p><p>
        <code class="literal">mysql_stmt_fetch()</code> を呼び出す前に、すべてのカラムがバッファーにバインドされている必要があります。<code class="literal">bind</code> は <code class="literal">MYSQL_BIND</code> 構造の配列のアドレスです。クライアントライブラリは、配列に、結果セットのカラムごとに 1 つの要素が含まれることを期待します。カラムを <code class="literal">MYSQL_BIND</code> 構造にバインドしない場合、<code class="literal">mysql_stmt_fetch()</code> は単にデータフェッチを無視します。プロトコルはまとめてデータ値を返さないため、バッファーはデータ値を保持できる十分な大きさがあるべきです。
      </p><p>
        結果セットが部分的に取得されたあとでも、カラムはいつでもバインドまたは再バインドできます。新しいバインドタスクは、次に <code class="literal">mysql_stmt_fetch()</code> が呼び出されたときに有効になります。アプリケーションが結果セット内のカラムをバインドし、<code class="literal">mysql_stmt_fetch()</code> を呼び出すものとします。クライアント/サーバープロトコルはバインドされたバッファーにデータを返します。その後、アプリケーションはカラムを別の一連のバッファーにバインドするものとします。<code class="literal">mysql_stmt_fetch()</code> への次の呼び出し時に、プロトコルは新しくバインドされたバッファーにデータを配置します。
      </p><p>
        カラムをバインドするには、アプリケーションで <code class="literal">mysql_stmt_bind_result()</code> を呼び出し、値を格納する出力バッファーの型、アドレス、および長さを渡します。<a class="xref" href="connectors-apis.html#c-api-prepared-statement-data-structures" title="23.8.9 C API プリペアドステートメントデータ構造">セクション23.8.9「C API プリペアドステートメントデータ構造」</a>に各 <code class="literal">MYSQL_BIND</code> 要素のメンバーおよび出力値を受け取るために設定する方法について説明します。
      </p><h5><a name="idm139978999803840"></a>戻り値</h5><p>
        成功の場合はゼロ。エラーが発生した場合、ゼロ以外。
      </p><h5><a name="idm139978999802576"></a>エラー</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_UNSUPPORTED_PARAM_TYPE</code>
          </p><p>
            変換はサポートされていません。<code class="literal">buffer_type</code> 値は無効か、サポートされるいずれの型でもない可能性があります。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_OUT_OF_MEMORY</code>
          </p><p>
            メモリー不足。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_UNKNOWN_ERROR</code>
          </p><p>
            不明なエラーが発生しました。
          </p></li></ul></div><h5><a name="idm139978999793856"></a>例</h5><p>
        <a class="xref" href="connectors-apis.html#mysql-stmt-fetch" title="23.8.11.11 mysql_stmt_fetch()">セクション23.8.11.11「mysql_stmt_fetch()」</a>の例を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-close"></a>23.8.11.6 mysql_stmt_close()</h4></div></div></div><a class="indexterm" name="idm139978999790976"></a><p>
        <code class="literal">my_bool mysql_stmt_close(MYSQL_STMT *)</code>
      </p><h5><a name="idm139978999788432"></a>説明</h5><p>
        プリペアドステートメントをクローズします。<code class="literal">mysql_stmt_close()</code> は <code class="literal">stmt</code> によって指されているステートメントハンドルの割り当ても解除します。
      </p><p>
        現在のステートメントに保留中か未読の結果がある場合、この関数は、次のクエリーを実行できるように、それらをキャンセルします。
      </p><h5><a name="idm139978999784496"></a>戻り値</h5><p>
        成功の場合はゼロ。エラーが発生した場合、ゼロ以外。
      </p><h5><a name="idm139978999783232"></a>エラー</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_SERVER_GONE_ERROR</code>
          </p><p>
            MySQL サーバーが存在しなくなりました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_UNKNOWN_ERROR</code>
          </p><p>
            不明なエラーが発生しました。
          </p></li></ul></div><h5><a name="idm139978999777616"></a>例</h5><p>
        <a class="xref" href="connectors-apis.html#mysql-stmt-execute" title="23.8.11.10 mysql_stmt_execute()">セクション23.8.11.10「mysql_stmt_execute()」</a>の例を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-data-seek"></a>23.8.11.7 mysql_stmt_data_seek()</h4></div></div></div><a class="indexterm" name="idm139978999774672"></a><p>
        <code class="literal">void mysql_stmt_data_seek(MYSQL_STMT *stmt, my_ulonglong offset)</code>
      </p><h5><a name="idm139978999772080"></a>説明</h5><p>
        ステートメント結果セット内の任意の行にシークします。<code class="literal">offset</code> 値は行番号で、<code class="literal">0</code> から <code class="literal">mysql_stmt_num_rows(stmt)-1</code> までの範囲であるべきです。
      </p><p>
        この関数は、ステートメント結果セット構造に最後に実行されたクエリーの結果全体を含める必要があるため、<code class="literal">mysql_stmt_data_seek()</code> は、<code class="literal">mysql_stmt_store_result()</code> と一緒にのみ使用できます。
      </p><h5><a name="idm139978999765488"></a>戻り値</h5><p>
        なし。
      </p><h5><a name="idm139978999764352"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-errno"></a>23.8.11.8 mysql_stmt_errno()</h4></div></div></div><a class="indexterm" name="idm139978999762048"></a><p>
        <code class="literal">unsigned int mysql_stmt_errno(MYSQL_STMT *stmt)</code>
      </p><h5><a name="idm139978999759488"></a>説明</h5><p>
        <code class="literal">stmt</code> によって指定されたステートメントに対して、<code class="literal">mysql_stmt_errno()</code> は最近呼び出された成功または失敗した可能性のあるステートメント API 関数のエラーコードを返します。ゼロの戻り値はエラーが発生しなかったことを意味します。クライアントのエラーメッセージ番号は、MySQL <code class="filename">errmsg.h</code> ヘッダーファイルに一覧表示されています。サーバーのエラーメッセージ番号は、<code class="filename">mysqld_error.h</code> に一覧表示されています。エラーは<a class="xref" href="error-handling.html" title="付録 B エラー、エラーコード、および一般的な問題">付録B <i>エラー、エラーコード、および一般的な問題</i></a>にも一覧表示しています。
      </p><h5><a name="idm139978999753568"></a>戻り値</h5><p>
        エラーコード値。エラーが発生しなかった場合はゼロ。
      </p><h5><a name="idm139978999752336"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-error"></a>23.8.11.9 mysql_stmt_error()</h4></div></div></div><a class="indexterm" name="idm139978999750096"></a><p>
        <code class="literal">const char *mysql_stmt_error(MYSQL_STMT *stmt)</code>
      </p><h5><a name="idm139978999747536"></a>説明</h5><p>
        <code class="literal">stmt</code> によって指定されたステートメントに対して、<code class="literal">mysql_stmt_error()</code> は最近呼び出された、成功または失敗した可能性のあるステートメント API 関数のエラーメッセージを格納する NULL 終端文字列を返します。エラーが発生しなかった場合、空の文字列 (<code class="literal">""</code>) が返されます。エラーをチェックするために、これらの 2 つのテストのいずれかを使用できます。
      </p><pre class="programlisting">
if(*mysql_stmt_errno(stmt))
{
  // an error occurred
}

if (mysql_stmt_error(stmt)[0])
{
  // an error occurred
}
</pre><p>
        クライアントエラーメッセージの言語は、MySQL クライアントライブラリを再コンパイルすることによって変更できます。現在、数種類の言語のエラーメッセージを選択できます。
      </p><h5><a name="idm139978999741504"></a>戻り値</h5><p>
        エラーについて説明する文字列。エラーが発生しなかった場合は空の文字列。
      </p><h5><a name="idm139978999740176"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-execute"></a>23.8.11.10 mysql_stmt_execute()</h4></div></div></div><a class="indexterm" name="idm139978999737920"></a><p>
        <code class="literal">int mysql_stmt_execute(MYSQL_STMT *stmt)</code>
      </p><h5><a name="idm139978999735360"></a>説明</h5><p>
        <code class="literal">mysql_stmt_execute()</code> はステートメントハンドルと関連付けられたプリペアドクエリーを実行します。現在バインドされているパラメータマーカー値がこの呼び出し中にサーバーに送信され、サーバーはそのマーカーをこの新しく提供されたデータと置き換えます。
      </p><p>
        <code class="literal">mysql_stmt_execute()</code> のあとのステートメント処理は、ステートメントの種類によって異なります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">UPDATE</code>、<code class="literal">DELETE</code>、または <code class="literal">INSERT</code> では、変更、削除、または挿入された行の数を <code class="literal">mysql_stmt_affected_rows()</code> を呼び出して見つけることができます。
          </p></li><li class="listitem"><p>
            結果セットを生成する <code class="literal">SELECT</code> などのステートメントでは、クエリー処理が発生するほかのすべての関数を呼び出す前に、<code class="literal">mysql_stmt_fetch()</code> を呼び出して、データをフェッチする必要があります。結果をフェッチする方法の詳細については、<a class="xref" href="connectors-apis.html#mysql-stmt-fetch" title="23.8.11.11 mysql_stmt_fetch()">セクション23.8.11.11「mysql_stmt_fetch()」</a>を参照してください。
          </p><p>
            <code class="literal">mysql_stmt_execute()</code> の呼び出しに続いて、<code class="literal">mysql_store_result()</code> または <code class="literal">mysql_use_result()</code> を呼び出さないでください。それらの関数は、プリペアドステートメントからの結果を処理することを意図していません。
          </p></li></ul></div><p>
        結果セットを生成するステートメントに対して、<code class="literal">mysql_stmt_execute()</code> に、ステートメントを実行する前に、<code class="literal">mysql_stmt_attr_set()</code>　を呼び出すことによって、ステートメントのカーソルを開くように要求できます。ステートメントを複数回実行する場合、<code class="literal">mysql_stmt_execute()</code> は新しいカーソルを開く前に、開いているカーソルを閉じます。
      </p><p>
        プリペアドステートメントによって参照されているテーブルやビューのメタデータの変更が検出され、それが次に実行されるときに、ステートメントが自動再準備されます。詳細については、<a class="xref" href="optimization.html#statement-caching" title="8.9.4 プリペアドステートメントおよびストアドプログラムのキャッシュ">セクション8.9.4「プリペアドステートメントおよびストアドプログラムのキャッシュ」</a>を参照してください。
      </p><h5><a name="idm139978999711584"></a>戻り値</h5><p>
        成功の場合はゼロ。エラーが発生した場合、ゼロ以外。
      </p><h5><a name="idm139978999710352"></a>エラー</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_COMMANDS_OUT_OF_SYNC</code>
          </p><p>
            コマンドが正しくない順番で実行されました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_OUT_OF_MEMORY</code>
          </p><p>
            メモリー不足。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_GONE_ERROR</code>
          </p><p>
            MySQL サーバーが存在しなくなりました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_LOST</code>
          </p><p>
            サーバーへの接続がクエリー中に失われました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_UNKNOWN_ERROR</code>
          </p><p>
            不明なエラーが発生しました。
          </p></li></ul></div><h5><a name="idm139978999697904"></a>例</h5><p>
        次の例に、<code class="literal">mysql_stmt_init()</code>、<code class="literal">mysql_stmt_prepare()</code>、<code class="literal">mysql_stmt_param_count()</code>、<code class="literal">mysql_stmt_bind_param()</code>、<code class="literal">mysql_stmt_execute()</code>、および <code class="literal">mysql_stmt_affected_rows()</code> を使用して、テーブルを作成し、移入する方法を示します。<code class="literal">mysql</code> 変数は有効な接続ハンドルであるとみなされます。データの取得方法を示す例については、<a class="xref" href="connectors-apis.html#mysql-stmt-fetch" title="23.8.11.11 mysql_stmt_fetch()">セクション23.8.11.11「mysql_stmt_fetch()」</a>を参照してください。
      </p><pre class="programlisting">
#define STRING_SIZE 50

#define DROP_SAMPLE_TABLE "DROP TABLE IF EXISTS test_table"
#define CREATE_SAMPLE_TABLE "CREATE TABLE test_table(col1 INT,\
                                                 col2 VARCHAR(40),\
                                                 col3 SMALLINT,\
                                                 col4 TIMESTAMP)"
#define INSERT_SAMPLE "INSERT INTO \
                       test_table(col1,col2,col3) \
                       VALUES(?,?,?)"

MYSQL_STMT    *stmt;
MYSQL_BIND    bind[3];
my_ulonglong  affected_rows;
int           param_count;
short         small_data;
int           int_data;
char          str_data[STRING_SIZE];
unsigned long str_length;
my_bool       is_null;

if (mysql_query(mysql, DROP_SAMPLE_TABLE))
{
  fprintf(stderr, " DROP TABLE failed\n");
  fprintf(stderr, " %s\n", mysql_error(mysql));
  exit(0);
}

if (mysql_query(mysql, CREATE_SAMPLE_TABLE))
{
  fprintf(stderr, " CREATE TABLE failed\n");
  fprintf(stderr, " %s\n", mysql_error(mysql));
  exit(0);
}

/* Prepare an INSERT query with 3 parameters */
/* (the TIMESTAMP column is not named; the server */
/*  sets it to the current date and time) */
stmt = mysql_stmt_init(mysql);
if (!stmt)
{
  fprintf(stderr, " mysql_stmt_init(), out of memory\n");
  exit(0);
}
if (mysql_stmt_prepare(stmt, INSERT_SAMPLE, strlen(INSERT_SAMPLE)))
{
  fprintf(stderr, " mysql_stmt_prepare(), INSERT failed\n");
  fprintf(stderr, " %s\n", mysql_stmt_error(stmt));
  exit(0);
}
fprintf(stdout, " prepare, INSERT successful\n");

/* Get the parameter count from the statement */
param_count= mysql_stmt_param_count(stmt);
fprintf(stdout, " total parameters in INSERT: %d\n", param_count);

if (param_count != 3) /* validate parameter count */
{
  fprintf(stderr, " invalid parameter count returned by MySQL\n");
  exit(0);
}

/* Bind the data for all 3 parameters */

memset(bind, 0, sizeof(bind));

/* INTEGER PARAM */
/* This is a number type, so there is no need
   to specify buffer_length */
bind[0].buffer_type= MYSQL_TYPE_LONG;
bind[0].buffer= (char *)&amp;int_data;
bind[0].is_null= 0;
bind[0].length= 0;

/* STRING PARAM */
bind[1].buffer_type= MYSQL_TYPE_STRING;
bind[1].buffer= (char *)str_data;
bind[1].buffer_length= STRING_SIZE;
bind[1].is_null= 0;
bind[1].length= &amp;str_length;

/* SMALLINT PARAM */
bind[2].buffer_type= MYSQL_TYPE_SHORT;
bind[2].buffer= (char *)&amp;small_data;
bind[2].is_null= &amp;is_null;
bind[2].length= 0;

/* Bind the buffers */
if (mysql_stmt_bind_param(stmt, bind))
{
  fprintf(stderr, " mysql_stmt_bind_param() failed\n");
  fprintf(stderr, " %s\n", mysql_stmt_error(stmt));
  exit(0);
}

/* Specify the data values for the first row */
int_data= 10;             /* integer */
strncpy(str_data, "MySQL", STRING_SIZE); /* string  */
str_length= strlen(str_data);

/* INSERT SMALLINT data as NULL */
is_null= 1;

/* Execute the INSERT statement - 1*/
if (mysql_stmt_execute(stmt))
{
  fprintf(stderr, " mysql_stmt_execute(), 1 failed\n");
  fprintf(stderr, " %s\n", mysql_stmt_error(stmt));
  exit(0);
}

/* Get the number of affected rows */
affected_rows= mysql_stmt_affected_rows(stmt);
fprintf(stdout, " total affected rows(insert 1): %lu\n",
                (unsigned long) affected_rows);

if (affected_rows != 1) /* validate affected rows */
{
  fprintf(stderr, " invalid affected rows by MySQL\n");
  exit(0);
}

/* Specify data values for second row,
   then re-execute the statement */
int_data= 1000;
strncpy(str_data, "
        The most popular Open Source database",
        STRING_SIZE);
str_length= strlen(str_data);
small_data= 1000;         /* smallint */
is_null= 0;               /* reset */

/* Execute the INSERT statement - 2*/
if (mysql_stmt_execute(stmt))
{
  fprintf(stderr, " mysql_stmt_execute, 2 failed\n");
  fprintf(stderr, " %s\n", mysql_stmt_error(stmt));
  exit(0);
}

/* Get the total rows affected */
affected_rows= mysql_stmt_affected_rows(stmt);
fprintf(stdout, " total affected rows(insert 2): %lu\n",
                (unsigned long) affected_rows);

if (affected_rows != 1) /* validate affected rows */
{
  fprintf(stderr, " invalid affected rows by MySQL\n");
  exit(0);
}

/* Close the statement */
if (mysql_stmt_close(stmt))
{
  fprintf(stderr, " failed while closing the statement\n");
  fprintf(stderr, " %s\n", mysql_stmt_error(stmt));
  exit(0);
}
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          プリペアドステートメント関数の使用の完全な例については、ファイル <code class="filename">tests/mysql_client_test.c</code> を参照してください。このファイルは MySQL ソース配布または Bazaar ソースリポジトリから取得できます。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-fetch"></a>23.8.11.11 mysql_stmt_fetch()</h4></div></div></div><a class="indexterm" name="idm139978999674144"></a><p>
        <code class="literal">int mysql_stmt_fetch(MYSQL_STMT *stmt)</code>
      </p><h5><a name="idm139978999671600"></a>説明</h5><p>
        <code class="literal">mysql_stmt_fetch()</code> は結果セットで次の行を返します。それは結果セットが存在する間にのみ呼び出すことができます。つまり、結果セットを生成する <code class="literal">SELECT</code> などのステートメントに対する <code class="literal">mysql_stmt_execute()</code> への呼び出し後です。
      </p><p>
        <code class="literal">mysql_stmt_fetch()</code> は、<code class="literal">mysql_stmt_bind_result()</code> によってバインドされたバッファーを使用して、行データを返します。それは、現在の行セット内のすべてのカラムについて、それらのバッファー内のデータを返し、長さが <code class="literal">length</code> ポインタに返されます。アプリケーションは <code class="literal">mysql_stmt_fetch()</code> を呼び出す前に、すべてのカラムをバインドする必要があります。
      </p><p>
        デフォルトで、結果セットはサーバーから一度に行がバッファーされずにフェッチされます。クライアントで結果セット全体をバッファーするには、データバッファーをバインドしたあとの <code class="literal">mysql_stmt_fetch()</code> を呼び出す前に、<code class="literal">mysql_stmt_store_result()</code> を呼び出します。
      </p><p>
        フェッチしたデータ値が <code class="literal">NULL</code> 値である場合、対応する <code class="literal">MYSQL_BIND</code> 構造の <code class="literal">*is_null</code> 値には TRUE (1) が含まれます。そうでない場合、データとその長さが、アプリケーションによって指定されたバッファーの型に基づいて、<code class="literal">*buffer</code> および <code class="literal">*length</code> 要素で返されます。次の表に示すように、各数値および時間型は固定の長さを持ちます。<code class="literal">data_length</code> に示されるように、文字列型の長さは実際のデータ値の長さによって異なります。
      </p><div class="informaltable"><table summary="この表は数値および時間の MySQL 型を一覧表示し、各型の固定長を示します。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">型</th><th scope="col">長さ</th></tr></thead><tbody><tr><td scope="row"><code class="literal">MYSQL_TYPE_TINY</code></td><td>1</td></tr><tr><td scope="row"><code class="literal">MYSQL_TYPE_SHORT</code></td><td>2</td></tr><tr><td scope="row"><code class="literal">MYSQL_TYPE_LONG</code></td><td>4</td></tr><tr><td scope="row"><code class="literal">MYSQL_TYPE_LONGLONG</code></td><td>8</td></tr><tr><td scope="row"><code class="literal">MYSQL_TYPE_FLOAT</code></td><td>4</td></tr><tr><td scope="row"><code class="literal">MYSQL_TYPE_DOUBLE</code></td><td>8</td></tr><tr><td scope="row"><code class="literal">MYSQL_TYPE_TIME</code></td><td><code class="literal">sizeof(MYSQL_TIME)</code></td></tr><tr><td scope="row"><code class="literal">MYSQL_TYPE_DATE</code></td><td><code class="literal">sizeof(MYSQL_TIME)</code></td></tr><tr><td scope="row"><code class="literal">MYSQL_TYPE_DATETIME</code></td><td><code class="literal">sizeof(MYSQL_TIME)</code></td></tr><tr><td scope="row"><code class="literal">MYSQL_TYPE_STRING</code></td><td><code class="literal">data length</code></td></tr><tr><td scope="row"><code class="literal">MYSQL_TYPE_BLOB</code></td><td><code class="literal">data_length</code></td></tr></tbody></table></div><p>
        場合によって、<code class="literal">mysql_stmt_fetch()</code> でカラム値をフェッチする前にその長さを判断したいと考えることがあります。たとえば、値が、割り当てる必要があるスペースの量を知りたいと思う長い文字列や <code class="literal">BLOB</code> 値である場合があります。これを実現するには、これらの戦略を使用できます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">mysql_stmt_fetch()</code> を呼び出して、各行を取得する前に、<code class="literal">STMT_ATTR_UPDATE_MAX_LENGTH</code> を <code class="literal">mysql_stmt_attr_set()</code> に渡してから、<code class="literal">mysql_stmt_store_result()</code> を呼び出して、クライアント側で結果セット全体をバッファーします。<code class="literal">STMT_ATTR_UPDATE_MAX_LENGTH</code> 属性を設定すると、カラム値の最大長が <code class="literal">mysql_stmt_result_metadata()</code> によって返される結果セットメタデータの <code class="literal">max_length</code> によって示されます。
          </p></li><li class="listitem"><p>
            問題のカラムに対し、ゼロの長さのバッファーで <code class="literal">mysql_stmt_fetch()</code> を呼び出すと、実際の長さのポインタを格納できます。その後、<code class="literal">mysql_stmt_fetch_column()</code> で実際の長さを使用します。
          </p><pre class="programlisting">
real_length= 0;

bind[0].buffer= 0;
bind[0].buffer_length= 0;
bind[0].length= &amp;real_length
mysql_stmt_bind_result(stmt, bind);

mysql_stmt_fetch(stmt);
if (real_length &gt; 0)
{
  data= malloc(real_length);
  bind[0].buffer= data;
  bind[0].buffer_length= real_length;
  mysql_stmt_fetch_column(stmt, bind, 0, 0);
}
</pre></li></ul></div><h5><a name="idm139978999613760"></a>戻り値</h5><div class="informaltable"><table summary="この表は mysql_stmt_fetch() の戻り値を一覧表示し、各値について説明します。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">戻り値</th><th scope="col">説明</th></tr></thead><tbody><tr><td scope="row">0</td><td>成功、データがアプリケーションデータバッファーにフェッチされました。</td></tr><tr><td scope="row">1</td><td>エラーが発生しました。エラーコードとエラーメッセージは、<code class="literal">mysql_stmt_errno()</code> および <code class="literal">mysql_stmt_error()</code> を呼び出すことによって取得できます。</td></tr><tr><td scope="row"><code class="literal">MYSQL_NO_DATA</code></td><td>それ以上の行/データは存在しません</td></tr><tr><td scope="row"><code class="literal">MYSQL_DATA_TRUNCATED</code></td><td>データ切り捨てが発生しました</td></tr></tbody></table></div><p>
        切り捨てレポートが有効にされている場合、<code class="literal">MYSQL_DATA_TRUNCATED</code> が返されます。この値が返されたときに、どのカラム値が切り捨てられたか判断するには、値をフェッチするために使用された <code class="literal">MYSQL_BIND</code> 構造の <code class="literal">error</code> メンバーをチェックします。切り捨てのレポートはデフォルトで有効ですが、<code class="literal">MYSQL_REPORT_DATA_TRUNCATION</code> オプションを使用して <code class="literal">mysql_options()</code> を呼び出すことによって制御できます。
      </p><h5><a name="idm139978999594160"></a>エラー</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_COMMANDS_OUT_OF_SYNC</code>
          </p><p>
            コマンドが正しくない順番で実行されました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_OUT_OF_MEMORY</code>
          </p><p>
            メモリー不足。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_GONE_ERROR</code>
          </p><p>
            MySQL サーバーが存在しなくなりました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_LOST</code>
          </p><p>
            サーバーへの接続がクエリー中に失われました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_UNKNOWN_ERROR</code>
          </p><p>
            不明なエラーが発生しました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_UNSUPPORTED_PARAM_TYPE</code>
          </p><p>
            バッファー型は、<code class="literal">MYSQL_TYPE_DATE</code>、<code class="literal">MYSQL_TYPE_TIME</code>、<code class="literal">MYSQL_TYPE_DATETIME</code>、<code class="literal">MYSQL_TYPE_TIMESTAMP</code> ですが、データ型は <code class="literal">DATE</code>、<code class="literal">TIME</code>、<code class="literal">DATETIME</code>、または <code class="literal">TIMESTAMP</code> ではありません。
          </p></li><li class="listitem"><p>
            サポートされていないほかのすべての変換エラーは、<code class="literal">mysql_stmt_bind_result()</code> から返されます。
          </p></li></ul></div><h5><a name="idm139978999570496"></a>例</h5><p>
        次の例は、<code class="literal">mysql_stmt_result_metadata()</code>、<code class="literal">mysql_stmt_bind_result()</code>、および <code class="literal">mysql_stmt_fetch()</code> を使用して、テーブルからデータをフェッチする方法を示します。(この例は <a class="xref" href="connectors-apis.html#mysql-stmt-execute" title="23.8.11.10 mysql_stmt_execute()">セクション23.8.11.10「mysql_stmt_execute()」</a> に示す例によって挿入された 2 つの行を取得することを期待します)。<code class="literal">mysql</code> 変数は有効な接続ハンドルであるとみなされます。
      </p><pre class="programlisting">
#define STRING_SIZE 50

#define SELECT_SAMPLE "SELECT col1, col2, col3, col4 \
                       FROM test_table"

MYSQL_STMT    *stmt;
MYSQL_BIND    bind[4];
MYSQL_RES     *prepare_meta_result;
MYSQL_TIME    ts;
unsigned long length[4];
int           param_count, column_count, row_count;
short         small_data;
int           int_data;
char          str_data[STRING_SIZE];
my_bool       is_null[4];
my_bool       error[4];

/* Prepare a SELECT query to fetch data from test_table */
stmt = mysql_stmt_init(mysql);
if (!stmt)
{
  fprintf(stderr, " mysql_stmt_init(), out of memory\n");
  exit(0);
}
if (mysql_stmt_prepare(stmt, SELECT_SAMPLE, strlen(SELECT_SAMPLE)))
{
  fprintf(stderr, " mysql_stmt_prepare(), SELECT failed\n");
  fprintf(stderr, " %s\n", mysql_stmt_error(stmt));
  exit(0);
}
fprintf(stdout, " prepare, SELECT successful\n");

/* Get the parameter count from the statement */
param_count= mysql_stmt_param_count(stmt);
fprintf(stdout, " total parameters in SELECT: %d\n", param_count);

if (param_count != 0) /* validate parameter count */
{
  fprintf(stderr, " invalid parameter count returned by MySQL\n");
  exit(0);
}

/* Fetch result set meta information */
prepare_meta_result = mysql_stmt_result_metadata(stmt);
if (!prepare_meta_result)
{
  fprintf(stderr,
         " mysql_stmt_result_metadata(), \
           returned no meta information\n");
  fprintf(stderr, " %s\n", mysql_stmt_error(stmt));
  exit(0);
}

/* Get total columns in the query */
column_count= mysql_num_fields(prepare_meta_result);
fprintf(stdout,
        " total columns in SELECT statement: %d\n",
        column_count);

if (column_count != 4) /* validate column count */
{
  fprintf(stderr, " invalid column count returned by MySQL\n");
  exit(0);
}

/* Execute the SELECT query */
if (mysql_stmt_execute(stmt))
{
  fprintf(stderr, " mysql_stmt_execute(), failed\n");
  fprintf(stderr, " %s\n", mysql_stmt_error(stmt));
  exit(0);
}

/* Bind the result buffers for all 4 columns before fetching them */

memset(bind, 0, sizeof(bind));

/* INTEGER COLUMN */
bind[0].buffer_type= MYSQL_TYPE_LONG;
bind[0].buffer= (char *)&amp;int_data;
bind[0].is_null= &amp;is_null[0];
bind[0].length= &amp;length[0];
bind[0].error= &amp;error[0];

/* STRING COLUMN */
bind[1].buffer_type= MYSQL_TYPE_STRING;
bind[1].buffer= (char *)str_data;
bind[1].buffer_length= STRING_SIZE;
bind[1].is_null= &amp;is_null[1];
bind[1].length= &amp;length[1];
bind[1].error= &amp;error[1];

/* SMALLINT COLUMN */
bind[2].buffer_type= MYSQL_TYPE_SHORT;
bind[2].buffer= (char *)&amp;small_data;
bind[2].is_null= &amp;is_null[2];
bind[2].length= &amp;length[2];
bind[2].error= &amp;error[2];

/* TIMESTAMP COLUMN */
bind[3].buffer_type= MYSQL_TYPE_TIMESTAMP;
bind[3].buffer= (char *)&amp;ts;
bind[3].is_null= &amp;is_null[3];
bind[3].length= &amp;length[3];
bind[3].error= &amp;error[3];

/* Bind the result buffers */
if (mysql_stmt_bind_result(stmt, bind))
{
  fprintf(stderr, " mysql_stmt_bind_result() failed\n");
  fprintf(stderr, " %s\n", mysql_stmt_error(stmt));
  exit(0);
}

/* Now buffer all results to client (optional step) */
if (mysql_stmt_store_result(stmt))
{
  fprintf(stderr, " mysql_stmt_store_result() failed\n");
  fprintf(stderr, " %s\n", mysql_stmt_error(stmt));
  exit(0);
}

/* Fetch all rows */
row_count= 0;
fprintf(stdout, "Fetching results ...\n");
while (!mysql_stmt_fetch(stmt))
{
  row_count++;
  fprintf(stdout, "  row %d\n", row_count);

  /* column 1 */
  fprintf(stdout, "   column1 (integer)  : ");
  if (is_null[0])
    fprintf(stdout, " NULL\n");
  else
    fprintf(stdout, " %d(%ld)\n", int_data, length[0]);

  /* column 2 */
  fprintf(stdout, "   column2 (string)   : ");
  if (is_null[1])
    fprintf(stdout, " NULL\n");
  else
    fprintf(stdout, " %s(%ld)\n", str_data, length[1]);

  /* column 3 */
  fprintf(stdout, "   column3 (smallint) : ");
  if (is_null[2])
    fprintf(stdout, " NULL\n");
  else
    fprintf(stdout, " %d(%ld)\n", small_data, length[2]);

  /* column 4 */
  fprintf(stdout, "   column4 (timestamp): ");
  if (is_null[3])
    fprintf(stdout, " NULL\n");
  else
    fprintf(stdout, " %04d-%02d-%02d %02d:%02d:%02d (%ld)\n",
                     ts.year, ts.month, ts.day,
                     ts.hour, ts.minute, ts.second,
                     length[3]);
  fprintf(stdout, "\n");
}

/* Validate rows fetched */
fprintf(stdout, " total rows fetched: %d\n", row_count);
if (row_count != 2)
{
  fprintf(stderr, " MySQL failed to return all rows\n");
  exit(0);
}

/* Free the prepared result metadata */
mysql_free_result(prepare_meta_result);


/* Close the statement */
if (mysql_stmt_close(stmt))
{
  fprintf(stderr, " failed while closing the statement\n");
  fprintf(stderr, " %s\n", mysql_stmt_error(stmt));
  exit(0);
}
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-fetch-column"></a>23.8.11.12 mysql_stmt_fetch_column()</h4></div></div></div><a class="indexterm" name="idm139978999550208"></a><p>
        <code class="literal">int mysql_stmt_fetch_column(MYSQL_STMT *stmt, MYSQL_BIND *bind, unsigned int column, unsigned long offset)</code>
      </p><h5><a name="idm139978999547584"></a>説明</h5><p>
        現在の結果セット行から 1 つのカラムをフェッチします。<code class="literal">bind</code> はデータを配置すべきバッファーを提供します。それは <code class="literal">mysql_stmt_bind_result()</code> の場合と同じように設定してください。<code class="literal">column</code> はフェッチするカラムを示します。最初のカラムは 0 と番号付けされます。<code class="literal">offset</code> はデータの取得を開始するデータ値内のオフセットです。これはデータ値を個々にフェッチするために使用できます。値の開始はオフセット 0 です。
      </p><h5><a name="idm139978999542320"></a>戻り値</h5><p>
        成功の場合はゼロ。エラーが発生した場合、ゼロ以外。
      </p><h5><a name="idm139978999541056"></a>エラー</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_INVALID_PARAMETER_NO</code>
          </p><p>
            無効なカラム番号。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_NO_DATA</code>
          </p><p>
            結果セットの末尾にすでに達しています。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-field-count"></a>23.8.11.13 mysql_stmt_field_count()</h4></div></div></div><a class="indexterm" name="idm139978999534256"></a><p>
        <code class="literal">unsigned int mysql_stmt_field_count(MYSQL_STMT *stmt)</code>
      </p><h5><a name="idm139978999531696"></a>説明</h5><p>
        ステートメントハンドラの最近のステートメントのカラムの数を返します。この値は、結果セットを生成しない <code class="literal">INSERT</code> または <code class="literal">DELETE</code> などのステートメントの場合ゼロです。
      </p><p>
        <code class="literal">mysql_stmt_prepare()</code> を呼び出して、ステートメントを準備したあとに、<code class="literal">mysql_stmt_field_count()</code> を呼び出すことができます。
      </p><h5><a name="idm139978999525600"></a>戻り値</h5><p>
        結果セット内のカラムの数を表す符号なし整数。
      </p><h5><a name="idm139978999524352"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-free-result"></a>23.8.11.14 mysql_stmt_free_result()</h4></div></div></div><a class="indexterm" name="idm139978999522000"></a><p>
        <code class="literal">my_bool mysql_stmt_free_result(MYSQL_STMT *stmt)</code>
      </p><h5><a name="idm139978999519440"></a>説明</h5><p>
        プリペアドステートメントの実行によって生成された結果セットに関連付けられたメモリーを解放します。ステートメントに開いているカーソルがある場合、<code class="literal">mysql_stmt_free_result()</code> はそれを閉じます。
      </p><h5><a name="idm139978999516848"></a>戻り値</h5><p>
        成功の場合はゼロ。エラーが発生した場合、ゼロ以外。
      </p><h5><a name="idm139978999515584"></a>エラー</h5></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-init"></a>23.8.11.15 mysql_stmt_init()</h4></div></div></div><a class="indexterm" name="idm139978999513728"></a><p>
        <code class="literal">MYSQL_STMT *mysql_stmt_init(MYSQL *mysql)</code>
      </p><h5><a name="idm139978999511168"></a>説明</h5><p>
        <code class="literal">MYSQL_STMT</code> ハンドルを作成します。ハンドルは <code class="literal">mysql_stmt_close(MYSQL_STMT *)</code> で解放してください。
      </p><p>
        詳細については、<a class="xref" href="connectors-apis.html#c-api-prepared-statement-data-structures" title="23.8.9 C API プリペアドステートメントデータ構造">セクション23.8.9「C API プリペアドステートメントデータ構造」</a>も参照してください。
      </p><h5><a name="idm139978999506944"></a>戻り値</h5><p>
        成功した場合は <code class="literal">MYSQL_STMT</code> 構造へのポインタ。メモリー不足の場合は <code class="literal">NULL</code>。
      </p><h5><a name="idm139978999504256"></a>エラー</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_OUT_OF_MEMORY</code>
          </p><p>
            メモリー不足。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-insert-id"></a>23.8.11.16 mysql_stmt_insert_id()</h4></div></div></div><a class="indexterm" name="idm139978999499856"></a><p>
        <code class="literal">my_ulonglong mysql_stmt_insert_id(MYSQL_STMT *stmt)</code>
      </p><h5><a name="idm139978999497280"></a>説明</h5><p>
        プリペアド <code class="literal">INSERT</code> または <code class="literal">UPDATE</code> ステートメントによって、<code class="literal">AUTO_INCREMENT</code> カラムに生成された値を返します。<code class="literal">AUTO_INCREMENT</code> フィールドを含むテーブルに対して、プリペアド <code class="literal">INSERT</code> ステートメントを実行したあとに、この関数を使用します。
      </p><p>
        詳細については、<a class="xref" href="connectors-apis.html#mysql-insert-id" title="23.8.7.37 mysql_insert_id()">セクション23.8.7.37「mysql_insert_id()」</a>を参照してください。
      </p><h5><a name="idm139978999490112"></a>戻り値</h5><p>
        プリペアドステートメントの実行中に自動的に生成されたか明示的に設定された <code class="literal">AUTO_INCREMENT</code> カラムの値、または <code class="literal">LAST_INSERT_ID(<em class="replaceable"><code>expr</code></em>)</code> 関数によって生成された値。ステートメントで <code class="literal">AUTO_INCREMENT</code> 値を設定しない場合、戻り値は不定になります。
      </p><h5><a name="idm139978999484768"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-next-result"></a>23.8.11.17 mysql_stmt_next_result()</h4></div></div></div><a class="indexterm" name="idm139978999482416"></a><p>
        <code class="literal">int mysql_stmt_next_result(MYSQL_STMT *mysql)</code>
      </p><h5><a name="idm139978999479856"></a>説明</h5><p>
        この関数は、複数の結果セットを返すことができるプリペアド <code class="literal">CALL</code> ステートメントを使用して、ストアドプロシージャーを実行する場合に使用します。<code class="literal">mysql_stmt_next_result()</code> を呼び出すループを使用して、それ以上の結果があるかどうかを判断します。プロシージャーに <code class="literal">OUT</code> または <code class="literal">INOUT</code> パラメータがある場合、それらの値はほかの結果セットに続いて、単一の行結果セットとして返されます。値は、プロシージャーパラメータリストに宣言されている順番で表示されます。
      </p><p>
        <code class="literal">mysql_stmt_next_result()</code> はそれ以上の結果が存在するかどうかを示すステータスを返します。<code class="literal">mysql_stmt_next_result()</code> がエラーを返した場合、それ以上の結果はありません。
      </p><p>
        <code class="literal">mysql_stmt_next_result()</code> の各呼び出しの前に、現在の結果で結果セット (結果のステータスだけでなく) が生成された場合、現在の結果に対して <code class="literal">mysql_stmt_free_result()</code> を呼び出す必要があります。
      </p><p>
        <code class="literal">mysql_stmt_next_result()</code> を呼び出したあとの接続の状態は、<code class="literal">mysql_stmt_execute()</code> を呼び出した場合のようになります。このことは、<code class="literal">mysql_stmt_bind_result()</code>、<code class="literal">mysql_stmt_affected_rows()</code> などを呼び出すことができることを意味します。
      </p><p>
        <code class="literal">mysql_more_results()</code> を呼び出して、それ以上の結果があるかどうかをテストすることもできます。ただし、この関数は接続の状態を変更しないため、それが true を返した場合は、さらに <code class="literal">mysql_stmt_next_result()</code> を呼び出して、次の結果に進む必要があります。
      </p><p>
        <code class="literal">mysql_stmt_next_result()</code> の使用方法を示す例については、<a class="xref" href="connectors-apis.html#c-api-prepared-call-statements" title="23.8.20 C API のプリペアド CALL ステートメントのサポート">セクション23.8.20「C API のプリペアド CALL ステートメントのサポート」</a>を参照してください。
      </p><h5><a name="idm139978999458832"></a>戻り値</h5><div class="informaltable"><table summary="この表では、mysql_stmt_next_result() の戻り値を一覧表示し、各値について説明します。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">戻り値</th><th scope="col">説明</th></tr></thead><tbody><tr><td scope="row">0</td><td>成功し、それ以上の結果が存在します</td></tr><tr><td scope="row">-1</td><td>成功し、それ以上の結果が存在しません</td></tr><tr><td scope="row">0 より大きい</td><td>エラーが発生しました</td></tr></tbody></table></div><h5><a name="idm139978999448544"></a>エラー</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_COMMANDS_OUT_OF_SYNC</code>
          </p><p>
            コマンドが正しくない順番で実行されました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_GONE_ERROR</code>
          </p><p>
            MySQL サーバーが存在しなくなりました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_LOST</code>
          </p><p>
            サーバーへの接続がクエリー中に失われました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_UNKNOWN_ERROR</code>
          </p><p>
            不明なエラーが発生しました。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-num-rows"></a>23.8.11.18 mysql_stmt_num_rows()</h4></div></div></div><a class="indexterm" name="idm139978999437152"></a><p>
        <code class="literal">my_ulonglong mysql_stmt_num_rows(MYSQL_STMT *stmt)</code>
      </p><h5><a name="idm139978999434576"></a>説明</h5><p>
        結果セット内の行数を返します。
      </p><p>
        <code class="literal">mysql_stmt_num_rows()</code> の使用は、ステートメントハンドルに結果セット全体をバッファーするために、<code class="literal">mysql_stmt_store_result()</code> を使用したどうかによって異なります。<code class="literal">mysql_stmt_store_result()</code> を使用した場合、<code class="literal">mysql_stmt_num_rows()</code> をただちに呼び出すことができます。そうでない場合、行をフェッチしながら、それをカウントしないかぎり、行カウントは使用できません。
      </p><p>
        <code class="literal">mysql_stmt_num_rows()</code> は <code class="literal">SELECT</code> などの結果セットを返すステートメントと一緒に使用することを意図しています。<code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、または <code class="literal">DELETE</code> などのステートメントでは、影響を受けた行の数を <code class="literal">mysql_stmt_affected_rows()</code> で取得できます。
      </p><h5><a name="idm139978999421520"></a>戻り値</h5><p>
        結果セット内の行数。
      </p><h5><a name="idm139978999420336"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-param-count"></a>23.8.11.19 mysql_stmt_param_count()</h4></div></div></div><a class="indexterm" name="idm139978999417984"></a><p>
        <code class="literal">unsigned long mysql_stmt_param_count(MYSQL_STMT *stmt)</code>
      </p><h5><a name="idm139978999415424"></a>説明</h5><p>
        プリペアドステートメントに存在するパラメータマーカーの数を返します。
      </p><h5><a name="idm139978999414096"></a>戻り値</h5><p>
        ステートメント内のパラメータ数を表す符号なし long 整数。
      </p><h5><a name="idm139978999412816"></a>エラー</h5><p>
        なし。
      </p><h5><a name="idm139978999411680"></a>例</h5><p>
        <a class="xref" href="connectors-apis.html#mysql-stmt-execute" title="23.8.11.10 mysql_stmt_execute()">セクション23.8.11.10「mysql_stmt_execute()」</a>の例を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-param-metadata"></a>23.8.11.20 mysql_stmt_param_metadata()</h4></div></div></div><a class="indexterm" name="idm139978999408704"></a><p>
        <code class="literal">MYSQL_RES *mysql_stmt_param_metadata(MYSQL_STMT *stmt)</code>
      </p><p>
        この関数は現在何もしません。
      </p><h5><a name="idm139978999405632"></a>説明</h5><h5><a name="idm139978999404944"></a>戻り値</h5><h5><a name="idm139978999404256"></a>エラー</h5></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-prepare"></a>23.8.11.21 mysql_stmt_prepare()</h4></div></div></div><a class="indexterm" name="idm139978999402400"></a><p>
        <code class="literal">int mysql_stmt_prepare(MYSQL_STMT *stmt, const char *stmt_str, unsigned long length)</code>
      </p><h5><a name="idm139978999399808"></a>説明</h5><p>
        <code class="literal">mysql_stmt_init()</code> によってステートメントハンドルが返されるとすると、文字列 <code class="literal">stmt_str</code> によって指示される SQL ステートメントを準備し、ステータス値を返します。文字列の長さは <code class="literal">length</code> 引数によって指定してください。文字列は 1 つの SQL ステートメントで構成されている必要があります。ステートメントに終端のセミコロン (<span class="quote">「<span class="quote"><code class="literal">;</code></span>」</span>) または <code class="literal">\g</code> を追加しないでください。
      </p><p>
        アプリケーションでは、疑問符 (<code class="literal">?</code>) 文字を SQL 文字列の適切な位置に埋め込むことによって、1 つまたは複数のパラメータマーカーを SQL ステートメントに含めることができます。
      </p><p>
        マーカーは SQL ステートメント内の特定の場所でのみ正当です。たとえば、それらは、<code class="literal">INSERT</code> ステートメントの <code class="literal">VALUES()</code> リスト (行のカラム値を指定するため) で、または比較値を指定するために <code class="literal">WHERE</code> 句内のカラムとの比較で使用できます。ただし、それらは識別子 (テーブルまたはカラム名など)、または <code class="literal">=</code> 等号などのバイナリ演算子の両方のオペランドに指定するために使用できません。パラメータの型を判断することは不可能な場合があるため、後者の制限は必要です。一般に、パラメータは Data Manipulation Language (DML) ステートメント内でのみ正当で、Data Definition Language (DDL) ステートメント内では許可されません。
      </p><p>
        パラメータマーカーは、ステートメントを実行する前に <code class="literal">mysql_stmt_bind_param()</code> を使用してアプリケーション変数にバインドされている必要があります。
      </p><p>
        プリペアドステートメントによって参照されているテーブルやビューのメタデータの変更が検出され、それが次に実行されるときに、ステートメントが自動再準備されます。詳細については、<a class="xref" href="optimization.html#statement-caching" title="8.9.4 プリペアドステートメントおよびストアドプログラムのキャッシュ">セクション8.9.4「プリペアドステートメントおよびストアドプログラムのキャッシュ」</a>を参照してください。
      </p><h5><a name="idm139978999384080"></a>戻り値</h5><p>
        成功の場合はゼロ。エラーが発生した場合、ゼロ以外。
      </p><h5><a name="idm139978999382848"></a>エラー</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_COMMANDS_OUT_OF_SYNC</code>
          </p><p>
            コマンドが正しくない順番で実行されました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_OUT_OF_MEMORY</code>
          </p><p>
            メモリー不足。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_GONE_ERROR</code>
          </p><p>
            MySQL サーバーが存在しなくなりました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_LOST</code>
          </p><p>
            クエリー中にサーバーへの接続が失われました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_UNKNOWN_ERROR</code>
          </p><p>
            不明なエラーが発生しました。
          </p></li></ul></div><p>
        準備操作が成功しなかった (つまり、<code class="literal">mysql_stmt_prepare()</code> はゼロ以外を返す) 場合、<code class="literal">mysql_stmt_error()</code> を呼び出して、エラーメッセージを取得できます。
      </p><h5><a name="idm139978999367696"></a>例</h5><p>
        <a class="xref" href="connectors-apis.html#mysql-stmt-execute" title="23.8.11.10 mysql_stmt_execute()">セクション23.8.11.10「mysql_stmt_execute()」</a>の例を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-reset"></a>23.8.11.22 mysql_stmt_reset()</h4></div></div></div><a class="indexterm" name="idm139978999364752"></a><p>
        <code class="literal">my_bool mysql_stmt_reset(MYSQL_STMT *stmt)</code>
      </p><h5><a name="idm139978999362192"></a>説明</h5><p>
        クライアントおよびサーバーでプリペアドステートメントを準備後の状態にリセットします。それは、サーバー上のステートメント、<code class="literal">mysql_stmt_send_long_data()</code> を使用して送信されたデータ、バッファーされていない結果セット、および現在のエラーをリセットします。それは、バインディングまたは保存された結果セットはクリアしません。保存された結果セットは、プリペアドステートメントを実行した (またはそれを閉じた) ときにクリアされます。
      </p><p>
        別のクエリーでステートメントを再準備するには、<code class="literal">mysql_stmt_prepare()</code> を使用します。
      </p><h5><a name="idm139978999357520"></a>戻り値</h5><p>
        成功の場合はゼロ。エラーが発生した場合、ゼロ以外。
      </p><h5><a name="idm139978999356256"></a>エラー</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_COMMANDS_OUT_OF_SYNC</code>
          </p><p>
            コマンドが正しくない順番で実行されました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_GONE_ERROR</code>
          </p><p>
            MySQL サーバーが存在しなくなりました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_LOST</code>
          </p><p>
            クエリー中にサーバーへの接続が失われました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_UNKNOWN_ERROR</code>
          </p><p>
            不明なエラーが発生しました。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-result-metadata"></a>23.8.11.23 mysql_stmt_result_metadata()</h4></div></div></div><a class="indexterm" name="idm139978999344864"></a><p>
        <code class="literal">MYSQL_RES *mysql_stmt_result_metadata(MYSQL_STMT *stmt)</code>
      </p><h5><a name="idm139978999342272"></a>説明</h5><p>
        <code class="literal">mysql_stmt_prepare()</code> に渡されたステートメントが結果セットを生成するステートメントである場合、<code class="literal">mysql_stmt_result_metadata()</code> は、フィールド数や個々のフィールド情報などのメタ情報を処理するために使用できる <code class="literal">MYSQL_RES</code> 構造へのポインタの形式で、結果セットメタデータを返します。この結果セットポインタは引数として、次のような結果セットメタデータを処理する任意のフィールドベースの API 関数に渡すことができます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">mysql_num_fields()</code>
          </p></li><li class="listitem"><p>
            <code class="literal">mysql_fetch_field()</code>
          </p></li><li class="listitem"><p>
            <code class="literal">mysql_fetch_field_direct()</code>
          </p></li><li class="listitem"><p>
            <code class="literal">mysql_fetch_fields()</code>
          </p></li><li class="listitem"><p>
            <code class="literal">mysql_field_count()</code>
          </p></li><li class="listitem"><p>
            <code class="literal">mysql_field_seek()</code>
          </p></li><li class="listitem"><p>
            <code class="literal">mysql_field_tell()</code>
          </p></li><li class="listitem"><p>
            <code class="literal">mysql_free_result()</code>
          </p></li></ul></div><p>
        結果セット構造は、その処理を終了したら解放してください。これは、<code class="literal">mysql_free_result()</code> にそれを渡すことによって実行できます。これは、<code class="literal">mysql_store_result()</code> への呼び出しから取得した結果セットを解放する方法に似ています。
      </p><p>
        <code class="literal">mysql_stmt_result_metadata()</code> によって返される結果セットにはメタデータだけが含まれます。それは行の結果を含んでいません。行は、<code class="literal">mysql_stmt_fetch()</code> によってステートメントハンドルを使用して取得します。
      </p><h5><a name="idm139978999317536"></a>戻り値</h5><p>
        <code class="literal">MYSQL_RES</code>結果構造。プリペアドクエリーにメタ情報が存在しない場合は <code class="literal">NULL</code>。
      </p><h5><a name="idm139978999314960"></a>エラー</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_OUT_OF_MEMORY</code>
          </p><p>
            メモリー不足。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_UNKNOWN_ERROR</code>
          </p><p>
            不明なエラーが発生しました。
          </p></li></ul></div><h5><a name="idm139978999309408"></a>例</h5><p>
        <a class="xref" href="connectors-apis.html#mysql-stmt-fetch" title="23.8.11.11 mysql_stmt_fetch()">セクション23.8.11.11「mysql_stmt_fetch()」</a>の例を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-row-seek"></a>23.8.11.24 mysql_stmt_row_seek()</h4></div></div></div><a class="indexterm" name="idm139978999306528"></a><p>
        <code class="literal">MYSQL_ROW_OFFSET mysql_stmt_row_seek(MYSQL_STMT *stmt, MYSQL_ROW_OFFSET offset)</code>
      </p><h5><a name="idm139978999303920"></a>説明</h5><p>
        ステートメント結果セット内の任意の行に行カーソルを設定します。<code class="literal">offset</code> 値は、<code class="literal">mysql_stmt_row_tell()</code> または <code class="literal">mysql_stmt_row_seek()</code> から返される値になるべきである行オフセットです。この値は行番号ではありません。番号によって結果セット内の行にシークする場合は、代わりに <code class="literal">mysql_stmt_data_seek()</code> を使用します。
      </p><p>
        この関数は、結果セット構造にクエリーの結果全体を含める必要があるため、<code class="literal">mysql_stmt_row_seek()</code> は、<code class="literal">mysql_stmt_store_result()</code> と一緒にのみ使用できます。
      </p><h5><a name="idm139978999295792"></a>戻り値</h5><p>
        行カーソルの前の値。この値は、<code class="literal">mysql_stmt_row_seek()</code> への後続の呼び出しに渡すことができます。
      </p><h5><a name="idm139978999293472"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-row-tell"></a>23.8.11.25 mysql_stmt_row_tell()</h4></div></div></div><a class="indexterm" name="idm139978999291168"></a><p>
        <code class="literal">MYSQL_ROW_OFFSET mysql_stmt_row_tell(MYSQL_STMT *stmt)</code>
      </p><h5><a name="idm139978999288592"></a>説明</h5><p>
        最後の <code class="literal">mysql_stmt_fetch()</code> の行カーソルの現在の位置を返します。この値は、<code class="literal">mysql_stmt_row_seek()</code> への引数として使うことができます。
      </p><p>
        <code class="literal">mysql_stmt_row_tell()</code> は、<code class="literal">mysql_stmt_store_result()</code> のあとにのみ使用してください。
      </p><h5><a name="idm139978999282784"></a>戻り値</h5><p>
        行カーソルの現在のオフセット。
      </p><h5><a name="idm139978999281568"></a>エラー</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-send-long-data"></a>23.8.11.26 mysql_stmt_send_long_data()</h4></div></div></div><a class="indexterm" name="idm139978999279264"></a><p>
        <code class="literal">my_bool mysql_stmt_send_long_data(MYSQL_STMT *stmt, unsigned int parameter_number, const char *data, unsigned long length)</code>
      </p><h5><a name="idm139978999276592"></a>説明</h5><p>
        アプリケーションはパラメータデータをサーバーに個々に (または<span class="quote">「<span class="quote">まとめて</span>」</span>) 送信できます。この関数は <code class="literal">mysql_stmt_bind_param()</code> のあと、かつ <code class="literal">mysql_stmt_execute()</code> の前に呼び出します。それを複数回呼び出して、カラムの文字の一部またはバイナリデータ値を送信できますが、これは <code class="literal">TEXT</code> または <code class="literal">BLOB</code> データ型のいずれかである必要があります。
      </p><p>
        <code class="literal">parameter_number</code> はデータを関連付けるパラメータを示します。パラメータは 0 から番号付けされます。<code class="literal">data</code> は送信されるデータを格納するバッファーへのポインタで、<code class="literal">length</code> はバッファー内のバイト数を示します。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          次の <code class="literal">mysql_stmt_execute()</code> 呼び出しは、最後の <code class="literal">mysql_stmt_execute()</code> または <code class="literal">mysql_stmt_reset()</code> から、<code class="literal">mysql_stmt_send_long_data()</code> によって使用されたすべてのパラメータのバインドバッファーを無視します。
        </p></div><p>
        送信されたデータをリセット/消去する場合、<code class="literal">mysql_stmt_reset()</code> によってそれを実行できます。<a class="xref" href="connectors-apis.html#mysql-stmt-reset" title="23.8.11.22 mysql_stmt_reset()">セクション23.8.11.22「mysql_stmt_reset()」</a>を参照してください。
      </p><p>
        MySQL 5.6.3 以降、<code class="literal">max_allowed_packet</code> システム変数は、<code class="literal">mysql_stmt_send_long_data()</code> によって送信できるパラメータ値の最大サイズを制御します。
      </p><h5><a name="idm139978999257184"></a>戻り値</h5><p>
        成功の場合はゼロ。エラーが発生した場合、ゼロ以外。
      </p><h5><a name="idm139978999255920"></a>エラー</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_INVALID_BUFFER_USE</code>
          </p><p>
            このパラメータは文字列またはバイナリ型は持ちません。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_COMMANDS_OUT_OF_SYNC</code>
          </p><p>
            コマンドが正しくない順番で実行されました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_GONE_ERROR</code>
          </p><p>
            MySQL サーバーが存在しなくなりました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_OUT_OF_MEMORY</code>
          </p><p>
            メモリー不足。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_UNKNOWN_ERROR</code>
          </p><p>
            不明なエラーが発生しました。
          </p></li></ul></div><h5><a name="idm139978999243440"></a>例</h5><p>
        次の例に、<code class="literal">TEXT</code> カラムのデータをまとめて送信する方法を示します。それはデータ値 <code class="literal">'MySQL - The most popular Open Source database'</code> を <code class="literal">text_column</code> カラムに挿入します。<code class="literal">mysql</code> 変数は有効な接続ハンドルであるとみなされます。
      </p><pre class="programlisting">
#define INSERT_QUERY "INSERT INTO \
                      test_long_data(text_column) VALUES(?)"

MYSQL_BIND bind[1];
long       length;

stmt = mysql_stmt_init(mysql);
if (!stmt)
{
  fprintf(stderr, " mysql_stmt_init(), out of memory\n");
  exit(0);
}
if (mysql_stmt_prepare(stmt, INSERT_QUERY, strlen(INSERT_QUERY)))
{
  fprintf(stderr, "\n mysql_stmt_prepare(), INSERT failed");
  fprintf(stderr, "\n %s", mysql_stmt_error(stmt));
  exit(0);
}
 memset(bind, 0, sizeof(bind));
 bind[0].buffer_type= MYSQL_TYPE_STRING;
 bind[0].length= &amp;length;
 bind[0].is_null= 0;

/* Bind the buffers */
if (mysql_stmt_bind_param(stmt, bind))
{
  fprintf(stderr, "\n param bind failed");
  fprintf(stderr, "\n %s", mysql_stmt_error(stmt));
  exit(0);
}

 /* Supply data in chunks to server */
 if (mysql_stmt_send_long_data(stmt,0,"MySQL",5))
{
  fprintf(stderr, "\n send_long_data failed");
  fprintf(stderr, "\n %s", mysql_stmt_error(stmt));
  exit(0);
}

 /* Supply the next piece of data */
 if (mysql_stmt_send_long_data(stmt,0,
           " - The most popular Open Source database",40))
{
  fprintf(stderr, "\n send_long_data failed");
  fprintf(stderr, "\n %s", mysql_stmt_error(stmt));
  exit(0);
}

 /* Now, execute the query */
 if (mysql_stmt_execute(stmt))
{
  fprintf(stderr, "\n mysql_stmt_execute failed");
  fprintf(stderr, "\n %s", mysql_stmt_error(stmt));
  exit(0);
}
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-sqlstate"></a>23.8.11.27 mysql_stmt_sqlstate()</h4></div></div></div><a class="indexterm" name="idm139978999233136"></a><p>
        <code class="literal">const char *mysql_stmt_sqlstate(MYSQL_STMT *stmt)</code>
      </p><h5><a name="idm139978999230576"></a>説明</h5><p>
        <code class="literal">stmt</code> によって指定されたステートメントに対して、<code class="literal">mysql_stmt_sqlstate()</code> は最近呼び出された成功または失敗した可能性のあるプリペアドステートメント API 関数の SQLSTATE エラーコードを格納する NULL 終端文字列を返します。エラーコードは 5 つの文字から構成されます。<code class="literal">"00000"</code> は<span class="quote">「<span class="quote">エラーなし</span>」</span>を意味します。値は ANSI SQL と ODBC によって規定されています。可能な値のリストについては、<a class="xref" href="error-handling.html" title="付録 B エラー、エラーコード、および一般的な問題">付録B <i>エラー、エラーコード、および一般的な問題</i></a>を参照してください。
      </p><p>
        すべての MySQL エラーがまだ SQLSTATE コードにマップされていません。値 <code class="literal">"HY000"</code> (一般エラー) はマップされていないエラー番号に使われます。
      </p><h5><a name="idm139978999223680"></a>戻り値</h5><p>
        SQLSTATE エラーコードを含む NULL 終端文字列。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-stmt-store-result"></a>23.8.11.28 mysql_stmt_store_result()</h4></div></div></div><a class="indexterm" name="idm139978999221264"></a><p>
        <code class="literal">int mysql_stmt_store_result(MYSQL_STMT *stmt)</code>
      </p><h5><a name="idm139978999218704"></a>説明</h5><p>
        結果セットは、<code class="literal">SELECT</code>、<code class="literal">SHOW</code>、<code class="literal">DESCRIBE</code>、および <code class="literal">EXPLAIN</code> などの SQL ステートメントの実行されたプリペアドステートメントに対し、<code class="literal">mysql_stmt_execute()</code> を呼び出して生成されます。デフォルトで、正常に実行されたプリペアドステートメントの結果セットは、クライアントでバッファーされず、<code class="literal">mysql_stmt_fetch()</code> はそれらをサーバーから一度に 1 つずつフェッチします。クライアントで完全な結果セットをバッファーさせるには、<code class="literal">mysql_stmt_bind_result()</code> によってデータバッファーをバインドしたあと、かつ <code class="literal">mysql_stmt_fetch()</code> を呼び出して行をフェッチする前に <code class="literal">mysql_stmt_store_result()</code> を呼び出します。(例については、<a class="xref" href="connectors-apis.html#mysql-stmt-fetch" title="23.8.11.11 mysql_stmt_fetch()">セクション23.8.11.11「mysql_stmt_fetch()」</a>を参照してください。)
      </p><p>
        <code class="literal">mysql_stmt_data_seek()</code>、<code class="literal">mysql_stmt_row_seek()</code>、または <code class="literal">mysql_stmt_row_tell()</code> を呼び出さないかぎり、<code class="literal">mysql_stmt_store_result()</code> は結果セットの処理にオプションです。それらの関数ではシーク可能な結果セットが必要です。
      </p><p>
        結果セットを生成しない SQL ステートメントの実行後に、<code class="literal">mysql_stmt_store_result()</code> を呼び出す必要はありませんが、そうした場合に、損害を与えたり、目立ったパフォーマンスの問題を発生させたりすることはありません。<code class="literal">mysql_stmt_result_metadata()</code> が <code class="literal">NULL</code> を返すかどうかをチェックすることによって、ステートメントが結果セットを生成したかどうかを検出できます。詳細については、<a class="xref" href="connectors-apis.html#mysql-stmt-result-metadata" title="23.8.11.23 mysql_stmt_result_metadata()">セクション23.8.11.23「mysql_stmt_result_metadata()」</a>を参照してください。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          MySQL はデフォルトで、<code class="literal">mysql_stmt_store_result()</code> ですべてのカラムの <code class="literal">MYSQL_FIELD-&gt;max_length</code> を計算しません。これを計算すると、<code class="literal">mysql_stmt_store_result()</code> がかなり遅くなることがあり、ほとんどのアプリケーションで <code class="literal">max_length</code> を必要としないためです。<code class="literal">max_length</code> を更新する必要がある場合、<code class="literal">mysql_stmt_attr_set(MYSQL_STMT, STMT_ATTR_UPDATE_MAX_LENGTH, &amp;flag)</code> を呼び出してこれを可能にできます。<a class="xref" href="connectors-apis.html#mysql-stmt-attr-set" title="23.8.11.3 mysql_stmt_attr_set()">セクション23.8.11.3「mysql_stmt_attr_set()」</a>を参照してください。
        </p></div><h5><a name="idm139978999189936"></a>戻り値</h5><p>
        成功の場合はゼロ。エラーが発生した場合、ゼロ以外。
      </p><h5><a name="idm139978999188704"></a>エラー</h5><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CR_COMMANDS_OUT_OF_SYNC</code>
          </p><p>
            コマンドが正しくない順番で実行されました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_OUT_OF_MEMORY</code>
          </p><p>
            メモリー不足。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_GONE_ERROR</code>
          </p><p>
            MySQL サーバーが存在しなくなりました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_SERVER_LOST</code>
          </p><p>
            サーバーへの接続がクエリー中に失われました。
          </p></li><li class="listitem"><p>
            <code class="literal">CR_UNKNOWN_ERROR</code>
          </p><p>
            不明なエラーが発生しました。
          </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-thread-functions"></a>23.8.12 C API スレッド関数の説明</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="connectors-apis.html#my-init">23.8.12.1 my_init()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-thread-end">23.8.12.2 mysql_thread_end()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-thread-init">23.8.12.3 mysql_thread_init()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-thread-safe">23.8.12.4 mysql_thread_safe()</a></span></dt></dl></div><p>
      スレッドクライアントを作成するには、次のセクションで説明する関数を使用します。<a class="xref" href="connectors-apis.html#c-api-threaded-clients" title="23.8.4.2 C API スレッドクライアントプログラムの作成">セクション23.8.4.2「C API スレッドクライアントプログラムの作成」</a>も参照してください。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="my-init"></a>23.8.12.1 my_init()</h4></div></div></div><a class="indexterm" name="idm139978999172416"></a><p>
        <code class="literal">void my_init(void)</code>
      </p><h5><a name="idm139978999169888"></a>説明</h5><p>
        <code class="literal">my_init()</code> は MySQL が必要とするいくつかのグローバル変数を初期化します。それはこのスレッドに対し、<code class="literal">mysql_thread_init()</code> も呼び出します。
      </p><p>
        <code class="literal">my_init()</code> は、プログラムの MySQL ライブラリの使用の初期化フェーズの早期に呼び出される必要があります。ただし、<code class="literal">my_init()</code> は <code class="literal">mysql_init()</code>、<code class="literal">mysql_library_init()</code>、<code class="literal">mysql_server_init()</code>、および <code class="literal">mysql_connect()</code> によって自動的に呼び出されます。プログラムでほかの MySQL 呼び出しの前に、それらの関数のいずれかを確実に呼び出している場合は、<code class="literal">my_init()</code> を明示的に呼び出す必要はありません。
      </p><p>
        <code class="literal">my_init()</code> のプロトタイプにアクセスするには、プログラムにこれらのヘッダーファイルを含めてください。
      </p><pre class="programlisting">
#include &lt;my_global.h&gt;
#include &lt;my_sys.h&gt;
</pre><h5><a name="idm139978999156096"></a>戻り値</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-thread-end"></a>23.8.12.2 mysql_thread_end()</h4></div></div></div><a class="indexterm" name="idm139978999153856"></a><p>
        <code class="literal">void mysql_thread_end(void)</code>
      </p><h5><a name="idm139978999151312"></a>説明</h5><p>
        この関数は、<code class="literal">pthread_exit()</code> を呼び出す前に、<code class="literal">mysql_thread_init()</code> によって割り当てられたメモリーを解放するために呼び出す必要があります。
      </p><p>
        <code class="literal">mysql_thread_end()</code> <span class="emphasis"><em>はクライアントライブラリによって自動的に呼び出されません</em></span>。それはメモリーリークを避けるために明示的に呼び出す必要があります。
      </p><h5><a name="idm139978999146272"></a>戻り値</h5><p>
        なし。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-thread-init"></a>23.8.12.3 mysql_thread_init()</h4></div></div></div><a class="indexterm" name="idm139978999143968"></a><p>
        <code class="literal">my_bool mysql_thread_init(void)</code>
      </p><h5><a name="idm139978999141424"></a>説明</h5><p>
        この関数は、スレッド固有変数を初期化するために、作成された各スレッド内の早期に呼び出す必要があります。ただし、必ずしもそれを明示的に呼び出す必要がないことがあります。<code class="literal">mysql_thread_init()</code> は <code class="literal">my_init()</code> によって自動的に呼び出され、それ自体も <code class="literal">mysql_init()</code>、<code class="literal">mysql_library_init()</code>、<code class="literal">mysql_server_init()</code>、および <code class="literal">mysql_connect()</code> によって自動的に呼び出されます。それらの関数のいずれかを呼び出すと、<code class="literal">mysql_thread_init()</code> が自動的に呼び出されます。
      </p><h5><a name="idm139978999132512"></a>戻り値</h5><p>
        成功の場合はゼロ。エラーが発生した場合、ゼロ以外。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-thread-safe"></a>23.8.12.4 mysql_thread_safe()</h4></div></div></div><a class="indexterm" name="idm139978999130080"></a><p>
        <code class="literal">unsigned int mysql_thread_safe(void)</code>
      </p><h5><a name="idm139978999127536"></a>説明</h5><p>
        この関数は、クライアントライブラリがスレッドセーフとしてコンパイルされるかどうかを示します。
      </p><h5><a name="idm139978999126144"></a>戻り値</h5><p>
        クライアントライブラリがスレッドセーフの場合は 1、それ以外の場合は 0。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-embedded-server-functions"></a>23.8.13 C API 組み込みサーバー関数の説明</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="connectors-apis.html#mysql-server-init">23.8.13.1 mysql_server_init()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-server-end">23.8.13.2 mysql_server_end()</a></span></dt></dl></div><p>
      MySQL アプリケーションは、組み込みサーバーを使うように書くことができます。<a class="xref" href="connectors-apis.html#libmysqld" title="23.7 組み込み MySQL サーバーライブラリ libmysqld">セクション23.7「組み込み MySQL サーバーライブラリ libmysqld」</a>を参照してください。そのようなアプリケーションを書くには、<code class="option">-lmysqlclient</code> フラグを使用して <code class="literal">libmysqlclient</code> クライアントライブラリに対してそれをリンクするのではなく、<code class="option">-lmysqld</code> フラグを使用して <code class="literal">libmysqld</code> ライブラリに対してそれをリンクする必要があります。ただし、クライアントアプリケーションを書くか、組み込みサーバーを使うものを書くかに関係なく、ライブラリを初期化する呼び出しとファイナライズする呼び出しは同じです。ライブラリを初期化するには <code class="literal">mysql_library_init()</code> を呼び出し、その処理が終わったら、<code class="literal">mysql_library_end()</code> を呼び出します。<a class="xref" href="connectors-apis.html#c-api-function-overview" title="23.8.6 C API 関数の概要">セクション23.8.6「C API 関数の概要」</a>を参照してください。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-server-init"></a>23.8.13.1 mysql_server_init()</h4></div></div></div><a class="indexterm" name="idm139978999114992"></a><p>
        <code class="literal">int mysql_server_init(int argc, char **argv, char **groups)</code>
      </p><h5><a name="idm139978999112416"></a>説明</h5><p>
        この関数は MySQL ライブラリを初期化します。これは、ほかのすべての MySQL 関数を呼び出す前に実行する必要があります。ただし、<code class="literal">mysql_server_init()</code> は非推奨であるため、代わりに、<code class="literal">mysql_library_init()</code> を呼び出してください。<a class="xref" href="connectors-apis.html#mysql-library-init" title="23.8.7.40 mysql_library_init()">セクション23.8.7.40「mysql_library_init()」</a>を参照してください。
      </p><h5><a name="idm139978999108128"></a>戻り値</h5><p>
        成功の場合はゼロ。エラーが発生した場合、ゼロ以外。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-server-end"></a>23.8.13.2 mysql_server_end()</h4></div></div></div><a class="indexterm" name="idm139978999105728"></a><p>
        <code class="literal">void mysql_server_end(void)</code>
      </p><h5><a name="idm139978999103184"></a>説明</h5><p>
        この関数は MySQL ライブラリをファイナライズします。これはライブラリの使用を終了したときに実行してください。ただし、<code class="literal">mysql_server_end()</code> は非推奨であるため、代わりに、<code class="literal">mysql_library_end()</code> を使用してください。<a class="xref" href="connectors-apis.html#mysql-library-end" title="23.8.7.39 mysql_library_end()">セクション23.8.7.39「mysql_library_end()」</a>を参照してください。
      </p><h5><a name="idm139978999098912"></a>戻り値</h5><p>
        なし。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-plugin-functions"></a>23.8.14 C API クライアントプラグイン関数</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="connectors-apis.html#mysql-client-find-plugin">23.8.14.1 mysql_client_find_plugin()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-client-register-plugin">23.8.14.2 mysql_client_register_plugin()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-load-plugin">23.8.14.3 mysql_load_plugin()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-load-plugin-v">23.8.14.4 mysql_load_plugin_v()</a></span></dt><dt><span class="section"><a href="connectors-apis.html#mysql-plugin-options">23.8.14.5 mysql_plugin_options()</a></span></dt></dl></div><p>
      このセクションでは、クライアント側プラグイン API に使用される関数について説明します。それらはクライアントプラグインの管理を可能にします。これらの関数によって使用される <code class="literal">st_mysql_client_plugin</code> 構造の説明については、<a class="xref" href="extending-mysql.html#client-plugin-descriptors" title="24.2.4.2.3 クライアントプラグインディスクリプタ">セクション24.2.4.2.3「クライアントプラグインディスクリプタ」</a>を参照してください。
    </p><p>
      クライアントプログラムでこのセクションの関数を呼び出す必要がある可能性はないと考えられます。たとえば、認証プラグインの使用をサポートするクライアントは通常 <code class="literal">mysql_options()</code> を呼び出して、<code class="literal">MYSQL_DEFAULT_AUTH</code> および <code class="literal">MYSQL_PLUGIN_DIR</code> オプションを設定することによって、プラグインをロードさせます。
    </p><pre class="programlisting">
char *plugin_dir = "<em class="replaceable"><code>path_to_plugin_dir</code></em>";
char *default_auth = "<em class="replaceable"><code>plugin_name</code></em>";

/* ... process command-line options ... */

mysql_options(&amp;mysql, MYSQL_PLUGIN_DIR, plugin_dir);
mysql_options(&amp;mysql, MYSQL_DEFAULT_AUTH, default_auth);
</pre><p>
      一般にプログラムは、ユーザーがデフォルト値をオーバーライドできるようにする <code class="option">--plugin-dir</code> および <code class="option">--default-auth</code> オプションも受け付けます。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-client-find-plugin"></a>23.8.14.1 mysql_client_find_plugin()</h4></div></div></div><a class="indexterm" name="idm139978999085600"></a><p>
        <code class="literal">struct st_mysql_client_plugin *mysql_client_find_plugin(MYSQL *mysql, const char *name, int type)</code>
      </p><h5><a name="idm139978999082960"></a>説明</h5><p>
        ロードしたプラグインへのポインタを返し、必要に応じて、最初にプラグインをロードします。型が無効か、プラグインが見つからないかロードできない場合はエラーが発生します。
      </p><p>
        パラメータを次のように指定します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">mysql</code>: <code class="literal">MYSQL</code> 構造へのポインタ。プラグイン API は MySQL サーバーへの接続を必要としませんが、この構造は正しく初期化する必要があります。この構造は、接続関連情報を取得するために使用されます。
          </p></li><li class="listitem"><p>
            <code class="literal">name</code>: プラグイン名。
          </p></li><li class="listitem"><p>
            <code class="literal">type</code>: プラグインの型。
          </p></li></ul></div><h5><a name="idm139978999074656"></a>戻り値</h5><p>
        成功のためのプラグインへのポインタ。エラーが発生した場合は <code class="literal">NULL</code>。
      </p><h5><a name="idm139978999072656"></a>エラー</h5><p>
        エラーをチェックするには、<code class="literal">mysql_error()</code> または <code class="literal">mysql_errno()</code> 関数を呼び出します。<a class="xref" href="connectors-apis.html#mysql-error" title="23.8.7.15 mysql_error()">セクション23.8.7.15「mysql_error()」</a>および<a class="xref" href="connectors-apis.html#mysql-errno" title="23.8.7.14 mysql_errno()">セクション23.8.7.14「mysql_errno()」</a>を参照してください。
      </p><h5><a name="idm139978999068048"></a>例</h5><pre class="programlisting">
MYSQL mysql;
struct st_mysql_client_plugin *p;

if ((p = mysql_client_find_plugin(&amp;mysql, "myplugin",
                                  MYSQL_CLIENT_AUTHENTICATION_PLUGIN, 0)))
{
  printf("Plugin version: %d.%d.%d\n", p-&gt;version[0], p-&gt;version[1], p-&gt;version[2]);
}
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-client-register-plugin"></a>23.8.14.2 mysql_client_register_plugin()</h4></div></div></div><a class="indexterm" name="idm139978999064896"></a><p>
        <code class="literal">struct st_mysql_client_plugin *mysql_client_register_plugin(MYSQL *mysql, struct st_mysql_client_plugin *plugin)</code>
      </p><h5><a name="idm139978999062240"></a>説明</h5><p>
        ロードされたプラグインのリストにプラグイン構造を追加します。プラグインがすでにロードされている場合、エラーが発生します。
      </p><p>
        パラメータを次のように指定します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">mysql</code>: <code class="literal">MYSQL</code> 構造へのポインタ。プラグイン API は MySQL サーバーへの接続を必要としませんが、この構造は正しく初期化する必要があります。この構造は、接続関連情報を取得するために使用されます。
          </p></li><li class="listitem"><p>
            <code class="literal">plugin</code>: プラグイン構造へのポインタ。
          </p></li></ul></div><h5><a name="idm139978999055568"></a>戻り値</h5><p>
        成功のためのプラグインへのポインタ。エラーが発生した場合は <code class="literal">NULL</code>。
      </p><h5><a name="idm139978999053568"></a>エラー</h5><p>
        エラーをチェックするには、<code class="literal">mysql_error()</code> または <code class="literal">mysql_errno()</code> 関数を呼び出します。<a class="xref" href="connectors-apis.html#mysql-error" title="23.8.7.15 mysql_error()">セクション23.8.7.15「mysql_error()」</a>および<a class="xref" href="connectors-apis.html#mysql-errno" title="23.8.7.14 mysql_errno()">セクション23.8.7.14「mysql_errno()」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-load-plugin"></a>23.8.14.3 mysql_load_plugin()</h4></div></div></div><a class="indexterm" name="idm139978999047824"></a><p>
        <code class="literal">struct st_mysql_client_plugin *mysql_load_plugin(MYSQL *mysql, const char *name, int type, int argc, ...)</code>
      </p><h5><a name="idm139978999045200"></a>説明</h5><p>
        名前と型で指定された MySQL クライアントプラグインをロードします。型が無効か、プラグインをロードできない場合はエラーが発生します。
      </p><p>
        同じ型の複数のプラグインをロードすることはできません。すでにロードされている型のプラグインをロードしようとすると、エラーが発生します。
      </p><p>
        パラメータを次のように指定します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">mysql</code>: <code class="literal">MYSQL</code> 構造へのポインタ。プラグイン API は MySQL サーバーへの接続を必要としませんが、この構造は正しく初期化する必要があります。この構造は、接続関連情報を取得するために使用されます。
          </p></li><li class="listitem"><p>
            <code class="literal">name</code>: ロードするプラグインの名前。
          </p></li><li class="listitem"><p>
            <code class="literal">type</code>: ロードするプラグインの型、または型チェックを無効にする場合は −1。型が −1 でない場合、型に一致するプラグインのみがロードに考慮されます。
          </p></li><li class="listitem"><p>
            <code class="literal">argc</code>: 後続の引数の数 (何もない場合は 0)。後続の引数の解釈はプラグインの型によって異なります。
          </p></li></ul></div><a class="indexterm" name="idm139978999034128"></a><a class="indexterm" name="idm139978999032592"></a><p>
        プラグインをロードさせるもう 1 つの方法は、<code class="literal">LIBMYSQL_PLUGINS</code> 環境変数にセミコロン区切りのプラグイン名のリストを設定することです。例:
      </p><pre class="programlisting">
shell&gt; export LIBMYSQL_PLUGINS="myplugin1;myplugin2"
</pre><p>
        クライアントプログラムが <code class="literal">mysql_library_init()</code> を呼び出したときに、<code class="literal">LIBMYSQL_PLUGINS</code> によって指定されたプラグインがロードされます。これらのプラグインのロードで問題が発生した場合、エラーは報告されません。
      </p><a class="indexterm" name="idm139978999025776"></a><a class="indexterm" name="idm139978999024240"></a><p>
        MySQL 5.6.10 以降、<code class="literal">LIBMYSQL_PLUGIN_DIR</code> 環境変数には、クライアントプラグインを探すディレクトリのパス名を設定できます。この変数は 2 つの方法で使用されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            クライアントプラグインのプリロード中、<code class="option">--plugin-dir</code> オプションの値は使用できないため、プラグインが、組み込まれたデフォルトのディレクトリに存在しない場合、クライアントプラグインのロードが失敗します。プラグインがほかの場所に存在する場合は、<code class="literal">LIBMYSQL_PLUGIN_DIR</code> 環境変数を正しいディレクトリに設定し、プラグインのプリロードが成功できるようにします。
          </p></li><li class="listitem"><p>
            明示的なクライアントプラグインのロードで、<code class="literal">mysql_load_plugin()</code> および <code class="literal">mysql_load_plugin_v()</code> C API 関数は <code class="literal">LIBMYSQL_PLUGIN_DIR</code> 値が存在し、<code class="option">--plugin-dir</code> オプションが指定されていない場合は、その値を使用します。<code class="option">--plugin-dir</code> が指定されている場合は、<code class="literal">mysql_load_plugin()</code> と <code class="literal">mysql_load_plugin_v()</code> は <code class="literal">LIBMYSQL_PLUGIN_DIR</code> を無視します。
          </p></li></ul></div><h5><a name="idm139978999009824"></a>戻り値</h5><p>
        プラグインが正常にロードされた場合にプラグインへのポインタ。エラーが発生した場合は <code class="literal">NULL</code>。
      </p><h5><a name="idm139978999007744"></a>エラー</h5><p>
        エラーをチェックするには、<code class="literal">mysql_error()</code> または <code class="literal">mysql_errno()</code> 関数を呼び出します。<a class="xref" href="connectors-apis.html#mysql-error" title="23.8.7.15 mysql_error()">セクション23.8.7.15「mysql_error()」</a>および<a class="xref" href="connectors-apis.html#mysql-errno" title="23.8.7.14 mysql_errno()">セクション23.8.7.14「mysql_errno()」</a>を参照してください。
      </p><h5><a name="idm139978999003136"></a>例</h5><pre class="programlisting">
MYSQL mysql;

if(!mysql_load_plugin(&amp;mysql, "myplugin",
                      MYSQL_CLIENT_AUTHENTICATION_PLUGIN, 0))
{
    fprintf(stderr, "Error: %s\n", mysql_error(&amp;mysql));
    exit(-1);
}
</pre><h5><a name="idm139978999001392"></a>関連項目</h5><p>
        <a class="xref" href="connectors-apis.html#mysql-load-plugin" title="23.8.14.3 mysql_load_plugin()">セクション23.8.14.3「mysql_load_plugin()」</a>、<a class="xref" href="connectors-apis.html#mysql-error" title="23.8.7.15 mysql_error()">セクション23.8.7.15「mysql_error()」</a>、<a class="xref" href="connectors-apis.html#mysql-errno" title="23.8.7.14 mysql_errno()">セクション23.8.7.14「mysql_errno()」</a> も参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-load-plugin-v"></a>23.8.14.4 mysql_load_plugin_v()</h4></div></div></div><a class="indexterm" name="idm139978998996944"></a><p>
        <code class="literal">struct st_mysql_client_plugin *mysql_load_plugin_v(MYSQL *mysql, const char *name, int type, int argc, va_list args)</code>
      </p><h5><a name="idm139978998994304"></a>説明</h5><p>
        この関数は <code class="literal">mysql_load_plugin()</code> と同等ですが、それはパラメータの変数リストの代わりに <code class="literal">va_list</code> を受け付けます。
      </p><h5><a name="idm139978998991264"></a>関連項目</h5><p>
        <a class="xref" href="connectors-apis.html#mysql-load-plugin" title="23.8.14.3 mysql_load_plugin()">セクション23.8.14.3「mysql_load_plugin()」</a>も参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-plugin-options"></a>23.8.14.5 mysql_plugin_options()</h4></div></div></div><a class="indexterm" name="idm139978998988336"></a><p>
        <code class="literal">int mysql_plugin_options(struct st_mysql_client_plugin *plugin, const char *option, const void *value)</code>
      </p><h5><a name="idm139978998985712"></a>説明</h5><p>
        オプションの型と値をプラグインに渡します。この関数を複数回呼び出して、複数のオプションを設定できます。プラグインにオプションハンドラがない場合、エラーが発生します。
      </p><p>
        パラメータを次のように指定します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">plugin</code>: プラグイン構造へのポインタ。
          </p></li><li class="listitem"><p>
            <code class="literal">option</code>: 設定されるオプション。
          </p></li><li class="listitem"><p>
            <code class="literal">value</code>: オプション値へのポインタ。
          </p></li></ul></div><h5><a name="idm139978998978448"></a>戻り値</h5><p>
        成功した場合はゼロ、エラーが発生した場合は 1。プラグインにオプションハンドラがある場合、そのハンドラも成功した場合にゼロを返し、エラーが発生した場合は 1 を返します。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-problems"></a>23.8.15 C API を使用する場合の一般的な質問と問題</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="connectors-apis.html#null-mysql-store-result">23.8.15.1 mysql_query() が成功を返したあとに mysql_store_result() が NULL を返すことがあるのはなぜか</a></span></dt><dt><span class="section"><a href="connectors-apis.html#query-results">23.8.15.2 クエリーからどんな結果を得ることができるか</a></span></dt><dt><span class="section"><a href="connectors-apis.html#getting-unique-id">23.8.15.3 最後に挿入された行の一意の ID を取得する方法</a></span></dt></dl></div><a class="indexterm" name="idm139978998975408"></a><a class="indexterm" name="idm139978998974096"></a><a class="indexterm" name="idm139978998972752"></a><a class="indexterm" name="idm139978998970688"></a><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="null-mysql-store-result"></a>23.8.15.1 mysql_query() が成功を返したあとに mysql_store_result() が NULL を返すことがあるのはなぜか</h4></div></div></div><p>
        <code class="literal">mysql_query()</code> への成功した呼び出しに続いて、<code class="literal">mysql_store_result()</code> が <code class="literal">NULL</code> を返すことがあります。これが発生した場合、それは次の状況のいずれかが発生したことを意味します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">malloc()</code> の障害が発生しました (たとえば、結果セットが大きすぎた場合)。
          </p></li><li class="listitem"><p>
            データを読み取ることができませんでした (接続でエラーが発生しました)。
          </p></li><li class="listitem"><p>
            クエリーがデータを返しませんでした (たとえば、それが <code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、または<code class="literal">DELETE</code> でした)。
          </p></li></ul></div><p>
        <code class="literal">mysql_field_count()</code> を呼び出して、ステートメントが空でない結果を生成したかどうかを常にチェックできます。<code class="literal">mysql_field_count()</code> がゼロを返し、結果が空で、最後のクエリーが値を返さないステートメント (<code class="literal">INSERT</code> または <code class="literal">DELETE</code> など) でした。<code class="literal">mysql_field_count()</code> がゼロ以外を返す場合、ステートメントは空でない結果を生成しています。例については、<code class="literal">mysql_field_count()</code> 関数の説明を参照してください。
      </p><p>
        <code class="literal">mysql_error()</code> または <code class="literal">mysql_errno()</code> を呼び出すことによって、エラーがないかテストできます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="query-results"></a>23.8.15.2 クエリーからどんな結果を得ることができるか</h4></div></div></div><p>
        クエリーによって返される結果セットに加えて、次の情報も取得できます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">mysql_affected_rows()</code> は、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、または <code class="literal">DELETE</code> の実行中に、最後のクエリーによって影響を受けた行の数を返します。
          </p><p>
            高速の再作成のために、<code class="literal">TRUNCATE TABLE</code> を使用します。
          </p></li><li class="listitem"><p>
            <code class="literal">mysql_num_rows()</code> は結果セット内に行数を返します。<code class="literal">mysql_store_result()</code> では、<code class="literal">mysql_store_result()</code> が戻ったらすぐに、<code class="literal">mysql_num_rows()</code> を呼び出すことができます。<code class="literal">mysql_use_result()</code> では、<code class="literal">mysql_fetch_row()</code> によってすべての行をフェッチしたあとにのみ、<code class="literal">mysql_num_rows()</code> を呼び出すことができます。
          </p></li><li class="listitem"><p>
            <code class="literal">mysql_insert_id()</code> は、<code class="literal">AUTO_INCREMENT</code> インデックスでテーブル内に行を挿入した最後のクエリーによって生成された ID を返します。<a class="xref" href="connectors-apis.html#mysql-insert-id" title="23.8.7.37 mysql_insert_id()">セクション23.8.7.37「mysql_insert_id()」</a>を参照してください。
          </p></li><li class="listitem"><p>
            いくつかのクエリー (<code class="literal">LOAD DATA INFILE ...</code>、<code class="literal">INSERT INTO ... SELECT ...</code>、<code class="literal">UPDATE</code>) は追加の情報を返します。結果は <code class="literal">mysql_info()</code> によって返されます。<code class="literal">mysql_info()</code> が返す文字列の形式については、その説明を参照してください。追加の情報がない場合は、<code class="literal">mysql_info()</code> は <code class="literal">NULL</code> ポインタを返します。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="getting-unique-id"></a>23.8.15.3 最後に挿入された行の一意の ID を取得する方法</h4></div></div></div><a class="indexterm" name="idm139978998916976"></a><a class="indexterm" name="idm139978998915552"></a><a class="indexterm" name="idm139978998913520"></a><a class="indexterm" name="idm139978998911552"></a><p>
        <code class="literal">AUTO_INCREMENT</code> カラムを含むテーブルにレコードを挿入する場合、<code class="literal">mysql_insert_id()</code> 関数を呼び出すことによって、そのカラム内に格納された値を取得できます。
      </p><p>
        C アプリケーションから、次のコード (ステートメントが成功したことをチェックしているものとみなす) を実行することによって、値が <code class="literal">AUTO_INCREMENT</code> カラム内に格納されたかどうかをチェックできます。それは、クエリーが <code class="literal">AUTO_INCREMENT</code> インデックスによる <code class="literal">INSERT</code> であったかどうかを判断します。
      </p><pre class="programlisting">
if ((result = mysql_store_result(&amp;mysql)) == 0 &amp;&amp;
    mysql_field_count(&amp;mysql) == 0 &amp;&amp;
    mysql_insert_id(&amp;mysql) != 0)
{
    used_id = mysql_insert_id(&amp;mysql);
}
</pre><p>
        新しい <code class="literal">AUTO_INCREMENT</code> 値が生成されたら、<code class="literal">mysql_query()</code> で、<code class="literal">SELECT LAST_INSERT_ID()</code> ステートメントを実行し、ステートメントによって返された結果セットから値を取得することによって、それを取得することもできます。
      </p><p>
        複数の値を挿入すると、自動的に増分された最後の値が返されます。
      </p><p>
        <code class="literal">LAST_INSERT_ID()</code> では、最近生成された ID が接続ごとにサーバーに維持されます。それはほかのクライアントによって変更されません。別の <code class="literal">AUTO_INCREMENT</code> カラムを非マジック値 (つまり、<code class="literal">NULL</code> でなく、<code class="literal">0</code> でない値) で更新した場合でも、それは変更されません。<code class="literal">LAST_INSERT_ID()</code> カラムと <code class="literal">AUTO_INCREMENT</code> カラムを複数のクライアントから同時に使うことは完全に有効です。各クライアントは、<span class="emphasis"><em>その</em></span>クライアントが実行した最後のステートメントの最後に挿入された ID を受け取ります。
      </p><p>
        1 つのテーブルに生成された ID を使用して、それを 2 番目のテーブルに挿入する場合、このような SQL ステートメントを使うことができます。
      </p><pre class="programlisting">
INSERT INTO foo (auto,text)
    VALUES(NULL,'text');         # generate ID by inserting NULL
INSERT INTO foo2 (id,text)
    VALUES(LAST_INSERT_ID(),'text');  # use ID in second table
</pre><p>
        <code class="literal">mysql_insert_id()</code> は <code class="literal">AUTO_INCREMENT</code> カラムに格納された値が、<code class="literal">NULL</code> または <code class="literal">0</code> を格納することによって自動的に生成されているか、または明示的な値として指定されたかどうかに関係なく、その値を返します。<code class="literal">LAST_INSERT_ID()</code> は自動的に生成された <code class="literal">AUTO_INCREMENT</code> 値のみを返します。<code class="literal">NULL</code> または <code class="literal">0</code> 以外の明示的な値を格納する場合、それは、<code class="literal">LAST_INSERT_ID()</code> によって返される値に影響を与えません。
      </p><p>
        <code class="literal">AUTO_INCREMENT</code> カラム内の最後の ID を取得する詳細については:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            SQL ステートメント内で使用できる <code class="literal">LAST_INSERT_ID()</code> に関する情報については、<a class="xref" href="functions.html#information-functions" title="12.14 情報関数">セクション12.14「情報関数」</a>を参照してください。
          </p></li><li class="listitem"><p>
            C API 内から使用する関数 <code class="literal">mysql_insert_id()</code> については、<a class="xref" href="connectors-apis.html#mysql-insert-id" title="23.8.7.37 mysql_insert_id()">セクション23.8.7.37「mysql_insert_id()」</a>を参照してください。
          </p></li><li class="listitem"><p>
            Connector/J を使用する場合の自動インクリメントされた値の取得については、<a class="ulink" href="http://dev.mysql.com/doc/connector-j/en/connector-j-usagenotes-last-insert-id.html" target="_top">Retrieving <code class="literal">AUTO_INCREMENT</code> Column Values through JDBC</a>を参照してください。
          </p></li><li class="listitem"><p>
            Connector/ODBC を使用する場合の自動インクリメントされた値の取得については、<a class="ulink" href="http://dev.mysql.com/doc/connector-odbc/en/connector-odbc-usagenotes-functionality-last-insert-id.html" target="_top">Obtaining Auto-Increment Values</a>を参照してください。
          </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="auto-reconnect"></a>23.8.16 自動再接続動作の制御</h3></div></div></div><a class="indexterm" name="idm139978998869536"></a><p>
      実行されるステートメントをサーバーに送信しようとしたときに、MySQL クライアントライブラリが接続が停止していることを検出した場合、それはサーバーへの自動再接続を実行できます。自動再接続が有効にされている場合、ライブラリは 1 回サーバーに再接続し、ステートメントを再度送信しようとします。
    </p><p>
      MySQL 5.6 では、自動再接続はデフォルトで無効にされています。
    </p><p>
      アプリケーションで、接続が切断されたことを知ることが重要な場合 (状態情報の損失に合わせて終了したり、アクションをとったりできるように)、自動再接続が無効にされるようにしてください。これを確実にするには、<code class="literal">MYSQL_OPT_RECONNECT</code> オプションを使用して <code class="literal">mysql_options()</code> を呼び出します。
    </p><pre class="programlisting">
my_bool reconnect = 0;
mysql_options(&amp;mysql, MYSQL_OPT_RECONNECT, &amp;reconnect);
</pre><p>
      接続が停止した場合、<code class="literal">mysql_ping()</code> の効果は自動再接続の状態によって異なります。自動再接続が有効にされている場合、<code class="literal">mysql_ping()</code> は再接続を実行します。そうでない場合、それはエラーを返します。
    </p><p>
      一部のクライアントプログラムでは、自動再接続を制御する機能を提供できます。たとえば、<span class="command"><strong>mysql</strong></span> はデフォルトで再接続しますが、<code class="option">--skip-reconnect</code> オプションを使用して、この動作を抑止できます。
    </p><p>
      自動再接続が行われた場合 (たとえば、<code class="literal">mysql_ping()</code> の呼び出しの結果として)、その明示的な兆候はありません。再接続をチェックするには、<code class="literal">mysql_ping()</code> を呼び出す前に <code class="literal">mysql_thread_id()</code> を呼び出して、元の接続識別子を取得してから、再度 <code class="literal">mysql_thread_id()</code> を呼び出して、識別子が変更されているかどうかを確認します。
    </p><p>
      自動再接続は、独自の再接続コードを実装する必要がないため、便利な場合がありますが、再接続が行われる場合、サーバー側で接続状態のいくつかの側面がリセットされ、アプリケーションに通知されません。
    </p><p>
      接続関連の状態は、次のように影響を受けます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          アクティブなトランザクションがすべてロールバックされ、自動コミットモードがリセットされます。
        </p></li><li class="listitem"><p>
          すべてのテーブルロックが解除されます。
        </p></li><li class="listitem"><p>
          すべての <code class="literal">TEMPORARY</code> テーブルが閉じられ (さらに削除され) ます。
        </p></li><li class="listitem"><p>
          セッションシステム変数は、<code class="literal">SET NAMES</code> などのステートメントによって暗黙的に設定されるシステム変数を含む、対応するグローバルシステム変数の値に再初期化されます。
        </p></li><li class="listitem"><p>
          ユーザー変数設定が失われます。
        </p></li><li class="listitem"><p>
          プリペアドステートメントがリリースされます。
        </p></li><li class="listitem"><p>
          <code class="literal">HANDLER</code> 変数が閉じられます。
        </p></li><li class="listitem"><p>
          <code class="literal">LAST_INSERT_ID()</code> の値が 0 にリセットされます。
        </p></li><li class="listitem"><p>
          <code class="literal">GET_LOCK()</code> によって取得されたロックが解放されます。
        </p></li><li class="listitem"><p>
          接続スレッドインストゥルメンテーションを判断するパフォーマンススキーマ <code class="literal">threads</code> テーブル行とクライアントの関連付けが失われます。クライアントが切断後に再接続した場合、セッションは <code class="literal">threads</code> テーブル内の新しい行に関連付けられるため、スレッドモニタリング状態が異なることがあります。<a class="xref" href="performance-schema.html#threads-table" title="22.9.10.3 スレッドテーブル">セクション22.9.10.3「スレッドテーブル」</a>を参照してください。
        </p></li></ul></div><p>
      接続が切断した場合、サーバーでクライアントが接続されなくなったことを検出していない場合に、サーバー側でその接続に関連付けられているセッションが引き続き実行する可能性があります。この場合、元の接続によって保持されたロックはまだそのセッションに属しているため、<code class="literal">mysql_kill()</code> を呼び出して、それを強制終了する必要がある可能性があります。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-multiple-queries"></a>23.8.17 複数ステートメント実行の C API サポート</h3></div></div></div><p>
      デフォルトで、<code class="literal">mysql_query()</code> と <code class="literal">mysql_real_query()</code> はそれらのステートメント文字列引数を、実行すべき単一のステートメントとして解釈し、ユーザーはステートメントが結果セット (行のセット、<code class="literal">SELECT</code> の場合) を生成するか、または影響を受ける行カウント (<code class="literal">INSERT</code>、<code class="literal">UPDATE</code> などの場合) を生成するかに従って、結果を処理します。
    </p><p>
      MySQL 5.6 はセミコロン (<span class="quote">「<span class="quote"><code class="literal">;</code></span>」</span>) 文字によって区切られた複数のステートメントを格納する文字列の実行もサポートします。この機能は、<code class="literal">mysql_real_connect()</code> によってサーバーに接続するとき、または <code class="literal">mysql_set_server_option()</code> の呼び出しによる接続後のいずれかに指定される特別なオプションによって有効化されます。
    </p><p>
      複数ステートメント文字列を実行すると、複数の結果セットまたは行カウントインジケータを生成できます。これらの結果の処理には、単一ステートメントの場合と異なるアプローチが必要です。最初のステートメントからの結果の処理後、それ以上の結果が存在するかどうかをチェックし、存在する場合は、それらを順番に処理する必要があります。複数結果の処理をサポートするため、C API には、<code class="literal">mysql_more_results()</code> 関数と <code class="literal">mysql_next_result()</code> 関数が含まれています。これらの関数は、それ以上の結果があるかぎり反復するループの最後で使用します。<span class="emphasis"><em>結果をこのように処理できないと、サーバーへの接続が切断される可能性があります。</em></span>
    </p><p>
      複数結果の処理は、ストアドプロシージャーに対して <code class="literal">CALL</code> ステートメントを実行する場合にも必要です。ストアドプロシージャーの結果にはこれらの特性があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          プロシージャー内のステートメントは結果セットを生成することがあります (たとえば、それが <code class="literal">SELECT</code> ステートメントを実行する場合など)。これらの結果セットは、プロシージャーの実行とともに、それらが生成された順番で返されます。
        </p><p>
          一般に、呼び出し元はプロシージャーが返す結果セットの数を知ることができません。プロシージャーの実行は、呼び出しごとに実行パスが異なるループや条件ステートメントによって異なることがあります。そのため、複数の結果を取得するように準備しておく必要があります。
        </p></li><li class="listitem"><p>
          プロシージャーからの最終結果は、結果セットを含まないステータス結果です。このステータスはプロシージャーが成功したか、エラーが発生したかを示します。
        </p></li></ul></div><p>
      複数ステートメントおよび結果機能は、<code class="literal">mysql_query()</code> または <code class="literal">mysql_real_query()</code> と一緒にのみ使用できます。それらはプリペアドステートメントインタフェースと一緒に使用できません。プリペアドステートメントハンドルは単一のステートメントを含む文字列のみを操作するように定義されます。<a class="xref" href="connectors-apis.html#c-api-prepared-statements" title="23.8.8 C API プリペアドステートメント">セクション23.8.8「C API プリペアドステートメント」</a>を参照してください。
    </p><p>
      複数ステートメントの実行と結果の処理を有効にするには、次のオプションを使うことができます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">mysql_real_connect()</code> 関数には 2 つのオプション値が関連する <code class="literal">flags</code> 引数があります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">CLIENT_MULTI_RESULTS</code> により、クライアントプログラムは複数の結果を処理できます。結果セットを生成するストアドプロシージャーに対して、<code class="literal">CALL</code> ステートメントを実行する場合、このオプションを有効にする<span class="emphasis"><em>必要があります</em></span>。そうしないと、そのようなプロシージャーはエラー<code class="literal">「エラー 1312 (0A000): PROCEDURE <em class="replaceable"><code>proc_name</code></em> は指定されたコンテキストで結果セットを返すことができません」</code>を生成します。MySQL 5.6 では、<code class="literal">CLIENT_MULTI_RESULTS</code> はデフォルトで有効にされています。
            </p></li><li class="listitem"><p>
              <code class="literal">CLIENT_MULTI_STATEMENTS</code> により、<code class="literal">mysql_query()</code> および <code class="literal">mysql_real_query()</code> はセミコロンで区切られた複数のステートメントを含むステートメント文字列を実行できます。このオプションにより、<code class="literal">CLIENT_MULTI_RESULTS</code> も暗黙的に有効になるため、<code class="literal">mysql_real_connect()</code> への <code class="literal">CLIENT_MULTI_STATEMENTS</code> の <code class="literal">flags</code> 引数は、<code class="literal">CLIENT_MULTI_STATEMENTS | CLIENT_MULTI_RESULTS</code> の引数と同等になります。つまり、<code class="literal">CLIENT_MULTI_STATEMENTS</code> は複数ステートメントの実行とすべての複数結果の処理を有効にするのに十分です。
            </p></li></ul></div></li><li class="listitem"><p>
          サーバーへの接続が確立されたあと、<code class="literal">mysql_set_server_option()</code> 関数を使用して、それを <code class="literal">MYSQL_OPTION_MULTI_STATEMENTS_ON</code> または <code class="literal">MYSQL_OPTION_MULTI_STATEMENTS_OFF</code> の引数に渡すことによって、複数ステートメントの実行を有効または無効にできます。この関数によって複数ステートメントの実行を有効にすると、複数ステートメント文字列の<span class="quote">「<span class="quote">簡単な</span>」</span>結果の処理も有効になります。そこでは、各ステートメントが単一の結果を生成しますが、結果セットを生成するストアドプロシージャーの処理を許可するには十分で<span class="emphasis"><em>ありません</em></span>。
        </p></li></ul></div><p>
      次の手順に、複数ステートメントの処理の推奨される戦略の概要を示します。
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          <code class="literal">CLIENT_MULTI_STATEMENTS</code> を <code class="literal">mysql_real_connect()</code> に渡して、複数ステートメントの実行と複数結果の処理を完全に有効にします。
        </p></li><li class="listitem"><p>
          <code class="literal">mysql_query()</code> または <code class="literal">mysql_real_query()</code> を呼び出し、それが成功したことを確認したあとに、ステートメント結果を処理するループに入ります。
        </p></li><li class="listitem"><p>
          ループの反復ごとに、現在のステートメント結果を処理し、結果セットまたは影響を受けた行カウントを取得します。エラーが発生したら、ループを終了します。
        </p></li><li class="listitem"><p>
          ループの終わりに、<code class="literal">mysql_next_result()</code> を呼び出して、ほかの結果が存在するかどうかをチェックし、その場合は、取得を開始します。それ以上の結果がなくなったら、ループを終了します。
        </p></li></ol></div><p>
      先述の戦略の 1 つの可能な実装を次に示します。ループの最終部分は、<code class="literal">mysql_next_result()</code> がゼロ以外を返すかどうかの簡単なテストに単純化できます。示されているコードは、それ以上の結果がないこととエラーを区別し、それによって、後者の発生でメッセージを出力させることができます。
    </p><pre class="programlisting">
/* connect to server with the CLIENT_MULTI_STATEMENTS option */
if (mysql_real_connect (mysql, host_name, user_name, password,
    db_name, port_num, socket_name, CLIENT_MULTI_STATEMENTS) == NULL)
{
  printf("mysql_real_connect() failed\n");
  mysql_close(mysql);
  exit(1);
}

/* execute multiple statements */
status = mysql_query(mysql,
                     "DROP TABLE IF EXISTS test_table;\
                      CREATE TABLE test_table(id INT);\
                      INSERT INTO test_table VALUES(10);\
                      UPDATE test_table SET id=20 WHERE id=10;\
                      SELECT * FROM test_table;\
                      DROP TABLE test_table");
if (status)
{
  printf("Could not execute statement(s)");
  mysql_close(mysql);
  exit(0);
}

/* process each statement result */
do {
  /* did current statement return data? */
  result = mysql_store_result(mysql);
  if (result)
  {
    /* yes; process rows and free the result set */
    process_result_set(mysql, result);
    mysql_free_result(result);
  }
  else          /* no result set or error */
  {
    if (mysql_field_count(mysql) == 0)
    {
      printf("%lld rows affected\n",
            mysql_affected_rows(mysql));
    }
    else  /* some error occurred */
    {
      printf("Could not retrieve result set\n");
      break;
    }
  }
  /* more results? -1 = no, &gt;0 = error, 0 = yes (keep looping) */
  if ((status = mysql_next_result(mysql)) &gt; 0)
    printf("Could not execute statement\n");
} while (status == 0);

mysql_close(mysql);
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-prepared-statement-problems"></a>23.8.18 C API プリペアドステートメントの問題</h3></div></div></div><p>
      次に、プリペアドステートメントの現在既知の問題のリストを示します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">TIME</code>、<code class="literal">TIMESTAMP</code>、および <code class="literal">DATETIME</code> は秒の部分 (<code class="literal">DATE_FORMAT()</code> からなど) をサポートしていません。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139978998755952"></a> 整数から文字列への変換時に、<code class="literal">ZEROFILL</code> は、MySQL サーバーが先頭のゼロを出力しない特定の場合に、プリペアドステートメントを使用できます。(たとえば、<code class="literal">MIN(<em class="replaceable"><code>number-with-zerofill</code></em>)</code> によって)。
        </p></li><li class="listitem"><p>
          クライアントで浮動小数点数値を文字列に変換すると、変換された値の右端の桁が、元の値のそれとわずかに異なることがあります。
        </p></li><li class="listitem"><p>
          プリペアドステートメントは、<a class="xref" href="optimization.html#query-cache-operation" title="8.9.3.1 クエリーキャッシュの動作">セクション8.9.3.1「クエリーキャッシュの動作」</a>に説明する状況でクエリーキャッシュを使用します。
        </p></li><li class="listitem"><p>
          プリペアドステートメントは、複数ステートメント (つまり、単一の文字列内にある <span class="quote">「<span class="quote"><code class="literal">;</code></span>」</span> 文字で区切られた複数のステートメント) をサポートしません。
        </p></li><li class="listitem"><p>
          プリペアド <code class="literal">CALL</code> ステートメントの機能については、<a class="xref" href="connectors-apis.html#c-api-prepared-call-statements" title="23.8.20 C API のプリペアド CALL ステートメントのサポート">セクション23.8.20「C API のプリペアド CALL ステートメントのサポート」</a>で説明しています。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-prepared-statement-date-handling"></a>23.8.19 C API プリペアドステートメントの日時値の処理</h3></div></div></div><p>
      バイナリ (プリペアドステートメント) プロトコルにより、<code class="literal">MYSQL_TIME</code> 構造を使用して、日時値 (<code class="literal">DATE</code>、<code class="literal">TIME</code>、<code class="literal">DATETIME</code>、および <code class="literal">TIMESTAMP</code>) を送受信できます。この構造のメンバーについては、<a class="xref" href="connectors-apis.html#c-api-prepared-statement-data-structures" title="23.8.9 C API プリペアドステートメントデータ構造">セクション23.8.9「C API プリペアドステートメントデータ構造」</a>で説明しています。
    </p><p>
      時間データ値を送信するには、<code class="literal">mysql_stmt_prepare()</code> を使用して、プリペアドステートメントを作成します。その後、<code class="literal">mysql_stmt_execute()</code> を呼び出して、ステートメントを実行する前に、次の手順を使用して、各時間パラメータを設定します。
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          データ値に関連付けられている <code class="literal">MYSQL_BIND</code> 構造で、<code class="literal">buffer_type</code> メンバーを、送信する時間値の種類を示す型に設定します。<code class="literal">DATE</code>、<code class="literal">TIME</code>、<code class="literal">DATETIME</code>、または <code class="literal">TIMESTAMP</code> 値で、<code class="literal">buffer_type</code> を <code class="literal">MYSQL_TYPE_DATE</code>、<code class="literal">MYSQL_TYPE_TIME</code>、<code class="literal">MYSQL_TYPE_DATETIME</code>、または <code class="literal">MYSQL_TYPE_TIMESTAMP</code> にそれぞれ設定します。
        </p></li><li class="listitem"><p>
          <code class="literal">MYSQL_BIND</code> 構造の <code class="literal">buffer</code> メンバーを、時間値を渡す <code class="literal">MYSQL_TIME</code> 構造のアドレスに設定します。
        </p></li><li class="listitem"><p>
          渡す時間値の型に適切な <code class="literal">MYSQL_TIME</code> 構造のメンバーを入力します。
        </p></li></ol></div><p>
      <code class="literal">mysql_stmt_bind_param()</code> を使用して、パラメータデータをステートメントにバインドします。これにより、<code class="literal">mysql_stmt_execute()</code> を呼び出すことができます。
    </p><p>
      時間値を取得する場合、<code class="literal">buffer_type</code> メンバーを、受け取ることを期待する値の型に設定し、<code class="literal">buffer</code> メンバーを、戻り値を配置させる <code class="literal">MYSQL_TIME</code> 構造のアドレスに設定することを除いて、手順は同じです。<code class="literal">mysql_stmt_bind_result()</code> を使用して、<code class="literal">mysql_stmt_execute()</code> を呼び出したあと、かつ結果をフェッチする前にステートメントにバッファーをバインドします。
    </p><p>
      これは <code class="literal">DATE</code>、<code class="literal">TIME</code>、および <code class="literal">TIMESTAMP</code> データを挿入する簡単な例です。<code class="literal">mysql</code> 変数は有効な接続ハンドルであるとみなされます。
    </p><pre class="programlisting">

  MYSQL_TIME  ts;
  MYSQL_BIND  bind[3];
  MYSQL_STMT  *stmt;

  strmov(query, "INSERT INTO test_table(date_field, time_field, \
                               timestamp_field) VALUES(?,?,?");

  stmt = mysql_stmt_init(mysql);
  if (!stmt)
  {
    fprintf(stderr, " mysql_stmt_init(), out of memory\n");
    exit(0);
  }
  if (mysql_stmt_prepare(mysql, query, strlen(query)))
  {
    fprintf(stderr, "\n mysql_stmt_prepare(), INSERT failed");
    fprintf(stderr, "\n %s", mysql_stmt_error(stmt));
    exit(0);
  }

  /* set up input buffers for all 3 parameters */
  bind[0].buffer_type= MYSQL_TYPE_DATE;
  bind[0].buffer= (char *)&amp;ts;
  bind[0].is_null= 0;
  bind[0].length= 0;
  ...
  bind[1]= bind[2]= bind[0];
  ...

  mysql_stmt_bind_param(stmt, bind);

  /* supply the data to be sent in the ts structure */
  ts.year= 2002;
  ts.month= 02;
  ts.day= 03;

  ts.hour= 10;
  ts.minute= 45;
  ts.second= 20;

  mysql_stmt_execute(stmt);
  ..

</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="c-api-prepared-call-statements"></a>23.8.20 C API のプリペアド CALL ステートメントのサポート</h3></div></div></div><p>
      このセクションでは、<code class="literal">CALL</code> ステートメントを使用して実行されるストアドプロシージャーに対する C API のプリペアドステートメントのサポートについて説明します。
    </p><p>
      MySQL 5.6 では、プリペアド <code class="literal">CALL</code> ステートメントを使用して実行されるストアドプロシージャーを次のように使用できます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ストアドプロシージャーは任意の数の結果セットを生成できます。カラムの数とカラムのデータ型はすべての結果セットで同じにする必要はありません。
        </p></li><li class="listitem"><p>
          <code class="literal">OUT</code> および <code class="literal">INOUT</code> パラメータの最終値は、プロシージャーが戻ったあとに、呼び出し元のアプリケーションで使用できます。これらのパラメータは、プロシージャー自体によって生成される結果セットに続いて、特別な単一行結果セットとして返されます。行には、<code class="literal">OUT</code> および <code class="literal">INOUT</code> パラメータがプロシージャーパラメータリストで宣言されている順番で含まれます。
        </p></li></ul></div><p>
      次の説明に、プリペアドステートメントに対して、C API からこれらの機能を使用する方法を示します。<code class="literal">PREPARE</code> および <code class="literal">EXECUTE</code> ステートメントからプリペアド <code class="literal">CALL</code> ステートメントを使用するには、<a class="xref" href="sql-syntax.html#call" title="13.2.1 CALL 構文">セクション13.2.1「CALL 構文」</a>を参照してください。
    </p><p>
      アプリケーションが 5.5.3 より古い MySQL のバージョンが使用されたコンテキストでコンパイルまたは実行されている可能性がある場合、複数の結果セットのプリペアド <code class="literal">CALL</code> 機能および <code class="literal">OUT</code> または <code class="literal">INOUT</code> パラメータを使用できない可能性があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          クライアント側で、ライブラリが MySQL 5.5.3 以上のものでないと、アプリケーションはコンパイルされません (そのバージョンで導入された API 関数およびシンボルが存在しなくなります)。
        </p></li><li class="listitem"><p>
          サーバーが十分に新しいことを実行時に確認するには、クライアントでこのテストを使用できます。
        </p><pre class="programlisting">
if (mysql_get_server_version(mysql) &lt; 50503)
{
  fprintf(stderr,
          "Server does not support required CALL capabilities\n");
  mysql_close(mysql);
  exit (1);
}
</pre></li></ul></div><p>
      プリペアド <code class="literal">CALL</code> ステートメントを実行するアプリケーションは、結果をフェッチし、次に <code class="literal">mysql_stmt_next_result()</code> を呼び出して、それ以上の結果があるかどうかを判断するループを使用してください。結果は、ストアドプロシージャーによって生成された結果セットと、それに続くプロシージャーが正常に終了したかどうかを示す最終ステータス値から構成されます。
    </p><p>
      プロシージャーに <code class="literal">OUT</code> または <code class="literal">INOUT</code> パラメータがある場合、最終ステータス値の前の結果セットにそれらの値が格納されます。結果セットにパラメータ値が格納されているかどうかを判断するには、<code class="literal">MYSQL</code> 接続ハンドラの <code class="literal">server_status</code> メンバーに、<code class="literal">SERVER_PS_OUT_PARAMS</code> ビットが設定されているかどうかをテストします。
    </p><pre class="programlisting">
mysql-&gt;server_status &amp; SERVER_PS_OUT_PARAMS
</pre><p>
      次の例では、プリペアド <code class="literal">CALL</code> ステートメントを使用して、複数の結果セットを生成して、<code class="literal">OUT</code> および <code class="literal">INOUT</code> パラメータを使用して、呼び出し元にパラメータ値を返すストアドプロシージャーを実行しています。プロシージャーは 3 つすべての型 (<code class="literal">IN</code>、<code class="literal">OUT</code>、<code class="literal">INOUT</code>) のパラメータをとり、それらの初期値を表示して、新しい値を割り当て、更新された値を表示して戻ります。そのため、プロシージャーからの予期される戻り情報は、複数の結果セットと最終ステータスから構成されます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          初期パラメータ値 (<code class="literal">10</code>、<code class="literal">NULL</code>、<code class="literal">30</code>) を表示する <code class="literal">SELECT</code> からの 1 つの結果セット。( <code class="literal">OUT</code> パラメータには呼び出し元によって値が割り当てられますが、この割り当ては無効にすることが期待されます。<code class="literal">OUT</code> パラメータは、プロシージャー内で値を割り当てるまで、プロシージャー内で <code class="literal">NULL</code> とみなされます。)
        </p></li><li class="listitem"><p>
          変更されたパラメータ値 (<code class="literal">100</code>、<code class="literal">200</code>、<code class="literal">300</code>) を表示する <code class="literal">SELECT</code> からの 1 つの結果セット。
        </p></li><li class="listitem"><p>
          最終 <code class="literal">OUT</code> および <code class="literal">INOUT</code> パラメータ値 (<code class="literal">200</code>、<code class="literal">300</code>) を格納する 1 つの結果セット。
        </p></li><li class="listitem"><p>
          最終ステータスパケット。
        </p></li></ul></div><p>
      プロシージャーを実行するコード:
    </p><pre class="programlisting">
MYSQL_STMT *stmt;
MYSQL_BIND ps_params[3];  /* input parameter buffers */
int        int_data[3];   /* input/output values */
my_bool    is_null[3];    /* output value nullability */
int        status;

/* set up stored procedure */
status = mysql_query(mysql, "DROP PROCEDURE IF EXISTS p1");
test_error(mysql, status);

status = mysql_query(mysql,
  "CREATE PROCEDURE p1("
  "  IN p_in INT, "
  "  OUT p_out INT, "
  "  INOUT p_inout INT) "
  "BEGIN "
  "  SELECT p_in, p_out, p_inout; "
  "  SET p_in = 100, p_out = 200, p_inout = 300; "
  "  SELECT p_in, p_out, p_inout; "
  "END");
test_error(mysql, status);

/* initialize and prepare CALL statement with parameter placeholders */
stmt = mysql_stmt_init(mysql);
if (!stmt)
{
  printf("Could not initialize statement\n");
  exit(1);
}
status = mysql_stmt_prepare(stmt, "CALL p1(?, ?, ?)", 16);
test_stmt_error(stmt, status);

/* initialize parameters: p_in, p_out, p_inout (all INT) */
memset(ps_params, 0, sizeof (ps_params));

ps_params[0].buffer_type = MYSQL_TYPE_LONG;
ps_params[0].buffer = (char *) &amp;int_data[0];
ps_params[0].length = 0;
ps_params[0].is_null = 0;

ps_params[1].buffer_type = MYSQL_TYPE_LONG;
ps_params[1].buffer = (char *) &amp;int_data[1];
ps_params[1].length = 0;
ps_params[1].is_null = 0;

ps_params[2].buffer_type = MYSQL_TYPE_LONG;
ps_params[2].buffer = (char *) &amp;int_data[2];
ps_params[2].length = 0;
ps_params[2].is_null = 0;

/* bind parameters */
status = mysql_stmt_bind_param(stmt, ps_params);
test_stmt_error(stmt, status);

/* assign values to parameters and execute statement */
int_data[0]= 10;  /* p_in */
int_data[1]= 20;  /* p_out */
int_data[2]= 30;  /* p_inout */

status = mysql_stmt_execute(stmt);
test_stmt_error(stmt, status);

/* process results until there are no more */
do {
  int i;
  int num_fields;       /* number of columns in result */
  MYSQL_FIELD *fields;  /* for result set metadata */
  MYSQL_BIND *rs_bind;  /* for output buffers */

  /* the column count is &gt; 0 if there is a result set */
  /* 0 if the result is only the final status packet */
  num_fields = mysql_stmt_field_count(stmt);

  if (num_fields &gt; 0)
  {
    /* there is a result set to fetch */
    printf("Number of columns in result: %d\n", (int) num_fields);

    /* what kind of result set is this? */
    printf("Data: ");
    if(mysql-&gt;server_status &amp; SERVER_PS_OUT_PARAMS)
      printf("this result set contains OUT/INOUT parameters\n");
    else
      printf("this result set is produced by the procedure\n");

    MYSQL_RES *rs_metadata = mysql_stmt_result_metadata(stmt);
    test_stmt_error(stmt, rs_metadata == NULL);

    fields = mysql_fetch_fields(rs_metadata);

    rs_bind = (MYSQL_BIND *) malloc(sizeof (MYSQL_BIND) * num_fields);
    if (!rs_bind)
    {
      printf("Cannot allocate output buffers\n");
      exit(1);
    }
    memset(rs_bind, 0, sizeof (MYSQL_BIND) * num_fields);

    /* set up and bind result set output buffers */
    for (i = 0; i &lt; num_fields; ++i)
    {
      rs_bind[i].buffer_type = fields[i].type;
      rs_bind[i].is_null = &amp;is_null[i];

      switch (fields[i].type)
      {
        case MYSQL_TYPE_LONG:
          rs_bind[i].buffer = (char *) &amp;(int_data[i]);
          rs_bind[i].buffer_length = sizeof (int_data);
          break;

        default:
          fprintf(stderr, "ERROR: unexpected type: %d.\n", fields[i].type);
          exit(1);
      }
    }

    status = mysql_stmt_bind_result(stmt, rs_bind);
    test_stmt_error(stmt, status);

    /* fetch and display result set rows */
    while (1)
    {
      status = mysql_stmt_fetch(stmt);

      if (status == 1 || status == MYSQL_NO_DATA)
        break;

      for (i = 0; i &lt; num_fields; ++i)
      {
        switch (rs_bind[i].buffer_type)
        {
          case MYSQL_TYPE_LONG:
            if (*rs_bind[i].is_null)
              printf(" val[%d] = NULL;", i);
            else
              printf(" val[%d] = %ld;",
                     i, (long) *((int *) rs_bind[i].buffer));
            break;

          default:
            printf("  unexpected type (%d)\n",
              rs_bind[i].buffer_type);
        }
      }
      printf("\n");
    }

    mysql_free_result(rs_metadata); /* free metadata */
    free(rs_bind);                  /* free output buffers */
  }
  else
  {
    /* no columns = final status packet */
    printf("End of procedure output\n");
  }

  /* more results? -1 = no, &gt;0 = error, 0 = yes (keep looking) */
  status = mysql_stmt_next_result(stmt);
  if (status &gt; 0)
    test_stmt_error(stmt, status);
} while (status == 0);

mysql_stmt_close(stmt);
</pre><p>
      プロシージャーを実行すると次の出力が生成されます。
    </p><pre class="programlisting">
Number of columns in result: 3
Data: this result set is produced by the procedure
 val[0] = 10; val[1] = NULL; val[2] = 30;
Number of columns in result: 3
Data: this result set is produced by the procedure
 val[0] = 100; val[1] = 200; val[2] = 300;
Number of columns in result: 2
Data: this result set contains OUT/INOUT parameters
 val[0] = 200; val[1] = 300;
End of procedure output
</pre><p>
      このコードでは、2 つのユーティリティールーチン <code class="literal">test_error()</code> および <code class="literal">test_stmt_error()</code> を使用して、エラーをチェックし、エラーが発生した場合は診断情報を出力したあとに終了します。
    </p><pre class="programlisting">
static void test_error(MYSQL *mysql, int status)
{
  if (status)
  {
    fprintf(stderr, "Error: %s (errno: %d)\n",
            mysql_error(mysql), mysql_errno(mysql));
    exit(1);
  }
}

static void test_stmt_error(MYSQL_STMT *stmt, int status)
{
  if (status)
  {
    fprintf(stderr, "Error: %s (errno: %d)\n",
            mysql_stmt_error(stmt), mysql_stmt_errno(stmt));
    exit(1);
  }
}
</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="apis-php-info"></a>23.9 MySQL PHP API</h2></div></div></div><p>
    MySQL PHP API のマニュアルは、MySQL リファレンスマニュアルの一部としてではなく、独立した形式で発行されるようになりました。<a class="ulink" href="http://dev.mysql.com/doc/apis-php/en/index.html" target="_top">MySQL and PHP</a>を参照してください。
  </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="apis-perl"></a>23.10 MySQL Perl API</h2></div></div></div><a class="indexterm" name="idm139978998630352"></a><a class="indexterm" name="idm139978998628416"></a><a class="indexterm" name="idm139978998627072"></a><a class="indexterm" name="idm139978998625568"></a><p>
    Perl<code class="literal">DBI</code>モジュールはデータベースアクセスのための一般的なインタフェースを提供します。変更せずに、多くのさまざまなデータベースエンジンで動作する DBI スクリプトを書くことができます。MySQL で DBI を使用するには、次をインストールします。
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
        <code class="literal">DBI</code> モジュール。
      </p></li><li class="listitem"><p>
        <code class="literal">DBD::mysql</code> モジュール。これは Perl のデータベースドライバ (DBD) モジュールです。
      </p></li><li class="listitem"><p>
        オプションで、アクセスするほかの任意の種類のデータベースサーバーの DBD モジュール。
      </p></li></ol></div><p>
    Perl DBI は推薦される Perl インタフェースです。それは、廃止とみなされるべき <code class="literal">mysqlperl</code> と呼ばれる古いインタフェースを置き換えます。
  </p><p>
    これらのセクションには、MySQL と Perl の使用および Perl での MySQL アプリケーションの作成に関する情報が含まれます。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        Perl DBI サポートのインストール手順については、<a class="xref" href="installing.html#perl-support" title="2.13 Perl のインストールに関する注釈">セクション2.13「Perl のインストールに関する注釈」</a>を参照してください。
      </p></li><li class="listitem"><p>
        オプションファイルからオプションを読み取る例については、<a class="xref" href="server-administration.html#multiple-server-clients" title="5.3.4 複数サーバー環境でのクライアントプログラムの使用">セクション5.3.4「複数サーバー環境でのクライアントプログラムの使用」</a>を参照してください。
      </p></li><li class="listitem"><p>
        セキュアなコーディングのヒントについては、<a class="xref" href="security.html#security-guidelines" title="6.1.1 セキュリティーガイドライン">セクション6.1.1「セキュリティーガイドライン」</a>を参照してください。
      </p></li><li class="listitem"><p>
        デバッグのヒントについては、<a class="xref" href="extending-mysql.html#using-gdb-on-mysqld" title="24.4.1.4 gdb での mysqld のデバッグ">セクション24.4.1.4「gdb での mysqld のデバッグ」</a>を参照してください。
      </p></li><li class="listitem"><p>
        いくつかの Perl 固有の環境変数については、<a class="xref" href="installing.html#environment-variables" title="2.12 環境変数">セクション2.12「環境変数」</a>を参照してください。
      </p></li><li class="listitem"><p>
        OS X 上で実行する場合の考慮事項については、<a class="xref" href="installing.html#osx-installation" title="2.4 OS X に MySQL をインストールする">セクション2.4「OS X に MySQL をインストールする」</a>を参照してください。
      </p></li><li class="listitem"><p>
        文字列リテラルを引用する方法については、<a class="xref" href="language-structure.html#string-literals" title="9.1.1 文字列リテラル">セクション9.1.1「文字列リテラル」</a>を参照してください。
      </p></li></ul></div><p>
    DBI 情報はコマンド行、オンライン、または印刷物で取得できます。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="literal">DBI</code> と <code class="literal">DBD::mysql</code> モジュールをインストールしたら、コマンド行で <code class="literal">perldoc</code> コマンドを使って、それらに関する情報を得ることができます。
      </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>perldoc DBI</code></strong>
shell&gt; <strong class="userinput"><code>perldoc DBI::FAQ</code></strong>
shell&gt; <strong class="userinput"><code>perldoc DBD::mysql</code></strong>
</pre><p>
        <code class="literal">pod2man</code>、<code class="literal">pod2html</code> などを使用して、この情報をほかのフォーマットに変換することもできます。
      </p></li><li class="listitem"><p>
        Perl DBI に関するオンライン情報については、DBI Web サイト <a class="ulink" href="http://dbi.perl.org/" target="_top">http://dbi.perl.org/</a> にアクセスしてください。そのサイトでは一般的な DBI メーリングリストをホストしています。Oracle Corporation では、特に <code class="literal">DBD::mysql</code> に関するリストをホストしています。<a class="xref" href="introduction.html#mailing-lists" title="1.6.1 MySQL メーリングリスト">セクション1.6.1「MySQL メーリングリスト」</a>を参照してください。
      </p></li><li class="listitem"><p>
        印刷された情報として、公式の DBI の書籍は『<em class="citetitle">Programming the Perl DBI</em>』(Alligator Descartes および Tim Bunce 著、O'Reilly &amp; Associates 発行、2000 年) があります。この書籍については、DBI Web サイト <a class="ulink" href="http://dbi.perl.org/" target="_top">http://dbi.perl.org/</a> を参照してください。
      </p><p>
        MySQL と DBI の使用に特に焦点を合わせた情報については、『<em class="citetitle">MySQL and Perl for the Web</em>』(Paul DuBois 著、New Riders 発行、2001 年) を参照してください。この書籍の Web サイトは <a class="ulink" href="http://www.kitebird.com/mysql-perl/" target="_top">http://www.kitebird.com/mysql-perl/</a> です。
      </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="apis-python"></a>23.11 MySQL Python API</h2></div></div></div><a class="indexterm" name="idm139978998584448"></a><p>
    <code class="literal">MySQLdb</code> は Python DB API バージョン 2.0 に準拠した MySQL の Python のサポートを提供するサードパーティードライバです。それは <a class="ulink" href="http://sourceforge.net/projects/mysql-python/" target="_top">http://sourceforge.net/projects/mysql-python/</a> にあります。
  </p><p>
    新しい MySQL Connector/Python コンポーネントは同じ Python API へのインタフェースを提供し、MySQL サーバーに組み込まれ、Oracle によってサポートされます。Connector の詳細と、Python アプリケーションのコーディングガイドラインおよびサンプル Python コードについては、<a class="ulink" href="http://dev.mysql.com/doc/connector-python/en/index.html" target="_top">MySQL Connector/Python Developer Guide</a>を参照してください。
  </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="apis-ruby"></a>23.12 MySQL Ruby API</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="connectors-apis.html#apis-ruby-mysqlruby">23.12.1 MySQL/Ruby API</a></span></dt><dt><span class="section"><a href="connectors-apis.html#apis-ruby-rubymysql">23.12.2 Ruby/MySQL API</a></span></dt></dl></div><a class="indexterm" name="idm139978998576992"></a><p>
    MySQL アプリケーションを開発する Ruby プログラマは 2 つの API を使用できます。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        MySQL/Ruby API は <code class="literal">libmysqlclient</code> API ライブラリに基づいています。MySQL/Ruby API のインストールと使用については、<a class="xref" href="connectors-apis.html#apis-ruby-mysqlruby" title="23.12.1 MySQL/Ruby API">セクション23.12.1「MySQL/Ruby API」</a>を参照してください。
      </p></li><li class="listitem"><p>
        Ruby/MySQL API はネイティブ MySQL ネットワークプロトコル (ネイティブドライバ) を使用するために書かれています。Ruby/Ruby API のインストールと使用については、<a class="xref" href="connectors-apis.html#apis-ruby-rubymysql" title="23.12.2 Ruby/MySQL API">セクション23.12.2「Ruby/MySQL API」</a>を参照してください。
      </p></li></ul></div><p>
    Ruby 言語に関するバックグラウンドと構文情報については、<a class="ulink" href="http://www.ruby-lang.org" target="_top">Ruby プログラミング言語</a>を参照してください。
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="apis-ruby-mysqlruby"></a>23.12.1 MySQL/Ruby API</h3></div></div></div><p>
      MySQL/Ruby モジュールは、<code class="literal">libmysqlclient</code> 経由で Ruby を使用した MySQL データベースへのアクセスを提供します。
    </p><p>
      モジュールのインストールと公開されている関数については、<a class="ulink" href="http://tmtm.org/en/mysql/ruby/" target="_top">「MySQL/Ruby」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="apis-ruby-rubymysql"></a>23.12.2 Ruby/MySQL API</h3></div></div></div><p>
      MySQL/Ruby モジュールは、MySQL ネットワークプロトコルを使用して、ネイティブドライバインタフェース経由で、Ruby を使用した MySQL データベースへのアクセスを提供します。
    </p><p>
      モジュールのインストールと公開されている関数については、<a class="ulink" href="http://tmtm.org/en/ruby/mysql/README_en.html" target="_top">「Ruby/MySQL」</a>を参照してください。
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="apis-tcl"></a>23.13 MySQL Tcl API</h2></div></div></div><a class="indexterm" name="idm139978998559936"></a><p>
    <code class="literal">MySQLtcl</code> は <a class="ulink" href="http://en.wikipedia.org/wiki/Tcl" target="_top">Tcl プログラミング言語</a>から MySQL データベースサーバーにアクセスするための簡単な API です。それは <a class="ulink" href="http://www.xdobry.de/mysqltcl/" target="_top">http://www.xdobry.de/mysqltcl/</a> にあります。
  </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="apis-eiffel"></a>23.14 MySQL Eiffel ラッパー</h2></div></div></div><a class="indexterm" name="idm139978998554416"></a><a class="indexterm" name="idm139978998553008"></a><p>
    Eiffel MySQL は、Michael Ravits によって書かれた <a class="ulink" href="http://en.wikipedia.org/wiki/Eiffel_(programming_language)" target="_top">Eiffel プログラミング言語</a>を使用した MySQL データベースサーバーへのインタフェースです。それは <a class="ulink" href="http://efsa.sourceforge.net/archive/ravits/mysql.htm" target="_top">http://efsa.sourceforge.net/archive/ravits/mysql.htm</a> にあります。
  </p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="performance-schema.html">前</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="extending-mysql.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第 22 章 MySQL パフォーマンススキーマ </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 第 24 章 MySQL の拡張</td></tr></table></div><div class="copyright-footer"></div></body></html>
