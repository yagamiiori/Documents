<html lang="ja"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>第 20 章 ストアドプログラムおよびビュー</title><link rel="stylesheet" type="text/css" href="mvl.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="MySQL 5.6 リファレンスマニュアル"><link rel="up" href="index.html" title="MySQL 5.6 リファレンスマニュアル"><link rel="prev" href="partitioning.html" title="第 19 章 パーティション化"><link rel="next" href="information-schema.html" title="第 21 章 INFORMATION_SCHEMA テーブル">
<script language="javascript" type="text/javascript">
  function addOnload(theFunc)
  {
    var previous = window.onload;
    if (typeof window.onload != 'function')
    {
      window.onload = theFunc;
    }
    else
    {
      window.onload = function()
      {
        previous();
        theFunc();
      }
    }
  }

  addOnload(function()
  {
    var base = new Date(1442918127*1000);
    var now = new Date();
    var diff = ((now-base)/1000)/(24*3600);

    if (diff > 90) {
      var nodes = document.getElementsByClassName('titlepage');
      nodes[0].innerHTML = '<p style="border: 5px #ff0000 solid; padding: 5px; margin 5px">' +
        'This copy of the manual is more than 90 days old. We encourage you to download a ' +
        'new version from <a href="http://dev.mysql.com">dev.mysql.com/doc</a>.</p>' + nodes[0].innerHTML;
    }
  });
</script>
<noscript></noscript>
</head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第 20 章 ストアドプログラムおよびビュー</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="partitioning.html">前</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="information-schema.html">次へ</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="stored-programs-views"></a>第 20 章 ストアドプログラムおよびビュー</h1></div></div></div><div class="toc"><p><b>目次</b></p><dl class="toc"><dt><span class="section"><a href="stored-programs-views.html#stored-programs-defining">20.1 ストアドプログラムの定義</a></span></dt><dt><span class="section"><a href="stored-programs-views.html#stored-routines">20.2 ストアドルーチン (プロシージャーと関数) の使用</a></span></dt><dd><dl><dt><span class="section"><a href="stored-programs-views.html#stored-routines-syntax">20.2.1 ストアドルーチンの構文</a></span></dt><dt><span class="section"><a href="stored-programs-views.html#stored-routines-privileges">20.2.2 ストアドルーチンと MySQL 権限</a></span></dt><dt><span class="section"><a href="stored-programs-views.html#stored-routines-metadata">20.2.3 ストアドルーチンのメタデータ</a></span></dt><dt><span class="section"><a href="stored-programs-views.html#stored-routines-last-insert-id">20.2.4 ストアドプロシージャー、関数、トリガー、および LAST_INSERT_ID()</a></span></dt></dl></dd><dt><span class="section"><a href="stored-programs-views.html#triggers">20.3 トリガーの使用</a></span></dt><dd><dl><dt><span class="section"><a href="stored-programs-views.html#trigger-syntax">20.3.1 トリガーの構文と例</a></span></dt><dt><span class="section"><a href="stored-programs-views.html#trigger-metadata">20.3.2 トリガーのメタデータ</a></span></dt></dl></dd><dt><span class="section"><a href="stored-programs-views.html#events">20.4 イベントスケジューラの使用</a></span></dt><dd><dl><dt><span class="section"><a href="stored-programs-views.html#events-overview">20.4.1 イベントスケジューラの概要</a></span></dt><dt><span class="section"><a href="stored-programs-views.html#events-configuration">20.4.2 イベントスケジューラの構成</a></span></dt><dt><span class="section"><a href="stored-programs-views.html#events-syntax">20.4.3 イベント構文</a></span></dt><dt><span class="section"><a href="stored-programs-views.html#events-metadata">20.4.4 イベントメタデータ</a></span></dt><dt><span class="section"><a href="stored-programs-views.html#events-status-info">20.4.5 イベントスケジューラのステータス</a></span></dt><dt><span class="section"><a href="stored-programs-views.html#events-privileges">20.4.6 イベントスケジューラと MySQL 権限</a></span></dt></dl></dd><dt><span class="section"><a href="stored-programs-views.html#views">20.5 ビューの使用</a></span></dt><dd><dl><dt><span class="section"><a href="stored-programs-views.html#view-syntax">20.5.1 ビューの構文</a></span></dt><dt><span class="section"><a href="stored-programs-views.html#view-algorithms">20.5.2 ビュー処理アルゴリズム</a></span></dt><dt><span class="section"><a href="stored-programs-views.html#view-updatability">20.5.3 更新可能および挿入可能なビュー</a></span></dt><dt><span class="section"><a href="stored-programs-views.html#view-metadata">20.5.4 ビューのメタデータ</a></span></dt></dl></dd><dt><span class="section"><a href="stored-programs-views.html#stored-programs-security">20.6 ストアドプログラムおよびビューのアクセスコントロール</a></span></dt><dt><span class="section"><a href="stored-programs-views.html#stored-programs-logging">20.7 ストアドプログラムのバイナリロギング</a></span></dt></dl></div><a class="indexterm" name="idm139979013834192"></a><a class="indexterm" name="idm139979013832736"></a><a class="indexterm" name="idm139979013830704"></a><a class="indexterm" name="idm139979013829360"></a><a class="indexterm" name="idm139979013828016"></a><a class="indexterm" name="idm139979013826640"></a><p>
    この章では、あとから実行するためにサーバーに格納された SQL コードの点で定義されたデータベースオブジェクトである、ストアドプログラムとビューについて説明します。
  </p><p>
    ストアドプログラムには次のオブジェクトが含まれます。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        ストアドルーチン、つまりストアドプロシージャーとストアドファンクション。ストアドプロシージャーは、<code class="literal">CALL</code> ステートメントを使用して呼び出されます。プロシージャーは、戻り値がありませんが、呼び出し元があとから検査できるようにそのパラメータを変更できます。また、クライアントプログラムに戻される結果セットも生成できます。ストアドファンクションは、組み込み関数と同様に使用されます。式で呼び出すと、式評価中に値を返します。
      </p></li><li class="listitem"><p>
        トリガー。トリガーは、テーブルに関連付けられ、そのテーブルに対して挿入や更新などの特定のイベントが起きたときにアクティブ化される、名前付きのデータベースオブジェクトです。
      </p></li><li class="listitem"><p>
        イベント。イベントとは、スケジュールに従ってサーバーが実行するタスクです。
      </p></li></ul></div><p>
    ビューは、参照されたときに結果セットを生成するストアドクエリーです。ビューは仮想テーブルとして機能します。
  </p><p>
    この章では、ストアドプログラムおよびビューを使用する方法について説明します。次のセクションで、これらのオブジェクトに関連したステートメントの SQL 構文に関する追加情報を示します。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        オブジェクト型ごとに、どのオブジェクトが存在し、どのように定義されているかを制御する <code class="literal">CREATE</code>、<code class="literal">ALTER</code>、および <code class="literal">DROP</code> ステートメントがあります。<a class="xref" href="sql-syntax.html#sql-syntax-data-definition" title="13.1 データ定義ステートメント">セクション13.1「データ定義ステートメント」</a>を参照してください。
      </p></li><li class="listitem"><p>
        <code class="literal">CALL</code> ステートメントは、ストアドプロシージャーの呼び出しに使用されます。<a class="xref" href="sql-syntax.html#call" title="13.2.1 CALL 構文">セクション13.2.1「CALL 構文」</a>を参照してください。
      </p></li><li class="listitem"><p>
        ストアドプログラム定義には、複合ステートメント、ループ、条件文、および宣言された変数を使用できる本体が含まれます。<a class="xref" href="sql-syntax.html#sql-syntax-compound-statements" title="13.6 MySQL 複合ステートメント構文">セクション13.6「MySQL 複合ステートメント構文」</a>を参照してください。
      </p></li></ul></div><p>
    MySQL 5.6.6 以降では、ストアドプログラムによって参照されるオブジェクトへのメタデータ変更が検出され、そのプログラムが次に実行されときに、影響を受けるステートメントの自動再解析が行われるようになります。詳細については、<a class="xref" href="optimization.html#statement-caching" title="8.9.4 プリペアドステートメントおよびストアドプログラムのキャッシュ">セクション8.9.4「プリペアドステートメントおよびストアドプログラムのキャッシュ」</a>を参照してください。
  </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="stored-programs-defining"></a>20.1 ストアドプログラムの定義</h2></div></div></div><p>
      各ストアドプログラムには、SQL ステートメントから構成される本体が含まれます。このステートメントは、セミコロン (<code class="literal">;</code>) 文字で区切られた複数のステートメントから構成される複合ステートメントの場合があります。たとえば、次のストアドプロシージャーには、<code class="literal">SET</code> ステートメントと <code class="literal">REPEAT</code> ループ (ループ自体に別の <code class="literal">SET</code> ステートメントが含まれます) を含む <code class="literal">BEGIN ... END</code> ブロックから構成される本体があります。
    </p><pre class="programlisting">
CREATE PROCEDURE dorepeat(p1 INT)
BEGIN
  SET @x = 0;
  REPEAT SET @x = @x + 1; UNTIL @x &gt; p1 END REPEAT;
END;
</pre><p>
      <span class="command"><strong>mysql</strong></span> クライアントプログラムを使用してセミコロン文字を含むストアドプログラムを定義すると、問題が発生します。デフォルトでは、<span class="command"><strong>mysql</strong></span> 自体はセミコロンをステートメント区切り文字と認識します。したがって、<span class="command"><strong>mysql</strong></span> がストアドプログラム定義全体をサーバーに渡すように、区切り文字を一時的に再定義する必要があります。
    </p><p>
      <span class="command"><strong>mysql</strong></span> の区切り文字を再定義するには、<code class="literal">delimiter</code> コマンドを使用します。次の例は、上記の <code class="literal">dorepeat()</code> プロシージャーについてこれを行う方法を示しています。区切り文字は <code class="literal">//</code> に変更され、定義全体を単一のステートメントとしてサーバーに渡して、プロシージャーの呼び出し前に <code class="literal">;</code> にリストアできます。これにより、プロシージャー本体で使用される <code class="literal">;</code> 区切り文字を、<span class="command"><strong>mysql</strong></span> 自体が解釈するのではなく、サーバーに渡すようにすることができます。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>delimiter //</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE PROCEDURE dorepeat(p1 INT)</code></strong>
    -&gt; <strong class="userinput"><code>BEGIN</code></strong>
    -&gt;   <strong class="userinput"><code>SET @x = 0;</code></strong>
    -&gt;   <strong class="userinput"><code>REPEAT SET @x = @x + 1; UNTIL @x &gt; p1 END REPEAT;</code></strong>
    -&gt; <strong class="userinput"><code>END</code></strong>
    -&gt; <strong class="userinput"><code>//</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>delimiter ;</code></strong>

mysql&gt; <strong class="userinput"><code>CALL dorepeat(1000);</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT @x;</code></strong>
+------+
| @x   |
+------+
| 1001 |
+------+
1 row in set (0.00 sec)
</pre><p>
      区切り文字を <code class="literal">//</code> 以外の文字列に再定義でき、区切り文字は単一の文字から構成することも、複数の文字から構成することもできます。バックスラッシュ (<span class="quote">「<span class="quote"><code class="literal">\</code></span>」</span>) 文字は、MySQL のエスケープ文字なので使用しないでください。
    </p><p>
      次に、パラメータを受け取り、SQL 関数を使用して操作を実行したあと、結果を返す関数例を示します。この場合は、関数定義に内部の <code class="literal">;</code> ステートメント区切り文字が含まれていないため、<code class="literal">delimiter</code> を使用する必要はありません。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE FUNCTION hello (s CHAR(20))</code></strong>
mysql&gt; <strong class="userinput"><code>RETURNS CHAR(50) DETERMINISTIC</code></strong>
    -&gt; <strong class="userinput"><code>RETURN CONCAT('Hello, ',s,'!');</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT hello('world');</code></strong>
+----------------+
| hello('world') |
+----------------+
| Hello, world!  |
+----------------+
1 row in set (0.00 sec)
</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="stored-routines"></a>20.2 ストアドルーチン (プロシージャーと関数) の使用</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="stored-programs-views.html#stored-routines-syntax">20.2.1 ストアドルーチンの構文</a></span></dt><dt><span class="section"><a href="stored-programs-views.html#stored-routines-privileges">20.2.2 ストアドルーチンと MySQL 権限</a></span></dt><dt><span class="section"><a href="stored-programs-views.html#stored-routines-metadata">20.2.3 ストアドルーチンのメタデータ</a></span></dt><dt><span class="section"><a href="stored-programs-views.html#stored-routines-last-insert-id">20.2.4 ストアドプロシージャー、関数、トリガー、および LAST_INSERT_ID()</a></span></dt></dl></div><a class="indexterm" name="idm139979013769520"></a><a class="indexterm" name="idm139979013768064"></a><a class="indexterm" name="idm139979013766032"></a><a class="indexterm" name="idm139979013764656"></a><p>
    ストアドルーチン (プロシージャーおよび関数) は MySQL 5.6 でサポートされています。ストアドルーチンとは、サーバーに格納できる一連の SQL ステートメントです。これが行われていると、クライアントは個々のステートメントを繰り返し発行し続ける必要はなく、代わりにストアドルーチンを参照できます。
  </p><p>
    ストアドルーチンには、<code class="literal">mysql</code> データベース内の <code class="literal">proc</code> テーブルが必要です。このテーブルは、MySQL 5.6 インストール手順中に作成されます。以前のバージョンから MySQL 5.6 にアップグレードしている場合、必ず付与テーブルを更新して、<code class="literal">proc</code> テーブルの存在を確認してください。<a class="xref" href="programs.html#mysql-upgrade" title="4.4.7 mysql_upgrade — MySQL テーブルのチェックとアップグレード">セクション4.4.7「<span class="command"><strong>mysql_upgrade</strong></span> — MySQL テーブルのチェックとアップグレード」</a>を参照してください。
  </p><p>
    ストアドルーチンは特に、次のような特定の状況で役立ちます。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        クライアントアプリケーションが異なる言語で作成されているか、異なるプラットフォームで動作しているが、同じデータベース操作を実行する必要がある場合。
      </p></li><li class="listitem"><p>
        セキュリティーが最重要である場合。たとえば、銀行では、すべての一般的な操作に対してストアドプロシージャーおよびストアドファンクションを使用します。これにより一貫したセキュアな環境が得られ、ルーチンによってそれぞれの操作が正しく記録されるようになります。このようなセットアップでは、アプリケーションおよびユーザーはデータベーステーブルに直接アクセスできませんが、特定のストアドルーチンだけを実行できます。
      </p></li></ul></div><p>
    ストアドルーチンは、サーバーとクライアント間で送信する必要のある情報が少なくなるので、パフォーマンスを改善できます。そのトレードオフでは、これによりサーバー側で行われる作業が増え、クライアント (アプリケーション) 側で行われる作業が少なくなるので、データベースサーバーでのロードが増大します。1 台または少数のデータベースサーバーだけで多数のクライアントマシン (Web サーバーなど) にサービスを提供している場合にはこれを検討してください。
  </p><p>
    ストアドルーチンを使用すれば、データベースサーバーで関数のライブラリを保持することもできます。これは、内部的に (たとえばクラスを使用して) このような設計を可能にする、現代のアプリケーション言語で共有されている機能です。これらのクライアントアプリケーションの言語機能を使用すると、データベース使用のスコープ外でもプログラマにとって利点があります。
  </p><p>
    MySQL はストアドルーチンについて SQL:2003 構文に従っており、これは IBM の DB2 でも使用されています。ここで説明するすべての構文はサポートされており、すべての制限と拡張が適宜ドキュメント化されています。
  </p><h3><a name="idm139979013750304"></a>追加のリソース</h3><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        ストアドプロシージャーおよびストアドファンクションを扱うときに、<a class="ulink" href="http://forums.mysql.com/list.php?98" target="_top">ストアドプロシージャーのユーザーフォーラム</a>が役立ちます。
      </p></li><li class="listitem"><p>
        MySQL のストアドルーチンに関するよくある質問とその回答については、<a class="xref" href="faqs.html#faqs-stored-procs" title="A.4 MySQL 5.6 FAQ: ストアドプロシージャーおよびストアドファンクション">セクションA.4「MySQL 5.6 FAQ: ストアドプロシージャーおよびストアドファンクション」</a>を参照してください。
      </p></li><li class="listitem"><p>
        ストアドルーチンの使用にはいくつかの制限があります。<a class="xref" href="restrictions.html#stored-program-restrictions" title="D.1 ストアドプログラムの制約">セクションD.1「ストアドプログラムの制約」</a>を参照してください。
      </p></li><li class="listitem"><p>
        ストアドルーチンのバイナリロギングは、<a class="xref" href="stored-programs-views.html#stored-programs-logging" title="20.7 ストアドプログラムのバイナリロギング">セクション20.7「ストアドプログラムのバイナリロギング」</a>で説明しているように行われます。
      </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="stored-routines-syntax"></a>20.2.1 ストアドルーチンの構文</h3></div></div></div><p>
      ストアドルーチンはプロシージャーまたは関数のどちらかです。ストアドルーチンは、<code class="literal">CREATE PROCEDURE</code> および <code class="literal">CREATE FUNCTION</code> ステートメントで作成されます (<a class="xref" href="sql-syntax.html#create-procedure" title="13.1.15 CREATE PROCEDURE および CREATE FUNCTION 構文">セクション13.1.15「CREATE PROCEDURE および CREATE FUNCTION 構文」</a>を参照してください)。プロシージャーは <code class="literal">CALL</code> ステートメントを使用して呼び出され (<a class="xref" href="sql-syntax.html#call" title="13.2.1 CALL 構文">セクション13.2.1「CALL 構文」</a>を参照してください)、出力変数の使用でのみ値を戻すことができます。関数は、ほかの関数とまったく同様に (つまり、関数の名前を呼び出すことによって) ステートメント内部から呼び出すことができ、スカラー値を戻すことができます。ストアドルーチンの本体では、複合ステートメントを使用できます (<a class="xref" href="sql-syntax.html#sql-syntax-compound-statements" title="13.6 MySQL 複合ステートメント構文">セクション13.6「MySQL 複合ステートメント構文」</a>を参照してください)。
    </p><p>
      ストアドルーチンは、<code class="literal">DROP PROCEDURE</code> および <code class="literal">DROP FUNCTION</code> ステートメントで削除でき (<a class="xref" href="sql-syntax.html#drop-procedure" title="13.1.26 DROP PROCEDURE および DROP FUNCTION 構文">セクション13.1.26「DROP PROCEDURE および DROP FUNCTION 構文」</a>を参照してください)、<code class="literal">ALTER PROCEDURE</code> および <code class="literal">ALTER FUNCTION</code> ステートメントで変更できます (<a class="xref" href="sql-syntax.html#alter-procedure" title="13.1.5 ALTER PROCEDURE 構文">セクション13.1.5「ALTER PROCEDURE 構文」</a>を参照してください)。
    </p><p>
      ストアドプロシージャーまたはストアドファンクションは、特定のデータベースに関連付けられています。これにはいくつかの問題があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ルーチンが呼び出されると、暗黙の <code class="literal">USE <em class="replaceable"><code>db_name</code></em></code> が実行されます (その後、ルーチンが終了すると元に戻ります)。ストアドルーチン内での <code class="literal">USE</code> ステートメントは許可されていません。
        </p></li><li class="listitem"><p>
          データベース名でルーチン名を修飾できます。これは現在のデータベースに存在しないルーチンを参照する場合に使用できます。たとえば、<code class="literal">test</code>データベースに関連するストアドプロシージャー <code class="literal">p</code> またはストアドファンクション <code class="literal">f</code> を呼び出すには、<code class="literal">CALL test.p()</code> または <code class="literal">test.f()</code> と指定します。
        </p></li><li class="listitem"><p>
          データベースを削除すると、そのデータベースに関連付けられたすべてのストアドルーチンも削除されます。
        </p></li></ul></div><p>
      ストアドファンクションは再帰関数にはできません。
    </p><p>
      ストアドプロシージャーでの再帰は許可されていますが、デフォルトでは無効になっています。再帰を有効にするには、<code class="literal">max_sp_recursion_depth</code> サーバーシステム変数を正の値に設定します。ストアドプロシージャーの再帰により、スレッドスタック領域の要求が増加します。<code class="literal">max_sp_recursion_depth</code> の値を増やした場合、サーバー起動時に <code class="literal">thread_stack</code> の値を増やすことによってスレッドスタックサイズを増やすことが必要な場合もあります。詳細は、<a class="xref" href="server-administration.html#server-system-variables" title="5.1.4 サーバーシステム変数">セクション5.1.4「サーバーシステム変数」</a>を参照してください。
    </p><p>
      MySQL では、通常の <code class="literal">SELECT</code> ステートメントをストアドプロシージャー内で (つまり、カーソルまたはローカル変数を使用せずに) 使用できるようにする非常に役立つ拡張をサポートしています。このようなクエリーの結果セットは単にクライアントに直接送信されます。複数の <code class="literal">SELECT</code> ステートメントは複数の結果セットを生成するので、クライアントは複数の結果セットをサポートしている MySQL クライアントライブラリを使用する必要があります。これは、クライアントが、4.1 以降の MySQL のバージョンからクライアントライブラリを使用する必要があることを意味します。クライアントは、接続するときに、<code class="literal">CLIENT_MULTI_RESULTS</code> オプションも指定する必要があります。C プログラムの場合、これは、<code class="literal">mysql_real_connect()</code>C API 関数で実行できます。<a class="xref" href="connectors-apis.html#mysql-real-connect" title="23.8.7.53 mysql_real_connect()">セクション23.8.7.53「mysql_real_connect()」</a>および<a class="xref" href="connectors-apis.html#c-api-multiple-queries" title="23.8.17 複数ステートメント実行の C API サポート">セクション23.8.17「複数ステートメント実行の C API サポート」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="stored-routines-privileges"></a>20.2.2 ストアドルーチンと MySQL 権限</h3></div></div></div><p>
      MySQL 許可システムはストアドルーチンを次のように考慮します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ストアドルーチンを生成するには、<code class="literal">CREATE ROUTINE</code> 権限が必要です。
        </p></li><li class="listitem"><p>
          ストアドルーチンを変更または削除するには、<code class="literal">ALTER ROUTINE</code> 権限が必要です。この権限は、必要に応じて、ルーチンの作成者に自動的に与えられ、ルーチンが削除されると作成者から削除されます。
        </p></li><li class="listitem"><p>
          ストアドルーチンを実行するには、<code class="literal">EXECUTE</code> 権限が必要です。ただし、この権限は、必要に応じて、ルーチンの作成者に自動的に与えられます (ルーチンが削除されると作成者から削除されます)。また、ルーチンのデフォルトの <code class="literal">SQL SECURITY</code> 特性は <code class="literal">DEFINER</code> であり、これにより、ルーチンが関連付けられているデータベースにアクセス可能なユーザーがルーチンを実行できるようになります。
        </p></li><li class="listitem"><p>
          <code class="literal">automatic_sp_privileges</code> システム変数が 0 である場合、<code class="literal">EXECUTE</code> および <code class="literal">ALTER ROUTINE</code> 権限は作成者に対して自動的には付与および削除されません。
        </p></li><li class="listitem"><p>
          ルーチンの作成者は、ルーチンの <code class="literal">CREATE</code> ステートメントを実行するために使用されるアカウントです。これは、ルーチン定義で <code class="literal">DEFINER</code> として名前が指定されているアカウントと同じでないことがあります。
        </p></li></ul></div><p>
      サーバーは、ストアドルーチンを作成、変更、または削除するステートメントに応じて、<code class="literal">mysql.proc</code> テーブルを操作します。このテーブルの手動操作に対するサーバーでの認識はサポートされていません。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="stored-routines-metadata"></a>20.2.3 ストアドルーチンのメタデータ</h3></div></div></div><a class="indexterm" name="idm139979013684928"></a><a class="indexterm" name="idm139979013682800"></a><p>
      ストアドルーチンに関するメタデータは次のように取得できます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">INFORMATION_SCHEMA</code> データベースの <code class="literal">ROUTINES</code> テーブルをクエリーします。<a class="xref" href="information-schema.html#routines-table" title="21.18 INFORMATION_SCHEMA ROUTINES テーブル">セクション21.18「INFORMATION_SCHEMA ROUTINES テーブル」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">SHOW CREATE PROCEDURE</code> および <code class="literal">SHOW CREATE FUNCTION</code> ステートメントを使用して、ルーチン定義を表示します。<a class="xref" href="sql-syntax.html#show-create-procedure" title="13.7.5.11 SHOW CREATE PROCEDURE 構文">セクション13.7.5.11「SHOW CREATE PROCEDURE 構文」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">SHOW PROCEDURE STATUS</code> および <code class="literal">SHOW FUNCTION STATUS</code> ステートメントを使用して、ルーチン特性を表示します。<a class="xref" href="sql-syntax.html#show-procedure-status" title="13.7.5.29 SHOW PROCEDURE STATUS 構文">セクション13.7.5.29「SHOW PROCEDURE STATUS 構文」</a>を参照してください。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="stored-routines-last-insert-id"></a>20.2.4 ストアドプロシージャー、関数、トリガー、および LAST_INSERT_ID()</h3></div></div></div><a class="indexterm" name="idm139979013668000"></a><a class="indexterm" name="idm139979013665904"></a><a class="indexterm" name="idm139979013663872"></a><a class="indexterm" name="idm139979013661920"></a><p>
      ストアドルーチン (プロシージャーまたは関数) またはトリガーの本体内では、<code class="literal">LAST_INSERT_ID()</code> の値は、このような種類のオブジェクトの本体外で実行されたステートメントと同様に変更されます (<a class="xref" href="functions.html#information-functions" title="12.14 情報関数">セクション12.14「情報関数」</a>を参照してください)。あとに続くステートメントで参照される <code class="literal">LAST_INSERT_ID()</code> の値でのストアドルーチンまたはトリガーの効果は、ルーチンの種類によって異なります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ストアドプロシージャーで <code class="literal">LAST_INSERT_ID()</code> の値を変更するステートメントが実行される場合は、プロシージャー呼び出しが続くステートメントで変更された値が参照されます。
        </p></li><li class="listitem"><p>
          値を変更するストアドファンクションやトリガーでは、値は関数やトリガーが終了したときにリストアされるので、後続のステートメントは変更された値を表示しません。
        </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="triggers"></a>20.3 トリガーの使用</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="stored-programs-views.html#trigger-syntax">20.3.1 トリガーの構文と例</a></span></dt><dt><span class="section"><a href="stored-programs-views.html#trigger-metadata">20.3.2 トリガーのメタデータ</a></span></dt></dl></div><a class="indexterm" name="idm139979013650784"></a><p>
    トリガーとは、テーブルに関連付けられ、そのテーブルに対して特定のイベントが発生するとアクティブ化される名前付きデータベースオブジェクトのことです。トリガーを使用する場合には、テーブルに挿入する値のチェックを実行したり、更新にかかわる値の計算を実行したりする場合があります。
  </p><p>
    トリガーは、関連付けられたテーブルでステートメントが行の挿入、更新、または削除を行なったときにアクティブ化するように定義されます。これらの行操作がトリガーイベントになります。たとえば、行は、<code class="literal">INSERT</code> または <code class="literal">LOAD DATA</code> ステートメントで挿入でき、挿入トリガーは挿入された行ごとにアクティブ化します。トリガーは、トリガーイベントの前または後のどちらかでアクティブ化するように設定できます。たとえば、テーブルに挿入される各行の前、または更新される各行のあとでトリガーをアクティブ化させることができます。
  </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
      MySQL のトリガーは、SQL ステートメントがテーブルに対して行なった変更の場合にのみアクティブ化します。ビューでの変更や、SQL ステートメントを MySQL Server に転送しない API がテーブルに対して行なった変更ではアクティブ化しません。これは次のことを意味します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">INFORMATION_SCHEMA</code> または <code class="literal">performance_schema</code> テーブルは実際にはビューなので、トリガーは、これらのテーブルでの変更ではアクティブ化されません。
        </p></li><li class="listitem"><p>
          トリガーは、<code class="literal">NDB</code> API を使用して行われた更新によってアクティブ化されません。
        </p></li></ul></div></div><p>
    次のセクションでは、トリガーを作成および削除するための構文について説明し、使用方法の例をいくつか挙げ、トリガーメタデータを取得する方法を示します。
  </p><h3><a name="idm139979013637680"></a>追加のリソース</h3><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        トリガーを扱うときには、<a class="ulink" href="http://forums.mysql.com/list.php?100" target="_top">トリガーユーザーフォーラム</a>が役立ちます。
      </p></li><li class="listitem"><p>
        MySQL でのトリガーに関するよくある質問とその回答については、<a class="xref" href="faqs.html#faqs-triggers" title="A.5 MySQL 5.6 FAQ: トリガー">セクションA.5「MySQL 5.6 FAQ: トリガー」</a>を参照してください。
      </p></li><li class="listitem"><p>
        トリガーの使用にはいくつかの制限があります。<a class="xref" href="restrictions.html#stored-program-restrictions" title="D.1 ストアドプログラムの制約">セクションD.1「ストアドプログラムの制約」</a>を参照してください。
      </p></li><li class="listitem"><p>
        トリガーのバイナリロギングは、<a class="xref" href="stored-programs-views.html#stored-programs-logging" title="20.7 ストアドプログラムのバイナリロギング">セクション20.7「ストアドプログラムのバイナリロギング」</a>で説明しているように行います。
      </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="trigger-syntax"></a>20.3.1 トリガーの構文と例</h3></div></div></div><p>
      トリガーを作成したり、トリガーを削除したりするには、<a class="xref" href="sql-syntax.html#create-trigger" title="13.1.19 CREATE TRIGGER 構文">セクション13.1.19「CREATE TRIGGER 構文」</a>および<a class="xref" href="sql-syntax.html#drop-trigger" title="13.1.30 DROP TRIGGER 構文">セクション13.1.30「DROP TRIGGER 構文」</a>で説明しているように、<code class="literal">CREATE TRIGGER</code> または <code class="literal">DROP TRIGGER</code> ステートメントを使用します。
    </p><p>
      次に、<code class="literal">INSERT</code> 操作に対してアクティブ化するトリガーをテーブルに関連付ける簡単な例を示します。このトリガーは加算器として機能し、テーブルのいずれかのカラムに挿入された値を合計します。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE account (acct_num INT, amount DECIMAL(10,2));</code></strong>
Query OK, 0 rows affected (0.03 sec)

mysql&gt; <strong class="userinput"><code>CREATE TRIGGER ins_sum BEFORE INSERT ON account</code></strong>
    -&gt; <strong class="userinput"><code>FOR EACH ROW SET @sum = @sum + NEW.amount;</code></strong>
Query OK, 0 rows affected (0.06 sec)
</pre><p>
      <code class="literal">CREATE TRIGGER</code> ステートメントは、<code class="literal">account</code> テーブルに関連付けられている <code class="literal">ins_sum</code> という名前のトリガーを作成します。トリガーアクションタイム、トリガーイベント、およびトリガーがアクティブ化したときに行う動作を指定する句も含みます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          キーワード <code class="literal">BEFORE</code> は、トリガーアクションタイムを示します。この場合、トリガーは、テーブルに挿入された各行の前にアクティブ化します。ここで許可されている別のキーワードは <code class="literal">AFTER</code> です。
        </p></li><li class="listitem"><p>
          キーワード <code class="literal">INSERT</code> は、トリガーイベント、つまりトリガーをアクティブ化する操作の種類を示します。例では、<code class="literal">INSERT</code> 操作がトリガーのアクティブ化を引き起こします。<code class="literal">DELETE</code> および <code class="literal">UPDATE</code> 操作に対するトリガーも作成できます。
        </p></li><li class="listitem"><p>
          <code class="literal">FOR EACH ROW</code> に続くステートメントは、トリガー本体を定義します。これは、トリガーがアクティブ化するたびに実行するステートメントであり、トリガーイベントによって影響される行ごとに一度行われます。この例では、トリガー本体は、<code class="literal">amount</code> カラムに挿入された値をユーザー変数に累積する単純な <code class="literal">SET</code> です。このステートメントは、<span class="quote">「<span class="quote">新しい行に挿入される <code class="literal">amount</code> カラムの値</span>」</span>を意味する <code class="literal">NEW.amount</code> としてカラムを参照します。
        </p></li></ul></div><p>
      トリガーを使用するには、加算器変数をゼロにセットし、<code class="literal">INSERT</code> ステートメントを実行して、その後変数がどの値になっているかを確認します。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET @sum = 0;</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO account VALUES(137,14.98),(141,1937.50),(97,-100.00);</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT @sum AS 'Total amount inserted';</code></strong>
+-----------------------+
| Total amount inserted |
+-----------------------+
| 1852.48               |
+-----------------------+
</pre><p>
      この場合、<code class="literal">INSERT</code> ステートメントの実行後の <code class="literal">@sum</code> の値は <code class="literal">14.98 + 1937.50 - 100</code> または <code class="literal">1852.48</code> です。
    </p><p>
      トリガーを破棄するには、<code class="literal">DROP TRIGGER</code> ステートメントを使用します。トリガーがデフォルトスキーマにない場合、スキーマ名を指定する必要があります。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>DROP TRIGGER test.ins_sum;</code></strong>
</pre><p>
      テーブルを削除すると、そのテーブルのトリガーもすべて削除されます。
    </p><p>
      トリガー名はスキーマの名前空間内に存在します。つまり、すべてのトリガーがスキーマ内で一意の名前を持つ必要があります。異なるスキーマ内のトリガーは同じ名前を持つことができます。
    </p><p>
      トリガー名はスキーマに対して一意であるという要件以外に、作成できるトリガーの種類に対して別の制限があります。特に、所定のテーブルに、同じトリガーイベントとアクションタイムを持つ複数のトリガーを含めることはできません。たとえば、1 つのテーブルに対して 2 つの <code class="literal">BEFORE UPDATE</code> トリガーを定義することはできません。これに対処するために、<code class="literal">FOR EACH ROW</code> のあとで <code class="literal">BEGIN ... END</code> 複合ステートメント構造構文を使用することにより、複数のステートメントを実行するトリガーを定義できます。(例はこのセクションであとから示します。)
    </p><p>
      トリガー本体内で、<code class="literal">OLD</code> および <code class="literal">NEW</code> キーワードを使用すると、トリガーの影響を受ける行のカラムにアクセスできます。<code class="literal">OLD</code> および <code class="literal">NEW</code> はトリガーに対する MySQL の拡張です。これらは大文字と小文字を区別しません。
    </p><p>
      <code class="literal">INSERT</code> トリガー内では、<code class="literal">NEW.<em class="replaceable"><code>col_name</code></em></code> だけを使用できます。古い行はありません。<code class="literal">DELETE</code> トリガーでは、<code class="literal">OLD.<em class="replaceable"><code>col_name</code></em></code> だけを使用できます。新しい行はありません。<code class="literal">UPDATE</code> トリガーでは、<code class="literal">OLD.<em class="replaceable"><code>col_name</code></em></code> を使用して、更新される前の行のカラムを参照でき、<code class="literal">NEW.<em class="replaceable"><code>col_name</code></em></code> を使用して、更新されたあとの行のカラムを参照できます。
    </p><p>
      <code class="literal">OLD</code> で指名されたカラムは読み取り専用です。(それに対する <code class="literal">SELECT</code> 権限がある場合) 参照はできますが、変更はできません。<code class="literal">NEW</code> で指名されたカラムは、それに対する <code class="literal">SELECT</code> 権限がある場合に参照できます。<code class="literal">BEFORE</code> トリガーでは、それに対する <code class="literal">UPDATE</code> 権限がある場合、<code class="literal">SET NEW.<em class="replaceable"><code>col_name</code></em> = <em class="replaceable"><code>value</code></em></code> でその値を変更することもできます。これは、トリガーを使用して、新しい行に挿入する値または行の更新に使用される値を変更できることを意味します。(このような <code class="literal">SET</code> ステートメントは、行の変更はすでに行われているため、<code class="literal">AFTER</code> トリガーでは効果がありません。)
    </p><p>
      <code class="literal">BEFORE</code> トリガーでは、<code class="literal">AUTO_INCREMENT</code> カラムの <code class="literal">NEW</code> 値は 0 であり、新しい行が実際に挿入されるときに自動的に生成されるシーケンス番号ではありません。
    </p><p>
      <code class="literal">BEGIN ... END</code> 構造構文を使用することにより、複数のステートメントを実行するトリガーを定義できます。<code class="literal">BEGIN</code> ブロック内では、条件文やループなど、ストアドルーチン内で許可されたほかの構文を使用することもできます。ただし、ストアドルーチンの場合と同様に、<span class="command"><strong>mysql</strong></span> プログラムを使用して、複数のステートメントを実行するトリガーを定義する場合、トリガー定義内で <code class="literal">;</code> ステートメント区切り文字を使用できるように、<span class="command"><strong>mysql</strong></span> ステートメント区切り文字を再定義する必要があります。次の例はこれらの要点を示しています。ここでは、各行の更新に使用する新しい値をチェックし、0 から 100 の範囲に収まるように値を変更する <code class="literal">UPDATE</code> トリガーを定義しています。行の更新に使用される前に値をチェックする必要があるので、これは <code class="literal">BEFORE</code> トリガーにする必要があります。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>delimiter //</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE TRIGGER upd_check BEFORE UPDATE ON account</code></strong>
    -&gt; <strong class="userinput"><code>FOR EACH ROW</code></strong>
    -&gt; <strong class="userinput"><code>BEGIN</code></strong>
    -&gt;     <strong class="userinput"><code>IF NEW.amount &lt; 0 THEN</code></strong>
    -&gt;         <strong class="userinput"><code>SET NEW.amount = 0;</code></strong>
    -&gt;     <strong class="userinput"><code>ELSEIF NEW.amount &gt; 100 THEN</code></strong>
    -&gt;         <strong class="userinput"><code>SET NEW.amount = 100;</code></strong>
    -&gt;     <strong class="userinput"><code>END IF;</code></strong>
    -&gt; <strong class="userinput"><code>END;//</code></strong>
mysql&gt; <strong class="userinput"><code>delimiter ;</code></strong>
</pre><p>
      ストアドプロシージャーを個別に定義してから、単純な <code class="literal">CALL</code> ステートメントを使用してトリガーから呼び出したほうが簡単になる場合があります。これは、複数のトリガー内から同じコードを実行する場合にも便利です。
    </p><p>
      アクティブ化したときにトリガーが実行するステートメントに表示できる対象には制限があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          トリガーは、<code class="literal">CALL</code> ステートメントを使用して、データをクライアントに戻すストアドプロシージャーや、ダイナミック SQL を使用するストアドプロシージャーの呼び出しはできません。(ストアドプロシージャーは、<code class="literal">OUT</code> または <code class="literal">INOUT</code> パラメータを通じてトリガーにデータを返すことが許可されています。)
        </p></li><li class="listitem"><p>
          トリガーは、<code class="literal">START TRANSACTION</code>、<code class="literal">COMMIT</code>、<code class="literal">ROLLBACK</code> など、トランザクションを明示的または暗黙的に開始したり終了したりするステートメントを使用できません。
        </p></li></ul></div><p>
      <a class="xref" href="restrictions.html#stored-program-restrictions" title="D.1 ストアドプログラムの制約">セクションD.1「ストアドプログラムの制約」</a>も参照してください。
    </p><p>
      MySQL は次のようにトリガー実行中にエラーを処理します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">BEFORE</code> トリガーが失敗した場合、対応する行に対する操作は実行されません。
        </p></li><li class="listitem"><p>
          <code class="literal">BEFORE</code> トリガーは、行を挿入または変更しようとする<span class="emphasis"><em>試行</em></span> によってアクティブ化され、その試行がその後成功するかどうかには関係ありません。
        </p></li><li class="listitem"><p>
          <code class="literal">AFTER</code> トリガーは、すべての <code class="literal">BEFORE</code> トリガーと行操作の実行が成功した場合にのみ実行されます。
        </p></li><li class="listitem"><p>
          <code class="literal">BEFORE</code> または <code class="literal">AFTER</code> トリガーのどちらかの実行中にエラーが発生すると、トリガーの呼び出しを起こしたステートメント全体が失敗します。
        </p></li><li class="listitem"><p>
          トランザクションテーブルの場合、ステートメントの失敗により、ステートメントが実行したすべての変更がロールバックされます。トリガーの失敗はステートメントの失敗を招くので、トリガーの失敗はロールバックも引き起こします。非トランザクションテーブルの場合、このようなロールバックは行えないので、ステートメントが失敗しても、エラーの時点以前に実行されたすべて変更は有効なままです。
        </p></li></ul></div><p>
      次の例に示す <code class="literal">testref</code> という名前のトリガーなど、トリガーには、名前によるテーブルへの直接の参照を含めることができます。
    </p><pre class="programlisting">
CREATE TABLE test1(a1 INT);
CREATE TABLE test2(a2 INT);
CREATE TABLE test3(a3 INT NOT NULL AUTO_INCREMENT PRIMARY KEY);
CREATE TABLE test4(
  a4 INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
  b4 INT DEFAULT 0
);

delimiter |

CREATE TRIGGER testref BEFORE INSERT ON test1
  FOR EACH ROW
  BEGIN
    INSERT INTO test2 SET a2 = NEW.a1;
    DELETE FROM test3 WHERE a3 = NEW.a1;
    UPDATE test4 SET b4 = b4 + 1 WHERE a4 = NEW.a1;
  END;
|

delimiter ;

INSERT INTO test3 (a3) VALUES
  (NULL), (NULL), (NULL), (NULL), (NULL),
  (NULL), (NULL), (NULL), (NULL), (NULL);

INSERT INTO test4 (a4) VALUES
  (0), (0), (0), (0), (0), (0), (0), (0), (0), (0);
</pre><p>
      次に示すように、テーブル <code class="literal">test1</code> に次の値を挿入するとします。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>INSERT INTO test1 VALUES </code></strong>
    -&gt; <strong class="userinput"><code>(1), (3), (1), (7), (1), (8), (4), (4);</code></strong>
Query OK, 8 rows affected (0.01 sec)
Records: 8  Duplicates: 0  Warnings: 0
</pre><p>
      この結果、4 つのテーブルに次のデータが含まれます。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT * FROM test1;</code></strong>
+------+
| a1   |
+------+
|    1 |
|    3 |
|    1 |
|    7 |
|    1 |
|    8 |
|    4 |
|    4 |
+------+
8 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM test2;</code></strong>
+------+
| a2   |
+------+
|    1 |
|    3 |
|    1 |
|    7 |
|    1 |
|    8 |
|    4 |
|    4 |
+------+
8 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM test3;</code></strong>
+----+
| a3 |
+----+
|  2 |
|  5 |
|  6 |
|  9 |
| 10 |
+----+
5 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM test4;</code></strong>
+----+------+
| a4 | b4   |
+----+------+
|  1 |    3 |
|  2 |    0 |
|  3 |    1 |
|  4 |    2 |
|  5 |    0 |
|  6 |    0 |
|  7 |    1 |
|  8 |    1 |
|  9 |    0 |
| 10 |    0 |
+----+------+
10 rows in set (0.00 sec)
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="trigger-metadata"></a>20.3.2 トリガーのメタデータ</h3></div></div></div><a class="indexterm" name="idm139979013507920"></a><a class="indexterm" name="idm139979013505808"></a><p>
      トリガーに関するメタデータは次のように取得できます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">INFORMATION_SCHEMA</code> データベースの <code class="literal">TRIGGERS</code> テーブルをクエリーします。<a class="xref" href="information-schema.html#triggers-table" title="21.26 INFORMATION_SCHEMA TRIGGERS テーブル">セクション21.26「INFORMATION_SCHEMA TRIGGERS テーブル」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">SHOW CREATE TRIGGER</code> ステートメントを使用します。<a class="xref" href="sql-syntax.html#show-create-trigger" title="13.7.5.13 SHOW CREATE TRIGGER 構文">セクション13.7.5.13「SHOW CREATE TRIGGER 構文」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">SHOW TRIGGERS</code> ステートメントを使用します。<a class="xref" href="sql-syntax.html#show-triggers" title="13.7.5.39 SHOW TRIGGERS 構文">セクション13.7.5.39「SHOW TRIGGERS 構文」</a>を参照してください。
        </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="events"></a>20.4 イベントスケジューラの使用</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="stored-programs-views.html#events-overview">20.4.1 イベントスケジューラの概要</a></span></dt><dt><span class="section"><a href="stored-programs-views.html#events-configuration">20.4.2 イベントスケジューラの構成</a></span></dt><dt><span class="section"><a href="stored-programs-views.html#events-syntax">20.4.3 イベント構文</a></span></dt><dt><span class="section"><a href="stored-programs-views.html#events-metadata">20.4.4 イベントメタデータ</a></span></dt><dt><span class="section"><a href="stored-programs-views.html#events-status-info">20.4.5 イベントスケジューラのステータス</a></span></dt><dt><span class="section"><a href="stored-programs-views.html#events-privileges">20.4.6 イベントスケジューラと MySQL 権限</a></span></dt></dl></div><a class="indexterm" name="idm139979013493136"></a><a class="indexterm" name="idm139979013491680"></a><p>
    <em class="firstterm">MySQL イベントスケジューラ</em>は、イベント、つまりスケジュールに従って実行するタスクのスケジュール設定および実行を管理します。次の説明では、イベントスケジューラを取り上げ、次のセクションに分かれています。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <a class="xref" href="stored-programs-views.html#events-overview" title="20.4.1 イベントスケジューラの概要">セクション20.4.1「イベントスケジューラの概要」</a>では、MySQL イベントの概論と概念的概要を示します。
      </p></li><li class="listitem"><p>
        <a class="xref" href="stored-programs-views.html#events-syntax" title="20.4.3 イベント構文">セクション20.4.3「イベント構文」</a>では、MySQL イベントを作成、変更、および削除するための SQL ステートメントについて説明します。
      </p></li><li class="listitem"><p>
        <a class="xref" href="stored-programs-views.html#events-metadata" title="20.4.4 イベントメタデータ">セクション20.4.4「イベントメタデータ」</a>では、イベントに関する情報の取得方法と、MySQL Server でのこの情報の格納方法を示します。
      </p></li><li class="listitem"><p>
        <a class="xref" href="stored-programs-views.html#events-privileges" title="20.4.6 イベントスケジューラと MySQL 権限">セクション20.4.6「イベントスケジューラと MySQL 権限」</a>では、イベントを処理するために必要な権限と、実行時に権限に関してイベントが持つ派生問題について説明します。
      </p></li></ul></div><p>
    ストアドルーチンには、<code class="literal">mysql</code> データベース内の <code class="literal">event</code> テーブルが必要です。このテーブルは、MySQL 5.6 インストール手順中に作成されます。以前のバージョンから MySQL 5.6 にアップグレードしている場合は、必ず付与テーブルを更新して、<code class="literal">event</code> テーブルがあるかどうか確認してください。<a class="xref" href="programs.html#mysql-upgrade" title="4.4.7 mysql_upgrade — MySQL テーブルのチェックとアップグレード">セクション4.4.7「<span class="command"><strong>mysql_upgrade</strong></span> — MySQL テーブルのチェックとアップグレード」</a>を参照してください。
  </p><h3><a name="idm139979013477488"></a>追加のリソース</h3><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        スケジュール設定済みイベントを扱うときには、「<a class="ulink" href="http://forums.mysql.com/list.php?119" target="_top">MySQL Event Scheduler User Forum</a>」が役立ちます。
      </p></li><li class="listitem"><p>
        イベントの使用にはいくつかの制限があります。<a class="xref" href="restrictions.html#stored-program-restrictions" title="D.1 ストアドプログラムの制約">セクションD.1「ストアドプログラムの制約」</a>を参照してください。
      </p></li><li class="listitem"><p>
        イベントのバイナリロギングは、<a class="xref" href="stored-programs-views.html#stored-programs-logging" title="20.7 ストアドプログラムのバイナリロギング">セクション20.7「ストアドプログラムのバイナリロギング」</a>で説明しているように行われます。
      </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="events-overview"></a>20.4.1 イベントスケジューラの概要</h3></div></div></div><a class="indexterm" name="idm139979013470448"></a><p>
      MySQL イベントはスケジュールに従って実行するタスクです。したがって、これらを<span class="emphasis"><em>スケジュール設定済み</em></span>イベントと呼ぶことがあります。イベントの作成時には、特定の日時に開始して終了し、1 つ以上の定期的な間隔で実行される 1 つ以上の SQL ステートメントを含んだ、名前付きデータベースオブジェクトを作成します。概念的には、このことは Unix の <code class="literal">crontab</code> (<span class="quote">「<span class="quote">cron ジョブ</span>」</span>とも呼ばれます) や、Windows のタスクスケジューラの考え方に似ています。
    </p><p>
      この種のスケジュール設定済みのタスクは、<span class="quote">「<span class="quote">時間トリガー</span>」</span>と呼ばれる場合もあり、これらが時間の経過によってトリガーされるオブジェクトであることを示しています。これは基本的には正しいのですが、<a class="xref" href="stored-programs-views.html#triggers" title="20.3 トリガーの使用">セクション20.3「トリガーの使用」</a>で説明している種類のトリガーと混同しないように、<span class="emphasis"><em>イベント</em></span>の用語を使用します。さらに厳密にいえば、イベントは<span class="quote">「<span class="quote">時間トリガー</span>」</span>と混同しないようにする必要があります。トリガーは、指定したテーブルで行われるイベントの特定の種類に応じて実行されるステートメントを持つデータベースオブジェクトですが、(スケジュール設定済み) イベントは、指定された時間間隔の経過に応じて実行されるステートメントを持つオブジェクトです。
    </p><p>
      SQL 標準にはイベントのスケジュール設定への対応はありませんが、ほかのデータベースシステムには先例があり、これらの実装と MySQL Server で見られる実装との間には一定の類似性が認められます。
    </p><p>
      MySQL イベントには次の主要機能およびプロパティーがあります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          MySQL 5.6 では、イベントはその名前と、イベントに割り当てられているスキーマによって一意に識別されます。
        </p></li><li class="listitem"><p>
          イベントは、スケジュールに従って特定のアクションを実行します。このアクションは、SQL ステートメントから構成され、必要に応じて <code class="literal">BEGIN ... END</code> ブロック内の複合ステートメントにできます (<a class="xref" href="sql-syntax.html#sql-syntax-compound-statements" title="13.6 MySQL 複合ステートメント構文">セクション13.6「MySQL 複合ステートメント構文」</a>を参照してください)。イベントのタイミングは<em class="firstterm">一度だけ</em>または<em class="firstterm">繰り返し</em>のどちらかです。一度だけのイベントは一度しか実行しません。繰り返しのイベントは、一定の間隔でアクションを繰り返し、イベントを繰り返すためのスケジュールに、特定の開始日時と終了日時の両方または一方を割り当てるか、どちらも割り当てないことができます。(デフォルトで、繰り返しイベントのスケジュールは作成されるとすぐに開始し、無効または削除されるまで継続します。)
        </p><p>
          繰り返しイベントがスケジュール間隔内に終了しない場合は、イベントの複数のインスタンスが同時に実行される可能性があります。これが好ましくない場合は、同時インスタンスを回避するためのメカニズムを設けてください。たとえば、<code class="literal">GET_LOCK()</code> 関数や、行またはテーブルのロックを使用できます。
        </p></li><li class="listitem"><p>
          ユーザーは、これらの目的用の SQL ステートメントを使用してスケジュール設定済みイベントを作成、変更、および削除できます。構文が無効なイベント作成および変更ステートメントは失敗し、対応するエラーメッセージが表示されます。<span class="emphasis"><em>ユーザーは、実際には自身が保有していない権限を必要とするステートメントを、イベントのアクションに含めることがあります</em></span>。イベントの作成または変更ステートメントは成功しますが、イベントのアクションは失敗します。詳細は、<a class="xref" href="stored-programs-views.html#events-privileges" title="20.4.6 イベントスケジューラと MySQL 権限">セクション20.4.6「イベントスケジューラと MySQL 権限」</a>を参照してください。
        </p></li><li class="listitem"><p>
          イベントのプロパティーの多くは、SQL ステートメントを使用して設定または変更できます。これらのプロパティーには、イベントの名前、タイミング、持続性 (つまり、そのスケジュールの有効期限が切れたあとも保持されるかどうか)、ステータス (有効または無効)、実行するアクション、および割り当て先のスキーマが含まれます。<a class="xref" href="sql-syntax.html#alter-event" title="13.1.2 ALTER EVENT 構文">セクション13.1.2「ALTER EVENT 構文」</a>を参照してください。
        </p><p>
          イベントのデフォルトの定義者は、イベントが変更されていない場合は、イベントを作成したユーザーであり、変更されている場合は、定義者はそのイベントに影響する <code class="literal">ALTER EVENT</code> ステートメントを最後に発行したユーザーです。イベントが定義されているデータベースに対する <code class="literal">EVENT</code> 権限を保有するすべてのユーザーは、そのイベントを変更できます。<a class="xref" href="stored-programs-views.html#events-privileges" title="20.4.6 イベントスケジューラと MySQL 権限">セクション20.4.6「イベントスケジューラと MySQL 権限」</a>を参照してください。
        </p></li><li class="listitem"><p>
          イベントのアクションステートメントには、ストアドルーチン内で許可されているほとんどの SQL ステートメントを含めることができます。制限については、<a class="xref" href="restrictions.html#stored-program-restrictions" title="D.1 ストアドプログラムの制約">セクションD.1「ストアドプログラムの制約」</a>を参照してください。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="events-configuration"></a>20.4.2 イベントスケジューラの構成</h3></div></div></div><p>
      イベントは、特別な<em class="firstterm">イベントスケジューラスレッド</em>によって実行されます。イベントスケジューラと呼ぶ場合、実際にはこのスレッドを指しています。実行中、イベントスケジューラスレッドとその現在の状態は、次の説明で示すように、<code class="literal">PROCESS</code> 権限を保有するユーザーが <code class="literal">SHOW PROCESSLIST</code> の出力で確認できます。
    </p><a class="indexterm" name="idm139979013435824"></a><a class="indexterm" name="idm139979013433632"></a><p><a name="events-event-scheduler-option"></a>
      <code class="literal">event_scheduler</code> グローバルシステム変数によって、イベントスケジューラがサーバー上で有効であり実行しているかどうかが決まります。これは次の 3 つの値のいずれかを取り、それぞれ次に説明するようにイベントスケジュール設定に影響します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">OFF</code>: イベントスケジューラは停止しています。イベントスケジューラスレッドは実行されておらず、<code class="literal">SHOW PROCESSLIST</code> の出力に表示されておらず、スケジュール設定済みイベントが実行されていません。<code class="literal">OFF</code> が <code class="literal">event_scheduler</code> のデフォルト値です。
        </p><p>
          イベントスケジューラが停止している場合 (<code class="literal">event_scheduler</code> が <code class="literal">OFF</code> です)、<code class="literal">event_scheduler</code> の値を <code class="literal">ON</code> に設定することで開始できます。(次の項目を参照してください。)
        </p></li><li class="listitem"><p>
          <code class="literal">ON</code>: イベントスケジューラが開始され、イベントスケジューラスレッドがすべてのスケジュール設定済みイベントを実行しています。
        </p><a class="indexterm" name="idm139979013418560"></a><p>
          イベントスケジューラが <code class="literal">ON</code> の場合、イベントスケジューラスレッドは、デーモンプロセスとして <code class="literal">SHOW PROCESSLIST</code> の出力に一覧表示され、その状態は次に示すように表示されます。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW PROCESSLIST\G</code></strong>
*************************** 1. row ***************************
     Id: 1
   User: root
   Host: localhost
     db: NULL
Command: Query
   Time: 0
  State: NULL
   Info: show processlist
*************************** 2. row ***************************
     Id: 2
   User: event_scheduler
   Host: localhost
     db: NULL
Command: Daemon
   Time: 3
  State: Waiting for next activation
   Info: NULL
2 rows in set (0.00 sec)
</pre><p>
          イベントスケジュール設定は、<code class="literal">event_scheduler</code> の値を <code class="literal">OFF</code> に設定することで停止できます。
        </p></li><li class="listitem"><p>
          <code class="literal">DISABLED</code>: この値はイベントスケジューラを動作しないようにします。イベントスケジューラが <code class="literal">DISABLED</code> の場合、イベントスケジューラスレッドは実行していません (また、<code class="literal">SHOW PROCESSLIST</code> の出力にも表示されません)。また、イベントスケジューラの状態は実行時に変更できません。
        </p></li></ul></div><p>
      イベントスケジューラのステータスが <code class="literal">DISABLED</code> に設定されていない場合、(<code class="literal">SET</code> を使用して) <code class="literal">event_scheduler</code> の <code class="literal">ON</code> と <code class="literal">OFF</code> を切り替えることができます。この変数を設定するときに、<code class="literal">OFF</code> に <code class="literal">0</code> を、<code class="literal">ON</code> に <code class="literal">1</code> を使用することも可能です。したがって、<span class="command"><strong>mysql</strong></span> クライアントで次の 4 つのどのステートメントを使用しても、イベントスケジューラをオンにできます。
    </p><pre class="programlisting">
SET GLOBAL event_scheduler = ON;
SET @@global.event_scheduler = ON;
SET GLOBAL event_scheduler = 1;
SET @@global.event_scheduler = 1;
</pre><p>
      同様に、次の 4 つのどのステートメントを使用してもイベントスケジューラをオフにできます。
    </p><pre class="programlisting">
SET GLOBAL event_scheduler = OFF;
SET @@global.event_scheduler = OFF;
SET GLOBAL event_scheduler = 0;
SET @@global.event_scheduler = 0;
</pre><p>
      <code class="literal">ON</code> と <code class="literal">OFF</code> には対応する数値がありますが、<code class="literal">SELECT</code> または <code class="literal">SHOW VARIABLES</code> によって <code class="literal">event_scheduler</code> に対して表示される値は、常に <code class="literal">OFF</code>、<code class="literal">ON</code>、または <code class="literal">DISABLED</code> のいずれかになります。<span class="emphasis"><em><code class="literal">DISABLED</code> に対応する数値はありません</em></span>。このため、この変数を設定するときに、<code class="literal">ON</code> と <code class="literal">OFF</code> は通常 <code class="literal">1</code> と <code class="literal">0</code> よりも優先されます。
    </p><p>
      グローバル変数として指定しないで <code class="literal">event_scheduler</code> を設定しようとすると、エラーが発生します。
    </p><pre class="programlisting">
mysql&lt; <strong class="userinput"><code>SET @@event_scheduler = OFF;</code></strong>
<span class="errortext">ERROR 1229 (HY000): Variable 'event_scheduler' is a GLOBAL
variable and should be set with SET GLOBAL</span>
</pre><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        イベントスケジューラを <code class="literal">DISABLED</code> に設定できるのは、サーバーの起動時だけです。<code class="literal">event_scheduler</code> が <code class="literal">ON</code> または <code class="literal">OFF</code> の場合、実行時にこれを <code class="literal">DISABLED</code> には設定できません。また、イベントスケジューラが起動時に <code class="literal">DISABLED</code> に設定されている場合、実行時に <code class="literal">event_scheduler</code> の値に変更できません。
      </p></div><p>
      イベントスケジューラを無効にするには、次の 2 つの方法のいずれかを使用します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          サーバーの起動時のコマンド行オプションとして
        </p><pre class="programlisting">
--event-scheduler=DISABLED
</pre></li><li class="listitem"><p>
          サーバー構成ファイル (Windows システムでの <code class="filename">my.cnf</code> または <code class="filename">my.ini</code>) で、サーバーが読み取る箇所 (たとえば、<code class="literal">[mysqld]</code> セクション内) に次の行を含めます。
        </p><pre class="programlisting">
event_scheduler=DISABLED
</pre></li></ul></div><p>
      イベントスケジューラを有効にするには、必要に応じて、<code class="option">--event-scheduler=DISABLED</code> コマンド行オプションを使用しないでサーバーを再起動するか、サーバー構成ファイルの <code class="option">event-scheduler=DISABLED</code> を含む行を削除するかコメントアウトしたあとでサーバーを再起動します。または、サーバーの起動時に <code class="literal">DISABLED</code> 値の代わりに <code class="literal">ON</code> (または <code class="literal">1</code>) か <code class="literal">OFF</code> (または <code class="literal">0</code>) を使用できます。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">event_scheduler</code> が <code class="literal">DISABLED</code> に設定されている場合、イベント操作ステートメントを発行できます。このような場合には警告もエラーも生成されません (ステートメント自体が有効であるとします)。ただし、この変数を <code class="literal">ON</code> (または <code class="literal">1</code>) に設定するまで、スケジュール設定済みイベントは実行できません。これが行われると、イベントスケジューラスレッドは、スケジュール設定条件が満たされているすべてのイベントを実行します。
      </p></div><p>
      <code class="option">--skip-grant-tables</code> オプションを使用して MySQL Server を起動すると、<code class="literal">event_scheduler</code> が <code class="literal">DISABLED</code> に設定され、コマンド行や <code class="filename">my.cnf</code> または <code class="filename">my.ini</code> ファイルで設定されたほかのすべての値をオーバーライドします (Bug #26807)。
    </p><p>
      イベントの作成、変更、または削除に使用される SQL ステートメントについては、<a class="xref" href="stored-programs-views.html#events-syntax" title="20.4.3 イベント構文">セクション20.4.3「イベント構文」</a>を参照してください。
    </p><p>
      MySQL 5.6 は、<code class="literal">INFORMATION_SCHEMA</code> データベースの <code class="literal">EVENTS</code> テーブルを提供します。このテーブルは、サーバー上で定義されているスケジュール設定済みイベントに関する情報を取得するためにクエリーできます。詳細は、<a class="xref" href="stored-programs-views.html#events-metadata" title="20.4.4 イベントメタデータ">セクション20.4.4「イベントメタデータ」</a>および<a class="xref" href="information-schema.html#events-table" title="21.7 INFORMATION_SCHEMA EVENTS テーブル">セクション21.7「INFORMATION_SCHEMA EVENTS テーブル」</a>を参照してください。
    </p><p>
      イベントスケジュール設定と MySQL 権限システムに関する情報については、<a class="xref" href="stored-programs-views.html#events-privileges" title="20.4.6 イベントスケジューラと MySQL 権限">セクション20.4.6「イベントスケジューラと MySQL 権限」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="events-syntax"></a>20.4.3 イベント構文</h3></div></div></div><a class="indexterm" name="idm139979013342960"></a><p>
      MySQL 5.6 には、スケジュール設定済みイベントを処理するための複数の SQL ステートメントが用意されています。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          新しいイベントは <code class="literal">CREATE EVENT</code> ステートメントを使用して定義されます。<a class="xref" href="sql-syntax.html#create-event" title="13.1.11 CREATE EVENT 構文">セクション13.1.11「CREATE EVENT 構文」</a>を参照してください。
        </p></li><li class="listitem"><p>
          既存のイベントの定義は、<code class="literal">ALTER EVENT</code> ステートメントによって変更できます。<a class="xref" href="sql-syntax.html#alter-event" title="13.1.2 ALTER EVENT 構文">セクション13.1.2「ALTER EVENT 構文」</a>を参照してください。
        </p></li><li class="listitem"><p>
          スケジュール設定済みイベントが不要になった場合は、その定義者が、<code class="literal">DROP EVENT</code> ステートメントを使用してサーバーから削除できます。<a class="xref" href="sql-syntax.html#drop-event" title="13.1.22 DROP EVENT 構文">セクション13.1.22「DROP EVENT 構文」</a>を参照してください。イベントがそのスケジュールの終了を過ぎても持続されるかどうかは、<code class="literal">ON COMPLETION</code> 句がある場合、この句によって決まります。<a class="xref" href="sql-syntax.html#create-event" title="13.1.11 CREATE EVENT 構文">セクション13.1.11「CREATE EVENT 構文」</a>を参照してください。
        </p><p>
          イベントが定義されているデータベースに対する <code class="literal">EVENT</code> 権限を保有するすべてのユーザーは、そのイベントをドロップできます。<a class="xref" href="stored-programs-views.html#events-privileges" title="20.4.6 イベントスケジューラと MySQL 権限">セクション20.4.6「イベントスケジューラと MySQL 権限」</a>を参照してください。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="events-metadata"></a>20.4.4 イベントメタデータ</h3></div></div></div><a class="indexterm" name="idm139979013326240"></a><a class="indexterm" name="idm139979013324064"></a><p>
      イベントに関するメタデータは次のように取得できます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">mysql</code> データベースの <code class="literal">event</code> テーブルをクエリーします。
        </p></li><li class="listitem"><p>
          <code class="literal">INFORMATION_SCHEMA</code> データベースの <code class="literal">EVENTS</code> テーブルをクエリーします。<a class="xref" href="information-schema.html#events-table" title="21.7 INFORMATION_SCHEMA EVENTS テーブル">セクション21.7「INFORMATION_SCHEMA EVENTS テーブル」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">SHOW CREATE EVENT</code> ステートメントを使用します。<a class="xref" href="sql-syntax.html#show-create-event" title="13.7.5.9 SHOW CREATE EVENT 構文">セクション13.7.5.9「SHOW CREATE EVENT 構文」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">SHOW EVENTS</code> ステートメントを使用します。<a class="xref" href="sql-syntax.html#show-events" title="13.7.5.19 SHOW EVENTS 構文">セクション13.7.5.19「SHOW EVENTS 構文」</a>を参照してください。
        </p></li></ul></div><p>
      <span class="bold"><strong>イベントスケジューラの時間表現</strong></span>
    </p><a class="indexterm" name="idm139979013309440"></a><a class="indexterm" name="idm139979013307248"></a><p>
      MySQL の各セッションには、セッションタイムゾーン (STZ) があります。これは、セッションの開始時にサーバーの <code class="literal">time_zone</code> グローバル値から初期化される <code class="literal">time_zone</code> セッション値ですが、セッション中に変更される可能性があります。
    </p><p>
      <code class="literal">CREATE EVENT</code> または <code class="literal">ALTER EVENT</code> ステートメントが実行するときに使用されているセッションタイムゾーンが、イベント定義で指定されている時間の解釈に使用されます。これがイベントタイムゾーン (ETZ) になります。つまり、イベントのスケジュール設定に使用され、イベントが実行するときにそのイベント内で有効になるタイムゾーンになります。
    </p><p>
      <code class="literal">mysql.event</code> テーブル内のイベント情報の表現については、<code class="literal">execute_at</code>、<code class="literal">starts</code>、および <code class="literal">ends</code> 時間は UTC に変換され、イベントタイムゾーンとともに格納されます。これにより、サーバータイムゾーンまたはサマータイムの影響に対し生じた変更とは無関係に、定義されたとおりにイベントの実行を処理できます。<code class="literal">last_executed</code> 時間も UTC で格納されます。
    </p><p>
      <code class="literal">mysql.event</code> から情報を選択すると、前述の時間は、UTC 値として取得されます。これらの時間は、<code class="literal">INFORMATION_SCHEMA.EVENTS</code> テーブルから、または <code class="literal">SHOW EVENTS</code> から選択して取得することもできますが、ETZ 値としてレポートされます。これらのソースから利用できるほかの時間は、イベントの作成時や最後の変更時を示します。これらは STZ 値として表示されます。次の表は、イベント時間の表現をまとめています。
    </p><div class="informaltable"><table summary="この表は、mysql.event、INFORMATION_SCHEMA.EVENTS、および SHOW EVENTS のイベント時間の (UTC、EZT、または STZ 値としての) 表現をまとめています。" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th scope="col">値</th><th scope="col"><code class="literal">mysql.event</code></th><th scope="col"><code class="literal">INFORMATION_SCHEMA.EVENTS</code></th><th scope="col"><code class="literal">SHOW EVENTS</code></th></tr></thead><tbody><tr><td scope="row">Execute at</td><td>UTC</td><td>ETZ</td><td>ETZ</td></tr><tr><td scope="row">Starts</td><td>UTC</td><td>ETZ</td><td>ETZ</td></tr><tr><td scope="row">Ends</td><td>UTC</td><td>ETZ</td><td>ETZ</td></tr><tr><td scope="row">Last executed</td><td>UTC</td><td>ETZ</td><td>該当なし</td></tr><tr><td scope="row">Created</td><td>STZ</td><td>STZ</td><td>該当なし</td></tr><tr><td scope="row">Last altered</td><td>STZ</td><td>STZ</td><td>該当なし</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="events-status-info"></a>20.4.5 イベントスケジューラのステータス</h3></div></div></div><a class="indexterm" name="idm139979013266208"></a><a class="indexterm" name="idm139979013264016"></a><a class="indexterm" name="idm139979013262784"></a><p>
      イベントスケジューラは、エラーまたは警告で終了したイベント実行に関する情報を、MySQL Server のエラーログに書き込みます。例については <a class="xref" href="stored-programs-views.html#events-privileges" title="20.4.6 イベントスケジューラと MySQL 権限">セクション20.4.6「イベントスケジューラと MySQL 権限」</a>を参照してください。
    </p><p>
      デバッグおよびトラブルシューティングのためにイベントスケジューラの状態に関する状態を取得するには、<span class="command"><strong>mysqladmin debug</strong></span> を実行します (<a class="xref" href="programs.html#mysqladmin" title="4.5.2 mysqladmin — MySQL サーバーの管理を行うクライアント">セクション4.5.2「<span class="command"><strong>mysqladmin</strong></span> — MySQL サーバーの管理を行うクライアント」</a>を参照してください)。このコマンドの実行後に、ここに示すようなイベントスケジューラに関連した出力がサーバーのエラーログに含まれます。
    </p><pre class="programlisting">
Events status:
LLA = Last Locked At  LUA = Last Unlocked At
WOC = Waiting On Condition  DL = Data Locked

Event scheduler status:
State      : INITIALIZED
Thread id  : 0
LLA        : init_scheduler:313
LUA        : init_scheduler:318
WOC        : NO
Workers    : 0
Executed   : 0
Data locked: NO

Event queue status:
Element count   : 1
Data locked     : NO
Attempting lock : NO
LLA             : init_queue:148
LUA             : init_queue:168
WOC             : NO
Next activation : 0000-00-00 00:00:00
</pre><p>
      イベントスケジューラが実行するイベントの一部として生じるステートメント内で、診断メッセージ (エラーだけでなく警告も) がエラーログと、Windows ではアプリケーションイベントログに書き込まれます。頻繁に実行するイベントの場合、これにより、多数のメッセージが記録される結果になることがあります。たとえば、<code class="literal">SELECT ... INTO <em class="replaceable"><code>var_list</code></em></code> ステートメントの場合、クエリーが行を返さなければ、エラーコード 1329 で警告が発生し (<code class="literal">No data</code>)、変数値は変更されないままになります。クエリーが複数の行を返す場合は、エラー 1172 が発生します (<code class="literal">結果が 2 行以上です</code>)。どちらの条件についても、条件ハンドラを宣言すると、警告を記録させないようにできます。<a class="xref" href="sql-syntax.html#declare-handler" title="13.6.7.2 DECLARE ... HANDLER 構文">セクション13.6.7.2「DECLARE ... HANDLER 構文」</a>を参照してください。複数の行を取得できるステートメントの場合、<code class="literal">LIMIT 1</code> を使用して結果セットを単一の行に制限するという別の方法があります。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="events-privileges"></a>20.4.6 イベントスケジューラと MySQL 権限</h3></div></div></div><a class="indexterm" name="idm139979013248528"></a><p>
      スケジュール設定済みイベントの実行を有効または無効にするには、<code class="literal">event_scheduler</code> グローバルシステム変数の値を設定する必要があります。これには <code class="literal">SUPER</code> 権限が必要です。
    </p><p>
      <code class="literal">EVENT</code> 権限は、イベントの作成、変更、および削除を制御します。この権限は、<code class="literal">GRANT</code> を使用して与えることができます。たとえば、次の <code class="literal">GRANT</code> ステートメントは、<code class="literal">myschema</code> という名前のスキーマに対する <code class="literal">EVENT</code> 権限を、ユーザー <code class="literal">jon@ghidora</code> に与えます。
    </p><pre class="programlisting">
GRANT EVENT ON myschema.* TO jon@ghidora;
</pre><p>
      (このユーザーアカウントがすでに存在していることと、その他の点では変更されないままであると想定しています。)
    </p><p>
      この同じユーザーにすべてのスキーマに対する <code class="literal">EVENT</code> 権限を認めるには、次のステートメントを使用します。
    </p><pre class="programlisting">
GRANT EVENT ON *.* TO jon@ghidora;
</pre><p>
      <code class="literal">EVENT</code> 権限にはグローバルまたはスキーマレベルのスコープがあります。このため、単一のテーブルに対してこれを与えようとすると、次のようなエラーが生じます。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>GRANT EVENT ON myschema.mytable TO jon@ghidora;</code></strong>
<span class="errortext">ERROR 1144 (42000): Illegal GRANT/REVOKE command; please
consult the manual to see which privileges can be used</span>
</pre><p>
      イベントはその定義者の権限で実行され、定義者が必須の権限を保有していないアクションは実行できません。たとえば、<code class="literal">jon@ghidora</code> が <code class="literal">myschema</code> に対する <code class="literal">EVENT</code> 権限を保有しているとします。また、このユーザーは <code class="literal">myschema</code> に対する <code class="literal">SELECT</code> 権限は保有しているが、このスキーマに対するほかの権限は保有していないとします。<code class="literal">jon@ghidora</code> は、次のような新しいイベントを作成できます。
    </p><pre class="programlisting">
CREATE EVENT e_store_ts
    ON SCHEDULE
      EVERY 10 SECOND
    DO
      INSERT INTO myschema.mytable VALUES (UNIX_TIMESTAMP());
</pre><p>
      このユーザーは 1 分ほど待機したあと、テーブルに複数の新しい行が表示されることを予想して <code class="literal">SELECT * FROM mytable;</code> クエリーを実行します。実際は、テーブルは空です。ユーザーは該当するテーブルに対する <code class="literal">INSERT</code> 権限がないので、イベントの効果はありませんでした。
    </p><p>
      MySQL エラーログ (<code class="filename"><em class="replaceable"><code>hostname</code></em>.err</code>) を調べると、イベントは実行していますが、<code class="literal">RetCode=0</code> で示されているように、イベントが実行しようとしているアクションは失敗していることがわかります。
    </p><pre class="programlisting">
060209 22:39:44 [Note]     EVEX EXECUTING event newdb.e [EXPR:10]
060209 22:39:44 [Note]     EVEX EXECUTED event newdb.e  [EXPR:10]. RetCode=0
060209 22:39:54 [Note]     EVEX EXECUTING event newdb.e [EXPR:10]
060209 22:39:54 [Note]     EVEX EXECUTED event newdb.e  [EXPR:10]. RetCode=0
060209 22:40:04 [Note]     EVEX EXECUTING event newdb.e [EXPR:10]
060209 22:40:04 [Note]     EVEX EXECUTED event newdb.e  [EXPR:10]. RetCode=0
</pre><p>
      このユーザーは、エラーログにアクセスできない可能性が非常に高いので、直接それを実行することによって、イベントのアクションステートメントが有効であるかどうか検証できます。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>INSERT INTO myschema.mytable VALUES (UNIX_TIMESTAMP());</code></strong>
<span class="errortext">ERROR 1142 (42000): INSERT command denied to user
'jon'@'ghidora' for table 'mytable'</span>
</pre><a class="indexterm" name="idm139979013213600"></a><p>
      <code class="literal">INFORMATION_SCHEMA.EVENTS</code> テーブルを調べることによって、<code class="literal">e_store_ts</code> が存在し有効になっているが、その <code class="literal">LAST_EXECUTED</code> カラムが <code class="literal">NULL</code> になっていることがわかります。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.EVENTS</code></strong>
     &gt;     <strong class="userinput"><code>WHERE EVENT_NAME='e_store_ts'</code></strong>
     &gt;     <strong class="userinput"><code>AND EVENT_SCHEMA='myschema'\G</code></strong>
*************************** 1. row ***************************
   EVENT_CATALOG: NULL
    EVENT_SCHEMA: myschema
      EVENT_NAME: e_store_ts
         DEFINER: jon@ghidora
      EVENT_BODY: SQL
EVENT_DEFINITION: INSERT INTO myschema.mytable VALUES (UNIX_TIMESTAMP())
      EVENT_TYPE: RECURRING
      EXECUTE_AT: NULL
  INTERVAL_VALUE: 5
  INTERVAL_FIELD: SECOND
        SQL_MODE: NULL
          STARTS: 0000-00-00 00:00:00
            ENDS: 0000-00-00 00:00:00
          STATUS: ENABLED
   ON_COMPLETION: NOT PRESERVE
         CREATED: 2006-02-09 22:36:06
    LAST_ALTERED: 2006-02-09 22:36:06
   LAST_EXECUTED: NULL
   EVENT_COMMENT:
1 row in set (0.00 sec)
</pre><p>
      <code class="literal">EVENT</code> 権限を取り消すには、<code class="literal">REVOKE</code> ステートメントを使用します。この例では、スキーマ <code class="literal">myschema</code> に対する <code class="literal">EVENT</code> 権限が <code class="literal">jon@ghidora</code> ユーザーアカウントから削除されます。
    </p><pre class="programlisting">
REVOKE EVENT ON myschema.* FROM jon@ghidora;
</pre><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        ユーザーから <code class="literal">EVENT</code> 権限を取り消しても、そのユーザーが作成したイベントが削除されたり無効にされたりすることはありません。
      </p><p>
        作成したユーザーの名前を変更したり削除したりしても、イベントが移行または削除されることはありません。
      </p></div><p>
      ユーザー <code class="literal">jon@ghidora</code> に、<code class="literal">myschema</code> スキーマに対する <code class="literal">EVENT</code> および <code class="literal">INSERT</code> 権限が与えられているとします。続いてこのユーザーが次のイベントを作成します。
    </p><pre class="programlisting">
CREATE EVENT e_insert
    ON SCHEDULE
      EVERY 7 SECOND
    DO
      INSERT INTO myschema.mytable;
</pre><p>
      このイベントの作成後、<code class="literal">root</code> は <code class="literal">jon@ghidora</code> の <code class="literal">EVENT</code> 権限を取り消します。ただし、<code class="literal">e_insert</code> は実行し続け、7 秒ごとに新しい行が <code class="literal">mytable</code> に挿入されます。<code class="literal">root</code> が次のどちらかのステートメントを発行した場合も、同じことが当てはまります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">DROP USER jon@ghidora;</code>
        </p></li><li class="listitem"><p>
          <code class="literal">RENAME USER jon@ghidora TO someotherguy@ghidora;</code>
        </p></li></ul></div><p>
      <code class="literal">DROP USER</code> または <code class="literal">RENAME USER</code> ステートメントの発行前後で、<code class="literal">mysql.event</code> テーブル (このセクションで後述します) か、<code class="literal">INFORMATION_SCHEMA.EVENTS</code> テーブル (<a class="xref" href="information-schema.html#events-table" title="21.7 INFORMATION_SCHEMA EVENTS テーブル">セクション21.7「INFORMATION_SCHEMA EVENTS テーブル」</a>を参照してください) を調べると、これが当てはまることを確認できます。
    </p><a class="indexterm" name="idm139979013176720"></a><p>
      イベント定義は、<code class="literal">mysql.event</code> テーブルに格納されています。別のユーザーアカウントが作成したイベントを削除するには、MySQL <code class="literal">root</code> ユーザー (または必要な権限を保有する別のユーザー) がこのテーブルから行を削除できます。たとえば、前述のイベント <code class="literal">e_insert</code> を削除するには、<code class="literal">root</code> は次のステートメントを使用できます。
    </p><pre class="programlisting">
DELETE FROM mysql.event
    WHERE db = 'myschema'
      AND definer = 'jon@ghidora'
      AND name = 'e_insert';
</pre><p>
      <code class="literal">mysql.event</code> テーブルから行を削除するときには、イベント名、データベーススキーマ名、ユーザーアカウントを一致させることが重要です。これは、同じユーザーが、別々のスキーマに同じ名前の異なるイベントを作成できるためです。
    </p><p>
      ユーザーの <code class="literal">EVENT</code> 権限は、<code class="literal">mysql.user</code> および <code class="literal">mysql.db</code> テーブルの <code class="literal">Event_priv</code> カラムに格納されています。どちらの場合でも、このカラムには、<code class="literal">「Y」</code>または<code class="literal">「N」</code>のどちらかの値が含まれています。<code class="literal">「N」</code>がデフォルトです。指定されたユーザーがグローバルな <code class="literal">EVENT</code> 権限を保有している場合 (つまり、<code class="literal">GRANT EVENT ON *.*</code> を使用して権限が与えられた場合) にのみ、そのユーザーの <code class="literal">mysql.user.Event_priv</code> は<code class="literal">「Y」</code>に設定されます。スキーマレベルの <code class="literal">EVENT</code> 権限の場合、<code class="literal">GRANT</code> は、<code class="literal">mysql.db</code> に行を作成し、その行の <code class="literal">Db</code> カラムをスキーマの名前に、<code class="literal">User</code> カラムをユーザーの名前に、<code class="literal">Event_priv</code> カラムを<code class="literal">「Y」</code>に設定します。<code class="literal">GRANT EVENT</code> および <code class="literal">REVOKE EVENT</code> ステートメントがこれらのテーブルでの必要な操作を実行するので、これらのテーブルを直接操作する必要はありません。
    </p><a class="indexterm" name="idm139979013151296"></a><p>
      5 つのステータス変数が、イベント関連操作のカウントを提供します (ただし、イベントが実行するステートメントのカウントは提供<span class="emphasis"><em>しません</em></span>。<a class="xref" href="restrictions.html#stored-program-restrictions" title="D.1 ストアドプログラムの制約">セクションD.1「ストアドプログラムの制約」</a>を参照してください)。これらを次に示します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">Com_create_event</code>: サーバーが最後に再起動してから実行された <code class="literal">CREATE EVENT</code> ステートメントの数。
        </p></li><li class="listitem"><p>
          <code class="literal">Com_alter_event</code>: サーバーが最後に再起動してから実行された <code class="literal">ALTER EVENT</code> ステートメントの数。
        </p></li><li class="listitem"><p>
          <code class="literal">Com_drop_event</code>: サーバーが最後に再起動してから実行された <code class="literal">DROP EVENT</code> ステートメントの数。
        </p></li><li class="listitem"><p>
          <code class="literal">Com_show_create_event</code>: サーバーが最後に再起動してから実行された <code class="literal">SHOW CREATE EVENT</code> ステートメントの数。
        </p></li><li class="listitem"><p>
          <code class="literal">Com_show_events</code>: サーバーが最後に再起動してから実行された <code class="literal">SHOW EVENTS</code> ステートメントの数。
        </p></li></ul></div><p>
      ステートメント <code class="literal">SHOW STATUS LIKE '%event%';</code> を実行すると、これらのすべての現在値を一度に表示できます。
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="views"></a>20.5 ビューの使用</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="stored-programs-views.html#view-syntax">20.5.1 ビューの構文</a></span></dt><dt><span class="section"><a href="stored-programs-views.html#view-algorithms">20.5.2 ビュー処理アルゴリズム</a></span></dt><dt><span class="section"><a href="stored-programs-views.html#view-updatability">20.5.3 更新可能および挿入可能なビュー</a></span></dt><dt><span class="section"><a href="stored-programs-views.html#view-metadata">20.5.4 ビューのメタデータ</a></span></dt></dl></div><a class="indexterm" name="idm139979013130832"></a><p>
    ビュー (更新可能なビューを含む) は MySQL Server 5.6 で使用できます。ビューは、呼び出されたときに結果セットを生成するストアドクエリーです。ビューは仮想テーブルとして機能します。
  </p><p>
    ビューをサポートしていなかった古いリリースから MySQL 5.6 にアップグレードした場合、ビューを使用するには、ビュー関連の権限を含めるように付与テーブルをアップグレードする必要があります。<a class="xref" href="programs.html#mysql-upgrade" title="4.4.7 mysql_upgrade — MySQL テーブルのチェックとアップグレード">セクション4.4.7「<span class="command"><strong>mysql_upgrade</strong></span> — MySQL テーブルのチェックとアップグレード」</a>を参照してください。
  </p><p>
    次の説明では、ビューを作成し削除するための構文について記述し、それらの使用法の例をいくつか示します。
  </p><h3><a name="idm139979013126064"></a>追加のリソース</h3><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        ビューを扱うときには、「<a class="ulink" href="http://forums.mysql.com/list.php?100" target="_top">Views User Forum</a>」が役立ちます。
      </p></li><li class="listitem"><p>
        MySQL のビューに関するよくある質問とその回答については、<a class="xref" href="faqs.html#faqs-views" title="A.6 MySQL 5.6 FAQ: ビュー">セクションA.6「MySQL 5.6 FAQ: ビュー」</a>を参照してください。
      </p></li><li class="listitem"><p>
        ビューの使用にはいくつかの制限があります。<a class="xref" href="restrictions.html#view-restrictions" title="D.5 ビューの制約">セクションD.5「ビューの制約」</a>を参照してください。
      </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="view-syntax"></a>20.5.1 ビューの構文</h3></div></div></div><p>
      <code class="literal">CREATE VIEW</code> ステートメントは新しいビューを作成します (<a class="xref" href="sql-syntax.html#create-view" title="13.1.20 CREATE VIEW 構文">セクション13.1.20「CREATE VIEW 構文」</a>を参照してください)。ビューの定義を変更したり、ビューを削除したりするには、<code class="literal">ALTER VIEW</code> (<a class="xref" href="sql-syntax.html#alter-view" title="13.1.9 ALTER VIEW 構文">セクション13.1.9「ALTER VIEW 構文」</a>を参照してください) または <code class="literal">DROP VIEW</code> (<a class="xref" href="sql-syntax.html#drop-view" title="13.1.31 DROP VIEW 構文">セクション13.1.31「DROP VIEW 構文」</a>を参照してください) を使用します。
    </p><p>
      ビューは、多くの種類の <code class="literal">SELECT</code> ステートメントから作成できできます。ベーステーブルまたはほかのビューを参照できます。結合、<code class="literal">UNION</code>、およびサブクエリーを使用できます。<code class="literal">SELECT</code> がテーブルをまったく参照しなくてもかまいません。次の例では、別のテーブルからの 2 つのカラムに加え、それらのカラムから計算される式を選択するビューを定義しています。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE t (qty INT, price INT);</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t VALUES(3, 50), (5, 60);</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE VIEW v AS SELECT qty, price, qty*price AS value FROM t;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT * FROM v;</code></strong>
+------+-------+-------+
| qty  | price | value |
+------+-------+-------+
|    3 |    50 |   150 |
|    5 |    60 |   300 |
+------+-------+-------+
mysql&gt; <strong class="userinput"><code>SELECT * FROM v WHERE qty = 5;</code></strong>
+------+-------+-------+
| qty  | price | value |
+------+-------+-------+
|    5 |    60 |   300 |
+------+-------+-------+
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="view-algorithms"></a>20.5.2 ビュー処理アルゴリズム</h3></div></div></div><a class="indexterm" name="idm139979013103040"></a><p>
      <code class="literal">CREATE VIEW</code> または <code class="literal">ALTER VIEW</code> のオプションの <code class="literal">ALGORITHM</code> 句は、標準 SQL に対する MySQL 拡張です。これは、MySQL によるビューの処理方法に影響を与えます。<code class="literal">ALGORITHM</code> は、<code class="literal">MERGE</code>、<code class="literal">TEMPTABLE</code>、または <code class="literal">UNDEFINED</code> の 3 つの値を受け取ります。<code class="literal">ALGORITHM</code> 句が存在しない場合、デフォルトのアルゴリズムは <code class="literal">UNDEFINED</code> です。
    </p><p>
      <code class="literal">MERGE</code> の場合、ビューを参照するステートメントのテキストとビュー定義がマージされ、ビュー定義の部分が対応するステートメントの部分と置き換えられます。
    </p><p>
      <code class="literal">TEMPTABLE</code> の場合、ビューの結果が一時テーブル内に取得され、その後、ステートメントを実行するために使用されます。
    </p><p>
      <code class="literal">UNDEFINED</code> の場合、MySQL は使用するアルゴリズムを選択します。できるかぎり <code class="literal">TEMPTABLE</code> より <code class="literal">MERGE</code> が優先されます。これは通常、<code class="literal">MERGE</code> のほうが効率性が高く、一時テーブルを使用するとビューを更新できなくなるためです。
    </p><p>
      明示的に <code class="literal">TEMPTABLE</code> を選択する理由は、一時テーブルが作成されたあとで、ステートメントの処理を終了するために使用される前に、ベースとなるテーブルでロックを解放できるからです。その結果、<code class="literal">MERGE</code> アルゴリズムよりもすみやかにロックが解除され、ビューを使用するほかのクライアントが長時間ブロックされることがなくなります。
    </p><p>
      次の 3 つの理由によって、ビューアルゴリズムを<code class="literal">UNDEFINED</code> にできます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">CREATE VIEW</code> ステートメントの中に <code class="literal">ALGORITHM</code> 句が存在しない。
        </p></li><li class="listitem"><p>
          <code class="literal">CREATE VIEW</code> ステートメントに明示的な <code class="literal">ALGORITHM = UNDEFINED</code> 句が含まれている。
        </p></li><li class="listitem"><p>
          一時テーブルだけでしか処理できないビューに対して、<code class="literal">ALGORITHM = MERGE</code> が指定されている。この場合、MySQL は警告を発し、アルゴリズムを <code class="literal">UNDEFINED</code> に設定します。
        </p></li></ul></div><p>
      前述のように、<code class="literal">MERGE</code> は、ビュー定義の対応する部分を、ビューを参照するステートメントにマージして処理されます。次の例で、<code class="literal">MERGE</code> アルゴリズムの動作について簡単に説明します。例では、次の定義を含むビュー <code class="literal">v_merge</code> が存在していると想定します。
    </p><pre class="programlisting">
CREATE ALGORITHM = MERGE VIEW v_merge (vc1, vc2) AS
SELECT c1, c2 FROM t WHERE c3 &gt; 100;
</pre><p>
      例 1: 次のステートメントを発行するとします。
    </p><pre class="programlisting">
SELECT * FROM v_merge;
</pre><p>
      MySQL は次のようにステートメントを処理します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">v_merge</code> は <code class="literal">t</code> になる
        </p></li><li class="listitem"><p>
          <code class="literal">*</code> は <code class="literal">vc1, vc2</code> となり、<code class="literal">c1, c2</code> と一致する
        </p></li><li class="listitem"><p>
          ビュー <code class="literal">WHERE</code> 句が追加される
        </p></li></ul></div><p>
      結果が実行されるステートメントは次のようになります。
    </p><pre class="programlisting">
SELECT c1, c2 FROM t WHERE c3 &gt; 100;
</pre><p>
      例 2: 次のステートメントを発行するとします。
    </p><pre class="programlisting">
SELECT * FROM v_merge WHERE vc1 &lt; 100;
</pre><p>
      このステートメントは、前述のステートメントと同様に処理されますが、<code class="literal">vc1 &lt; 100</code> が <code class="literal">c1 &lt; 100</code> になり、<code class="literal">AND</code> 連結詞を使用してビュー <code class="literal">WHERE</code> 句がステートメント <code class="literal">WHERE</code> 句に追加される点が異なります (また、句の一部が確実に正しい優先順位で実行されるように、かっこが追加されます)。結果が実行されるステートメントは次のようになります。
    </p><pre class="programlisting">
SELECT c1, c2 FROM t WHERE (c3 &gt; 100) AND (c1 &lt; 100);
</pre><p>
      事実上、実行されるステートメントには、次の形式の <code class="literal">WHERE</code> 句が含まれます。
    </p><pre class="programlisting">
WHERE (select WHERE) AND (view WHERE)
</pre><p>
      <code class="literal">MERGE</code> アルゴリズムを使用できない場合、一時テーブルを代わりに使用する必要があります。ビューに次のいずれかの構造構文が含まれる場合、<code class="literal">MERGE</code> は使用できません。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          集計関数 (<code class="literal">SUM()</code>、<code class="literal">MIN()</code>、<code class="literal">MAX()</code>、<code class="literal">COUNT()</code> など)
        </p></li><li class="listitem"><p>
          <code class="literal">DISTINCT</code>
        </p></li><li class="listitem"><p>
          <code class="literal">GROUP BY</code>
        </p></li><li class="listitem"><p>
          <code class="literal">HAVING</code>
        </p></li><li class="listitem"><p>
          <code class="literal">LIMIT</code>
        </p></li><li class="listitem"><p>
          <code class="literal">UNION</code> または <code class="literal">UNION ALL</code>
        </p></li><li class="listitem"><p>
          選択リスト内のサブクエリー
        </p></li><li class="listitem"><p>
          リテラル値だけの参照 (この場合、ベースとなるテーブルがありません)
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="view-updatability"></a>20.5.3 更新可能および挿入可能なビュー</h3></div></div></div><a class="indexterm" name="idm139979013029728"></a><a class="indexterm" name="idm139979013028272"></a><a class="indexterm" name="idm139979013026240"></a><p>
      いくつかのビューは更新可能です。つまり、これらのビューを <code class="literal">UPDATE</code>、<code class="literal">DELETE</code>、<code class="literal">INSERT</code> などのステートメントで使用して、ベースとなるテーブルの内容を更新できます。ビューが更新可能であるためには、そのビュー内の行とベースとなるテーブル内の行の間に 1 対 1 の関係が存在する必要があります。また、ビューを更新不可能にするその他の特定の構造構文も存在します。より具体的には、次のいずれかを含む場合、ビューは更新可能ではありません。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          集計関数 (<code class="literal">SUM()</code>、<code class="literal">MIN()</code>、<code class="literal">MAX()</code>、<code class="literal">COUNT()</code> など)
        </p></li><li class="listitem"><p>
          <code class="literal">DISTINCT</code>
        </p></li><li class="listitem"><p>
          <code class="literal">GROUP BY</code>
        </p></li><li class="listitem"><p>
          <code class="literal">HAVING</code>
        </p></li><li class="listitem"><p>
          <code class="literal">UNION</code> または <code class="literal">UNION ALL</code>
        </p></li><li class="listitem"><p>
          選択リスト内のサブクエリー
        </p></li><li class="listitem"><p>
          特定の結合 (このセクションで後述する結合に関する追加説明を参照してください)
        </p></li><li class="listitem"><p>
          <code class="literal">FROM</code> 句内の更新不可能なビュー
        </p></li><li class="listitem"><p>
          <code class="literal">FROM</code> 句内のテーブルを参照する <code class="literal">WHERE</code> 句内のサブクエリー
        </p></li><li class="listitem"><p>
          リテラル値だけの参照 (この場合、更新するベースとなるテーブルがありません)
        </p></li><li class="listitem"><p>
          <code class="literal">ALGORITHM = TEMPTABLE</code> の使用 (一時テーブルを使用すると常にビューは更新不可能になります)
        </p></li><li class="listitem"><p>
          ベーステーブルのいずれかのカラムに対する複数の参照。
        </p></li></ul></div><p>
      挿入可能性 (<code class="literal">INSERT</code> ステートメントで更新可能であること) については、更新可能なビューがビューカラムに対する次の追加要件も満たしている場合に挿入可能になります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          重複したビューカラム名が存在しないようにする必要があります。
        </p></li><li class="listitem"><p>
          ビューには、デフォルト値を持たない、ベーステーブル内のすべてのカラムが含まれている必要があります。
        </p></li><li class="listitem"><p>
          ビューカラムは、派生カラムではなく、単純なカラム参照である必要があります。派生カラムは、単純なカラム参照ではなく、式から派生したカラムです。派生したカラムの例は次のとおりです。
        </p><pre class="programlisting">
3.14159
col1 + 3
UPPER(col2)
col3 / col4
(<em class="replaceable"><code>subquery</code></em>)
</pre></li></ul></div><p>
      単純なカラム参照と派生カラムが混在しているビューは挿入できませんが、派生カラム以外のカラムだけを更新する場合は、更新可能になります。次のビューを考えてみてください。
    </p><pre class="programlisting">
CREATE VIEW v AS SELECT col1, 1 AS col2 FROM t;
</pre><p>
      このビューは、<code class="literal">col2</code> が式から派生しているので挿入できません。ただし、更新で <code class="literal">col2</code> を更新しようとしていない場合は、更新可能になります。次の更新は許可されます。
    </p><pre class="programlisting">
UPDATE v SET col1 = 0;
</pre><p>
      次の更新は、派生カラムを更新しようとしているので、許可されません。
    </p><pre class="programlisting">
UPDATE v SET col2 = 0;
</pre><p>
      <code class="literal">MERGE</code> アルゴリズムで処理できるとすれば、複数テーブルビューが更新できる可能性があります。これを実現するには、ビューで (外部結合または <code class="literal">UNION</code> ではなく) 内部結合を使用する必要があります。また、ビュー定義内の単一のテーブルだけを更新できるので、<code class="literal">SET</code> 句は、ビュー内のいずれかのテーブルのカラムだけを指名する必要があります。<code class="literal">UNION ALL</code> を使用するビューは、実装が一時テーブルを使用して処理するので、理論的に更新可能でも許可されません。
    </p><p>
      更新可能な複数テーブルビューでは、<code class="literal">INSERT</code> は、単一のテーブルに挿入する場合に機能します。<code class="literal">DELETE</code> はサポートされません。
    </p><p>
      <code class="literal">INSERT DELAYED</code> は、ビューではサポートされません。
    </p><p>
      テーブルに <code class="literal">AUTO_INCREMENT</code> カラムが含まれている場合、<code class="literal">AUTO_INCREMENT</code> カラムが含まれていないテーブル上の挿入可能なビューに挿入すると、<code class="literal">LAST_INSERT_ID()</code> の値を変更しません。これは、ビューの一部ではないカラムにデフォルト値を挿入した副作用が現れないようにするためです。
    </p><p>
      更新可能なビューに対して <code class="literal">WITH CHECK OPTION</code> 句を指定すると、<em class="replaceable"><code>select_statement</code></em> 内の <code class="literal">WHERE</code> 句が true である行を除く行への挿入または更新を回避できます。
    </p><p>
      更新可能なビューに対する <code class="literal">WITH CHECK OPTION</code> 句では、そのビューが別のビューとの関連で定義されている場合、<code class="literal">LOCAL</code> および <code class="literal">CASCADED</code> キーワードによってチェックテストのスコープが決定されます。<code class="literal">LOCAL</code> キーワードは、<code class="literal">CHECK OPTION</code> を、定義されているビューのみに制限します。<code class="literal">CASCADED</code> を指定すると、ベースとなるビューに対するチェックも評価されます。どちらのキーワードも指定されていない場合、デフォルトは <code class="literal">CASCADED</code> になります。次のテーブルと一連のビューの定義を考えてみてください。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (a INT);</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE VIEW v1 AS SELECT * FROM t1 WHERE a &lt; 2</code></strong>
    -&gt; <strong class="userinput"><code>WITH CHECK OPTION;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE VIEW v2 AS SELECT * FROM v1 WHERE a &gt; 0</code></strong>
    -&gt; <strong class="userinput"><code>WITH LOCAL CHECK OPTION;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE VIEW v3 AS SELECT * FROM v1 WHERE a &gt; 0</code></strong>
    -&gt; <strong class="userinput"><code>WITH CASCADED CHECK OPTION;</code></strong>
</pre><p>
      ここで、<code class="literal">v2</code> および <code class="literal">v3</code> ビューは、<code class="literal">v1</code> という別のビューの観点で定義されています。<code class="literal">v2</code> には <code class="literal">LOCAL</code> チェックオプションがあるので、挿入は、<code class="literal">v2</code> チェックに対してのみテストされます。<code class="literal">v3</code> には <code class="literal">CASCADED</code> チェックオプションがあるので、挿入はそれ自身のチェックに対してだけでなく、ベースとなるビューのチェックに対してもテストされます。次のステートメントでこれらの違いを示しています。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>INSERT INTO v2 VALUES (2);</code></strong>
Query OK, 1 row affected (0.00 sec)
mysql&gt; <strong class="userinput"><code>INSERT INTO v3 VALUES (2);</code></strong>
ERROR 1369 (HY000): CHECK OPTION failed 'test.v3'
</pre><p>
      MySQL は、<code class="literal">CREATE VIEW</code> 時に、ビューの更新可能性フラグというフラグを設定します。<code class="literal">UPDATE</code> および <code class="literal">DELETE</code> (および同様の操作) がビューで有効な場合、フラグは <code class="literal">YES</code> (true) に設定されます。それ以外の場合、フラグは <code class="literal">NO</code> (false) に設定されます。<code class="literal">INFORMATION_SCHEMA.VIEWS</code> テーブルの <code class="literal">IS_UPDATABLE</code> カラムは、このフラグのステータスを表示します。これは、ビューが更新可能であるかどうかをサーバーが常に把握していることを意味します。ビューが更新可能ではない場合、<code class="literal">UPDATE</code>、<code class="literal">DELETE</code>、<code class="literal">INSERT</code> などのステートメントは無効であり、拒否されます。(このセクションの別の箇所で説明しているように、ビューが更新可能である場合でも、ビューへの挿入はできない場合もあります。)
    </p><p>
      ビューを更新できるかどうかは、<code class="literal">updatable_views_with_limit</code> システム変数の値に影響されます。<a class="xref" href="server-administration.html#server-system-variables" title="5.1.4 サーバーシステム変数">セクション5.1.4「サーバーシステム変数」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="view-metadata"></a>20.5.4 ビューのメタデータ</h3></div></div></div><a class="indexterm" name="idm139979012932944"></a><a class="indexterm" name="idm139979012930832"></a><p>
      ビューに関するメタデータは次のように取得できます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">INFORMATION_SCHEMA</code> データベースの <code class="literal">VIEWS</code> テーブルをクエリーします。<a class="xref" href="information-schema.html#views-table" title="21.28 INFORMATION_SCHEMA VIEWS テーブル">セクション21.28「INFORMATION_SCHEMA VIEWS テーブル」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">SHOW CREATE VIEW</code> ステートメントを使用します。<a class="xref" href="sql-syntax.html#show-create-view" title="13.7.5.14 SHOW CREATE VIEW 構文">セクション13.7.5.14「SHOW CREATE VIEW 構文」</a>を参照してください。
        </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="stored-programs-security"></a>20.6 ストアドプログラムおよびビューのアクセスコントロール</h2></div></div></div><p>
      ストアドプログラムとビューは使用する前に定義され、参照されるときに、その権限を決定するセキュリティーのコンテキスト内で実行します。これらの権限は、その <code class="literal">DEFINER</code> 属性と、存在する場合はその <code class="literal">SQL SECURITY</code> 特性で制御されます。
    </p><p>
      すべてのストアドプログラム (プロシージャー、関数、トリガー、およびイベント) とビューには、MySQL アカウントを指名する <code class="literal">DEFINER</code> 属性を含めることができます。<code class="literal">DEFINER</code> 属性をストアドプログラムまたはビュー定義から省略した場合、デフォルトのアカウントは、オブジェクトを作成するユーザーになります。
    </p><p>
      さらに、ストアドルーチン (プロシージャーおよび関数) とビューには、値が <code class="literal">DEFINER</code> または <code class="literal">INVOKER</code> である <code class="literal">SQL SECURITY</code> 特性があり、オブジェクトが定義側のコンテキストで実行するか、呼び出し元のコンテキストで実行するかを指定できます。<code class="literal">SQL SECURITY</code> 特性を省略した場合、デフォルトは定義側のコンテキストになります。
    </p><p>
      トリガーとイベントには、<code class="literal">SQL SECURITY</code> 特性がなく、常に定義側のコンテキストで実行します。サーバーが必要に応じて自動的にこれらのオブジェクトを呼び出すので、呼び出し元ユーザーは存在しません。
    </p><p>
      定義側と呼び出し元のセキュリティーのコンテキストは次のように異なります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          定義側のセキュリティーコンテキストで実行するストアドプログラムまたはビューは、<code class="literal">DEFINER</code> 属性で指名されたアカウントの権限で実行します。これらの権限は、呼び出し元ユーザーの権限とは完全に異なる場合があります。呼び出し元は、オブジェクトを参照するために適切な権限 (たとえば、ストアドプロシージャーを呼び出すための <code class="literal">EXECUTE</code> や、ビューから選択するための <code class="literal">SELECT</code>) が必要ですが、オブジェクトが実行すると、呼び出し元の権限は無視され、<code class="literal">DEFINER</code> アカウント権限だけが重要になります。このアカウントの権限が低い場合、オブジェクトが実行できる操作は、それに応じて制限されます。<code class="literal">DEFINER</code> アカウントに高い権限が与えられている場合 (<code class="literal">root</code> アカウントなど)、<span class="emphasis"><em>呼び出し元のユーザーにかかわらず</em></span>、オブジェクトは強力な操作を実行できます。
        </p></li><li class="listitem"><p>
          呼び出し元のセキュリティーコンテキストで実行するストアドルーチンまたはビューは、呼び出し元が権限を持つ操作だけを実行できます。<code class="literal">DEFINER</code> 属性は指定できますが、呼び出し元のコンテキストで実行するオブジェクトに対して効果はありません。
        </p></li></ul></div><p>
      次のストアドプロシージャーを検討してください。
    </p><pre class="programlisting">
CREATE DEFINER = 'admin'@'localhost' PROCEDURE p1()
SQL SECURITY DEFINER
BEGIN
  UPDATE t1 SET counter = counter + 1;
END;
</pre><p>
      <code class="literal">p1</code> に対する <code class="literal">EXECUTE</code> 権限を持つどのユーザーでも、<code class="literal">CALL</code> ステートメントを使用してこれを呼び出すことができます。ただし、<code class="literal">p1</code> が実行するときには、<code class="literal">DEFINER</code> のセキュリティーコンテキストで実行するので、<code class="literal">DEFINER</code> 属性で指名されたアカウントである <code class="literal">'admin'@'localhost'</code> の権限で実行します。このアカウントは、<code class="literal">p1</code> の <code class="literal">EXECUTE</code> 権限のほかに、テーブル <code class="literal">t1</code> の <code class="literal">UPDATE</code> 権限が必要です。それ以外の場合、プロシージャーは失敗します。
    </p><p>
      続いて次のストアドプロシージャーを検討してください。これは <code class="literal">p1</code> と同じですが、その <code class="literal">SQL SECURITY</code> 特性が <code class="literal">INVOKER</code> である点が異なります。
    </p><pre class="programlisting">
CREATE DEFINER = 'admin'@'localhost' PROCEDURE p2()
SQL SECURITY INVOKER
BEGIN
  UPDATE t1 SET counter = counter + 1;
END;
</pre><p>
      <code class="literal">p2</code> は <code class="literal">p1</code> と異なり、<code class="literal">INVOKER</code> のセキュリティーコンテキストで実行します。<code class="literal">DEFINER</code> 属性は無関係であり、<code class="literal">p2</code> は呼び出し元ユーザーの権限で実行します。呼び出し元に <code class="literal">p2</code> に対する <code class="literal">EXECUTE</code> 権限、またはテーブル <code class="literal">t1</code> に対する <code class="literal">UPDATE</code> 権限が不足している場合、<code class="literal">p2</code> は失敗します。
    </p><p>
      MySQL は、次のルールを使用して、ユーザーがオブジェクトの <code class="literal">DEFINER</code> 属性で指定できるアカウントを制御します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">SUPER</code> 権限がある場合にかぎり、自身のアカウント以外の <code class="literal">DEFINER</code> 値を指定できます。
        </p></li><li class="listitem"><p>
          <code class="literal">SUPER</code> 権限がない場合、唯一の正当なユーザー値は、文字どおり指定するか、<code class="literal">CURRENT_USER</code> を使用して指定した自身のアカウントです。定義者をほかのアカウントに設定することはできません。
        </p></li></ul></div><p>
      ストアドプログラムおよびビューの作成と使用に関して考えられるリスクを最小限に抑えるため、次のガイドラインに従ってください。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          可能な場合は、ストアドルーチンまたはビューに対して、オブジェクト定義の <code class="literal">SQL SECURITY INVOKER</code> を使用して、オブジェクトが実行する操作に適したアクセス許可を持つユーザーだけが使用できるようにします。
        </p></li><li class="listitem"><p>
          <code class="literal">SUPER</code> 権限を持つアカウントの使用中に、定義側のコンテキストのストアドプログラムまたはビューを作成する場合は、オブジェクトが実行する操作に必要な権限だけを所有しているアカウントを指名する明示的な <code class="literal">DEFINER</code> 属性を指定します。高い権限を持つ <code class="literal">DEFINER</code> アカウントは、絶対に必要な場合にのみ指定してください。
        </p></li><li class="listitem"><p>
          管理者は、<code class="literal">SUPER</code> 権限をユーザーに与えなければ、高い権限を持つ <code class="literal">DEFINER</code> アカウントをユーザーが指定できないようにできます。
        </p></li><li class="listitem"><p>
          定義側のコンテキストのオブジェクトを作成するときには、呼び出し元ユーザーに権限のないデータに定義側がアクセスできる場合があります。権限のないユーザーに特定の権限を与えなければ、これらのオブジェクトへの参照を防止できる場合があります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              ストアドプロシージャーまたはストアドファンクションに対する <code class="literal">EXECUTE</code> 権限を持たないユーザーは、これを参照できません。
            </p></li><li class="listitem"><p>
              ビューに対する適切な権限 (ビューから選択するための <code class="literal">SELECT</code>、ビューに挿入するための <code class="literal">INSERT</code> など) を持っていないユーザーは、ビューを参照できません。
            </p></li></ul></div><p>
          ただし、トリガーに対するこのような制御は存在しません。ユーザーが直接トリガーを参照することはないからです。トリガーは常に、<code class="literal">DEFINER</code> コンテキストで実行し、特別な権限を持たないユーザーによる通常のテーブルアクセスを含め、トリガーが関連付けられているテーブルへのアクセスがあるとアクティブ化されます。<code class="literal">DEFINER</code> アカウントに高い権限が与えられている場合、トリガーは、慎重を要する操作または危険な操作を実行できます。トリガーの作成に必要な <code class="literal">SUPER</code> および <code class="literal">TRIGGER</code> 権限が、作成したユーザーのアカウントから削除された場合にも、このことは引き続き当てはまります。管理者は、この権限の組み合わせをユーザーに認める場合、特に注意する必要があります。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="stored-programs-logging"></a>20.7 ストアドプログラムのバイナリロギング</h2></div></div></div><p>
      バイナリログには、データベースの内容を変更する SQL ステートメントに関する情報が含まれます。この情報は、変更について記述した<span class="quote">「<span class="quote">イベント</span>」</span>の形式で格納されます。バイナリログには 2 つの重要な目的があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          レプリケーションの場合、バイナリログは、スレーブサーバーに送信されるステートメントのレコードとして、マスターレプリケーションサーバー上で使用されます。マスターサーバーは、そのバイナリログに格納されているイベントをそのスレーブに送信し、スレーブはこれらのイベントを実行して、マスター上で実行されたものと同じデータ変更を実行します。<a class="xref" href="replication.html#replication-implementation" title="17.2 レプリケーションの実装">セクション17.2「レプリケーションの実装」</a>を参照してください。
        </p></li><li class="listitem"><p>
          ある特定のデータリカバリ操作には、バイナリログの使用が必要です。バックアップファイルがリストアされたあと、バックアップの作成後に記録されたバイナリログ内のイベントが、再度実行されます。これらのイベントは、データベースをバックアップのポイントから最新の状態に持って行きます。<a class="xref" href="backup-and-recovery.html#recovery-from-backups" title="7.3.2 リカバリへのバックアップの使用">セクション7.3.2「リカバリへのバックアップの使用」</a>を参照してください。
        </p></li></ul></div><p>
      ただし、ロギングがステートメントレベルで行われる場合、ストアドプログラム (ストアドプロシージャーおよびストアドファンクション、トリガー、イベント) に関して該当する、特定のバイナリロギングの問題があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          場合によっては、ステートメントが、マスターとスレーブで別々の行セットに影響する可能性があります。
        </p></li><li class="listitem"><p>
          スレーブ上で実行された複製ステートメントは、完全な権限を持つスレーブ SQL スレッドで処理されます。プロシージャーが、マスターサーバーとスレーブサーバーで別々の実行パスに従うことが可能なので、ユーザーは、スレーブ上でのみ実行し、完全な権限を持つスレーブスレッドで処理される危険なステートメントを含んだルーチンを作成できます。
        </p></li><li class="listitem"><p>
          データを変更するストアドプログラムが非決定的である場合、再現可能ではありません。これにより、マスターとスレーブでデータが異なる結果になったり、リストアしたデータが元のデータと一致しなくなったりする場合があります。
        </p></li></ul></div><p>
      このセクションでは、MySQL 5.6 のストアドプログラムのバイナリロギングの処理について説明します。ここでは、実装がストアドプログラムの使用に対して設定している現在の条件と、問題を避けるために実行可能な対処について記しています。また、これらの条件の理由に関する追加情報も示します。
    </p><p>
      一般に、ここで述べる問題は、SQL ステートメントレベルでバイナリロギングが行われるときに生じます。行ベースのバイナリロギングを使用する場合、ログには、SQL ステートメントを実行した結果として個々の行に行われた変更が含まれます。ルーチンまたはトリガーが実行されると、行の変更が記録されますが、変更を行なったステートメントは記録されません。ストアドプロシージャーの場合、これは <code class="literal">CALL</code> ステートメントが記録されないことを意味します。ストアドファンクションの場合、関数内で行われた行の変更が記録され、関数呼び出しは記録されません。トリガーの場合、トリガーによって行われた行の変更が記録されます。スレーブ側では、行の変更だけが表示され、ストアドプログラムの呼び出しは表示されません。行ベースのロギングに関する一般情報については、<a class="xref" href="replication.html#replication-formats" title="17.1.2 レプリケーション形式">セクション17.1.2「レプリケーション形式」</a>を参照してください。
    </p><p>
      特に明記しないかぎり、ここでの説明では、<code class="option">--log-bin</code> オプションを指定してサーバーを起動することによって、バイナリロギングを有効にしていると想定しています。(<a class="xref" href="server-administration.html#binary-log" title="5.2.4 バイナリログ">セクション5.2.4「バイナリログ」</a>を参照してください。)バイナリログが有効でない場合、レプリケーションは可能でなく、バイナリログをデータリカバリに利用することもできません。
    </p><p>
      MySQL 5.6 でストアドファンクションを使用するための現在の条件は、次のように要約できます。これらの条件は、ストアドプロシージャーまたはイベントスケジューラのイベントには適用されず、バイナリロギングが有効でないかぎり適用されません。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ストアドファンクションを生成または変更するには、ユーザーは、通常必要になる <code class="literal">CREATE ROUTINE</code> 権限または <code class="literal">ALTER ROUTINE</code> 権限以外に、<code class="literal">SUPER</code> 権限が必要です。(関数定義の <code class="literal">DEFINER</code> 値によっては、バイナリロギングが有効かどうかにかかわらず <code class="literal">SUPER</code> が必要になる場合があります。<a class="xref" href="sql-syntax.html#create-procedure" title="13.1.15 CREATE PROCEDURE および CREATE FUNCTION 構文">セクション13.1.15「CREATE PROCEDURE および CREATE FUNCTION 構文」</a>を参照してください。)
        </p></li><li class="listitem"><p>
          ストアドファンクションを作成するとき、その関数が決定的であるということ、またはデータを変更しないということを宣言する必要があります。そのようにしないと、データリカバリまたレプリケーションにとって安全でなくなる可能性があります。
        </p><p>
          デフォルトでは、<code class="literal">CREATE FUNCTION</code> ステートメントを受け入れるには、<code class="literal">DETERMINISTIC</code>、<code class="literal">NO SQL</code>、または <code class="literal">READS SQL DATA</code> の少なくとも 1 つを明示的に指定する必要があります。そうでない場合はエラーが発生します。
        </p><pre class="programlisting">
ERROR 1418 (HY000): This function has none of DETERMINISTIC, NO SQL,
or READS SQL DATA in its declaration and binary logging is enabled
(you *might* want to use the less safe log_bin_trust_function_creators
variable)
</pre><p>
          次の関数は決定的なため (また、データを変更しません)、安全です。
        </p><pre class="programlisting">
CREATE FUNCTION f1(i INT)
RETURNS INT
DETERMINISTIC
READS SQL DATA
BEGIN
  RETURN i;
END;
</pre><p>
          次の関数は <code class="literal">UUID()</code> を使用しますが、これは決定的でないため、関数も決定的でなく、安全ではありません。
        </p><pre class="programlisting">
CREATE FUNCTION f2()
RETURNS CHAR(36) CHARACTER SET utf8
BEGIN
  RETURN UUID();
END;
</pre><p>
          次の関数はデータを変更するので、安全ではない可能性があります。
        </p><pre class="programlisting">
CREATE FUNCTION f3(p_id INT)
RETURNS INT
BEGIN
  UPDATE t SET modtime = NOW() WHERE id = p_id;
  RETURN ROW_COUNT();
END;
</pre><p>
          関数の性質の評価は、作成者の<span class="quote">「<span class="quote">誠実さ</span>」</span>に基づいています。MySQL は、<code class="literal">DETERMINISTIC</code> と宣言された関数に非決定的な結果を生成するステートメントが含まれていないかどうかをチェックしません。
        </p></li><li class="listitem"><p>
          <code class="literal">DETERMINISTIC</code> を指定しないで、決定的であるストアドファンクションを作成することは可能ですが、ステートメントベースのバイナリロギングを使用してこの関数を実行できません。このような関数を実行するには、行ベースまたは混合バイナリロギングを使用する必要があります。または、関数定義で <code class="literal">DETERMINISTIC</code> と明示的に指定すると、ステートメントベースのバイナリロギングを含むあらゆる種類のロギングを使用できます。
        </p></li><li class="listitem"><p>
          関数作成に関する前述の条件 (<code class="literal">SUPER</code> 権限を持つ必要があることと、関数が決定的であるか、データを変更しないと宣言する必要があること) を緩和するには、<code class="literal">log_bin_trust_function_creators</code> グローバルシステム変数を 1 に設定します。デフォルトでこの変数には 0 の値が設定されていますが、次のように変更できます。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET GLOBAL log_bin_trust_function_creators = 1;</code></strong>
</pre><p>
          サーバーの起動時に <code class="option">--log-bin-trust-function-creators=1</code> オプションを使用することによって、この変数を設定することもできます。
        </p><p>
          バイナリロギングが有効でない場合、<code class="literal">log_bin_trust_function_creators</code> は適用されません。前述のように、関数定義の <code class="literal">DEFINER</code> 値が必要としないかぎり、関数の作成に <code class="literal">SUPER</code> は必要ありません。
        </p></li><li class="listitem"><p>
          レプリケーションで安全ではない可能性のある (そのため、これらを使用するストアドファンクションも安全でなくなります) 組み込み関数の詳細は、<a class="xref" href="replication.html#replication-features" title="17.4.1 レプリケーションの機能と問題">セクション17.4.1「レプリケーションの機能と問題」</a>を参照してください。
        </p></li></ul></div><p>
      トリガーは、ストアドファンクションと似ているので、関数に関する前述の説明がトリガーにも当てはまりますが、<code class="literal">CREATE TRIGGER</code> にはオプションの <code class="literal">DETERMINISTIC</code> 特性がないため、トリガーは常に決定的であると想定されるという点が異なります。ただし、この想定は一部の場合で無効になることがあります。たとえば、<code class="literal">UUID()</code> 関数は非決定的です (また、複製しません)。トリガーでのこのような関数の使用には注意する必要があります。
    </p><p>
      トリガーはテーブルを更新できるので、必要な権限がない場合には、<code class="literal">CREATE TRIGGER</code> で、ストアドファンクションの場合と同様のエラーメッセージが表示されます。スレーブ側では、スレーブは <code class="literal">DEFINER</code> トリガー属性を使用して、トリガーの作成者であると思われるユーザーを特定します。
    </p><p>
      このセクションの残りの部分では、ロギングの実装とその意味に関する追加詳細について説明します。ストアドルーチンの使用に関する現在のロギング関連の条件の理論的根拠についての背景に関心がある場合には、こちらをお読みください。この説明はステートメントベースのロギングにのみ該当し、行ベースのロギングには該当しませんが、<code class="literal">CREATE</code> および <code class="literal">DROP</code> ステートメントは、ロギングモードとは無関係にステートメントとして記録されるという最初の項目は除きます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          サーバーは、<code class="literal">CREATE EVENT</code>、<code class="literal">CREATE PROCEDURE</code>、<code class="literal">CREATE FUNCTION</code>、<code class="literal">ALTER EVENT</code>、<code class="literal">ALTER PROCEDURE</code>、<code class="literal">ALTER FUNCTION</code>、<code class="literal">DROP EVENT</code>、<code class="literal">DROP PROCEDURE</code>、および <code class="literal">DROP FUNCTION</code> ステートメントをバイナリログに書き込みます。
        </p></li><li class="listitem"><p>
          ストアドファンクションの呼び出しは、この関数がデータを変更し、それ以外では記録されないようなステートメント内で行われた場合に、<code class="literal">SELECT</code> ステートメントとして記録されます。これにより、記録されないステートメントでストアドファンクションを使用した結果生じたデータの変更をレプリケーションできなくなるという事態が防止されます。たとえば、<code class="literal">SELECT</code> ステートメントはバイナリログに書き込まれませんが、<code class="literal">SELECT</code> は、変更を行うストアドファンクションを呼び出す場合があります。これを扱うため、<code class="literal">SELECT <em class="replaceable"><code>func_name</code></em>()</code> ステートメントは、指定した関数が変更を行うときにバイナリログに書き込まれます。次のステートメントがマスターで実行されるとします。
        </p><pre class="programlisting">
CREATE FUNCTION f1(a INT) RETURNS INT
BEGIN
  IF (a &lt; 3) THEN
    INSERT INTO t2 VALUES (a);
  END IF;
  RETURN 0;
END;

CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1),(2),(3);

SELECT f1(a) FROM t1;
</pre><p>
          <code class="literal">SELECT</code> ステートメントが実行されると、関数 <code class="literal">f1()</code> は 3 回呼び出されます。このうち 2 回の呼び出しで行を挿入し、MySQL は各行に対し <code class="literal">SELECT</code> ステートメントを記録します。つまり、MySQL は次のステートメントをバイナリログに書き込みます。
        </p><pre class="programlisting">
SELECT f1(1);
SELECT f1(2);
</pre><p>
          サーバーは、エラーを発生させるストアドプロシージャーをストアドファンクションが呼び出すときに、そのストアドファンクションの呼び出しに対する <code class="literal">SELECT</code> ステートメントも記録します。この場合、サーバーは、予想されるエラーコードとともに、<code class="literal">SELECT</code> ステートメントをログに書き込みます。スレーブ上で、同じエラーが起きた場合、これは予想される結果でありレプリケーションは継続します。それ以外の場合は、レプリケーションは停止します。
        </p></li><li class="listitem"><p>
          関数によって実行されるステートメントではなく、ストアドファンクションの呼び出しのロギングは、レプリケーションでは、次の 2 つの要因から生じるセキュリティー上の意味があります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              関数が、マスターサーバーとスレーブサーバーで別々の実行パスに従うことが可能です。
            </p></li><li class="listitem"><p>
              スレーブ上で実行されたステートメントは、完全な権限を持つスレーブ SQL スレッドで処理されます。
            </p></li></ul></div><p>
          つまり、ユーザーは関数を作成するために <code class="literal">CREATE ROUTINE</code> 権限を持つ必要がありますが、完全な権限を持つスレッドで処理されるスレーブ上でのみ実行する危険なステートメントを含んだ関数を作成できます。たとえば、マスターサーバーとスレーブサーバーのサーバー ID 値がそれぞれ 1 と 2 の場合、マスターサーバー上のユーザーは、安全ではない関数 <code class="literal">unsafe_func()</code> を次のように作成し呼び出すことができます。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>delimiter //</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE FUNCTION unsafe_func () RETURNS INT</code></strong>
    -&gt; <strong class="userinput"><code>BEGIN</code></strong>
    -&gt;   <strong class="userinput"><code>IF @@server_id=2 THEN <em class="replaceable"><code>dangerous_statement</code></em>; END IF;</code></strong>
    -&gt;   <strong class="userinput"><code>RETURN 1;</code></strong>
    -&gt; <strong class="userinput"><code>END;</code></strong>
    -&gt; <strong class="userinput"><code>//</code></strong>
mysql&gt; <strong class="userinput"><code>delimiter ;</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t VALUES(unsafe_func());</code></strong>
</pre><p>
          <code class="literal">CREATE FUNCTION</code> ステートメントおよび <code class="literal">INSERT</code> ステートメントはバイナリログに書き込まれるので、スレーブサーバーはそれらを実行します。スレーブ SQL スレッドには完全な権限があるので、危険なステートメントを実行します。したがって、関数の呼び出しがマスターとスレーブに与える効果は異なり、レプリケーションは安全ではなくなります。
        </p><p>
          バイナリロギングを有効にしているサーバーに対するこの危険から保護するために、ストアドファンクションの作成者は、必要な通常の <code class="literal">CREATE ROUTINE</code> 権限に加え、<code class="literal">SUPER</code> 権限も持つ必要があります。同様に、<code class="literal">ALTER FUNCTION</code> を使用するには、ユーザーは <code class="literal">ALTER ROUTINE</code> 権限に加え、<code class="literal">SUPER</code> 権限を持つ必要があります。<code class="literal">SUPER</code> 権限がないと、エラーが発生します。
        </p><pre class="programlisting">
ERROR 1419 (HY000): You do not have the SUPER privilege and
binary logging is enabled (you *might* want to use the less safe
log_bin_trust_function_creators variable)
</pre><p>
          関数作成者が <code class="literal">SUPER</code> 権限を持つよう要求しない場合 (たとえば、システム上の <code class="literal">CREATE ROUTINE</code> 権限を持つすべてのユーザーが経験豊かなアプリケーション開発者である場合)、<code class="literal">log_bin_trust_function_creators</code> グローバルシステム変数を 1 に設定します。サーバーの起動時に <code class="option">--log-bin-trust-function-creators=1</code> オプションを使用することによって、この変数を設定することもできます。バイナリロギングが有効でない場合、<code class="literal">log_bin_trust_function_creators</code> は適用されません。前述のように、関数定義の <code class="literal">DEFINER</code> 値が必要としないかぎり、関数の作成に <code class="literal">SUPER</code> は必要ありません。
        </p></li><li class="listitem"><p>
          更新を実行する関数が非決定的である場合、再現可能ではありません。これは次の 2 つの望ましくない影響を及ぼす可能性があります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              スレーブがマスターと一致しなくなります。
            </p></li><li class="listitem"><p>
              リストアされたデータが元のデータと異なります。
            </p></li></ul></div><p>
          これらの問題に対処するために、MySQL では、関数を決定的であるか、データを変更しないと宣言しないかぎり、マスターサーバーでは関数の作成と変更は拒否されるという要件を強制しています。ここでは次の 2 つの関数特性セットが適用されます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">DETERMINISTIC</code> 特性と <code class="literal">NOT DETERMINISTIC</code> 特性は、関数が一定の入力に対して常に同じ結果を生成するかどうかを示します。どちらの特性も指定されていない場合は、デフォルトは <code class="literal">NOT DETERMINISTIC</code> です。関数が決定的であることを宣言するには、明示的に <code class="literal">DETERMINISTIC</code> を指定する必要があります。
            </p></li><li class="listitem"><p>
              <code class="literal">CONTAINS SQL</code>、<code class="literal">NO SQL</code>、<code class="literal">READS SQL DATA</code>、および <code class="literal">MODIFIES SQL DATA</code> 特性は、関数がデータを読み取るか書き込むかに関する情報を示します。<code class="literal">NO SQL</code> または <code class="literal">READS SQL DATA</code> は、関数がデータを変更しないことを示しますが、特性が指定されていない場合にデフォルトは <code class="literal">CONTAINS SQL</code> になるので、これらのどちらかを明示的に指定する必要があります。
            </p></li></ul></div><p>
          デフォルトでは、<code class="literal">CREATE FUNCTION</code> ステートメントを受け入れるには、<code class="literal">DETERMINISTIC</code>、<code class="literal">NO SQL</code>、または <code class="literal">READS SQL DATA</code> の少なくとも 1 つを明示的に指定する必要があります。そうでない場合はエラーが発生します。
        </p><pre class="programlisting">
ERROR 1418 (HY000): This function has none of DETERMINISTIC, NO SQL,
or READS SQL DATA in its declaration and binary logging is enabled
(you *might* want to use the less safe log_bin_trust_function_creators
variable)
</pre><p>
          <code class="literal">log_bin_trust_function_creators</code> を 1 に設定した場合、関数が決定的であるか、データを変更しないという要件は破棄されます。
        </p></li><li class="listitem"><p>
          ストアドプロシージャーの呼び出しは <code class="literal">CALL</code> レベルでなく、ステートメントレベルで記録されます。つまり、サーバーは、<code class="literal">CALL</code> ステートメントを記録せず、実際に実行するプロシージャー内のステートメントを記録します。その結果、マスターで行われた同じ変更が、スレーブサーバーで確認されます。これにより、別々のマシン上で異なる実行パスを持つプロシージャーから生じる問題が防止されます。
        </p><p>
          一般に、ストアドプロシージャー内で実行されるステートメントは、スタンドアロンでステートメントを実行した場合に適用されるものと同じルールを使用して、バイナリログに書き込まれます。プロシージャー内でのステートメントの実行は、非プロシージャーのコンテキストとまったく同じにはならないので、プロシージャーステートメントのロギング時には、十分に注意してください。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <a class="indexterm" name="idm139979012692480"></a> 記録されるステートメントには、ローカルプロシージャー変数への参照が含まれる場合があります。これらの変数は、ストアドプロシージャーのコンテキスト外に存在しないので、このような変数を参照するステートメントは、文字どおりには記録できません。代わりに、ローカル変数のそれぞれの参照は、ロギングのために次の構造構文に置き換えられます。
            </p><pre class="programlisting">
NAME_CONST(<em class="replaceable"><code>var_name</code></em>, <em class="replaceable"><code>var_value</code></em>)
</pre><p>
              <em class="replaceable"><code>var_name</code></em> はローカル変数名であり、<em class="replaceable"><code>var_value</code></em> は、ステートメントの記録時に変数に含まれていた値を示す定数です。<code class="literal">NAME_CONST()</code> には <em class="replaceable"><code>var_value</code></em> の値と <em class="replaceable"><code>var_name</code></em> の<span class="quote">「<span class="quote">名前</span>」</span>が含まれます。したがって、この関数を直接呼び出した場合、次のような結果が得られます。
            </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT NAME_CONST('myname', 14);</code></strong>
+--------+
| myname |
+--------+
|     14 |
+--------+
</pre><p>
              <code class="literal">NAME_CONST()</code> は、マスター上でストアドプロシージャー内で実行された元のステートメントと同じ効果で、記録されたスタンドアロンのステートメントを、スレーブ上でも実行できるようにします。
            </p><p>
              <code class="literal">NAME_CONST()</code> を使用した結果、ソースカラム式がローカル変数を参照するときに、<code class="literal">CREATE TABLE ... SELECT</code> ステートメントの問題が生じる場合があります。これらの参照を <code class="literal">NAME_CONST()</code> 式に変換した結果、マスターサーバーとスレーブサーバーでカラム名が異なったり、正当なカラム識別子としては長すぎる名前になったりすることがあります。回避策では、ローカル変数を参照するカラムのエイリアスを指定します。<code class="literal">myvar</code> の値が 1 の場合は次のステートメントを検討してください。
            </p><pre class="programlisting">
CREATE TABLE t1 SELECT myvar;
</pre><p>
              これは次のように書き換えられます。
            </p><pre class="programlisting">
CREATE TABLE t1 SELECT NAME_CONST(myvar, 1);
</pre><p>
              マスターテーブルとスレーブテーブルに同じカラム名があることを確認するには、次のようなステートメントを作成します。
            </p><pre class="programlisting">
CREATE TABLE t1 SELECT myvar AS myvar;
</pre><p>
              書き換えられたステートメントは次のようになります。
            </p><pre class="programlisting">
CREATE TABLE t1 SELECT NAME_CONST(myvar, 1) AS myvar;
</pre></li><li class="listitem"><p>
              記録されるステートメントには、ユーザー定義変数への参照が含まれる場合があります。これを処理するために、MySQL は、<code class="literal">SET</code> ステートメントをバイナリログに書き込んで、マスター上にあるものと同じ値の変数がスレーブ上にもあることを確認します。たとえば、ステートメントが変数 <code class="literal">@my_var</code> を参照する場合、そのステートメントはバイナリログ内で次のステートメントに優先されます。ここで、<em class="replaceable"><code>value</code></em> マスター上の <code class="literal">@my_var</code> の値です。
            </p><pre class="programlisting">
SET @my_var = <em class="replaceable"><code>value</code></em>;
</pre></li><li class="listitem"><p>
              プロシージャーの呼び出しは、コミットまたはロールバックしたトランザクション内で行えます。プロシージャー実行のトランザクションの側面が正しく複製されるように、トランザクションのコンテキストが説明されます。つまり、サーバーは、実際にデータを実行し修正するプロシージャー内のステートメントを記録し、<code class="literal">BEGIN</code>、<code class="literal">COMMIT</code>、および <code class="literal">ROLLBACK</code> ステートメントも必要に応じて記録します。たとえば、プロシージャーがトランザクションテーブルだけを更新し、ロールバックされるトランザクション内で実行される場合、これらの更新は記録されません。プロシージャーがコミットされたトランザクション内で行われた場合、<code class="literal">BEGIN</code> および <code class="literal">COMMIT</code> ステートメントが更新とともに記録されます。ロールバックしたトランザクション内で実行するプロシージャーの場合、そのステートメントは、ステートメントがスタンドアロンで実行された場合に適用されるものと同じルールを使用して記録されます。
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                  トランザクションテーブルに対する更新は記録されません。
                </p></li><li class="listitem"><p>
                  非トランザクションテーブルに対する更新は、ロールバックで取り消されないので、記録されます。
                </p></li><li class="listitem"><p>
                  トランザクションテーブルと非トランザクションテーブルの混在に対する更新は、スレーブがマスターと同じ変更およびロールバックを行うように、<code class="literal">BEGIN</code> と <code class="literal">ROLLBACK</code> で囲まれて記録されます。
                </p></li></ul></div></li></ul></div></li><li class="listitem"><p>
          ストアドプロシージャーの呼び出しは、ストアドファンクション内から呼び出される場合、ステートメントレベルのバイナリログに書き込まれ<span class="emphasis"><em>ません</em></span>。この場合、記録される唯一の対象は、関数を呼び出すステートメント (記録されたステートメント内で行われた場合) または <code class="literal">DO</code> ステートメント (記録されないステートメント内で行われた場合) です。このため、それ以外の場合にプロシージャー自体が安全であっても、プロシージャーを呼び出すストアドファンクションを使用するときには注意を払う必要があります。
        </p></li></ul></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="partitioning.html">前</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="information-schema.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第 19 章 パーティション化 </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 第 21 章 INFORMATION_SCHEMA テーブル</td></tr></table></div><div class="copyright-footer"></div></body></html>
