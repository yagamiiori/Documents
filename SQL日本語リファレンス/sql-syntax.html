<html lang="ja"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>第 13 章 SQL ステートメントの構文</title><link rel="stylesheet" type="text/css" href="mvl.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="MySQL 5.6 リファレンスマニュアル"><link rel="up" href="index.html" title="MySQL 5.6 リファレンスマニュアル"><link rel="prev" href="functions.html" title="第 12 章 関数と演算子"><link rel="next" href="innodb-storage-engine.html" title="第 14 章 InnoDB ストレージエンジン">
<script language="javascript" type="text/javascript">
  function addOnload(theFunc)
  {
    var previous = window.onload;
    if (typeof window.onload != 'function')
    {
      window.onload = theFunc;
    }
    else
    {
      window.onload = function()
      {
        previous();
        theFunc();
      }
    }
  }

  addOnload(function()
  {
    var base = new Date(1442918127*1000);
    var now = new Date();
    var diff = ((now-base)/1000)/(24*3600);

    if (diff > 90) {
      var nodes = document.getElementsByClassName('titlepage');
      nodes[0].innerHTML = '<p style="border: 5px #ff0000 solid; padding: 5px; margin 5px">' +
        'This copy of the manual is more than 90 days old. We encourage you to download a ' +
        'new version from <a href="http://dev.mysql.com">dev.mysql.com/doc</a>.</p>' + nodes[0].innerHTML;
    }
  });
</script>
<noscript></noscript>
</head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第 13 章 SQL ステートメントの構文</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="functions.html">前</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="innodb-storage-engine.html">次へ</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="sql-syntax"></a>第 13 章 SQL ステートメントの構文</h1></div></div></div><div class="toc"><p><b>目次</b></p><dl class="toc"><dt><span class="section"><a href="sql-syntax.html#sql-syntax-data-definition">13.1 データ定義ステートメント</a></span></dt><dd><dl><dt><span class="section"><a href="sql-syntax.html#alter-database">13.1.1 ALTER DATABASE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-event">13.1.2 ALTER EVENT 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-logfile-group">13.1.3 ALTER LOGFILE GROUP 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-function">13.1.4 ALTER FUNCTION 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-procedure">13.1.5 ALTER PROCEDURE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-server">13.1.6 ALTER SERVER 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-table">13.1.7 ALTER TABLE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-tablespace">13.1.8 ALTER TABLESPACE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-view">13.1.9 ALTER VIEW 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-database">13.1.10 CREATE DATABASE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-event">13.1.11 CREATE EVENT 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-function">13.1.12 CREATE FUNCTION 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-index">13.1.13 CREATE INDEX 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-logfile-group">13.1.14 CREATE LOGFILE GROUP 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-procedure">13.1.15 CREATE PROCEDURE および CREATE FUNCTION 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-server">13.1.16 CREATE SERVER 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-table">13.1.17 CREATE TABLE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-tablespace">13.1.18 CREATE TABLESPACE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-trigger">13.1.19 CREATE TRIGGER 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-view">13.1.20 CREATE VIEW 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-database">13.1.21 DROP DATABASE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-event">13.1.22 DROP EVENT 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-function">13.1.23 DROP FUNCTION 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-index">13.1.24 DROP INDEX 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-logfile-group">13.1.25 DROP LOGFILE GROUP 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-procedure">13.1.26 DROP PROCEDURE および DROP FUNCTION 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-server">13.1.27 DROP SERVER 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-table">13.1.28 DROP TABLE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-tablespace">13.1.29 DROP TABLESPACE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-trigger">13.1.30 DROP TRIGGER 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-view">13.1.31 DROP VIEW 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#rename-table">13.1.32 RENAME TABLE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#truncate-table">13.1.33 TRUNCATE TABLE 構文</a></span></dt></dl></dd><dt><span class="section"><a href="sql-syntax.html#sql-syntax-data-manipulation">13.2 データ操作ステートメント</a></span></dt><dd><dl><dt><span class="section"><a href="sql-syntax.html#call">13.2.1 CALL 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#delete">13.2.2 DELETE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#do">13.2.3 DO 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#handler">13.2.4 HANDLER 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#insert">13.2.5 INSERT 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#load-data">13.2.6 LOAD DATA INFILE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#load-xml">13.2.7 LOAD XML 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#replace">13.2.8 REPLACE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#select">13.2.9 SELECT 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#subqueries">13.2.10 サブクエリー構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#update">13.2.11 UPDATE 構文</a></span></dt></dl></dd><dt><span class="section"><a href="sql-syntax.html#sql-syntax-transactions">13.3 MySQL トランザクションおよびロックステートメント</a></span></dt><dd><dl><dt><span class="section"><a href="sql-syntax.html#commit">13.3.1 START TRANSACTION、COMMIT、および ROLLBACK 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#cannot-roll-back">13.3.2 ロールバックできないステートメント</a></span></dt><dt><span class="section"><a href="sql-syntax.html#implicit-commit">13.3.3 暗黙的なコミットを発生させるステートメント</a></span></dt><dt><span class="section"><a href="sql-syntax.html#savepoint">13.3.4 SAVEPOINT、ROLLBACK TO SAVEPOINT、および RELEASE SAVEPOINT 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#lock-tables">13.3.5 LOCK TABLES および UNLOCK TABLES 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#set-transaction">13.3.6 SET TRANSACTION 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#xa">13.3.7 XA トランザクション</a></span></dt></dl></dd><dt><span class="section"><a href="sql-syntax.html#sql-syntax-replication">13.4 レプリケーションステートメント</a></span></dt><dd><dl><dt><span class="section"><a href="sql-syntax.html#replication-master-sql">13.4.1 マスターサーバーを制御するための SQL ステートメント</a></span></dt><dt><span class="section"><a href="sql-syntax.html#replication-slave-sql">13.4.2 スレーブサーバーを制御するための SQL ステートメント</a></span></dt></dl></dd><dt><span class="section"><a href="sql-syntax.html#sql-syntax-prepared-statements">13.5 準備済みステートメントのための SQL 構文</a></span></dt><dd><dl><dt><span class="section"><a href="sql-syntax.html#prepare">13.5.1 PREPARE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#execute">13.5.2 EXECUTE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#deallocate-prepare">13.5.3 DEALLOCATE PREPARE 構文</a></span></dt></dl></dd><dt><span class="section"><a href="sql-syntax.html#sql-syntax-compound-statements">13.6 MySQL 複合ステートメント構文</a></span></dt><dd><dl><dt><span class="section"><a href="sql-syntax.html#begin-end">13.6.1 BEGIN ... END 複合ステートメント構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#statement-labels">13.6.2 ステートメントラベルの構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#declare">13.6.3 DECLARE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#stored-program-variables">13.6.4 ストアドプログラム内の変数</a></span></dt><dt><span class="section"><a href="sql-syntax.html#flow-control-statements">13.6.5 フロー制御ステートメント</a></span></dt><dt><span class="section"><a href="sql-syntax.html#cursors">13.6.6 カーソル</a></span></dt><dt><span class="section"><a href="sql-syntax.html#condition-handling">13.6.7 条件の処理</a></span></dt></dl></dd><dt><span class="section"><a href="sql-syntax.html#sql-syntax-server-administration">13.7 データベース管理ステートメント</a></span></dt><dd><dl><dt><span class="section"><a href="sql-syntax.html#account-management-sql">13.7.1 アカウント管理ステートメント</a></span></dt><dt><span class="section"><a href="sql-syntax.html#table-maintenance-sql">13.7.2 テーブル保守ステートメント</a></span></dt><dt><span class="section"><a href="sql-syntax.html#plugin-sql">13.7.3 プラグインおよびユーザー定義関数ステートメント</a></span></dt><dt><span class="section"><a href="sql-syntax.html#set-statement">13.7.4 SET 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show">13.7.5 SHOW 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#other-administrative-sql">13.7.6 その他の管理ステートメント</a></span></dt></dl></dd><dt><span class="section"><a href="sql-syntax.html#sql-syntax-utility">13.8 MySQL ユーティリティーステートメント</a></span></dt><dd><dl><dt><span class="section"><a href="sql-syntax.html#describe">13.8.1 DESCRIBE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#explain">13.8.2 EXPLAIN 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#help">13.8.3 HELP 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#use">13.8.4 USE 構文</a></span></dt></dl></dd></dl></div><p>
    この章では、MySQL によってサポートされる <a class="link" href="glossary.html#glos_sql" title="SQL">SQL</a> ステートメントの構文について説明します。
  </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sql-syntax-data-definition"></a>13.1 データ定義ステートメント</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-syntax.html#alter-database">13.1.1 ALTER DATABASE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-event">13.1.2 ALTER EVENT 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-logfile-group">13.1.3 ALTER LOGFILE GROUP 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-function">13.1.4 ALTER FUNCTION 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-procedure">13.1.5 ALTER PROCEDURE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-server">13.1.6 ALTER SERVER 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-table">13.1.7 ALTER TABLE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-tablespace">13.1.8 ALTER TABLESPACE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-view">13.1.9 ALTER VIEW 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-database">13.1.10 CREATE DATABASE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-event">13.1.11 CREATE EVENT 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-function">13.1.12 CREATE FUNCTION 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-index">13.1.13 CREATE INDEX 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-logfile-group">13.1.14 CREATE LOGFILE GROUP 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-procedure">13.1.15 CREATE PROCEDURE および CREATE FUNCTION 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-server">13.1.16 CREATE SERVER 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-table">13.1.17 CREATE TABLE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-tablespace">13.1.18 CREATE TABLESPACE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-trigger">13.1.19 CREATE TRIGGER 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-view">13.1.20 CREATE VIEW 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-database">13.1.21 DROP DATABASE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-event">13.1.22 DROP EVENT 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-function">13.1.23 DROP FUNCTION 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-index">13.1.24 DROP INDEX 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-logfile-group">13.1.25 DROP LOGFILE GROUP 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-procedure">13.1.26 DROP PROCEDURE および DROP FUNCTION 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-server">13.1.27 DROP SERVER 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-table">13.1.28 DROP TABLE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-tablespace">13.1.29 DROP TABLESPACE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-trigger">13.1.30 DROP TRIGGER 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-view">13.1.31 DROP VIEW 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#rename-table">13.1.32 RENAME TABLE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#truncate-table">13.1.33 TRUNCATE TABLE 構文</a></span></dt></dl></div><a class="indexterm" name="idm139979090135632"></a><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="alter-database"></a>13.1.1 ALTER DATABASE 構文</h3></div></div></div><a class="indexterm" name="idm139979090133136"></a><a class="indexterm" name="idm139979090131824"></a><a class="indexterm" name="idm139979090130480"></a><a class="indexterm" name="idm139979090128336"></a><a class="indexterm" name="idm139979090126304"></a><a class="indexterm" name="idm139979090124272"></a><pre class="programlisting">
ALTER {DATABASE | SCHEMA} [<em class="replaceable"><code>db_name</code></em>]
    <em class="replaceable"><code>alter_specification</code></em> ...
ALTER {DATABASE | SCHEMA} <em class="replaceable"><code>db_name</code></em>
    UPGRADE DATA DIRECTORY NAME

<em class="replaceable"><code>alter_specification</code></em>:
    [DEFAULT] CHARACTER SET [=] <em class="replaceable"><code>charset_name</code></em>
  | [DEFAULT] COLLATE [=] <em class="replaceable"><code>collation_name</code></em>
</pre><p>
      <code class="literal">ALTER DATABASE</code> を使用すると、データベースの全体的な特性を変更できます。これらの特性は、データベースディレクトリ内の <code class="filename">db.opt</code> ファイルに格納されます。<code class="literal">ALTER DATABASE</code> を使用するには、そのデータベースに対する <code class="literal">ALTER</code> 権限が必要です。<code class="literal">ALTER SCHEMA</code> は <code class="literal">ALTER DATABASE</code> のシノニムです。
    </p><p>
      最初の構文からはデータベース名を省略できます。その場合、このステートメントはデフォルトデータベースに適用されます。
    </p><h4><a name="idm139979090108544"></a>各国語に関する特性</h4><p>
      <code class="literal">CHARACTER SET</code> 句は、デフォルトのデータベース文字セットを変更します。<code class="literal">COLLATE</code> 句は、デフォルトのデータベース照合順序を変更します。<a class="xref" href="globalization.html#charset" title="10.1 文字セットのサポート">セクション10.1「文字セットのサポート」</a>では、文字セットと照合順序名について説明しています。
    </p><p>
      どのような文字セットと照合順序を使用できるかは、それぞれ <code class="literal">SHOW CHARACTER SET</code> および <code class="literal">SHOW COLLATION</code> ステートメントを使用して確認できます。詳細は、<a class="xref" href="sql-syntax.html#show-character-set" title="13.7.5.4 SHOW CHARACTER SET 構文">セクション13.7.5.4「SHOW CHARACTER SET 構文」</a>および<a class="xref" href="sql-syntax.html#show-collation" title="13.7.5.5 SHOW COLLATION 構文">セクション13.7.5.5「SHOW COLLATION 構文」</a>を参照してください。
    </p><p>
      データベースのデフォルトの文字セットまたは照合順序を変更する場合、データベースのデフォルトを使用するストアドルーチンを削除して、新しいデフォルトを使用するように再作成する必要があります。(ストアドルーチンでは、文字セットまたは照合順序が明示的に指定されていない場合、文字データ型を伴う変数は、データベースのデフォルトを使用します。<a class="xref" href="sql-syntax.html#create-procedure" title="13.1.15 CREATE PROCEDURE および CREATE FUNCTION 構文">セクション13.1.15「CREATE PROCEDURE および CREATE FUNCTION 構文」</a>を参照してください。)
    </p><h4><a name="idm139979090098816"></a>MySQL 5.1 より古いバージョンからのアップグレード</h4><p>
      <code class="literal">UPGRADE DATA DIRECTORY NAME</code> 句を含む構文は、データベースに関連付けられたディレクトリの名前を、データベース名をデータベースディレクトリ名にマップするための MySQL 5.1 で実装されたエンコーディングを使用するように更新します (<a class="xref" href="language-structure.html#identifier-mapping" title="9.2.3 識別子とファイル名のマッピング">セクション9.2.3「識別子とファイル名のマッピング」</a>を参照してください)。この句は、次の条件の下で使用されることを目的にしています。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          MySQL を古いバージョンから 5.1 以降にアップグレードすることを目的にしている。
        </p></li><li class="listitem"><p>
          データベースディレクトリ名にエンコーディングが必要な特殊文字が含まれている場合は、その名前を現在のエンコーディング形式に更新することを目的にしている。
        </p></li><li class="listitem"><p>
          このステートメントが (<span class="command"><strong>mysql_upgrade</strong></span> から呼び出された) <span class="command"><strong>mysqlcheck</strong></span> によって使用されている。
        </p></li></ul></div><p>
      たとえば、MySQL 5.0 でのデータベース名が <code class="literal">a-b-c</code> である場合、その名前には <code class="literal">-</code> (ダッシュ) 文字のインスタンスが含まれています。MySQL 5.0 では、データベースディレクトリの名前も、必ずしもすべてのファイルシステムで安全ではない <code class="literal">a-b-c</code> になります。MySQL 5.1 以降では、ファイルシステムに依存しないディレクトリ名を生成するために、同じデータベース名が <code class="literal">a@002db@002dc</code> としてエンコードされます。
    </p><p>
      MySQL インストールが古いバージョンから MySQL 5.1 以降にアップグレードされると、サーバーでは <code class="literal">a-b-c</code> などの (古い形式の) 名前が <code class="literal">#mysql50#a-b-c</code> として表示されるため、<code class="literal">#mysql50#</code> プリフィクスを使用して名前を参照する必要があります。この場合は、<code class="literal">UPGRADE DATA DIRECTORY NAME</code> を使用して、データベースディレクトリ名を現在のエンコーディング形式に再エンコーディングするようサーバーに明示的に指示します。
    </p><pre class="programlisting">
ALTER DATABASE `#mysql50#a-b-c` UPGRADE DATA DIRECTORY NAME;
</pre><p>
      このステートメントを実行したあとは、特殊な <code class="literal">#mysql50#</code> プリフィクスなしで、そのデータベースを <code class="literal">a-b-c</code> として参照できます。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="alter-event"></a>13.1.2 ALTER EVENT 構文</h3></div></div></div><a class="indexterm" name="idm139979090077328"></a><a class="indexterm" name="idm139979090075168"></a><a class="indexterm" name="idm139979090073136"></a><pre class="programlisting">
ALTER
    [DEFINER = { <em class="replaceable"><code>user</code></em> | CURRENT_USER }]
    EVENT <em class="replaceable"><code>event_name</code></em>
    [ON SCHEDULE <em class="replaceable"><code>schedule</code></em>]
    [ON COMPLETION [NOT] PRESERVE]
    [RENAME TO <em class="replaceable"><code>new_event_name</code></em>]
    [ENABLE | DISABLE | DISABLE ON SLAVE]
    [COMMENT '<em class="replaceable"><code>comment</code></em>']
    [DO <em class="replaceable"><code>event_body</code></em>]
</pre><p>
      <code class="literal">ALTER EVENT</code> ステートメントは、既存のイベントの 1 つ以上の特性を、そのイベントを削除して再作成することなく変更します。<code class="literal">DEFINER</code>、<code class="literal">ON SCHEDULE</code>、<code class="literal">ON COMPLETION</code>、<code class="literal">COMMENT</code>、<code class="literal">ENABLE</code>/<code class="literal">DISABLE</code>、<code class="literal">DO</code> の各句の構文は、<code class="literal">CREATE EVENT</code> で使用される場合とまったく同じです。(<a class="xref" href="sql-syntax.html#create-event" title="13.1.11 CREATE EVENT 構文">セクション13.1.11「CREATE EVENT 構文」</a>を参照してください。)
    </p><p>
      どのユーザーも、そのユーザーが <code class="literal">EVENT</code> 権限を持っているデータベースで定義されたイベントを変更できます。ユーザーが正常な <code class="literal">ALTER EVENT</code> ステートメントを実行すると、そのユーザーは、影響を受けるイベントの定義者になります。
    </p><p>
      <code class="literal">ALTER EVENT</code> は、既存のイベントでのみ機能します。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>ALTER EVENT no_such_event </code></strong>
     &gt;     <strong class="userinput"><code>ON SCHEDULE </code></strong>
     &gt;       <strong class="userinput"><code>EVERY '2:3' DAY_HOUR;</code></strong>
<span class="errortext">ERROR 1517 (HY000): Unknown event 'no_such_event'</span>
</pre><p>
      次の各例では、<code class="literal">myevent</code> という名前のイベントが次に示すように定義されていることを前提にしています。
    </p><pre class="programlisting">
CREATE EVENT myevent
    ON SCHEDULE
      EVERY 6 HOUR
    COMMENT 'A sample comment.'
    DO
      UPDATE myschema.mytable SET mycol = mycol + 1;
</pre><p>
      次のステートメントは、<code class="literal">myevent</code> のスケジュールを、ただちに開始して 6 時間ごとに 1 回から、ステートメントが実行された 4 時間後から開始して 12 時間ごとに 1 回に変更します。
    </p><pre class="programlisting">
ALTER EVENT myevent
    ON SCHEDULE
      EVERY 12 HOUR
    STARTS CURRENT_TIMESTAMP + INTERVAL 4 HOUR;
</pre><p>
      イベントの複数の特性を 1 つのステートメントで変更できます。この例では、<code class="literal">myevent</code> によって実行される SQL ステートメントを、<code class="literal">mytable</code> のすべてのレコードを削除する SQL ステートメントに変更します。また、イベントのスケジュールも、この <code class="literal">ALTER EVENT</code> ステートメントが実行された 1 日あとに 1 回実行されるように変更します。
    </p><pre class="programlisting">
ALTER EVENT myevent
    ON SCHEDULE
      AT CURRENT_TIMESTAMP + INTERVAL 1 DAY
    DO
      TRUNCATE TABLE myschema.mytable;
</pre><p>
      <code class="literal">ALTER EVENT</code> ステートメントでは、変更したい特性のオプションのみを指定します。省略されたオプションでは、その既存の値が保持されます。これには、<code class="literal">ENABLE</code> などの、<code class="literal">CREATE EVENT</code> のデフォルト値もすべて含まれます。
    </p><p>
      <code class="literal">myevent</code> を無効にするには、この <code class="literal">ALTER EVENT</code> ステートメントを使用します。
    </p><pre class="programlisting">
ALTER EVENT myevent
    DISABLE;
</pre><p>
      <code class="literal">ON SCHEDULE</code> 句では、組み込みの MySQL 関数やユーザー変数を含む式を使用して、そこに含まれているすべての <em class="replaceable"><code>timestamp</code></em> または <em class="replaceable"><code>interval</code></em> 値を取得できます。このような式でストアドルーチンやユーザー定義関数を使用したり、テーブル参照を使用したりすることはできません。ただし、<code class="literal">SELECT FROM DUAL</code> は使用できます。これは、<code class="literal">ALTER EVENT</code> ステートメントと <code class="literal">CREATE EVENT</code> ステートメントの両方に当てはまります。このような場合のストアドルーチン、ユーザー定義関数、およびテーブルへの参照は明確に禁止されており、エラーで失敗します (Bug #22830 を参照してください)。
    </p><p>
      <code class="literal">DO</code> 句に別の <code class="literal">ALTER EVENT</code> ステートメントを含む <code class="literal">ALTER EVENT</code> ステートメントは成功したように見えますが、結果として得られるスケジュールされたイベントをサーバーが実行しようとすると、その実行はエラーで失敗します。
    </p><p>
      イベントの名前を変更するには、<code class="literal">ALTER EVENT</code> ステートメントの <code class="literal">RENAME TO</code> 句を使用します。このステートメントは、イベント <code class="literal">myevent</code> の名前を <code class="literal">yourevent</code> に変更します。
    </p><pre class="programlisting">
ALTER EVENT myevent
    RENAME TO yourevent;
</pre><p>
      次に示すように、<code class="literal">ALTER EVENT ... RENAME TO ...</code> と <code class="literal"><em class="replaceable"><code>db_name.event_name</code></em></code> 表記を使用して、イベントを別のデータベースに移動することもできます。
    </p><pre class="programlisting">
ALTER EVENT olddb.myevent
    RENAME TO newdb.myevent;
</pre><p>
      前のステートメントを実行するには、それを実行するユーザーが、<code class="literal">olddb</code> および <code class="literal">newdb</code> データベースの両方に対する <code class="literal">EVENT</code> 権限を持っている必要があります。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">RENAME EVENT</code> ステートメントはありません。
      </p></div><p>
      値 <code class="literal">DISABLE ON SLAVE</code> は、マスター上で作成されてスレーブにレプリケートされたが、まだスレーブ上で実行されていないイベントを示すために、<code class="literal">ENABLE</code> または <code class="literal">DISABLE</code> の代わりにレプリケーションスレーブに対して使用されます。通常、<code class="literal">DISABLE ON SLAVE</code> は必要に応じて自動的に設定されます。ただし、手動で変更することが必要になる場合もあります。詳細は、<a class="xref" href="replication.html#replication-features-invoked" title="17.4.1.11 呼び出される機能のレプリケーション">セクション17.4.1.11「呼び出される機能のレプリケーション」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="alter-logfile-group"></a>13.1.3 ALTER LOGFILE GROUP 構文</h3></div></div></div><a class="indexterm" name="idm139979090004688"></a><pre class="programlisting">
ALTER LOGFILE GROUP <em class="replaceable"><code>logfile_group</code></em>
    ADD UNDOFILE '<em class="replaceable"><code>file_name</code></em>'
    [INITIAL_SIZE [=] <em class="replaceable"><code>size</code></em>]
    [WAIT]
    ENGINE [=] <em class="replaceable"><code>engine_name</code></em>
</pre><p>
      このステートメントは、'<em class="replaceable"><code>file_name</code></em>' という名前の <code class="literal">UNDO</code> ファイルを既存のログファイルグループ <em class="replaceable"><code>logfile_group</code></em> に追加します。<code class="literal">ALTER LOGFILE GROUP</code> ステートメントには、<code class="literal">ADD UNDOFILE</code> 句が 1 つだけ存在します。<code class="literal">DROP UNDOFILE</code> 句は、現在サポートされていません。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        すべての MySQL Cluster ディスクデータオブジェクトが同じ名前空間を共有します。つまり、<span class="emphasis"><em>各ディスクデータオブジェクト</em></span>は (単に、特定の型の各ディスクデータオブジェクトというだけでなく)、一意の名前が付けられている必要があります。たとえば、テーブルスペースと Undo ログファイルを同じ名前にしたり、Undo ログファイルとデータファイルを同じ名前にしたりすることはできません。
      </p></div><p>
      オプションの <code class="literal">INITIAL_SIZE</code> パラメータは、<code class="literal">UNDO</code> ファイルの初期サイズをバイト単位で設定します。指定されていない場合、初期サイズはデフォルトで 134217728 (128M バイト) になります。MySQL Cluster NDB 7.3.2 より前は、この値は数字で指定する必要がありました。MySQL Cluster NDB 7.3.2 以降では、<em class="replaceable"><code>size</code></em> のあとにオプションで、<code class="filename">my.cnf</code> で使用されるのと同様の、オーダーを示す 1 文字の略語を指定できます。一般に、これは <code class="literal">M</code> (M バイト) または <code class="literal">G</code> (G バイト) のどちらかの文字です。(Bug #13116514、Bug #16104705、Bug #62858)
    </p><p>
      32 ビットシステム上では、<code class="literal">INITIAL_SIZE</code> のサポートされる最大値は 4294967296 (4G バイト) です。(Bug #29186)
    </p><p>
      <code class="literal">INITIAL_SIZE</code> の許可される最小値は 1048576 (1M バイト) です。(Bug #29574)
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">WAIT</code> は解析されますが、それ以外は無視されます。このキーワードは現在何の効果もなく、将来の拡張のために用意されています。
      </p></div><p>
      <code class="literal">ENGINE</code> パラメータ (必須) は、このログファイルグループによって使用されるストレージエンジンを決定します。ここで、<em class="replaceable"><code>engine_name</code></em> はそのストレージエンジンの名前です。現在、<em class="replaceable"><code>engine_name</code></em> として受け入れられる値は<span class="quote">「<span class="quote"><code class="literal">NDBCLUSTER</code></span>」</span>と<span class="quote">「<span class="quote"><code class="literal">NDB</code></span>」</span>だけです。この 2 つの値は同等です。
    </p><p>
      次の例では、ログファイルグループ <code class="literal">lg_3</code> がすでに <code class="literal">CREATE LOGFILE GROUP</code> を使用して作成されていることを前提にしています (<a class="xref" href="sql-syntax.html#create-logfile-group" title="13.1.14 CREATE LOGFILE GROUP 構文">セクション13.1.14「CREATE LOGFILE GROUP 構文」</a>を参照してください)。
    </p><pre class="programlisting">
ALTER LOGFILE GROUP lg_3
    ADD UNDOFILE 'undo_10.dat'
    INITIAL_SIZE=32M
    ENGINE=NDBCLUSTER;
</pre><p>
      <code class="literal">ALTER LOGFILE GROUP</code> が <code class="literal">ENGINE = NDBCLUSTER</code> (または、<code class="literal">ENGINE = NDB</code>) とともに使用された場合は、<code class="literal">UNDO</code> ログファイルが各 MySQL Cluster データノード上に作成されます。<code class="literal">INFORMATION_SCHEMA.FILES</code> テーブルをクエリーすることによって、<code class="literal">UNDO</code> ファイルが作成されたことを確認したり、それらに関する情報を取得したりできます。例:
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT FILE_NAME, LOGFILE_GROUP_NUMBER, EXTRA</code></strong>
    -&gt; <strong class="userinput"><code>FROM INFORMATION_SCHEMA.FILES</code></strong>
    -&gt; <strong class="userinput"><code>WHERE LOGFILE_GROUP_NAME = 'lg_3';</code></strong>
+-------------+----------------------+----------------+
| FILE_NAME   | LOGFILE_GROUP_NUMBER | EXTRA          |
+-------------+----------------------+----------------+
| newdata.dat |                    0 | CLUSTER_NODE=3 |
| newdata.dat |                    0 | CLUSTER_NODE=4 |
| undo_10.dat |                   11 | CLUSTER_NODE=3 |
| undo_10.dat |                   11 | CLUSTER_NODE=4 |
+-------------+----------------------+----------------+
4 rows in set (0.01 sec)
</pre><p>
      (<a class="xref" href="information-schema.html#files-table" title="21.30.1 INFORMATION_SCHEMA FILES テーブル">セクション21.30.1「INFORMATION_SCHEMA FILES テーブル」</a>を参照してください。)
    </p><p>
      <code class="literal">UNDO_BUFFER_SIZE</code> に使用されるメモリーは、サイズが <code class="literal">SharedGlobalMemory</code> データノード構成パラメータの値によって決定されるグローバルプールから取得されます。これには、<code class="literal">InitialLogFileGroup</code> データノード構成パラメータの設定により、このオプションに暗黙的に指定されるデフォルト値もすべて含まれます。
    </p><p>
      <code class="literal">ALTER LOGFILE GROUP</code> は、MySQL Cluster のディスクデータストレージでのみ有効です。詳細は、<a class="xref" href="mysql-cluster.html#mysql-cluster-disk-data" title="18.5.12 MySQL Cluster ディスクデータテーブル">セクション18.5.12「MySQL Cluster ディスクデータテーブル」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="alter-function"></a>13.1.4 ALTER FUNCTION 構文</h3></div></div></div><a class="indexterm" name="idm139979089953712"></a><pre class="programlisting">
ALTER FUNCTION <em class="replaceable"><code>func_name</code></em> [<em class="replaceable"><code>characteristic</code></em> ...]

<em class="replaceable"><code>characteristic</code></em>:
    COMMENT '<em class="replaceable"><code>string</code></em>'
  | LANGUAGE SQL
  | { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }
  | SQL SECURITY { DEFINER | INVOKER }
</pre><p>
      このステートメントを使用すると、ストアドファンクションの特性を変更できます。<code class="literal">ALTER FUNCTION</code> ステートメントでは、複数の変更を指定できます。ただし、このステートメントを使用して、ストアドファンクションのパラメータまたは本体を変更することはできません。このような変更を行うには、<code class="literal">DROP FUNCTION</code> と <code class="literal">CREATE FUNCTION</code> を使用して、この関数を削除および再作成する必要があります。
    </p><p>
      この関数に対する <code class="literal">ALTER ROUTINE</code> 権限が必要です。(その権限は、関数作成者に自動的に付与されます。)バイナリロギングが有効になっている場合は、<a class="xref" href="stored-programs-views.html#stored-programs-logging" title="20.7 ストアドプログラムのバイナリロギング">セクション20.7「ストアドプログラムのバイナリロギング」</a>で説明されているように、<code class="literal">ALTER FUNCTION</code> ステートメントに <code class="literal">SUPER</code> 権限も必要になる可能性があります。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="alter-procedure"></a>13.1.5 ALTER PROCEDURE 構文</h3></div></div></div><a class="indexterm" name="idm139979089935856"></a><pre class="programlisting">
ALTER PROCEDURE <em class="replaceable"><code>proc_name</code></em> [<em class="replaceable"><code>characteristic</code></em> ...]

<em class="replaceable"><code>characteristic</code></em>:
    COMMENT '<em class="replaceable"><code>string</code></em>'
  | LANGUAGE SQL
  | { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }
  | SQL SECURITY { DEFINER | INVOKER }
</pre><p>
      このステートメントを使用すると、ストアドプロシージャーの特性を変更できます。<code class="literal">ALTER PROCEDURE</code> ステートメントでは、複数の変更を指定できます。ただし、このステートメントを使用して、ストアドプロシージャーのパラメータまたは本体を変更することはできません。このような変更を行うには、<code class="literal">DROP PROCEDURE</code> と <code class="literal">CREATE PROCEDURE</code> を使用して、このプロシージャーを削除および再作成する必要があります。
    </p><p>
      このプロシージャーに対する <code class="literal">ALTER ROUTINE</code> 権限が必要です。デフォルトでは、その権限は、プロシージャー作成者に自動的に付与されます。この動作は、<code class="literal">automatic_sp_privileges</code> システム変数を無効にすることによって変更できます。<a class="xref" href="stored-programs-views.html#stored-routines-privileges" title="20.2.2 ストアドルーチンと MySQL 権限">セクション20.2.2「ストアドルーチンと MySQL 権限」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="alter-server"></a>13.1.6 ALTER SERVER 構文</h3></div></div></div><a class="indexterm" name="idm139979089918848"></a><pre class="programlisting">
ALTER SERVER  <em class="replaceable"><code>server_name</code></em>
    OPTIONS (<em class="replaceable"><code>option</code></em> [, <em class="replaceable"><code>option</code></em>] ...)
</pre><p>
      <code class="literal"><em class="replaceable"><code>server_name</code></em></code> のサーバー情報を変更して、<code class="literal">CREATE SERVER</code> ステートメント内で許可されているオプションのいずれかを調整します。それに応じて、<code class="literal">mysql.servers</code> テーブル内の対応するフィールドが更新されます。このステートメントには、<code class="literal">SUPER</code> 権限が必要です。
    </p><p>
      たとえば、<code class="literal">USER</code> オプションを更新するには、次のようにします。
    </p><pre class="programlisting">ALTER SERVER s OPTIONS (USER 'sally');</pre><p>
      <code class="literal">ALTER SERVER</code> では、自動コミットは実行されません。
    </p><p>
      MySQL 5.6 では、使用されているロギング形式には関係なく、<code class="literal">ALTER SERVER</code> はバイナリログに書き込まれません。
    </p><p>
      MySQL 5.6.11 でのみ、このステートメントを発行する前に、<code class="literal">gtid_next</code> を <code class="literal">AUTOMATIC</code> に設定する必要があります。(Bug #16062608、Bug #16715809、Bug #69045)
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="alter-table"></a>13.1.7 ALTER TABLE 構文</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-syntax.html#alter-table-partition-operations">13.1.7.1 ALTER TABLE パーティション操作</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-table-online-operations">13.1.7.2 MySQL Cluster での ALTER TABLE オンライン操作</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-table-examples">13.1.7.3 ALTER TABLE の例</a></span></dt></dl></div><a class="indexterm" name="idm139979089899104"></a><a class="indexterm" name="idm139979089897792"></a><a class="indexterm" name="idm139979089895648"></a><pre class="programlisting">
ALTER [ONLINE|OFFLINE] [IGNORE] TABLE <em class="replaceable"><code>tbl_name</code></em>
    [<em class="replaceable"><code>alter_specification</code></em> [, <em class="replaceable"><code>alter_specification</code></em>] ...]
    [<em class="replaceable"><code>partition_options</code></em>]

<em class="replaceable"><code>alter_specification</code></em>:
    <em class="replaceable"><code>table_options</code></em>
  | ADD [COLUMN] <em class="replaceable"><code>col_name</code></em> <em class="replaceable"><code>column_definition</code></em>
        [FIRST | AFTER <em class="replaceable"><code>col_name</code></em> ]
  | ADD [COLUMN] (<em class="replaceable"><code>col_name</code></em> <em class="replaceable"><code>column_definition</code></em>,...)
  | ADD {INDEX|KEY} [<em class="replaceable"><code>index_name</code></em>]
        [<em class="replaceable"><code>index_type</code></em>] (<em class="replaceable"><code>index_col_name</code></em>,...) [<em class="replaceable"><code>index_option</code></em>] ...
  | ADD [CONSTRAINT [<em class="replaceable"><code>symbol</code></em>]] PRIMARY KEY
        [<em class="replaceable"><code>index_type</code></em>] (<em class="replaceable"><code>index_col_name</code></em>,...) [<em class="replaceable"><code>index_option</code></em>] ...
  | ADD [CONSTRAINT [<em class="replaceable"><code>symbol</code></em>]]
        UNIQUE [INDEX|KEY] [<em class="replaceable"><code>index_name</code></em>]
        [<em class="replaceable"><code>index_type</code></em>] (<em class="replaceable"><code>index_col_name</code></em>,...) [<em class="replaceable"><code>index_option</code></em>] ...
  | ADD FULLTEXT [INDEX|KEY] [<em class="replaceable"><code>index_name</code></em>]
        (<em class="replaceable"><code>index_col_name</code></em>,...) [<em class="replaceable"><code>index_option</code></em>] ...
  | ADD SPATIAL [INDEX|KEY] [<em class="replaceable"><code>index_name</code></em>]
        (<em class="replaceable"><code>index_col_name</code></em>,...) [<em class="replaceable"><code>index_option</code></em>] ...
  | ADD [CONSTRAINT [<em class="replaceable"><code>symbol</code></em>]]
        FOREIGN KEY [<em class="replaceable"><code>index_name</code></em>] (<em class="replaceable"><code>index_col_name</code></em>,...)
        <em class="replaceable"><code>reference_definition</code></em>
  | ALGORITHM [=] {DEFAULT|INPLACE|COPY}
  | ALTER [COLUMN] <em class="replaceable"><code>col_name</code></em> {SET DEFAULT <em class="replaceable"><code>literal</code></em> | DROP DEFAULT}
  | CHANGE [COLUMN] <em class="replaceable"><code>old_col_name</code></em> <em class="replaceable"><code>new_col_name</code></em> <em class="replaceable"><code>column_definition</code></em>
        [FIRST|AFTER <em class="replaceable"><code>col_name</code></em>]
  | LOCK [=] {DEFAULT|NONE|SHARED|EXCLUSIVE}
  | MODIFY [COLUMN] <em class="replaceable"><code>col_name</code></em> <em class="replaceable"><code>column_definition</code></em>
        [FIRST | AFTER <em class="replaceable"><code>col_name</code></em>]
  | DROP [COLUMN] <em class="replaceable"><code>col_name</code></em>
  | DROP PRIMARY KEY
  | DROP {INDEX|KEY} <em class="replaceable"><code>index_name</code></em>
  | DROP FOREIGN KEY <em class="replaceable"><code>fk_symbol</code></em>
  | DISABLE KEYS
  | ENABLE KEYS
  | RENAME [TO|AS] <em class="replaceable"><code>new_tbl_name</code></em>
  | ORDER BY <em class="replaceable"><code>col_name</code></em> [, <em class="replaceable"><code>col_name</code></em>] ...
  | CONVERT TO CHARACTER SET <em class="replaceable"><code>charset_name</code></em> [COLLATE <em class="replaceable"><code>collation_name</code></em>]
  | [DEFAULT] CHARACTER SET [=] <em class="replaceable"><code>charset_name</code></em> [COLLATE [=] <em class="replaceable"><code>collation_name</code></em>]
  | DISCARD TABLESPACE
  | IMPORT TABLESPACE
  | FORCE
  | ADD PARTITION (<em class="replaceable"><code>partition_definition</code></em>)
  | DROP PARTITION <em class="replaceable"><code>partition_names</code></em>
  | TRUNCATE PARTITION {<em class="replaceable"><code>partition_names</code></em> | ALL}
  | COALESCE PARTITION <em class="replaceable"><code>number</code></em>
  | REORGANIZE PARTITION <em class="replaceable"><code>partition_names</code></em> INTO (<em class="replaceable"><code>partition_definitions</code></em>)
  | EXCHANGE PARTITION <em class="replaceable"><code>partition_name</code></em> WITH TABLE <em class="replaceable"><code>tbl_name</code></em>
  | ANALYZE PARTITION {<em class="replaceable"><code>partition_names</code></em> | ALL}
  | CHECK PARTITION {<em class="replaceable"><code>partition_names</code></em> | ALL}
  | OPTIMIZE PARTITION {<em class="replaceable"><code>partition_names</code></em> | ALL}
  | REBUILD PARTITION {<em class="replaceable"><code>partition_names</code></em> | ALL}
  | REPAIR PARTITION {<em class="replaceable"><code>partition_names</code></em> | ALL}
  | REMOVE PARTITIONING

<em class="replaceable"><code>index_col_name</code></em>:
    <em class="replaceable"><code>col_name</code></em> [(<em class="replaceable"><code>length</code></em>)] [ASC | DESC]

<em class="replaceable"><code>index_type</code></em>:
    USING {BTREE | HASH}

<em class="replaceable"><code>index_option</code></em>:
    KEY_BLOCK_SIZE [=] <em class="replaceable"><code>value</code></em>
  | <em class="replaceable"><code>index_type</code></em>
  | WITH PARSER <em class="replaceable"><code>parser_name</code></em>
  | COMMENT '<em class="replaceable"><code>string</code></em>'

<em class="replaceable"><code>table_options</code></em>:
    <em class="replaceable"><code>table_option</code></em> [[,] <em class="replaceable"><code>table_option</code></em>] ...  (see <code class="literal">CREATE TABLE</code> options)

<em class="replaceable"><code>partition_options</code></em>:
    (see <code class="literal">CREATE TABLE</code> options)
</pre><p>
      <code class="literal">ALTER TABLE</code> は、テーブルの構造を変更します。たとえば、カラムを追加または削除したり、インデックスを作成または破棄したり、既存のカラムの型を変更したり、カラムまたはテーブル自体の名前を変更したりできます。また、テーブルに使用されているストレージエンジンやテーブルのコメントなどの特性を変更することもできます。
    </p><p>
      テーブル名のあとに、行う変更を指定します。何も指定されていない場合、<code class="literal">ALTER TABLE</code> は何もしません。
    </p><p>
      許可される多くの変更の構文は、<code class="literal">CREATE TABLE</code> ステートメントの各句に似ています。詳細は、<a class="xref" href="sql-syntax.html#create-table" title="13.1.17 CREATE TABLE 構文">セクション13.1.17「CREATE TABLE 構文」</a>を参照してください。
    </p><p>
      <em class="replaceable"><code>table_options</code></em> は、<code class="literal">ENGINE</code>、<code class="literal">AUTO_INCREMENT</code>、<code class="literal">AVG_ROW_LENGTH</code>、<code class="literal">MAX_ROWS</code>、<code class="literal">ROW_FORMAT</code> などの、<code class="literal">CREATE TABLE</code> ステートメントで使用できる種類のテーブルオプションを示します。すべてのテーブルオプションのリストと各オプションの説明については、<a class="xref" href="sql-syntax.html#create-table" title="13.1.17 CREATE TABLE 構文">セクション13.1.17「CREATE TABLE 構文」</a>を参照してください。ただし、<code class="literal">ALTER TABLE</code> は、<code class="literal">DATA DIRECTORY</code> および <code class="literal">INDEX DIRECTORY</code> テーブルオプションを無視します。
    </p><p>
      <em class="replaceable"><code>partition_options</code></em> は、再パーティション化、パーティションの追加、削除、マージ、および分割、パーティション化の保守の実行などのために、パーティション化されたテーブルで使用できるオプションを示します。<code class="literal">ALTER TABLE</code> ステートメントには、ほかの変更指定に加えて、<code class="literal">PARTITION BY</code> または <code class="literal">REMOVE PARTITIONING</code> 句を含めることができますが、<code class="literal">PARTITION BY</code> または <code class="literal">REMOVE PARTITIONING</code> 句は、ほかのどの指定よりもあとの最後に指定する必要があります。<code class="literal">ADD PARTITION</code>、<code class="literal">DROP PARTITION</code>、<code class="literal">COALESCE PARTITION</code>、<code class="literal">REORGANIZE PARTITION</code>、<code class="literal">EXCHANGE PARTITION</code>、<code class="literal">ANALYZE PARTITION</code>、<code class="literal">CHECK PARTITION</code>、および <code class="literal">REPAIR PARTITION</code> オプションは、個々のパーティションに対して機能するため、1 つの <code class="literal">ALTER TABLE</code> 内でほかの変更指定と組み合わせることはできません。パーティションのオプションの詳細は、<a class="xref" href="sql-syntax.html#create-table" title="13.1.17 CREATE TABLE 構文">セクション13.1.17「CREATE TABLE 構文」</a>および<a class="xref" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1 ALTER TABLE パーティション操作">セクション13.1.7.1「ALTER TABLE パーティション操作」</a>を参照してください。<code class="literal">ALTER TABLE ... EXCHANGE PARTITION</code> ステートメントの詳細および例については、<a class="xref" href="partitioning.html#partitioning-management-range-list" title="19.3.1 RANGE および LIST パーティションの管理">セクション19.3.1「RANGE および LIST パーティションの管理」</a>を参照してください。
    </p><p>
      操作によっては、ストレージエンジンがその操作をサポートしていないテーブルに対して試行されると、警告が生成される場合があります。これらの警告は、<code class="literal">SHOW WARNINGS</code> で表示できます。<a class="xref" href="sql-syntax.html#show-warnings" title="13.7.5.41 SHOW WARNINGS 構文">セクション13.7.5.41「SHOW WARNINGS 構文」</a>を参照してください。
    </p><p>
      <code class="literal">ALTER TABLE</code> のトラブルシューティングについては、<a class="xref" href="error-handling.html#alter-table-problems" title="B.5.7.1 ALTER TABLE での問題">セクションB.5.7.1「ALTER TABLE での問題」</a>を参照してください。
    </p><h4><a name="idm139979089816096"></a>ストレージ、パフォーマンス、および並列性に関する考慮事項</h4><p>
      ほとんどの場合、<code class="literal">ALTER TABLE</code> は元のテーブルの一時的なコピーを作成します。MySQL は、そのテーブルを変更しているほかの操作を待ってから、処理を続行します。そのコピーに変更を組み込み、元のテーブルを削除したあと、新しいテーブルの名前を変更します。<code class="literal">ALTER TABLE</code> の実行中、ほかのセッションは元のテーブルを読み取ることができます (例外については、すぐあとに説明します)。<code class="literal">ALTER TABLE</code> 操作の開始後に開始されたテーブルへの更新や書き込みは、新しいテーブルの準備ができるまで停止されてから、どの更新も失敗することなく、新しいテーブルに自動的にリダイレクトされます。元のテーブルの一時的なコピーは、新しいテーブルのデータベースディレクトリ内に作成されます。これは、テーブルの名前を別のデータベースに変更した <code class="literal">ALTER TABLE</code> 操作のための元のテーブルのデータベースディレクトリとは異なる場合があります。
    </p><p>
      前に触れた例外とは、<code class="literal">ALTER TABLE</code> が、テーブルの <code class="filename">.frm</code> ファイルの新しいバージョンをインストールし、古いファイルを破棄して、テーブルおよびテーブル定義キャッシュから古くなったテーブル構造をクリアする準備ができた時点で (書き込みだけでなく) 読み取りをブロックすることです。この時点で、このステートメントは排他的ロックを取得する必要があります。それを行うために、現在の読み取り側が完了するのを待って、新しい読み取り (および書き込み) をブロックします。
    </p><p>
      <code class="literal">MyISAM</code> テーブルの場合は、<code class="literal">myisam_sort_buffer_size</code> システム変数を大きな値に設定することによって、インデックスの再作成 (変更プロセスのもっとも遅い部分) を高速化できます。
    </p><p>
      一部の操作では、一時テーブルを必要としないインプレース <code class="literal">ALTER TABLE</code> が可能です。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> RENAME TO <em class="replaceable"><code>new_tbl_name</code></em></code> をほかのオプションなしで実行すると、MySQL は単純に、コピーを作成することなく、テーブル <em class="replaceable"><code>tbl_name</code></em> に対応するすべてのファイルの名前を変更します。(<code class="literal">RENAME TABLE</code> ステートメントを使用してテーブルの名前を変更することもできます。<a class="xref" href="sql-syntax.html#rename-table" title="13.1.32 RENAME TABLE 構文">セクション13.1.32「RENAME TABLE 構文」</a>を参照してください。)名前変更されたテーブル専用に付与された権限は、どれも新しい名前には移行されません。それらは、手動で変更する必要があります。
        </p></li><li class="listitem"><p>
          サーバーが変更する必要があるのはテーブルの内容ではなく、テーブルの <code class="filename">.frm</code> ファイルだけであるため、テーブルデータを変更せず、テーブルメタデータだけを変更する変更はただちに実行されます。次の変更は、この方法で実行できる迅速な変更です。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              カラムの名前変更。ただし、MySQL 5.6.6 より前の <code class="literal">InnoDB</code> ストレージエンジンを除きます。
            </p></li><li class="listitem"><p>
              カラムのデフォルト値の変更 (<code class="literal">NDB</code> テーブルを除きます。「<a class="link" href="sql-syntax.html#alter-table-online-limitations" title="MySQL Cluster オンライン操作の制限">MySQL Cluster オンライン操作の制限</a>」を参照してください)。
            </p></li><li class="listitem"><p>
              有効なメンバー値のリストの<span class="emphasis"><em>最後</em></span>に新しい列挙またはセットメンバーを追加することによる、<code class="literal">ENUM</code> または <code class="literal">SET</code> カラムの定義の変更。ただし、データ型のストレージサイズが変更される場合を除きます。たとえば、メンバー数が 8 の <code class="literal">SET</code> カラムにメンバーを追加すると、値ごとに必要なストレージが 1 バイトから 2 バイトに変更されます。これには、テーブルコピーが必要になります。リストの途中にメンバーを追加すると、既存のメンバーの番号が変更されます。これには、テーブルコピーが必要になります。
            </p></li></ul></div></li><li class="listitem"><p>
          <code class="literal">ADD PARTITION</code>、<code class="literal">DROP PARTITION</code>、<code class="literal">COALESCE PARTITION</code>、<code class="literal">REBUILD PARTITION</code>、または <code class="literal">REORGANIZE PARTITION</code> を含む <code class="literal">ALTER TABLE</code> は、一時テーブルを作成しません (<code class="literal">NDB</code> テーブルで使用される場合を除きます)。ただし、これらの操作では、一時的なパーティションファイルが作成されます。
        </p><p>
          <code class="literal">RANGE</code> または <code class="literal">LIST</code> パーティションに対する <code class="literal">ADD</code> または <code class="literal">DROP</code> 操作は即座の操作か、ほぼ即座の操作です。<code class="literal">HASH</code> または <code class="literal">KEY</code> パーティションに対する <code class="literal">ADD</code> または <code class="literal">COALESCE</code> 操作では、<code class="literal">LINEAR HASH</code> または <code class="literal">LINEAR KEY</code> が使用されていないかぎり、すべてのパーティション間でデータがコピーされます。<code class="literal">ADD</code> または <code class="literal">COALESCE</code> 操作はパーティションごとに実行されますが、これは実質的に、新しいテーブルの作成と同じです。<code class="literal">REORGANIZE</code> 操作では変更されたパーティションのみがコピーされ、変更されていないものはそのままです。
        </p></li><li class="listitem"><p>
          インデックスの名前変更。<code class="literal">InnoDB</code> を除きます。
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> と <code class="literal">NDB</code> に対するインデックスの追加または削除。
        </p></li></ul></div><p>
      <code class="literal">old_alter_table</code> システム変数を <code class="literal">ON</code> に設定するか、または <em class="replaceable"><code>alter_specification</code></em> 句の 1 つとして <code class="literal">ALGORITHM=COPY</code> を指定することによって、通常であればテーブルコピーを必要としない <code class="literal">ALTER TABLE</code> 操作で強制的に (MySQL 5.0 でサポートされている) 一時テーブルの方法を使用するようにできます。<code class="literal">old_alter_table</code> 設定と、<code class="literal">DEFAULT</code> 以外の値を持つ <code class="literal">ALGORITHM</code> 句の間に矛盾がある場合は、<code class="literal">ALGORITHM</code> 句が優先されます。(<code class="literal">ALGORITHM = DEFAULT</code> は、<code class="literal">ALGORITHM</code> 句をまったく指定しないのと同じです。)
    </p><p>
      <code class="literal">ALGORITHM=INPLACE</code> を指定すると、それをサポートする句やストレージエンジンに対してインプレースの手法が使用されるようになり、サポートされていない場合はエラーで失敗します。そのため、予測していたものとは異なるストレージエンジンを使用するテーブルを変更しようとした場合の非常に長いテーブルコピーが回避されます。<code class="literal">InnoDB</code> テーブルに対するオンライン DDL については、<a class="xref" href="innodb-storage-engine.html#innodb-online-ddl" title="14.11 InnoDB とオンライン DDL">セクション14.11「InnoDB とオンライン DDL」</a>を参照してください。
    </p><p>
      MySQL 5.6.16 では、<code class="literal">ALTER TABLE</code> は、<code class="literal">ADD COLUMN</code>、<code class="literal">CHANGE COLUMN</code>、<code class="literal">MODIFY COLUMN</code>、<code class="literal">ADD INDEX</code>、および <code class="literal">FORCE</code> 操作に関して、古い時間カラムを 5.6 形式にアップグレードします。テーブルを再構築しなければならないため、この変換は <code class="literal">INPLACE</code> アルゴリズムを使用して実行することはできません。そのため、これらの場合に <code class="literal">ALGORITHM=INPLACE</code> を指定するとエラーになります。必要であれば、<code class="literal">ALGORITHM=COPY</code> を指定します。
    </p><p>
      MySQL 5.6.22 から、テーブルを <code class="literal">KEY</code> によってパーティション化するために使用されるマルチカラムインデックスに対する <code class="literal">ALTER TABLE</code> 操作は、この操作によってカラムの順序が変更される場合はオンラインで実行できません。このような場合は、代わりに、コピーする <code class="literal">ALTER TABLE</code> を使用する必要があります。(Bug #17896265)
    </p><p>
      MySQL Cluster はオンライン <code class="literal">ALTER TABLE</code> 操作もサポートしていますが、<code class="literal">ALGORITHM=INPLACE</code> 構文を受け入れないため、代わりに <code class="literal">ONLINE</code> キーワードが使用されます。<code class="literal">ONLINE</code> および <code class="literal">OFFLINE</code> キーワードは、MySQL Cluster でのみサポートされます。これらのキーワードは、MySQL Cluster NDB 7.3 から非推奨です。MySQL Cluster NDB 7.4 では引き続きサポートされますが、将来のバージョンの MySQL Cluster で削除される可能性があります。正確な構文およびその他の詳細については、<a class="xref" href="sql-syntax.html#alter-table-online-operations" title="13.1.7.2 MySQL Cluster での ALTER TABLE オンライン操作">セクション13.1.7.2「MySQL Cluster での ALTER TABLE オンライン操作」</a>を参照してください。
    </p><p>
      <code class="literal">LOCK</code> 句を使用すると、変更中のテーブルの並列読み取りおよび書き込みのレベルを制御できます。この句にデフォルト以外の値を指定すると、変更操作中に特定の量の並列アクセスまたは排他性が要求されるようにすることが可能であり、要求されたレベルのロックを使用できない場合は操作が停止されます。<code class="literal">LOCK</code> 句のパラメータは次のとおりです。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
</p><pre class="programlisting">
LOCK = DEFAULT
</pre><p>

          指定された <code class="literal">ALGORITHM</code> 句 (存在する場合) および <code class="literal">ALTER TABLE</code> 操作に対する最大レベルの並列性: サポートされている場合は、並列読み取りおよび書き込みを許可します。そうでない場合、サポートされている場合は、並列読み取りを許可します。そうでない場合は、排他的アクセスを適用します。
        </p></li><li class="listitem"><p>
</p><pre class="programlisting">
LOCK = NONE
</pre><p>

          サポートされている場合は、並列読み取りおよび書き込みを許可します。そうでない場合は、エラーメッセージを返します。
        </p></li><li class="listitem"><p>
</p><pre class="programlisting">
LOCK = SHARED
</pre><p>

          サポートされている場合は、並列読み取りを許可しますが、書き込みはブロックします。書き込みは、指定された <code class="literal">ALGORITHM</code> 句 (存在する場合) および <code class="literal">ALTER TABLE</code> 操作に対して、並列書き込みがストレージエンジンによってサポートされている場合でもブロックされます。並列読み取りがサポートされていない場合は、エラーメッセージを返します。
        </p></li><li class="listitem"><p>
</p><pre class="programlisting">
LOCK = EXCLUSIVE
</pre><p>

          排他的アクセスを適用します。これは、指定された <code class="literal">ALGORITHM</code> 句 (存在する場合) および <code class="literal">ALTER TABLE</code> 操作に対して、並列読み取り/書き込みがストレージエンジンによってサポートされている場合でも実行されます。
        </p></li></ul></div><p>
      MySQL 5.6.3 の時点では、<code class="literal">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> FORCE</code> を使用して、テーブルを再構築する<span class="quote">「<span class="quote">null</span>」</span>変更操作を実行することもできます。以前は、<code class="literal">FORCE</code> オプションは認識されましたが、無視されました。MySQL 5.6.17 の時点では、<a class="link" href="glossary.html#glos_online_ddl" title="オンライン DDL">オンライン DDL</a> のサポートは <code class="literal">FORCE</code> オプションに対して提供されます。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-create-index-overview" title="14.11.1 オンライン DDL の概要">セクション14.11.1「オンライン DDL の概要」</a>を参照してください。
    </p><p>
      <code class="literal">NDB</code> テーブルの場合、可変幅カラム上のインデックスを追加および削除する操作は、そのほとんどの期間、テーブルコピーを行なったり、並列 DML アクションをブロックしたりすることなくオンラインで実行されます。<a class="xref" href="sql-syntax.html#alter-table-online-operations" title="13.1.7.2 MySQL Cluster での ALTER TABLE オンライン操作">セクション13.1.7.2「MySQL Cluster での ALTER TABLE オンライン操作」</a>を参照してください。
    </p><h4><a name="idm139979089708688"></a>使用上の注意</h4><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">ALTER TABLE</code> を使用するには、このテーブルに対する <code class="literal">ALTER</code>、<code class="literal">CREATE</code>、および <code class="literal">INSERT</code> 権限が必要です。テーブルを名前変更するには、古いテーブル側で <code class="literal">ALTER</code> および <code class="literal">DROP</code> と、新しいテーブル側で <code class="literal">ALTER</code>、<code class="literal">CREATE</code>、および <code class="literal">INSERT</code> 権限が必要です。
        </p></li><li class="listitem"><p>
          <code class="literal">IGNORE</code> は、標準 SQL への MySQL 拡張です。これは、新しいテーブル内の一意のキーに関して重複が存在する場合や、厳密モードが有効になっているときに警告が発生した場合の <code class="literal">ALTER TABLE</code> の動作を制御します。<code class="literal">IGNORE</code> が指定されていない場合は、重複キーエラーが発生すると、コピーは中止され、ロールバックされます。<code class="literal">IGNORE</code> が指定されている場合は、一意のキーが重複している行のうちの 1 行だけが使用されます。その他の競合している行は削除されます。正しくない値は、もっとも近い一致する許容可能な値に切り捨てられます。
        </p><p>
          MySQL 5.6.17 の時点では、<code class="literal">IGNORE</code> 句は非推奨であり、使用すると警告が生成されます。MySQL 5.7 では、<code class="literal">IGNORE</code> は削除されます。
        </p></li><li class="listitem"><p>
          テーブルが書き込みロックされているときに、そのテーブル構造を変更するために <code class="literal">ALTER TABLE</code> が使用されると、保留中の <code class="literal">INSERT DELAYED</code> ステートメントは失われます。
        </p></li><li class="listitem"><p>
          <em class="replaceable"><code>table_option</code></em> は、<code class="literal">ENGINE</code>、<code class="literal">AUTO_INCREMENT</code>、<code class="literal">AVG_ROW_LENGTH</code>、<code class="literal">MAX_ROWS</code>、<code class="literal">ROW_FORMAT</code> などの、<code class="literal">CREATE TABLE</code> ステートメントで使用できる種類のテーブルオプションを示します。すべてのテーブルオプションのリストと各オプションの説明については、<a class="xref" href="sql-syntax.html#create-table" title="13.1.17 CREATE TABLE 構文">セクション13.1.17「CREATE TABLE 構文」</a>を参照してください。ただし、<code class="literal">ALTER TABLE</code> は、<code class="literal">DATA DIRECTORY</code> および <code class="literal">INDEX DIRECTORY</code> テーブルオプションを無視します。
        </p><p>
          たとえば、テーブルを <code class="literal">InnoDB</code> テーブルになるように変換するには、次のステートメントを使用します。
        </p><pre class="programlisting">
ALTER TABLE t1 ENGINE = InnoDB;
</pre><p>
          テーブルを <code class="literal">InnoDB</code> ストレージエンジンに切り替えるときの考慮事項については、<a class="xref" href="innodb-storage-engine.html#converting-tables-to-innodb" title="14.6.4 MyISAM から InnoDB へのテーブルの変換">セクション14.6.4「MyISAM から InnoDB へのテーブルの変換」</a>を参照してください。
        </p><p>
          <code class="literal">ENGINE</code> 句を指定すると、<code class="literal">ALTER TABLE</code> はテーブルを再構築します。これは、そのテーブルに指定されたストレージエンジンがすでに存在する場合にも当てはまります。
        </p><p>
          既存の <code class="literal">InnoDB</code> テーブルに対して <code class="literal">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> ENGINE=INNODB</code> を実行すると、<span class="quote">「<span class="quote">null</span>」</span> <code class="literal">ALTER TABLE</code> 操作が実行されます。これは、<a class="xref" href="innodb-storage-engine.html#innodb-file-defragmenting" title="14.10.4 テーブルのデフラグ">セクション14.10.4「テーブルのデフラグ」</a>で説明されているように、<code class="literal">InnoDB</code> テーブルのデフラグに使用できます。<code class="literal">InnoDB</code> テーブルに対して <code class="literal">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> FORCE</code> を実行しても、同じ機能が実行されます。
        </p><p>
          MySQL 5.6.17 の時点では、<code class="literal">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> ENGINE=INNODB</code> と <code class="literal">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> FORCE</code> の両方が<a class="link" href="innodb-storage-engine.html#innodb-online-ddl" title="14.11 InnoDB とオンライン DDL">オンライン DDL</a> (<code class="literal">ALGORITHM=COPY</code>) を使用します。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-create-index-overview" title="14.11.1 オンライン DDL の概要">セクション14.11.1「オンライン DDL の概要」</a>を参照してください。
        </p><p>
          テーブルのストレージエンジンを変更しようとすると、<a class="xref" href="server-administration.html#sql-mode" title="5.1.7 サーバー SQL モード">セクション5.1.7「サーバー SQL モード」</a>で説明されているように、その結果は目的のストレージエンジンが使用可能かどうかや、<code class="literal">NO_ENGINE_SUBSTITUTION</code> SQL モードの設定によって影響を受けます。
        </p><p>
          データが誤って失われることのないように、<code class="literal">ALTER TABLE</code> を使用して、テーブルのストレージエンジンを <code class="literal">MERGE</code> または <code class="literal">BLACKHOLE</code> に変更することはできません。
        </p><p>
          新しい行に使用される <code class="literal">AUTO_INCREMENT</code> カウンタの値を変更するには、次のようにします。
        </p><pre class="programlisting">
ALTER TABLE t2 AUTO_INCREMENT = <em class="replaceable"><code>value</code></em>;
</pre><p>
          このカウンタを、現在使用されている値以下の値にリセットすることはできません。<code class="literal">InnoDB</code> と <code class="literal">MyISAM</code> のどちらの場合も、この値が現在 <code class="literal">AUTO_INCREMENT</code> カラム内にある最大値以下である場合、この値は現在の <code class="literal">AUTO_INCREMENT</code> カラムの最大値に 1 を加えた値にリセットされます。
        </p></li><li class="listitem"><p>
          1 つの <code class="literal">ALTER TABLE</code> ステートメントで、カンマで区切られた複数の <code class="literal">ADD</code>、<code class="literal">ALTER</code>、<code class="literal">DROP</code>、および <code class="literal">CHANGE</code> 句を発行できます。これは、<code class="literal">ALTER TABLE</code> ステートメントごとに各句が 1 つしか許可されない標準 SQL への MySQL 拡張です。たとえば、1 つのステートメントで複数のカラムを削除するには、次のようにします。
        </p><pre class="programlisting">
ALTER TABLE t2 DROP COLUMN c, DROP COLUMN d;
</pre></li><li class="listitem"><p>
          <code class="literal">CHANGE <em class="replaceable"><code>col_name</code></em></code>、<code class="literal">DROP <em class="replaceable"><code>col_name</code></em></code>、および <code class="literal">DROP INDEX</code> は、標準 SQL への MySQL 拡張です。
        </p></li><li class="listitem"><p>
          ワード <code class="literal">COLUMN</code> はオプションであり、省略できます。
        </p></li><li class="listitem"><p>
          <em class="replaceable"><code>column_definition</code></em> 句は、<code class="literal">ADD</code> と <code class="literal">CHANGE</code> に対して、<code class="literal">CREATE TABLE</code> に対するのと同じ構文を使用します。<a class="xref" href="sql-syntax.html#create-table" title="13.1.17 CREATE TABLE 構文">セクション13.1.17「CREATE TABLE 構文」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">CHANGE <em class="replaceable"><code>old_col_name</code></em> <em class="replaceable"><code>new_col_name</code></em> <em class="replaceable"><code>column_definition</code></em></code> 句を使用して、カラムの名前を変更できます。それを行うには、古いカラム名と新しいカラム名、およびそのカラムの現在の定義を指定します。たとえば、<code class="literal">INTEGER</code> カラムの名前を <code class="literal">a</code> から <code class="literal">b</code> に変更するには、次のように行うことができます。
        </p><pre class="programlisting">
ALTER TABLE t1 CHANGE a b INTEGER;
</pre><p>
          カラムの名前を変更せずに、その型を変更するには、古いカラム名と新しいカラム名が同じ場合でも、<code class="literal">CHANGE</code> 構文にはそれらの名前が引き続き必要です。例:
        </p><pre class="programlisting">
ALTER TABLE t1 CHANGE b b BIGINT NOT NULL;
</pre><p>
          <code class="literal">MODIFY</code> を使用しても、カラムの名前を変更せずに、その型を変更できます。
        </p><pre class="programlisting">
ALTER TABLE t1 MODIFY b BIGINT NOT NULL;
</pre><a class="indexterm" name="idm139979089616944"></a><a class="indexterm" name="idm139979089615456"></a><p>
          <code class="literal">MODIFY</code> は、Oracle の互換性のための <code class="literal">ALTER TABLE</code> への拡張です。
        </p><p>
          <code class="literal">CHANGE</code> または <code class="literal">MODIFY</code> を使用する場合は、<em class="replaceable"><code>column_definition</code></em> に、データ型および <code class="literal">PRIMARY KEY</code> や <code class="literal">UNIQUE</code> などのインデックス属性以外の、新しいカラムに適用されるすべての属性を含める必要があります。元の定義には存在するが、新しい定義として指定されていない属性は引き継がれません。カラム <code class="literal">col1</code> が <code class="literal">INT UNSIGNED DEFAULT 1 COMMENT 'my column'</code> として定義されているときに、このカラムを次のように変更するとします。
        </p><pre class="programlisting">
ALTER TABLE t1 MODIFY col1 BIGINT;
</pre><p>
          結果として得られるカラムは <code class="literal">BIGINT</code> として定義されますが、属性 <code class="literal">UNSIGNED DEFAULT 1 COMMENT 'my column'</code> は含まれません。これらを保持するには、ステートメントを次のようにしてください。
        </p><pre class="programlisting">
ALTER TABLE t1 MODIFY col1 BIGINT UNSIGNED DEFAULT 1 COMMENT 'my column';
</pre></li><li class="listitem"><p>
          <code class="literal">CHANGE</code> または <code class="literal">MODIFY</code> を使用してデータ型を変更すると、MySQL は、既存のカラム値を新しい型にできるだけ変換しようとします。
        </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
            この変換によって、データが変更される可能性があります。たとえば、文字列カラムを短くすると、値が切り捨てられる可能性があります。新しいデータ型への変換によってデータが失われる場合は操作が成功しないようにするには、<code class="literal">ALTER TABLE</code> を使用する前に厳密な SQL モードを有効にします (<a class="xref" href="server-administration.html#sql-mode" title="5.1.7 サーバー SQL モード">セクション5.1.7「サーバー SQL モード」</a>を参照してください)。
          </p></div></li><li class="listitem"><p>
          テーブル行内の特定の位置にカラムを追加するには、<code class="literal">FIRST</code> または <code class="literal">AFTER <em class="replaceable"><code>col_name</code></em></code> を使用します。デフォルトでは、そのカラムを最後に追加します。また、<code class="literal">CHANGE</code> または <code class="literal">MODIFY</code> 操作で <code class="literal">FIRST</code> と <code class="literal">AFTER</code> を使用して、テーブル内のカラムを並べ替えることもできます。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979089589312"></a> <a class="indexterm" name="idm139979089587968"></a> <a class="indexterm" name="idm139979089585824"></a> <a class="indexterm" name="idm139979089583792"></a> <a class="indexterm" name="idm139979089581760"></a> <code class="literal">ALTER ... SET DEFAULT</code> または <code class="literal">ALTER ... DROP DEFAULT</code> は、それぞれ、カラムの新しいデフォルト値を指定するか、または古いデフォルト値を削除します。古いデフォルトが削除され、かつカラムを <code class="literal">NULL</code> にできる場合、新しいデフォルトは <code class="literal">NULL</code> です。カラムを <code class="literal">NULL</code> にできない場合、MySQL は、<a class="xref" href="data-types.html#data-type-defaults" title="11.6 データ型デフォルト値">セクション11.6「データ型デフォルト値」</a>で説明されているようにデフォルト値を割り当てます。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979089574160"></a> <a class="indexterm" name="idm139979089572848"></a> <a class="indexterm" name="idm139979089570704"></a> <code class="literal">DROP INDEX</code> は、インデックスを削除します。これは、標準 SQL への MySQL 拡張です。<a class="xref" href="sql-syntax.html#drop-index" title="13.1.24 DROP INDEX 構文">セクション13.1.24「DROP INDEX 構文」</a>を参照してください。インデックス名に確信がない場合は、<code class="literal">SHOW INDEX FROM <em class="replaceable"><code>tbl_name</code></em></code> を使用します。
        </p></li><li class="listitem"><p>
          テーブルからカラムが削除された場合、そのカラムは、それが含まれているすべてのインデックスからも削除されます。インデックスを構成するすべてのカラムが削除された場合は、そのインデックスも削除されます。<code class="literal">CHANGE</code> または <code class="literal">MODIFY</code> を使用して、インデックスが存在するカラムを短くしたときに、結果として得られるカラムの長さがインデックスの長さより短くなった場合、MySQL は自動的にそのインデックスを短くします。
        </p></li><li class="listitem"><p>
          テーブルに 1 つのカラムしか含まれていない場合は、そのカラムを削除できません。テーブルを削除することが目的である場合は、代わりに <code class="literal">DROP TABLE</code> を使用します。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979089559360"></a> <a class="indexterm" name="idm139979089558016"></a> <a class="indexterm" name="idm139979089555872"></a> <code class="literal">DROP PRIMARY KEY</code> は、<a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a>を削除します。主キーが存在しない場合は、エラーが発生します。主キーのパフォーマンス特性 (特に <code class="literal">InnoDB</code> テーブルの場合) については、<a class="xref" href="optimization.html#optimizing-primary-keys" title="8.3.2 主キーの使用">セクション8.3.2「主キーの使用」</a>を参照してください。
        </p><a class="indexterm" name="idm139979089550512"></a><a class="indexterm" name="idm139979089549200"></a><p>
          テーブルに <code class="literal">UNIQUE INDEX</code> または <code class="literal">PRIMARY KEY</code> を追加すると、重複キーをできるだけ早く検出できるようにするために、MySQL はそれを一意でないどのインデックスよりも前に格納します。
        </p></li><li class="listitem"><p>
          一部のストレージエンジンでは、インデックスの作成時にインデックスタイプを指定できます。<em class="replaceable"><code>index_type</code></em> 指定子の構文は、<code class="literal">USING <em class="replaceable"><code>type_name</code></em></code> です。<code class="literal">USING</code> の詳細は、<a class="xref" href="sql-syntax.html#create-index" title="13.1.13 CREATE INDEX 構文">セクション13.1.13「CREATE INDEX 構文」</a>を参照してください。推奨される位置は、カラムリストのあとです。このオプションをカラムリストの前に使用するためのサポートは、将来の MySQL リリースで削除される予定です。
        </p><p>
          <em class="replaceable"><code>index_option</code></em> 値は、インデックスの追加オプションを指定します。<code class="literal">USING</code> はそのようなオプションの 1 つです。許可される <em class="replaceable"><code>index_option</code></em> 値の詳細は、<a class="xref" href="sql-syntax.html#create-index" title="13.1.13 CREATE INDEX 構文">セクション13.1.13「CREATE INDEX 構文」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">ALTER TABLE</code> ステートメントのあとに、インデックスカーディナリティー情報を更新するために <code class="literal">ANALYZE TABLE</code> の実行が必要になることがあります。<a class="xref" href="sql-syntax.html#show-index" title="13.7.5.23 SHOW INDEX 構文">セクション13.7.5.23「SHOW INDEX 構文」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979089534000"></a> <code class="literal">ORDER BY</code> を使用すると、特定の順序で行が含まれる新しいテーブルを作成できます。このオプションは主に、ほとんどは特定の順序で行をクエリーすることがわかっている場合に役立ちます。このオプションをテーブルの大幅な変更のあとに使用すると、パフォーマンスの向上が得られる可能性があります。場合によっては、テーブルが、あとでその並べ替えに使用するカラムごとの順番になっていれば、MySQL でのソートが簡単になることがあります。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            挿入や削除を行うと、このテーブルは指定された順序のままではなくなります。
          </p></div><p>
          <code class="literal">ORDER BY</code> 構文では、ソートのためのカラム名を 1 つ以上指定できます。その各カラム名に続けて、オプションで、それぞれ昇順または降順のソート順序を示す <code class="literal">ASC</code> または <code class="literal">DESC</code> を指定できます。デフォルトは昇順です。ソート条件として許可されるのはカラム名だけです。任意の式は許可されていません。この句は、ほかのどの句よりもあとの最後に指定するようにしてください。
        </p><p>
          <code class="literal">InnoDB</code> は常に、<a class="link" href="glossary.html#glos_clustered_index" title="クラスタ化されたインデックス">クラスタ化されたインデックス</a>に従ってテーブル行を並べ替えるため、<code class="literal">ORDER BY</code> は <code class="literal">InnoDB</code> テーブルでは意味がありません。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            パーティション化されたテーブルに対して使用されている場合、<code class="literal">ALTER TABLE ... ORDER BY</code> は、各パーティション内でのみ行を並べ替えます。
          </p></div></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979089519888"></a> <a class="indexterm" name="idm139979089518544"></a> <a class="indexterm" name="idm139979089516400"></a> <code class="literal">MyISAM</code> テーブルに対して <code class="literal">ALTER TABLE</code> を使用した場合、一意でないインデックスはすべて (<code class="literal">REPAIR TABLE</code> として) 別のバッチに作成されます。多くのインデックスがあるときは、この方法で <code class="literal">ALTER TABLE</code> がはるかに早くなります。
        </p><p>
          <code class="literal">MyISAM</code> テーブルの場合は、キーの更新を明示的に制御できます。<code class="literal">ALTER TABLE ... DISABLE KEYS</code> を使用して、一意でないインデックスの更新を停止するよう MySQL に指示します。次に、<code class="literal">ALTER TABLE ... ENABLE KEYS</code> を使用して、不足しているインデックスを再作成します。<code class="literal">MyISAM</code> はこれを、キーを 1 つずつ挿入するのに比べてはるかに高速な特殊なアルゴリズムで実行するため、一括挿入操作を実行する前にキーを無効にすると大幅な高速化が得られます。<code class="literal">ALTER TABLE ... DISABLE KEYS</code> を使用するには、先に説明した権限に加えて <code class="literal">INDEX</code> 権限が必要です。
        </p><p>
          一意でないインデックスは、無効になっている間、有効なときにはこのインデックスを使用する <code class="literal">SELECT</code> や <code class="literal">EXPLAIN</code> などのステートメントで無視されます。
        </p></li><li class="listitem"><p>
          MySQL 5.6.7 より前は、<code class="literal">ALTER TABLE</code> を使用して外部キーカラムの定義を変更すると、参照整合性が失われる可能性がありました。たとえば、<code class="literal">NULL</code> 値を含む外部キーカラムを <code class="literal">NOT NULL</code> になるように変更すると、<code class="literal">NULL</code> 値が空の文字列になりました。同様に、親テーブル内の行を削除する <code class="literal">ALTER TABLE IGNORE</code> によって、参照整合性が破壊される可能性がありました。
        </p><p>
          5.6.7 の時点では、参照整合性が失われる可能性のある外部キーカラムへの変更がサーバーによって禁止されます。また、安全でない可能性のある、このようなカラムのデータ型への変更も禁止されます。たとえば、<code class="literal">VARCHAR(20)</code> の <code class="literal">VARCHAR(30)</code> への変更は許可されますが、それを <code class="literal">VARCHAR(1024)</code> に変更することは、それによって個々の値を格納するために必要なバイト長の数が変更されるため許可されません。回避方法として、カラム定義を変更する前に <code class="literal">ALTER TABLE ... DROP FOREIGN KEY</code> を使用し、あとで <code class="literal">ALTER TABLE ... ADD FOREIGN KEY</code> を使用します。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979089487504"></a> <a class="indexterm" name="idm139979089486048"></a> <code class="literal">FOREIGN KEY</code> および <code class="literal">REFERENCES</code> 句は、<code class="literal">ADD [CONSTRAINT [<em class="replaceable"><code>symbol</code></em>]] FOREIGN KEY [<em class="replaceable"><code>index_name</code></em>] (...) REFERENCES ... (...)</code> を実装している <code class="literal">InnoDB</code> および <code class="literal">NDB</code> ストレージエンジンによってサポートされます。<a class="xref" href="innodb-storage-engine.html#innodb-foreign-key-constraints" title="14.6.6 InnoDB と FOREIGN KEY 制約">セクション14.6.6「InnoDB と FOREIGN KEY 制約」</a>を参照してください。その他のストレージエンジンでは、これらの句は解析されますが、無視されます。<code class="literal">CHECK</code> 句は、すべてのストレージエンジンによって解析されますが、無視されます。<a class="xref" href="sql-syntax.html#create-table" title="13.1.17 CREATE TABLE 構文">セクション13.1.17「CREATE TABLE 構文」</a>を参照してください。構文の句を受け入れるが、無視する理由は互換性のためです。つまり、ほかの SQL サーバーからコードを移植し、参照によってテーブルを作成するアプリケーションを実行することを容易にするためです。<a class="xref" href="introduction.html#differences-from-ansi" title="1.8.2 MySQL と標準 SQL との違い">セクション1.8.2「MySQL と標準 SQL との違い」</a>を参照してください。
        </p><p>
          <code class="literal">ALTER TABLE</code> では、<code class="literal">CREATE TABLE</code> とは異なり、<code class="literal">ADD FOREIGN KEY</code> は <em class="replaceable"><code>index_name</code></em> (指定されている場合) を無視し、自動的に生成された外部キー名を使用します。回避方法として、外部キー名を指定する <code class="literal">CONSTRAINT</code> 句を含めます。
        </p><pre class="programlisting">
ADD CONSTRAINT <em class="replaceable"><code>name</code></em> FOREIGN KEY (....) ...
</pre><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
            参照がカラム指定の一部として定義されているインラインの <code class="literal">REFERENCES</code> 指定は、暗黙のうちに無視されます。MySQL は、個別の <code class="literal">FOREIGN KEY</code> 指定の一部として定義されている <code class="literal">REFERENCES</code> 句のみを受け入れます。
          </p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            パーティション化された <code class="literal">InnoDB</code> テーブルは、外部キーをサポートしていません。この制限は、<code class="literal">NDB</code> テーブル (<code class="literal">[LINEAR] KEY</code> によって明示的にパーティション化されたテーブルを含む) には適用されません。詳細は、<a class="xref" href="partitioning.html#partitioning-limitations-storage-engines" title="19.6.2 ストレージエンジンに関連するパーティショニング制限">セクション19.6.2「ストレージエンジンに関連するパーティショニング制限」</a>を参照してください。
          </p></div></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979089462032"></a> <a class="indexterm" name="idm139979089460688"></a> <a class="indexterm" name="idm139979089458544"></a> <code class="literal">InnoDB</code> および <code class="literal">NDB</code> ストレージエンジンは、外部キーを削除するための <code class="literal">ALTER TABLE</code> の使用をサポートします。
        </p><pre class="programlisting">
ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> DROP FOREIGN KEY <em class="replaceable"><code>fk_symbol</code></em>;
</pre><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-foreign-key-constraints" title="14.6.6 InnoDB と FOREIGN KEY 制約">セクション14.6.6「InnoDB と FOREIGN KEY 制約」</a>を参照してください。
        </p></li><li class="listitem"><p>
          MySQL 5.6.6 より前は、同じ <code class="literal">ALTER TABLE</code> ステートメントでの外部キーの追加と削除は、問題が発生する場合があるためサポートされていません。操作ごとに個別のステートメントを使用するようにしてください。MySQL 5.6.6 の時点では、同じ <code class="literal">ALTER TABLE</code> ステートメントでの外部キーの追加と削除は <code class="literal">ALTER TABLE ... ALGORITHM=INPLACE</code> ではサポートされますが、<code class="literal">ALTER TABLE ... ALGORITHM=COPY</code> では未サポートのままです。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979089443840"></a> <a class="indexterm" name="idm139979089442496"></a> <code class="filename">.ibd</code> ファイル内の独自のテーブルスペースで作成された <code class="literal">InnoDB</code> テーブルの場合は、そのファイルを破棄したり、インポートしたりできます。<code class="filename">.ibd</code> ファイルを破棄するには、次のステートメントを使用します。
        </p><pre class="programlisting">
ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> DISCARD TABLESPACE;
</pre><p>
          これにより、現在の <code class="filename">.ibd</code> ファイルが削除されるため、最初にバックアップがあることを確認してください。テーブルスペースファイルが破棄されている間にテーブルの内容を変更しようとすると、エラーが発生します。テーブルスペースファイルが破棄されている間に、<a class="xref" href="innodb-storage-engine.html#innodb-online-ddl" title="14.11 InnoDB とオンライン DDL">セクション14.11「InnoDB とオンライン DDL」</a>に示されている DDL 操作を実行できます。
        </p><p>
          バックアップ <code class="filename">.ibd</code> ファイルを元のテーブルにインポートするには、それをデータベースディレクトリにコピーしてから、次のステートメントを発行します。
        </p><pre class="programlisting">
ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> IMPORT TABLESPACE;
</pre><p>
          テーブルスペースファイルは、必ずしも、あとでインポートされるサーバー上に作成されている必要はありません。MySQL 5.6 では、テーブルスペースファイルの別のサーバーからのインポートが機能するのは、両方のサーバーのステータスが GA (General Availablility) であり、かつそれらのバージョンが同じシリーズ内にある場合です。そうでない場合、そのファイルはインポートされるサーバー上に作成されている必要があります。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            <code class="literal">ALTER TABLE ... IMPORT TABLESPACE</code> 機能は、インポートされたデータに対して外部キー制約を課しません。
          </p></div><p>
          <a class="xref" href="innodb-storage-engine.html#innodb-multiple-tablespaces" title="14.5.2 InnoDB File-Per-Table モード">セクション14.5.2「InnoDB File-Per-Table モード」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979089426880"></a> テーブルのデフォルトの文字セットおよびすべての文字カラム (<code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、<code class="literal">TEXT</code>) を新しい文字セットに変更するには、次のようなステートメントを使用します。
        </p><pre class="programlisting">
ALTER TABLE <em class="replaceable"><code>tbl_name</code></em>
CONVERT TO CHARACTER SET <em class="replaceable"><code>charset_name</code></em> [COLLATE <em class="replaceable"><code>collation_name</code></em>];
</pre><p>
          このステートメントでは、すべての文字カラムの照合順序も変更されます。使用する照合順序を示す <code class="literal">COLLATE</code> 句を指定しない場合、このステートメントは、その文字セットのデフォルトの照合順序を使用します。この照合順序が目的とするテーブル使用に適していない (たとえば、大文字と小文字が区別される照合順序から大文字と小文字が区別されない照合順序に変更されてしまう) 場合は、照合順序を明示的に指定します。
        </p><p>
          データ型が <code class="literal">VARCHAR</code> か、またはいずれかの <code class="literal">TEXT</code> 型であるカラムに対して、<code class="literal">CONVERT TO CHARACTER SET</code> は、新しいカラムが確実に元のカラムと同じ数の文字を格納できる十分な長さになるように、必要に応じてデータ型を変更します。たとえば、<code class="literal">TEXT</code> カラムには、そのカラム内の値のバイト長 (最大 65,535) を格納するための 2 バイト長があります。<code class="literal">latin1</code> <code class="literal">TEXT</code> カラムの場合は、各文字に 1 バイトが必要なため、このカラムには最大 65,535 文字を格納できます。このカラムが <code class="literal">utf8</code> に変換された場合は、各文字に最大 3 バイトが必要になる可能性があるため、可能性のある最大の長さは 3 × 65,535 = 196,605 バイトになります。その長さは <code class="literal">TEXT</code> カラムのバイト長には収まらないため、MySQL はそのデータ型を、バイト長に 196,605 の値を記録できる最小の文字列型である <code class="literal">MEDIUMTEXT</code> に変換します。同様に、<code class="literal">VARCHAR</code> カラムは <code class="literal">MEDIUMTEXT</code> に変換される可能性があります。
        </p><p>
          今説明した型のデータ型の変更を回避するには、<code class="literal">CONVERT TO CHARACTER SET</code> を使用しないでください。代わりに、<code class="literal">MODIFY</code> を使用して個々のカラムを変更します。例:
        </p><pre class="programlisting">
ALTER TABLE t MODIFY latin1_text_col TEXT CHARACTER SET utf8;
ALTER TABLE t MODIFY latin1_varchar_col VARCHAR(<em class="replaceable"><code>M</code></em>) CHARACTER SET utf8;
</pre><p>
          <code class="literal">CONVERT TO CHARACTER SET binary</code> を指定した場合、<code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、および <code class="literal">TEXT</code> カラムは、それぞれ対応するバイナリ文字列型 (<code class="literal">BINARY</code>、<code class="literal">VARBINARY</code>、<code class="literal">BLOB</code>) に変換されます。つまり、これらのカラムには文字セットが含まれなくなるため、以降の <code class="literal">CONVERT TO</code> 操作は適用されません。
        </p><p>
          <em class="replaceable"><code>charset_name</code></em> が <code class="literal">DEFAULT</code> である場合は、データベース文字セットが使用されます。
        </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
            <code class="literal">CONVERT TO</code> 操作は、文字セット間でカラム値を変換します。これは、ある文字セット (<code class="literal">latin1</code> など) のカラムがあるが、格納された値が実際には、ほかの何らかの互換性のない文字セット (<code class="literal">utf8</code> など) を使用している場合に必要なもの<span class="emphasis"><em>ではありません</em></span>。この場合は、このようなカラムごとに、次を実行する必要があります。
          </p><pre class="programlisting">
ALTER TABLE t1 CHANGE c1 c1 BLOB;
ALTER TABLE t1 CHANGE c1 c1 TEXT CHARACTER SET utf8;
</pre><p>
            これが機能する理由は、<code class="literal">BLOB</code> カラムとの間で変換する場合は変換が発生しないためです。
          </p></div><p>
          テーブルの<span class="emphasis"><em>デフォルトの</em></span>文字セットのみを変更するには、次のステートメントを使用します。
        </p><pre class="programlisting">
ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> DEFAULT CHARACTER SET <em class="replaceable"><code>charset_name</code></em>;
</pre><p>
          ワード <code class="literal">DEFAULT</code> はオプションです。デフォルトの文字セットは、あとで (たとえば、<code class="literal">ALTER TABLE ... ADD column</code> で) テーブルに追加するカラムの文字セットを指定しない場合に使用される文字セットです。
        </p></li></ul></div><a class="indexterm" name="idm139979089380592"></a><p>
      <code class="literal">mysql_info()</code> C API 関数を使用すると、<code class="literal">ALTER TABLE</code> によってコピーされた行数、および (<code class="literal">IGNORE</code> が使用されている場合は) 一意のキー値の重複のために削除された行数を確認できます。<a class="xref" href="connectors-apis.html#mysql-info" title="23.8.7.35 mysql_info()">セクション23.8.7.35「mysql_info()」</a>を参照してください。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="alter-table-partition-operations"></a>13.1.7.1 ALTER TABLE パーティション操作</h4></div></div></div><p>
        <code class="literal">ALTER TABLE</code> のパーティション化関連の句は、再パーティション化、パーティションの追加、削除、マージ、および分割、パーティション化の保守の実行などのために、パーティション化されたテーブルで使用できます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            単に、パーティション化されたテーブルに対して <code class="literal">ALTER TABLE</code> で <em class="replaceable"><code>partition_options</code></em> 句を使用するだけで、<em class="replaceable"><code>partition_options</code></em> で定義されたパーティション化スキームに従って、そのテーブルが再パーティション化されます。この句は、常に <code class="literal">PARTITION BY</code> で始まり、<code class="literal">CREATE TABLE</code> の <em class="replaceable"><code>partition_options</code></em> 句に適用されるのと同じ構文およびその他のルールに従います (詳細は、<a class="xref" href="sql-syntax.html#create-table" title="13.1.17 CREATE TABLE 構文">セクション13.1.17「CREATE TABLE 構文」</a>を参照してください)。また、まだパーティション化されていない既存のテーブルのパーティション化にも使用できます。たとえば、次に示すように定義された (パーティション化されていない) テーブルを考えてみます。
          </p><pre class="programlisting">
CREATE TABLE t1 (
    id INT,
    year_col INT
);
</pre><p>
            このテーブルは、次のステートメントを使用し、<code class="literal">id</code> カラムをパーティション化キーとして使用して <code class="literal">HASH</code> によって 8 つのパーティションにパーティション化できます。
          </p><pre class="programlisting">
ALTER TABLE t1
    PARTITION BY HASH(id)
    PARTITIONS 8;
</pre><p>
            MySQL 5.6.11 以降では、<code class="literal">[SUB]PARTITION BY [LINEAR] KEY</code> で <code class="literal">ALGORITHM</code> オプションがサポートされます。<code class="literal">ALGORITHM=1</code> を指定すると、サーバーは、パーティション内の行の配置を計算するときに MySQL 5.1 と同じキーハッシュ関数を使用します。<code class="literal">ALGORITHM=2</code> は、サーバーが、MySQL 5.5 以降で実装され、<code class="literal">KEY</code> によってパーティション化された新しいテーブルに対してデフォルトで使用されるキーハッシュ関数を使用することを示します。(MySQL 5.5 以降で採用されたキーハッシュ関数によって作成されたパーティション化されたテーブルを MySQL 5.1 サーバーで使用することはできません。)このオプションを指定しない場合は、<code class="literal">ALGORITHM=2</code> を使用するのと同じ効果があります。このオプションは、主に <code class="literal">[LINEAR] KEY</code> によってパーティション化されたテーブルを MySQL 5.1 以降の MySQL バージョン間でアップグレードまたはダウングレードするときに使用するか、または MySQL 5.5 以降のサーバー上で、MySQL 5.1 サーバー上で使用できる <code class="literal">KEY</code> または <code class="literal">LINEAR KEY</code> によってパーティション化されたテーブルを作成することを目的にしています。
          </p><p>
            MySQL 5.1 で作成された、<code class="literal">KEY</code> によってパーティション化されたテーブルをアップグレードするには、最初に <code class="literal">SHOW CREATE TABLE</code> を実行し、表示される正確なカラムおよびパーティションの数をメモします。次に、<code class="literal">CREATE TABLE</code> ステートメントとまったく同じカラムリストおよびパーティションの数を使用して <code class="literal">ALTER TABLE</code> ステートメントを実行しますが、そのとき <code class="literal">PARTITION BY</code> キーワードの直後に <code class="literal">ALGORITHM=2</code> を追加します。(元のテーブル定義に <code class="literal">LINEAR</code> キーワードが使用されていた場合は、そのキーワードも含めるようにしてください。)<span class="command"><strong>mysql</strong></span> クライアントでのセッションの例を次に示します。
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE p\G</code></strong>
*************************** 1. row ***************************
       Table: p
Create Table: CREATE TABLE `p` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `cd` datetime NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1
/*!50100 <span class="emphasis"><em>PARTITION BY LINEAR KEY (id)
PARTITIONS 32</em></span> */
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE p</code></strong> <span class="emphasis"><em>PARTITION BY LINEAR KEY ALGORITHM=2 (id) PARTITIONS 32</em></span><strong class="userinput"><code>;</code></strong>
Query OK, 0 rows affected (5.34 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE p\G</code></strong>
*************************** 1. row ***************************
       Table: p
Create Table: CREATE TABLE `p` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `cd` datetime NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1
/*!50100 PARTITION BY LINEAR KEY (id)
PARTITIONS 32 */
1 row in set (0.00 sec)
</pre><p>
            MySQL 5.5 以降で使用されているデフォルトのキーハッシュを使用して作成されたテーブルを、MySQL 5.1 サーバーで使用できるようにダウングレードする場合も同様です。ただし、この場合は、そのテーブルのパーティションが強制的に MySQL 5.1 のキーハッシュ関数を使用して再構築されるように、<code class="literal">ALGORITHM=1</code> を使用するようにしてください。MySQL 5.5 以降ではデフォルトで使用される改善された <code class="literal">KEY</code> ハッシュ関数により、古い実装で見つかった多くの問題に対する修正が提供されるため、MySQL 5.1 サーバーとの互換性のために必要な場合を除き、これは行わないようにすることをお勧めします。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              <code class="literal">ALTER TABLE ... PARTITION BY ALGORITHM=2 [LINEAR] KEY ...</code> を使用してアップグレードされたテーブルは、MySQL 5.1 サーバーでは使用できなくなります。(このようなテーブルを MySQL 5.1 サーバーでふたたび使用できるようにするには、<code class="literal">ALTER TABLE ... PARTITION BY ALGORITHM=1 [LINEAR] KEY ...</code> を使用してダウングレードする必要があります。)
            </p></div><p>
            <code class="literal">ALTER TABLE ... PARTITION BY</code> ステートメントを使用して作成されたテーブルは、<code class="literal">CREATE TABLE ... PARTITION BY</code> を使用して作成されたテーブルと同じルールに従う必要があります。これには、そのテーブルに含まれている可能性のあるすべての一意のキー (すべての主キーを含む) と、パーティショニング式で使用されている 1 つまたは複数のカラムの間の関係を管理するルールが含まれます。これについては、<a class="xref" href="partitioning.html#partitioning-limitations-partitioning-keys-unique-keys" title="19.6.1 パーティショニングキー、主キー、および一意キー">セクション19.6.1「パーティショニングキー、主キー、および一意キー」</a>で説明されています。また、パーティションの数を指定するための <code class="literal">CREATE TABLE ... PARTITION BY</code> のルールも <code class="literal">ALTER TABLE ... PARTITION BY</code> に適用されます。
          </p><p>
            <code class="literal">ALTER TABLE ADD PARTITION</code> の <em class="replaceable"><code>partition_definition</code></em> 句は、<code class="literal">CREATE TABLE</code> ステートメントの同じ名前の句と同じオプションをサポートしています。(構文と説明については、<a class="xref" href="sql-syntax.html#create-table" title="13.1.17 CREATE TABLE 構文">セクション13.1.17「CREATE TABLE 構文」</a>を参照してください。)次に示すように作成されたパーティション化されたテーブルがあるとします。
          </p><pre class="programlisting">
CREATE TABLE t1 (
    id INT,
    year_col INT
)
PARTITION BY RANGE (year_col) (
    PARTITION p0 VALUES LESS THAN (1991),
    PARTITION p1 VALUES LESS THAN (1995),
    PARTITION p2 VALUES LESS THAN (1999)
);
</pre><p>
            このテーブルに、<code class="literal">2002</code> より小さい値を格納するための新しいパーティション <code class="literal">p3</code> を次のように追加できます。
          </p><pre class="programlisting">
ALTER TABLE t1 ADD PARTITION (PARTITION p3 VALUES LESS THAN (2002));
</pre><p>
            <code class="literal">DROP PARTITION</code> を使用すると、1 つ以上の <code class="literal">RANGE</code> または <code class="literal">LIST</code> パーティションを削除できます。このステートメントを <code class="literal">HASH</code> または <code class="literal">KEY</code> パーティションに使用することはできません。代わりに <code class="literal">COALESCE PARTITION</code> を使用します (下を参照してください)。<em class="replaceable"><code>partition_names</code></em> リストで名前が指定されている削除されたパーティションに格納されていたデータはすべて破棄されます。たとえば、前に定義されたテーブル <code class="literal">t1</code> の場合は、<code class="literal">p0</code> および <code class="literal">p1</code> という名前のパーティションを次に示すように削除できます。
          </p><pre class="programlisting">
ALTER TABLE t1 DROP PARTITION p0, p1;
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              <code class="literal">DROP PARTITION</code> は、<code class="literal">NDB</code> ストレージエンジンを使用するテーブルでは機能しません。<a class="xref" href="partitioning.html#partitioning-management-range-list" title="19.3.1 RANGE および LIST パーティションの管理">セクション19.3.1「RANGE および LIST パーティションの管理」</a>および<a class="xref" href="mysql-cluster.html#mysql-cluster-limitations" title="18.1.6 MySQL Cluster の既知の制限">セクション18.1.6「MySQL Cluster の既知の制限」</a>を参照してください。
            </p></div><p>
            <code class="literal">ADD PARTITION</code> と <code class="literal">DROP PARTITION</code> は現在、<code class="literal">IF [NOT] EXISTS</code> をサポートしていません。
          </p><p>
            パーティション化されたテーブルの名前変更がサポートされています。<code class="literal">ALTER TABLE ... REORGANIZE PARTITION</code> を使用して、間接的に個々のパーティションの名前を変更できます。ただし、この操作によってパーティションのデータのコピーが作成されます。
          </p><p>
            MySQL 5.6 では、<code class="literal">TRUNCATE PARTITION</code> オプションを使用して、選択したパーティションの行を削除できます。このオプションは、1 つ以上のパーティション名のカンマ区切りリストを受け取ります。たとえば、次のように定義されたテーブル <code class="literal">t1</code> を考えてみます。
          </p><pre class="programlisting">
CREATE TABLE t1 (
    id INT,
    year_col INT
)
PARTITION BY RANGE (year_col) (
    PARTITION p0 VALUES LESS THAN (1991),
    PARTITION p1 VALUES LESS THAN (1995),
    PARTITION p2 VALUES LESS THAN (1999),
    PARTITION p3 VALUES LESS THAN (2003),
    PARTITION p4 VALUES LESS THAN (2007)
);
</pre><p>
            パーティション <code class="literal">p0</code> のすべての行を削除するには、次のステートメントを使用できます。
          </p><pre class="programlisting">
ALTER TABLE t1 TRUNCATE PARTITION p0;
</pre><p>
            今示したステートメントには、次の <code class="literal">DELETE</code> ステートメントと同じ効果があります。
          </p><pre class="programlisting">
DELETE FROM t1 WHERE year_col &lt; 1991;
</pre><p>
            複数のパーティションを切り詰める場合、パーティションが連続している必要はありません。これにより、通常、<code class="literal">DELETE</code> ステートメントで実行された場合は非常に複雑な <code class="literal">WHERE</code> 条件が必要になる、パーティション化されたテーブルでの削除操作が大幅に簡素化される可能性があります。たとえば、次のステートメントは、パーティション <code class="literal">p1</code> と <code class="literal">p3</code> のすべての行を削除します。
          </p><pre class="programlisting">
ALTER TABLE t1 TRUNCATE PARTITION p1, p3;
</pre><p>
            同等の <code class="literal">DELETE</code> ステートメントを次に示します。
          </p><pre class="programlisting">
DELETE FROM t1 WHERE 
    (year_col &gt;= 1991 AND year_col &lt; 1995)
    OR
    (year_col &gt;= 2003 AND year_col &lt; 2007);
</pre><p>
            パーティション名のリストの代わりに <code class="literal">ALL</code> キーワードを使用することもできます。この場合、このステートメントはテーブル内のすべてのパーティションに対して機能します。
          </p><p>
            <code class="literal">TRUNCATE PARTITION</code> は行を削除するだけです。そのテーブル自体や、どのパーティションの定義も変更されません。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              <code class="literal">TRUNCATE PARTITION</code> は、サブパーティションでは機能しません。
            </p></div><p>
            次のようなクエリーを使用して <code class="literal">INFORMATION_SCHEMA.PARTITIONS</code> テーブルをチェックすることにより、行が削除されたことを確認できます。
          </p><pre class="programlisting">
SELECT PARTITION_NAME, TABLE_ROWS 
    FROM INFORMATION_SCHEMA.PARTITIONS 
    WHERE TABLE_NAME = 't1';
</pre><p>
            <code class="literal">TRUNCATE PARTITION</code> は、<code class="literal">MyISAM</code>、<code class="literal">InnoDB</code>、または <code class="literal">MEMORY</code> ストレージエンジンを使用するパーティション化されたテーブルでのみサポートされます。また、<code class="literal">BLACKHOLE</code> テーブルに対しても機能します (ただし、何の効果もありません)。<code class="literal">ARCHIVE</code> テーブルではサポートされません。
          </p><p>
            <code class="literal">HASH</code> または <code class="literal">KEY</code> によってパーティション化されたテーブルで <code class="literal">COALESCE PARTITION</code> を使用すると、そのパーティションの数を <em class="replaceable"><code>number</code></em> だけ減らすことができます。次の定義を使用して、テーブル <code class="literal">t2</code> を作成したとします。
          </p><pre class="programlisting">
CREATE TABLE t2 (
    name VARCHAR (30),
    started DATE
)
PARTITION BY HASH( YEAR(started) )
PARTITIONS 6;
</pre><p>
            <code class="literal">t2</code> によって使用されるパーティションの数を、次のステートメントを使用して 6 から 4 に減らすことができます。
          </p><pre class="programlisting">
ALTER TABLE t2 COALESCE PARTITION 2;
</pre><p>
            最後の <em class="replaceable"><code>number</code></em> 個のパーティションに含まれているデータは、残りのパーティションにマージされます。この場合は、パーティション 4 と 5 が最初の 4 つのパーティション (0、1、2、および 3 の番号を持つ各パーティション) にマージされます。
          </p><p>
            パーティション化されたテーブルで使用される (すべてではなく) 一部のパーティションを変更するには、<code class="literal">REORGANIZE PARTITION</code> を使用できます。このステートメントは、次のいくつかの方法で使用できます。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                一連のパーティションを単一パーティションにマージします。これは、<em class="replaceable"><code>partition_names</code></em> リストにいくつかのパーティションの名前を指定し、<em class="replaceable"><code>partition_definition</code></em> に 1 つの定義を指定することによって実行できます。
              </p></li><li class="listitem"><p>
                既存のパーティションをいくつかのパーティションに分割します。これは、<em class="replaceable"><code>partition_names</code></em> に単一パーティションを指定し、複数の <em class="replaceable"><code>partition_definitions</code></em> を指定することによって実行できます。
              </p></li><li class="listitem"><p>
                <code class="literal">VALUES LESS THAN</code> を使用して、定義されたパーティションのサブセットの範囲を変更するか、または <code class="literal">VALUES IN</code> を使用して、定義されたパーティションのサブセットの値リストを変更します。
              </p></li><li class="listitem"><p>
                このステートメントはまた、<code class="literal">HASH</code> パーティション化を使用して自動的にパーティション化されるテーブルに対して <code class="literal"><em class="replaceable"><code>partition_names</code></em> INTO (<em class="replaceable"><code>partition_definitions</code></em>)</code> オプションなしで使用すると、データを強制的に再配布できます。(現在、このように自動的にパーティション化されるのは <code class="literal">NDB</code> テーブルだけです。)これは、既存の MySQL Cluster に新しい MySQL Cluster データノードをオンラインで追加したあと、既存の MySQL Cluster テーブルデータを新しいデータノードに再配布する必要がある MySQL Cluster で役立ちます。このような場合は、<code class="literal">ONLINE</code> オプションを使用してこのステートメントを呼び出すようにしてください。つまり、次に示すようにします。
              </p><pre class="programlisting">
ALTER ONLINE TABLE <em class="replaceable"><code>table</code></em> REORGANIZE PARTITION;
</pre><p>
                オンラインのテーブル再編成と同時にほかの DDL を実行することはできません。つまり、<code class="literal">ALTER ONLINE TABLE ... REORGANIZE PARTITION</code> ステートメントの実行中は、ほかの DDL ステートメントを発行できません。MySQL Cluster データノードをオンラインで追加する方法の詳細は、<a class="xref" href="mysql-cluster.html#mysql-cluster-online-add-node" title="18.5.13 MySQL Cluster データノードのオンライン追加">セクション18.5.13「MySQL Cluster データノードのオンライン追加」</a>を参照してください。
              </p><p>
                <code class="literal">ALTER ONLINE TABLE ... REORGANIZE PARTITION</code> は、<code class="literal">MAX_ROWS</code> オプションを使用して作成されたテーブルでは機能しません。このステートメントは、元の <code class="literal">CREATE TABLE</code> ステートメントで指定された一定の <code class="literal">MAX_ROWS</code> 値を使用して必要なパーティションの数を決定するため、新しいパーティションが作成されないためです。テーブルの行の最大数を増やすには、<code class="literal">ALTER ONLINE TABLE ... MAX_ROWS=<em class="replaceable"><code>rows</code></em></code> を使用できます。このあと、<code class="literal">ALTER ONLINE TABLE ... REORGANIZE PARTITION</code> は、この大きくなった新しい値を使用してパーティションの数を増やすことができます。これが機能するには、<em class="replaceable"><code>rows</code></em> の値を、元の <code class="literal">CREATE TABLE</code> ステートメントで <code class="literal">MAX_ROWS</code> に指定された値より大きくする必要があります。
              </p><p>
                明示的にパーティション化されたテーブルに対して、<code class="literal">REORGANIZE PARTITION</code> を <code class="literal"><em class="replaceable"><code>partition_names</code></em> INTO (<em class="replaceable"><code>partition_definitions</code></em>)</code> オプションなしで使用しようとすると、<span class="errortext">REORGANIZE PARTITION without parameters can only be used on auto-partitioned tables using HASH partitioning</span>エラーが発生します。
              </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              明示的に名前が付けられていないパーティションに対して、MySQL は自動的に <code class="literal">p0</code>、<code class="literal">p1</code>、<code class="literal">p2</code> などのデフォルト名を付けます。同じことがサブパーティションにも当てはまります。
            </p></div><p>
            <code class="literal">ALTER TABLE ... REORGANIZE PARTITION</code> ステートメントの詳細および例については、<a class="xref" href="partitioning.html#partitioning-management-range-list" title="19.3.1 RANGE および LIST パーティションの管理">セクション19.3.1「RANGE および LIST パーティションの管理」</a>を参照してください。
          </p></li><li class="listitem"><p>
            MySQL 5.6 では、<code class="literal">ALTER TABLE ... EXCHANGE PARTITION</code> ステートメントを使用して、テーブルパーティションまたはサブパーティションを別のテーブルと交換できます。つまり、パーティションまたはサブパーティション内の既存の任意の行をパーティション化されていないテーブルに移動したり、パーティション化されていないテーブル内の既存の任意の行をテーブルパーティションまたはサブパーティションに移動したりできます。
          </p><p>
            使用方法および例については、<a class="xref" href="partitioning.html#partitioning-management-exchange" title="19.3.3 パーティションとサブパーティションをテーブルと交換する">セクション19.3.3「パーティションとサブパーティションをテーブルと交換する」</a>を参照してください。
          </p></li><li class="listitem"><p>
            いくつかの追加オプションによって、パーティション化されていないテーブルのために <code class="literal">CHECK TABLE</code> や <code class="literal">REPAIR TABLE</code> などのステートメントによって実装されている機能 (これは、パーティション化されたテーブルでもサポートされます。詳細は、<a class="xref" href="sql-syntax.html#table-maintenance-sql" title="13.7.2 テーブル保守ステートメント">セクション13.7.2「テーブル保守ステートメント」</a>を参照してください) に類似したパーティションの保守および修復機能が提供されます。これには、<code class="literal">ANALYZE PARTITION</code>、<code class="literal">CHECK PARTITION</code>、<code class="literal">OPTIMIZE PARTITION</code>、<code class="literal">REBUILD PARTITION</code>、および <code class="literal">REPAIR PARTITION</code> が含まれます。これらの各オプションは、1 つ以上のパーティション名から成るカンマで区切られた <em class="replaceable"><code>partition_names</code></em> 句を受け取ります。これらのパーティションは、変更されるテーブル内にすでに存在する必要があります。<em class="replaceable"><code>partition_names</code></em> の代わりに <code class="literal">ALL</code> キーワードを使用することもできます。その場合、このステートメントはテーブル内のすべてのパーティションに対して機能します。詳細および例については、<a class="xref" href="partitioning.html#partitioning-maintenance" title="19.3.4 パーティションの保守">セクション19.3.4「パーティションの保守」</a>を参照してください。
          </p><p>
            <code class="literal">InnoDB</code> などの一部の MySQL ストレージエンジンは、パーティションごとの最適化をサポートしていません。このようなストレージエンジンを使用したパーティション化されたテーブルに対して、<code class="literal">ALTER TABLE ... OPTIMIZE PARTITION</code> はテーブル全体を再構築します。これは既知の問題です。MySQL 5.6.9 から、このようなテーブルに対してこのステートメントを実行するとテーブル全体が再構築および分析され、該当する警告が発行されます。(Bug #11751825、Bug #42822)
          </p><p>
            この問題を回避するには、代わりに、ステートメント <code class="literal">ALTER TABLE ... REBUILD PARTITION</code> および <code class="literal">ALTER TABLE ... ANALYZE PARTITION</code> を使用します。
          </p><p>
            <code class="literal">ANALYZE PARTITION</code>、<code class="literal">CHECK PARTITION</code>、<code class="literal">OPTIMIZE PARTITION</code>、および <code class="literal">REPAIR PARTITION</code> オプションは、パーティション化されていないテーブルには許可されません。
          </p></li><li class="listitem"><p>
            <code class="literal">REMOVE PARTITIONING</code> を使用すると、テーブルのパーティション化を削除でき、そのテーブルやデータはそれ以外の影響を受けません。このオプションは、カラムやインデックスの追加、削除、名前変更などのために使用されるその他の <code class="literal">ALTER TABLE</code> オプションと組み合わせることができます。
          </p></li><li class="listitem"><p>
            <code class="literal">ALTER TABLE</code> で <code class="literal">ENGINE</code> オプションを使用すると、パーティション化に影響を与えることなく、テーブルで使用されるストレージエンジンが変更されます。
          </p></li></ul></div><p>
        MySQL 5.6.6 より前は、<code class="literal">MyISAM</code> (または、テーブルレベルのロックを使用する別のストレージエンジン) を使用するパーティション化されたテーブルに対して <code class="literal">ALTER TABLE ... EXCHANGE PARTITION</code> または <code class="literal">ALTER TABLE ... TRUNCATE PARTITION</code> が実行されると、そのパーティション化されたテーブル全体がロックされました。MySQL 5.6.6 以降では、このような場合、実際に読み取られたパーティションのみがロックされます。これは、行レベルロックを採用している (<code class="literal">InnoDB</code> などの) ストレージエンジンを使用するパーティション化されたテーブルには影響しませんでした (現在も影響しません)。<a class="xref" href="partitioning.html#partitioning-limitations-locking" title="19.6.4 パーティショニングとロック">セクション19.6.4「パーティショニングとロック」</a>を参照してください。
      </p><p>
        <code class="literal">ALTER TABLE</code> ステートメントには、ほかの変更指定に加えて、<code class="literal">PARTITION BY</code> または <code class="literal">REMOVE PARTITIONING</code> 句を含めることができますが、<code class="literal">PARTITION BY</code> または <code class="literal">REMOVE PARTITIONING</code> 句は、ほかのどの指定よりもあとの最後に指定する必要があります。
      </p><p>
        <code class="literal">ADD PARTITION</code>、<code class="literal">DROP PARTITION</code>、<code class="literal">COALESCE PARTITION</code>、<code class="literal">REORGANIZE PARTITION</code>、<code class="literal">ANALYZE PARTITION</code>、<code class="literal">CHECK PARTITION</code>、および <code class="literal">REPAIR PARTITION</code> オプションは、個々のパーティションに対して機能するため、1 つの <code class="literal">ALTER TABLE</code> 内でほかの変更指定と組み合わせることはできません。詳細は、<a class="xref" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1 ALTER TABLE パーティション操作">セクション13.1.7.1「ALTER TABLE パーティション操作」</a>を参照してください。
      </p><p>
        特定の <code class="literal">ALTER TABLE</code> ステートメントでは、次のいずれか 1 つのオプションの単一インスタンスのみを使用できます。<code class="literal">PARTITION BY</code>、<code class="literal">ADD PARTITION</code>、<code class="literal">DROP PARTITION</code>、<code class="literal">TRUNCATE PARTITION</code>、<code class="literal">EXCHANGE PARTITION</code>、<code class="literal">REORGANIZE PARTITION</code>、または <code class="literal">COALESCE PARTITION</code>、<code class="literal">ANALYZE PARTITION</code>、<code class="literal">CHECK PARTITION</code>、<code class="literal">OPTIMIZE PARTITION</code>、<code class="literal">REBUILD PARTITION</code>、<code class="literal">REMOVE PARTITIONING</code>。
      </p><p>
        たとえば、次の 2 つのステートメントは無効です。
      </p><pre class="programlisting">
ALTER TABLE t1 ANALYZE PARTITION p1, ANALYZE PARTITION p2;

ALTER TABLE t1 ANALYZE PARTITION p1, CHECK PARTITION p2;
</pre><p>
        最初のケースでは、次のように、分析される両方のパーティションを一覧表示した 1 つの <code class="literal">ANALYZE PARTITION</code> オプションを含む 1 つのステートメントを使用して、テーブル <code class="literal">t1</code> のパーティション <code class="literal">p1</code> と <code class="literal">p2</code> を同時に分析できます。
      </p><pre class="programlisting">
ALTER TABLE t1 ANALYZE PARTITION p1, p2;
</pre><p>
        2 番目のケースでは、同じテーブルの別のパーティションに対する <code class="literal">ANALYZE</code> 操作と <code class="literal">CHECK</code> 操作を同時に実行することはできません。代わりに、次のように、2 つの個別のステートメントを発行する必要があります。
      </p><pre class="programlisting">
ALTER TABLE t1 ANALYZE PARTITION p1;
ALTER TABLE t1 CHECK PARTITION p2;
</pre><p>
        <code class="literal">ANALYZE</code>、<code class="literal">CHECK</code>、<code class="literal">OPTIMIZE</code>、<code class="literal">REBUILD</code>、<code class="literal">REPAIR</code>、および <code class="literal">TRUNCATE</code> 操作は、サブパーティションではサポートされません。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="alter-table-online-operations"></a>13.1.7.2 MySQL Cluster での ALTER TABLE オンライン操作</h4></div></div></div><p>
        このセクションでは、MySQL Cluster で実装されたオンラインのテーブルスキーマ変更について説明します。<code class="literal">InnoDB</code> ストレージエンジンもまた、MySQL Cluster によってサポートされるものとは異なる構文を使用して、このような操作をオンラインで実行できます。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-online-ddl" title="14.11 InnoDB とオンライン DDL">セクション14.11「InnoDB とオンライン DDL」</a>を参照してください。
      </p><p>
        <code class="literal">NDB</code> テーブルの可変幅カラム上のインデックスを追加および削除する操作はオンラインで実行されます。オンライン操作はコピーなしです。つまり、インデックスを再作成する必要はありません。変更されるテーブルが、MySQL Cluster 内のほかの API ノードによるアクセスからロックされることはありません (ただし、このセクションのあとの方にある「<em class="citetitle">制限</em>」を参照してください)。このような操作では、複数の API ノードを含むクラスタで行われる <code class="literal">NDB</code> テーブルの変更にシングルユーザーモードは必要ありません。オンライン DDL 操作中も、トランザクションは中断なく続行できます。
      </p><p>
        <code class="literal">ONLINE</code> キーワードを使用すると、<code class="literal">NDB</code> テーブルに対してオンライン <code class="literal">ADD COLUMN</code>、<code class="literal">ADD INDEX</code> (<code class="literal">CREATE INDEX</code> ステートメントを含む)、および <code class="literal">DROP INDEX</code> 操作を実行できます。また、<code class="literal">NDB</code> テーブルのオンラインでの名前変更もサポートされます。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">ONLINE</code> および <code class="literal">OFFLINE</code> キーワードは、MySQL Cluster でのみサポートされます。標準の MySQL Server 5.6 リリースでは、<code class="literal">ONLINE</code> または <code class="literal">OFFLINE</code> キーワードを <code class="literal">ALTER TABLE</code>、<code class="literal">CREATE INDEX</code>、または <code class="literal">DROP INDEX</code> ステートメントで使用しようとすると、エラーが発生します。
        </p><p>
          <code class="literal">ONLINE</code> および <code class="literal">OFFLINE</code> キーワードは、MySQL Cluster NDB 7.3 から非推奨です。MySQL Cluster NDB 7.4 では引き続きサポートされますが、将来のバージョンの MySQL Cluster で削除される可能性があります。
        </p></div><p>
        現在、ディスクベースのカラムを <code class="literal">NDB</code> テーブルにオンラインで追加することはできません。つまり、テーブルレベルの <code class="literal">STORAGE DISK</code> オプションを使用する <code class="literal">NDB</code> テーブルにインメモリーカラムを追加する場合は、新しいカラムをメモリーベースのストレージの使用として明示的に宣言する必要があります。たとえば、すでにテーブルスペース <code class="literal">ts1</code> を作成していると仮定して、テーブル <code class="literal">t1</code> を次のように作成するとします。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (</code></strong>
     &gt;     <strong class="userinput"><code>c1 INT NOT NULL PRIMARY KEY,</code></strong>
     &gt;     <strong class="userinput"><code>c2 VARCHAR(30)</code></strong>
     &gt;     <strong class="userinput"><code>)</code></strong>
     &gt;     <strong class="userinput"><code>TABLESPACE ts1 STORAGE DISK</code></strong>
     &gt;     <strong class="userinput"><code>ENGINE NDB;</code></strong>
Query OK, 0 rows affected (1.73 sec)
Records: 0  Duplicates: 0  Warnings: 0
</pre><p>
        次に示すように、新しいインメモリーカラムをこのテーブルにオンラインで追加できます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>ALTER ONLINE TABLE t1 ADD COLUMN c3 INT COLUMN_FORMAT DYNAMIC STORAGE MEMORY;</code></strong>
Query OK, 0 rows affected (1.25 sec)
Records: 0  Duplicates: 0  Warnings: 0
</pre><p>
        <code class="literal">STORAGE MEMORY</code> オプションが省略されている場合、このステートメントは失敗します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>ALTER ONLINE TABLE t1 ADD COLUMN c3 INT COLUMN_FORMAT DYNAMIC;</code></strong>
<span class="errortext">ERROR 1235 (42000): This version of MySQL doesn't yet support
'ALTER ONLINE TABLE t1 ADD COLUMN c3 INT COLUMN_FORMAT DYNAMIC'</span>
</pre><p>
        <code class="literal">COLUMN_FORMAT DYNAMIC</code> オプションを省略した場合は、動的なカラムフォーマットが自動的に使用されますが、次に示すような警告が発行されます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>ALTER ONLINE TABLE t1 ADD COLUMN c3 INT STORAGE MEMORY;</code></strong>
Query OK, 0 rows affected, 1 warning (1.17 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+---------+------+---------------------------------------------------------------+
| Level   | Code | Message                                                       |
+---------+------+---------------------------------------------------------------+
| Warning | 1478 | Converted FIXED field to DYNAMIC to enable on-line ADD COLUMN |
+---------+------+---------------------------------------------------------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE t1\G</code></strong>
*************************** 1. row ***************************
       Table: t1
Create Table: CREATE TABLE `t1` (
  `c1` int(11) NOT NULL,
  `c2` varchar(30) DEFAULT NULL,
  `c3` int(11) /*!50120 STORAGE MEMORY */ /*!50120 COLUMN_FORMAT DYNAMIC */ DEFAULT NULL,
  `t4` int(11) /*!50120 STORAGE MEMORY */ DEFAULT NULL,
  PRIMARY KEY (`c1`)
) /*!50100 TABLESPACE ts_1 STORAGE DISK */ ENGINE=ndbcluster DEFAULT CHARSET=latin1
1 row in set (0.03 sec)
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">STORAGE</code> および <code class="literal">COLUMN_FORMAT</code> キーワードは、MySQL Cluster でのみサポートされます。ほかのどのバージョンの MySQL でも、このどちらかのキーワードを <code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> ステートメントで使用しようとすると、エラーが発生します。
        </p></div><p>
        <code class="literal">NDB</code> テーブルに対して、ステートメント <code class="literal">ALTER ONLINE TABLE ... REORGANIZE PARTITION</code> を <code class="literal"><em class="replaceable"><code>partition_names</code></em> INTO (<em class="replaceable"><code>partition_definitions</code></em>)</code> オプションなしで使用することもできます。これを使用すると、オンラインでクラスタに追加された新しいデータノードの間で MySQL Cluster データを再配布できます。このステートメントの詳細は、<a class="xref" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1 ALTER TABLE パーティション操作">セクション13.1.7.1「ALTER TABLE パーティション操作」</a>を参照してください。MySQL Cluster にデータノードをオンラインで追加する方法の詳細は、<a class="xref" href="mysql-cluster.html#mysql-cluster-online-add-node" title="18.5.13 MySQL Cluster データノードのオンライン追加">セクション18.5.13「MySQL Cluster データノードのオンライン追加」</a>を参照してください。
      </p><h5><a name="alter-table-online-limitations"></a>MySQL Cluster オンライン操作の制限</h5><p>
        オンライン <code class="literal">DROP COLUMN</code> 操作はサポートされていません。
      </p><p>
        カラムを追加するか、あるいはインデックスを追加または削除するオンライン <code class="literal">ALTER TABLE</code>、<code class="literal">CREATE INDEX</code>、または <code class="literal">DROP INDEX</code> ステートメントは、次の制限に従います。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            特定のオンライン <code class="literal">ALTER TABLE</code> では、<code class="literal">ADD COLUMN</code>、<code class="literal">ADD INDEX</code>、<code class="literal">DROP INDEX</code> のいずれか 1 つのみを使用できます。1 つのステートメントで、1 つ以上のカラムをオンラインで追加できます。1 つのステートメントで、1 つのインデックスのみをオンラインで作成または削除できます。
          </p></li><li class="listitem"><p>
            変更されるテーブルは、オンライン <code class="literal">ALTER TABLE</code> <code class="literal">ADD COLUMN</code>、<code class="literal">ADD INDEX</code>、または <code class="literal">DROP INDEX</code> 操作 (あるいは <code class="literal">CREATE INDEX</code> または <code class="literal">DROP INDEX</code> ステートメント) が実行されている API ノード以外の API ノードに対してロックされません。ただし、オンライン操作が実行されている間、このテーブルは<span class="emphasis"><em>同じ</em></span> API ノードから発信されているほかのすべての操作に対してロックされます。
          </p></li><li class="listitem"><p>
            変更されるテーブルには明示的な主キーが存在する必要があります。<code class="literal">NDB</code> ストレージエンジンによって作成された非表示の主キーは、この目的には不十分です。
          </p></li><li class="listitem"><p>
            テーブルで使用されるストレージエンジンをオンラインで変更することはできません。
          </p></li><li class="listitem"><p>
            MySQL Cluster ディスクデータテーブルで使用された場合、カラムのストレージ型 (<code class="literal">DISK</code> または <code class="literal">MEMORY</code>) をオンラインで変更することはできません。つまり、操作がオンラインで実行されるような方法でインデックスを追加または削除するときに、1 つまたは複数のカラムのストレージ型が変更されるようにする場合は、インデックスを追加または削除するステートメントで <code class="literal">OFFLINE</code> キーワードを使用する必要があります。
          </p></li></ul></div><p>
        オンラインで追加されるカラムは <code class="literal">BLOB</code> または <code class="literal">TEXT</code> 型を使用できず、次の条件を満たす必要があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            このカラムは動的である必要があります。つまり、<code class="literal">COLUMN_FORMAT DYNAMIC</code> を使用して作成できる必要があります。<code class="literal">COLUMN_FORMAT DYNAMIC</code> オプションを省略した場合は、動的なカラムフォーマットが自動的に使用されます。
          </p></li><li class="listitem"><p>
            このカラムは <code class="literal">NULL</code> 値を許可する必要があり、<code class="literal">NULL</code> 以外の明示的なデフォルト値があってはなりません。オンラインで追加されるカラムは、次に示すように、<code class="literal">DEFAULT NULL</code> として自動的に作成されます。
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (</code></strong>
     &gt;     <strong class="userinput"><code>c1 INT NOT NULL AUTO_INCREMENT PRIMARY KEY</code></strong>
     &gt;     <strong class="userinput"><code>) ENGINE=NDB;</code></strong>
Query OK, 0 rows affected (1.44 sec)

mysql&gt; <strong class="userinput"><code>ALTER ONLINE TABLE t1</code></strong>
     &gt;     <strong class="userinput"><code>ADD COLUMN c2 INT,</code></strong>
     &gt;     <strong class="userinput"><code>ADD COLUMN c3 INT;</code></strong>
Query OK, 0 rows affected, 2 warnings (0.93 sec)

mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE t1\G</code></strong>
*************************** 1. row ***************************
       Table: t1
Create Table: CREATE TABLE `t1` (
  `c1` int(11) NOT NULL AUTO_INCREMENT,
  `c2` int(11) DEFAULT NULL,
  `c3` int(11) DEFAULT NULL,
  PRIMARY KEY (`c1`)
) ENGINE=ndbcluster DEFAULT CHARSET=latin1
1 row in set (0.00 sec)
</pre></li><li class="listitem"><p>
            このカラムは、既存のすべてのカラムのあとに追加する必要があります。既存のいずれかのカラムの前に、または <code class="literal">FIRST</code> キーワードを使用してオンラインでカラムを追加しようとすると、このステートメントはエラーで失敗します。
          </p></li><li class="listitem"><p>
            既存のテーブルカラムをオンラインで並べ替えることはできません。
          </p></li></ul></div><p>
        前の制限は、テーブルまたはカラムの名前を変更するだけの操作には適用されません。
      </p><p>
        <code class="literal">NDB</code> テーブルに対するオンライン <code class="literal">ALTER TABLE</code> 操作の場合、固定フォーマットのカラムは次に示すように、オンラインで追加されるか、またはインデックスがオンラインで作成または削除されたときに動的なカラムに変換されます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (</code></strong>
     &gt;     <strong class="userinput"><code>c1 INT NOT NULL AUTO_INCREMENT PRIMARY KEY</code></strong>
     &gt;     <strong class="userinput"><code>) ENGINE=NDB;</code></strong>
Query OK, 0 rows affected (1.44 sec)

mysql&gt; <strong class="userinput"><code>ALTER ONLINE TABLE t1 ADD COLUMN c2 INT, ADD COLUMN c3 INT;</code></strong>
Query OK, 0 rows affected, 2 warnings (0.93 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+---------+------+---------------------------------------------------------------+
| Level   | Code | Message                                                       |
+---------+------+---------------------------------------------------------------+
| Warning | 1475 | Converted FIXED field to DYNAMIC to enable on-line ADD COLUMN |
| Warning | 1475 | Converted FIXED field to DYNAMIC to enable on-line ADD COLUMN |
+---------+------+---------------------------------------------------------------+
2 rows in set (0.00 sec)
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          既存のカラム (テーブルの主キーを含む) は、動的である必要はありません。動的である必要があるのは、オンラインで追加される 1 つまたは複数のカラムだけです。
        </p></div><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE t2 (</code></strong>
     &gt;     <strong class="userinput"><code>c1 INT NOT NULL AUTO_INCREMENT PRIMARY KEY COLUMN_FORMAT FIXED</code></strong>
     &gt;     <strong class="userinput"><code>) ENGINE=NDB;</code></strong>
Query OK, 0 rows affected (2.10 sec)

mysql&gt; <strong class="userinput"><code>ALTER ONLINE TABLE t2 ADD COLUMN c2 INT;</code></strong>
Query OK, 0 rows affected, 1 warning (0.78 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+---------+------+---------------------------------------------------------------+
| Level   | Code | Message                                                       |
+---------+------+---------------------------------------------------------------+
| Warning | 1475 | Converted FIXED field to DYNAMIC to enable on-line ADD COLUMN |
+---------+------+---------------------------------------------------------------+
1 row in set (0.00 sec)
</pre><p>
        名前の変更操作によって、カラムが <code class="literal">FIXED</code> から <code class="literal">DYNAMIC</code> のカラムフォーマットに変換されることはありません。<code class="literal">COLUMN_FORMAT</code> の詳細は、<a class="xref" href="sql-syntax.html#create-table" title="13.1.17 CREATE TABLE 構文">セクション13.1.17「CREATE TABLE 構文」</a>を参照してください。
      </p><p>
        <code class="literal">KEY</code>、<code class="literal">CONSTRAINT</code>、および <code class="literal">IGNORE</code> キーワードは、<code class="literal">ONLINE</code> キーワードを使用している <code class="literal">ALTER TABLE</code> ステートメントでサポートされます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="alter-table-examples"></a>13.1.7.3 ALTER TABLE の例</h4></div></div></div><p>
        次に示すように作成されているテーブル <code class="literal">t1</code> から始めます。
      </p><pre class="programlisting">
CREATE TABLE t1 (a INTEGER,b CHAR(10));
</pre><p>
        テーブルの名前を <code class="literal">t1</code> から <code class="literal">t2</code> に変更するには、次のようにします。
      </p><pre class="programlisting">
ALTER TABLE t1 RENAME t2;
</pre><p>
        カラム <code class="literal">a</code> を <code class="literal">INTEGER</code> から <code class="literal">TINYINT NOT NULL</code> に変更し (名前は同じままにします)、またカラム <code class="literal">b</code> を <code class="literal">CHAR(10)</code> から <code class="literal">CHAR(20)</code> に変更し、さらにその名前を <code class="literal">b</code> から <code class="literal">c</code> に変更するには、次のようにします。
      </p><pre class="programlisting">
ALTER TABLE t2 MODIFY a TINYINT NOT NULL, CHANGE b c CHAR(20);
</pre><p>
        <code class="literal">d</code> という名前の新しい <code class="literal">TIMESTAMP</code> カラムを追加するには、次のようにします。
      </p><pre class="programlisting">
ALTER TABLE t2 ADD d TIMESTAMP;
</pre><p>
        カラム <code class="literal">d</code> にインデックスを、またカラム <code class="literal">a</code> に <code class="literal">UNIQUE</code> インデックスを追加するには、次のようにします。
      </p><pre class="programlisting">
ALTER TABLE t2 ADD INDEX (d), ADD UNIQUE (a);
</pre><p>
        カラム <code class="literal">c</code> を削除するには、次のようにします。
      </p><pre class="programlisting">
ALTER TABLE t2 DROP COLUMN c;
</pre><p>
        <code class="literal">c</code> という名前の新しい <code class="literal">AUTO_INCREMENT</code> 整数カラムを追加するには、次のようにします。
      </p><pre class="programlisting">
ALTER TABLE t2 ADD c INT UNSIGNED NOT NULL AUTO_INCREMENT,
  ADD PRIMARY KEY (c);
</pre><p>
        <code class="literal">AUTO_INCREMENT</code> カラムにはインデックスを設定する必要があるため <code class="literal">c</code> に (<code class="literal">PRIMARY KEY</code> として) インデックスを設定し、また主キーカラムは <code class="literal">NULL</code> にできないため <code class="literal">c</code> を <code class="literal">NOT NULL</code> として宣言します。
      </p><p>
        <code class="literal">NDB</code> テーブルの場合は、テーブルまたはカラムに使用されるストレージ型を変更することもできます。たとえば、次に示すように作成された <code class="literal">NDB</code> テーブルを考えてみます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT) TABLESPACE ts_1 ENGINE NDB;</code></strong>
Query OK, 0 rows affected (1.27 sec)
</pre><p>
        このテーブルをディスクベースのストレージに変換するには、次の <code class="literal">ALTER TABLE</code> ステートメントを使用できます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>ALTER TABLE t1 TABLESPACE ts_1 STORAGE DISK;</code></strong>
Query OK, 0 rows affected (2.99 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE t1\G</code></strong>
*************************** 1. row ***************************
       Table: t1
Create Table: CREATE TABLE `t1` (
  `c1` int(11) DEFAULT NULL
) /*!50100 TABLESPACE ts_1 STORAGE DISK */
ENGINE=ndbcluster DEFAULT CHARSET=latin1
1 row in set (0.01 sec)
</pre><p>
        テーブルが最初に作成されたときにテーブルスペースが参照されている必要はありませんが、テーブルスペースは <code class="literal">ALTER TABLE</code> によって参照される必要があります。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE t2 (c1 INT) ts_1 ENGINE NDB;</code></strong>
Query OK, 0 rows affected (1.00 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE t2 STORAGE DISK;</code></strong>
<span class="errortext">ERROR 1005 (HY000): Can't create table 'c.#sql-1750_3' (errno: 140)</span>
mysql&gt; <strong class="userinput"><code>ALTER TABLE t2 TABLESPACE ts_1 STORAGE DISK;</code></strong>
Query OK, 0 rows affected (3.42 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE t2\G</code></strong>
*************************** 1. row ***************************
       Table: t1
Create Table: CREATE TABLE `t2` (
  `c1` int(11) DEFAULT NULL
) /*!50100 TABLESPACE ts_1 STORAGE DISK */
ENGINE=ndbcluster DEFAULT CHARSET=latin1
1 row in set (0.01 sec)
</pre><p>
        個々のカラムのストレージ型を変更するには、<code class="literal">ALTER TABLE ... MODIFY [COLUMN]</code> を使用できます。たとえば、次の <code class="literal">CREATE TABLE</code> ステートメントを使用して、2 つのカラムを含む MySQL Cluster ディスクデータテーブルを作成するとします。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE t3 (c1 INT, c2 INT)</code></strong>
    -&gt;     <strong class="userinput"><code>TABLESPACE ts_1 STORAGE DISK ENGINE NDB;</code></strong>
Query OK, 0 rows affected (1.34 sec)
</pre><p>
        カラム <code class="literal">c2</code> をディスクベースのストレージからインメモリーストレージに変更するには、次に示すように、ALTER TABLE ステートメントで使用されるカラム定義に STORAGE MEMORY 句を含めます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>ALTER TABLE t3 MODIFY c2 INT STORAGE MEMORY;</code></strong>
Query OK, 0 rows affected (3.14 sec)
Records: 0  Duplicates: 0  Warnings: 0
</pre><p>
        同様の方法で <code class="literal">STORAGE DISK</code> を使用して、インメモリーカラムをディスクベースのカラムにすることができます。
      </p><p>
        カラム <code class="literal">c1</code> は、ディスクベースのストレージを使用します。これが (<code class="literal">CREATE TABLE</code> ステートメント内のテーブルレベルの <code class="literal">STORAGE DISK</code> 句によって決定される) テーブルのデフォルトであるためです。ただし、次の SHOW <code class="literal">CREATE TABLE</code> の出力に示すように、カラム <code class="literal">c2</code> はインメモリーストレージを使用します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE t3\G</code></strong>
*************************** 1. row ***************************
       Table: t3
Create Table: CREATE TABLE `t3` (
  `c1` int(11) DEFAULT NULL,
  `c2` int(11) /*!50120 STORAGE MEMORY */ DEFAULT NULL
) /*!50100 TABLESPACE ts_1 STORAGE DISK */ ENGINE=ndbcluster DEFAULT CHARSET=latin1
1 row in set (0.02 sec)
</pre><p>
        <code class="literal">AUTO_INCREMENT</code> カラムを追加すると、カラム値には、自動的にシーケンス番号が入力されます。<code class="literal">MyISAM</code> テーブルの場合は、<code class="literal">ALTER TABLE</code> の前に <code class="literal">SET INSERT_ID=<em class="replaceable"><code>value</code></em></code> を実行するか、または <code class="literal">AUTO_INCREMENT=<em class="replaceable"><code>value</code></em></code> テーブルオプションを使用することによって、最初のシーケンス番号を設定できます。<a class="xref" href="server-administration.html#server-system-variables" title="5.1.4 サーバーシステム変数">セクション5.1.4「サーバーシステム変数」</a>を参照してください。
      </p><p>
        <code class="literal">MyISAM</code> テーブルでは、<code class="literal">AUTO_INCREMENT</code> カラムを変更しない場合、シーケンス番号は影響を受けません。<code class="literal">AUTO_INCREMENT</code> カラムを削除してから、別の <code class="literal">AUTO_INCREMENT</code> カラムを追加した場合、シーケンス番号は 1 から付け直されます。
      </p><p>
        レプリケーションが使用されている場合は、テーブルに <code class="literal">AUTO_INCREMENT</code> カラムを追加しても、スレーブとマスターで行の順序が同じにならない可能性があります。これが発生するのは、行が番号付けされる順序が、テーブルに使用される固有のストレージエンジンおよび行が挿入された順序に依存するためです。マスターとスレーブで同じ順序を持つことが重要である場合は、行を並べ替えてから <code class="literal">AUTO_INCREMENT</code> 番号を割り当てる必要があります。テーブル <code class="literal">t1</code> に <code class="literal">AUTO_INCREMENT</code> カラムを追加すると仮定した場合、次のステートメントは、<code class="literal">t1</code> と同一であるが、<code class="literal">AUTO_INCREMENT</code> カラムを含む新しいテーブル <code class="literal">t2</code> を生成します。
      </p><pre class="programlisting">
CREATE TABLE t2 (id INT AUTO_INCREMENT PRIMARY KEY)
SELECT * FROM t1 ORDER BY col1, col2;
</pre><p>
        ここでは、テーブル <code class="literal">t1</code> にカラム <code class="literal">col1</code> と <code class="literal">col2</code> が存在することを前提にしています。
      </p><p>
        この一連のステートメントではまた、<code class="literal">t1</code> と同一であるが、<code class="literal">AUTO_INCREMENT</code> カラムが追加された新しいテーブル <code class="literal">t2</code> も生成されます。
      </p><pre class="programlisting">
CREATE TABLE t2 LIKE t1;
ALTER TABLE t2 ADD id INT AUTO_INCREMENT PRIMARY KEY;
INSERT INTO t2 SELECT * FROM t1 ORDER BY col1, col2;
</pre><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          マスターとスレーブの両方で順序が同じになることを保証するには、<code class="literal">ORDER BY</code> 句で <code class="literal">t1</code> の<span class="emphasis"><em>すべての</em></span>カラムを参照する必要があります。
        </p></div><p>
        <code class="literal">AUTO_INCREMENT</code> カラムを持つコピーを作成および移入するために使用する方法にかかわらず、最終手順は元のテーブルを削除してコピーの名前を変更することです。
      </p><pre class="programlisting">
DROP TABLE t1;
ALTER TABLE t2 RENAME t1;
</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="alter-tablespace"></a>13.1.8 ALTER TABLESPACE 構文</h3></div></div></div><a class="indexterm" name="idm139979088946368"></a><pre class="programlisting">
ALTER TABLESPACE <em class="replaceable"><code>tablespace_name</code></em>
    {ADD|DROP} DATAFILE '<em class="replaceable"><code>file_name</code></em>'
    [INITIAL_SIZE [=] <em class="replaceable"><code>size</code></em>]
    [WAIT]
    ENGINE [=] <em class="replaceable"><code>engine_name</code></em>
</pre><p>
      このステートメントを使用すると、テーブルスペースへの新しいデータファイルの追加、またはテーブルスペースからのデータファイルの削除を実行できます。
    </p><p>
      <code class="literal">ADD DATAFILE</code> バリアントでは、<code class="literal">INITIAL_SIZE</code> 句を使用して初期サイズを指定できます。ここで、<em class="replaceable"><code>size</code></em> はバイト単位で測定されます。デフォルト値は 134217728 (128M バイト) です。MySQL Cluster NDB 7.3.2 より前は、この値は数字で指定する必要がありました。(Bug #13116514、Bug #16104705、Bug #62858)。MySQL Cluster NDB 7.3.2 以降では、<em class="replaceable"><code>size</code></em> のあとにオプションで、<code class="filename">my.cnf</code> で使用されるのと同様の、オーダーを示す 1 文字の略語を指定できます。一般に、これは <code class="literal">M</code> (M バイト) または <code class="literal">G</code> (G バイト) のどちらかの文字です。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        すべての MySQL Cluster ディスクデータオブジェクトが同じ名前空間を共有します。つまり、<span class="emphasis"><em>各ディスクデータオブジェクト</em></span>は (単に、特定の型の各ディスクデータオブジェクトというだけでなく)、一意の名前が付けられている必要があります。たとえば、テーブルスペースとデータファイルを同じ名前にしたり、Undo ログファイルとテーブルスペースを同じ名前にしたりすることはできません。
      </p></div><p>
      32 ビットシステム上では、<code class="literal">INITIAL_SIZE</code> のサポートされる最大値は 4294967296 (4G バイト) です。(Bug #29186)
    </p><p>
      <code class="literal">INITIAL_SIZE</code> は、<code class="literal">CREATE TABLESPACE</code> と同様に明示的に丸められます。
    </p><p>
      データファイルが作成されたあと、そのサイズを変更することはできません。ただし、追加の <code class="literal">ALTER TABLESPACE ... ADD DATAFILE</code> ステートメントを使用して、テーブルスペースにさらに多くのデータファイルを追加できます。
    </p><p>
      <code class="literal">DROP DATAFILE</code> を <code class="literal">ALTER TABLESPACE</code> とともに使用すると、テーブルスペースからデータファイル '<em class="replaceable"><code>file_name</code></em>' が削除されます。いずれかのテーブルが使用しているテーブルスペースからはデータファイルを削除できません。つまり、そのデータファイルが空である (エクステントが使用されていない) ことが必要です。<a class="xref" href="mysql-cluster.html#mysql-cluster-disk-data-objects" title="18.5.12.1 MySQL Cluster ディスクデータオブジェクト">セクション18.5.12.1「MySQL Cluster ディスクデータオブジェクト」</a>を参照してください。さらに、削除されるデータファイルはすべて、<code class="literal">CREATE TABLESPACE</code> または <code class="literal">ALTER TABLESPACE</code> で以前にそのテーブルスペースに追加されている必要があります。
    </p><p>
      <code class="literal">ALTER TABLESPACE ... ADD DATAFILE</code> と <code class="literal">ALTER TABLESPACE ... DROP DATAFILE</code> のどちらにも、そのテーブルスペースによって使用されるストレージエンジンを指定する <code class="literal">ENGINE</code> 句が必要です。現在、<em class="replaceable"><code>engine_name</code></em> として受け入れられる値は <code class="literal">NDB</code> と <code class="literal">NDBCLUSTER</code> だけです。
    </p><p>
      <code class="literal">WAIT</code> は解析されますが、それ以外は無視されるため、MySQL 5.6 では何の効果もありません。これは将来の拡張のために用意されています。
    </p><p>
      <code class="literal">ALTER TABLESPACE ... ADD DATAFILE</code> が <code class="literal">ENGINE = NDB</code> とともに使用された場合は、データファイルが各クラスタデータノード上に作成されます。<code class="literal">INFORMATION_SCHEMA.FILES</code> テーブルをクエリーすることによって、データファイルが作成されたことを確認したり、それらに関する情報を取得したりできます。たとえば、次のクエリーは、<code class="literal">newts</code> という名前のテーブルスペースに属するすべてのデータファイルを表示します。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT LOGFILE_GROUP_NAME, FILE_NAME, EXTRA</code></strong>
    -&gt; <strong class="userinput"><code>FROM INFORMATION_SCHEMA.FILES</code></strong>
    -&gt; <strong class="userinput"><code>WHERE TABLESPACE_NAME = 'newts' AND FILE_TYPE = 'DATAFILE';</code></strong>
+--------------------+--------------+----------------+
| LOGFILE_GROUP_NAME | FILE_NAME    | EXTRA          |
+--------------------+--------------+----------------+
| lg_3               | newdata.dat  | CLUSTER_NODE=3 |
| lg_3               | newdata.dat  | CLUSTER_NODE=4 |
| lg_3               | newdata2.dat | CLUSTER_NODE=3 |
| lg_3               | newdata2.dat | CLUSTER_NODE=4 |
+--------------------+--------------+----------------+
2 rows in set (0.03 sec)
</pre><p>
      <a class="xref" href="information-schema.html#files-table" title="21.30.1 INFORMATION_SCHEMA FILES テーブル">セクション21.30.1「INFORMATION_SCHEMA FILES テーブル」</a>を参照してください。
    </p><p>
      <code class="literal">ALTER TABLESPACE</code> は、MySQL Cluster のディスクデータストレージでのみ有効です。<a class="xref" href="mysql-cluster.html#mysql-cluster-disk-data" title="18.5.12 MySQL Cluster ディスクデータテーブル">セクション18.5.12「MySQL Cluster ディスクデータテーブル」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="alter-view"></a>13.1.9 ALTER VIEW 構文</h3></div></div></div><a class="indexterm" name="idm139979088899232"></a><pre class="programlisting">
ALTER
    [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]
    [DEFINER = { <em class="replaceable"><code>user</code></em> | CURRENT_USER }]
    [SQL SECURITY { DEFINER | INVOKER }]
    VIEW <em class="replaceable"><code>view_name</code></em> [(<em class="replaceable"><code>column_list</code></em>)]
    AS <em class="replaceable"><code>select_statement</code></em>
    [WITH [CASCADED | LOCAL] CHECK OPTION]
</pre><p>
      このステートメントは、ビューの定義を変更します。このビューは存在する必要があります。この構文は <code class="literal">CREATE VIEW</code> の構文に似ていますが、その効果は <code class="literal">CREATE OR REPLACE VIEW</code> と同じです。<a class="xref" href="sql-syntax.html#create-view" title="13.1.20 CREATE VIEW 構文">セクション13.1.20「CREATE VIEW 構文」</a>を参照してください。このステートメントには、このビューに対する <code class="literal">CREATE VIEW</code> および <code class="literal">DROP</code> 権限と、<code class="literal">SELECT</code> ステートメントで参照される各カラムに対する何らかの権限が必要です。<code class="literal">ALTER VIEW</code> は、定義者または <code class="literal">SUPER</code> 権限を持つユーザーにのみ許可されます。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="create-database"></a>13.1.10 CREATE DATABASE 構文</h3></div></div></div><a class="indexterm" name="idm139979088881664"></a><a class="indexterm" name="idm139979088879552"></a><a class="indexterm" name="idm139979088878320"></a><a class="indexterm" name="idm139979088876976"></a><a class="indexterm" name="idm139979088874832"></a><a class="indexterm" name="idm139979088872800"></a><a class="indexterm" name="idm139979088870768"></a><pre class="programlisting">
CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] <em class="replaceable"><code>db_name</code></em>
    [<em class="replaceable"><code>create_specification</code></em>] ...

<em class="replaceable"><code>create_specification</code></em>:
    [DEFAULT] CHARACTER SET [=] <em class="replaceable"><code>charset_name</code></em>
  | [DEFAULT] COLLATE [=] <em class="replaceable"><code>collation_name</code></em>
</pre><p>
      <code class="literal">CREATE DATABASE</code> は、指定された名前を持つデータベースを作成します。このステートメントを使用するには、このデータベースに対する <code class="literal">CREATE</code> 権限が必要です。<code class="literal">CREATE SCHEMA</code> は <code class="literal">CREATE DATABASE</code> のシノニムです。
    </p><p>
      そのデータベースが存在するときに <code class="literal">IF NOT EXISTS</code> を指定しなかった場合は、エラーが発生します。
    </p><p>
      MySQL 5.6 では、アクティブな <code class="literal">LOCK TABLES</code> ステートメントが存在するセッション内では <code class="literal">CREATE DATABASE</code> が許可されません。
    </p><p>
      <em class="replaceable"><code>create_specification</code></em> オプションは、データベースの特性を指定します。データベースの特性は、データベースディレクトリ内の <code class="filename">db.opt</code> ファイルに格納されます。<code class="literal">CHARACTER SET</code> 句は、デフォルトのデータベース文字セットを指定します。<code class="literal">COLLATE</code> 句は、デフォルトのデータベース照合順序を指定します。<a class="xref" href="globalization.html#charset" title="10.1 文字セットのサポート">セクション10.1「文字セットのサポート」</a>では、文字セットと照合順序名について説明しています。
    </p><p>
      MySQL でのデータベースは、そのデータベース内のテーブルに対応するファイルを含むディレクトリとして実装されます。データベースが最初に作成されたとき、その中にはテーブルが存在しないため、<code class="literal">CREATE DATABASE</code> ステートメントは、MySQL データディレクトリの下のディレクトリと <code class="filename">db.opt</code> ファイルのみを作成します。許可されるデータベース名のルールは、<a class="xref" href="language-structure.html#identifiers" title="9.2 スキーマオブジェクト名">セクション9.2「スキーマオブジェクト名」</a>に示されています。データベース名に特殊文字が含まれている場合は、<a class="xref" href="language-structure.html#identifier-mapping" title="9.2.3 識別子とファイル名のマッピング">セクション9.2.3「識別子とファイル名のマッピング」</a>で説明されているように、その文字のエンコードされたバージョンがデータベースディレクトリの名前に含まれます。
    </p><p>
      データディレクトリの下に (たとえば、<span class="command"><strong>mkdir</strong></span> で) ディレクトリを手動で作成すると、サーバーはそれをデータベースディレクトリと見なし、<code class="literal">SHOW DATABASES</code> の出力に表示します。
    </p><a class="indexterm" name="idm139979088842240"></a><p>
      <span class="command"><strong>mysqladmin</strong></span> プログラムを使用してデータベースを作成することもできます。<a class="xref" href="programs.html#mysqladmin" title="4.5.2 mysqladmin — MySQL サーバーの管理を行うクライアント">セクション4.5.2「<span class="command"><strong>mysqladmin</strong></span> — MySQL サーバーの管理を行うクライアント」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="create-event"></a>13.1.11 CREATE EVENT 構文</h3></div></div></div><a class="indexterm" name="idm139979088837664"></a><a class="indexterm" name="idm139979088835504"></a><a class="indexterm" name="idm139979088833472"></a><pre class="programlisting">
CREATE
    [DEFINER = { <em class="replaceable"><code>user</code></em> | CURRENT_USER }]
    EVENT
    [IF NOT EXISTS]
    <em class="replaceable"><code>event_name</code></em>
    ON SCHEDULE <em class="replaceable"><code>schedule</code></em>
    [ON COMPLETION [NOT] PRESERVE]
    [ENABLE | DISABLE | DISABLE ON SLAVE]
    [COMMENT '<em class="replaceable"><code>comment</code></em>']
    DO <em class="replaceable"><code>event_body</code></em>;

<em class="replaceable"><code>schedule</code></em>:
    AT <em class="replaceable"><code>timestamp</code></em> [+ INTERVAL <em class="replaceable"><code>interval</code></em>] ...
  | EVERY <em class="replaceable"><code>interval</code></em>
    [STARTS <em class="replaceable"><code>timestamp</code></em> [+ INTERVAL <em class="replaceable"><code>interval</code></em>] ...]
    [ENDS <em class="replaceable"><code>timestamp</code></em> [+ INTERVAL <em class="replaceable"><code>interval</code></em>] ...]

<em class="replaceable"><code>interval</code></em>:
    <em class="replaceable"><code>quantity</code></em> {YEAR | QUARTER | MONTH | DAY | HOUR | MINUTE |
              WEEK | SECOND | YEAR_MONTH | DAY_HOUR | DAY_MINUTE |
              DAY_SECOND | HOUR_MINUTE | HOUR_SECOND | MINUTE_SECOND}
</pre><p>
      このステートメントは、新しいイベントを作成してスケジュールします。このイベントは、イベントスケジューラが有効になっていないかぎり実行されません。イベントスケジューラのステータスをチェックし、必要に応じてそれを有効にする方法については、<a class="xref" href="stored-programs-views.html#events-configuration" title="20.4.2 イベントスケジューラの構成">セクション20.4.2「イベントスケジューラの構成」</a>を参照してください。
    </p><p>
      <code class="literal">CREATE EVENT</code> には、イベントが作成されるスキーマに対する <code class="literal">EVENT</code> 権限が必要です。このセクションのあとの方で説明されているように、<code class="literal">DEFINER</code> 値によっては <code class="literal">SUPER</code> 権限も必要になる可能性があります。
    </p><p>
      有効な <code class="literal">CREATE EVENT</code> ステートメントの最小要件は次のとおりです。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          キーワード <code class="literal">CREATE EVENT</code> に加えて、データベーススキーマ内のイベントを一意に識別するイベント名。
        </p></li><li class="listitem"><p>
          イベントが実行される時期と頻度を決定する <code class="literal">ON SCHEDULE</code> 句。
        </p></li><li class="listitem"><p>
          イベントによって実行される SQL ステートメントを含む <code class="literal">DO</code> 句。
        </p></li></ul></div><p>
      最小限の <code class="literal">CREATE EVENT</code> ステートメントの例を次に示します。
    </p><pre class="programlisting">
CREATE EVENT myevent
    ON SCHEDULE AT CURRENT_TIMESTAMP + INTERVAL 1 HOUR
    DO
      UPDATE myschema.mytable SET mycol = mycol + 1;
</pre><p>
      前のステートメントは、<code class="literal">myevent</code> という名前のイベントを作成します。このイベントは、<code class="literal">myschema.mytable</code> テーブルの <code class="literal">mycol</code> カラムの値を 1 増分する SQL ステートメントを実行することによって (その作成の 1 時間後に) 1 回実行されます。
    </p><p>
      <em class="replaceable"><code>event_name</code></em> は、最大長が 64 文字の有効な MySQL 識別子である必要があります。イベント名は大文字と小文字が区別されないため、<code class="literal">myevent</code> と <code class="literal">MyEvent</code> という名前の 2 つのイベントを同じスキーマ内に含めることはできません。一般に、イベント名を管理するルールは、ストアドルーチンの名前の場合と同じです。<a class="xref" href="language-structure.html#identifiers" title="9.2 スキーマオブジェクト名">セクション9.2「スキーマオブジェクト名」</a>を参照してください。
    </p><p>
      イベントはスキーマに関連付けられています。<em class="replaceable"><code>event_name</code></em> の一部としてスキーマが示されていない場合は、デフォルトの (現在の) スキーマと見なされます。イベントを特定のスキーマ内に作成するには、<code class="literal"><em class="replaceable"><code>schema_name</code></em>.<em class="replaceable"><code>event_name</code></em></code> 構文を使用して、そのイベント名をスキーマで修飾します。
    </p><p>
      <code class="literal">DEFINER</code> 句は、イベントの実行時にアクセス権限を確認するときに使用される MySQL アカウントを指定します。<em class="replaceable"><code>user</code></em> 値を指定する場合は、<code class="literal">'<em class="replaceable"><code>user_name</code></em>'@'<em class="replaceable"><code>host_name</code></em>'</code> (<code class="literal">GRANT</code> ステートメントで使用されるのと同じ形式)、<code class="literal">CURRENT_USER</code>、または <code class="literal">CURRENT_USER()</code> として指定された MySQL アカウントにしてください。<code class="literal">DEFINER</code> のデフォルト値は、<code class="literal">CREATE EVENT</code> ステートメントを実行するユーザーです。これは、明示的に <code class="literal">DEFINER = CURRENT_USER</code> を指定するのと同じです。
    </p><p>
      <code class="literal">DEFINER</code> 句を指定した場合は、次のルールによって有効な <code class="literal">DEFINER</code> ユーザーの値が決定されます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">SUPER</code> 権限がない場合、許可される唯一の <em class="replaceable"><code>user</code></em> 値は、リテラルで指定するか、または <code class="literal">CURRENT_USER</code> を使用して指定した自分のアカウントです。定義者をほかのアカウントに設定することはできません。
        </p></li><li class="listitem"><p>
          <code class="literal">SUPER</code> 権限がある場合は、構文として有効な任意のアカウント名を指定できます。そのアカウントが実際に存在しない場合は、警告が生成されます。
        </p></li><li class="listitem"><p>
          存在しない <code class="literal">DEFINER</code> アカウントでイベントを作成することはできますが、そのアカウントが存在しない場合は、イベント実行時にエラーが発生します。
        </p></li></ul></div><p>
      イベントのセキュリティーの詳細は、<a class="xref" href="stored-programs-views.html#stored-programs-security" title="20.6 ストアドプログラムおよびビューのアクセスコントロール">セクション20.6「ストアドプログラムおよびビューのアクセスコントロール」</a>を参照してください。
    </p><p>
      イベント内では、<code class="literal">CURRENT_USER()</code> 関数が、イベント実行時に権限を確認するために使用されるアカウント (<code class="literal">DEFINER</code> ユーザー) を返します。イベント内のユーザー監査については、<a class="xref" href="security.html#account-activity-auditing" title="6.3.13 SQL ベースの MySQL アカウントアクティビティーの監査">セクション6.3.13「SQL ベースの MySQL アカウントアクティビティーの監査」</a>を参照してください。
    </p><p>
      <code class="literal">CREATE EVENT</code> での <code class="literal">IF NOT EXISTS</code> には、<code class="literal">CREATE TABLE</code> での場合と同じ意味があります。<em class="replaceable"><code>event_name</code></em> という名前のイベントが同じスキーマ内にすでに存在する場合、アクションは実行されず、エラーも発生しません。(ただし、このような場合は警告が生成されます。)
    </p><p>
      <code class="literal">ON SCHEDULE</code> 句は、そのイベントに対して定義された <em class="replaceable"><code>event_body</code></em> を繰り返す時期、頻度、および期間を決定します。この句は、次の 2 つの形式のいずれかを取ります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          1 回限りのイベントには、<code class="literal">AT <em class="replaceable"><code>timestamp</code></em></code> が使用されます。これは、そのイベントが <em class="replaceable"><code>timestamp</code></em> で指定された日付と時間に 1 回だけ実行されることを指定します。この値は、日付と時間の両方を含んでいるか、または datetime 値に解決される式である必要があります。この目的には、<code class="literal">DATETIME</code> または <code class="literal">TIMESTAMP</code> 型のどちらかの値を使用できます。日付が過去の日付である場合は、次に示すように、警告が発生します。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT NOW();</code></strong>
+---------------------+
| NOW()               |
+---------------------+
| 2006-02-10 23:59:01 |
+---------------------+
1 row in set (0.04 sec)

mysql&gt; <strong class="userinput"><code>CREATE EVENT e_totals</code></strong>
    -&gt;     <strong class="userinput"><code>ON SCHEDULE AT '2006-02-10 23:59:00'</code></strong>
    -&gt;     <strong class="userinput"><code>DO INSERT INTO test.totals VALUES (NOW());</code></strong>
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS\G</code></strong>
*************************** 1. row ***************************
  Level: Note
   Code: 1588
Message: Event execution time is in the past and ON COMPLETION NOT
         PRESERVE is set. The event was dropped immediately after
         creation.
</pre><p>
          どのような理由であれ、それ自体が無効な <code class="literal">CREATE EVENT</code> ステートメントはエラーで失敗します。
        </p><p>
          現在の日付と時間を指定するには、<code class="literal">CURRENT_TIMESTAMP</code> を使用できます。このような場合、イベントは、作成されるとすぐに機能します。
        </p><p>
          現在の日付と時間を基準にした将来のある時点 (<span class="quote">「<span class="quote">今から 3 週間後</span>」</span>というフレーズで表される時点など) に発生するイベントを作成するには、オプションの句 <code class="literal">+ INTERVAL <em class="replaceable"><code>interval</code></em></code> を使用できます。<em class="replaceable"><code>interval</code></em> 部分は、数量と時間単位の 2 つの部分で構成され、<code class="literal">DATE_ADD()</code> 関数で使用される間隔を管理するのと同じ構文ルールに従います (<a class="xref" href="functions.html#date-and-time-functions" title="12.7 日付および時間関数">セクション12.7「日付および時間関数」</a>を参照してください)。また、単位のキーワードも、イベントを定義する場合はマイクロ秒を含む単位を使用できない点を除いて同じです。一部の間隔型では、複合の時間単位を使用できます。たとえば、<span class="quote">「<span class="quote">2 分と 10 秒</span>」</span>は、<code class="literal">+ INTERVAL '2:10' MINUTE_SECOND</code> として表すことができます。
        </p><p>
          また、間隔を組み合わせることもできます。たとえば、<code class="literal">AT CURRENT_TIMESTAMP + INTERVAL 3 WEEK + INTERVAL 2 DAY</code> は、<span class="quote">「<span class="quote">今から 3 週間と 2 日後</span>」</span>と同等です。このような句の各部分は、<code class="literal">+ INTERVAL</code> で始まる必要があります。
        </p></li><li class="listitem"><p>
          アクションを定期的に繰り返すには、<code class="literal">EVERY</code> 句を使用します。<code class="literal">EVERY</code> キーワードのあとに、前の <code class="literal">AT</code> キーワードの説明に示されている <em class="replaceable"><code>interval</code></em> を指定します。(<code class="literal">EVERY</code> では <code class="literal">+ INTERVAL</code> は使用され<span class="emphasis"><em>ません</em></span>。)たとえば、<code class="literal">EVERY 6 WEEK</code> は<span class="quote">「<span class="quote">6 週間ごと</span>」</span>を示します。
        </p><p>
          <code class="literal">EVERY</code> 句では <code class="literal">+ INTERVAL</code> 句は許可されていませんが、<code class="literal">+ INTERVAL</code> 内で許可されているのと同じ複合の時間単位を使用できます。
        </p><p>
          <code class="literal">EVERY</code> 句には、オプションの <code class="literal">STARTS</code> 句を含めることができます。<code class="literal">STARTS</code> のあとに、このアクションがいつ繰り返しを開始するかを示す <em class="replaceable"><code>timestamp</code></em> 値を指定します。また、<code class="literal">+ INTERVAL <em class="replaceable"><code>interval</code></em></code> を使用して、<span class="quote">「<span class="quote">今からの</span>」</span>時間を指定することもできます。たとえば、<code class="literal">EVERY 3 MONTH STARTS CURRENT_TIMESTAMP + INTERVAL 1 WEEK</code> は、<span class="quote">「<span class="quote">今から 1 週間後に開始して 3 か月ごと</span>」</span>を示します。同様に、<span class="quote">「<span class="quote">今から 6 時間と 15 分後から開始して 2 週ごと</span>」</span>を、<code class="literal">EVERY 2 WEEK STARTS CURRENT_TIMESTAMP + INTERVAL '6:15' HOUR_MINUTE</code> として表すことができます。<code class="literal">STARTS</code> を指定しないことは、<code class="literal">STARTS CURRENT_TIMESTAMP</code> を使用することと同じです。つまり、イベントに対して指定されたアクションは、そのイベントが作成されるとただちに繰り返しを開始します。
        </p><p>
          <code class="literal">EVERY</code> 句には、オプションの <code class="literal">ENDS</code> 句を含めることができます。<code class="literal">ENDS</code> キーワードのあとに、このイベントがいつ繰り返しを停止するかを MySQL に指示する <em class="replaceable"><code>timestamp</code></em> 値を指定します。また、<code class="literal">ENDS</code> とともに <code class="literal">+ INTERVAL <em class="replaceable"><code>interval</code></em></code> を使用することもできます。たとえば、<code class="literal">EVERY 12 HOUR STARTS CURRENT_TIMESTAMP + INTERVAL 30 MINUTE ENDS CURRENT_TIMESTAMP + INTERVAL 4 WEEK</code> は、<span class="quote">「<span class="quote">今から 30 分後に開始し、今から 4 週間後に終了するまで 12 時間ごと</span>」</span>と同等です。<code class="literal">ENDS</code> を使用しないことは、このイベントがいつまでも実行を続行することを示します。
        </p><p>
          <code class="literal">ENDS</code> は、複合の時間単位に対して <code class="literal">STARTS</code> と同じ構文をサポートします。
        </p><p>
          <code class="literal">EVERY</code> 句では、<code class="literal">STARTS</code> または <code class="literal">ENDS</code>、あるいはその両方を使用できます。また、どちらも使用しないことも可能です。
        </p><p>
          繰り返しイベントがスケジュール間隔内に終了しない場合は、イベントの複数のインスタンスが同時に実行される可能性があります。これが好ましくない場合は、同時インスタンスを回避するためのメカニズムを設けてください。たとえば、<code class="literal">GET_LOCK()</code> 関数や、行またはテーブルのロックを使用できます。
        </p></li></ul></div><p>
      <code class="literal">ON SCHEDULE</code> 句では、組み込みの MySQL 関数やユーザー変数を含む式を使用して、そこに含まれているすべての <em class="replaceable"><code>timestamp</code></em> または <em class="replaceable"><code>interval</code></em> 値を取得できます。このような式でストアドファンクションやユーザー定義関数を使用したり、テーブル参照を使用したりすることはできません。ただし、<code class="literal">SELECT FROM DUAL</code> は使用できます。これは、<code class="literal">CREATE EVENT</code> ステートメントと <code class="literal">ALTER EVENT</code> ステートメントの両方に当てはまります。このような場合のストアドファンクション、ユーザー定義関数、およびテーブルへの参照は明確に禁止されており、エラーで失敗します (Bug #22830 を参照してください)。
    </p><p>
      <code class="literal">ON SCHEDULE</code> 句の時間は、現在のセッションの <code class="literal">time_zone</code> 値を使用して解釈されます。これがイベントのタイムゾーン、つまり、イベントのスケジューリングに使用され、イベントが実行されるとそのイベント内で有効になるタイムゾーンになります。これらの時間は UTC に変換され、イベントのタイムゾーンとともに <code class="literal">mysql.event</code> テーブル内に格納されます。これにより、サーバータイムゾーンまたはサマータイムの影響に対し生じた変更とは無関係に、定義されたとおりにイベントの実行を処理できます。イベントの時間の表現の詳細は、<a class="xref" href="stored-programs-views.html#events-metadata" title="20.4.4 イベントメタデータ">セクション20.4.4「イベントメタデータ」</a>を参照してください。<a class="xref" href="sql-syntax.html#show-events" title="13.7.5.19 SHOW EVENTS 構文">セクション13.7.5.19「SHOW EVENTS 構文」</a>および<a class="xref" href="information-schema.html#events-table" title="21.7 INFORMATION_SCHEMA EVENTS テーブル">セクション21.7「INFORMATION_SCHEMA EVENTS テーブル」</a>も参照してください。
    </p><p>
      通常は、イベントの期限が切れると、そのイベントはただちに削除されます。この動作は、<code class="literal">ON COMPLETION PRESERVE</code> を指定することによってオーバーライドできます。<code class="literal">ON COMPLETION NOT PRESERVE</code> を使用すると、単にデフォルトの非持続性の動作が明示的になるだけです。
    </p><p>
      <code class="literal">DISABLE</code> キーワードを使用すると、イベントは作成するが、それがアクティブにならないようにすることができます。あるいは、<code class="literal">ENABLE</code> を使用して、デフォルトステータス (アクティブ) を明示的にすることもできます。これは、<code class="literal">ALTER EVENT</code> と組み合わせるともっとも有効です (<a class="xref" href="sql-syntax.html#alter-event" title="13.1.2 ALTER EVENT 構文">セクション13.1.2「ALTER EVENT 構文」</a>を参照してください)。
    </p><p>
      <code class="literal">ENABLE</code> や <code class="literal">DISABLE</code> の代わりに 3 番目の値を使用することもできます。<code class="literal">DISABLE ON SLAVE</code> は、イベントがマスター上で作成されてスレーブにレプリケートされたが、まだスレーブ上で実行されていないことを示すために、レプリケーションスレーブ上のイベントのステータスに対して設定されます。<a class="xref" href="replication.html#replication-features-invoked" title="17.4.1.11 呼び出される機能のレプリケーション">セクション17.4.1.11「呼び出される機能のレプリケーション」</a>を参照してください。
    </p><p>
      <code class="literal">COMMENT</code> 句を使用して、イベントに対するコメントを指定できます。<em class="replaceable"><code>comment</code></em> には、イベントの説明に使用する、最大 64 文字の任意の文字列を指定できます。コメントテキストは文字列リテラルであるため、引用符で囲む必要があります。
    </p><p>
      <code class="literal">DO</code> 句は、イベントによって実行されるアクションを指定するものであり、SQL ステートメントで構成されます。ストアドルーチンで使用できる有効な MySQL ステートメントのほぼすべてを、スケジュールされたイベントのアクションステートメントとしても使用できます。(<a class="xref" href="restrictions.html#stored-program-restrictions" title="D.1 ストアドプログラムの制約">セクションD.1「ストアドプログラムの制約」</a>を参照してください。)たとえば、次のイベント <code class="literal">e_hourly</code> は、<code class="literal">sessions</code> テーブルのすべての行を 1 時間に 1 回削除します。ここで、このテーブルは <code class="literal">site_activity</code> スキーマの一部です。
    </p><pre class="programlisting">
CREATE EVENT e_hourly
    ON SCHEDULE
      EVERY 1 HOUR
    COMMENT 'Clears out sessions table each hour.'
    DO
      DELETE FROM site_activity.sessions;
</pre><p>
      MySQL は、イベントが作成または変更されたときの有効な <code class="literal">sql_mode</code> システム変数の設定を格納し、<span class="emphasis"><em>イベントが実行を開始したときの現在のサーバー SQL モードには関係なく</em></span>、常にそのイベントを強制的にこの設定で実行します。
    </p><p>
      <code class="literal">DO</code> 句に <code class="literal">ALTER EVENT</code> ステートメントを含む <code class="literal">CREATE EVENT</code> ステートメントは成功したように見えます。ただし、結果として得られるスケジュールされたイベントをサーバーが実行しようとすると、その実行はエラーで失敗します。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        単に結果セットを返す <code class="literal">SELECT</code> や <code class="literal">SHOW</code> などのステートメントは、イベントで使用されても何の効果もありません。これらのステートメントからの出力は MySQL モニターに送信されず、またどこにも格納されません。ただし、結果を格納する <code class="literal">SELECT ... INTO</code> や <code class="literal">INSERT INTO ... SELECT</code> などのステートメントは使用できます。(後者の例については、このセクションにある次の例を参照してください。)
      </p></div><p>
      イベントが属するスキーマは、<code class="literal">DO</code> 句でのテーブル参照のためのデフォルトスキーマです。ほかのスキーマでのテーブルへの参照はすべて、正しいスキーマ名で修飾する必要があります。
    </p><p>
      次に示すように、ストアドルーチンと同様に、<code class="literal">BEGIN</code> および <code class="literal">END</code> キーワードを使用して <code class="literal">DO</code> 句で複合ステートメントの構文を使用できます。
    </p><pre class="programlisting">
delimiter |

CREATE EVENT e_daily
    ON SCHEDULE
      EVERY 1 DAY
    COMMENT 'Saves total number of sessions then clears the table each day'
    DO
      BEGIN
        INSERT INTO site_activity.totals (time, total)
          SELECT CURRENT_TIMESTAMP, COUNT(*)
            FROM site_activity.sessions;
        DELETE FROM site_activity.sessions;
      END |

delimiter ;
</pre><p>
      この例では、<code class="literal">delimiter</code> コマンドを使用して、ステートメント区切り文字を変更します。<a class="xref" href="stored-programs-views.html#stored-programs-defining" title="20.1 ストアドプログラムの定義">セクション20.1「ストアドプログラムの定義」</a>を参照してください。
    </p><p>
      イベントでは、ストアドルーチンで使用されているような、より複雑な複合ステートメントを使用できます。この例では、ローカル変数、エラーハンドラ、およびフロー制御構造構文を使用しています。
    </p><pre class="programlisting">
delimiter |

CREATE EVENT e
    ON SCHEDULE
      EVERY 5 SECOND
    DO
      BEGIN
        DECLARE v INTEGER;
        DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN END;

        SET v = 0;

        WHILE v &lt; 5 DO
          INSERT INTO t1 VALUES (0);
          UPDATE t2 SET s1 = s1 + 1;
          SET v = v + 1;
        END WHILE;
    END |

delimiter ;
</pre><p>
      イベントに、またはイベントから直接パラメータを渡す方法はありませんが、パラメータを持つストアドルーチンをイベント内で呼び出すことは可能です。
    </p><pre class="programlisting">
CREATE EVENT e_call_myproc
    ON SCHEDULE
      AT CURRENT_TIMESTAMP + INTERVAL 1 DAY
    DO CALL myproc(5, 27);
</pre><p>
      イベントの定義者に <code class="literal">SUPER</code> 権限がある場合、そのイベントはグローバル変数の読み取りおよび書き込みが可能です。この権限を付与すると悪用される可能性があるため、これを行う場合は十分に注意する必要があります。
    </p><p>
      一般に、ストアドルーチンで有効なすべてのステートメントを、イベントによって実行されるアクションステートメントに使用できます。ストアドルーチン内で許可されるステートメントの詳細は、<a class="xref" href="stored-programs-views.html#stored-routines-syntax" title="20.2.1 ストアドルーチンの構文">セクション20.2.1「ストアドルーチンの構文」</a>を参照してください。ストアドルーチンの一部としてイベントを作成できますが、イベントを別のイベントで作成することはできません。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="create-function"></a>13.1.12 CREATE FUNCTION 構文</h3></div></div></div><p>
      <code class="literal">CREATE FUNCTION</code> ステートメントは、ストアドファンクションやユーザー定義関数 (UDF) を作成するために使用されます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ストアドファンクションの作成については、<a class="xref" href="sql-syntax.html#create-procedure" title="13.1.15 CREATE PROCEDURE および CREATE FUNCTION 構文">セクション13.1.15「CREATE PROCEDURE および CREATE FUNCTION 構文」</a>を参照してください。
        </p></li><li class="listitem"><p>
          ユーザー定義関数の作成については、<a class="xref" href="sql-syntax.html#create-function-udf" title="13.7.3.1 ユーザー定義関数のための CREATE FUNCTION 構文">セクション13.7.3.1「ユーザー定義関数のための CREATE FUNCTION 構文」</a>を参照してください。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="create-index"></a>13.1.13 CREATE INDEX 構文</h3></div></div></div><a class="indexterm" name="idm139979088639872"></a><a class="indexterm" name="idm139979088638560"></a><a class="indexterm" name="idm139979088637104"></a><a class="indexterm" name="idm139979088635072"></a><pre class="programlisting">
CREATE [ONLINE|OFFLINE] [UNIQUE|FULLTEXT|SPATIAL] INDEX <em class="replaceable"><code>index_name</code></em>
    [<em class="replaceable"><code>index_type</code></em>]
    ON <em class="replaceable"><code>tbl_name</code></em> (<em class="replaceable"><code>index_col_name</code></em>,...)
    [<em class="replaceable"><code>index_option</code></em>]
    [<em class="replaceable"><code>algorithm_option</code></em> | <em class="replaceable"><code>lock_option</code></em>] ...

<em class="replaceable"><code>index_col_name</code></em>:
    <em class="replaceable"><code>col_name</code></em> [(<em class="replaceable"><code>length</code></em>)] [ASC | DESC]

<em class="replaceable"><code>index_type</code></em>:
    USING {BTREE | HASH}

<em class="replaceable"><code>index_option</code></em>:
    KEY_BLOCK_SIZE [=] <em class="replaceable"><code>value</code></em>
  | <em class="replaceable"><code>index_type</code></em>
  | WITH PARSER <em class="replaceable"><code>parser_name</code></em>
  | COMMENT '<em class="replaceable"><code>string</code></em>'

<em class="replaceable"><code>algorithm_option</code></em>:
    ALGORITHM [=] {DEFAULT|INPLACE|COPY}

<em class="replaceable"><code>lock_option</code></em>:
    LOCK [=] {DEFAULT|NONE|SHARED|EXCLUSIVE}
</pre><p>
      <code class="literal">CREATE INDEX</code> は、インデックスを作成するために <code class="literal">ALTER TABLE</code> ステートメントにマップされます。<a class="xref" href="sql-syntax.html#alter-table" title="13.1.7 ALTER TABLE 構文">セクション13.1.7「ALTER TABLE 構文」</a>を参照してください。<code class="literal">CREATE INDEX</code> を使用して <code class="literal">PRIMARY KEY</code> を作成することはできません。代わりに <code class="literal">ALTER TABLE</code> を使用します。インデックスの詳細は、<a class="xref" href="optimization.html#mysql-indexes" title="8.3.1 MySQL のインデックスの使用の仕組み">セクション8.3.1「MySQL のインデックスの使用の仕組み」</a>を参照してください。
    </p><p>
      通常、テーブル上のすべてのインデックスは、そのテーブル自体が <code class="literal">CREATE TABLE</code> で作成された時点で作成します。<a class="xref" href="sql-syntax.html#create-table" title="13.1.17 CREATE TABLE 構文">セクション13.1.17「CREATE TABLE 構文」</a>を参照してください。このガイドラインは、主キーによってデータファイル内の行の物理配列が決定される <code class="literal">InnoDB</code> テーブルの場合に特に重要です。<code class="literal">CREATE INDEX</code> では、既存のテーブルにインデックスを追加できます。
    </p><p>
      <code class="literal">(col1,col2,...)</code> という形式のカラムリストは、マルチカラムインデックスを作成します。インデックスキーの値は、特定のカラムの値を連結することによって形成されます。
    </p><p>
      <code class="literal"><em class="replaceable"><code>col_name</code></em>(<em class="replaceable"><code>length</code></em>)</code> 構文を使用してインデックスプリフィクス長を指定することにより、カラム値の先頭の部分のみを使用するインデックスを作成できます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          プリフィクスは、<code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、<code class="literal">BINARY</code>、および <code class="literal">VARBINARY</code> カラムに対して指定できます。
        </p></li><li class="listitem"><p>
          <code class="literal">BLOB</code> および <code class="literal">TEXT</code> カラムにもインデックスを設定できますが、プリフィクス長を指定する<span class="emphasis"><em>必要があります</em></span>。
        </p></li><li class="listitem"><p>
          プリフィクス長は、バイナリ以外の文字列型の場合は文字数で、バイナリ文字列型の場合はバイト単位で指定されます。つまり、インデックスエントリは、<code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、および <code class="literal">TEXT</code> カラムの場合は各カラム値の最初の <em class="replaceable"><code>length</code></em> 文字、<code class="literal">BINARY</code>、<code class="literal">VARBINARY</code>、および <code class="literal">BLOB</code> カラムの場合は各カラム値の最初の <em class="replaceable"><code>length</code></em> バイトで構成されます。
        </p></li><li class="listitem"><p>
          このセクションのあとの方で説明されているように、空間カラムの場合はプリフィクス値を指定できません。
        </p></li></ul></div><p>
      次に示すステートメントは、<code class="literal">name</code> カラムの最初の 10 文字を使用してインデックスを作成します。
    </p><pre class="programlisting">
CREATE INDEX part_of_name ON customer (name(10));
</pre><p>
      カラム内の名前が一般に最初の 10 文字と異なっている場合は、このインデックスが、<code class="literal">name</code> カラム全体から作成されたインデックスよりはるかに遅いことはないはずです。また、インデックスにカラムプリフィクスを使用するとインデックスファイルをはるかに小さくできるため、多くのディスク領域が節約されるだけでなく、<code class="literal">INSERT</code> 操作も高速化される可能性があります。
    </p><p>
      プリフィクスのサポートやプリフィクスの長さ (サポートされている場合) は、ストレージエンジンに依存します。たとえば、<code class="literal">InnoDB</code> テーブルではプリフィクスの長さを最大 767 バイトに、また <code class="literal">innodb_large_prefix</code> オプションが有効になっている場合は 3072 バイトにすることができます。MyISAM テーブルの場合、プリフィクスの制限は 1000 バイトです。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        プリフィクスの制限がバイト単位で測定されるのに対して、<code class="literal">CREATE INDEX</code> ステートメントでのプリフィクス長は、バイナリ以外のデータ型 (<code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、<code class="literal">TEXT</code>) では文字数として解釈されます。複数バイトの文字セットを使用するカラムのプリフィクス長を指定する場合は、この点を考慮に入れてください。
      </p></div><p>
      <code class="literal">NDBCLUSTER</code> テーブルの可変幅カラム上のインデックスはオンラインで、つまり、テーブルコピーを行うことなく作成されます。このテーブルは、この操作の期間中、<span class="emphasis"><em>同じ</em></span> API ノードに対するほかの操作に対してロックされますが、ほかの MySQL Cluster API ノードからのアクセスに対してはロックされません。これは、サーバーが実行できると判断した場合は常に、そのサーバーによって自動的に実行されます。これを実行するために、特殊な SQL 構文やサーバーオプションを使用する必要はありません。
    </p><p>
      標準の MySQL 5.6 リリースでは、サーバーがテーブルコピーなしでインデックスを作成すると決定したとき、そのサーバーをオーバーライドすることはできません。MySQL Cluster では、<code class="literal">OFFLINE</code> キーワードを使用してインデックスをオフラインで作成できます (これにより、そのテーブルはクラスタ内のすべての API ノードに対してロックされます)。<code class="literal">CREATE OFFLINE INDEX</code> および <code class="literal">CREATE ONLINE INDEX</code> を管理するルールや制限は、<code class="literal">ALTER OFFLINE TABLE ... ADD INDEX</code> および <code class="literal">ALTER ONLINE TABLE ... ADD INDEX</code> の場合と同じです。<code class="literal">ONLINE</code> キーワードを使用して、通常はオフラインで作成されるインデックスのコピーなし作成が実行されるようにすることはできません。<code class="literal">CREATE INDEX</code> 操作をテーブルコピーなしで実行できない場合、サーバーは <code class="literal">ONLINE</code> キーワードを無視します。詳細は、<a class="xref" href="sql-syntax.html#alter-table-online-operations" title="13.1.7.2 MySQL Cluster での ALTER TABLE オンライン操作">セクション13.1.7.2「MySQL Cluster での ALTER TABLE オンライン操作」</a>を参照してください。
    </p><p>
      <code class="literal">ONLINE</code> および <code class="literal">OFFLINE</code> キーワードは、MySQL Cluster でのみ使用できます。これらのキーワードを標準の MySQL Server 5.6 リリースで使用しようとすると、構文エラーが発生します。<code class="literal">ONLINE</code> および <code class="literal">OFFLINE</code> キーワードは、MySQL Cluster NDB 7.3 では非推奨です。MySQL Cluster NDB 7.4 では引き続きサポートされますが、将来の MySQL Cluster リリースで削除される可能性があります。
    </p><p>
      <code class="literal">UNIQUE</code> インデックスは、そのインデックス内のすべての値が異なっている必要があるという制約を作成します。既存の行に一致するキー値を持つ新しい行を追加しようとすると、エラーが発生します。すべてのエンジンについて、<code class="literal">UNIQUE</code> インデックスは、<code class="literal">NULL</code> を含むことができるカラムでの複数の <code class="literal">NULL</code> 値を許可します。<code class="literal">UNIQUE</code> インデックス内のカラムのプリフィクス値を指定する場合は、カラム値がプリフィクス内で一意である必要があります。
    </p><p>
      <code class="literal">FULLTEXT</code> インデックスは <code class="literal">InnoDB</code> および <code class="literal">MyISAM</code> テーブルでのみサポートされ、<code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、および <code class="literal">TEXT</code> カラムのみを含めることができます。インデックス設定は常に、カラム全体に対して実行されます。カラムプリフィクスのインデックス設定はサポートされていないため、プリフィクス長が指定されてもすべて無視されます。操作の詳細は、<a class="xref" href="functions.html#fulltext-search" title="12.9 全文検索関数">セクション12.9「全文検索関数」</a>を参照してください。
    </p><p>
      <code class="literal">MyISAM</code>、<code class="literal">InnoDB</code>、<code class="literal">NDB</code>、および <code class="literal">ARCHIVE</code> ストレージエンジンは、<code class="literal">POINT</code> や <code class="literal">GEOMETRY</code> などの空間カラムをサポートしています。(<a class="xref" href="data-types.html#spatial-extensions" title="11.5 空間データの拡張">セクション11.5「空間データの拡張」</a>では、空間データ型について説明しています。)ただし、空間カラムのインデックス設定に対するサポートはエンジンによって異なります。空間および非空間インデックスは、次のルールに従って使用できます。
    </p><p>
      (<code class="literal">SPATIAL INDEX</code> を使用して作成された) 空間インデックスには、次の特性があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">MyISAM</code> テーブルでのみ使用できます。その他のストレージエンジンに対して <code class="literal">SPATIAL INDEX</code> を指定すると、エラーが発生します。
        </p></li><li class="listitem"><p>
          インデックス付きカラムは <code class="literal">NOT NULL</code> である必要があります。
        </p></li><li class="listitem"><p>
          MySQL 5.6 では、カラムプリフィクス長は禁止されています。各カラムの幅全体にインデックスが設定されます。
        </p></li></ul></div><p>
      <code class="literal">INDEX</code>、<code class="literal">UNIQUE</code>、または <code class="literal">PRIMARY KEY</code> で作成された非空間インデックスの特性は次のとおりです。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">ARCHIVE</code> を除く空間カラムをサポートするすべてのストレージエンジンに対して許可されます。
        </p></li><li class="listitem"><p>
          インデックスが主キーでないかぎり、カラムを <code class="literal">NULL</code> にすることができます。
        </p></li><li class="listitem"><p>
          <code class="literal">POINT</code> カラムを除く非 <code class="literal">SPATIAL</code> インデックス内の空間カラムごとに、カラムプリフィクス長を指定する必要があります。(これは、インデックス付き <code class="literal">BLOB</code> カラムの場合と同じ要件です。)プリフィクス長は、バイト単位で指定されます。
        </p></li><li class="listitem"><p>
          非 <code class="literal">SPATIAL</code> インデックスのインデックスタイプは、ストレージエンジンによって異なります。現在は、B ツリーが使用されます。
        </p></li></ul></div><p>
      MySQL 5.6 では次のとおりです。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">NULL</code> 値を持つことができるカラムにインデックスを追加できるのは、<code class="literal">InnoDB</code>、<code class="literal">MyISAM</code>、または <code class="literal">MEMORY</code> ストレージエンジンを使用している場合だけです。
        </p></li><li class="listitem"><p>
          <code class="literal">BLOB</code> または <code class="literal">TEXT</code> カラムにインデックスを追加できるのは、<code class="literal">InnoDB</code> または <code class="literal">MyISAM</code> ストレージエンジンを使用している場合だけです。
        </p></li><li class="listitem"><p>
          <code class="literal">innodb_stats_persistent</code> 設定が有効になっている場合は、<code class="literal">InnoDB</code> テーブル上でインデックスを作成したあと、そのテーブルに対して <code class="literal">ANALYZE TABLE</code> ステートメントを実行します。
        </p></li></ul></div><p>
      <em class="replaceable"><code>index_col_name</code></em> の指定を <code class="literal">ASC</code> または <code class="literal">DESC</code> で終了させることができます。これらのキーワードは、インデックス値の昇順または降順での格納を指定する将来の拡張のために許可されています。現在、これらは解析されますが、無視されます。インデックス値は、常に昇順で格納されます。
    </p><p>
      インデックスカラムリストのあとに、インデックスオプションを指定できます。<em class="replaceable"><code>index_option</code></em> 値には、次のいずれかを指定できます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">KEY_BLOCK_SIZE [=] <em class="replaceable"><code>value</code></em></code>
        </p><p>
          オプションで、インデックスキーのブロックに使用するサイズをバイト単位で指定します。この値はヒントとして扱われます。必要に応じて、異なるサイズが使用される可能性があります。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            <code class="literal">KEY_BLOCK_SIZE</code> は、<code class="literal">InnoDB</code> に対してテーブルレベルでのみサポートされます。<a class="xref" href="sql-syntax.html#create-table" title="13.1.17 CREATE TABLE 構文">セクション13.1.17「CREATE TABLE 構文」</a>を参照してください。
          </p></div></li><li class="listitem"><p>
          <em class="replaceable"><code>index_type</code></em>
        </p><p>
          一部のストレージエンジンでは、インデックスの作成時にインデックスタイプを指定できます。ストレージエンジンごとにサポートされている許可されるインデックスタイプ値を次の表に示します。複数のインデックスタイプが示されている場合は、最初のものが、インデックスタイプ指示子が指定されないときのデフォルトになります。
        </p><div class="informaltable"><table summary="この表は、ストレージエンジンごとに許可されるインデックスタイプを示しています。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">ストレージエンジン</th><th scope="col">許可されるインデックスタイプ</th></tr></thead><tbody><tr><td scope="row"><code class="literal">InnoDB</code></td><td><code class="literal">BTREE</code></td></tr><tr><td scope="row"><code class="literal">MyISAM</code></td><td><code class="literal">BTREE</code></td></tr><tr><td scope="row"><code class="literal">MEMORY</code>/<code class="literal">HEAP</code></td><td><code class="literal">HASH</code>、<code class="literal">BTREE</code></td></tr><tr><td scope="row"><code class="literal">NDB</code></td><td><code class="literal">HASH</code>、<code class="literal">BTREE</code> (テキストの注を参照してください)</td></tr></tbody></table></div><p>
          例:
        </p><pre class="programlisting">
CREATE TABLE lookup (id INT) ENGINE = MEMORY;
CREATE INDEX id_index ON lookup (id) USING BTREE;
</pre><p>
          <code class="literal">BTREE</code> インデックスは、<code class="literal">NDBCLUSTER</code> ストレージエンジンによって T ツリーインデックスとして実装されます。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            <code class="literal">NDB</code> テーブルカラム上のインデックスの場合、<code class="literal">USING</code> オプションは、一意のインデックスまたは主キーに対してのみ指定できます。<code class="literal">USING HASH</code> は、暗黙的な順序付けされたインデックスが作成されないようにします。それ以外の場合は、<code class="literal">NDB</code> テーブル上に一意のインデックスまたは主キーを作成すると、順序付けされたインデックスとハッシュインデックスの両方が自動的に作成され、それぞれが同じ一連のカラムにインデックスを設定します。
          </p><p>
            つまり、<code class="literal">NULL</code> カラム上の一意のインデックスまたは主キーを使用するクエリーは常に、<code class="literal">NDB</code> によってテーブルのフルスキャンで処理されます。特に、<code class="literal">NDB</code> テーブルの一意のインデックスまたは主キーカラムに関連した <code class="literal">IS NULL</code> または <code class="literal">IS NOT NULL</code> 条件を使用する予定がある場合は、このようなインデックスをすべて <code class="literal">USING HASH</code> なしで作成するようにしてください。
          </p></div><p>
          <em class="replaceable"><code>index_type</code></em> 句を <code class="literal">SPATIAL INDEX</code> とともに使用することはできません。
        </p><p>
          特定のストレージエンジンに対して有効でないインデックスタイプを指定したが、そのエンジンがクエリー結果に影響を与えることなく使用できる使用可能な別のインデックスタイプが存在する場合、エンジンはその使用可能なタイプを使用します。パーサーは <code class="literal">RTREE</code> をタイプ名として認識しますが、現在、これはどのストレージエンジンに対しても指定できません。
        </p><p>
          このオプションを <code class="literal">ON <em class="replaceable"><code>tbl_name</code></em></code> 句の前に使用することは非推奨です。このオプションをこの位置で使用するためのサポートは、将来の MySQL リリースで削除される予定です。<em class="replaceable"><code>index_type</code></em> オプションが前とあとの両方の位置で指定された場合は、最後のオプションが適用されます。
        </p><p>
          <code class="literal">TYPE <em class="replaceable"><code>type_name</code></em></code> は、<code class="literal">USING <em class="replaceable"><code>type_name</code></em></code> のシノニムとして認識されます。ただし、推奨される形式は <code class="literal">USING</code> です。
        </p></li><li class="listitem"><p>
          <code class="literal">WITH PARSER <em class="replaceable"><code>parser_name</code></em></code>
        </p><p>
          このオプションは、<code class="literal">FULLTEXT</code> インデックスとともにのみ使用できます。これは、全文インデックス設定および検索操作に特殊な処理が必要な場合に、パーサープラグインをインデックスに関連付けます。プラグインの作成の詳細は、<a class="xref" href="extending-mysql.html#plugin-api" title="24.2 MySQL プラグイン API">セクション24.2「MySQL プラグイン API」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">COMMENT '<em class="replaceable"><code>string</code></em>'</code>
        </p><p>
          インデックス定義には、最大 1024 文字のオプションのコメントを含めることができます。
        </p></li></ul></div><p>
      MySQL 5.6.6 の時点では、<code class="literal">ALGORITHM</code> および <code class="literal">LOCK</code> 句を指定できます。これらは、テーブルコピーの方法や、インデックスが変更されている間のテーブルの読み取りと書き込みの並列性のレベルに影響を与えます。これらには、<code class="literal">ALTER TABLE</code> ステートメントの場合と同じ意味があります。詳細は、<a class="xref" href="sql-syntax.html#alter-table" title="13.1.7 ALTER TABLE 構文">セクション13.1.7「ALTER TABLE 構文」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="create-logfile-group"></a>13.1.14 CREATE LOGFILE GROUP 構文</h3></div></div></div><a class="indexterm" name="idm139979088442800"></a><pre class="programlisting">
CREATE LOGFILE GROUP <em class="replaceable"><code>logfile_group</code></em>
    ADD UNDOFILE '<em class="replaceable"><code>undo_file</code></em>'
    [INITIAL_SIZE [=] <em class="replaceable"><code>initial_size</code></em>]
    [UNDO_BUFFER_SIZE [=] <em class="replaceable"><code>undo_buffer_size</code></em>]
    [REDO_BUFFER_SIZE [=] <em class="replaceable"><code>redo_buffer_size</code></em>]
    [NODEGROUP [=] <em class="replaceable"><code>nodegroup_id</code></em>]
    [WAIT]
    [COMMENT [=] <em class="replaceable"><code>comment_text</code></em>]
    ENGINE [=] <em class="replaceable"><code>engine_name</code></em>
</pre><p>
      このステートメントは、'<em class="replaceable"><code>undo_file</code></em>' という名前の 1 つの <code class="literal">UNDO</code> ファイルを持つ <em class="replaceable"><code>logfile_group</code></em> という名前の新しいログファイルグループを作成します。<code class="literal">CREATE LOGFILE GROUP</code> ステートメントには、<code class="literal">ADD UNDOFILE</code> 句が 1 つだけ存在します。ログファイルグループの命名を管理するルールについては、<a class="xref" href="language-structure.html#identifiers" title="9.2 スキーマオブジェクト名">セクション9.2「スキーマオブジェクト名」</a>を参照してください。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        すべての MySQL Cluster ディスクデータオブジェクトが同じ名前空間を共有します。つまり、<span class="emphasis"><em>各ディスクデータオブジェクト</em></span>は (単に、特定の型の各ディスクデータオブジェクトというだけでなく)、一意の名前が付けられている必要があります。たとえば、テーブルスペースとログファイルグループを同じ名前にしたり、テーブルスペースとデータファイルを同じ名前にしたりすることはできません。
      </p></div><p>
      MySQL Cluster NDB 7.3 以降では、クラスタあたり、常に 1 つのログファイルグループしか作成できません。(Bug #16386 を参照してください)
    </p><p>
      オプションの <code class="literal">INITIAL_SIZE</code> パラメータは、<code class="literal">UNDO</code> ファイルの初期サイズを設定します。指定されていない場合は、デフォルトで <code class="literal">128M</code> (128M バイト) になります。オプションの <code class="literal">UNDO_BUFFER_SIZE</code> パラメータは、ログファイルグループの <code class="literal">UNDO</code> バッファーで使用されるサイズを設定します。<code class="literal">UNDO_BUFFER_SIZE</code> のデフォルト値は <code class="literal">8M</code> (8M バイト) です。この値が、使用可能なシステムメモリーの量を超えることはできません。これらのパラメータは、どちらもバイト単位で指定されます。MySQL Cluster NDB 7.3.2 以降では、これらの両方またはどちらか一方のあとにオプションで、<code class="filename">my.cnf</code> で使用されるのと同様の、桁を示す 1 文字の略語を指定できます。一般に、これは <code class="literal">M</code> (M バイト) または <code class="literal">G</code> (G バイト) のどちらかの文字です。MySQL Cluster NDB 7.3.2 より前は、これらのオプションの値は数字でしか指定できませんでした。(Bug #13116514、Bug #16104705、Bug #62858)
    </p><p>
      <code class="literal">INITIAL_SIZE</code> と <code class="literal">UNDO_BUFFER_SIZE</code> の両方に使用されるメモリーは、サイズが <code class="literal">SharedGlobalMemory</code> データノード構成パラメータの値によって決定されるグローバルプールから取得されます。これには、<code class="literal">InitialLogFileGroup</code> データノード構成パラメータの設定により、これらのオプションに暗黙的に指定されるデフォルト値もすべて含まれます。
    </p><p>
      <code class="literal">UNDO_BUFFER_SIZE</code> に許可される最大値は 629145600 (600M バイト) です。
    </p><p>
      32 ビットシステム上では、<code class="literal">INITIAL_SIZE</code> のサポートされる最大値は 4294967296 (4G バイト) です。(Bug #29186)
    </p><p>
      <code class="literal">INITIAL_SIZE</code> の許可される最小値は 1048576 (1M バイト) です。
    </p><p>
      <code class="literal">ENGINE</code> オプションは、このログファイルグループによって使用されるストレージエンジンを決定します。ここで、<em class="replaceable"><code>engine_name</code></em> はそのストレージエンジンの名前です。MySQL 5.6 では、これは <code class="literal">NDB</code> (または <code class="literal">NDBCLUSTER</code>) である必要があります。<code class="literal">ENGINE</code> が設定されていない場合、MySQL は、<code class="literal">default_storage_engine</code> サーバーシステム変数 (以前の <code class="literal">storage_engine</code>) で指定されたエンジンを使用しようとします。いずれにしても、エンジンが <code class="literal">NDB</code> または <code class="literal">NDBCLUSTER</code> として指定されていない場合、<code class="literal">CREATE LOGFILE GROUP</code> ステートメントは成功したように見えますが、次に示すように、実際にはログファイルグループの作成に失敗します。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE LOGFILE GROUP lg1</code></strong> 
    -&gt;     <strong class="userinput"><code>ADD UNDOFILE 'undo.dat' INITIAL_SIZE = 10M;</code></strong>
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+-------+------+------------------------------------------------------------------------------------------------+
| Level | Code | Message                                                                                        |
+-------+------+------------------------------------------------------------------------------------------------+
| Error | 1478 | <span class="errortext">Table storage engine 'InnoDB' does not support the create option 'TABLESPACE or LOGFILE GROUP'</span> |
+-------+------+------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>DROP LOGFILE GROUP lg1 ENGINE = NDB;</code></strong>              
<span class="errortext">ERROR 1529 (HY000): Failed to drop LOGFILE GROUP</span>

mysql&gt; <strong class="userinput"><code>CREATE LOGFILE GROUP lg1</code></strong> 
    -&gt;     <strong class="userinput"><code>ADD UNDOFILE 'undo.dat' INITIAL_SIZE = 10M</code></strong>
    -&gt;     <strong class="userinput"><code>ENGINE = NDB;</code></strong>
Query OK, 0 rows affected (2.97 sec)
</pre><p>
      <code class="literal">NDB</code> 以外のストレージエンジンが指定されたときに <code class="literal">CREATE LOGFILE GROUP</code> ステートメントが実際にはエラーを返さず、成功したように見えるという事実は、MySQL Cluster の将来のリリースで対処したいと考えている既知の問題です。
    </p><p>
      <em class="replaceable"><code>REDO_BUFFER_SIZE</code></em>、<code class="literal">NODEGROUP</code>、<code class="literal">WAIT</code>、および <code class="literal">COMMENT</code> は解析されますが、無視されるため、MySQL 5.6 では何の効果もありません。これらのオプションは、将来の拡張のために用意されています。
    </p><p>
      <code class="literal">ENGINE [=] NDB</code> とともに使用された場合は、ログファイルグループとそれに関連付けられた <code class="literal">UNDO</code> ログファイルが各クラスタデータノード上に作成されます。<code class="literal">INFORMATION_SCHEMA.FILES</code> テーブルをクエリーすることによって、<code class="literal">UNDO</code> ファイルが作成されたことを確認したり、それらに関する情報を取得したりできます。例:
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT LOGFILE_GROUP_NAME, LOGFILE_GROUP_NUMBER, EXTRA</code></strong>
    -&gt; <strong class="userinput"><code>FROM INFORMATION_SCHEMA.FILES</code></strong>
    -&gt; <strong class="userinput"><code>WHERE FILE_NAME = 'undo_10.dat';</code></strong>
+--------------------+----------------------+----------------+
| LOGFILE_GROUP_NAME | LOGFILE_GROUP_NUMBER | EXTRA          |
+--------------------+----------------------+----------------+
| lg_3               |                   11 | CLUSTER_NODE=3 |
| lg_3               |                   11 | CLUSTER_NODE=4 |
+--------------------+----------------------+----------------+
2 rows in set (0.06 sec)
</pre><p>
      <code class="literal">CREATE LOGFILE GROUP</code> は、MySQL Cluster のディスクデータストレージでのみ有効です。<a class="xref" href="mysql-cluster.html#mysql-cluster-disk-data" title="18.5.12 MySQL Cluster ディスクデータテーブル">セクション18.5.12「MySQL Cluster ディスクデータテーブル」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="create-procedure"></a>13.1.15 CREATE PROCEDURE および CREATE FUNCTION 構文</h3></div></div></div><a class="indexterm" name="idm139979088373600"></a><a class="indexterm" name="idm139979088372288"></a><pre class="programlisting">
CREATE
    [DEFINER = { <em class="replaceable"><code>user</code></em> | CURRENT_USER }]
    PROCEDURE <em class="replaceable"><code>sp_name</code></em> ([<em class="replaceable"><code>proc_parameter</code></em>[,...]])
    [<em class="replaceable"><code>characteristic</code></em> ...] <em class="replaceable"><code>routine_body</code></em>

CREATE
    [DEFINER = { <em class="replaceable"><code>user</code></em> | CURRENT_USER }]
    FUNCTION <em class="replaceable"><code>sp_name</code></em> ([<em class="replaceable"><code>func_parameter</code></em>[,...]])
    RETURNS <em class="replaceable"><code>type</code></em>
    [<em class="replaceable"><code>characteristic</code></em> ...] <em class="replaceable"><code>routine_body</code></em>

<em class="replaceable"><code>proc_parameter</code></em>:
    [ IN | OUT | INOUT ] <em class="replaceable"><code>param_name</code></em> <em class="replaceable"><code>type</code></em>

<em class="replaceable"><code>func_parameter</code></em>:
    <em class="replaceable"><code>param_name</code></em> <em class="replaceable"><code>type</code></em>

<em class="replaceable"><code>type</code></em>:
    <em class="replaceable"><code>Any valid MySQL data type</code></em>

<em class="replaceable"><code>characteristic</code></em>:
    COMMENT '<em class="replaceable"><code>string</code></em>'
  | LANGUAGE SQL
  | [NOT] DETERMINISTIC
  | { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }
  | SQL SECURITY { DEFINER | INVOKER }

<em class="replaceable"><code>routine_body</code></em>:
    <em class="replaceable"><code>Valid SQL routine statement</code></em>
</pre><p>
      これらのステートメントは、ストアドルーチンを作成します。デフォルトでは、ルーチンはデフォルトデータベースに関連付けられます。ルーチンを明示的に特定のデータベースに関連付けるには、そのルーチンの作成時に、その名前を <em class="replaceable"><code>db_name.sp_name</code></em> として指定します。
    </p><p>
      <code class="literal">CREATE FUNCTION</code> ステートメントはまた、UDF (ユーザー定義関数) をサポートするために MySQL でも使用されます。<a class="xref" href="extending-mysql.html#adding-functions" title="24.3 MySQL への新しい関数の追加">セクション24.3「MySQL への新しい関数の追加」</a>を参照してください。UDF は、外部のストアドファンクションと見なすことができます。ストアドファンクションは、その名前空間を UDF と共有します。各種の関数への参照をサーバーが解釈する方法を記述したルールについては、<a class="xref" href="language-structure.html#function-resolution" title="9.2.4 関数名の構文解析と解決">セクション9.2.4「関数名の構文解析と解決」</a>を参照してください。
    </p><p>
      ストアドプロシージャーを呼び出すには、<code class="literal">CALL</code> ステートメントを使用します (<a class="xref" href="sql-syntax.html#call" title="13.2.1 CALL 構文">セクション13.2.1「CALL 構文」</a>を参照してください)。ストアドファンクションを呼び出すには、式でその関数を参照します。その関数は、式の評価中に値を返します。
    </p><p>
      <code class="literal">CREATE PROCEDURE</code> および <code class="literal">CREATE FUNCTION</code> には、<code class="literal">CREATE ROUTINE</code> 権限が必要です。このセクションのあとの方で説明されているように、<code class="literal">DEFINER</code> 値によっては <code class="literal">SUPER</code> 権限も必要になる可能性があります。バイナリロギングが有効になっている場合は、<a class="xref" href="stored-programs-views.html#stored-programs-logging" title="20.7 ストアドプログラムのバイナリロギング">セクション20.7「ストアドプログラムのバイナリロギング」</a>で説明されているように、<code class="literal">CREATE FUNCTION</code> に <code class="literal">SUPER</code> 権限が必要になることがあります。
    </p><p>
      デフォルトでは、MySQL は、ルーチン作成者に <code class="literal">ALTER ROUTINE</code> および <code class="literal">EXECUTE</code> 権限を自動的に付与します。この動作は、<code class="literal">automatic_sp_privileges</code> システム変数を無効にすることによって変更できます。<a class="xref" href="stored-programs-views.html#stored-routines-privileges" title="20.2.2 ストアドルーチンと MySQL 権限">セクション20.2.2「ストアドルーチンと MySQL 権限」</a>を参照してください。
    </p><p>
      <code class="literal">DEFINER</code> および <code class="literal">SQL SECURITY</code> 句は、このセクションのあとの方で説明されているように、ルーチンの実行時にアクセス権限を確認するときに使用されるセキュリティーコンテキストを指定します。
    </p><p>
      ルーチン名が組み込みの SQL 関数の名前と同じである場合は、そのルーチンを定義するか、またはあとで呼び出すときに名前とそれに続く括弧の間にスペースを使用しないかぎり、構文エラーが発生します。このため、ユーザー独自のストアドルーチンに既存の SQL 関数の名前を使用することは避けてください。
    </p><p>
      <code class="literal">IGNORE_SPACE</code> SQL モードは、ストアドルーチンではなく、組み込み関数に適用されます。ストアドルーチン名のあとのスペースは、<code class="literal">IGNORE_SPACE</code> が有効になっているかどうかには関係なく、常に許可されます。
    </p><p>
      括弧で囲まれたパラメータリストは、常に存在する必要があります。パラメータが存在しない場合は、<code class="literal">()</code> の空のパラメータリストを使用するようにしてください。パラメータ名は大文字と小文字が区別されません。
    </p><p>
      各パラメータは、デフォルトでは <code class="literal">IN</code> パラメータです。それ以外のパラメータを指定するには、パラメータ名の前にキーワード <code class="literal">OUT</code> または <code class="literal">INOUT</code> を使用します。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">IN</code>、<code class="literal">OUT</code>、または <code class="literal">INOUT</code> としてのパラメータの指定は、<code class="literal">PROCEDURE</code> に対してのみ有効です。<code class="literal">FUNCTION</code> の場合、パラメータは常に <code class="literal">IN</code> パラメータと見なされます。
      </p></div><p>
      <code class="literal">IN</code> パラメータは、プロシージャーへの値を渡します。プロシージャーはその値を変更する可能性がありますが、そのプロシージャーから戻ったとき、その変更は呼び出し元に表示されません。<code class="literal">OUT</code> パラメータは、プロシージャーから呼び出し元に値を渡します。その初期値はプロシージャー内では <code class="literal">NULL</code> であり、そのプロシージャーから戻ったとき、その値は呼び出し元に表示されます。<code class="literal">INOUT</code> パラメータは呼び出し元によって初期化され、プロシージャーで変更できます。そのプロシージャーから戻ったとき、プロシージャーによって行われた変更はすべて呼び出し元に表示されます。
    </p><p>
      <code class="literal">OUT</code> または <code class="literal">INOUT</code> パラメータごとに、プロシージャーを呼び出す <code class="literal">CALL</code> ステートメントでユーザー定義変数を渡して、プロシージャーから戻ったときにその値を取得できるようにします。そのプロシージャーを別のストアドプロシージャーまたはストアドファンクション内から呼び出している場合は、<code class="literal">IN</code> または <code class="literal">INOUT</code> パラメータとしてルーチンパラメータまたはローカルルーチン変数を渡すこともできます。
    </p><p>
      ルーチン内に準備されたステートメントでルーチンパラメータを参照することはできません。<a class="xref" href="restrictions.html#stored-program-restrictions" title="D.1 ストアドプログラムの制約">セクションD.1「ストアドプログラムの制約」</a>を参照してください。
    </p><p>
      次の例は、<code class="literal">OUT</code> パラメータを使用する単純なストアドプロシージャーを示しています。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>delimiter //</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE PROCEDURE simpleproc (OUT param1 INT)</code></strong>
    -&gt; <strong class="userinput"><code>BEGIN</code></strong>
    -&gt;   <strong class="userinput"><code>SELECT COUNT(*) INTO param1 FROM t;</code></strong>
    -&gt; <strong class="userinput"><code>END//</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>delimiter ;</code></strong>

mysql&gt; <strong class="userinput"><code>CALL simpleproc(@a);</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT @a;</code></strong>
+------+
| @a   |
+------+
| 3    |
+------+
1 row in set (0.00 sec)
</pre><p>
      この例では、プロシージャーの定義中に <span class="command"><strong>mysql</strong></span> クライアントの <code class="literal">delimiter</code> コマンドを使用して、ステートメント区切り文字を <code class="literal">;</code> から <code class="literal">//</code> に変更しています。これにより、プロシージャー本体で使用される <code class="literal">;</code> 区切り文字を、<span class="command"><strong>mysql</strong></span> 自体が解釈するのではなく、サーバーに渡すようにすることができます。<a class="xref" href="stored-programs-views.html#stored-programs-defining" title="20.1 ストアドプログラムの定義">セクション20.1「ストアドプログラムの定義」</a>を参照してください。
    </p><p>
      <code class="literal">RETURNS</code> 句は、<code class="literal">FUNCTION</code> (これには必須です) に対してのみ指定できます。これは関数の戻り型を示すものであり、関数本体には <code class="literal">RETURN <em class="replaceable"><code>value</code></em></code> ステートメントが含まれている必要があります。<code class="literal">RETURN</code> ステートメントが異なる型の値を返した場合、その値は正しい型に強制的に変更されます。たとえば、ある関数が <code class="literal">RETURNS</code> 句で <code class="literal">ENUM</code> または <code class="literal">SET</code> 値を指定しているが、<code class="literal">RETURN</code> ステートメントが整数を返した場合、その関数から返される値は <code class="literal">SET</code> メンバーのセットの対応する <code class="literal">ENUM</code> メンバーを示す文字列になります。
    </p><p>
      次の関数例はパラメータを受け取り、SQL 関数を使用して操作を実行したあと、結果を返します。この場合は、関数定義に内部の <code class="literal">;</code> ステートメント区切り文字が含まれていないため、<code class="literal">delimiter</code> を使用する必要はありません。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE FUNCTION hello (s CHAR(20))</code></strong>
mysql&gt; <strong class="userinput"><code>RETURNS CHAR(50) DETERMINISTIC</code></strong>
    -&gt; <strong class="userinput"><code>RETURN CONCAT('Hello, ',s,'!');</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT hello('world');</code></strong>
+----------------+
| hello('world') |
+----------------+
| Hello, world!  |
+----------------+
1 row in set (0.00 sec)
</pre><p>
      パラメータ型と関数の戻り型は、任意の有効なデータ型を使用するように宣言できます。前に <code class="literal">CHARACTER SET</code> 属性がある場合は、<code class="literal">COLLATE</code> 属性を使用できます。
    </p><p>
      <em class="replaceable"><code>routine_body</code></em> は、有効な SQL ルーチンステートメントで構成されます。これは <code class="literal">SELECT</code> や <code class="literal">INSERT</code> などの単純なステートメントでも、<code class="literal">BEGIN</code> と <code class="literal">END</code> を使用して記述された複合ステートメントでもかまいません。複合ステートメントには、宣言、ループ、およびその他の制御構造ステートメントを含めることができます。これらのステートメントの構文については、<a class="xref" href="sql-syntax.html#sql-syntax-compound-statements" title="13.6 MySQL 複合ステートメント構文">セクション13.6「MySQL 複合ステートメント構文」</a>で説明されています。
    </p><p>
      MySQL では、ルーチンに <code class="literal">CREATE</code> や <code class="literal">DROP</code> などの DDL ステートメントを含めることが許可されます。MySQL ではまた、ストアドプロシージャーに <code class="literal">COMMIT</code> などの SQL トランザクションステートメントを含めることも許可されます (ただし、ストアドファンクションには許可されません)。ストアドファンクションには、明示的または暗黙的なコミットまたはロールバックを実行するステートメントを含めることはできません。これらのステートメントのサポートは、SQL 標準では必要ありません。SQL 標準では、各 DBMS ベンダーがこれらのステートメントを許可するかどうかを決められると定めています。
    </p><p>
      結果セットを返すステートメントはストアドプロシージャー内で使用できますが、ストアドファンクション内では使用できません。この禁止には、<code class="literal">INTO <em class="replaceable"><code>var_list</code></em></code> 句を含まない <code class="literal">SELECT</code> ステートメントや、<code class="literal">SHOW</code>、<code class="literal">EXPLAIN</code>、<code class="literal">CHECK TABLE</code> などのその他のステートメントが含まれます。結果セットを返すことを関数の定義時に判定できるステートメントの場合は、<code class="literal">Not allowed to return a result set from a function</code> エラーが発生します (<code class="literal">ER_SP_NO_RETSET</code>)。結果セットを返すことを実行時にしか判定できないステートメントの場合は、<code class="literal">PROCEDURE %s can't return a result set in the given context</code> エラーが発生します (<code class="literal">ER_SP_BADSELECT</code>)。
    </p><p>
      ストアドルーチン内での <code class="literal">USE</code> ステートメントは許可されていません。ルーチンが呼び出されると、暗黙的な <code class="literal">USE <em class="replaceable"><code>db_name</code></em></code> が実行されます (また、そのルーチンが終了すると元に戻されます)。これにより、そのルーチンには実行中、特定のデフォルトデータベースが割り当てられます。ルーチンのデフォルトデータベース以外のデータベース内のオブジェクトへの参照は、適切なデータベース名で修飾するようにしてください。
    </p><p>
      ストアドルーチン内では許可されないステートメントの詳細は、<a class="xref" href="restrictions.html#stored-program-restrictions" title="D.1 ストアドプログラムの制約">セクションD.1「ストアドプログラムの制約」</a>を参照してください。
    </p><p>
      MySQL インタフェースを備える言語で記述されたプログラム内からのストアドプロシージャーの呼び出しについては、<a class="xref" href="sql-syntax.html#call" title="13.2.1 CALL 構文">セクション13.2.1「CALL 構文」</a>を参照してください。
    </p><p>
      MySQL は、ルーチンが作成または変更されたときの有効な <code class="literal">sql_mode</code> システム変数の設定を格納し、<span class="emphasis"><em>ルーチンが実行を開始したときの現在のサーバー SQL モードには関係なく</em></span>、常にそのルーチンを強制的にこの設定で実行します。
    </p><p>
      呼び出し元の SQL モードからそのルーチンの SQL モードへの切り替えは、引数を評価し、結果として得られる値をルーチンパラメータに割り当てたあとに実行されます。あるルーチンを厳密な SQL モードで定義したが、その呼び出しを非厳密モードで行なった場合は、引数のルーチンパラメータへの割り当てが厳密モードで実行されません。ルーチンに渡される式を厳密な SQL モードで割り当てる必要がある場合は、そのルーチンを厳密モードが有効な状態で呼び出すようにしてください。
    </p><p>
      <code class="literal">COMMENT</code> 特性は MySQL 拡張であり、そのストアドルーチンの説明のために使用できます。この情報は、<code class="literal">SHOW CREATE PROCEDURE</code> および <code class="literal">SHOW CREATE FUNCTION</code> ステートメントによって表示されます。
    </p><p>
      <code class="literal">LANGUAGE</code> 特性は、そのルーチンが記述されている言語を示します。サーバーはこの特性を無視します。SQL ルーチンのみがサポートされています。
    </p><p>
      ルーチンは、同じ入力パラメータに対して常に同じ結果を生成する場合は<span class="quote">「<span class="quote">決定的</span>」</span>と見なされ、それ以外の場合は<span class="quote">「<span class="quote">非決定的</span>」</span>と見なされます。ルーチン定義で <code class="literal">DETERMINISTIC</code> と <code class="literal">NOT DETERMINISTIC</code> のどちらも指定されていない場合、デフォルトは <code class="literal">NOT DETERMINISTIC</code> になります。関数が決定的であることを宣言するには、明示的に <code class="literal">DETERMINISTIC</code> を指定する必要があります。
    </p><p>
      ルーチンの性質の評価は、作成者の<span class="quote">「<span class="quote">誠実さ</span>」</span>に基づいています。MySQL は、<code class="literal">DETERMINISTIC</code> と宣言されたルーチンに非決定的な結果を生成するステートメントが含まれていないかどうかをチェックしません。ただし、ルーチンの誤った宣言は、その結果やパフォーマンスに影響を与える可能性があります。非決定的なルーチンを <code class="literal">DETERMINISTIC</code> として宣言すると、オプティマイザが正しくない実行計画を選択するために、予期しない結果を招くことがあります。決定的なルーチンを <code class="literal">NONDETERMINISTIC</code> として宣言すると、使用可能な最適化が使用されなくなるために、パフォーマンスが低下することがあります。
    </p><p>
      バイナリロギングが有効になっている場合、<code class="literal">DETERMINISTIC</code> 特性は、MySQL がどのルーチン定義を受け入れるかに影響を与えます。<a class="xref" href="stored-programs-views.html#stored-programs-logging" title="20.7 ストアドプログラムのバイナリロギング">セクション20.7「ストアドプログラムのバイナリロギング」</a>を参照してください。
    </p><p>
      <code class="literal">NOW()</code> 関数 (または、そのシノニム) あるいは <code class="literal">RAND()</code> を含むルーチンは非決定的ですが、引き続きレプリケーションに対して安全である可能性があります。<code class="literal">NOW()</code> の場合、バイナリログにはタイムスタンプが含まれ、正しくレプリケートされます。<code class="literal">RAND()</code> もまた、ルーチンの実行中に 1 回だけ呼び出されるかぎり、正しくレプリケートされます。(ルーチン実行のタイムスタンプや乱数シードは、マスターとスレーブ上で同一の暗黙的な入力と見なすことができます。)
    </p><p>
      いくつかの特性によって、ルーチンによるデータ使用の性質に関する情報が提供されます。MySQL では、これらの特性はアドバイザリにすぎません。サーバーがこれらを使用して、あるルーチンにどのような種類のステートメントの実行を許可するかを制約することはありません。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">CONTAINS SQL</code> は、そのルーチンに、データの読み取りや書き込みを行うステートメントが含まれていないことを示します。これは、これらのどの特性も明示的に指定されていない場合のデフォルトです。このようなステートメントの例として、実行されてもデータの読み取りや書き込みを行わない <code class="literal">SET @x = 1</code> または <code class="literal">DO RELEASE_LOCK('abc')</code> があります。
        </p></li><li class="listitem"><p>
          <code class="literal">NO SQL</code> は、そのルーチンに SQL ステートメントが含まれていないことを示します。
        </p></li><li class="listitem"><p>
          <code class="literal">READS SQL DATA</code> は、そのルーチンに、データを読み取るステートメント (<code class="literal">SELECT</code> など) が含まれているが、データを書き込むステートメントは含まれていないことを示します。
        </p></li><li class="listitem"><p>
          <code class="literal">MODIFIES SQL DATA</code> は、そのルーチンに、データを書き込む可能性のあるステートメント (<code class="literal">INSERT</code> や <code class="literal">DELETE</code> など) が含まれていることを示します。
        </p></li></ul></div><p>
      <code class="literal">SQL SECURITY</code> 特性は、セキュリティーコンテキストを指定する <code class="literal">DEFINER</code> または <code class="literal">INVOKER</code> のどちらかです。これは、そのルーチンがルーチンの <code class="literal">DEFINER</code> 句で指定されたアカウント、またはそのルーチンを呼び出すユーザーのどちらの権限を使用して実行されるかを示します。このアカウントには、そのルーチンが関連付けられているデータベースにアクセスするためのアクセス権が必要です。デフォルト値は <code class="literal">DEFINER</code> です。そのルーチンを呼び出すユーザーには、それに対する <code class="literal">EXECUTE</code> 権限が必要です。また、そのルーチンが定義者のセキュリティーコンテキストで実行される場合は、<code class="literal">DEFINER</code> アカウントにもその権限が必要です。
    </p><p>
      <code class="literal">DEFINER</code> 句は、<code class="literal">SQL SECURITY DEFINER</code> 特性を持つルーチンのルーチン実行時にアクセス権限を確認するときに使用される MySQL アカウントを指定します。
    </p><p>
      <code class="literal">DEFINER</code> 句に <em class="replaceable"><code>user</code></em> 値を指定する場合は、<code class="literal">'<em class="replaceable"><code>user_name</code></em>'@'<em class="replaceable"><code>host_name</code></em>'</code> (<code class="literal">GRANT</code> ステートメントで使用されるのと同じ形式)、<code class="literal">CURRENT_USER</code>、または <code class="literal">CURRENT_USER()</code> として指定された MySQL アカウントにするようにしてください。<code class="literal">DEFINER</code> のデフォルト値は、<code class="literal">CREATE PROCEDURE</code> または <code class="literal">CREATE FUNCTION</code> ステートメントを実行するユーザーです。これは、明示的に <code class="literal">DEFINER = CURRENT_USER</code> を指定するのと同じです。
    </p><p>
      <code class="literal">DEFINER</code> 句を指定した場合は、次のルールによって有効な <code class="literal">DEFINER</code> ユーザーの値が決定されます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">SUPER</code> 権限がない場合、許可される唯一の <em class="replaceable"><code>user</code></em> 値は、リテラルで指定するか、または <code class="literal">CURRENT_USER</code> を使用して指定した自分のアカウントです。定義者をほかのアカウントに設定することはできません。
        </p></li><li class="listitem"><p>
          <code class="literal">SUPER</code> 権限がある場合は、構文として有効な任意のアカウント名を指定できます。そのアカウントが実際に存在しない場合は、警告が生成されます。
        </p></li><li class="listitem"><p>
          存在しない <code class="literal">DEFINER</code> アカウントでルーチンを作成することはできますが、<code class="literal">SQL SECURITY</code> 値が <code class="literal">DEFINER</code> であるが、定義者アカウントが存在しない場合は、ルーチン実行時にエラーが発生します。
        </p></li></ul></div><p>
      ストアドルーチンのセキュリティーの詳細は、<a class="xref" href="stored-programs-views.html#stored-programs-security" title="20.6 ストアドプログラムおよびビューのアクセスコントロール">セクション20.6「ストアドプログラムおよびビューのアクセスコントロール」</a>を参照してください。
    </p><p>
      <code class="literal">SQL SECURITY DEFINER</code> 特性を使用して定義されたストアドルーチン内で、<code class="literal">CURRENT_USER</code> は、そのルーチンの <code class="literal">DEFINER</code> 値を返します。ストアドルーチン内のユーザー監査については、<a class="xref" href="security.html#account-activity-auditing" title="6.3.13 SQL ベースの MySQL アカウントアクティビティーの監査">セクション6.3.13「SQL ベースの MySQL アカウントアクティビティーの監査」</a>を参照してください。
    </p><p>
      <code class="literal">mysql.user</code> テーブルにリストされている MySQL アカウントの数を表示する次のプロシージャーを考えてみます。
    </p><pre class="programlisting">
CREATE DEFINER = 'admin'@'localhost' PROCEDURE account_count()
BEGIN
  SELECT 'Number of accounts:', COUNT(*) FROM mysql.user;
END;
</pre><p>
      このプロシージャーには、それがどのユーザーによって定義されている場合でも、<code class="literal">'admin'@'localhost'</code> の <code class="literal">DEFINER</code> アカウントが割り当てられます。また、それがどのユーザーから呼び出された場合でも、そのアカウントの権限で実行されます (デフォルトのセキュリティー特性は <code class="literal">DEFINER</code> であるため)。このプロシージャーは、呼び出し元にそれに対する <code class="literal">EXECUTE</code> 権限があり、かつ <code class="literal">'admin'@'localhost'</code> に <code class="literal">mysql.user</code> テーブルに対する <code class="literal">SELECT</code> 権限があるかどうかに応じて成功または失敗します。
    </p><p>
      ここで、このプロシージャーが <code class="literal">SQL SECURITY INVOKER</code> 特性を使用して定義されているとします。
    </p><pre class="programlisting">
CREATE DEFINER = 'admin'@'localhost' PROCEDURE account_count()
SQL SECURITY INVOKER
BEGIN
  SELECT 'Number of accounts:', COUNT(*) FROM mysql.user;
END;
</pre><p>
      このプロシージャーは、依然として <code class="literal">'admin'@'localhost'</code> の <code class="literal">DEFINER</code> を持っていますが、この場合は呼び出し元ユーザーの権限で実行されます。そのため、このプロシージャーは、呼び出し元にそれに対する <code class="literal">EXECUTE</code> 権限と、<code class="literal">mysql.user</code> テーブルに対する <code class="literal">SELECT</code> 権限があるかどうかに応じて成功または失敗します。
    </p><p>
      サーバーは、ルーチンパラメータ、<code class="literal">DECLARE</code> を使用して作成されたローカルルーチン変数、または関数の戻り値のデータ型を次のように処理します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          データ型の不一致やオーバーフローがないかどうか割り当てがチェックされます。変換やオーバーフローの問題によって警告が発生するか、または厳密な SQL モードではエラーが発生します。
        </p></li><li class="listitem"><p>
          スカラー値のみを割り当てることができます。たとえば、<code class="literal">SET x = (SELECT 1, 2)</code> などのステートメントは無効です。
        </p></li><li class="listitem"><p>
          文字データ型で、宣言内に <code class="literal">CHARACTER SET</code> 属性が存在する場合は、指定された文字セットとそのデフォルトの照合順序が使用されます。<code class="literal">COLLATE</code> 属性も存在する場合は、デフォルトの照合順序ではなく、その照合順序が使用されます。
        </p><p>
          <code class="literal">CHARACTER SET</code> および <code class="literal">COLLATE</code> 属性が存在しない場合は、ルーチンの作成時に有効なデータベース文字セットおよび照合順序が使用されます。サーバーでデータベース文字セットおよび照合順序が使用されないようにするには、文字データパラメータとして明示的な <code class="literal">CHARACTER SET</code> および <code class="literal">COLLATE</code> 属性を指定します。
        </p><p>
          データベースのデフォルトの文字セットまたは照合順序を変更する場合は、データベースのデフォルトを使用するストアドルーチンを削除および再作成して、それらが新しいデフォルトを使用するようにする必要があります。
        </p><p>
          データベース文字セットおよび照合順序は、<code class="literal">character_set_database</code> および <code class="literal">collation_database</code> システム変数の値で指定されます。詳細は、<a class="xref" href="globalization.html#charset-database" title="10.1.3.2 データベース文字セットおよび照合順序">セクション10.1.3.2「データベース文字セットおよび照合順序」</a>を参照してください。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="create-server"></a>13.1.16 CREATE SERVER 構文</h3></div></div></div><a class="indexterm" name="idm139979088140960"></a><pre class="programlisting">
CREATE SERVER <em class="replaceable"><code>server_name</code></em>
    FOREIGN DATA WRAPPER <em class="replaceable"><code>wrapper_name</code></em>
    OPTIONS (<em class="replaceable"><code>option</code></em> [, <em class="replaceable"><code>option</code></em>] ...)

<em class="replaceable"><code>option</code></em>:
  { HOST <em class="replaceable"><code>character-literal</code></em>
  | DATABASE <em class="replaceable"><code>character-literal</code></em>
  | USER <em class="replaceable"><code>character-literal</code></em>
  | PASSWORD <em class="replaceable"><code>character-literal</code></em>
  | SOCKET <em class="replaceable"><code>character-literal</code></em>
  | OWNER <em class="replaceable"><code>character-literal</code></em>
  | PORT <em class="replaceable"><code>numeric-literal</code></em> }
</pre><p>
      このステートメントは、<code class="literal">FEDERATED</code> ストレージエンジンで使用するためのサーバーの定義を作成します。<code class="literal">CREATE SERVER</code> ステートメントは、<code class="literal">mysql</code> データベース内の <code class="literal">servers</code> テーブルに新しい行を作成します。このステートメントには、<code class="literal">SUPER</code> 権限が必要です。
    </p><p>
      <code class="literal"><em class="replaceable"><code>server_name</code></em></code> は、そのサーバーへの一意の参照にしてください。サーバー定義は、そのサーバーのスコープ内ではグローバルであるため、サーバー定義を特定のデータベースに対して修飾することはできません。<code class="literal"><em class="replaceable"><code>server_name</code></em></code> の最大長は 64 文字であり (64 文字より長い名前は暗黙のうちに切り捨てられます)、大文字小文字を区別しません。この名前は、引用符で囲まれた文字列として指定できます。
    </p><p>
      <code class="literal"><em class="replaceable"><code>wrapper_name</code></em></code> は <code class="literal">mysql</code> にしてください。また、それを単一引用符で囲むことができます。<code class="literal"><em class="replaceable"><code>wrapper_name</code></em></code> に対するその他の値は現在、サポートされていません。
    </p><p>
      各 <code class="literal"><em class="replaceable"><code>option</code></em></code> について、文字リテラルまたは数値リテラルのどちらかを指定する必要があります。文字リテラルは UTF-8 であり、64 文字の最大長をサポートし、デフォルトではブランク (空) の文字列になります。文字列リテラルは、暗黙のうちに 64 文字に切り捨てられます。数値リテラルは 0 から 9999 までの数字である必要があり、デフォルト値は 0 です。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">OWNER</code> オプションは現在、適用されず、作成されるサーバー接続の所有権または操作には影響を与えません。
      </p></div><p>
      <code class="literal">CREATE SERVER</code> ステートメントは、<code class="literal">mysql.servers</code> テーブル内にエントリを作成します。これは、あとで <code class="literal">FEDERATED</code> テーブルを作成するときに <code class="literal">CREATE TABLE</code> ステートメントで使用できます。指定したオプションは、<code class="literal">mysql.servers</code> テーブル内のカラムを移入するために使用されます。テーブルカラムは、<code class="literal">Server_name</code>、<code class="literal">Host</code>、<code class="literal">Db</code>、<code class="literal">Username</code>、<code class="literal">Password</code>、<code class="literal">Port</code>、および <code class="literal">Socket</code> です。
    </p><p>
      例:
    </p><pre class="programlisting">
CREATE SERVER s
FOREIGN DATA WRAPPER mysql
OPTIONS (USER 'Remote', HOST '192.168.1.106', DATABASE 'test');
</pre><p>
      サーバーへの接続を確立するために必要なすべてのオプションを指定する必要があります。ユーザー名、ホスト名、およびデータベース名は必須です。パスワードなどの、その他のオプションも必要になる可能性があります。
    </p><p>
      このテーブルに格納されたデータは、<code class="literal">FEDERATED</code> テーブルへの接続を作成するときに使用できます。
    </p><pre class="programlisting">CREATE TABLE t (s1 INT) ENGINE=FEDERATED CONNECTION='s';</pre><p>
      詳細は、<a class="xref" href="storage-engines.html#federated-storage-engine" title="15.8 FEDERATED ストレージエンジン">セクション15.8「FEDERATED ストレージエンジン」</a>を参照してください。
    </p><p>
      <code class="literal">CREATE SERVER</code> では、自動コミットが実行されます。
    </p><p>
      MySQL 5.6 では、使用されているロギング形式には関係なく、<code class="literal">CREATE SERVER</code> はバイナリログに書き込まれません。
    </p><p>
      MySQL 5.6.11 でのみ、このステートメントを発行する前に、<code class="literal">gtid_next</code> を <code class="literal">AUTOMATIC</code> に設定する必要があります。(Bug #16062608、Bug #16715809、Bug #69045)
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="create-table"></a>13.1.17 CREATE TABLE 構文</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-syntax.html#create-table-select">13.1.17.1 CREATE TABLE ... SELECT 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-table-foreign-keys">13.1.17.2 外部キー制約の使用</a></span></dt><dt><span class="section"><a href="sql-syntax.html#silent-column-changes">13.1.17.3 暗黙のカラム指定の変更</a></span></dt></dl></div><a class="indexterm" name="idm139979088093616"></a><pre class="programlisting">
CREATE [TEMPORARY] TABLE [IF NOT EXISTS] <em class="replaceable"><code>tbl_name</code></em>
    (<em class="replaceable"><code>create_definition</code></em>,...)
    [<em class="replaceable"><code>table_options</code></em>]
    [<em class="replaceable"><code>partition_options</code></em>]

CREATE [TEMPORARY] TABLE [IF NOT EXISTS] <em class="replaceable"><code>tbl_name</code></em>
    [(<em class="replaceable"><code>create_definition</code></em>,...)]
    [<em class="replaceable"><code>table_options</code></em>]
    [<em class="replaceable"><code>partition_options</code></em>]
    <em class="replaceable"><code>select_statement</code></em>

CREATE [TEMPORARY] TABLE [IF NOT EXISTS] <em class="replaceable"><code>tbl_name</code></em>
    { LIKE <em class="replaceable"><code>old_tbl_name</code></em> | (LIKE <em class="replaceable"><code>old_tbl_name</code></em>) }

<em class="replaceable"><code>create_definition</code></em>:
    <em class="replaceable"><code>col_name</code></em> <em class="replaceable"><code>column_definition</code></em>
  | [CONSTRAINT [<em class="replaceable"><code>symbol</code></em>]] PRIMARY KEY [<em class="replaceable"><code>index_type</code></em>] (<em class="replaceable"><code>index_col_name</code></em>,...)
      [<em class="replaceable"><code>index_option</code></em>] ...
  | {INDEX|KEY} [<em class="replaceable"><code>index_name</code></em>] [<em class="replaceable"><code>index_type</code></em>] (<em class="replaceable"><code>index_col_name</code></em>,...)
      [<em class="replaceable"><code>index_option</code></em>] ...
  | [CONSTRAINT [<em class="replaceable"><code>symbol</code></em>]] UNIQUE [INDEX|KEY]
      [<em class="replaceable"><code>index_name</code></em>] [<em class="replaceable"><code>index_type</code></em>] (<em class="replaceable"><code>index_col_name</code></em>,...)
      [<em class="replaceable"><code>index_option</code></em>] ...
  | {FULLTEXT|SPATIAL} [INDEX|KEY] [<em class="replaceable"><code>index_name</code></em>] (<em class="replaceable"><code>index_col_name</code></em>,...)
      [<em class="replaceable"><code>index_option</code></em>] ...
  | [CONSTRAINT [<em class="replaceable"><code>symbol</code></em>]] FOREIGN KEY
      [<em class="replaceable"><code>index_name</code></em>] (<em class="replaceable"><code>index_col_name</code></em>,...) <em class="replaceable"><code>reference_definition</code></em>
  | CHECK (<em class="replaceable"><code>expr</code></em>)

<em class="replaceable"><code>column_definition</code></em>:
    <em class="replaceable"><code>data_type</code></em> [NOT NULL | NULL] [DEFAULT <em class="replaceable"><code>default_value</code></em>]
      [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY]
      [COMMENT '<em class="replaceable"><code>string</code></em>']
      [COLUMN_FORMAT {FIXED|DYNAMIC|DEFAULT}]
      [STORAGE {DISK|MEMORY|DEFAULT}]
      [<em class="replaceable"><code>reference_definition</code></em>]

<em class="replaceable"><code>data_type</code></em>:
    BIT[(<em class="replaceable"><code>length</code></em>)]
  | TINYINT[(<em class="replaceable"><code>length</code></em>)] [UNSIGNED] [ZEROFILL]
  | SMALLINT[(<em class="replaceable"><code>length</code></em>)] [UNSIGNED] [ZEROFILL]
  | MEDIUMINT[(<em class="replaceable"><code>length</code></em>)] [UNSIGNED] [ZEROFILL]
  | INT[(<em class="replaceable"><code>length</code></em>)] [UNSIGNED] [ZEROFILL]
  | INTEGER[(<em class="replaceable"><code>length</code></em>)] [UNSIGNED] [ZEROFILL]
  | BIGINT[(<em class="replaceable"><code>length</code></em>)] [UNSIGNED] [ZEROFILL]
  | REAL[(<em class="replaceable"><code>length</code></em>,<em class="replaceable"><code>decimals</code></em>)] [UNSIGNED] [ZEROFILL]
  | DOUBLE[(<em class="replaceable"><code>length</code></em>,<em class="replaceable"><code>decimals</code></em>)] [UNSIGNED] [ZEROFILL]
  | FLOAT[(<em class="replaceable"><code>length</code></em>,<em class="replaceable"><code>decimals</code></em>)] [UNSIGNED] [ZEROFILL]
  | DECIMAL[(<em class="replaceable"><code>length</code></em>[,<em class="replaceable"><code>decimals</code></em>])] [UNSIGNED] [ZEROFILL]
  | NUMERIC[(<em class="replaceable"><code>length</code></em>[,<em class="replaceable"><code>decimals</code></em>])] [UNSIGNED] [ZEROFILL]
  | DATE
  | TIME[(<em class="replaceable"><code>fsp</code></em>)]
  | TIMESTAMP[(<em class="replaceable"><code>fsp</code></em>)]
  | DATETIME[(<em class="replaceable"><code>fsp</code></em>)]
  | YEAR
  | CHAR[(<em class="replaceable"><code>length</code></em>)]
      [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>] [COLLATE <em class="replaceable"><code>collation_name</code></em>]
  | VARCHAR(<em class="replaceable"><code>length</code></em>)
      [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>] [COLLATE <em class="replaceable"><code>collation_name</code></em>]
  | BINARY[(<em class="replaceable"><code>length</code></em>)]
  | VARBINARY(<em class="replaceable"><code>length</code></em>)
  | TINYBLOB
  | BLOB
  | MEDIUMBLOB
  | LONGBLOB
  | TINYTEXT [BINARY]
      [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>] [COLLATE <em class="replaceable"><code>collation_name</code></em>]
  | TEXT [BINARY]
      [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>] [COLLATE <em class="replaceable"><code>collation_name</code></em>]
  | MEDIUMTEXT [BINARY]
      [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>] [COLLATE <em class="replaceable"><code>collation_name</code></em>]
  | LONGTEXT [BINARY]
      [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>] [COLLATE <em class="replaceable"><code>collation_name</code></em>]
  | ENUM(<em class="replaceable"><code>value1</code></em>,<em class="replaceable"><code>value2</code></em>,<em class="replaceable"><code>value3</code></em>,...)
      [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>] [COLLATE <em class="replaceable"><code>collation_name</code></em>]
  | SET(<em class="replaceable"><code>value1</code></em>,<em class="replaceable"><code>value2</code></em>,<em class="replaceable"><code>value3</code></em>,...)
      [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>] [COLLATE <em class="replaceable"><code>collation_name</code></em>]
  | <em class="replaceable"><code>spatial_type</code></em>

<em class="replaceable"><code>index_col_name</code></em>:
    <em class="replaceable"><code>col_name</code></em> [(<em class="replaceable"><code>length</code></em>)] [ASC | DESC]

<em class="replaceable"><code>index_type</code></em>:
    USING {BTREE | HASH}

<em class="replaceable"><code>index_option</code></em>:
    KEY_BLOCK_SIZE [=] <em class="replaceable"><code>value</code></em>
  | <em class="replaceable"><code>index_type</code></em>
  | WITH PARSER <em class="replaceable"><code>parser_name</code></em>
  | COMMENT '<em class="replaceable"><code>string</code></em>'

<em class="replaceable"><code>reference_definition</code></em>:
    REFERENCES <em class="replaceable"><code>tbl_name</code></em> (<em class="replaceable"><code>index_col_name</code></em>,...)
      [MATCH FULL | MATCH PARTIAL | MATCH SIMPLE]
      [ON DELETE <em class="replaceable"><code>reference_option</code></em>]
      [ON UPDATE <em class="replaceable"><code>reference_option</code></em>]

<em class="replaceable"><code>reference_option</code></em>:
    RESTRICT | CASCADE | SET NULL | NO ACTION

<em class="replaceable"><code>table_options</code></em>:
    <em class="replaceable"><code>table_option</code></em> [[,] <em class="replaceable"><code>table_option</code></em>] ...

<em class="replaceable"><code>table_option</code></em>:
    ENGINE [=] <em class="replaceable"><code>engine_name</code></em>
  | AUTO_INCREMENT [=] <em class="replaceable"><code>value</code></em>
  | AVG_ROW_LENGTH [=] <em class="replaceable"><code>value</code></em>
  | [DEFAULT] CHARACTER SET [=] <em class="replaceable"><code>charset_name</code></em>
  | CHECKSUM [=] {0 | 1}
  | [DEFAULT] COLLATE [=] <em class="replaceable"><code>collation_name</code></em>
  | COMMENT [=] '<em class="replaceable"><code>string</code></em>'
  | CONNECTION [=] '<em class="replaceable"><code>connect_string</code></em>'
  | DATA DIRECTORY [=] '<em class="replaceable"><code>absolute path to directory</code></em>'
  | DELAY_KEY_WRITE [=] {0 | 1}
  | INDEX DIRECTORY [=] '<em class="replaceable"><code>absolute path to directory</code></em>'
  | INSERT_METHOD [=] { NO | FIRST | LAST }
  | KEY_BLOCK_SIZE [=] <em class="replaceable"><code>value</code></em>
  | MAX_ROWS [=] <em class="replaceable"><code>value</code></em>
  | MIN_ROWS [=] <em class="replaceable"><code>value</code></em>
  | PACK_KEYS [=] {0 | 1 | DEFAULT}
  | PASSWORD [=] '<em class="replaceable"><code>string</code></em>'
  | ROW_FORMAT [=] {DEFAULT|DYNAMIC|FIXED|COMPRESSED|REDUNDANT|COMPACT}
  | STATS_AUTO_RECALC [=] {DEFAULT|0|1}
  | STATS_PERSISTENT [=] {DEFAULT|0|1}
  | STATS_SAMPLE_PAGES [=] <em class="replaceable"><code>value</code></em>
  | TABLESPACE <em class="replaceable"><code>tablespace_name</code></em> [STORAGE {DISK|MEMORY|DEFAULT}]
  | UNION [=] (<em class="replaceable"><code>tbl_name</code></em>[,<em class="replaceable"><code>tbl_name</code></em>]...)

<em class="replaceable"><code>partition_options</code></em>:
    PARTITION BY
        { [LINEAR] HASH(<em class="replaceable"><code>expr</code></em>)
        | [LINEAR] KEY [ALGORITHM={1|2}] (<em class="replaceable"><code>column_list</code></em>)
        | RANGE{(<em class="replaceable"><code>expr</code></em>) | COLUMNS(<em class="replaceable"><code>column_list</code></em>)}
        | LIST{(<em class="replaceable"><code>expr</code></em>) | COLUMNS(<em class="replaceable"><code>column_list</code></em>)} }
    [PARTITIONS <em class="replaceable"><code>num</code></em>]
    [SUBPARTITION BY
        { [LINEAR] HASH(<em class="replaceable"><code>expr</code></em>)
        | [LINEAR] KEY [ALGORITHM={1|2}] (<em class="replaceable"><code>column_list</code></em>) }
      [SUBPARTITIONS <em class="replaceable"><code>num</code></em>]
    ]
    [(<em class="replaceable"><code>partition_definition</code></em> [, <em class="replaceable"><code>partition_definition</code></em>] ...)]

<em class="replaceable"><code>partition_definition</code></em>:
    PARTITION <em class="replaceable"><code>partition_name</code></em>
        [VALUES 
            {LESS THAN {(<em class="replaceable"><code>expr</code></em> | <em class="replaceable"><code>value_list</code></em>) | <code class="literal">MAXVALUE</code>} 
            | 
            IN (<em class="replaceable"><code>value_list</code></em>)}]
        [[STORAGE] ENGINE [=] <em class="replaceable"><code>engine_name</code></em>]
        [COMMENT [=] <em class="replaceable"><code>'comment_text'</code></em> ]
        [DATA DIRECTORY [=] '<code class="filename"><em class="replaceable"><code>data_dir</code></em></code>']
        [INDEX DIRECTORY [=] '<code class="filename"><em class="replaceable"><code>index_dir</code></em></code>']
        [MAX_ROWS [=] <em class="replaceable"><code>max_number_of_rows</code></em>]
        [MIN_ROWS [=] <em class="replaceable"><code>min_number_of_rows</code></em>]
        [TABLESPACE [=] <em class="replaceable"><code>tablespace_name</code></em>]
        [NODEGROUP [=] <em class="replaceable"><code>node_group_id</code></em>]
        [(<em class="replaceable"><code>subpartition_definition</code></em> [, <em class="replaceable"><code>subpartition_definition</code></em>] ...)]

<em class="replaceable"><code>subpartition_definition</code></em>:
    SUBPARTITION <em class="replaceable"><code>logical_name</code></em>
        [[STORAGE] ENGINE [=] <em class="replaceable"><code>engine_name</code></em>]
        [COMMENT [=] <em class="replaceable"><code>'comment_text'</code></em> ]
        [DATA DIRECTORY [=] '<code class="filename"><em class="replaceable"><code>data_dir</code></em></code>']
        [INDEX DIRECTORY [=] '<code class="filename"><em class="replaceable"><code>index_dir</code></em></code>']
        [MAX_ROWS [=] <em class="replaceable"><code>max_number_of_rows</code></em>]
        [MIN_ROWS [=] <em class="replaceable"><code>min_number_of_rows</code></em>]
        [TABLESPACE [=] <em class="replaceable"><code>tablespace_name</code></em>]
        [NODEGROUP [=] <em class="replaceable"><code>node_group_id</code></em>]

<em class="replaceable"><code>select_statement:</code></em>
    [IGNORE | REPLACE] [AS] SELECT ...   (<em class="replaceable"><code>Some valid select statement</code></em>)
</pre><p>
      <code class="literal">CREATE TABLE</code> は、指定された名前を持つテーブルを作成します。このテーブルに対する <code class="literal">CREATE</code> 権限が必要です。
    </p><p>
      許可されるテーブル名のルールは、<a class="xref" href="language-structure.html#identifiers" title="9.2 スキーマオブジェクト名">セクション9.2「スキーマオブジェクト名」</a>に示されています。デフォルトでは、テーブルは <code class="literal">InnoDB</code> ストレージエンジンを使用して、デフォルトデータベース内に作成されます。テーブルがすでに存在する場合、デフォルトデータベースが存在しない場合、またはデータベースが存在しない場合はエラーが発生します。
    </p><p>
      特定のデータベース内にテーブルを作成するには、テーブル名を <em class="replaceable"><code>db_name.tbl_name</code></em> として指定できます。そのデータベースが存在すると仮定すると、これは、デフォルトデータベースが存在するかどうかには関係なく機能します。引用符で囲まれた識別子を使用する場合は、データベース名とテーブル名を個別に引用符で囲みます。たとえば、<code class="literal">`mydb.mytbl`</code> ではなく、<code class="literal">`mydb`.`mytbl`</code> と記述します。
    </p><h4><a name="create-temporary-table"></a>一時テーブル</h4><p>
      テーブルの作成時に <code class="literal">TEMPORARY</code> キーワードを使用できます。<code class="literal">TEMPORARY</code> テーブルは現在のセッションにのみ表示され、そのセッションが閉じられると自動的に削除されます。つまり、2 つの異なるセッションが同じ一時テーブル名を使用することができ、互いに、または同じ名前の既存の <code class="literal">TEMPORARY</code> 以外のテーブルと競合することはありません。(既存のテーブルは、一時テーブルが削除されるまで非表示になります。)一時テーブルを作成するには、<code class="literal">CREATE TEMPORARY TABLES</code> 権限が必要です。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">TEMPORARY</code> キーワードを使用した場合、<code class="literal">CREATE TABLE</code> は、現在のアクティブなトランザクションを自動的にはコミットしません。
      </p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">TEMPORARY</code> テーブルは、データベース (スキーマ) と非常に疎な関係を持っています。データベースを削除しても、そのデータベース内で作成されたどの <code class="literal">TEMPORARY</code> テーブルも自動的には削除されません。また、<code class="literal">CREATE TABLE</code> ステートメントでテーブル名をデータベース名で修飾した場合は、存在しないデータベース内に <code class="literal">TEMPORARY</code> テーブルを作成することもできます。この場合は、そのテーブルへの以降のすべての参照をデータベース名で修飾する必要があります。
      </p></div><h4><a name="idm139979087988480"></a>同じ名前を持つ既存のテーブル</h4><p>
      キーワード <code class="literal">IF NOT EXISTS</code> は、テーブルがすでに存在する場合にエラーが発生しないようにします。ただし、既存のテーブルの構造が <code class="literal">CREATE TABLE</code> ステートメントによって示されている構造と同一であることの検証は行われません。
    </p><h4><a name="idm139979087985072"></a>物理表現</h4><p>
      MySQL は、各テーブルを、データベースディレクトリ内にある <code class="filename">.frm</code> テーブル形式 (定義) ファイルで表します。そのテーブルのストレージエンジンによって、ほかのファイルが作成されることもあります。
    </p><p>
      <code class="literal">InnoDB</code> テーブルの場合、ファイルストレージは、<code class="literal">innodb_file_per_table</code> 構成オプションによって制御されます。このオプションがオフになっている場合、<code class="literal">InnoDB</code> テーブルおよびインデックスはすべて、1 つ以上の <a class="link" href="glossary.html#glos_ibd_file" title=".ibd ファイル">.ibd ファイル</a>によって表される<a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">システムテーブルスペース</a>に格納されます。このオプションがオンになっているときに作成された各 <code class="literal">InnoDB</code> テーブルでは、テーブルデータとそれに関連付けられたすべてのインデックスは、データベースディレクトリ内にある <a class="link" href="glossary.html#glos_ibd_file" title=".ibd ファイル">.ibd ファイル</a>に格納されます。
    </p><p>
      <code class="literal">MyISAM</code> テーブルの場合は、ストレージエンジンがデータおよびインデックスファイルを作成します。そのため、<code class="literal">MyISAM</code> テーブル <em class="replaceable"><code>tbl_name</code></em> ごとに 3 つのディスクファイルが存在します。
    </p><div class="informaltable"><table summary="この表は、MyISAM テーブル tbl_name のディスクファイルの目的について説明しています。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">ファイル</th><th scope="col">目的</th></tr></thead><tbody><tr><td scope="row"><code class="filename"><em class="replaceable"><code>tbl_name</code></em>.frm</code></td><td>テーブル形式 (定義) ファイル</td></tr><tr><td scope="row"><code class="filename"><em class="replaceable"><code>tbl_name</code></em>.MYD</code></td><td>データファイル</td></tr><tr><td scope="row"><code class="filename"><em class="replaceable"><code>tbl_name</code></em>.MYI</code></td><td>インデックスファイル</td></tr></tbody></table></div><p>
      <a class="xref" href="storage-engines.html" title="第 15 章 代替ストレージエンジン">第15章「<i>代替ストレージエンジン</i>」</a>では、テーブルを表すために各ストレージエンジンがどのようなファイルを作成するかについて説明しています。テーブル名に特殊文字が含まれている場合は、<a class="xref" href="language-structure.html#identifier-mapping" title="9.2.3 識別子とファイル名のマッピング">セクション9.2.3「識別子とファイル名のマッピング」</a>で説明されているように、その文字のエンコードされたバージョンがテーブルファイルの名前に含まれます。
    </p><h4><a name="idm139979087958960"></a>カラムのデータ型および属性</h4><p>
      <em class="replaceable"><code>data_type</code></em> は、カラム定義内のデータ型を表します。<em class="replaceable"><code>spatial_type</code></em> は、空間データ型を表します。示されているデータ型の構文は代表的な例にすぎません。カラムデータ型を指定するために使用できる構文の完全な説明や、各型のプロパティーに関する情報については、<a class="xref" href="data-types.html" title="第 11 章 データ型">第11章「<i>データ型</i>」</a>および<a class="xref" href="data-types.html#spatial-extensions" title="11.5 空間データの拡張">セクション11.5「空間データの拡張」</a>を参照してください。
    </p><p>
      属性の中には、すべてのデータ型には適用されないものがあります。<code class="literal">AUTO_INCREMENT</code> は、整数型と浮動小数点型にのみ適用されます。<code class="literal">DEFAULT</code> は、<code class="literal">BLOB</code> または <code class="literal">TEXT</code> 型には適用されません。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">NULL</code> と <code class="literal">NOT NULL</code> のどちらも指定されていない場合、そのカラムは <code class="literal">NULL</code> が指定されたかのように処理されます。
        </p></li><li class="listitem"><p>
          整数または浮動小数点のカラムには、追加の属性 <code class="literal">AUTO_INCREMENT</code> を指定できます。インデックスが設定された <code class="literal">AUTO_INCREMENT</code> カラムに <code class="literal">NULL</code> (推奨) または <code class="literal">0</code> の値を挿入すると、カラムは次のシーケンス値に設定されます。通常、これは <code class="literal"><em class="replaceable"><code>value</code></em>+1</code> です。ここで <em class="replaceable"><code>value</code></em> は現在テーブルにあるカラムの最大値です。<code class="literal">AUTO_INCREMENT</code> シーケンスは <code class="literal">1</code> で始まります。
        </p><p>
          行を挿入したあとに <code class="literal">AUTO_INCREMENT</code> 値を取得するには、<code class="literal">LAST_INSERT_ID()</code> SQL 関数または <code class="literal">mysql_insert_id()</code> C API 関数を使用します。<a class="xref" href="functions.html#information-functions" title="12.14 情報関数">セクション12.14「情報関数」</a>および<a class="xref" href="connectors-apis.html#mysql-insert-id" title="23.8.7.37 mysql_insert_id()">セクション23.8.7.37「mysql_insert_id()」</a>を参照してください。
        </p><p>
          <code class="literal">NO_AUTO_VALUE_ON_ZERO</code> SQL モードが有効になっている場合は、新しいシーケンス値を生成することなく、<code class="literal">0</code> を <code class="literal">AUTO_INCREMENT</code> カラム内に <code class="literal">0</code> として格納できます。<a class="xref" href="server-administration.html#sql-mode" title="5.1.7 サーバー SQL モード">セクション5.1.7「サーバー SQL モード」</a>を参照してください。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            テーブルごとに存在できる <code class="literal">AUTO_INCREMENT</code> カラムは 1 つだけです。このカラムはインデックス付きである必要があり、<code class="literal">DEFAULT</code> 値を割り当てることはできません。<code class="literal">AUTO_INCREMENT</code> カラムは、正の値だけが含まれている場合にのみ正しく機能します。負の数を挿入すると、非常に大きな正の数を挿入したと見なされます。これは、数字が正から負に<span class="quote">「<span class="quote">ラップする</span>」</span>ときの精度の問題を回避すると同時に、<code class="literal">0</code> を含む <code class="literal">AUTO_INCREMENT</code> カラムを誤って取得してしまわないようにするために行われます。
          </p></div><p>
          <code class="literal">MyISAM</code> テーブルの場合は、マルチカラムキー内の <code class="literal">AUTO_INCREMENT</code> セカンダリカラムを指定できます。<a class="xref" href="tutorial.html#example-auto-increment" title="3.6.9 AUTO_INCREMENT の使用">セクション3.6.9「AUTO_INCREMENT の使用」</a>を参照してください。
        </p><a class="indexterm" name="idm139979087922640"></a><a class="indexterm" name="idm139979087921200"></a><p>
          MySQL を一部の ODBC アプリケーションと互換性があるようにするために、次のクエリーを使用して、最後に挿入された行の <code class="literal">AUTO_INCREMENT</code> 値を見つけることができます。
        </p><pre class="programlisting">
SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>auto_col</code></em> IS NULL
</pre><p>
          <code class="literal">InnoDB</code> と <code class="literal">AUTO_INCREMENT</code> については、<a class="xref" href="innodb-storage-engine.html#innodb-auto-increment-handling" title="14.6.5 InnoDB での AUTO_INCREMENT 処理">セクション14.6.5「InnoDB での AUTO_INCREMENT 処理」</a>を参照してください。<code class="literal">AUTO_INCREMENT</code> と MySQL レプリケーションについては、<a class="xref" href="replication.html#replication-features-auto-increment" title="17.4.1.1 レプリケーションと AUTO_INCREMENT">セクション17.4.1.1「レプリケーションと AUTO_INCREMENT」</a>を参照してください。
        </p></li><li class="listitem"><p>
          文字データ型 (<code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、<code class="literal">TEXT</code>) には、そのカラムの文字セットと照合順序を指定するための <code class="literal">CHARACTER SET</code> および <code class="literal">COLLATE</code> 属性を含めることができます。詳細は、<a class="xref" href="globalization.html#charset" title="10.1 文字セットのサポート">セクション10.1「文字セットのサポート」</a>を参照してください。<code class="literal">CHARSET</code> は <code class="literal">CHARACTER SET</code> のシノニムです。例:
        </p><pre class="programlisting">
CREATE TABLE t (c CHAR(20) CHARACTER SET utf8 COLLATE utf8_bin);
</pre><p>
          MySQL 5.6 は、文字カラム定義内の長さの指定を文字数で解釈します。(MySQL 4.1 より前のバージョンでは、バイト単位で解釈されました。)<code class="literal">BINARY</code> と <code class="literal">VARBINARY</code> の長さはバイト単位です。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979087900096"></a> <a class="indexterm" name="idm139979087898640"></a> <code class="literal">DEFAULT</code> 句は、カラムのデフォルト値を指定します。例外が 1 つあります。デフォルト値は定数である必要があるので、関数または式にはできません。これは、たとえば日付カラムのデフォルト値に <code class="literal">NOW()</code> や <code class="literal">CURRENT_DATE</code> などの関数の値を設定できないことを意味します。例外として、<code class="literal">TIMESTAMP</code> または (MySQL 5.6.5 の時点では) <code class="literal">DATETIME</code> カラムのデフォルトとして <code class="literal">CURRENT_TIMESTAMP</code> を指定できることがあります。<a class="xref" href="data-types.html#timestamp-initialization" title="11.3.5 TIMESTAMP および DATETIME の自動初期化および更新機能">セクション11.3.5「TIMESTAMP および DATETIME の自動初期化および更新機能」</a>を参照してください。
        </p><p>
          カラム定義に明示的な <code class="literal">DEFAULT</code> 値が含まれていない場合、MySQL は、<a class="xref" href="data-types.html#data-type-defaults" title="11.6 データ型デフォルト値">セクション11.6「データ型デフォルト値」</a>で説明されているようにデフォルト値を決定します。
        </p><p>
          <code class="literal">BLOB</code> および <code class="literal">TEXT</code> カラムにはデフォルト値を割り当てられません。
        </p><p>
          <code class="literal">NO_ZERO_DATE</code> または <code class="literal">NO_ZERO_IN_DATE</code> SQL モードが有効になっているときに、日付の値のデフォルトがそのモードに従って正しくない場合、<code class="literal">CREATE TABLE</code> では厳密な SQL モードが有効になっていない場合は警告を、厳密モードが有効になっている場合はエラーを生成します。たとえば、<code class="literal">NO_ZERO_IN_DATE</code> が有効になっている場合は、<code class="literal">c1 DATE DEFAULT '2010-00-00'</code> によって警告が生成されます。(MySQL 5.6.6 より前は、厳密モードが有効になっていない場合でも、このステートメントはエラーを生成します。)
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979087878720"></a> <code class="literal">COMMENT</code> オプションを使用して、カラムのコメントを最大 1024 文字の長さで指定できます。このコメントは、<code class="literal">SHOW CREATE TABLE</code> および <code class="literal">SHOW FULL COLUMNS</code> ステートメントによって表示されます。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979087873264"></a> MySQL Cluster では、<code class="literal">COLUMN_FORMAT</code> を使用して、<code class="literal">NDB</code> テーブルの個々のカラムのデータストレージフォーマットを指定することもできます。許可されるカラムフォーマットは、<code class="literal">FIXED</code>、<code class="literal">DYNAMIC</code>、および <code class="literal">DEFAULT</code> です。<code class="literal">FIXED</code> は固定幅のストレージを指定するために使用され、<code class="literal">DYNAMIC</code> はカラムが可変幅になることを許可し、<code class="literal">DEFAULT</code> はカラムで、そのカラムのデータ型によって決定される固定幅または可変幅のストレージが使用されるようにします (<code class="literal">ROW_FORMAT</code> 指定子によってオーバーライドされる可能性があります)。
        </p><p>
          <code class="literal">NDB</code> テーブルの場合、<code class="literal">COLUMN_FORMAT</code> のデフォルト値は <code class="literal">DEFAULT</code> です。
        </p><p>
          <code class="literal">COLUMN_FORMAT</code> は現在、<code class="literal">NDB</code> 以外のストレージエンジンを使用しているテーブルのカラムには影響を与えません。MySQL 5.6 以降では、<code class="literal">COLUMN_FORMAT</code> は暗黙のうちに無視されます。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979087857376"></a> <code class="literal">NDB</code> テーブルの場合は、<code class="literal">STORAGE</code> 句を使用して、カラムがディスク上またはメモリー内のどちらに格納されるかを指定することもできます。<code class="literal">STORAGE DISK</code> を指定するとカラムはディスク上に格納され、<code class="literal">STORAGE MEMORY</code> を指定するとインメモリーストレージが使用されます。使用される <code class="literal">CREATE TABLE</code> ステートメントには、引き続き <code class="literal">TABLESPACE</code> 句が含まれている必要があります。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (</code></strong>
    -&gt;     <strong class="userinput"><code>c1 INT STORAGE DISK,</code></strong>
    -&gt;     <strong class="userinput"><code>c2 INT STORAGE MEMORY</code></strong>
    -&gt; <strong class="userinput"><code>) ENGINE NDB;</code></strong>
<span class="errortext">ERROR 1005 (HY000): Can't create table 'c.t1' (errno: 140)</span>

mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (</code></strong>
    -&gt;     <strong class="userinput"><code>c1 INT STORAGE DISK,</code></strong>
    -&gt;     <strong class="userinput"><code>c2 INT STORAGE MEMORY</code></strong>
    -&gt; <strong class="userinput"><code>) TABLESPACE ts_1 ENGINE NDB;</code></strong>
Query OK, 0 rows affected (1.06 sec)
</pre><p>
          <code class="literal">NDB</code> テーブルの場合、<code class="literal">STORAGE DEFAULT</code> は <code class="literal">STORAGE MEMORY</code> と同等です。
        </p><p>
          <code class="literal">STORAGE</code> 句は、<code class="literal">NDB</code> 以外のストレージエンジンを使用しているテーブルには影響を与えません。<code class="literal">STORAGE</code> キーワードは、MySQL Cluster に付属の <span class="command"><strong>mysqld</strong></span> の構築でのみサポートされます。ほかのどのバージョンの MySQL でも認識されません。その場合は、<code class="literal">STORAGE</code> キーワードを使用しようとすると、必ず構文エラーが発生します。
        </p></li><li class="listitem"><p>
          <code class="literal">KEY</code> は通常、<code class="literal">INDEX</code> のシノニムです。キー属性 <code class="literal">PRIMARY KEY</code> もまた、カラム定義内で指定する場合は、単に <code class="literal">KEY</code> として指定できます。これは、ほかのデータベースシステムとの互換性のために実装されました。
        </p></li><li class="listitem"><p>
          <code class="literal">UNIQUE</code> インデックスは、そのインデックス内のすべての値が異なっている必要があるという制約を作成します。既存の行に一致するキー値を持つ新しい行を追加しようとすると、エラーが発生します。すべてのエンジンについて、<code class="literal">UNIQUE</code> インデックスは、<code class="literal">NULL</code> を含むことができるカラムでの複数の <code class="literal">NULL</code> 値を許可します。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979087826496"></a> <code class="literal">PRIMARY KEY</code> は、すべてのキーカラムを <code class="literal">NOT NULL</code> として定義する必要のある一意のインデックスです。それらが <code class="literal">NOT NULL</code> として明示的に宣言されていない場合、MySQL は、それらを暗黙的に (かつ警告なしで) そのように宣言します。テーブルに存在できる <code class="literal">PRIMARY KEY</code> は 1 つだけです。<code class="literal">PRIMARY KEY</code> の名前は、常に <code class="literal">PRIMARY</code> です。そのため、これをその他のどの種類のインデックスの名前としても使用できません。
        </p><p>
          <code class="literal">PRIMARY KEY</code> が存在しないときに、アプリケーションがテーブル内の <code class="literal">PRIMARY KEY</code> を要求した場合、MySQL は、<code class="literal">NULL</code> カラムのない最初の <code class="literal">UNIQUE</code> インデックスを <code class="literal">PRIMARY KEY</code> として返します。
        </p><p>
          <code class="literal">InnoDB</code> テーブルでは、セカンダリインデックスのためのストレージのオーバーヘッドを最小限に抑えるために、<code class="literal">PRIMARY KEY</code> を短い値に維持してください。各セカンダリインデックスエントリには、対応する行の主キーカラムのコピーが含まれています。(<a class="xref" href="innodb-storage-engine.html#innodb-table-and-index" title="14.2.13 InnoDB テーブルおよびインデックスの構造">セクション14.2.13「InnoDB テーブルおよびインデックスの構造」</a>を参照してください。)
        </p></li><li class="listitem"><p>
          作成されたテーブルでは、<code class="literal">PRIMARY KEY</code> が最初に配置され、そのあとにすべての <code class="literal">UNIQUE</code> インデックス、さらに一意でないインデックスが続きます。これは、MySQL オプティマイザが、使用するインデックスに優先順位を付けたり、重複した <code class="literal">UNIQUE</code> キーをよりすばやく検出したりするのに役立ちます。
        </p></li><li class="listitem"><p>
          <code class="literal">PRIMARY KEY</code> をマルチカラムインデックスにすることができます。ただし、カラム指定で <code class="literal">PRIMARY KEY</code> キー属性を使用してマルチカラムインデックスを作成することはできません。それを行なっても、その単一カラムがプライマリとしてマークされるだけです。個別の <code class="literal">PRIMARY KEY(<em class="replaceable"><code>index_col_name</code></em>, ...)</code> 句を使用する必要があります。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979087803952"></a> <code class="literal">PRIMARY KEY</code> または <code class="literal">UNIQUE</code> インデックスが、整数型を含む 1 つのカラムのみで構成されている場合は、<code class="literal">SELECT</code> ステートメントでそのカラムを <code class="literal">_rowid</code> として参照することもできます。
        </p></li><li class="listitem"><p>
          MySQL では、<code class="literal">PRIMARY KEY</code> の名前は <code class="literal">PRIMARY</code> です。その他のインデックスでは、名前を割り当てなかった場合、そのインデックスには最初のインデックス付きカラムと同じ名前が割り当てられ、それを一意にするためにオプションのサフィクス (<code class="literal">_2</code>、<code class="literal">_3</code>、<code class="literal">...</code>) が付けられます。テーブルのインデックス名は、<code class="literal">SHOW INDEX FROM <em class="replaceable"><code>tbl_name</code></em></code> を使用して確認できます。<a class="xref" href="sql-syntax.html#show-index" title="13.7.5.23 SHOW INDEX 構文">セクション13.7.5.23「SHOW INDEX 構文」</a>を参照してください。
        </p></li><li class="listitem"><p>
          一部のストレージエンジンでは、インデックスの作成時にインデックスタイプを指定できます。<em class="replaceable"><code>index_type</code></em> 指定子の構文は、<code class="literal">USING <em class="replaceable"><code>type_name</code></em></code> です。
        </p><p>
          例:
        </p><pre class="programlisting">
CREATE TABLE lookup
  (id INT, INDEX USING BTREE (id))
  ENGINE = MEMORY;
</pre><p>
          <code class="literal">USING</code> の推奨される位置は、インデックスカラムリストのあとです。カラムリストの前にも指定できますが、このオプションをその位置で使用するためのサポートは非推奨であり、将来の MySQL リリースで削除される予定です。
        </p><p>
          <em class="replaceable"><code>index_option</code></em> 値は、インデックスの追加オプションを指定します。<code class="literal">USING</code> はそのようなオプションの 1 つです。許可される <em class="replaceable"><code>index_option</code></em> 値の詳細は、<a class="xref" href="sql-syntax.html#create-index" title="13.1.13 CREATE INDEX 構文">セクション13.1.13「CREATE INDEX 構文」</a>を参照してください。
        </p><p>
          インデックスの詳細は、<a class="xref" href="optimization.html#mysql-indexes" title="8.3.1 MySQL のインデックスの使用の仕組み">セクション8.3.1「MySQL のインデックスの使用の仕組み」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979087781808"></a> <a class="indexterm" name="idm139979087779696"></a> MySQL 5.6 では、<code class="literal">NULL</code> 値を持つことができるカラム上のインデックスをサポートするのは <code class="literal">InnoDB</code>、<code class="literal">MyISAM</code>、および <code class="literal">MEMORY</code> だけです。それ以外の場合は、インデックス付きカラムを <code class="literal">NOT NULL</code> として宣言する必要があります。そうしないと、エラー結果が発生します。
        </p></li><li class="listitem"><p>
          <code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、<code class="literal">BINARY</code>、および <code class="literal">VARBINARY</code> カラムの場合は、<code class="literal"><em class="replaceable"><code>col_name</code></em>(<em class="replaceable"><code>length</code></em>)</code> 構文を使用してインデックスプリフィクス長を指定することにより、カラム値の先頭の部分のみを使用するインデックスを作成できます。<code class="literal">BLOB</code> および <code class="literal">TEXT</code> カラムにもインデックスを設定できますが、プリフィクス長を指定する<span class="emphasis"><em>必要があります</em></span>。プリフィクス長は、バイナリ以外の文字列型の場合は文字数で、バイナリ文字列型の場合はバイト単位で指定されます。つまり、インデックスエントリは、<code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、および <code class="literal">TEXT</code> カラムの場合は各カラム値の最初の <em class="replaceable"><code>length</code></em> 文字、<code class="literal">BINARY</code>、<code class="literal">VARBINARY</code>、および <code class="literal">BLOB</code> カラムの場合は各カラム値の最初の <em class="replaceable"><code>length</code></em> バイトで構成されます。このようにカラム値のプリフィクスのみにインデックスを設定すると、インデックスファイルをはるかに小さくできます。<a class="xref" href="optimization.html#column-indexes" title="8.3.4 カラムインデックス">セクション8.3.4「カラムインデックス」</a>を参照してください。
        </p><a class="indexterm" name="idm139979087756032"></a><a class="indexterm" name="idm139979087753872"></a><a class="indexterm" name="idm139979087751824"></a><a class="indexterm" name="idm139979087749744"></a><p>
          <code class="literal">BLOB</code> および <code class="literal">TEXT</code> カラム上のインデックス設定をサポートするのは、<code class="literal">InnoDB</code> および <code class="literal">MyISAM</code> ストレージエンジンだけです。例:
        </p><pre class="programlisting">
CREATE TABLE test (blob_col BLOB, INDEX(blob_col(10)));
</pre><p>
          <code class="literal">InnoDB</code> テーブルではプリフィクスの長さを最大 767 バイトに、また <code class="literal">innodb_large_prefix</code> オプションが有効になっている場合は 3072 バイトにすることができます。プリフィクスの制限がバイト単位で測定されるのに対して、<code class="literal">CREATE TABLE</code> ステートメントでのプリフィクス長は、バイナリ以外のデータ型 (<code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、<code class="literal">TEXT</code>) では文字数として解釈されます。複数バイトの文字セットを使用するカラムのプリフィクス長を指定する場合は、この点を考慮に入れてください。
        </p></li><li class="listitem"><p>
          <em class="replaceable"><code>index_col_name</code></em> の指定を <code class="literal">ASC</code> または <code class="literal">DESC</code> で終了させることができます。これらのキーワードは、インデックス値の昇順または降順での格納を指定する将来の拡張のために許可されています。現在、これらは解析されますが、無視されます。インデックス値は、常に昇順で格納されます。
        </p></li><li class="listitem"><p>
          <code class="literal">SELECT</code> 内でカラムに対して <code class="literal">ORDER BY</code> または <code class="literal">GROUP BY</code> を使用すると、サーバーは、<code class="literal">max_sort_length</code> システム変数によって示されている初期のバイト数のみを使用して値をソートします。
        </p></li><li class="listitem"><p>
          全文検索に使用される特殊な <code class="literal">FULLTEXT</code> インデックスを作成できます。<code class="literal">FULLTEXT</code> インデックスをサポートするのは、<code class="literal">InnoDB</code> および <code class="literal">MyISAM</code> だけです。これらは、<code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、および <code class="literal">TEXT</code> カラムからのみ作成できます。インデックス設定は常に、カラム全体に対して実行されます。カラムプリフィクスのインデックス設定はサポートされていないため、プリフィクス長が指定されてもすべて無視されます。操作の詳細は、<a class="xref" href="functions.html#fulltext-search" title="12.9 全文検索関数">セクション12.9「全文検索関数」</a>を参照してください。<code class="literal">WITH PARSER</code> 句は、全文インデックス設定および検索操作に特殊な処理が必要な場合にパーサープラグインをインデックスに関連付けるために、<em class="replaceable"><code>index_option</code></em> 値として指定できます。この句は、<code class="literal">FULLTEXT</code> インデックスに対してのみ有効です。プラグインの作成の詳細は、<a class="xref" href="extending-mysql.html#plugin-api" title="24.2 MySQL プラグイン API">セクション24.2「MySQL プラグイン API」</a>を参照してください。
        </p></li><li class="listitem"><p>
          空間データ型に <code class="literal">SPATIAL</code> インデックスを作成できます。空間型は <code class="literal">MyISAM</code> テーブルでのみサポートされ、インデックス付きカラムを <code class="literal">NOT NULL</code> として宣言する必要があります。<a class="xref" href="data-types.html#spatial-extensions" title="11.5 空間データの拡張">セクション11.5「空間データの拡張」</a>を参照してください。
        </p></li><li class="listitem"><p>
          MySQL 5.6 では、インデックス定義に最大 1024 文字のオプションのコメントを含めることができます。
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> および <code class="literal">NDB</code> テーブルは、外部キー制約のチェックをサポートしています。参照されるテーブルのカラムには、常に明示的に名前を付ける必要があります。外部キーに対しては <code class="literal">ON DELETE</code> と <code class="literal">ON UPDATE</code> の両方のアクションがサポートされています。詳細および例については、<a class="xref" href="sql-syntax.html#create-table-foreign-keys" title="13.1.17.2 外部キー制約の使用">セクション13.1.17.2「外部キー制約の使用」</a>を参照してください。<code class="literal">InnoDB</code> での外部キーに固有の情報については、<a class="xref" href="innodb-storage-engine.html#innodb-foreign-key-constraints" title="14.6.6 InnoDB と FOREIGN KEY 制約">セクション14.6.6「InnoDB と FOREIGN KEY 制約」</a>を参照してください。
        </p><p>
          その他のストレージエンジンの場合、MySQL Server は、<code class="literal">CREATE TABLE</code> ステートメント内の <code class="literal">FOREIGN KEY</code> および <code class="literal">REFERENCES</code> 構文を解析して無視します。<code class="literal">CHECK</code> 句は、すべてのストレージエンジンによって解析されますが、無視されます。<a class="xref" href="introduction.html#ansi-diff-foreign-keys" title="1.8.2.4 外部キーの違い">セクション1.8.2.4「外部キーの違い」</a>を参照してください。
        </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
            ANSI/ISO SQL 標準に精通しているユーザーの場合は、参照整合性の制約定義で使用される <code class="literal">MATCH</code> 句を認識または適用するストレージエンジンは (<code class="literal">InnoDB</code> を含め) 存在しません。明示的な <code class="literal">MATCH</code> 句を使用しても、指定された効果が得られないだけでなく、<code class="literal">ON DELETE</code> および <code class="literal">ON UPDATE</code> 句が無視される原因にもなります。これらの理由により、<code class="literal">MATCH</code> の指定は避けるようにしてください。
          </p><p>
            SQL 標準での <code class="literal">MATCH</code> 句は、複合 (マルチカラム) 外部キー内の <code class="literal">NULL</code> 値が、主キーとの比較時にどのように処理されるかを制御します。<code class="literal">InnoDB</code> は基本的に、外部キーをすべてまたは部分的に <code class="literal">NULL</code> にすることが許可される、<code class="literal">MATCH SIMPLE</code> で定義されるセマンティクスを実装しています。その場合は、このような外部キーを含む (子テーブルの) 行の挿入が許可され、その行は参照される (親) テーブル内のどの行にも一致しません。トリガーを使用して、ほかのセマンティクスを実装できます。
          </p><p>
            さらに、MySQL ではパフォーマンスのために、参照されるカラムにインデックスを設定する必要があります。ただし、参照されるカラムを <code class="literal">UNIQUE</code> または <code class="literal">NOT NULL</code> として宣言するという要件は適用されません。一意でないキーまたは <code class="literal">NULL</code> 値を含むキーへの外部キー参照の処理は、<code class="literal">UPDATE</code> や <code class="literal">DELETE CASCADE</code> などの操作に対して適切に定義されていません。<code class="literal">UNIQUE</code> (または <code class="literal">PRIMARY</code>) と <code class="literal">NOT NULL</code> の両方であるキーのみを参照する外部キーを使用することをお勧めします。
          </p><p>
            MySQL は、参照がカラム指定の一部として定義されている (SQL 標準で定義された) <span class="quote">「<span class="quote">インラインの <code class="literal">REFERENCES</code> 指定</span>」</span>を認識せず、またサポートもしていません。MySQL は、個別の <code class="literal">FOREIGN KEY</code> 指定の一部として指定されている場合にのみ <code class="literal">REFERENCES</code> 句を受け入れます。
          </p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            <code class="literal">InnoDB</code> ストレージエンジンを使用するパーティション化されたテーブルは、外部キーをサポートしていません。<code class="literal">KEY</code> または <code class="literal">LINEAR KEY</code> によってパーティション化された <code class="literal">NDB</code> テーブルは、この制限によって影響を受けません。詳細については、<a class="xref" href="partitioning.html#partitioning-limitations" title="19.6 パーティショニングの制約と制限">セクション19.6「パーティショニングの制約と制限」</a>を参照してください。
          </p></div></li><li class="listitem"><p>
          テーブルあたり 4096 カラムという強い制限値がありますが、特定のテーブルでは、実際の最大数がこれより少なくなる可能性があります。実際の最大数は、<a class="xref" href="restrictions.html#column-count-limit" title="D.10.4 テーブルカラム数と行サイズの制限">セクションD.10.4「テーブルカラム数と行サイズの制限」</a>で説明されている要因によって異なります。
        </p></li></ul></div><p>
      <code class="literal">TABLESPACE</code> および <code class="literal">STORAGE</code> テーブルオプションは、<code class="literal">NDB</code> テーブルでのみ使用されます。<em class="replaceable"><code>tablespace_name</code></em> という名前のテーブルスペースが、すでに <code class="literal">CREATE TABLESPACE</code> を使用して作成されている必要があります。<code class="literal">STORAGE</code> は、使用されるストレージのタイプ (ディスクまたはメモリー) を決定するものであり、<code class="literal">DISK</code>、<code class="literal">MEMORY</code>、<code class="literal">DEFAULT</code> のいずれかです。
    </p><p>
      <code class="literal">TABLESPACE ... STORAGE DISK</code> は、MySQL Cluster ディスクデータテーブルスペースにテーブルを割り当てます。詳細は、<a class="xref" href="mysql-cluster.html#mysql-cluster-disk-data" title="18.5.12 MySQL Cluster ディスクデータテーブル">セクション18.5.12「MySQL Cluster ディスクデータテーブル」</a>を参照してください。
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        <code class="literal">STORAGE</code> 句を、<code class="literal">TABLESPACE</code> 句のない <code class="literal">CREATE TABLE</code> ステートメントで使用することはできません。
      </p></div><h4><a name="idm139979087657136"></a>Storage Engines (ストレージエンジン)</h4><p>
      <code class="literal">ENGINE</code> テーブルオプションは、次の表に示されている名前のいずれかを使用して、テーブルのストレージエンジンを指定します。エンジン名は、引用符で囲んでも囲まなくてもかまいません。引用符で囲まれた名前 <code class="literal">'DEFAULT'</code> は認識されますが、無視されます。
    </p><div class="informaltable"><table summary="この表は、ENGINE テーブルオプションによって取得されるストレージエンジン名を示しています。名前ごとに説明が示されています。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">ストレージエンジン</th><th scope="col">説明</th></tr></thead><tbody><tr><td scope="row"><code class="literal">InnoDB</code></td><td>行ロックと外部キーを備えたトランザクションセーフテーブル。新しいテーブルのためのデフォルトのストレージエンジン。MySQL は経験しているが、<code class="literal">InnoDB</code> がはじめてである場合は、<a class="xref" href="innodb-storage-engine.html" title="第 14 章 InnoDB ストレージエンジン">第14章「<i>InnoDB ストレージエンジン</i>」</a>、そのなかでも特に<a class="xref" href="innodb-storage-engine.html#innodb-default-se" title="14.1.1 デフォルトの MySQL ストレージエンジンとしての InnoDB">セクション14.1.1「デフォルトの MySQL ストレージエンジンとしての InnoDB」</a>を参照してください。</td></tr><tr><td scope="row"><code class="literal">MyISAM</code></td><td>主に読み取り専用または読み取りが大半のワークロードに使用される、バイナリの移植可能なストレージエンジン。<a class="xref" href="storage-engines.html#myisam-storage-engine" title="15.2 MyISAM ストレージエンジン">セクション15.2「MyISAM ストレージエンジン」</a>を参照してください。</td></tr><tr><td scope="row"><code class="literal">MEMORY</code></td><td>このストレージエンジンのデータは、メモリー内にのみ格納されます。<a class="xref" href="storage-engines.html#memory-storage-engine" title="15.3 MEMORY ストレージエンジン">セクション15.3「MEMORY ストレージエンジン」</a>を参照してください。</td></tr><tr><td scope="row"><code class="literal">CSV</code></td><td>カンマ区切り値形式で行を格納するテーブル。<a class="xref" href="storage-engines.html#csv-storage-engine" title="15.4 CSV ストレージエンジン">セクション15.4「CSV ストレージエンジン」</a>を参照してください。</td></tr><tr><td scope="row"><code class="literal">ARCHIVE</code></td><td>アーカイブストレージエンジン。<a class="xref" href="storage-engines.html#archive-storage-engine" title="15.5 ARCHIVE ストレージエンジン">セクション15.5「ARCHIVE ストレージエンジン」</a>を参照してください。</td></tr><tr><td scope="row"><code class="literal">EXAMPLE</code></td><td>サンプルのエンジン。<a class="xref" href="storage-engines.html#example-storage-engine" title="15.9 EXAMPLE ストレージエンジン">セクション15.9「EXAMPLE ストレージエンジン」</a>を参照してください。</td></tr><tr><td scope="row"><code class="literal">FEDERATED</code></td><td>リモートテーブルにアクセスするストレージエンジン。<a class="xref" href="storage-engines.html#federated-storage-engine" title="15.8 FEDERATED ストレージエンジン">セクション15.8「FEDERATED ストレージエンジン」</a>を参照してください。</td></tr><tr><td scope="row"><code class="literal">HEAP</code></td><td>これは <code class="literal">MEMORY</code> のシノニムです。</td></tr><tr><td scope="row"><code class="literal">MERGE</code></td><td>1 つのテーブルとして使用される <code class="literal">MyISAM</code> テーブルのコレクション。<code class="literal">MRG_MyISAM</code> とも呼ばれます。<a class="xref" href="storage-engines.html#merge-storage-engine" title="15.7 MERGE ストレージエンジン">セクション15.7「MERGE ストレージエンジン」</a>を参照してください。</td></tr><tr><td scope="row"><code class="literal">NDB</code></td><td>トランザクションと外部キーをサポートする、クラスタ化された、耐障害の、メモリーベースのテーブル。<code class="literal">NDBCLUSTER</code> とも呼ばれます。<a class="xref" href="mysql-cluster.html" title="第 18 章 MySQL Cluster NDB 7.3 および MySQL Cluster NDB 7.4">第18章「<i>MySQL Cluster NDB 7.3 および MySQL Cluster NDB 7.4</i>」</a>を参照してください。</td></tr></tbody></table></div><p>
      使用できないストレージエンジンが指定されている場合、MySQL は、代わりにデフォルトのエンジンを使用します。通常、これは <code class="literal">MyISAM</code> です。たとえば、テーブル定義に <code class="literal">ENGINE=INNODB</code> オプションが含まれているが、MySQL サーバーが <code class="literal">INNODB</code> テーブルをサポートしていない場合、テーブルは <code class="literal">MyISAM</code> テーブルとして作成されます。これにより、マスター上にはトランザクションテーブルが存在するが、スレーブ上に作成されるテーブルは (高速化のために) 非トランザクションであるようなレプリケーションセットアップを行うことが可能になります。MySQL 5.6 では、ストレージエンジンの指定が受け付けられない場合は警告が発生します。
    </p><p>
      <a class="xref" href="server-administration.html#sql-mode" title="5.1.7 サーバー SQL モード">セクション5.1.7「サーバー SQL モード」</a>で説明されているように、<code class="literal">NO_ENGINE_SUBSTITUTION</code> SQL モードの設定によってエンジンの置換を制御できます。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">ENGINE</code> のシノニムであった古い <code class="literal">TYPE</code> オプションは、MySQL 5.5 で削除されました。<span class="emphasis"><em>MySQL 5.5 以降にアップグレードする場合は、<code class="literal">TYPE</code> に依存する既存のアプリケーションを、代わりに <code class="literal">ENGINE</code> を使用するように変換する必要があります</em></span>。
      </p></div><h4><a name="idm139979087608096"></a>パフォーマンスの最適化</h4><p>
      その他のテーブルオプションは、テーブルの動作を最適化するために使用されます。ほとんどの場合は、それらのうちのどれも指定する必要はありません。特に示されていないかぎり、これらのオプションはすべてのストレージエンジンに適用されます。特定のストレージエンジンに適用されないオプションは、テーブル定義の一部として受け入れられ、記憶される可能性があります。それにより、あとで <code class="literal">ALTER TABLE</code> を使用して、別のストレージエンジンを使用するようにテーブルを変換した場合に、このようなオプションが適用されます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">AUTO_INCREMENT</code>
        </p><p>
          テーブルの初期の <code class="literal">AUTO_INCREMENT</code> 値。MySQL 5.6 では、これは <code class="literal">MyISAM</code>、<code class="literal">MEMORY</code>、<code class="literal">InnoDB</code>、および <code class="literal">ARCHIVE</code> テーブルに対して機能します。<code class="literal">AUTO_INCREMENT</code> テーブルオプションをサポートしていないエンジンの最初の自動インクリメント値を設定するには、テーブルを作成したあとに目的の値より 1 小さい値を持つ<span class="quote">「<span class="quote">ダミーの</span>」</span>行を挿入してから、そのダミーの行を削除します。
        </p><p>
          <code class="literal">CREATE TABLE</code> ステートメント内の <code class="literal">AUTO_INCREMENT</code> テーブルオプションをサポートするエンジンの場合は、<code class="literal">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> AUTO_INCREMENT = <em class="replaceable"><code>N</code></em></code> を使用して <code class="literal">AUTO_INCREMENT</code> 値をリセットすることもできます。この値を、現在カラム内にある最大値より小さく設定することはできません。
        </p></li><li class="listitem"><p>
          <code class="literal">AVG_ROW_LENGTH</code>
        </p><p>
          テーブルの平均の行の長さの近似値。これを設定する必要があるのは、可変サイズの行を持つ大きなテーブルの場合だけです。
        </p><p>
          <code class="literal">MyISAM</code> テーブルを作成すると、MySQL は <code class="literal">MAX_ROWS</code> および <code class="literal">AVG_ROW_LENGTH</code> オプションの積を使用して、結果として得られるテーブルがどれくらいの大きさになるかを判定します。どちらのオプションも指定しない場合、<code class="literal">MyISAM</code> データおよびインデックスファイルの最大サイズは、デフォルトで 256T バイトになります。(オペレーティングシステムでその大きさのファイルがサポートされていない場合、テーブルサイズはファイルサイズ制限によって制約されます。)インデックスをより小さく、かつ高速にするためにポインタサイズを小さく維持したいと考えており、実際に大きなファイルが必要でない場合は、<code class="literal">myisam_data_pointer_size</code> システム変数を設定することによってデフォルトのポインタサイズを小さくすることができます。(<a class="xref" href="server-administration.html#server-system-variables" title="5.1.4 サーバーシステム変数">セクション5.1.4「サーバーシステム変数」</a>を参照してください。)すべてのテーブルをデフォルトの制限を超えて拡張できるようにしたいと考えており、テーブルが必要以上に少し遅く、かつ大きくなってもかまわない場合は、この変数を設定することによってデフォルトのポインタサイズを大きくすることができます。この値を 7 に設定すると、最大 65,536T バイトのテーブルサイズが許可されます。
        </p></li><li class="listitem"><p>
          <code class="literal">[DEFAULT] CHARACTER SET</code>
        </p><p>
          テーブルのデフォルトの文字セットを指定します。<code class="literal">CHARSET</code> は <code class="literal">CHARACTER SET</code> のシノニムです。文字セット名が <code class="literal">DEFAULT</code> である場合は、データベース文字セットが使用されます。
        </p></li><li class="listitem"><p>
          <code class="literal">CHECKSUM</code>
        </p><p>
          MySQL ですべての行のライブチェックサム (つまり、テーブルが変更されると MySQL が自動的に更新するチェックサム) が保持されるようにする場合は、これを 1 に設定します。これにより、テーブルの更新が少し遅くなりますが、破損したテーブルを見つけることが容易になります。<code class="literal">CHECKSUM TABLE</code> ステートメントは、このチェックサムをレポートします。(<code class="literal">MyISAM</code> のみ。)
        </p></li><li class="listitem"><p>
          <code class="literal">[DEFAULT] COLLATE</code>
        </p><p>
          テーブルのデフォルトの照合順序を指定します。
        </p></li><li class="listitem"><p>
          <code class="literal">COMMENT</code>
        </p><p>
          テーブルのコメントであり、長さは最大 2048 文字です。
        </p></li><li class="listitem"><p>
          <code class="literal">CONNECTION</code>
        </p><p>
          <code class="literal">FEDERATED</code> テーブルの接続文字列。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            古いバージョンの MySQL は、接続文字列に <code class="literal">COMMENT</code> オプションを使用していました。
          </p></div></li><li class="listitem"><p>
          <code class="literal">DATA DIRECTORY</code>、<code class="literal">INDEX DIRECTORY</code>
        </p><p>
          <code class="literal">InnoDB</code> では、<code class="literal">DATA DIRECTORY='<em class="replaceable"><code>directory</code></em>'</code> オプションを使用すると、MySQL データディレクトリ以外の場所に新しい <code class="literal">InnoDB</code> file-per-table テーブルスペースを作成できます。MySQL は、指定されたディレクトリ内にデータベース名に対応するサブディレクトリを作成し、さらにその中に新しいテーブルの <code class="filename">.ibd</code> ファイルを作成します。<code class="literal">InnoDB</code> テーブルで <code class="literal">DATA DIRECTORY</code> オプションを使用するには、<code class="literal">innodb_file_per_table</code> 構成オプションを有効にする必要があります。このディレクトリは、ディレクトリへの (相対パスではなく) フルパス名である必要があります。詳細は、<a class="xref" href="innodb-storage-engine.html#tablespace-placing" title="14.5.4 テーブルスペースの位置の指定">セクション14.5.4「テーブルスペースの位置の指定」</a>を参照してください。
        </p><p>
          <code class="literal">MyISAM</code> テーブルを作成する場合は、<code class="literal">DATA DIRECTORY='<em class="replaceable"><code>directory</code></em>'</code> 句、<code class="literal">INDEX DIRECTORY='<em class="replaceable"><code>directory</code></em>'</code> 句、またはその両方を使用できます。これらは、それぞれ <code class="literal">MyISAM</code> テーブルのデータファイルとインデックスファイルを配置する場所を指定します。<code class="literal">InnoDB</code> テーブルとは異なり、<code class="literal">DATA DIRECTORY</code> または <code class="literal">INDEX DIRECTORY</code> オプションで <code class="literal">MyISAM</code> テーブルを作成する場合、MySQL はデータベース名に対応するサブディレクトリを作成しません。各ファイルは、指定されたディレクトリ内に作成されます。
        </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
            テーブルレベルの <code class="literal">DATA DIRECTORY</code> および <code class="literal">INDEX DIRECTORY</code> オプションは、パーティション化されたテーブルでは無視されます。(Bug #32091)
          </p></div><p>
          これらのオプションは、<code class="option">--skip-symbolic-links</code> オプションを使用していない場合にのみ機能します。また、オペレーティングシステムにも、機能するスレッドに対して安全な <code class="literal">realpath()</code> 呼び出しが存在する必要があります。詳細は、<a class="xref" href="optimization.html#symbolic-links-to-tables" title="8.11.3.1.2 Unix 上の MyISAM へのシンボリックリンクの使用">セクション8.11.3.1.2「Unix 上の MyISAM へのシンボリックリンクの使用」</a>を参照してください。
        </p><p>
          <code class="literal">MyISAM</code> テーブルが <code class="literal">DATA DIRECTORY</code> オプションなしで作成される場合、<code class="filename">.MYD</code> ファイルがデータベースディレクトリ内に作成されます。デフォルトでは、<code class="literal">MyISAM</code> が既存の <code class="filename">.MYD</code> ファイルを検出した場合、そのファイルを上書きします。<code class="literal">INDEX DIRECTORY</code> オプションを指定せずに作成されたテーブルについて、<code class="filename">.MYI</code> ファイルに同じことが当てはまります。この動作を抑制するには、<code class="option">--keep_files_on_create</code> オプションを使用してサーバーを起動します。その場合、<code class="literal">MyISAM</code> は既存のファイルを上書きせず、代わりにエラーを返します。
        </p><p>
          <code class="literal">MyISAM</code> テーブルが <code class="literal">DATA DIRECTORY</code> または <code class="literal">INDEX DIRECTORY</code> オプションを使用して作成され、既存の <code class="filename">.MYD</code> または <code class="filename">.MYI</code> ファイルが見つかった場合、MyISAM は常にエラーを返します。指定されたディレクトリ内のファイルは上書きされません。
        </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
            <code class="literal">DATA DIRECTORY</code> または <code class="literal">INDEX DIRECTORY</code> では、MySQL データディレクトリを含むパス名を使用できません。これには、パーティション化されたテーブルや個々のテーブルパーティションが含まれます。(Bug #32167 を参照してください。)
          </p></div></li><li class="listitem"><p>
          <code class="literal">DELAY_KEY_WRITE</code>
        </p><p>
          テーブルのキー更新をテーブルが閉じられるまで遅らせる場合は、これを 1 に設定します。<a class="xref" href="server-administration.html#server-system-variables" title="5.1.4 サーバーシステム変数">セクション5.1.4「サーバーシステム変数」</a>にある <code class="literal">delay_key_write</code> システム変数の説明を参照してください。(<code class="literal">MyISAM</code> のみ。)
        </p></li><li class="listitem"><p>
          <code class="literal">INSERT_METHOD</code>
        </p><p>
          <code class="literal">MERGE</code> テーブルにデータを挿入する場合は、<code class="literal">INSERT_METHOD</code> を使用して、行を挿入するテーブルを指定する必要があります。<code class="literal">INSERT_METHOD</code> は、<code class="literal">MERGE</code> テーブルにのみ役立つオプションです。最初または最後のテーブルに挿入するには <code class="literal">FIRST</code> または <code class="literal">LAST</code> の値を、挿入されないようにするには <code class="literal">NO</code> の値を使用します。<a class="xref" href="storage-engines.html#merge-storage-engine" title="15.7 MERGE ストレージエンジン">セクション15.7「MERGE ストレージエンジン」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">KEY_BLOCK_SIZE</code>
        </p><p>
          <a class="link" href="glossary.html#glos_compression" title="圧縮">圧縮された</a> <code class="literal">InnoDB</code> テーブルでは、オプションで、<a class="link" href="glossary.html#glos_page" title="ページ">ページ</a>に使用するサイズをバイト単位で指定します。この値はヒントとして扱われます。<code class="literal">InnoDB</code> では、必要に応じて異なるサイズが使用される可能性があります。値 0 は、<code class="literal">innodb_page_size</code> 値の半分であるデフォルトの圧縮済みページサイズを表します。<code class="literal">KEY_BLOCK_SIZE</code> 値は、<code class="literal">innodb_page_size</code> 値以下にしかできません。<code class="literal">innodb_page_size</code> 値を超える値を指定した場合は、その値が無視され、警告が発行されます。また、<code class="literal">KEY_BLOCK_SIZE</code> は <code class="literal">innodb_page_size</code> 値の半分に設定されます。<code class="literal">innodb_strict_mode=ON</code> の場合、無効な <code class="literal">KEY_BLOCK_SIZE</code> 値を指定するとエラーが返されます。使用法の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-compression" title="14.7 InnoDB 圧縮テーブル">セクション14.7「InnoDB 圧縮テーブル」</a>を参照してください。
        </p><p>
          個々のインデックス定義では、テーブルの値をオーバーライドする独自の <code class="literal">KEY_BLOCK_SIZE</code> 値を指定できます。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            <code class="literal">InnoDB</code> テーブルに対して <code class="literal">KEY_BLOCK_SIZE</code> 句を使用している場合は、<code class="literal">innodb_strict_mode</code> を有効にすることをお勧めします。
          </p></div></li><li class="listitem"><p>
          <code class="literal">MAX_ROWS</code>
        </p><p>
          テーブル内に格納することを予定している行の最大数。これは強い制限値ではなく、どちらかと言うと、テーブルが少なくともこの行数を格納できる必要があるという、ストレージエンジンへのヒントです。
        </p><p>
          <a class="indexterm" name="idm139979087493040"></a> <a class="indexterm" name="idm139979087491008"></a> <a class="indexterm" name="idm139979087488864"></a> <a class="indexterm" name="idm139979087486816"></a> <a class="indexterm" name="idm139979087484752"></a> <a class="indexterm" name="idm139979087482688"></a> <a class="indexterm" name="idm139979087480688"></a> <a class="indexterm" name="idm139979087478832"></a> <code class="literal">NDB</code> ストレージエンジンは、この値を最大値として扱います。非常に大きな (数百万行を含む) MySQL Cluster テーブルを作成する予定がある場合は、このオプションを使用して <code class="literal">MAX_ROWS = 2 * <em class="replaceable"><code>rows</code></em></code> を設定することにより、テーブルの主キーのハッシュを格納するために使用されるハッシュテーブル内に <code class="literal">NDB</code> によって十分な数のインデックススロットが割り当てられることを保証するようにしてください。ここで、<em class="replaceable"><code>rows</code></em> はテーブルに挿入することが予測される行数です。
        </p><p>
          <code class="literal">MAX_ROWS</code> の最大値は 4294967295 です。これを超える値は、この制限に切り捨てられます。
        </p></li><li class="listitem"><p>
          <code class="literal">MIN_ROWS</code>
        </p><p>
          テーブル内に格納することを予定している行の最小数。<code class="literal">MEMORY</code> ストレージエンジンは、このオプションをメモリー使用に関するヒントとして使用します。
        </p></li><li class="listitem"><p>
          <code class="literal">PACK_KEYS</code>
        </p><p>
          <code class="literal">PACK_KEYS</code> は、<code class="literal">MyISAM</code> テーブルでのみ有効になります。インデックスを小さくする場合は、このオプションを 1 に設定します。通常は、これによって更新は遅く、読み取りは高速になります。このオプションを 0 に設定すると、キーのすべてのパッキングが無効になります。これを <code class="literal">DEFAULT</code> に設定すると、長い <code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、<code class="literal">BINARY</code>、または <code class="literal">VARBINARY</code> カラムのみをパックするようストレージエンジンに指示します。
        </p><p>
          <code class="literal">PACK_KEYS</code> を使用しない場合、デフォルトでは文字列をパックしますが、数値はパックしません。<code class="literal">PACK_KEYS=1</code> を使用した場合は、数値もパックされます。
        </p><p>
          2 進数のキーをパックする場合、MySQL は次のプリフィクス圧縮を使用します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              前のキーの何バイトが次のキーと同じであるかを示すために、すべてのキーに 1 バイトが余分に必要になります。
            </p></li><li class="listitem"><p>
              行へのポインタは、圧縮率を向上させるために、キーの直後に高位バイトが先に来る順序で格納されます。
            </p></li></ul></div><p>
          つまり、2 つの連続した行に等しいキーが多数存在する場合は、次の<span class="quote">「<span class="quote">同じ</span>」</span>キーはすべて、通常 (行へのポインタを含め) 2 バイトしか占有しません。これを、次のキーが <code class="literal">storage_size_for_key + pointer_size</code> (ここで、ポインタサイズは通常 4) を占有する通常のケースと比較してください。逆に言うと、プリフィクス圧縮から大きな利点が得られるのは、同じ数値が多数存在する場合だけです。すべてのキーが完全に異なっている場合は、そのキーが <code class="literal">NULL</code> 値を持つことができるキーでないかぎり、キーあたり 1 バイト多く使用されます。(この場合、パックされたキーの長さは、キーが <code class="literal">NULL</code> であるかどうかをマークするために使用されるのと同じバイトに格納されます。)
        </p></li><li class="listitem"><p>
          <code class="literal">PASSWORD</code>
        </p><p>
          このオプションは使用されません。<code class="filename">.frm</code> ファイルを暗号化し、ほかのどの MySQL サーバーからも使用できないようにする必要がある場合は、当社の販売部門に問い合わせてください。
        </p></li><li class="listitem"><p>
          <code class="literal">ROW_FORMAT</code>
        </p><p>
          行が格納される物理フォーマットを定義します。これらの選択は、テーブルに使用されているストレージエンジンによって異なります。
        </p><p>
          <code class="literal">InnoDB</code> テーブルの場合:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              デフォルトでは、行は圧縮形式 (<code class="literal">ROW_FORMAT=COMPACT</code>) で格納されます。
            </p></li><li class="listitem"><p>
              古いバージョンの MySQL で使用されていた非圧縮形式は、<code class="literal">ROW_FORMAT=REDUNDANT</code> を指定することによって引き続き要求できます。
            </p></li><li class="listitem"><p>
              <code class="literal">InnoDB</code> テーブルの圧縮を有効にするには、<code class="literal">ROW_FORMAT=COMPRESSED</code> を指定し、<a class="xref" href="innodb-storage-engine.html#innodb-compression" title="14.7 InnoDB 圧縮テーブル">セクション14.7「InnoDB 圧縮テーブル」</a>の手順に従います。
            </p></li><li class="listitem"><p>
              データ型 (特に <code class="literal">BLOB</code> 型) の <code class="literal">InnoDB</code> ストレージの効率を向上させるには、<code class="literal">ROW_FORMAT=DYNAMIC</code> を指定し、<a class="xref" href="innodb-storage-engine.html#innodb-row-format-dynamic" title="14.9.3 DYNAMIC および COMPRESSED 行フォーマット">セクション14.9.3「DYNAMIC および COMPRESSED 行フォーマット」</a>の手順に従います。<code class="literal">COMPRESSED</code> および <code class="literal">DYNAMIC</code> 行フォーマットはどちらも、構成設定 <code class="literal">innodb_file_per_table=1</code> および <code class="literal">innodb_file_format=barracuda</code> を使用してテーブルを作成する必要があります。
            </p></li><li class="listitem"><p>
              デフォルト以外の <code class="literal">ROW_FORMAT</code> 句を指定する場合は、<code class="literal">innodb_strict_mode</code> 構成オプションも有効にすることを考慮してください。
            </p></li><li class="listitem"><p>
              <code class="literal">InnoDB</code> 行フォーマットの詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-row-format" title="14.9 InnoDB の行ストレージと行フォーマット">セクション14.9「InnoDB の行ストレージと行フォーマット」</a>を参照してください。
            </p></li></ul></div><p>
          <code class="literal">MyISAM</code> テーブルの場合は、このオプション値を、静的行フォーマットまたは可変長行フォーマットを示す <code class="literal">FIXED</code> または <code class="literal">DYNAMIC</code> に設定できます。<span class="command"><strong>myisampack</strong></span> は、この型を <code class="literal">COMPRESSED</code> に設定します。<a class="xref" href="storage-engines.html#myisam-table-formats" title="15.2.3 MyISAM テーブルのストレージフォーマット">セクション15.2.3「MyISAM テーブルのストレージフォーマット」</a>を参照してください。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            <code class="literal">CREATE TABLE</code> ステートメントを実行するとき、テーブルに使用しているストレージエンジンでサポートされていない行フォーマットを指定した場合、テーブルはそのストレージエンジンのデフォルトの行フォーマットを使用して作成されます。<code class="literal">SHOW TABLE STATUS</code> に応答してこのカラムでレポートされる情報は、使用されている実際の行フォーマットです。作成中は元の <code class="literal">CREATE TABLE</code> 定義が保持されているため、これは <code class="literal">Create_options</code> カラム内の値とは異なる可能性があります。
          </p></div></li><li class="listitem"><p>
          <code class="literal">STATS_AUTO_RECALC</code>
        </p><p>
          <code class="literal">InnoDB</code> テーブルの<a class="link" href="glossary.html#glos_persistent_statistics" title="永続的統計">永続的統計</a>を自動的に再計算するかどうかを指定します。値 <code class="literal">DEFAULT</code> を指定すると、テーブルの永続的統計設定は <code class="literal">innodb_stats_auto_recalc</code> 構成オプションによって決定されます。値 <code class="literal">1</code> を指定すると、統計は、テーブル内のデータの 10% が変更されたときに再計算されます。値 <code class="literal">0</code> は、このテーブルの自動再計算が行われないようにします。この設定の場合、テーブルへの大幅な変更を行なったあとに統計を再計算するには、<code class="literal">ANALYZE TABLE</code> ステートメントを発行します。永続的統計機能の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="14.13.16.1 永続的オプティマイザ統計のパラメータの構成">セクション14.13.16.1「永続的オプティマイザ統計のパラメータの構成」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">STATS_PERSISTENT</code>
        </p><p>
          <code class="literal">InnoDB</code> テーブルの<a class="link" href="glossary.html#glos_persistent_statistics" title="永続的統計">永続的統計</a>を有効にするかどうかを指定します。値 <code class="literal">DEFAULT</code> を指定すると、テーブルの永続的統計設定は <code class="literal">innodb_stats_persistent</code> 構成オプションによって決定されます。値 <code class="literal">1</code> がテーブルの永続的統計を有効にするのに対して、値 <code class="literal">0</code> はこの機能を無効にします。<code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> ステートメントを使用して永続的統計を有効にしたあと、代表的なデータのテーブルへのロード後に統計を計算するには、<code class="literal">ANALYZE TABLE</code> ステートメントを発行します。永続的統計機能の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="14.13.16.1 永続的オプティマイザ統計のパラメータの構成">セクション14.13.16.1「永続的オプティマイザ統計のパラメータの構成」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">STATS_SAMPLE_PAGES</code>
        </p><p>
          インデックス付きカラムのカーディナリティーやその他の統計 (<code class="literal">ANALYZE TABLE</code> によって計算される統計など) を推定するときにサンプリングするインデックスページの数。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="14.13.16.1 永続的オプティマイザ統計のパラメータの構成">セクション14.13.16.1「永続的オプティマイザ統計のパラメータの構成」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">UNION</code>
        </p><p>
          <code class="literal">UNION</code> は、同一の <code class="literal">MyISAM</code> テーブルのコレクションを 1 つのものとしてアクセスする場合に使用されます。これは、<code class="literal">MERGE</code> テーブルでのみ機能します。<a class="xref" href="storage-engines.html#merge-storage-engine" title="15.7 MERGE ストレージエンジン">セクション15.7「MERGE ストレージエンジン」</a>を参照してください。
        </p><p>
          <code class="literal">MERGE</code> テーブルにマップするテーブルに対する <code class="literal">SELECT</code>、<code class="literal">UPDATE</code>、および <code class="literal">DELETE</code> 権限が必要です。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            以前は、使用されるすべてのテーブルが <code class="literal">MERGE</code> テーブル自体と同じデータベース内に存在する必要がありました。この制限は適用されなくなりました。
          </p></div></li></ul></div><h4><a name="idm139979087375712"></a>パーティション化</h4><p>
      <em class="replaceable"><code>partition_options</code></em> を使用すると、<code class="literal">CREATE TABLE</code> で作成されたテーブルのパーティション化を制御できます。
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        このセクションの最初にある <em class="replaceable"><code>partition_options</code></em> の構文に示されているすべてのオプションが、すべてのパーティショニングタイプに使用できるわけではありません。各タイプに固有の情報については、次の個々のタイプのリストを参照してください。また、MySQL でのパーティション化の動作や使用に関するより詳細な情報、および MySQL のパーティション化に関連したテーブル作成やその他のステートメントの追加の例については、<a class="xref" href="partitioning.html" title="第 19 章 パーティション化">第19章「<i>パーティション化</i>」</a>を参照してください。
      </p></div><p>
      <em class="replaceable"><code>partition_options</code></em> 句が使用される場合、この句は <code class="literal">PARTITION BY</code> で始まります。この句には、パーティションを決定するために使用される関数が含まれています。この関数は、1 から <em class="replaceable"><code>num</code></em> までの範囲の整数値を返します。ここで、<em class="replaceable"><code>num</code></em> はパーティションの数です。(テーブルに含めることのできるユーザー定義パーティションの最大数は 1024 です。この最大数には、このセクションのあとの方で説明されているサブパーティションの数が含まれています。)MySQL 5.6 で、この関数に使用可能な選択肢を次のリストに示します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">HASH(<em class="replaceable"><code>expr</code></em>)</code>: 行の配置および検索のためのキーを作成するために 1 つ以上のカラムをハッシュします。<em class="replaceable"><code>expr</code></em> は、1 つ以上のテーブルカラムを使用した式です。これは、1 つの整数値が得られる任意の有効な MySQL 式 (MySQL 関数を含む) にすることができます。たとえば、次はどちらも、<code class="literal">PARTITION BY HASH</code> を使用した有効な <code class="literal">CREATE TABLE</code> ステートメントです。
        </p><pre class="programlisting">
CREATE TABLE t1 (col1 INT, col2 CHAR(5))
    PARTITION BY HASH(col1);

CREATE TABLE t1 (col1 INT, col2 CHAR(5), col3 DATETIME)
    PARTITION BY HASH ( YEAR(col3) );
</pre><p>
          <code class="literal">PARTITION BY HASH</code> では、<code class="literal">VALUES LESS THAN</code> または <code class="literal">VALUES IN</code> のどちらの句も使用できません。
        </p><p>
          <code class="literal">PARTITION BY HASH</code> は、<em class="replaceable"><code>expr</code></em> をパーティションの数で割った余り (つまり、法) を使用します。例および追加情報については、<a class="xref" href="partitioning.html#partitioning-hash" title="19.2.4 HASH パーティショニング">セクション19.2.4「HASH パーティショニング」</a>を参照してください。
        </p><p>
          <code class="literal">LINEAR</code> キーワードには、いくぶん異なるアルゴリズムが必要になります。この場合、行が格納されるパーティションの数は、1 つ以上の論理的な <code class="literal">AND</code> 演算の結果として計算されます。線形ハッシュの説明および例については、<a class="xref" href="partitioning.html#partitioning-linear-hash" title="19.2.4.1 LINEAR HASH パーティショニング">セクション19.2.4.1「LINEAR HASH パーティショニング」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">KEY(<em class="replaceable"><code>column_list</code></em>)</code>: これは <code class="literal">HASH</code> に似ていますが、均一なデータ分散を保証するために MySQL がハッシュ関数を提供する点が異なります。<em class="replaceable"><code>column_list</code></em> 引数は、単純に 1 つ以上のテーブルカラム (最大 16 個) のリストです。この例は、4 つのパーティションを持つ、キーによってパーティション化された単純なテーブルを示しています。
        </p><pre class="programlisting">
CREATE TABLE tk (col1 INT, col2 CHAR(5), col3 DATE)
    PARTITION BY KEY(col3)
    PARTITIONS 4;
</pre><p>
          キーによってパーティション化されたテーブルの場合は、<code class="literal">LINEAR</code> キーワードを使用して線形パーティション化を採用できます。これには、<code class="literal">HASH</code> によってパーティション化されたテーブルの場合と同じ効果があります。つまり、パーティション番号は法ではなく、<code class="literal">&amp;</code> 演算子を使用して見つけられます (詳細は、<a class="xref" href="partitioning.html#partitioning-linear-hash" title="19.2.4.1 LINEAR HASH パーティショニング">セクション19.2.4.1「LINEAR HASH パーティショニング」</a>および<a class="xref" href="partitioning.html#partitioning-key" title="19.2.5 KEY パーティショニング">セクション19.2.5「KEY パーティショニング」</a>を参照してください)。この例では、キーによる線形パーティション化を使用して 5 つのパーティション間でデータを分散させます。
        </p><pre class="programlisting">
CREATE TABLE tk (col1 INT, col2 CHAR(5), col3 DATE)
    PARTITION BY LINEAR KEY(col3)
    PARTITIONS 5;
</pre><p>
          <code class="literal">ALGORITHM={1|2}</code> オプションは、MySQL 5.6.11 から <code class="literal">[SUB]PARTITION BY [LINEAR] KEY</code> でサポートされています。<code class="literal">ALGORITHM=1</code> を指定すると、サーバーは MySQL 5.1 と同じキーハッシュ関数を使用します。<code class="literal">ALGORITHM=2</code> は、サーバーが、MySQL 5.5 以降で実装され、<code class="literal">KEY</code> によってパーティション化された新しいテーブルに対してデフォルトで使用されるキーハッシュ関数を採用することを示します。(MySQL 5.5 以降で採用されたキーハッシュ関数によって作成されたパーティション化されたテーブルを MySQL 5.1 サーバーで使用することはできません。)このオプションを指定しない場合は、<code class="literal">ALGORITHM=2</code> を使用するのと同じ効果があります。このオプションは、主に <code class="literal">[LINEAR] KEY</code> によってパーティション化されたテーブルを MySQL 5.1 以降の MySQL バージョン間でアップグレードまたはダウングレードするときに使用するか、または MySQL 5.5 以降のサーバー上で、MySQL 5.1 サーバー上で使用できる <code class="literal">KEY</code> または <code class="literal">LINEAR KEY</code> によってパーティション化されたテーブルを作成することを目的にしています。詳細は、<a class="xref" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1 ALTER TABLE パーティション操作">セクション13.1.7.1「ALTER TABLE パーティション操作」</a>を参照してください。
        </p><p>
          MySQL 5.6.11 以降の <span class="command"><strong>mysqldump</strong></span> は、このオプションをバージョン管理されたコメント内に次のように書き込みます。
        </p><pre class="programlisting">
CREATE TABLE t1 (a INT)
/*!50100 PARTITION BY KEY */ <span class="emphasis"><em>/*!50611 ALGORITHM = 1 */</em></span> /*!50100 ()
      PARTITIONS 3 */
</pre><p>
          これにより、MySQL 5.6.10 以前のサーバーはこのオプションを無視するようになります。これらのバージョンでは、通常であれば構文エラーが発生します。<code class="literal">KEY</code> によってパーティション化またはサブパーティション化されたテーブルを使用している MySQL 5.5.31 またはそれ以降の MySQL 5.5 サーバー上で作成されたダンプを、バージョン 5.6.11 より前の MySQL 5.6 サーバーにロードする予定がある場合は、続行する前に、必ず<a class="xref" href="installing.html#upgrading-from-previous-series" title="2.11.1.3 MySQL 5.5 から 5.6 へのアップグレード">セクション2.11.1.3「MySQL 5.5 から 5.6 へのアップグレード」</a>を参照するようにしてください。(そこで見つかった情報は、MySQL 5.6.11 以降のサーバーから作成された <code class="literal">KEY</code> によってパーティション化またはサブパーティション化されたテーブルを含むダンプを、MySQL 5.5.30 以前のサーバーにロードする場合にも適用されます。)
        </p><p>
          また、MySQL 5.6.11 以降では、<code class="literal">ALGORITHM=1</code> が <span class="command"><strong>mysqldump</strong></span> と同じ方法で、バージョン管理されたコメントを使用して <code class="literal">SHOW CREATE TABLE</code> の出力に必要に応じて表示されます。<code class="literal">ALGORITHM=2</code> は、元のテーブルを作成するときにこのオプションが指定された場合でも、<code class="literal">SHOW CREATE TABLE</code> の出力から常に省略されます。
        </p><p>
          <code class="literal">PARTITION BY KEY</code> では、<code class="literal">VALUES LESS THAN</code> または <code class="literal">VALUES IN</code> のどちらの句も使用できません。
        </p></li><li class="listitem"><p>
          <code class="literal">RANGE(<em class="replaceable"><code>expr</code></em>)</code>: この場合、<em class="replaceable"><code>expr</code></em> は、<code class="literal">VALUES LESS THAN</code> 演算子のセットを使用して値の範囲を示します。範囲のパーティション化を使用する場合は、<code class="literal">VALUES LESS THAN</code> を使用して、少なくとも 1 つのパーティションを定義する必要があります。範囲のパーティション化では <code class="literal">VALUES IN</code> を使用できません。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            <code class="literal">RANGE</code> によってパーティション化されたテーブルでは、<code class="literal">VALUES LESS THAN</code> を整数リテラル値、または 1 つの整数値に評価される式のどちらかとともに使用する必要があります。MySQL 5.6 では、このセクションのあとの方で説明されている、<code class="literal">PARTITION BY RANGE COLUMNS</code> を使用して定義されたテーブルでこの制限を克服できます。
          </p></div><p>
          次のスキームに従って、年の値を含むカラムに関してパーティション化するテーブルがあるとします。
        </p><div class="informaltable"><table summary="この表は、前の文章で説明されているように、年の値を含むカラムに基づいたテーブルパーティション化スキームを示しています。この表は、パーティション番号および対応する年の範囲を一覧表示しています。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">パーティション番号:</th><th scope="col">年の範囲:</th></tr></thead><tbody><tr><td scope="row">0</td><td>1990 以前</td></tr><tr><td scope="row">1</td><td>1991 から 1994 まで</td></tr><tr><td scope="row">2</td><td>1995 から 1998 まで</td></tr><tr><td scope="row">3</td><td>1999 から 2002 まで</td></tr><tr><td scope="row">4</td><td>2003 から 2005 まで</td></tr><tr><td scope="row">5</td><td>2006 以降</td></tr></tbody></table></div><p>
          このようなパーティション化スキームを実装するテーブルは、次に示す <code class="literal">CREATE TABLE</code> ステートメントによって実現できます。
        </p><pre class="programlisting">
CREATE TABLE t1 (
    year_col  INT,
    some_data INT
)
PARTITION BY RANGE (year_col) (
    PARTITION p0 VALUES LESS THAN (1991),
    PARTITION p1 VALUES LESS THAN (1995),
    PARTITION p2 VALUES LESS THAN (1999),
    PARTITION p3 VALUES LESS THAN (2002),
    PARTITION p4 VALUES LESS THAN (2006),
    PARTITION p5 VALUES LESS THAN MAXVALUE
);
</pre><p>
          <code class="literal">PARTITION ... VALUES LESS THAN ...</code> ステートメントは、連続的に機能します。<code class="literal">VALUES LESS THAN MAXVALUE</code> は、それ以外で指定されている最大値より大きい<span class="quote">「<span class="quote">残りの</span>」</span>値を指定するように機能します。
        </p><p>
          <code class="literal">VALUES LESS THAN</code> 句は (C、Java、PHP などの多くのプログラミング言語に見られるような) <code class="literal">switch ... case</code> ブロックの <code class="literal">case</code> 部分と同様の方法で連続的に機能します。つまり、この句は、連続した各 <code class="literal">VALUES LESS THAN</code> で指定されている上限が前の句の上限より大きく、かつ <code class="literal">MAXVALUE</code> を参照している句がリスト内のすべての句の最後に来るような方法で配置されている必要があります。
        </p></li><li class="listitem"><p>
          <code class="literal">RANGE COLUMNS(<em class="replaceable"><code>column_list</code></em>)</code>: <code class="literal">RANGE</code> に対するこのバリアントは、複数のカラムに関する範囲条件を使用した (つまり、<code class="literal">WHERE a = 1 AND b &lt; 10</code> や <code class="literal">WHERE a = 1 AND b = 10 AND c &lt; 10</code> などの条件を持つ) クエリーに対するパーティションプルーニングを容易にします。これにより、<code class="literal">COLUMNS</code> 句内のカラムのリストと、各 <code class="literal">PARTITION ... VALUES LESS THAN (<em class="replaceable"><code>value_list</code></em>)</code> パーティション定義句内のカラム値のセットを使用して、複数のカラム内の値の範囲を指定できるようになります。(もっとも単純なケースでは、このセットは単一カラムで構成されます。)<em class="replaceable"><code>column_list</code></em> および <em class="replaceable"><code>value_list</code></em> で参照できるカラムの最大数は 16 です。
        </p><p>
          <code class="literal">COLUMNS</code> 句で使用される <em class="replaceable"><code>column_list</code></em> には、カラムの名前のみを含めることができます。リスト内の各カラムは MySQL のデータ型のうち、整数型、文字列型、および時間または日付カラム型のいずれかである必要があります。<code class="literal">BLOB</code>、<code class="literal">TEXT</code>、<code class="literal">SET</code>、<code class="literal">ENUM</code>、<code class="literal">BIT</code>、または空間データ型を使用したカラムは許可されていません。浮動小数点数型を使用するカラムも許可されていません。また、<code class="literal">COLUMNS</code> 句では、関数や演算式も使用できません。
        </p><p>
          パーティション定義で使用される <code class="literal">VALUES LESS THAN</code> 句は、<code class="literal">COLUMNS()</code> 句に現れるカラムごとにリテラル値を指定する必要があります。つまり、各 <code class="literal">VALUES LESS THAN</code> 句で使用される値のリストには、<code class="literal">COLUMNS</code> 句にリストされているカラムの数と同じ数の値が含まれている必要があります。<code class="literal">VALUES LESS THAN</code> 句で <code class="literal">COLUMNS</code> 句に存在する数より多いか、または少ない値を使用しようとすると、このステートメントはエラー <span class="errortext">Inconsistency in usage of column lists for partitioning...</span> で失敗します。<code class="literal">VALUES LESS THAN</code> に現れるどの値にも <code class="literal">NULL</code> は使用できません。この例に示すように、最初のカラム以外の特定のカラムで <code class="literal">MAXVALUE</code> を複数回使用できます。
        </p><pre class="programlisting">
CREATE TABLE rc (
    a INT NOT NULL, 
    b INT NOT NULL
)
PARTITION BY RANGE COLUMNS(a,b) (
    PARTITION p0 VALUES LESS THAN (10,5),
    PARTITION p1 VALUES LESS THAN (20,10),
    PARTITION p2 VALUES LESS THAN (MAXVALUE,15),
    PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE)
);
</pre><p>
          <code class="literal">VALUES LESS THAN</code> 値リストで使用されている各値が、対応するカラムの型に正確に一致している必要があります。変換は行われません。たとえば、整数型を使用するカラムに一致する値として文字列 <code class="literal">'1'</code> を使用したり (代わりに、数値 <code class="literal">1</code> を使用する必要があります)、文字列型を使用するカラムに一致する値として数値 <code class="literal">1</code> を使用したりすることはできません (このような場合は、引用符で囲まれた文字列 <code class="literal">'1'</code> を使用する必要があります)。
        </p><p>
          詳細は、<a class="xref" href="partitioning.html#partitioning-range" title="19.2.1 RANGE パーティショニング">セクション19.2.1「RANGE パーティショニング」</a>および<a class="xref" href="partitioning.html#partitioning-pruning" title="19.4 パーティションプルーニング">セクション19.4「パーティションプルーニング」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">LIST(<em class="replaceable"><code>expr</code></em>)</code>: これは、州または国コードなどの、制限された指定可能な値のセットを持つテーブルカラムに基づいてパーティションを割り当てる場合に役立ちます。このような場合は、特定の州または国に関連するすべての行を単一パーティションに割り当てたり、特定の州または国のセットのためにパーティションを予約したりできます。これは <code class="literal">RANGE</code> に似ていますが、各パーティションに許可される値を指定するために <code class="literal">VALUES IN</code> しか使用できない点が異なります。
        </p><p>
          <code class="literal">VALUES IN</code> は、一致させる値のリストとともに使用されます。たとえば、次のようなパーティション化スキームを作成できます。
        </p><pre class="programlisting">
CREATE TABLE client_firms (
    id   INT,
    name VARCHAR(35)
)
PARTITION BY LIST (id) (
    PARTITION r0 VALUES IN (1, 5, 9, 13, 17, 21),
    PARTITION r1 VALUES IN (2, 6, 10, 14, 18, 22),
    PARTITION r2 VALUES IN (3, 7, 11, 15, 19, 23),
    PARTITION r3 VALUES IN (4, 8, 12, 16, 20, 24)
);
</pre><p>
          リストのパーティション化を使用する場合は、<code class="literal">VALUES IN</code> を使用して、少なくとも 1 つのパーティションを定義する必要があります。<code class="literal">PARTITION BY LIST</code> では <code class="literal">VALUES LESS THAN</code> を使用できません。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            <code class="literal">LIST</code> によってパーティション化されたテーブルでは、<code class="literal">VALUES IN</code> で使用される値リストを整数値のみで構成する必要があります。MySQL 5.6 では、このセクションのあとの方で説明されている、<code class="literal">LIST COLUMNS</code> によるパーティション化を使用してこの制限を克服できます。
          </p></div></li><li class="listitem"><p>
          <code class="literal">LIST COLUMNS(<em class="replaceable"><code>column_list</code></em>)</code>: <code class="literal">LIST</code> に対するこのバリアントは、複数のカラムに関する比較条件を使用した (つまり、<code class="literal">WHERE a = 5 AND b = 5</code> や <code class="literal">WHERE a = 1 AND b = 10 AND c = 5</code> などの条件を持つ) クエリーに対するパーティションプルーニングを容易にします。これにより、<code class="literal">COLUMNS</code> 句内のカラムのリストと、各 <code class="literal">PARTITION ... VALUES IN (<em class="replaceable"><code>value_list</code></em>)</code> パーティション定義句内のカラム値のセットを使用して、複数のカラム内の値を指定できるようになります。
        </p><p>
          <code class="literal">LIST COLUMNS(<em class="replaceable"><code>column_list</code></em>)</code> で使用されるカラムリストと <code class="literal">VALUES IN(<em class="replaceable"><code>value_list</code></em>)</code> で使用される値リストに関連したデータ型を管理するルールは、<code class="literal">VALUES IN</code> 句では <code class="literal">MAXVALUE</code> が許可されず、<code class="literal">NULL</code> を使用できる点を除き、それぞれ <code class="literal">RANGE COLUMNS(<em class="replaceable"><code>column_list</code></em>)</code> で使用されるカラムリストと <code class="literal">VALUES LESS THAN(<em class="replaceable"><code>value_list</code></em>)</code> で使用される値リストの場合のルールと同じです。
        </p><p>
          <code class="literal">PARTITION BY LIST COLUMNS</code> で <code class="literal">VALUES IN</code> に使用される値のリストには、<code class="literal">PARTITION BY LIST</code> で使用された場合と比較して重要な違いが 1 つあります。<code class="literal">PARTITION BY LIST COLUMNS</code> で使用された場合、<code class="literal">VALUES IN</code> 句内の各要素は、カラム値の<span class="emphasis"><em>セット</em></span>である必要があります。各セット内の値の数は <code class="literal">COLUMNS</code> 句で使用されているカラム数と同じである必要があり、これらの値のデータ型はそれらのカラムのデータ型に一致している (しかも、同じ順序で現れる) 必要があります。もっとも単純なケースでは、このセットは単一カラムで構成されます。<em class="replaceable"><code>column_list</code></em> および <em class="replaceable"><code>value_list</code></em> を構成する各要素で使用できるカラムの最大数は 16 です。
        </p><p>
          次の <code class="literal">CREATE TABLE</code> ステートメントで定義されるテーブルは、<code class="literal">LIST COLUMNS</code> パーティション化を使用したテーブルの例を示しています。
        </p><pre class="programlisting">
CREATE TABLE lc (
    a INT NULL, 
    b INT NULL
)
PARTITION BY LIST COLUMNS(a,b) (
    PARTITION p0 VALUES IN( (0,0), (NULL,NULL) ),
    PARTITION p1 VALUES IN( (0,1), (0,2), (0,3), (1,1), (1,2) ),
    PARTITION p2 VALUES IN( (1,0), (2,0), (2,1), (3,0), (3,1) ),
    PARTITION p3 VALUES IN( (1,3), (2,2), (2,3), (3,2), (3,3) )
);
</pre></li><li class="listitem"><p>
          オプションで、<code class="literal">PARTITIONS <em class="replaceable"><code>num</code></em></code> 句を使用してパーティションの数を指定できます。ここで、<em class="replaceable"><code>num</code></em> はパーティションの数です。この句<span class="emphasis"><em>と</em></span>ほかのいずれかの <code class="literal">PARTITION</code> 句の両方が使用されている場合、<em class="replaceable"><code>num</code></em> は、<code class="literal">PARTITION</code> 句を使用して宣言されているすべてのパーティションの総数と同じである必要があります。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            <code class="literal">RANGE</code> または <code class="literal">LIST</code> によってパーティション化されたテーブルの作成で <code class="literal">PARTITIONS</code> 句を使用するかどうかにかかわらず、テーブル定義には引き続き、少なくとも 1 つの <code class="literal">PARTITION VALUES</code> 句を含める必要があります (下を参照してください)。
          </p></div></li><li class="listitem"><p>
          オプションで、パーティションを複数のサブパーティションに分割できます。これは、オプションの <code class="literal">SUBPARTITION BY</code> 句を使用して示すことができます。サブパーティション化は、<code class="literal">HASH</code> または <code class="literal">KEY</code> によって実行できます。これらのどちらも <code class="literal">LINEAR</code> にすることができます。これらは、同等のパーティショニングタイプについて前に説明したのと同じように機能します。(<code class="literal">LIST</code> または <code class="literal">RANGE</code> によってサブパーティション化することはできません。)
        </p><p>
          サブパーティションの数は、<code class="literal">SUBPARTITIONS</code> キーワードと、そのあとの整数値を使用して示すことができます。
        </p></li><li class="listitem"><p>
          <code class="literal">PARTITIONS</code> または <code class="literal">SUBPARTITIONS</code> 句で使用されている値の厳密なチェックが適用され、この値は次のルールに従っている必要があります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              この値は 0 以外の正の整数である必要があります。
            </p></li><li class="listitem"><p>
              先頭の 0 は許可されません。
            </p></li><li class="listitem"><p>
              この値は整数リテラルである必要があり、式にすることはできません。たとえば、<code class="literal">0.2E+01</code> が <code class="literal">2</code> に評価されたとしても、<code class="literal">PARTITIONS 0.2E+01</code> は許可されません。(Bug #15890)
            </p></li></ul></div></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">PARTITION BY</code> 句で使用される式 (<em class="replaceable"><code>expr</code></em>) は、作成されているテーブルにはないどのカラムも参照できません。このような参照は明確に禁止されており、そのステートメントがエラーで失敗する原因になります。(Bug #29444)
      </p></div><p>
      各パーティションは、<em class="replaceable"><code>partition_definition</code></em> 句を使用して個別に定義できます。この句を構成する個別の部分は次のとおりです。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">PARTITION <em class="replaceable"><code>partition_name</code></em></code>: これはパーティションの論理名を指定します。
        </p></li><li class="listitem"><p>
          <code class="literal">VALUES</code> 句: 範囲のパーティション化では、各パーティションに <code class="literal">VALUES LESS THAN</code> 句が含まれている必要があります。リストのパーティション化では、パーティションごとに <code class="literal">VALUES IN</code> 句を指定する必要があります。これは、このパーティションにどの行を格納するかを決定するために使用されます。構文の例については、<a class="xref" href="partitioning.html" title="第 19 章 パーティション化">第19章「<i>パーティション化</i>」</a>にあるパーティショニングタイプの説明を参照してください。
        </p></li><li class="listitem"><p>
          オプションの <code class="literal">COMMENT</code> 句を使用すると、このパーティションを説明する文字列を指定できます。例:
        </p><pre class="programlisting">
COMMENT = 'Data for the years previous to 1999'
</pre><p>
          MySQL 5.6.6 から、パーティションのコメントの最大長は 1024 文字です。(以前は、この制限が明示的に定義されていませんでした。)
        </p></li><li class="listitem"><p>
          <code class="literal">DATA DIRECTORY</code> と <code class="literal">INDEX DIRECTORY</code> は、それぞれ、このパーティションのデータとインデックスが格納されるディレクトリを示すために使用できます。<code class="filename"><em class="replaceable"><code>data_dir</code></em></code> と <code class="filename"><em class="replaceable"><code>index_dir</code></em></code> はどちらも、絶対システムパス名である必要があります。例:
        </p><pre class="programlisting">
CREATE TABLE th (id INT, name VARCHAR(30), adate DATE)
PARTITION BY LIST(YEAR(adate))
(
  PARTITION p1999 VALUES IN (1995, 1999, 2003)
    DATA DIRECTORY = '<code class="filename">/var/appdata/95/data</code>'
    INDEX DIRECTORY = '<code class="filename">/var/appdata/95/idx</code>',
  PARTITION p2000 VALUES IN (1996, 2000, 2004)
    DATA DIRECTORY = '<code class="filename">/var/appdata/96/data</code>'
    INDEX DIRECTORY = '<code class="filename">/var/appdata/96/idx</code>',
  PARTITION p2001 VALUES IN (1997, 2001, 2005)
    DATA DIRECTORY = '<code class="filename">/var/appdata/97/data</code>'
    INDEX DIRECTORY = '<code class="filename">/var/appdata/97/idx</code>',
  PARTITION p2002 VALUES IN (1998, 2002, 2006)
    DATA DIRECTORY = '<code class="filename">/var/appdata/98/data</code>'
    INDEX DIRECTORY = '<code class="filename">/var/appdata/98/idx</code>'
);
</pre><p>
          <code class="literal">DATA DIRECTORY</code> と <code class="literal">INDEX DIRECTORY</code> は、<code class="literal">MyISAM</code> テーブルに使用される <code class="literal">CREATE TABLE</code> ステートメントの <em class="replaceable"><code>table_option</code></em> 句と同じように動作します。
        </p><p>
          パーティションごとに 1 つのデータディレクトリと 1 つのインデックスディレクトリを指定できます。指定されないままになっている場合、データとインデックスは、デフォルトではそのテーブルのデータベースディレクトリ内に格納されます。
        </p><p>
          Windows では、<code class="literal">DATA DIRECTORY</code> および <code class="literal">INDEX DIRECTORY</code> オプションは <code class="literal">MyISAM</code> テーブルの個々のパーティションまたはサブパーティションに対してサポートされず、<code class="literal">INDEX DIRECTORY</code> オプションは <code class="literal">InnoDB</code> テーブルの個々のパーティションまたはサブパーティションに対してサポートされません。これらのオプションは、警告が生成される点を除き、Windows では無視されます。(Bug #30459)
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            <code class="literal">DATA DIRECTORY</code> および <code class="literal">INDEX DIRECTORY</code> オプションは、<code class="literal">NO_DIR_IN_CREATE</code> が有効になっている場合、パーティション化されたテーブルの作成では無視されます。(Bug #24633)
          </p></div></li><li class="listitem"><p>
          <code class="literal">MAX_ROWS</code> と <code class="literal">MIN_ROWS</code> は、それぞれ、このパーティションに格納される行の最大数と最小数を指定するために使用できます。<em class="replaceable"><code>max_number_of_rows</code></em> と <em class="replaceable"><code>min_number_of_rows</code></em> の値は正の整数である必要があります。同じ名前を持つテーブルレベルのオプションと同様に、これらはサーバーへの<span class="quote">「<span class="quote">提案</span>」</span>としてのみ機能し、強い制限値ではありません。
        </p></li><li class="listitem"><p>
          オプションの <code class="literal">TABLESPACE</code> 句を使用すると、このパーティションのテーブルスペースを指定できます。MySQL Cluster にのみ使用されます。
        </p></li><li class="listitem"><p>
          パーティション化ハンドラは、<code class="literal">PARTITION</code> と <code class="literal">SUBPARTITION</code> の両方について <code class="literal">[STORAGE] ENGINE</code> オプションを受け入れます。現在、これを使用するには、すべてのパーティションまたはすべてのサブパーティションを同じストレージエンジンに設定するしか方法がなく、同じテーブル内のパーティションまたはサブパーティションに対して異なるストレージエンジンを設定しようとするとエラー <span class="errortext">ERROR 1469 (HY000): The mix of handlers in the partitions is not permitted in this version of MySQL</span> が発生します。将来の MySQL リリースでは、このパーティション化に関する制限を解消する予定です。
        </p></li><li class="listitem"><p>
          オプションで、パーティション定義に 1 つ以上の <em class="replaceable"><code>subpartition_definition</code></em> 句を含めることができます。これらの各句は、少なくとも <code class="literal">SUBPARTITION <em class="replaceable"><code>name</code></em></code> で構成されます。ここで、<em class="replaceable"><code>name</code></em> はそのサブパーティションの識別子です。<code class="literal">PARTITION</code> キーワードが <code class="literal">SUBPARTITION</code> に置き換えられる点を除き、サブパーティション定義の構文はパーティション定義の構文と同じです。
        </p><p>
          サブパーティション化は <code class="literal">HASH</code> または <code class="literal">KEY</code> によって実行する必要があり、<code class="literal">RANGE</code> または <code class="literal">LIST</code> パーティションに対してのみ実行できます。<a class="xref" href="partitioning.html#partitioning-subpartitions" title="19.2.6 サブパーティショニング">セクション19.2.6「サブパーティショニング」</a>を参照してください。
        </p></li></ul></div><p>
      パーティションに対しては変更、マージ、テーブルへの追加、およびテーブルからの削除が可能です。これらのタスクを実行するための MySQL ステートメントに関する基本情報については、<a class="xref" href="sql-syntax.html#alter-table" title="13.1.7 ALTER TABLE 構文">セクション13.1.7「ALTER TABLE 構文」</a>を参照してください。より詳細な説明および例については、<a class="xref" href="partitioning.html#partitioning-management" title="19.3 パーティション管理">セクション19.3「パーティション管理」</a>を参照してください。
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        元の <code class="literal">CREATE TABLE</code> ステートメント (すべての指定およびテーブルオプションを含む) は、そのテーブルが作成されるときに MySQL によって格納されます。この情報が保持されるのは、<code class="literal">ALTER TABLE</code> ステートメントを使用してストレージエンジン、照合順序、またはその他の設定を変更した場合に、指定された元のテーブルオプションが保持されるようにするためです。これにより、2 つのエンジンによってサポートされる行フォーマットが異なっていても、<code class="literal">InnoDB</code> と <code class="literal">MyISAM</code> のテーブルタイプ間での変更が可能になります。
      </p><p>
        元のステートメントのテキストは保持されますが、特定の値やオプション (<code class="literal">ROW_FORMAT</code> など) が暗黙のうちに再構成される可能性があるため、アクティブなテーブル定義 (<code class="literal">DESCRIBE</code> または <code class="literal">SHOW TABLE STATUS</code> によってアクセス可能) やテーブル作成文字列 (<code class="literal">SHOW CREATE TABLE</code> によってアクセス可能) は異なる値をレポートします。
      </p></div><h4><a name="idm139979087120144"></a>テーブルのクローニングまたはコピー</h4><a class="indexterm" name="idm139979087119392"></a><a class="indexterm" name="idm139979087118016"></a><p>
      <code class="literal">CREATE TABLE</code> ステートメントの最後に <code class="literal">SELECT</code> ステートメントを追加することによって、あるテーブルを別のテーブルから作成できます。
    </p><pre class="programlisting">
CREATE TABLE <em class="replaceable"><code>new_tbl</code></em> SELECT * FROM <em class="replaceable"><code>orig_tbl</code></em>;
</pre><p>
      詳細は、<a class="xref" href="sql-syntax.html#create-table-select" title="13.1.17.1 CREATE TABLE ... SELECT 構文">セクション13.1.17.1「CREATE TABLE ... SELECT 構文」</a>を参照してください。
    </p><p>
      別のテーブルの定義 (元のテーブルで定義されているすべてのカラム属性やインデックスを含む) に基づいて空のテーブルを作成するには、<code class="literal">LIKE</code> を使用します。
    </p><pre class="programlisting">
CREATE TABLE <em class="replaceable"><code>new_tbl</code></em> LIKE <em class="replaceable"><code>orig_tbl</code></em>;
</pre><p>
      このコピーは、元のテーブルと同じバージョンのテーブルストレージフォーマットを使用して作成されます。元のテーブルに対する <code class="literal">SELECT</code> 権限が必要です。
    </p><p>
      <code class="literal">LIKE</code> は、ビューに対してではなく、ベーステーブルに対してのみ機能します。
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        MySQL 5.6.1 から、<code class="literal">LOCK TABLES</code> ステートメントが有効になっている間は <code class="literal">CREATE TABLE</code> または <code class="literal">CREATE TABLE ... LIKE</code> を実行できません。
      </p><p>
        また MySQL 5.6.1 の時点では、<code class="literal">CREATE TABLE ... LIKE</code> は <code class="literal">CREATE TABLE</code> と同じチェックを行い、単に <code class="filename">.frm</code> ファイルをコピーするだけではありません。つまり、現在の SQL モードが、元のテーブルが作成されたときの有効なモードとは異なっている場合、テーブル定義が新しいモードでは無効と見なされる可能性があり、ステートメントは失敗します。
      </p></div><p>
      <code class="literal">CREATE TABLE ... LIKE</code> は、元のテーブルや、すべての外部キー定義に対して指定されたどの <code class="literal">DATA DIRECTORY</code> または <code class="literal">INDEX DIRECTORY</code> テーブルオプションも保持しません。
    </p><p>
      元のテーブルが <code class="literal">TEMPORARY</code> テーブルである場合、<code class="literal">CREATE TABLE ... LIKE</code> は <code class="literal">TEMPORARY</code> を保持しません。<code class="literal">TEMPORARY</code> 宛先テーブルを作成するには、<code class="literal">CREATE TEMPORARY TABLE ... LIKE</code> を使用します。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="create-table-select"></a>13.1.17.1 CREATE TABLE ... SELECT 構文</h4></div></div></div><a class="indexterm" name="idm139979087088592"></a><a class="indexterm" name="idm139979087087136"></a><p>
        <code class="literal">CREATE TABLE</code> ステートメントの最後に <code class="literal">SELECT</code> ステートメントを追加することによって、あるテーブルを別のテーブルから作成できます。
      </p><pre class="programlisting">
CREATE TABLE <em class="replaceable"><code>new_tbl</code></em> [AS] SELECT * FROM <em class="replaceable"><code>orig_tbl</code></em>;
</pre><p>
        MySQL は、<code class="literal">SELECT</code> 内のすべての要素に対して新しいカラムを作成します。例:
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE test (a INT NOT NULL AUTO_INCREMENT,</code></strong>
    -&gt;        <strong class="userinput"><code>PRIMARY KEY (a), KEY(b))</code></strong>
    -&gt;        <strong class="userinput"><code>ENGINE=MyISAM SELECT b,c FROM test2;</code></strong>
</pre><p>
        これにより、<code class="literal">a</code>、<code class="literal">b</code>、<code class="literal">c</code> の 3 つのカラムを含む <code class="literal">MyISAM</code> テーブルが作成されます。<code class="literal">ENGINE</code> オプションは <code class="literal">CREATE TABLE</code> ステートメントの一部であるため、<code class="literal">SELECT</code> のあとに使用してはいけません。これにより、構文エラーが発生します。<code class="literal">CHARSET</code> などのその他の <code class="literal">CREATE TABLE</code> オプションにも同じことが当てはまります。
      </p><p>
        <code class="literal">SELECT</code> ステートメントからのカラムは、テーブルにオーバーラップされるのではなく、テーブルの右側に付加されます。次の例を考えてみます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT * FROM foo;</code></strong>
+---+
| n |
+---+
| 1 |
+---+

mysql&gt; <strong class="userinput"><code>CREATE TABLE bar (m INT) SELECT n FROM foo;</code></strong>
Query OK, 1 row affected (0.02 sec)
Records: 1  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT * FROM bar;</code></strong>
+------+---+
| m    | n |
+------+---+
| NULL | 1 |
+------+---+
1 row in set (0.00 sec)
</pre><p>
        テーブル <code class="literal">foo</code> 内の行ごとに、<code class="literal">foo</code> からの値と新しいカラムのデフォルト値を持つ行が <code class="literal">bar</code> 内に挿入されます。
      </p><p>
        <code class="literal">CREATE TABLE ... SELECT</code> の結果として得られるテーブルでは、<code class="literal">CREATE TABLE</code> 部分でのみ指定されているカラムが最初に来ます。両方の部分で指定されているカラム、または <code class="literal">SELECT</code> 部分でのみ指定されているカラムがそのあとに来ます。<code class="literal">SELECT</code> カラムのデータ型は、<code class="literal">CREATE TABLE</code> 部分にあるカラムも指定することによってオーバーライドできます。
      </p><p>
        テーブルへのデータのコピー中にエラーが発生した場合、そのデータは自動的に削除され、作成されません。
      </p><p>
        一意のキー値を複製する行を処理する方法を示すために、<code class="literal">SELECT</code> の前に <code class="literal">IGNORE</code> または <code class="literal">REPLACE</code> を指定できます。<code class="literal">IGNORE</code> を指定すると、一意のキー値に関して既存の行を複製する行は破棄されます。<code class="literal">REPLACE</code> を指定すると、新しい行によって同じ一意のキー値を持つ行が置き換えられます。<code class="literal">IGNORE</code> と <code class="literal">REPLACE</code> のどちらも指定されていない場合は、重複した一意のキー値によってエラーが発生します。
      </p><p>
        ベースとなる <code class="literal">SELECT</code> ステートメント内の行の順序を常に特定することはできないため、MySQL 5.6.4 以降では、<code class="literal">CREATE TABLE ... IGNORE SELECT</code> および <code class="literal">CREATE TABLE ... REPLACE SELECT</code> ステートメントには、ステートメントベースのレプリケーションには安全でないというフラグが付けられます。この変更により、このようなステートメントは、ステートメントベースモードを使用しているときはログ内に警告を生成し、<code class="literal">MIXED</code> モードを使用しているときは行ベース形式を使用してログに記録されます。<a class="xref" href="replication.html#replication-sbr-rbr" title="17.1.2.1 ステートメントベースおよび行ベースレプリケーションのメリットとデメリット">セクション17.1.2.1「ステートメントベースおよび行ベースレプリケーションのメリットとデメリット」</a>も参照してください。
      </p><p>
        <code class="literal">CREATE TABLE ... SELECT</code> は、どのインデックスも自動的には作成しません。これは、ステートメントをできるだけ柔軟にするために意図的に行われます。作成されたテーブル内にインデックスを設定する場合は、これらを <code class="literal">SELECT</code> ステートメントの前に指定するようにしてください。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE bar (UNIQUE (n)) SELECT n FROM foo;</code></strong>
</pre><p>
        何らかのデータ型の変換が実行される可能性があります。たとえば、<code class="literal">AUTO_INCREMENT</code> 属性が保持されないため、<code class="literal">VARCHAR</code> カラムは <code class="literal">CHAR</code> カラムになることができます。リトレインされる属性は <code class="literal">NULL</code> (または <code class="literal">NOT NULL</code>) と、それらを含むカラムの場合は、<code class="literal">CHARACTER SET</code>、<code class="literal">COLLATION</code>、<code class="literal">COMMENT</code>、および <code class="literal">DEFAULT</code> 句です。
      </p><p>
        <code class="literal">CREATE TABLE ... SELECT</code> を使用してテーブルを作成する場合は、クエリー内のすべての関数呼び出しまたは式にエイリアスを付けるようにしてください。そうしないと、<code class="literal">CREATE</code> ステートメントが失敗するか、または好ましくないカラム名が生成される可能性があります。
      </p><pre class="programlisting">
CREATE TABLE artists_and_works
  SELECT artist.name, COUNT(work.artist_id) AS number_of_works
  FROM artist LEFT JOIN work ON artist.id = work.artist_id
  GROUP BY artist.id;
</pre><p>
        また、生成されるカラムのデータ型を明示的に指定することもできます。
      </p><pre class="programlisting">
CREATE TABLE foo (a TINYINT NOT NULL) SELECT b+1 AS a FROM bar;
</pre><p>
        <code class="literal">CREATE TABLE ... SELECT</code> で、<code class="literal">IF NOT EXISTS</code> が指定されているときに宛先テーブルがすでに存在する場合、その結果はバージョンに依存します。MySQL 5.5.6 より前は、MySQL はこのステートメントを次のように処理します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CREATE TABLE</code> 部分で指定されているテーブル定義は無視されます。その定義が既存のテーブルの定義に一致しない場合でも、エラーは発生しません。MySQL は、いずれにしても <code class="literal">SELECT</code> 部分から行を挿入しようとします。
          </p></li><li class="listitem"><p>
            テーブル内のカラム数と、<code class="literal">SELECT</code> 部分によって生成されたカラム数の間に不一致がある場合、選択された値は右端のカラムに割り当てられます。たとえば、テーブルに <em class="replaceable"><code>n</code></em> 個のカラムが含まれているとき、<code class="literal">SELECT</code> によって <em class="replaceable"><code>m</code></em> 個のカラムが生成される場合 (ここで、<em class="replaceable"><code>m</code></em> &lt; <em class="replaceable"><code>n</code></em>)、選択された値はテーブル内の右端の <em class="replaceable"><code>m</code></em> 個のカラムに割り当てられます。最初の <em class="replaceable"><code>n</code></em> - <em class="replaceable"><code>m</code></em> 個の各カラムにはデフォルト値が割り当てられます。このデフォルト値は、カラム定義で明示的に、またはその定義にデフォルトが含まれていない場合は暗黙的なカラムデータ型のデフォルトで指定されます。<code class="literal">SELECT</code> 部分によって生成されるカラムが多すぎる場合は (<em class="replaceable"><code>m</code></em> &gt; <em class="replaceable"><code>n</code></em>)、エラーが発生します。
          </p></li><li class="listitem"><p>
            厳密な SQL モードが有効になっており、かつこれらの最初のカラムのいずれにも明示的なデフォルト値が含まれていない場合、このステートメントはエラーで失敗します。
          </p></li></ul></div><p>
        次の例は、<code class="literal">IF NOT EXISTS</code> の処理を示しています。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (i1 INT DEFAULT 0, i2 INT, i3 INT, i4 INT);</code></strong>
Query OK, 0 rows affected (0.05 sec)

mysql&gt; <strong class="userinput"><code>CREATE TABLE IF NOT EXISTS t1 (c1 CHAR(10)) SELECT 1, 2;</code></strong>
Query OK, 1 row affected, 1 warning (0.01 sec)
Records: 1  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT * FROM t1;</code></strong>
+------+------+------+------+
| i1   | i2   | i3   | i4   |
+------+------+------+------+
|    0 | NULL |    1 |    2 |
+------+------+------+------+
1 row in set (0.00 sec)
</pre><p>
        MySQL 5.5.6 の時点で、<code class="literal">CREATE TABLE IF NOT EXISTS ... SELECT</code> ステートメントの処理は、宛先テーブルがすでに存在するケースに関して変更されました。また、この変更には 5.1.51 以降の MySQL 5.1 での変更も含まれています。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            以前は、<code class="literal">CREATE TABLE IF NOT EXISTS ... SELECT</code> の場合、MySQL はテーブルが存在するという警告を生成しましたが、いずれにしてもそれらの行を挿入し、そのステートメントをバイナリログに書き込みました。これに対して、<code class="literal">CREATE TABLE ... SELECT</code> (<code class="literal">IF NOT EXISTS</code> がありません) はエラーで失敗しましたが、MySQL は行を挿入せず、バイナリログにもステートメントを書き込みませんでした。
          </p></li><li class="listitem"><p>
            MySQL は現在、宛先テーブルが存在する場合、両方のステートメントを同じ方法で処理します。つまり、どちらのステートメントも行を挿入せず、またバイナリログにも書き込まれません。これらの違いは、<code class="literal">IF NOT EXISTS</code> が存在する場合は MySQL が警告を生成し、存在しない場合はエラーを生成することです。
          </p></li></ul></div><p>
        この変更は、前の例で言うと、MySQL 5.5.6 の時点では <code class="literal">CREATE TABLE IF NOT EXISTS ... SELECT</code> ステートメントが宛先テーブルに何も挿入しないことを示します。
      </p><p>
        この <code class="literal">IF NOT EXISTS</code> の処理の変更により、元の動作を行う MySQL 5.1 マスターから、新しい動作を行う MySQL 5.5 スレーブへのステートメントベースのレプリケーションで非互換性が発生します。<code class="literal">CREATE TABLE IF NOT EXISTS ... SELECT</code> がマスター上で実行されたときに、宛先テーブルが存在しているとします。その結果、マスター上では行が挿入されますが、スレーブ上では挿入されません。(行ベースのレプリケーションにはこの問題はありません。)
      </p><p>
        この問題に対処するために、MySQL 5.1 では、<code class="literal">CREATE TABLE IF NOT EXISTS ... SELECT</code> に対するステートメントベースのバイナリロギングが 5.1.51 の時点で変更されました。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            宛先テーブルが存在しない場合は、変更ありません。ステートメントはそのままログに記録されます。
          </p></li><li class="listitem"><p>
            宛先テーブルが存在しない場合、ステートメントは <code class="literal">CREATE TABLE IF NOT EXISTS</code> および <code class="literal">INSERT ... SELECT</code> ステートメントの同等のペアとしてログに記録されます。(元のステートメント内の <code class="literal">SELECT</code> の前に <code class="literal">IGNORE</code> または <code class="literal">REPLACE</code> が指定されている場合は、<code class="literal">INSERT</code> がそれぞれ、<code class="literal">INSERT IGNORE</code> または <code class="literal">REPLACE</code> になります。)
          </p></li></ul></div><p>
        この変更により、宛先テーブルが存在する場合はマスターとスレーブの両方で行が挿入されるため、MySQL 5.1 から 5.5 へのステートメントベースのレプリケーションでの上位互換性が提供されます。この互換性対策を利用するには、5.1 サーバーは少なくとも 5.1.51 である必要があり、5.5 サーバーは少なくとも 5.5.6 である必要があります。
      </p><p>
        既存の 5.1 から 5.5 へのレプリケーションシナリオをアップグレードするには、最初にマスターを 5.1.51 以降にアップグレードします。これは、最初にスレーブをアップグレードするという、通常のレプリケーションアップグレードのアドバイスとは異なります。
      </p><p>
        元の効果 (宛先テーブルが存在するかどうかには関係なく行が挿入される) を実現したいアプリケーションには、<code class="literal">CREATE TABLE IF NOT EXISTS ... SELECT</code> ステートメントではなく、<code class="literal">CREATE TABLE IF NOT EXISTS</code> および <code class="literal">INSERT ... SELECT</code> ステートメントを使用するという回避方法があります。
      </p><p>
        今説明した変更とともに、次の関連する変更が行われました。以前は、<code class="literal">CREATE TABLE IF NOT EXISTS ... SELECT</code> の宛先テーブルとして既存のビューが指定された場合、基礎となるベーステーブルに行が挿入され、このステートメントがバイナリログに書き込まれました。MySQL 5.1.51 および 5.5.6 の時点では、何も挿入されたり、ログに記録されたりしません。
      </p><p>
        バイナリログを使用して元のテーブルを確実に再作成できるようにするために、MySQL では、<code class="literal">CREATE TABLE ... SELECT</code> 中の並列挿入が許可されません。
      </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          <code class="literal">CREATE TABLE <em class="replaceable"><code>new_table</code></em> SELECT ... FROM <em class="replaceable"><code>old_table</code></em> ...</code> などのステートメントで <code class="literal">SELECT</code> の一部として <code class="literal">FOR UPDATE</code> を使用することはできません。それを行おうとすると、このステートメントは失敗します。これは、<code class="literal">CREATE TABLE ... SELECT</code> ステートメントが作成されているテーブル以外のテーブルで変更を行うことを許可していた、MySQL 5.5 およびそれ以前からの動作の変更を表しています。
        </p><p>
          この変更はまた、古いマスターから MySQL 5.6 以降のスレーブへのステートメントベースのレプリケーションにも影響を与える場合があります。詳細は、<a class="xref" href="replication.html#replication-features-create-select" title="17.4.1.5 CREATE TABLE ... SELECT ステートメントのレプリケーション">セクション17.4.1.5「CREATE TABLE ... SELECT ステートメントのレプリケーション」</a>を参照してください。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="create-table-foreign-keys"></a>13.1.17.2 外部キー制約の使用</h4></div></div></div><a class="indexterm" name="idm139979086951712"></a><a class="indexterm" name="idm139979086950240"></a><p>
        MySQL は、関連データのテーブルにまたがる相互参照を可能にする外部キーと、この分散したデータの整合性を維持するために役立つ<a class="link" href="glossary.html#glos_foreign_key_constraint" title="FOREIGN KEY 制約">外部キー制約</a>をサポートします。<code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> ステートメントで外部キー制約を定義するための基本的な構文は次のようになります。
      </p><pre class="programlisting">
[CONSTRAINT [<em class="replaceable"><code>symbol</code></em>]] FOREIGN KEY
    [<em class="replaceable"><code>index_name</code></em>] (<em class="replaceable"><code>index_col_name</code></em>, ...)
    REFERENCES <em class="replaceable"><code>tbl_name</code></em> (<em class="replaceable"><code>index_col_name</code></em>,...)
    [ON DELETE <em class="replaceable"><code>reference_option</code></em>]
    [ON UPDATE <em class="replaceable"><code>reference_option</code></em>]

<em class="replaceable"><code>reference_option</code></em>:
    RESTRICT | CASCADE | SET NULL | NO ACTION
</pre><p>
        <em class="replaceable"><code>index_name</code></em> は、外部キー ID を表します。外部キーをサポートできる子テーブル上に明示的に定義されたインデックスがすでに存在する場合、<em class="replaceable"><code>index_name</code></em> 値は無視されます。それ以外の場合、MySQL は、次のルールに従って名前が付けられた外部キーのインデックスを暗黙的に作成します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            定義されている場合は、<code class="literal">CONSTRAINT</code> <em class="replaceable"><code>symbol</code></em> 値が使用されます。それ以外の場合は、<code class="literal">FOREIGN KEY</code> <em class="replaceable"><code>index_name</code></em> 値が使用されます。
          </p></li><li class="listitem"><p>
            <code class="literal">CONSTRAINT</code> <em class="replaceable"><code>symbol</code></em> と <code class="literal">FOREIGN KEY</code> <em class="replaceable"><code>index_name</code></em> のどちらも定義されていない場合、外部キーのインデックス名は、参照している外部キーカラムの名前を使用して生成されます。
          </p></li></ul></div><p>
        外部キー定義は、次の条件に従います。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            外部キー関係には、中央のデータ値を保持している<a class="link" href="glossary.html#glos_parent_table" title="親テーブル">親テーブル</a>と、その元の親を指す同一の値を持っている<a class="link" href="glossary.html#glos_child_table" title="子テーブル">子テーブル</a>が含まれます。<code class="literal">FOREIGN KEY</code> 句は、子テーブルで指定されます。親テーブルと子テーブルは、同じストレージエンジンを使用する必要があります。これらは、<code class="literal">TEMPORARY</code> テーブルであってはいけません。
          </p></li><li class="listitem"><p>
            外部キー内の対応するカラムと、参照されるキーは同様のデータ型を持っている必要があります。<span class="emphasis"><em>整数型のサイズと符号が同じである必要があります</em></span>。文字列型の長さが同じである必要はありません。バイナリ以外の (文字の) 文字列カラムの場合、文字セットと照合順序が同じである必要があります。
          </p></li><li class="listitem"><p>
            MySQL では、外部キーチェックを高速に実行でき、かつテーブルスキャンが必要なくなるように、外部キーおよび参照されるキーに関するインデックスが必要です。参照しているテーブルには、外部キーカラムが同じ順序で<span class="emphasis"><em>最初の</em></span>カラムとしてリストされているインデックスが存在する必要があります。このようなインデックスが存在しない場合は、参照しているテーブル上に自動的に作成されます。このインデックスは、外部キー制約を適用するために使用できる別のインデックスを作成した場合、あとで暗黙のうちに削除される可能性があります。<em class="replaceable"><code>index_name</code></em> (指定されている場合) は、前に説明したとおりに使用されます。
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> では、外部キーが任意のインデックスカラムまたはカラムのグループを参照することが許可されます。ただし、参照されるテーブルには、参照されるカラムが同じ順序で<span class="emphasis"><em>最初の</em></span>カラムとして一覧表示されているインデックスが存在する必要があります。
          </p><p>
            <code class="literal">NDB</code> には、外部キーとして参照されるいずれかのカラム上の明示的な一意のキー (または主キー) が必要です。
          </p></li><li class="listitem"><p>
            外部キーカラム上のインデックスプリフィクスはサポートされていません。この 1 つの影響として、<code class="literal">BLOB</code> および <code class="literal">TEXT</code> カラム上のインデックスには常にプリフィクス長が含まれている必要があるため、それらのカラムを外部キーに含めることができない点があります。
          </p></li><li class="listitem"><p>
            <code class="literal">CONSTRAINT <em class="replaceable"><code>symbol</code></em></code> 句が指定されている場合、<em class="replaceable"><code>symbol</code></em> 値 (使用されている場合) はデータベース内で一意である必要があります。<em class="replaceable"><code>symbol</code></em> が重複している場合は、次のようなエラーが発生します: <span class="errortext">ERROR 1022 (2300): 書き込めません。テーブル '#sql- 464_1' に重複するキーがあります'</span>。この句が指定されていない場合や、<code class="literal">CONSTRAINT</code> キーワードのあとに <em class="replaceable"><code>symbol</code></em> が含まれていない場合は、制約の名前が自動的に作成されます。
          </p></li><li class="listitem"><p>
            現在、<code class="literal">InnoDB</code> ではユーザー定義のパーティションを持つテーブルの外部キーがサポートされていません。これには、親テーブルと子テーブルの両方が含まれます。
          </p><p>
            この制限は、<code class="literal">KEY</code> または <code class="literal">LINEAR KEY</code> によってパーティション化された <code class="literal">NDB</code> テーブル (<code class="literal">NDB</code> ストレージエンジンによってサポートされる唯一のユーザーパーティショニングタイプ) には適用されません。これらは外部キー参照を含むか、またはこのような参照のターゲットになることができます。
          </p></li><li class="listitem"><p>
            <code class="literal">NDB</code> テーブルでは、参照先が親テーブルの主キーである場合、<code class="literal">ON UPDATE CASCADE</code> はサポートされません。
          </p></li></ul></div><h5><a name="idm139979086895392"></a>参照アクション</h5><p>
        このセクションでは、外部キーが<a class="link" href="glossary.html#glos_referential_integrity" title="参照整合性">参照整合性</a>の保証にどのように役立つかについて説明します。
      </p><p>
        外部キーをサポートするストレージエンジンで、親テーブル内に一致する候補のキー値が存在しない場合、MySQL は、子テーブル内に外部キー値を作成しようとするすべての <code class="literal">INSERT</code> または <code class="literal">UPDATE</code> 操作を拒否します。
      </p><p>
        <code class="literal">UPDATE</code> または <code class="literal">DELETE</code> 操作が、子テーブル内に一致する行を持つ親テーブル内のキー値に影響を与える場合、その結果は、<code class="literal">FOREIGN KEY</code> 句の <code class="literal">ON UPDATE</code> および <code class="literal">ON DELETE</code> サブ句を使用して指定された<span class="emphasis"><em>参照アクション</em></span>によって異なります。MySQL は、実行されるアクションに関連した次の 5 つのオプションをサポートしています。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CASCADE</code>: 親テーブルの行を削除または更新し、子テーブル内の一致する行を自動的に削除または更新します。<code class="literal">ON DELETE CASCADE</code> と <code class="literal">ON UPDATE CASCADE</code> の両方がサポートされています。2 つのテーブル間で、親テーブルまたは子テーブル内の同じカラムに対して機能する複数の <code class="literal">ON UPDATE CASCADE</code> 句を定義しないでください。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              現在、カスケードされた外部キーのアクションではトリガーがアクティブになっていません。
            </p></div></li><li class="listitem"><p>
            <code class="literal">SET NULL</code>: 親テーブルの行を削除または更新し、子テーブル内の 1 つまたは複数の外部キーカラムを <code class="literal">NULL</code> に設定します。<code class="literal">ON DELETE SET NULL</code> 句と <code class="literal">ON UPDATE SET NULL</code> 句の両方がサポートされています。
          </p><p>
            <code class="literal">SET NULL</code> アクションを指定する場合は、<span class="emphasis"><em>子テーブル内のカラムを <code class="literal">NOT NULL</code> として宣言していないことを確認してください</em></span>。
          </p></li><li class="listitem"><p>
            <code class="literal">RESTRICT</code>: 親テーブルに対する削除または更新操作を拒否します。<code class="literal">RESTRICT</code> (または <code class="literal">NO ACTION</code>) を指定することは、<code class="literal">ON DELETE</code> または <code class="literal">ON UPDATE</code> 句を省略することと同じです。
          </p></li><li class="listitem"><p>
            <code class="literal">NO ACTION</code>: 標準 SQL のキーワード。MySQL では、<code class="literal">RESTRICT</code> と同等です。MySQL Server は、参照されるテーブル内に関連する外部キー値が存在する場合、親テーブルに対する削除または更新操作を拒否します。一部のデータベースシステムは遅延チェックを備えており、その場合、<code class="literal">NO ACTION</code> は遅延チェックです。MySQL では、外部キー制約はただちにチェックされるため、<code class="literal">NO ACTION</code> は <code class="literal">RESTRICT</code> と同じです。
          </p></li><li class="listitem"><p>
            <code class="literal">SET DEFAULT</code>: このアクションは MySQL パーサーによって認識されますが、<code class="literal">InnoDB</code> と <code class="literal">NDB</code> はどちらも、<code class="literal">ON DELETE SET DEFAULT</code> または <code class="literal">ON UPDATE SET DEFAULT</code> 句を含むテーブル定義を拒否します。
          </p></li></ul></div><p>
        指定されていない <code class="literal">ON DELETE</code> または <code class="literal">ON UPDATE</code> では、デフォルトのアクションは常に <code class="literal">RESTRICT</code> です。
      </p><p>
        MySQL は、1 つのテーブル内のあるカラムと別のカラムの間の外部キー参照をサポートしています。(あるカラムが、それ自体への外部キー参照を持つことはできません。)これらの場合、<span class="quote">「<span class="quote">子テーブルのレコード</span>」</span>は、実際に同じテーブル内の依存レコードを参照します。
      </p><h5><a name="idm139979086853440"></a>外部キー句の例</h5><p>
        単一カラム外部キーを使用して <code class="literal">parent</code> および <code class="literal">child</code> テーブルを関連付ける単純な例を次に示します。
      </p><pre class="programlisting">
CREATE TABLE parent (
    id INT NOT NULL,
    PRIMARY KEY (id)
) ENGINE=INNODB;

CREATE TABLE child (
    id INT, 
    parent_id INT,
    INDEX par_ind (parent_id),
    FOREIGN KEY (parent_id) 
        REFERENCES parent(id)
        ON DELETE CASCADE
) ENGINE=INNODB;
</pre><p>
        <code class="literal">product_order</code> テーブルにほかの 2 つのテーブルへの外部キーが存在する、より複雑な例。1 つの外部キーが、<code class="literal">product</code> テーブル内の 2 カラムのインデックスを参照しています。もう一方の外部キーは、<code class="literal">customer</code> テーブル内の単一カラムインデックスを参照しています。
      </p><pre class="programlisting">
CREATE TABLE product (
    category INT NOT NULL, id INT NOT NULL,
    price DECIMAL,
    PRIMARY KEY(category, id)
)   ENGINE=INNODB;

CREATE TABLE customer (
    id INT NOT NULL,
    PRIMARY KEY (id)
)   ENGINE=INNODB;

CREATE TABLE product_order (
    no INT NOT NULL AUTO_INCREMENT,
    product_category INT NOT NULL,
    product_id INT NOT NULL,
    customer_id INT NOT NULL,

    PRIMARY KEY(no),
    INDEX (product_category, product_id),
    INDEX (customer_id),

    FOREIGN KEY (product_category, product_id)
      REFERENCES product(category, id)
      ON UPDATE CASCADE ON DELETE RESTRICT,

    FOREIGN KEY (customer_id)
      REFERENCES customer(id)
)   ENGINE=INNODB;
</pre><h5><a name="idm139979086843264"></a>外部キーの追加</h5><p>
        <code class="literal">ALTER TABLE</code> を使用して、既存のテーブルに新しい外部キー制約を追加できます。このステートメントの外部キーに関連した構文を次に示します。
      </p><pre class="programlisting">
ALTER TABLE <em class="replaceable"><code>tbl_name</code></em>
    ADD [CONSTRAINT [<em class="replaceable"><code>symbol</code></em>]] FOREIGN KEY
    [<em class="replaceable"><code>index_name</code></em>] (<em class="replaceable"><code>index_col_name</code></em>, ...)
    REFERENCES <em class="replaceable"><code>tbl_name</code></em> (<em class="replaceable"><code>index_col_name</code></em>,...)
    [ON DELETE <em class="replaceable"><code>reference_option</code></em>]
    [ON UPDATE <em class="replaceable"><code>reference_option</code></em>]
</pre><p>
        外部キーは、自己参照型にする (同じテーブルを参照する) ことができます。<code class="literal">ALTER TABLE</code> を使用してテーブルに外部キー制約を追加する場合は、<span class="emphasis"><em>まず必要なインデックスを作成することを忘れないでください。</em></span>
      </p><h5><a name="idm139979086834416"></a>外部キーの削除</h5><a class="indexterm" name="idm139979086833728"></a><a class="indexterm" name="idm139979086832496"></a><a class="indexterm" name="idm139979086830352"></a><p>
        次に示す構文を使用して、<code class="literal">ALTER TABLE</code> で外部キーを削除することもできます。
      </p><pre class="programlisting">
ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> DROP FOREIGN KEY <em class="replaceable"><code>fk_symbol</code></em>;
</pre><p>
        外部キーを作成したときに <code class="literal">FOREIGN KEY</code> 句に <code class="literal">CONSTRAINT</code> の名前が含まれていた場合は、その名前を参照して外部キーを削除できます。それ以外の場合は、外部キーが作成されるときに <em class="replaceable"><code>fk_symbol</code></em> 値が内部的に生成されます。外部キーを削除するときにシンボル値を見つけるには、次に示すように、<code class="literal">SHOW CREATE TABLE</code> ステートメントを使用します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE ibtest11c\G</code></strong>
*************************** 1. row ***************************
       Table: ibtest11c
Create Table: CREATE TABLE `ibtest11c` (
  `A` int(11) NOT NULL auto_increment,
  `D` int(11) NOT NULL default '0',
  `B` varchar(200) NOT NULL default '',
  `C` varchar(175) default NULL,
  PRIMARY KEY  (`A`,`D`,`B`),
  KEY `B` (`B`,`C`),
  KEY `C` (`C`),
  CONSTRAINT `0_38775` FOREIGN KEY (`A`, `D`)
REFERENCES `ibtest11a` (`A`, `D`)
ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `0_38776` FOREIGN KEY (`B`, `C`)
REFERENCES `ibtest11a` (`B`, `C`)
ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=INNODB CHARSET=latin1
1 row in set (0.01 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE ibtest11c DROP FOREIGN KEY `0_38775`;</code></strong>
</pre><p>
        MySQL 5.6.6 より前は、同じ <code class="literal">ALTER TABLE</code> ステートメントでの外部キーの追加と削除は、問題が発生する場合があるためサポートされていません。操作ごとに個別のステートメントを使用するようにしてください。MySQL 5.6.6 の時点では、同じ <code class="literal">ALTER TABLE</code> ステートメントでの外部キーの追加と削除は <code class="literal">ALTER TABLE ... ALGORITHM=INPLACE</code> ではサポートされますが、<code class="literal">ALTER TABLE ... ALGORITHM=COPY</code> では未サポートのままです。
      </p><p>
        MySQL 5.6.7 より前は、<code class="literal">ALTER TABLE</code> を使用して外部キーカラムの定義を変更すると、参照整合性が失われる可能性がありました。たとえば、<code class="literal">NULL</code> 値を含む外部キーカラムを <code class="literal">NOT NULL</code> になるように変更すると、<code class="literal">NULL</code> 値が空の文字列になりました。同様に、親テーブル内の行を削除する <code class="literal">ALTER TABLE IGNORE</code> によって、参照整合性が破壊される可能性がありました。
      </p><p>
        5.6.7 の時点では、参照整合性が失われる可能性のある外部キーカラムへの変更がサーバーによって禁止されます。回避方法として、カラム定義を変更する前に <code class="literal">ALTER TABLE ... DROP FOREIGN KEY</code> を使用し、あとで <code class="literal">ALTER TABLE ... ADD FOREIGN KEY</code> を使用します。
      </p><h5><a name="idm139979086802064"></a>外部キーおよびその他の MySQL ステートメント</h5><p>
        <code class="literal">FOREIGN KEY ... REFERENCES ...</code> 句内のテーブルとカラムの識別子は、逆引用符 (<code class="literal">`</code>) で囲むことができます。あるいは、<code class="literal">ANSI_QUOTES</code> SQL モードが有効になっている場合は、二重引用符 (<code class="literal">"</code>) を使用できます。また、<code class="literal">lower_case_table_names</code> システム変数の設定も考慮に入れられます。
      </p><p>
        <code class="literal">SHOW CREATE TABLE</code> ステートメントの出力の一部として、子テーブルの外部キー定義を表示できます。
      </p><pre class="programlisting">
SHOW CREATE TABLE <em class="replaceable"><code>tbl_name</code></em>;
</pre><p>
        <code class="literal">INFORMATION_SCHEMA.KEY_COLUMN_USAGE</code> テーブルをクエリーすることによって、外部キーに関する情報を取得することもできます。
      </p><p>
        <code class="literal">INNODB_SYS_FOREIGN</code> および <code class="literal">INNODB_SYS_FOREIGN_COLS</code> テーブル、さらには <code class="literal">INFORMATION_SCHEMA</code> データベース内の <code class="literal">InnoDB</code> テーブルによって使用される外部キーに関する情報を検索できます。
      </p><p>
        <span class="command"><strong>mysqldump</strong></span> は、テーブルの正しい定義 (子テーブルへの外部キーを含む) をダンプファイル内に生成します。
      </p><p>
        外部キー関係を持つテーブルのダンプファイルのリロードを容易にするために、<span class="command"><strong>mysqldump</strong></span> は、<code class="literal">foreign_key_checks</code> を 0 に設定するステートメントをダンプ出力内に自動的に含めます。これにより、ダンプがリロードされるときに特定の順序でリロードする必要のあるテーブルに関する問題が回避されます。また、この変数を手動で設定することもできます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET foreign_key_checks = 0;</code></strong>
mysql&gt; <strong class="userinput"><code>SOURCE <em class="replaceable"><code>dump_file_name</code></em>;</code></strong>
mysql&gt; <strong class="userinput"><code>SET foreign_key_checks = 1;</code></strong>
</pre><p>
        これにより、外部キーに関して正しく順序付けられていないテーブルがダンプファイルに含まれている場合でも、そのテーブルを任意の順序でインポートできます。また、インポート操作も高速化されます。<code class="literal">foreign_key_checks</code> を 0 に設定することは、<code class="literal">LOAD DATA</code> および <code class="literal">ALTER TABLE</code> 操作中に外部キー制約を無視するためにも役立つ場合があります。ただし、<code class="literal">foreign_key_checks = 0</code> の場合でも、MySQL では、カラムが一致しないカラム型を参照している外部キー制約の作成は許可されません。また、テーブルに外部キー制約が存在する場合は、<code class="literal">ALTER TABLE</code> を使用して、そのテーブルを別のストレージエンジンを使用するように変更することはできません。ストレージエンジンを変更するには、まず外部キー制約をすべて削除する必要があります。
      </p><p>
        <code class="literal">SET foreign_key_checks = 0</code> を実行しないかぎり、<code class="literal">FOREIGN KEY</code> 制約によって参照されるテーブルに対して <code class="literal">DROP TABLE</code> を発行できません。テーブルを削除すると、そのテーブルを作成するために使用されたステートメントで定義されていた制約もすべて削除されます。
      </p><p>
        削除されたテーブルを再作成する場合は、そのテーブルに、それを参照している外部キー制約に準拠する定義が存在する必要があります。また、カラムの正しい名前と型、および前に説明した参照されるキーに関するインデックスが存在する必要があります。これらが満たされていない場合、MySQL はエラー 1005 を返し、エラーメッセージでエラー 150 を示します。これは、外部キー制約が正しく形成されなかったことを示します。同様に、<code class="literal">ALTER TABLE</code> がエラー 150 で失敗した場合、これは、変更されたテーブルのために外部キー定義が誤って形成されることを示します。
      </p><p>
        <code class="literal">InnoDB</code> テーブルの場合は、<code class="literal">SHOW ENGINE INNODB STATUS</code> の出力をチェックすることによって、MySQL Server で最新の <code class="literal">InnoDB</code> 外部キーエラーの詳細な説明を取得できます。
      </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          ANSI/ISO SQL 標準に精通しているユーザーの場合は、参照整合性の制約定義で使用される <code class="literal">MATCH</code> 句を認識または適用するストレージエンジンは (<code class="literal">InnoDB</code> を含め) 存在しません。明示的な <code class="literal">MATCH</code> 句を使用しても、指定された効果が得られないだけでなく、<code class="literal">ON DELETE</code> および <code class="literal">ON UPDATE</code> 句が無視される原因にもなります。これらの理由により、<code class="literal">MATCH</code> の指定は避けるようにしてください。
        </p><p>
          SQL 標準での <code class="literal">MATCH</code> 句は、複合 (マルチカラム) 外部キー内の <code class="literal">NULL</code> 値が、主キーとの比較時にどのように処理されるかを制御します。MySQL は基本的に、外部キーをすべてまたは部分的に <code class="literal">NULL</code> にすることが許可される、<code class="literal">MATCH SIMPLE</code> で定義されるセマンティクスを実装しています。その場合は、このような外部キーを含む (子テーブルの) 行の挿入が許可され、その行は参照される (親) テーブル内のどの行にも一致しません。トリガーを使用して、ほかのセマンティクスを実装できます。
        </p><p>
          さらに、MySQL ではパフォーマンス上の理由から、参照されるカラムにインデックスを設定する必要があります。ただし、システムでは、参照されるカラムを <code class="literal">UNIQUE</code> にするか、または <code class="literal">NOT NULL</code> として宣言するという要件は適用されません。一意でないキーまたは <code class="literal">NULL</code> 値を含むキーへの外部キー参照の処理は、<code class="literal">UPDATE</code> や <code class="literal">DELETE CASCADE</code> などの操作に対して適切に定義されていません。<code class="literal">UNIQUE</code> (<code class="literal">PRIMARY</code> を含む) および <code class="literal">NOT NULL</code> キーのみを参照する外部キーを使用することをお勧めします。
        </p><p>
          さらに、MySQL は、参照がカラム指定の一部として定義されている (SQL 標準で定義された) <span class="quote">「<span class="quote">インラインの <code class="literal">REFERENCES</code> 指定</span>」</span>を認識せず、またサポートもしていません。MySQL は、個別の <code class="literal">FOREIGN KEY</code> 指定の一部として指定されている場合にのみ <code class="literal">REFERENCES</code> 句を受け入れます。外部キーをサポートしていない (<code class="literal">MyISAM</code> などの) ストレージエンジンの場合、MySQL Server は、外部キーの指定を解析して無視します。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="silent-column-changes"></a>13.1.17.3 暗黙のカラム指定の変更</h4></div></div></div><a class="indexterm" name="idm139979086740160"></a><p>
        MySQL は場合によって、カラム指定を <code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> ステートメントで指定されたものから暗黙のうちに変更することがあります。これらの変更は、データ型、データ型に関連付けられた属性、またはインデックス指定に対して行われる可能性があります。
      </p><p>
        すべての変更は 65,535 バイトの内部の行サイズ制限に従うため、データ型を変更しようとする一部の試みが失敗する可能性があります。<a class="xref" href="restrictions.html#column-count-limit" title="D.10.4 テーブルカラム数と行サイズの制限">セクションD.10.4「テーブルカラム数と行サイズの制限」</a>を参照してください。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">PRIMARY KEY</code> の一部であるカラムは、そのように宣言されていない場合でも、<code class="literal">NOT NULL</code> にされます。
          </p></li><li class="listitem"><p>
            テーブルが作成されたとき、<code class="literal">ENUM</code> および <code class="literal">SET</code> メンバー値から末尾のスペースが自動的に削除されます。
          </p></li><li class="listitem"><p>
            MySQL は、ほかの SQL データベースベンダーによって使用されている特定のデータ型を MySQL 型にマップします。<a class="xref" href="data-types.html#other-vendor-data-types" title="11.9 その他のデータベースエンジンのデータ型の使用">セクション11.9「その他のデータベースエンジンのデータ型の使用」</a>を参照してください。
          </p></li><li class="listitem"><p>
            特定のストレージエンジンには許可されないインデックスタイプを指定するために <code class="literal">USING</code> 句を含めたが、そのエンジンがクエリー結果に影響を与えることなく使用できる使用可能な別のインデックスタイプが存在する場合、エンジンはその使用可能なタイプを使用します。
          </p></li><li class="listitem"><p>
            厳密な SQL モードが有効になっていない場合、長さ指定が 65535 より大きい <code class="literal">VARCHAR</code> カラムは <code class="literal">TEXT</code> に変換され、長さ指定が 65535 より大きい <code class="literal">VARBINARY</code> カラムは <code class="literal">BLOB</code> に変換されます。そうでない場合は、これらのいずれの場合にもエラーが発生します。
          </p></li><li class="listitem"><p>
            文字データ型に <code class="literal">CHARACTER SET binary</code> 属性を指定すると、カラムは対応するバイナリデータ型として作成されます。つまり、<code class="literal">CHAR</code> は <code class="literal">BINARY</code> になり、<code class="literal">VARCHAR</code> は <code class="literal">VARBINARY</code> になり、<code class="literal">TEXT</code> は <code class="literal">BLOB</code> になります。<code class="literal">ENUM</code> および <code class="literal">SET</code> データ型では、これは行われず、宣言されたとおりに作成されます。この定義を使用して、テーブルを指定したとします。
          </p><pre class="programlisting">
CREATE TABLE t
(
  c1 VARCHAR(10) CHARACTER SET binary,
  c2 TEXT CHARACTER SET binary,
  c3 ENUM('a','b','c') CHARACTER SET binary
);
</pre><p>
            結果のテーブルには、この定義が含まれています。
          </p><pre class="programlisting">
CREATE TABLE t
(
  c1 VARBINARY(10),
  c2 BLOB,
  c3 ENUM('a','b','c') CHARACTER SET binary
);
</pre></li></ul></div><p>
        MySQL が、指定したもの以外のデータ型を使用したかどうかを確認するには、テーブルを作成または変更したあとに、<code class="literal">DESCRIBE</code> または <code class="literal">SHOW CREATE TABLE</code> ステートメントを発行します。
      </p><a class="indexterm" name="idm139979086703968"></a><p>
        <span class="command"><strong>myisampack</strong></span> を使用してテーブルを圧縮する場合は、その他の特定のデータ型の変更が発生する場合があります。<a class="xref" href="storage-engines.html#compressed-format" title="15.2.3.3 圧縮テーブルの特徴">セクション15.2.3.3「圧縮テーブルの特徴」</a>を参照してください。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="create-tablespace"></a>13.1.18 CREATE TABLESPACE 構文</h3></div></div></div><a class="indexterm" name="idm139979086699104"></a><pre class="programlisting">
CREATE TABLESPACE <em class="replaceable"><code>tablespace_name</code></em>
    ADD DATAFILE '<em class="replaceable"><code>file_name</code></em>'
    USE LOGFILE GROUP <em class="replaceable"><code>logfile_group</code></em>
    [EXTENT_SIZE [=] <em class="replaceable"><code>extent_size</code></em>]
    [INITIAL_SIZE [=] <em class="replaceable"><code>initial_size</code></em>]
    [AUTOEXTEND_SIZE [=] <em class="replaceable"><code>autoextend_size</code></em>]
    [MAX_SIZE [=] <em class="replaceable"><code>max_size</code></em>]
    [NODEGROUP [=] <em class="replaceable"><code>nodegroup_id</code></em>]
    [WAIT]
    [COMMENT [=] <em class="replaceable"><code>comment_text</code></em>]
    ENGINE [=] <em class="replaceable"><code>engine_name</code></em>
</pre><p>
      このステートメントは、テーブルスペースを作成するために使用されます。テーブルスペースは 1 つ以上のデータファイルを含むことができ、テーブルのストレージ領域を提供します。このステートメントを使用して 1 つのデータファイルが作成され、テーブルスペースに追加されます。<code class="literal">ALTER TABLESPACE</code> ステートメントを使用して、テーブルスペースにデータファイルを追加できます (<a class="xref" href="sql-syntax.html#alter-tablespace" title="13.1.8 ALTER TABLESPACE 構文">セクション13.1.8「ALTER TABLESPACE 構文」</a>を参照してください)。テーブルスペースの命名を管理するルールについては、<a class="xref" href="language-structure.html#identifiers" title="9.2 スキーマオブジェクト名">セクション9.2「スキーマオブジェクト名」</a>を参照してください。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        すべての MySQL Cluster ディスクデータオブジェクトが同じ名前空間を共有します。つまり、<span class="emphasis"><em>各ディスクデータオブジェクト</em></span>は (単に、特定の型の各ディスクデータオブジェクトというだけでなく)、一意の名前が付けられている必要があります。たとえば、テーブルスペースとログファイルグループを同じ名前にしたり、テーブルスペースとデータファイルを同じ名前にしたりすることはできません。
      </p></div><p>
      作成されるテーブルスペースには、<code class="literal">USE LOGFILE GROUP</code> 句を使用して、1 つ以上の <code class="literal">UNDO</code> ログファイルのログファイルグループを割り当てる必要があります。<em class="replaceable"><code>logfile_group</code></em> は、<code class="literal">CREATE LOGFILE GROUP</code> で作成された既存のログファイルグループである必要があります (<a class="xref" href="sql-syntax.html#create-logfile-group" title="13.1.14 CREATE LOGFILE GROUP 構文">セクション13.1.14「CREATE LOGFILE GROUP 構文」</a>を参照してください)。複数のテーブルスペースが <code class="literal">UNDO</code> ロギングのために同じログファイルグループを使用できます。
    </p><p>
      <code class="literal">EXTENT_SIZE</code> は、そのテーブルスペースに属するすべてのファイルによって使用されるエクステントのサイズ (バイト単位) を設定します。デフォルト値は 1M です。最小サイズは 32K であり、理論的な最大サイズは 2G です。ただし、実際的な最大サイズはいくつかの要因によって異なります。ほとんどの場合は、エクステントサイズを変更してもパフォーマンスに測定可能な影響を与えることはないため、特別な状況を除き、常にデフォルト値を使用することをお勧めします。
    </p><p>
      <em class="firstterm">エクステント</em>は、ディスク領域の割り当ての単位です。1 つのエクステントが、そのエクステントに収容できる量のデータでいっぱいになってから、別のエクステントが使用されます。理論上は、データファイルあたり最大 65,535 (64K) 個のエクステントを使用できます。ただし、推奨される最大数は 32,768 (32K) です。1 つのデータファイルの推奨される最大サイズは 32G (つまり、32K 個のエクステント × エクステントあたり 1M バイト) です。さらに、エクステントを特定のパーティションに割り当てたあと、そのエクステントを使用して別のパーティションのデータを格納することはできません。エクステントには、複数のパーティションのデータを格納できません。つまり、たとえば、<code class="literal">INITIAL_SIZE</code> が 256M バイトで、<code class="literal">EXTENT_SIZE</code> が 128M である 1 つのデータファイルを含むテーブルスペースにはエクステントが 2 つしか存在しないため、このテーブルスペースを使用して最大 2 つの異なるディスクデータテーブルパーティションのデータを格納できます。
    </p><p>
      <code class="literal">INFORMATION_SCHEMA.FILES</code> テーブルをクエリーすることによって、特定のデータファイルに未使用のまま残っているエクステントの数を確認できるため、ファイル内の空き容量の概算値を導き出すことができます。それ以上の説明および例については、<a class="xref" href="information-schema.html#files-table" title="21.30.1 INFORMATION_SCHEMA FILES テーブル">セクション21.30.1「INFORMATION_SCHEMA FILES テーブル」</a>を参照してください。
    </p><p>
      <code class="literal">INITIAL_SIZE</code> パラメータは、データファイルの合計サイズをバイト単位で設定します。ファイルが作成されたあと、そのサイズを変更することはできません。ただし、<code class="literal">ALTER TABLESPACE ... ADD DATAFILE</code> を使用して、テーブルスペースにさらに多くのデータファイルを追加できます。<a class="xref" href="sql-syntax.html#alter-tablespace" title="13.1.8 ALTER TABLESPACE 構文">セクション13.1.8「ALTER TABLESPACE 構文」</a>を参照してください。
    </p><p>
      <code class="literal">INITIAL_SIZE</code> はオプションです。そのデフォルト値は 134217728 (128M バイト) です。
    </p><p>
      32 ビットシステム上では、<code class="literal">INITIAL_SIZE</code> のサポートされる最大値は 4294967296 (4G バイト) です。(Bug #29186)
    </p><p>
      <code class="literal">EXTENT_SIZE</code> を設定する場合は、数値のあとにオプションで、<code class="filename">my.cnf</code> で使用されるのと同様の、桁を示す 1 文字の略語を指定できます。一般に、これは <code class="literal">M</code> (M バイト) または <code class="literal">G</code> (G バイト) のどちらかの文字です。MySQL Cluster NDB 7.3.2 以降では、これらの略語は <code class="literal">INITIAL_SIZE</code> を指定する場合もサポートされます。(Bug #13116514、Bug #16104705、Bug #62858)
    </p><p>
      <code class="literal">INITIAL_SIZE</code>、<code class="literal">EXTENT_SIZE</code>、および <code class="literal">UNDO_BUFFER_SIZE</code> は、次のような丸めに従います。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">EXTENT_SIZE</code> と <code class="literal">UNDO_BUFFER_SIZE</code> はそれぞれ、32K のもっとも近い整数倍に切り上げられます。
        </p></li><li class="listitem"><p>
          <code class="literal">INITIAL_SIZE</code> は、32K のもっとも近い整数倍に切り<span class="emphasis"><em>下げ</em></span>られます。
        </p><p>
          データファイルの場合は、<span class="emphasis"><em>INITIAL_SIZE</em></span> に対してさらに丸め処理が行われます。今得られた結果が (すべての丸めのあと) <code class="literal">EXTENT_SIZE</code> のもっとも近い整数倍に切り上げられます。
        </p></li></ul></div><p>
      今説明した丸めは明示的に実行され、このような丸めのいずれかが実行された場合は MySQL Server によって警告が発行されます。丸められた値はまた、<code class="literal">INFORMATION_SCHEMA.FILES</code> カラム値の計算やその他の目的のために、NDB カーネルでも使用されます。ただし、予期しない結果が発生しないようにするために、これらのオプションの指定では常に 32K の整数倍を使用することをお勧めします。
    </p><p>
      <code class="literal">AUTOEXTEND_SIZE</code>、<code class="literal">MAX_SIZE</code>、<code class="literal">NODEGROUP</code>、<code class="literal">WAIT</code>、および <code class="literal">COMMENT</code> は解析されますが、無視されるため、現在は何の効果もありません。これらのオプションは、将来の拡張のために用意されています。
    </p><p>
      <code class="literal">ENGINE</code> パラメータは、このテーブルスペースが使用するストレージエンジンを決定します。ここで、<em class="replaceable"><code>engine_name</code></em> はそのストレージエンジンの名前です。現在、<em class="replaceable"><code>engine_name</code></em> は、値 <code class="literal">NDB</code> または <code class="literal">NDBCLUSTER</code> のいずれかである必要があります。
    </p><p>
      <code class="literal">CREATE TABLESPACE</code> が <code class="literal">ENGINE = NDB</code> とともに使用された場合は、テーブルスペースとそれに関連付けられたデータファイルが各クラスタデータノード上に作成されます。<code class="literal">INFORMATION_SCHEMA.FILES</code> テーブルをクエリーすることによって、データファイルが作成されたことを確認したり、それらに関する情報を取得したりできます。例:
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT LOGFILE_GROUP_NAME, FILE_NAME, EXTRA</code></strong>
    -&gt; <strong class="userinput"><code>FROM INFORMATION_SCHEMA.FILES</code></strong>
    -&gt; <strong class="userinput"><code>WHERE TABLESPACE_NAME = 'newts' AND FILE_TYPE = 'DATAFILE';</code></strong>
+--------------------+-------------+----------------+
| LOGFILE_GROUP_NAME | FILE_NAME   | EXTRA          |
+--------------------+-------------+----------------+
| lg_3               | newdata.dat | CLUSTER_NODE=3 |
| lg_3               | newdata.dat | CLUSTER_NODE=4 |
+--------------------+-------------+----------------+
2 rows in set (0.01 sec)
</pre><p>
      (<a class="xref" href="information-schema.html#files-table" title="21.30.1 INFORMATION_SCHEMA FILES テーブル">セクション21.30.1「INFORMATION_SCHEMA FILES テーブル」</a>を参照してください。)
    </p><p>
      <code class="literal">CREATE TABLESPACE</code> は、MySQL Cluster のディスクデータストレージでのみ有効です。<a class="xref" href="mysql-cluster.html#mysql-cluster-disk-data" title="18.5.12 MySQL Cluster ディスクデータテーブル">セクション18.5.12「MySQL Cluster ディスクデータテーブル」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="create-trigger"></a>13.1.19 CREATE TRIGGER 構文</h3></div></div></div><a class="indexterm" name="idm139979086625744"></a><a class="indexterm" name="idm139979086624432"></a><pre class="programlisting">
CREATE
    [DEFINER = { <em class="replaceable"><code>user</code></em> | CURRENT_USER }]
    TRIGGER <em class="replaceable"><code>trigger_name</code></em>
    <em class="replaceable"><code>trigger_time</code></em> <em class="replaceable"><code>trigger_event</code></em>
    ON <em class="replaceable"><code>tbl_name</code></em> FOR EACH ROW
    <em class="replaceable"><code>trigger_body</code></em>

<em class="replaceable"><code>trigger_time</code></em>: { BEFORE | AFTER }

<em class="replaceable"><code>trigger_event</code></em>: { INSERT | UPDATE | DELETE }
</pre><p>
      このステートメントは、新しいトリガーを作成します。トリガーとは、テーブルに関連付けられ、そのテーブルに対して特定のイベントが発生するとアクティブ化される名前付きデータベースオブジェクトのことです。トリガーは、<em class="replaceable"><code>tbl_name</code></em> という名前のテーブルに関連付けられます。これは、永続的なテーブルを指す必要があります。トリガーを <code class="literal">TEMPORARY</code> テーブルまたはビューに関連付けることはできません。
    </p><p>
      トリガー名はスキーマの名前空間内に存在します。つまり、すべてのトリガーがスキーマ内で一意の名前を持つ必要があります。異なるスキーマ内のトリガーは同じ名前を持つことができます。
    </p><p>
      このセクションでは、<code class="literal">CREATE TRIGGER</code> 構文について説明します。詳細は、<a class="xref" href="stored-programs-views.html#trigger-syntax" title="20.3.1 トリガーの構文と例">セクション20.3.1「トリガーの構文と例」</a>を参照してください。
    </p><p>
      <code class="literal">CREATE TRIGGER</code> には、このトリガーに関連付けられたテーブルに対する <code class="literal">TRIGGER</code> 権限が必要です。このセクションのあとの方で説明されているように、<code class="literal">DEFINER</code> 値によっては、このステートメントに <code class="literal">SUPER</code> 権限も必要になる可能性があります。バイナリロギングが有効になっている場合は、<a class="xref" href="stored-programs-views.html#stored-programs-logging" title="20.7 ストアドプログラムのバイナリロギング">セクション20.7「ストアドプログラムのバイナリロギング」</a>で説明されているように、<code class="literal">CREATE TRIGGER</code> に <code class="literal">SUPER</code> 権限が必要になることがあります。
    </p><p>
      <code class="literal">DEFINER</code> 句は、このセクションのあとの方で説明されているように、トリガーのアクティブ化時にアクセス権限を確認するときに使用されるセキュリティーコンテキストを決定します。
    </p><p>
      <em class="replaceable"><code>trigger_time</code></em> は、このトリガーのアクション時間です。これは、トリガーが各行の変更の前またはあとにアクティブ化されることを示す <code class="literal">BEFORE</code> または <code class="literal">AFTER</code> にすることができます。
    </p><p>
      <em class="replaceable"><code>trigger_event</code></em> は、このトリガーをアクティブ化する操作の種類を示します。次の <em class="replaceable"><code>trigger_event</code></em> 値が許可されます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">INSERT</code>: このトリガーは (たとえば、<code class="literal">INSERT</code>、<code class="literal">LOAD DATA</code>、および <code class="literal">REPLACE</code> ステートメントを使用して) 新しい行がテーブルに挿入されると常にアクティブ化されます。
        </p></li><li class="listitem"><p>
          <code class="literal">UPDATE</code>: このトリガーは (たとえば、<code class="literal">UPDATE</code> ステートメントを使用して) 行が変更されると常にアクティブ化されます。
        </p></li><li class="listitem"><p>
          <code class="literal">DELETE</code>: このトリガーは (たとえば、<code class="literal">DELETE</code> および <code class="literal">REPLACE</code> ステートメントを使用して) 行がテーブルから削除されると常にアクティブ化されます。テーブルに対する <code class="literal">DROP TABLE</code> および <code class="literal">TRUNCATE TABLE</code> ステートメントは、<code class="literal">DELETE</code> を使用しないため、このトリガーをアクティブ化<span class="emphasis"><em>しません</em></span>。また、パーティションを削除しても <code class="literal">DELETE</code> トリガーはアクティブ化されません。
        </p></li></ul></div><p>
      <em class="replaceable"><code>trigger_event</code></em> は、トリガーをアクティブ化する SQL ステートメントのリテラル型を表しているのではなく、テーブル操作の種類を表しています。たとえば、<code class="literal">INSERT</code> トリガーは、<code class="literal">INSERT</code> ステートメントだけでなく、<code class="literal">LOAD DATA</code> ステートメントでもアクティブ化されます。それは、どちらのステートメントもテーブルに行を挿入するためです。
    </p><p>
      この混乱を招く可能性がある例として、<code class="literal">INSERT INTO ... ON DUPLICATE KEY UPDATE ...</code> 構文があります。すべての行で <code class="literal">BEFORE INSERT</code> トリガーがアクティブ化されたあと、その行に重複キーが存在したかどうかに応じて、<code class="literal">AFTER INSERT</code> トリガーだけか、または <code class="literal">BEFORE UPDATE</code> トリガーと <code class="literal">AFTER UPDATE</code> トリガーの両方がアクティブ化されます。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        カスケードされた外部キーアクションはトリガーをアクティブ化しません。
      </p></div><p>
      特定のテーブルに対して、トリガーイベントとアクション時間が同じ複数のトリガーが存在していてはいけません。たとえば、1 つのテーブルに対して 2 つの <code class="literal">BEFORE UPDATE</code> トリガーを定義することはできません。ただし、<code class="literal">BEFORE UPDATE</code> および <code class="literal">BEFORE INSERT</code> トリガー、または <code class="literal">BEFORE UPDATE</code> および <code class="literal">AFTER UPDATE</code> トリガーは設定できます。
    </p><p>
      <em class="replaceable"><code>trigger_body</code></em> は、トリガーがアクティブ化されるときに実行されるステートメントです。複数のステートメントを実行するには、<code class="literal">BEGIN ... END</code> 複合ステートメント構造構文を使用します。また、これにより、ストアドルーチン内で許可されるのと同じステートメントを使用することもできます。<a class="xref" href="sql-syntax.html#begin-end" title="13.6.1 BEGIN ... END 複合ステートメント構文">セクション13.6.1「BEGIN ... END 複合ステートメント構文」</a>を参照してください。一部のステートメントは、トリガー内では許可されません。<a class="xref" href="restrictions.html#stored-program-restrictions" title="D.1 ストアドプログラムの制約">セクションD.1「ストアドプログラムの制約」</a>を参照してください。
    </p><p>
      トリガー本体内では、エイリアス <code class="literal">OLD</code> と <code class="literal">NEW</code> を使用して、対象テーブル (そのトリガーに関連付けられたテーブル) 内のカラムを参照できます。<code class="literal">OLD.<em class="replaceable"><code>col_name</code></em></code> は、更新または削除される前の既存の行のカラムを示します。<code class="literal">NEW.<em class="replaceable"><code>col_name</code></em></code> は、挿入された新しい行、または更新されたあとの既存の行のカラムを示します。
    </p><p>
      MySQL は、トリガーが作成されたときの有効な <code class="literal">sql_mode</code> システム変数の設定を格納し、<span class="emphasis"><em>トリガーが実行を開始したときの現在のサーバー SQL モードには関係なく</em></span>、常にそのトリガー本体を強制的にこの設定で実行します。
    </p><p>
      <code class="literal">DEFINER</code> 句は、トリガーのアクティブ化時にアクセス権限を確認するときに使用される MySQL アカウントを指定します。<em class="replaceable"><code>user</code></em> 値を指定する場合は、<code class="literal">'<em class="replaceable"><code>user_name</code></em>'@'<em class="replaceable"><code>host_name</code></em>'</code> (<code class="literal">GRANT</code> ステートメントで使用されるのと同じ形式)、<code class="literal">CURRENT_USER</code>、または <code class="literal">CURRENT_USER()</code> として指定された MySQL アカウントにしてください。<code class="literal">DEFINER</code> のデフォルト値は、<code class="literal">CREATE TRIGGER</code> ステートメントを実行するユーザーです。これは、明示的に <code class="literal">DEFINER = CURRENT_USER</code> を指定するのと同じです。
    </p><p>
      <code class="literal">DEFINER</code> 句を指定した場合は、次のルールによって有効な <code class="literal">DEFINER</code> ユーザーの値が決定されます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">SUPER</code> 権限がない場合、許可される唯一の <em class="replaceable"><code>user</code></em> 値は、リテラルで指定するか、または <code class="literal">CURRENT_USER</code> を使用して指定した自分のアカウントです。定義者をほかのアカウントに設定することはできません。
        </p></li><li class="listitem"><p>
          <code class="literal">SUPER</code> 権限がある場合は、構文として有効な任意のアカウント名を指定できます。そのアカウントが実際に存在しない場合は、警告が生成されます。
        </p></li><li class="listitem"><p>
          存在しない <code class="literal">DEFINER</code> アカウントでトリガーを作成することはできますが、そのアカウントが実際に存在するようになるまで、このようなトリガーをアクティブ化することはお勧めできません。それ以外の権限確認に関する動作は定義されていません。
        </p></li></ul></div><p>
      MySQL は、トリガー権限を確認するときに、<code class="literal">DEFINER</code> ユーザーを次のように考慮します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">CREATE TRIGGER</code> の時点で、このステートメントを発行するユーザーには <code class="literal">TRIGGER</code> 権限が必要です。
        </p></li><li class="listitem"><p>
          トリガーのアクティブ化時、権限は <code class="literal">DEFINER</code> ユーザーに対して確認されます。このユーザーには、次の権限が必要です。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              対象テーブルに対する <code class="literal">TRIGGER</code> 権限。
            </p></li><li class="listitem"><p>
              テーブルカラムへの参照がトリガー本体内の <code class="literal">OLD.<em class="replaceable"><code>col_name</code></em></code> または <code class="literal">NEW.<em class="replaceable"><code>col_name</code></em></code> を使用して発生した場合は、対象テーブルに対する <code class="literal">SELECT</code> 権限。
            </p></li><li class="listitem"><p>
              テーブルカラムがトリガー本体内の <code class="literal">SET NEW.<em class="replaceable"><code>col_name</code></em> = <em class="replaceable"><code>value</code></em></code> 割り当てのターゲットである場合は、対象テーブルに対する <code class="literal">UPDATE</code> 権限。
            </p></li><li class="listitem"><p>
              その他のどのような権限も、通常、そのトリガーによって実行されるステートメントに必要です。
            </p></li></ul></div></li></ul></div><p>
      トリガーのセキュリティーの詳細は、<a class="xref" href="stored-programs-views.html#stored-programs-security" title="20.6 ストアドプログラムおよびビューのアクセスコントロール">セクション20.6「ストアドプログラムおよびビューのアクセスコントロール」</a>を参照してください。
    </p><p>
      トリガー本体内で、<code class="literal">CURRENT_USER()</code> 関数は、トリガーのアクティブ化時に権限を確認するために使用されるアカウントを返します。これは、そのトリガーがアクティブ化される原因となるアクションを実行したユーザーではなく、<code class="literal">DEFINER</code> ユーザーです。トリガー内のユーザー監査については、<a class="xref" href="security.html#account-activity-auditing" title="6.3.13 SQL ベースの MySQL アカウントアクティビティーの監査">セクション6.3.13「SQL ベースの MySQL アカウントアクティビティーの監査」</a>を参照してください。
    </p><p>
      <code class="literal">LOCK TABLES</code> を使用してトリガーを含むテーブルをロックした場合は、<a class="xref" href="sql-syntax.html#lock-tables-and-triggers" title="13.3.5.2 LOCK TABLES とトリガー">セクション13.3.5.2「LOCK TABLES とトリガー」</a>で説明されているように、そのトリガー内で使用されているテーブルもロックされます。
    </p><p>
      トリガーの使用の詳細は、<a class="xref" href="stored-programs-views.html#trigger-syntax" title="20.3.1 トリガーの構文と例">セクション20.3.1「トリガーの構文と例」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="create-view"></a>13.1.20 CREATE VIEW 構文</h3></div></div></div><a class="indexterm" name="idm139979086506432"></a><a class="indexterm" name="idm139979086505008"></a><a class="indexterm" name="idm139979086502976"></a><pre class="programlisting">
CREATE
    [OR REPLACE]
    [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]
    [DEFINER = { <em class="replaceable"><code>user</code></em> | CURRENT_USER }]
    [SQL SECURITY { DEFINER | INVOKER }]
    VIEW <em class="replaceable"><code>view_name</code></em> [(<em class="replaceable"><code>column_list</code></em>)]
    AS <em class="replaceable"><code>select_statement</code></em>
    [WITH [CASCADED | LOCAL] CHECK OPTION]
</pre><p>
      <code class="literal">CREATE VIEW</code> ステートメントは、新しいビューを作成するか、または <code class="literal">OR REPLACE</code> 句が指定されている場合は既存のビューを置き換えます。そのビューが存在しない場合、<code class="literal">CREATE OR REPLACE VIEW</code> は <code class="literal">CREATE VIEW</code> と同じです。そのビューが存在する場合、<code class="literal">CREATE OR REPLACE VIEW</code> は <code class="literal">ALTER VIEW</code> と同じです。
    </p><p>
      <em class="replaceable"><code>select_statement</code></em> は、そのビューの定義を提供する <code class="literal">SELECT</code> ステートメントです。(ビューから選択すると、事実上、<code class="literal">SELECT</code> ステートメントを使用して選択したことになります。) <em class="replaceable"><code>select_statement</code></em> は、ベーステーブルまたはほかのビューから選択できます。
    </p><p>
      ビュー定義は作成時に<span class="quote">「<span class="quote">固定される</span>」</span>ため、ベースとなるテーブルへのそれ以降の変更はビュー定義に影響を与えません。たとえば、ビューがテーブル上で <code class="literal">SELECT *</code> として定義されている場合、あとでテーブルに追加された新しいカラムはそのビューの一部になりません。
    </p><p>
      <code class="literal">ALGORITHM</code> 句は、MySQL によるビューの処理方法に影響を与えます。<code class="literal">DEFINER</code> および <code class="literal">SQL SECURITY</code> 句は、ビューの呼び出し時にアクセス権限を確認するときに使用されるセキュリティーコンテキストを指定します。<code class="literal">WITH CHECK OPTION</code> 句を指定すると、ビューによって参照されているテーブル内の行への挿入または更新を制約できます。これらの句については、このセクションのあとの方で説明されています。
    </p><p>
      <code class="literal">CREATE VIEW</code> ステートメントには、このビューに対する <code class="literal">CREATE VIEW</code> 権限と、<code class="literal">SELECT</code> ステートメントによって選択される各カラムに対する何らかの権限が必要です。<code class="literal">SELECT</code> ステートメント内の別の場所で使用されているカラムに対しては、<code class="literal">SELECT</code> 権限が必要です。<code class="literal">OR REPLACE</code> 句が存在する場合は、このビューに対する <code class="literal">DROP</code> 権限も必要です。このセクションのあとの方で説明されているように、<code class="literal">DEFINER</code> 値によっては、<code class="literal">CREATE VIEW</code> に <code class="literal">SUPER</code> 権限も必要になる可能性があります。
    </p><p>
      ビューが参照されると、このセクションのあとの方で説明されている権限確認が発生します。
    </p><p>
      ビューはデータベースに属します。デフォルトでは、新しいビューはデフォルトデータベース内に作成されます。ビューを明示的に特定のデータベース内に作成するには、そのビューの作成時に、その名前を <em class="replaceable"><code>db_name.view_name</code></em> として指定します。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE VIEW test.v AS SELECT * FROM t;</code></strong>
</pre><p>
      データベース内で、ベーステーブルとビューは同じ名前空間を共有するため、ベーステーブルとビューが同じ名前を持つことはできません。
    </p><p>
      <code class="literal">SELECT</code> ステートメントによって取得されるカラムは、テーブルカラムへの単純な参照にすることができます。また、関数、定数値、演算子などを使用した式にすることもできます。
    </p><p>
      ビューは、ベーステーブルと同様に、重複のない一意のカラム名を持つ必要があります。デフォルトでは、<code class="literal">SELECT</code> ステートメントによって取得されるカラムの名前はビューカラム名に使用されます。ビューカラムの明示的な名前を定義するには、オプションの <em class="replaceable"><code>column_list</code></em> 句をカンマで区切られた識別子のリストとして指定できます。<em class="replaceable"><code>column_list</code></em> 内の名前の数は、<code class="literal">SELECT</code> ステートメントによって取得されるカラムの数と同じである必要があります。
    </p><p>
      <code class="literal">SELECT</code> ステートメント内の修飾されていないテーブルまたはビュー名は、デフォルトデータベースを基準にして解釈されます。ビューは、テーブルまたはビュー名を適切なデータベース名で修飾することによって、ほかのデータベース内のテーブルまたはビューを参照できます。
    </p><p>
      ビューは、多くの種類の <code class="literal">SELECT</code> ステートメントから作成できできます。ベーステーブルまたはほかのビューを参照できます。結合、<code class="literal">UNION</code>、およびサブクエリーを使用できます。<code class="literal">SELECT</code> がテーブルをまったく参照しなくてもかまいません。次の例では、別のテーブルからの 2 つのカラムに加え、それらのカラムから計算される式を選択するビューを定義しています。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE t (qty INT, price INT);</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t VALUES(3, 50);</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE VIEW v AS SELECT qty, price, qty*price AS value FROM t;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT * FROM v;</code></strong>
+------+-------+-------+
| qty  | price | value |
+------+-------+-------+
|    3 |    50 |   150 |
+------+-------+-------+
</pre><p>
      ビュー定義は、次の制限に従います。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">SELECT</code> ステートメントに <code class="literal">FROM</code> 句内のサブクエリーを含めることはできません。
        </p></li><li class="listitem"><p>
          <code class="literal">SELECT</code> ステートメントは、システムまたはユーザー変数を参照できません。
        </p></li><li class="listitem"><p>
          ストアドプログラム内で、この定義は、プログラムパラメータまたはローカル変数を参照できません。
        </p></li><li class="listitem"><p>
          <code class="literal">SELECT</code> ステートメントは、準備済みステートメントのパラメータを参照できません。
        </p></li><li class="listitem"><p>
          この定義で参照されているテーブルまたはビューは、すべて存在する必要があります。ただし、ビューが作成されたあとは、この定義で参照されているテーブルまたはビューを削除できます。この場合は、このビューを使用すると、エラーが発生します。この種類の問題に関してビュー定義を確認するには、<code class="literal">CHECK TABLE</code> ステートメントを使用します。
        </p></li><li class="listitem"><p>
          この定義は <code class="literal">TEMPORARY</code> テーブルを参照できないため、<code class="literal">TEMPORARY</code> ビューは作成できません。
        </p></li><li class="listitem"><p>
          ビュー定義で指定されているテーブルは、すべて定義時に存在する必要があります。
        </p></li><li class="listitem"><p>
          トリガーをビューに関連付けることはできません。
        </p></li><li class="listitem"><p>
          <code class="literal">SELECT</code> ステートメント内のカラム名のエイリアスは (256 文字の別名の最大の長さではなく) 64 文字のカラムの最大の長さに対してチェックされます。
        </p></li></ul></div><p>
      <code class="literal">ORDER BY</code> はビュー定義内で許可されていますが、独自の <code class="literal">ORDER BY</code> を含むステートメントを使用しているビューから選択した場合は無視されます。
    </p><p>
      この定義内のその他のオプションまたは句の場合は、そのビューを参照しているステートメントのオプションまたは句に追加されますが、その効果は定義されていません。たとえば、ビュー定義に <code class="literal">LIMIT</code> 句が含まれているときに、独自の <code class="literal">LIMIT</code> 句を含むステートメントを使用しているビューから選択した場合、どの制限が適用されるかは未定義です。この同じ原則は、<code class="literal">SELECT</code> キーワードに続く <code class="literal">ALL</code>、<code class="literal">DISTINCT</code>、<code class="literal">SQL_SMALL_RESULT</code> などのオプションや、<code class="literal">INTO</code>、<code class="literal">FOR UPDATE</code>、<code class="literal">LOCK IN SHARE MODE</code>、<code class="literal">PROCEDURE</code> などの句にも適用されます。
    </p><p>
      ビューを作成したあとに、システム変数の変更によってクエリー処理環境を変更すると、そのビューから得られる結果に影響を与える可能性があります。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE VIEW v (mycol) AS SELECT 'abc';</code></strong>
Query OK, 0 rows affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>SET sql_mode = '';</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT "mycol" FROM v;</code></strong>
+-------+
| mycol |
+-------+
| mycol |
+-------+
1 row in set (0.01 sec)

mysql&gt; <strong class="userinput"><code>SET sql_mode = 'ANSI_QUOTES';</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT "mycol" FROM v;</code></strong>
+-------+
| mycol |
+-------+
| abc   |
+-------+
1 row in set (0.00 sec)
</pre><p>
      <code class="literal">DEFINER</code> および <code class="literal">SQL SECURITY</code> 句は、そのビューを参照しているステートメントの実行時に、そのビューに対するアクセス権限を確認するときにどの MySQL アカウントを使用するかを決定します。<code class="literal">SQL SECURITY</code> 特性の有効な値は、<code class="literal">DEFINER</code> と <code class="literal">INVOKER</code> です。これらは、それぞれ、そのビューを定義したユーザーまたは呼び出したユーザーが必要な権限を持っている必要があることを示します。<code class="literal">SQL SECURITY</code> のデフォルト値は <code class="literal">DEFINER</code> です。
    </p><p>
      <code class="literal">DEFINER</code> 句に <em class="replaceable"><code>user</code></em> 値を指定する場合は、<code class="literal">'<em class="replaceable"><code>user_name</code></em>'@'<em class="replaceable"><code>host_name</code></em>'</code> (<code class="literal">GRANT</code> ステートメントで使用されるのと同じ形式)、<code class="literal">CURRENT_USER</code>、または <code class="literal">CURRENT_USER()</code> として指定された MySQL アカウントにするようにしてください。<code class="literal">DEFINER</code> のデフォルト値は、<code class="literal">CREATE VIEW</code> ステートメントを実行するユーザーです。これは、明示的に <code class="literal">DEFINER = CURRENT_USER</code> を指定するのと同じです。
    </p><p>
      <code class="literal">DEFINER</code> 句を指定した場合は、次のルールによって有効な <code class="literal">DEFINER</code> ユーザーの値が決定されます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">SUPER</code> 権限がない場合、有効な唯一の <em class="replaceable"><code>user</code></em> 値は、リテラルで指定するか、または <code class="literal">CURRENT_USER</code> を使用して指定した自分のアカウントです。定義者をほかのアカウントに設定することはできません。
        </p></li><li class="listitem"><p>
          <code class="literal">SUPER</code> 権限がある場合は、構文として有効な任意のアカウント名を指定できます。そのアカウントが実際に存在しない場合は、警告が生成されます。
        </p></li><li class="listitem"><p>
          存在しない <code class="literal">DEFINER</code> アカウントでビューを作成することはできますが、<code class="literal">SQL SECURITY</code> 値が <code class="literal">DEFINER</code> であるが、定義者アカウントが存在しない場合は、そのビューが参照されたときにエラーが発生します。
        </p></li></ul></div><p>
      ビューのセキュリティーの詳細は、<a class="xref" href="stored-programs-views.html#stored-programs-security" title="20.6 ストアドプログラムおよびビューのアクセスコントロール">セクション20.6「ストアドプログラムおよびビューのアクセスコントロール」</a>を参照してください。
    </p><p>
      ビュー定義内で、<code class="literal">CURRENT_USER</code> は、デフォルトではそのビューの <code class="literal">DEFINER</code> 値を返します。<code class="literal">SQL SECURITY INVOKER</code> 特性を使用して定義されたビューの場合、<code class="literal">CURRENT_USER</code> は、そのビューの呼び出し元のアカウントを返します。ビュー内のユーザー監査については、<a class="xref" href="security.html#account-activity-auditing" title="6.3.13 SQL ベースの MySQL アカウントアクティビティーの監査">セクション6.3.13「SQL ベースの MySQL アカウントアクティビティーの監査」</a>を参照してください。
    </p><p>
      <code class="literal">SQL SECURITY DEFINER</code> 特性を使用して定義されたストアドルーチン内で、<code class="literal">CURRENT_USER</code> は、そのルーチンの <code class="literal">DEFINER</code> 値を返します。ビュー定義に <code class="literal">CURRENT_USER</code> の <code class="literal">DEFINER</code> 値が含まれている場合は、これにより、このようなルーチン内で定義されたビューも影響を受けます。
    </p><p>
      ビューの権限は、次のように確認されます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ビューの定義時に、ビュー作成者は、そのビューによってアクセスされるトップレベルのオブジェクトを使用するために必要な権限を持っている必要があります。たとえば、ビュー定義がテーブルカラムを参照している場合、作成者は、その定義の選択リスト内の各カラムに対する何らかの権限と、その定義内の別の場所で使用されている各カラムに対する <code class="literal">SELECT</code> 権限を持っている必要があります。この定義がストアドファンクションを参照している場合は、その関数を呼び出すために必要な権限のみを確認できます。関数呼び出し時に必要な権限は、その関数が実行されるときにしか確認できません。別の呼び出しでは、その関数内の別の実行パスが選択される可能性があります。
        </p></li><li class="listitem"><p>
          ビューを参照するユーザーは、そのビューにアクセスするための適切な権限 (そのビューから選択するための <code class="literal">SELECT</code> や、そのビューに挿入するための <code class="literal">INSERT</code> など) を持っている必要があります。
        </p></li><li class="listitem"><p>
          ビューが参照されると、そのビューによってアクセスされるオブジェクトに対する権限が、<code class="literal">SQL SECURITY</code> 特性が <code class="literal">DEFINER</code> または <code class="literal">INVOKER</code> のどちらであるかに応じて、それぞれ、そのビューの <code class="literal">DEFINER</code> アカウントによって保持されている権限または呼び出し元に対して確認されます。
        </p></li><li class="listitem"><p>
          ビューへの参照によってストアドファンクションが実行される場合、その関数内で実行されるステートメントの権限確認は、その関数の <code class="literal">SQL SECURITY</code> 特性が <code class="literal">DEFINER</code> または <code class="literal">INVOKER</code> のどちらであるかによって異なります。セキュリティー特性が <code class="literal">DEFINER</code> である場合、その関数は <code class="literal">DEFINER</code> アカウントの権限で実行されます。この特性が <code class="literal">INVOKER</code> である場合、その関数は、そのビューの <code class="literal">SQL SECURITY</code> 特性によって決定される権限で実行されます。
        </p></li></ul></div><p>
      例: あるビューがストアドファンクションに依存する可能性があり、さらにその関数がほかのストアドルーチンを呼び出す可能性があります。たとえば、次のビューはストアドファンクション <code class="literal">f()</code> を呼び出します。
    </p><pre class="programlisting">
CREATE VIEW v AS SELECT * FROM t WHERE t.id = f(t.name);
</pre><p>
      <code class="literal">f()</code> に次のようなステートメントが含まれているとします。
    </p><pre class="programlisting">
IF name IS NULL then
  CALL p1();
ELSE
  CALL p2();
END IF;
</pre><p>
      <code class="literal">f()</code> が実行されるとき、<code class="literal">f()</code> 内のステートメントを実行するために必要な権限を確認する必要があります。これは、<code class="literal">f()</code> 内の実行パスに応じて、<code class="literal">p1()</code> または <code class="literal">p2()</code> に対する権限が必要であることを示します。これらの権限は実行時に確認する必要があり、それらの権限を持っている必要のあるユーザーは、ビュー <code class="literal">v</code> と関数 <code class="literal">f()</code> の <code class="literal">SQL SECURITY</code> 値によって決定されます。
    </p><p>
      ビューの <code class="literal">DEFINER</code> および <code class="literal">SQL SECURITY</code> 句は、標準 SQL への拡張です。標準 SQL では、ビューは <code class="literal">SQL SECURITY DEFINER</code> のルールを使用して処理されます。標準には、ビューの定義者 (これは、ビューのスキーマの所有者と同じです) はそのビューに対する該当する権限 (<code class="literal">SELECT</code> など) を取得し、またそれらを付与することができると記載されています。MySQL にはスキーマの<span class="quote">「<span class="quote">所有者</span>」</span>という概念がないため、MySQL では定義者を識別するための句が追加されています。<code class="literal">DEFINER</code> 句は、標準が備えている機能、つまり、だれがそのビューを定義したかについての永続的なレコードを備えることを目的とした拡張です。<code class="literal">DEFINER</code> のデフォルト値がビュー作成者のアカウントになっているのはそのためです。
    </p><p>
      オプションの <code class="literal">ALGORITHM</code> 句は、標準 SQL への MySQL 拡張です。これは、MySQL によるビューの処理方法に影響を与えます。<code class="literal">ALGORITHM</code> は、<code class="literal">MERGE</code>、<code class="literal">TEMPTABLE</code>、または <code class="literal">UNDEFINED</code> の 3 つの値を受け取ります。<code class="literal">ALGORITHM</code> 句が存在しない場合、デフォルトのアルゴリズムは <code class="literal">UNDEFINED</code> です。詳細は、<a class="xref" href="stored-programs-views.html#view-algorithms" title="20.5.2 ビュー処理アルゴリズム">セクション20.5.2「ビュー処理アルゴリズム」</a>を参照してください。
    </p><p>
      いくつかのビューは更新可能です。つまり、これらのビューを <code class="literal">UPDATE</code>、<code class="literal">DELETE</code>、<code class="literal">INSERT</code> などのステートメントで使用して、ベースとなるテーブルの内容を更新できます。ビューが更新可能であるためには、そのビュー内の行とベースとなるテーブル内の行の間に 1 対 1 の関係が存在する必要があります。また、ビューを更新不可能にするその他の特定の構造構文も存在します。
    </p><p>
      更新可能なビューに対して <code class="literal">WITH CHECK OPTION</code> 句を指定すると、<em class="replaceable"><code>select_statement</code></em> 内の <code class="literal">WHERE</code> 句が true である行を除く行への挿入または更新を回避できます。
    </p><p>
      更新可能なビューに対する <code class="literal">WITH CHECK OPTION</code> 句では、そのビューが別のビューとの関連で定義されている場合、<code class="literal">LOCAL</code> および <code class="literal">CASCADED</code> キーワードによってチェックテストのスコープが決定されます。<code class="literal">LOCAL</code> キーワードは、<code class="literal">CHECK OPTION</code> を、定義されているビューのみに制限します。<code class="literal">CASCADED</code> を指定すると、ベースとなるビューに対するチェックも評価されます。どちらのキーワードも指定されていない場合、デフォルトは <code class="literal">CASCADED</code> になります。
    </p><p>
      更新可能なビューおよび <code class="literal">WITH CHECK OPTION</code> 句の詳細は、<a class="xref" href="stored-programs-views.html#view-updatability" title="20.5.3 更新可能および挿入可能なビュー">セクション20.5.3「更新可能および挿入可能なビュー」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="drop-database"></a>13.1.21 DROP DATABASE 構文</h3></div></div></div><a class="indexterm" name="idm139979086315616"></a><a class="indexterm" name="idm139979086314304"></a><a class="indexterm" name="idm139979086312960"></a><a class="indexterm" name="idm139979086310816"></a><a class="indexterm" name="idm139979086308784"></a><a class="indexterm" name="idm139979086306752"></a><pre class="programlisting">
DROP {DATABASE | SCHEMA} [IF EXISTS] <em class="replaceable"><code>db_name</code></em>
</pre><p>
      <code class="literal">DROP DATABASE</code> は、データベース内のすべてのテーブルを削除したあと、そのデータベースを削除します。このステートメントには<span class="emphasis"><em>十分に</em></span>注意してください。<code class="literal">DROP DATABASE</code> を使用するには、そのデータベースに対する <code class="literal">DROP</code> 権限が必要です。<code class="literal">DROP SCHEMA</code> は <code class="literal">DROP DATABASE</code> のシノニムです。
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        データベースが削除されても、そのデータベースに対するユーザー権限が自動的に削除されることは<span class="emphasis"><em>ありません</em></span>。<a class="xref" href="sql-syntax.html#grant" title="13.7.1.4 GRANT 構文">セクション13.7.1.4「GRANT 構文」</a>を参照してください。
      </p></div><p>
      <code class="literal">IF EXISTS</code> は、データベースが存在しない場合にエラーが発生しないようにするために使用されます。
    </p><p>
      デフォルトデータベースが削除されると、そのデフォルトデータベースは設定解除されます (<code class="literal">DATABASE()</code> 関数が <code class="literal">NULL</code> を返します)。
    </p><p>
      シンボリックリンクされたデータベースに対して <code class="literal">DROP DATABASE</code> を使用した場合は、そのリンクと元のデータベースの両方が削除されます。
    </p><p>
      <code class="literal">DROP DATABASE</code> は、削除されたテーブルの数を返します。これは、削除された <code class="filename">.frm</code> ファイルの数に対応します。
    </p><p>
      <code class="literal">DROP DATABASE</code> ステートメントは、MySQL 自体が通常の動作中に作成する可能性のあるファイルとディレクトリを特定のデータベースディレクトリから削除します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          次の拡張子を持つすべてのファイル。
        </p><div class="informaltable"><table summary="DROP DATABASE ステートメントは、この表に示されている拡張子の種類を持つファイルを削除します。拡張子は、左から右にアルファベット順に一覧表示されています。" border="1"><colgroup><col><col><col><col></colgroup><tbody><tr><td scope="row"><code class="literal">.BAK</code></td><td><code class="literal">.DAT</code></td><td><code class="literal">.HSH</code></td><td><code class="literal">.MRG</code></td></tr><tr><td scope="row"><code class="literal">.MYD</code></td><td><code class="literal">.MYI</code></td><td><code class="literal">.TRG</code></td><td><code class="literal">.TRN</code></td></tr><tr><td scope="row"><code class="literal">.db</code></td><td><code class="literal">.frm</code></td><td><code class="literal">.ibd</code></td><td><code class="literal">.ndb</code></td></tr><tr><td scope="row"><code class="literal">.par</code></td><td> </td><td> </td><td> </td></tr></tbody></table></div></li><li class="listitem"><p>
          <code class="filename">db.opt</code> ファイル (存在する場合)。
        </p></li></ul></div><p>
      今一覧表示されたファイルを MySQL が削除したあとに、このデータベースディレクトリ内にほかのファイルやディレクトリが残っている場合は、そのデータベースディレクトリを削除できません。この場合は、残っているすべてのファイルまたはディレクトリを手動で削除してから、再度 <code class="literal">DROP DATABASE</code> ステートメントを発行する必要があります。
    </p><p>
      データベースを削除しても、そのデータベース内に作成されたどの <code class="literal">TEMPORARY</code> テーブルも削除されません。<code class="literal">TEMPORARY</code> テーブルは、それらを作成したセッションが終了すると自動的に削除されます。<a class="xref" href="sql-syntax.html#create-temporary-table" title="一時テーブル">一時テーブル</a>を参照してください。
    </p><a class="indexterm" name="idm139979086255712"></a><p>
      データベースは <span class="command"><strong>mysqladmin</strong></span> でも削除できます。<a class="xref" href="programs.html#mysqladmin" title="4.5.2 mysqladmin — MySQL サーバーの管理を行うクライアント">セクション4.5.2「<span class="command"><strong>mysqladmin</strong></span> — MySQL サーバーの管理を行うクライアント」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="drop-event"></a>13.1.22 DROP EVENT 構文</h3></div></div></div><a class="indexterm" name="idm139979086251152"></a><a class="indexterm" name="idm139979086249840"></a><a class="indexterm" name="idm139979086247648"></a><pre class="programlisting">
DROP EVENT [IF EXISTS] <em class="replaceable"><code>event_name</code></em>
</pre><p>
      このステートメントは、<em class="replaceable"><code>event_name</code></em> という名前のイベントを削除します。このイベントはただちにアクティブな状態を停止し、サーバーから完全に削除されます。
    </p><p>
      このイベントが存在しない場合は、エラー <span class="errortext">ERROR 1517 (HY000): Unknown event '<em class="replaceable"><code>event_name</code></em>'</span> が発生します。これをオーバーライドし、代わりに <code class="literal">IF EXISTS</code> を使用して、このステートメントで存在しないイベントに対する警告が生成されるようにできます。
    </p><p>
      このステートメントには、削除されるイベントが属するスキーマに対する <code class="literal">EVENT</code> 権限が必要です。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="drop-function"></a>13.1.23 DROP FUNCTION 構文</h3></div></div></div><p>
      <code class="literal">DROP FUNCTION</code> ステートメントは、ストアドファンクションやユーザー定義関数 (UDF) を削除するために使用されます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ストアドファンクションの削除については、<a class="xref" href="sql-syntax.html#drop-procedure" title="13.1.26 DROP PROCEDURE および DROP FUNCTION 構文">セクション13.1.26「DROP PROCEDURE および DROP FUNCTION 構文」</a>を参照してください。
        </p></li><li class="listitem"><p>
          ユーザー定義関数の削除については、<a class="xref" href="sql-syntax.html#drop-function-udf" title="13.7.3.2 DROP FUNCTION 構文">セクション13.7.3.2「DROP FUNCTION 構文」</a>を参照してください。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="drop-index"></a>13.1.24 DROP INDEX 構文</h3></div></div></div><a class="indexterm" name="idm139979086225392"></a><a class="indexterm" name="idm139979086224080"></a><a class="indexterm" name="idm139979086221936"></a><pre class="programlisting">
DROP INDEX [ONLINE|OFFLINE] <em class="replaceable"><code>index_name</code></em> ON <em class="replaceable"><code>tbl_name</code></em>
    [<em class="replaceable"><code>algorithm_option</code></em> | <em class="replaceable"><code>lock_option</code></em>] ...

<em class="replaceable"><code>algorithm_option</code></em>:
    ALGORITHM [=] {DEFAULT|INPLACE|COPY}

<em class="replaceable"><code>lock_option</code></em>:
    LOCK [=] {DEFAULT|NONE|SHARED|EXCLUSIVE}
</pre><p>
      <code class="literal">DROP INDEX</code> は、テーブル <em class="replaceable"><code>tbl_name</code></em> から <em class="replaceable"><code>index_name</code></em> という名前のインデックスを削除します。このステートメントは、このインデックスを削除するために <code class="literal">ALTER TABLE</code> ステートメントにマップされます。<a class="xref" href="sql-syntax.html#alter-table" title="13.1.7 ALTER TABLE 構文">セクション13.1.7「ALTER TABLE 構文」</a>を参照してください。
    </p><p>
      主キーを削除するには、インデックス名は常に <code class="literal">PRIMARY</code> です。これは、<code class="literal">PRIMARY</code> が予約語であるため、引用符で囲まれた識別子として指定する必要があります。
    </p><pre class="programlisting">
DROP INDEX `PRIMARY` ON t;
</pre><p>
      <code class="literal">NDB</code> テーブルの可変幅カラム上のインデックスはオンラインで、つまり、テーブルコピーを行うことなく削除されます。このテーブルは、この操作の期間中、<span class="emphasis"><em>同じ</em></span> API ノードに対するほかの操作に対してロックされますが、ほかの MySQL Cluster API ノードからのアクセスに対してはロックされません。これは、サーバーが実行できると判断した場合は常に、そのサーバーによって自動的に実行されます。これを実行するために、特殊な SQL 構文やサーバーオプションを使用する必要はありません。
    </p><p>
      MySQL Cluster では、<code class="literal">OFFLINE</code> キーワードを使用してインデックスをオフラインで削除できます (これにより、そのテーブルはクラスタ内のすべての API ノードに対してロックされます)。<code class="literal">DROP OFFLINE INDEX</code> および <code class="literal">DROP ONLINE INDEX</code> を管理するルールや制限は、<code class="literal">ALTER OFFLINE TABLE ... DROP INDEX</code> および <code class="literal">ALTER ONLINE TABLE ... DROP INDEX</code> の場合と同じです。<code class="literal">ONLINE</code> キーワードを使用して、通常はオフラインで削除されるインデックスのコピーなし削除が実行されるようにすることはできません。<code class="literal">DROP</code> 操作をテーブルコピーなしで実行できない場合、サーバーは <code class="literal">ONLINE</code> キーワードを無視します。詳細は、<a class="xref" href="sql-syntax.html#alter-table-online-operations" title="13.1.7.2 MySQL Cluster での ALTER TABLE オンライン操作">セクション13.1.7.2「MySQL Cluster での ALTER TABLE オンライン操作」</a>を参照してください。
    </p><p>
      <code class="literal">ONLINE</code> および <code class="literal">OFFLINE</code> キーワードは、MySQL Cluster でのみ使用できます。これらのキーワードを標準の MySQL Server 5.6 リリースで使用しようとすると、構文エラーが発生します。<code class="literal">ONLINE</code> および <code class="literal">OFFLINE</code> キーワードは、MySQL Cluster NDB 7.3 では非推奨です。MySQL Cluster NDB 7.4 では引き続きサポートされますが、将来の MySQL Cluster リリースでは削除対象としてスケジュールされています。
    </p><p>
      MySQL 5.6.6 の時点では、<code class="literal">ALGORITHM</code> および <code class="literal">LOCK</code> 句を指定できます。これらは、テーブルコピーの方法や、インデックスが変更されている間のテーブルの読み取りと書き込みの並列性のレベルに影響を与えます。これらには、<code class="literal">ALTER TABLE</code> ステートメントの場合と同じ意味があります。詳細は、<a class="xref" href="sql-syntax.html#alter-table" title="13.1.7 ALTER TABLE 構文">セクション13.1.7「ALTER TABLE 構文」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="drop-logfile-group"></a>13.1.25 DROP LOGFILE GROUP 構文</h3></div></div></div><a class="indexterm" name="idm139979086185744"></a><pre class="programlisting">
DROP LOGFILE GROUP <em class="replaceable"><code>logfile_group</code></em>
    ENGINE [=] <em class="replaceable"><code>engine_name</code></em>
</pre><p>
      このステートメントは、<em class="replaceable"><code>logfile_group</code></em> という名前のログファイルグループを削除します。このログファイルグループがすでに存在する必要があります。そうしないと、エラー結果が発生します。(ログファイルグループの作成については、<a class="xref" href="sql-syntax.html#create-logfile-group" title="13.1.14 CREATE LOGFILE GROUP 構文">セクション13.1.14「CREATE LOGFILE GROUP 構文」</a>を参照してください。)
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        ログファイルグループを削除する前に、そのログファイルグループを <code class="literal">UNDO</code> ロギングのために使用しているすべてのテーブルスペースを削除する必要があります。
      </p></div><p>
      必須の <code class="literal">ENGINE</code> 句は、削除されるログファイルグループによって使用されるストレージエンジンの名前を指定します。現在、<em class="replaceable"><code>engine_name</code></em> に許可される値は <code class="literal">NDB</code> と <code class="literal">NDBCLUSTER</code> だけです。
    </p><p>
      <code class="literal">DROP LOGFILE GROUP</code> は、MySQL Cluster のディスクデータストレージでのみ有効です。<a class="xref" href="mysql-cluster.html#mysql-cluster-disk-data" title="18.5.12 MySQL Cluster ディスクデータテーブル">セクション18.5.12「MySQL Cluster ディスクデータテーブル」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="drop-procedure"></a>13.1.26 DROP PROCEDURE および DROP FUNCTION 構文</h3></div></div></div><a class="indexterm" name="idm139979086170912"></a><a class="indexterm" name="idm139979086169600"></a><pre class="programlisting">
DROP {PROCEDURE | FUNCTION} [IF EXISTS] <em class="replaceable"><code>sp_name</code></em>
</pre><p>
      このステートメントは、ストアドプロシージャーまたはストアドファンクションを削除するために使用されます。つまり、指定されたルーチンがサーバーから削除されます。このルーチンに対する <code class="literal">ALTER ROUTINE</code> 権限が必要です。(<code class="literal">automatic_sp_privileges</code> システム変数が有効になっている場合は、その権限と <code class="literal">EXECUTE</code> が自動的に、そのルーチンが作成されるときはルーチン作成者に付与され、そのルーチンが削除されるときは作成者から削除されます。<a class="xref" href="stored-programs-views.html#stored-routines-privileges" title="20.2.2 ストアドルーチンと MySQL 権限">セクション20.2.2「ストアドルーチンと MySQL 権限」</a>を参照してください。)
    </p><p>
      <code class="literal">IF EXISTS</code> 句は MySQL 拡張です。これは、プロシージャーまたは関数が存在しない場合にエラーが発生しないようにします。<code class="literal">SHOW WARNINGS</code> で表示できる警告が生成されます。
    </p><p>
      <code class="literal">DROP FUNCTION</code> はまた、ユーザー定義関数を削除するためにも使用されます (<a class="xref" href="sql-syntax.html#drop-function-udf" title="13.7.3.2 DROP FUNCTION 構文">セクション13.7.3.2「DROP FUNCTION 構文」</a>を参照してください)。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="drop-server"></a>13.1.27 DROP SERVER 構文</h3></div></div></div><a class="indexterm" name="idm139979086153120"></a><pre class="programlisting">
DROP SERVER [ IF EXISTS ] <em class="replaceable"><code>server_name</code></em>
</pre><p>
      <code class="literal"><em class="replaceable"><code>server_name</code></em></code> という名前のサーバーのサーバー定義を削除します。<code class="literal">mysql.servers</code> テーブル内の対応する行が削除されます。このステートメントには、<code class="literal">SUPER</code> 権限が必要です。
    </p><p>
      テーブルのサーバーを削除しても、作成されるときにこの接続情報を使用したどの <code class="literal">FEDERATED</code> テーブルにも影響を与えません。<a class="xref" href="sql-syntax.html#create-server" title="13.1.16 CREATE SERVER 構文">セクション13.1.16「CREATE SERVER 構文」</a>を参照してください。
    </p><p>
      <code class="literal">DROP SERVER</code> では、自動コミットは実行されません。
    </p><p>
      MySQL 5.6 では、使用されているロギング形式には関係なく、<code class="literal">DROP SERVER</code> はバイナリログに書き込まれません。
    </p><p>
      MySQL 5.6.11 でのみ、このステートメントを発行する前に、<code class="literal">gtid_next</code> を <code class="literal">AUTOMATIC</code> に設定する必要があります。(Bug #16062608、Bug #16715809、Bug #69045)
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="drop-table"></a>13.1.28 DROP TABLE 構文</h3></div></div></div><a class="indexterm" name="idm139979086135680"></a><a class="indexterm" name="idm139979086134368"></a><a class="indexterm" name="idm139979086132224"></a><pre class="programlisting">
DROP [TEMPORARY] TABLE [IF EXISTS]
    <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ...
    [RESTRICT | CASCADE]
</pre><p>
      <code class="literal">DROP TABLE</code> は、1 つ以上のテーブルを削除します。各テーブルに対する <code class="literal">DROP</code> 権限が必要です。すべてのテーブルデータとテーブル定義が<span class="emphasis"><em>削除される</em></span>ため、このステートメントには<span class="emphasis"><em>注意してください</em></span>。引数リストで指定されているいずれかのテーブルが存在しない場合、MySQL は削除できなかった存在しないテーブルを名前で示すエラーを返しますが、リスト内の存在しているすべてのテーブルの削除も行います。
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        テーブルが削除されても、そのテーブルに対するユーザー権限は自動的には削除され<span class="emphasis"><em>ません</em></span>。<a class="xref" href="sql-syntax.html#grant" title="13.7.1.4 GRANT 構文">セクション13.7.1.4「GRANT 構文」</a>を参照してください。
      </p></div><p>
      パーティション化されたテーブルの場合は、<code class="literal">DROP TABLE</code> によってテーブル定義、そのすべてのパーティション、およびそれらのパーティションに格納されていたすべてのデータが永続的に削除されることに注意してください。また、削除されたテーブルに関連付けられているパーティション化定義 (<code class="filename">.par</code>) ファイルも削除されます。
    </p><p>
      存在しないテーブルに対してエラーが発生しないようにするには、<code class="literal">IF EXISTS</code> を使用します。<code class="literal">IF EXISTS</code> を使用している場合は、存在しないテーブルごとに <code class="literal">NOTE</code> が生成されます。<a class="xref" href="sql-syntax.html#show-warnings" title="13.7.5.41 SHOW WARNINGS 構文">セクション13.7.5.41「SHOW WARNINGS 構文」</a>を参照してください。
    </p><p>
      <code class="literal">RESTRICT</code> と <code class="literal">CASCADE</code> は、移植を容易にするために許可されています。MySQL 5.6 では、これらは何も行いません。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">DROP TABLE</code> は、<code class="literal">TEMPORARY</code> キーワードが使用されていないかぎり、現在のアクティブなトランザクションを自動的にコミットします。
      </p></div><p>
      <code class="literal">TEMPORARY</code> キーワードには、次の効果があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          このステートメントは、<code class="literal">TEMPORARY</code> テーブルのみを削除します。
        </p></li><li class="listitem"><p>
          このステートメントは、進行中のトランザクションを終了しません。
        </p></li><li class="listitem"><p>
          アクセス権は確認されません。(<code class="literal">TEMPORARY</code> テーブルは、それを作成したセッションにのみ表示されるため、確認は必要ありません。)
        </p></li></ul></div><p>
      <code class="literal">TEMPORARY</code> の使用は、<code class="literal">TEMPORARY</code> 以外のテーブルを誤って削除してしまわないようにするための適切な方法です。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="drop-tablespace"></a>13.1.29 DROP TABLESPACE 構文</h3></div></div></div><a class="indexterm" name="idm139979086098624"></a><pre class="programlisting">
DROP TABLESPACE <em class="replaceable"><code>tablespace_name</code></em>
    ENGINE [=] <em class="replaceable"><code>engine_name</code></em>
</pre><p>
      このステートメントは、以前に <code class="literal">CREATE TABLESPACE</code> を使用して作成されたテーブルスペースを削除します (<a class="xref" href="sql-syntax.html#create-tablespace" title="13.1.18 CREATE TABLESPACE 構文">セクション13.1.18「CREATE TABLESPACE 構文」</a>を参照してください)。
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        削除されるテーブルスペースにデータファイルが含まれていてはいけません。つまり、テーブルスペースを削除できるようにするには、まず <code class="literal">ALTER TABLESPACE ... DROP DATAFILE</code> を使用してその各データファイルを削除する必要があります (<a class="xref" href="sql-syntax.html#alter-tablespace" title="13.1.8 ALTER TABLESPACE 構文">セクション13.1.8「ALTER TABLESPACE 構文」</a>を参照してください)。
      </p></div><p>
      <code class="literal">ENGINE</code> 句 (必須) は、このテーブルスペースによって使用されるストレージエンジンを指定します。現在、<em class="replaceable"><code>engine_name</code></em> として受け入れられる値は <code class="literal">NDB</code> と <code class="literal">NDBCLUSTER</code> だけです。
    </p><p>
      <code class="literal">DROP TABLESPACE</code> は、MySQL Cluster のディスクデータストレージでのみ有効です。<a class="xref" href="mysql-cluster.html#mysql-cluster-disk-data" title="18.5.12 MySQL Cluster ディスクデータテーブル">セクション18.5.12「MySQL Cluster ディスクデータテーブル」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="drop-trigger"></a>13.1.30 DROP TRIGGER 構文</h3></div></div></div><a class="indexterm" name="idm139979086079728"></a><a class="indexterm" name="idm139979086078416"></a><pre class="programlisting">
DROP TRIGGER [IF EXISTS] [<em class="replaceable"><code>schema_name</code></em>.]<em class="replaceable"><code>trigger_name</code></em>
</pre><p>
      このステートメントは、トリガーを削除します。スキーマ (データベース) 名はオプションです。スキーマが省略されている場合、このトリガーはデフォルトスキーマから削除されます。<code class="literal">DROP TRIGGER</code> には、このトリガーに関連付けられたテーブルに対する <code class="literal">TRIGGER</code> 権限が必要です。
    </p><p>
      存在しないトリガーに対してエラーが発生しないようにするには、<code class="literal">IF EXISTS</code> を使用します。<code class="literal">IF EXISTS</code> を使用している場合は、存在しないトリガーに対して <code class="literal">NOTE</code> が生成されます。<a class="xref" href="sql-syntax.html#show-warnings" title="13.7.5.41 SHOW WARNINGS 構文">セクション13.7.5.41「SHOW WARNINGS 構文」</a>を参照してください。
    </p><p>
      テーブルを削除すると、そのテーブルのトリガーも削除されます。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="drop-view"></a>13.1.31 DROP VIEW 構文</h3></div></div></div><a class="indexterm" name="idm139979086063744"></a><pre class="programlisting">
DROP VIEW [IF EXISTS]
    <em class="replaceable"><code>view_name</code></em> [, <em class="replaceable"><code>view_name</code></em>] ...
    [RESTRICT | CASCADE]
</pre><p>
      <code class="literal">DROP VIEW</code> は、1 つ以上のビューを削除します。各ビューに対する <code class="literal">DROP</code> 権限が必要です。引数リストで指定されているいずれかのビューが存在しない場合、MySQL は削除できなかった存在しないビューを名前で示すエラーを返しますが、リスト内の存在しているすべてのビューの削除も行います。
    </p><p>
      <code class="literal">IF EXISTS</code> 句は、存在しないビューに対してエラーが発生しないようにします。この句が指定されている場合は、存在しないビューごとに <code class="literal">NOTE</code> が生成されます。<a class="xref" href="sql-syntax.html#show-warnings" title="13.7.5.41 SHOW WARNINGS 構文">セクション13.7.5.41「SHOW WARNINGS 構文」</a>を参照してください。
    </p><p>
      <code class="literal">RESTRICT</code> と <code class="literal">CASCADE</code> (指定されている場合) は解析されますが、無視されます。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="rename-table"></a>13.1.32 RENAME TABLE 構文</h3></div></div></div><a class="indexterm" name="idm139979086048464"></a><pre class="programlisting">
RENAME TABLE <em class="replaceable"><code>tbl_name</code></em> TO <em class="replaceable"><code>new_tbl_name</code></em>
    [, <em class="replaceable"><code>tbl_name2</code></em> TO <em class="replaceable"><code>new_tbl_name2</code></em>] ...
</pre><p>
      このステートメントは、1 つ以上のテーブルの名前を変更します。
    </p><p>
      名前変更の操作は原子的に実行されます。つまり、名前の変更が実行されている間、ほかのセッションはどのテーブルにもアクセスできません。たとえば、既存のテーブル <code class="literal">old_table</code> が存在する場合は、次のように、同じ構造を持っているが空である別のテーブル <code class="literal">new_table</code> を作成してから、既存のテーブルをその空のテーブルに置き換えることができます (<code class="literal">backup_table</code> はまだ存在していないと仮定します)。
    </p><pre class="programlisting">
CREATE TABLE new_table (...);
RENAME TABLE old_table TO backup_table, new_table TO old_table;
</pre><p>
      このステートメントで複数のテーブルの名前を変更する場合、名前の変更操作は左から右に実行されます。2 つのテーブル名をスワップする場合は、次のように実行できます (<code class="literal">tmp_table</code> はまだ存在していないと仮定します)。
    </p><pre class="programlisting">
RENAME TABLE old_table TO tmp_table,
             new_table TO old_table,
             tmp_table TO new_table;
</pre><p>
      2 つのデータベースが同じファイルシステム上に存在するかぎり、<code class="literal">RENAME TABLE</code> を使用して、あるデータベースから別のデータベースにテーブルを移動できます。
    </p><pre class="programlisting">
RENAME TABLE <em class="replaceable"><code>current_db.tbl_name</code></em> TO <em class="replaceable"><code>other_db.tbl_name;</code></em>
</pre><p>
      <code class="literal">RENAME TABLE</code> を使用して別のデータベースに移動されたテーブルに関連付けられたトリガーが存在する場合は、ステートメントがエラー <span class="errortext">Trigger in wrong schema</span> で失敗します。
    </p><p>
      ビューの名前を変更して別のデータベースに移動しようとしないかぎり、<code class="literal">RENAME TABLE</code> はビューに対しても機能します。
    </p><p>
      名前変更されたテーブルまたはビュー専用に付与された権限は、どれも新しい名前には移行されません。それらは、手動で変更する必要があります。
    </p><p>
      <code class="literal">RENAME</code> を実行する場合は、ロックされたテーブルやアクティブなトランザクションが存在していてはいけません。また、元のテーブルに対する <code class="literal">ALTER</code> および <code class="literal">DROP</code> 権限と、新しいテーブルに対する <code class="literal">CREATE</code> および <code class="literal">INSERT</code> 権限も必要です。
    </p><p>
      複数テーブルの名前変更で何らかのエラーが発生した場合、MySQL はすべてをその元の状態に戻すために、名前変更されたすべてのテーブルに対して逆方向の名前変更を実行します。
    </p><p>
      <code class="literal">RENAME</code> を使用して <code class="literal">TEMPORARY</code> テーブルの名前を変更することはできません。ただし、代わりに <code class="literal">ALTER TABLE</code> を使用できます。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>ALTER TABLE orig_name RENAME new_name;</code></strong>
</pre><p>
      この名前変更操作によってテーブルが別のファイルシステム上にあるデータベースに移動される場合、結果の成功はプラットフォーム固有であり、テーブルファイルを移動するために使用されるベースとなるオペレーティングシステムコールに依存します。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="truncate-table"></a>13.1.33 TRUNCATE TABLE 構文</h3></div></div></div><a class="indexterm" name="idm139979086012464"></a><pre class="programlisting">
TRUNCATE [TABLE] <em class="replaceable"><code>tbl_name</code></em>
</pre><p>
      <code class="literal">TRUNCATE TABLE</code> は、テーブルを完全に空にします。これには <code class="literal">DROP</code> 権限が必要です。
    </p><p>
      <code class="literal">TRUNCATE TABLE</code> は論理的に、すべての行を削除する <code class="literal">DELETE</code> ステートメントや、<code class="literal">DROP TABLE</code> および <code class="literal">CREATE TABLE</code> ステートメントのシーケンスに似ています。高性能を実現するために、データを削除するための DML の方法をバイパスします。そのため、ロールバックすることができず、<code class="literal">ON DELETE</code> トリガーが起動されることはなく、さらに親子の外部キー関係を持つ <code class="literal">InnoDB</code> テーブルに対して実行することもできません。
    </p><p>
      <code class="literal">TRUNCATE TABLE</code> は <code class="literal">DELETE</code> に似ているにもかかわらず、DML ステートメントではなく DDL ステートメントとして分類されます。MySQL 5.6 では、<code class="literal">DELETE</code> とは次の点で異なります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          切り捨て操作はテーブルを削除して再作成するため、特に大きなテーブルの場合は、行を 1 つずつ削除するよりはるかに高速です。
        </p></li><li class="listitem"><p>
          切り捨て操作は暗黙的なコミットを発生させるため、ロールバックできません。
        </p></li><li class="listitem"><p>
          セッションがアクティブなテーブルロックを保持している場合は、切り詰め操作を実行できません。
        </p></li><li class="listitem"><p>
          <code class="literal">TRUNCATE TABLE</code> は、<code class="literal">InnoDB</code> テーブルに対して、このテーブルを参照するほかのテーブルからの何らかの <code class="literal">FOREIGN KEY</code> 制約が存在する場合は失敗します。同じテーブルのカラム間の外部キー制約が許可されます。
        </p></li><li class="listitem"><p>
          切り詰め操作は、削除された行数に対して、意味のある値を返しません。通常の結果は<span class="quote">「<span class="quote">0 rows affected</span>」</span>ですが、これは<span class="quote">「<span class="quote">情報がない</span>」</span>ものとして解釈してください。
        </p></li><li class="listitem"><p>
          テーブル形式ファイル <code class="filename"><em class="replaceable"><code>tbl_name</code></em>.frm</code> が有効であるかぎり、データまたはインデックスファイルが破損した場合でも、<code class="literal">TRUNCATE TABLE</code> を使用してテーブルを空のテーブルとして再作成できます。
        </p></li><li class="listitem"><p>
          <code class="literal">AUTO_INCREMENT</code> 値はすべて、その開始値にリセットされます。これは、通常はシーケンス値を再利用しない <code class="literal">MyISAM</code> や <code class="literal">InnoDB</code> にも当てはまります。
        </p></li><li class="listitem"><p>
          パーティション化されたテーブルで使用された場合、<code class="literal">TRUNCATE TABLE</code> はそのパーティション化を保持します。つまり、データおよびインデックスファイルが削除されて再作成されるのに対して、パーティション定義 (<code class="filename">.par</code>) ファイルは影響を受けません。
        </p></li><li class="listitem"><p>
          <code class="literal">TRUNCATE TABLE</code> ステートメントは、<code class="literal">ON DELETE</code> トリガーを起動しません。
        </p></li></ul></div><p>
      テーブルに対する <code class="literal">TRUNCATE TABLE</code> は、<code class="literal">HANDLER OPEN</code> で開かれたそのテーブルのすべてのハンドラを閉じます。
    </p><p>
      <code class="literal">TRUNCATE TABLE</code> は、バイナリロギングおよびレプリケーション目的のときは、<code class="literal">DROP TABLE</code> とそれに続く <code class="literal">CREATE TABLE</code> として、つまり、DML ではなく DDL として扱われます。これは、<code class="literal">InnoDB</code> またはほかのトランザクションストレージエンジン (そのトランザクション分離レベルがステートメントベースロギングを許可しない (<code class="literal">READ COMMITTED</code> または <code class="literal">READ UNCOMMITTED</code>)) を使用するときは、<code class="literal">STATEMENT</code> または <code class="literal">MIXED</code> ロギングモード使用時にステートメントがログに記録されず複製されなかった事実によります。(Bug #36763) ただし、<code class="literal">InnoDB</code> を使用するレプリケーションスレーブには依然としてすでに説明した方法で適用されます。
    </p><p>
      <code class="literal">TRUNCATE TABLE</code> はパフォーマンススキーマのサマリーテーブルで使用できますが、その効果は行の削除ではなく、サマリーカラムを 0 または <code class="literal">NULL</code> にリセットすることです。<a class="xref" href="performance-schema.html#performance-schema-summary-tables" title="22.9.9 パフォーマンススキーマサマリーテーブル">セクション22.9.9「パフォーマンススキーマサマリーテーブル」</a>を参照してください。
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sql-syntax-data-manipulation"></a>13.2 データ操作ステートメント</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-syntax.html#call">13.2.1 CALL 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#delete">13.2.2 DELETE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#do">13.2.3 DO 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#handler">13.2.4 HANDLER 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#insert">13.2.5 INSERT 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#load-data">13.2.6 LOAD DATA INFILE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#load-xml">13.2.7 LOAD XML 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#replace">13.2.8 REPLACE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#select">13.2.9 SELECT 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#subqueries">13.2.10 サブクエリー構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#update">13.2.11 UPDATE 構文</a></span></dt></dl></div><a class="indexterm" name="idm139979085954688"></a><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="call"></a>13.2.1 CALL 構文</h3></div></div></div><a class="indexterm" name="idm139979085952304"></a><pre class="programlisting">
CALL <em class="replaceable"><code>sp_name</code></em>([<em class="replaceable"><code>parameter</code></em>[,...]])
CALL <em class="replaceable"><code>sp_name</code></em>[()]
</pre><p>
      <code class="literal">CALL</code> ステートメントは、以前に <code class="literal">CREATE PROCEDURE</code> を使用して定義されたストアドプロシージャーを呼び出します。
    </p><p>
      引数を取らないストアドプロシージャーは、括弧なしで呼び出すことができます。つまり、<code class="literal">CALL p()</code> と <code class="literal">CALL p</code> は同等です。
    </p><p>
      <code class="literal">CALL</code> は、<code class="literal">OUT</code> または <code class="literal">INOUT</code> パラメータとして宣言されたパラメータを使用して、その呼び出し元に値を返すことができます。そのプロシージャーから戻るとき、クライアントプログラムは、ルーチン内で実行された最後のステートメントで影響を受けた行数を取得することもできます。SQL レベルでは、<code class="literal">ROW_COUNT()</code> 関数を呼び出します。C API からは、<code class="literal">mysql_affected_rows()</code> 関数を呼び出します。
    </p><p>
      <code class="literal">OUT</code> または <code class="literal">INOUT</code> パラメータを使用してプロシージャーから値を取得するには、ユーザー変数を使用してこのパラメータを渡し、そのプロシージャーから戻ったあとに変数の値をチェックします。(そのプロシージャーを別のストアドプロシージャーまたはストアドファンクション内から呼び出している場合は、<code class="literal">IN</code> または <code class="literal">INOUT</code> パラメータとしてルーチンパラメータまたはローカルルーチン変数を渡すこともできます。)<code class="literal">INOUT</code> パラメータの場合は、プロシージャーに渡す前にその値を初期化してください。次のプロシージャーには、このプロシージャーが現在のサーバーバージョンに設定する <code class="literal">OUT</code> パラメータと、このプロシージャーがその現在の値から 1 増分する <code class="literal">INOUT</code> 値が含まれています。
    </p><pre class="programlisting">
CREATE PROCEDURE p (OUT ver_param VARCHAR(25), INOUT incr_param INT)
BEGIN
  # Set value of OUT parameter
  SELECT VERSION() INTO ver_param;
  # Increment value of INOUT parameter
  SET incr_param = incr_param + 1;
END;
</pre><p>
      このプロシージャーを呼び出す前に、<code class="literal">INOUT</code> パラメータとして渡される変数を初期化します。このプロシージャーを呼び出したあと、これらの 2 つの変数の値は設定または変更されています。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET @increment = 10;</code></strong>
mysql&gt; <strong class="userinput"><code>CALL p(@version, @increment);</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT @version, @increment;</code></strong>
+--------------+------------+
| @version     | @increment |
+--------------+------------+
| 5.5.3-m3-log |         11 |
+--------------+------------+
</pre><p>
      <code class="literal">PREPARE</code> および <code class="literal">EXECUTE</code> で使用される準備済み <code class="literal">CALL</code> ステートメントでは、<code class="literal">IN</code> パラメータにプレースホルダを使用できます。<code class="literal">OUT</code> および <code class="literal">INOUT</code> パラメータの場合、プレースホルダのサポートは MySQL 5.5.3 以降で使用できます。これらの種類のパラメータは、次のように使用できます。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET @increment = 10;</code></strong>
mysql&gt; <strong class="userinput"><code>PREPARE s FROM 'CALL p(?, ?)';</code></strong>
mysql&gt; <strong class="userinput"><code>EXECUTE s USING @version, @increment;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT @version, @increment;</code></strong>
+--------------+------------+
| @version     | @increment |
+--------------+------------+
| 5.5.3-m3-log |         11 |
+--------------+------------+
</pre><p>
      MySQL 5.5.3 より前は、<code class="literal">OUT</code> または <code class="literal">INOUT</code> パラメータにプレースホルダのサポートは使用できません。<code class="literal">OUT</code> および <code class="literal">INOUT</code> パラメータに対するこの制限を回避するために、プレースホルダの使用は避けてください。代わりに、ユーザー変数を <code class="literal">CALL</code> ステートメント自体で参照し、<code class="literal">EXECUTE</code> ステートメントでは指定しないでください。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET @increment = 10;</code></strong>
mysql&gt; <strong class="userinput"><code>PREPARE s FROM 'CALL p(@version, @increment)';</code></strong>
mysql&gt; <strong class="userinput"><code>EXECUTE s;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT @version, @increment;</code></strong>
+--------------+------------+
| @version     | @increment |
+--------------+------------+
| 5.5.0-m2-log |         11 |
+--------------+------------+
</pre><p>
      <code class="literal">CALL</code> SQL ステートメントを使用して、結果セットを生成するストアドプロシージャーを実行する C プログラムを記述するには、<code class="literal">CLIENT_MULTI_RESULTS</code> フラグが有効になっている必要があります。これは、各 <code class="literal">CALL</code> によって、プロシージャー内で実行されるステートメントによって返される可能性のある結果セットに加えて、呼び出しステータスを示すための結果が返されるためです。<code class="literal">CLIENT_MULTI_RESULTS</code> は、<code class="literal">CALL</code> が、準備済みステートメントを含むストアドプロシージャーを実行するために使用される場合にも有効になっている必要があります。このようなプロシージャーがいつロードされるかや、これらのステートメントによって結果セットが生成されるかどうかを特定することはできないため、これらを想定する必要があります。
    </p><p>
      <code class="literal">CLIENT_MULTI_RESULTS</code> は、<code class="literal">mysql_real_connect()</code> を呼び出すときに、<code class="literal">CLIENT_MULTI_RESULTS</code> フラグ自体を渡すことによって明示的に、または <code class="literal">CLIENT_MULTI_STATEMENTS</code> を渡すことによって暗黙的に有効にする (これによって <code class="literal">CLIENT_MULTI_RESULTS</code> も有効になります) ことができます。MySQL 5.6 では、<code class="literal">CLIENT_MULTI_RESULTS</code> はデフォルトで有効にされています。
    </p><p>
      <code class="literal">mysql_query()</code> または <code class="literal">mysql_real_query()</code> を使用して実行された <code class="literal">CALL</code> ステートメントの結果を処理するには、それ以上結果が存在するかどうかを判定するために <code class="literal">mysql_next_result()</code> を呼び出すループを使用してください。例については、<a class="xref" href="connectors-apis.html#c-api-multiple-queries" title="23.8.17 複数ステートメント実行の C API サポート">セクション23.8.17「複数ステートメント実行の C API サポート」</a>を参照してください。
    </p><p>
      MySQL インタフェースを備える言語で記述されたプログラムの場合は、<code class="literal">CALL</code> ステートメントからの <code class="literal">OUT</code> または <code class="literal">INOUT</code> パラメータの結果を直接取得するためのネイティブメソッドが MySQL 5.5.3 より前には存在しません。これらのパラメータ値を取得するには、<code class="literal">CALL</code> ステートメントでプロシージャーにユーザー定義変数を渡したあと、<code class="literal">SELECT</code> ステートメントを実行して変数値を含む結果セットを生成してください。<code class="literal">INOUT</code> パラメータを処理するには、<code class="literal">CALL</code> の前に、対応するユーザー変数を、プロシージャーに渡される値に設定するステートメントを実行してください。
    </p><p>
      次の例は、先に説明した、<code class="literal">OUT</code> パラメータと <code class="literal">INOUT</code> パラメータを含むストアドプロシージャー <code class="literal">p</code> の手法 (エラーチェックはなし) を示しています。
    </p><pre class="programlisting">
mysql_query(mysql, "SET @increment = 10");
mysql_query(mysql, "CALL p(@version, @increment)");
mysql_query(mysql, "SELECT @version, @increment");
result = mysql_store_result(mysql);
row = mysql_fetch_row(result);
mysql_free_result(result);
</pre><p>
      前のコードが実行されたあと、<code class="literal">row[0]</code> と <code class="literal">row[1]</code> にはそれぞれ、<code class="literal">@version</code> と <code class="literal">@increment</code> の値が含まれています。
    </p><p>
      MySQL 5.6 では、C プログラムは準備済みステートメントインタフェースを使用して <code class="literal">CALL</code> ステートメントを実行し、<code class="literal">OUT</code> および <code class="literal">INOUT</code> パラメータにアクセスできます。これは、それ以上結果が存在するかどうかを判定するために <code class="literal">mysql_stmt_next_result()</code> を呼び出すループを使用して <code class="literal">CALL</code> ステートメントの結果を処理することにより行われます。例については、<a class="xref" href="connectors-apis.html#c-api-prepared-call-statements" title="23.8.20 C API のプリペアド CALL ステートメントのサポート">セクション23.8.20「C API のプリペアド CALL ステートメントのサポート」</a>を参照してください。MySQL インタフェースを備える言語は、準備済み <code class="literal">CALL</code> ステートメントを使用して、<code class="literal">OUT</code> および <code class="literal">INOUT</code> プロシージャーパラメータを直接取得できます。
    </p><p>
      MySQL 5.6.6 以降では、ストアドプログラムによって参照されるオブジェクトへのメタデータ変更が検出され、そのプログラムが次に実行されときに、影響を受けるステートメントの自動再解析が行われるようになります。詳細については、<a class="xref" href="optimization.html#statement-caching" title="8.9.4 プリペアドステートメントおよびストアドプログラムのキャッシュ">セクション8.9.4「プリペアドステートメントおよびストアドプログラムのキャッシュ」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="delete"></a>13.2.2 DELETE 構文</h3></div></div></div><a class="indexterm" name="idm139979085859344"></a><a class="indexterm" name="idm139979085858032"></a><p>
      <code class="literal">DELETE</code> は、テーブルの行を削除する DML ステートメントです。
    </p><h4><a name="idm139979085852560"></a>単一テーブル構文</h4><pre class="programlisting">
DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM <em class="replaceable"><code>tbl_name</code></em>
    [PARTITION (<em class="replaceable"><code>partition_name</code></em>,...)]
    [WHERE <em class="replaceable"><code>where_condition</code></em>]
    [ORDER BY ...]
    [LIMIT <em class="replaceable"><code>row_count</code></em>]
</pre><p>
      <code class="literal">DELETE</code> ステートメントは、<em class="replaceable"><code>tbl_name</code></em> の行を削除し、削除された行数を返します。削除された行数をチェックするには、<a class="xref" href="functions.html#information-functions" title="12.14 情報関数">セクション12.14「情報関数」</a>で説明されている<code class="literal">ROW_COUNT()</code> 関数を呼び出します。
    </p><h4><a name="idm139979085845792"></a>メインの句</h4><p>
      オプションの <code class="literal">WHERE</code> 句内の条件は、どの行を削除するかを識別します。<code class="literal">WHERE</code> 句がない場合は、すべての行が削除されます。
    </p><p>
      <em class="replaceable"><code>where_condition</code></em> は、削除される各行に対して true に評価される式です。これは、<a class="xref" href="sql-syntax.html#select" title="13.2.9 SELECT 構文">セクション13.2.9「SELECT 構文」</a>で説明されているように指定されます。
    </p><p>
      <code class="literal">ORDER BY</code> 句が指定されている場合は、指定されている順序で行が削除されます。<code class="literal">LIMIT</code> 句は、削除できる行数に制限を設定します。これらの句は単一テーブルの削除に適用されますが、複数テーブルの削除には適用されません。
    </p><h4><a name="idm139979085838880"></a>複数テーブル構文</h4><pre class="programlisting">
DELETE [LOW_PRIORITY] [QUICK] [IGNORE]
    <em class="replaceable"><code>tbl_name</code></em>[.*] [, <em class="replaceable"><code>tbl_name</code></em>[.*]] ...
    FROM <em class="replaceable"><code>table_references</code></em>
    [WHERE <em class="replaceable"><code>where_condition</code></em>]
</pre><p>
      または:
    </p><pre class="programlisting">
DELETE [LOW_PRIORITY] [QUICK] [IGNORE]
    FROM <em class="replaceable"><code>tbl_name</code></em>[.*] [, <em class="replaceable"><code>tbl_name</code></em>[.*]] ...
    USING <em class="replaceable"><code>table_references</code></em>
    [WHERE <em class="replaceable"><code>where_condition</code></em>]
</pre><h4><a name="idm139979085831696"></a>権限</h4><p>
      テーブルから行を削除するには、そのテーブルに対する <code class="literal">DELETE</code> 権限が必要です。<code class="literal">WHERE</code> 句で指定されているカラムなどの、読み取られるだけのカラムに対しては、<code class="literal">SELECT</code> 権限のみが必要です。
    </p><h4><a name="idm139979085827456"></a>パフォーマンス</h4><p>
      削除された行数を知る必要がない場合、テーブルを空にするには、<code class="literal">WHERE</code> 句のない <code class="literal">DELETE</code> ステートメントより <code class="literal">TRUNCATE TABLE</code> ステートメントの方が高速です。<code class="literal">DELETE</code> とは異なり、<code class="literal">TRUNCATE TABLE</code> はトランザクション内で、またはそのテーブルがロックされている場合は使用できません。<a class="xref" href="sql-syntax.html#truncate-table" title="13.1.33 TRUNCATE TABLE 構文">セクション13.1.33「TRUNCATE TABLE 構文」</a>および<a class="xref" href="sql-syntax.html#lock-tables" title="13.3.5 LOCK TABLES および UNLOCK TABLES 構文">セクション13.3.5「LOCK TABLES および UNLOCK TABLES 構文」</a>を参照してください。
    </p><p>
      削除操作の速度はまた、<a class="xref" href="optimization.html#delete-speed" title="8.2.2.3 DELETE ステートメントの速度">セクション8.2.2.3「DELETE ステートメントの速度」</a>で説明されている要因によって影響を受ける可能性もあります。
    </p><p>
      特定の <code class="literal">DELETE</code> ステートメントに時間がかかりすぎないようにするために、<code class="literal">DELETE</code> の MySQL 固有の <code class="literal">LIMIT <em class="replaceable"><code>row_count</code></em></code> 句は、削除される行の最大数を指定します。削除する行数がこの制限を超えている場合は、影響を受ける行数が <code class="literal">LIMIT</code> 値を下回るまで <code class="literal">DELETE</code> ステートメントを繰り返します。
    </p><h4><a name="idm139979085812928"></a>サブクエリー</h4><p>
      現在、テーブルから削除し、さらにサブクエリーで同じテーブルから選択することはできません。
    </p><h4><a name="idm139979085811552"></a>パーティション化されたテーブル</h4><p>
      MySQL 5.6.2 から、<code class="literal">DELETE</code> は、削除される行を選択する 1 つ以上のパーティションまたはサブパーティション (またはその両方) の名前のカンマ区切りリストを含む <code class="literal">PARTITION</code> オプションを使用した明示的なパーティション選択をサポートしています。このリストに含まれていないパーティションは無視されます。<code class="literal">p0</code> という名前のパーティションを含むパーティション化されたテーブル <code class="literal">t</code> がある場合、ステートメント <code class="literal">DELETE FROM t PARTITION (p0)</code> の実行には、このテーブルに対して <code class="literal">ALTER TABLE t TRUNCATE PARTITION (p0)</code> を実行するのと同じ効果があります。どちらの場合も、パーティション <code class="literal">p0</code> 内のすべての行が削除されます。
    </p><p>
      <code class="literal">PARTITION</code> は、<code class="literal">WHERE</code> 条件とともに使用できます。その場合、この条件は、リストされているパーティション内の行に対してのみテストされます。たとえば、<code class="literal">DELETE FROM t PARTITION (p0) WHERE c &lt; 5</code> は、条件 <code class="literal">c &lt; 5</code> が true であるパーティション <code class="literal">p0</code> の行のみを削除します。ほかのパーティション内の行はチェックされないため、<code class="literal">DELETE</code> によって影響を受けません。
    </p><p>
      <code class="literal">PARTITION</code> オプションはまた、複数テーブルの <code class="literal">DELETE</code> ステートメントでも使用できます。このようなオプションを、<code class="literal">FROM</code> オプションで指定されているテーブルごとに最大 1 つ使用できます。
    </p><p>
      詳細および例については、<a class="xref" href="partitioning.html#partitioning-selection" title="19.5 パーティション選択">セクション19.5「パーティション選択」</a>を参照してください。
    </p><h4><a name="idm139979085793424"></a>自動インクリメントカラム</h4><p>
      <code class="literal">AUTO_INCREMENT</code> カラムに最大値を含む行を削除した場合、その値は、<code class="literal">MyISAM</code> または <code class="literal">InnoDB</code> テーブルには再利用されません。<code class="literal">autocommit</code> モードで <code class="literal">DELETE FROM <em class="replaceable"><code>tbl_name</code></em></code> (<code class="literal">WHERE</code> 句はなし) を使用してテーブル内のすべての行を削除した場合、そのシーケンスは、<code class="literal">InnoDB</code> と <code class="literal">MyISAM</code> を除くすべてのストレージエンジンに対して開始されます。<a class="xref" href="innodb-storage-engine.html#innodb-auto-increment-handling" title="14.6.5 InnoDB での AUTO_INCREMENT 処理">セクション14.6.5「InnoDB での AUTO_INCREMENT 処理」</a>で説明されているように、<code class="literal">InnoDB</code> テーブルに対しては、この動作の例外がいくつかあります。
    </p><p>
      <code class="literal">MyISAM</code> テーブルの場合は、マルチカラムキー内の <code class="literal">AUTO_INCREMENT</code> セカンダリカラムを指定できます。この場合は、シーケンスの先頭から削除された値の再利用が <code class="literal">MyISAM</code> テーブルに対しても実行されます。<a class="xref" href="tutorial.html#example-auto-increment" title="3.6.9 AUTO_INCREMENT の使用">セクション3.6.9「AUTO_INCREMENT の使用」</a>を参照してください。
    </p><h4><a name="idm139979085780176"></a>修飾子</h4><p>
      <code class="literal">DELETE</code> ステートメントは、次の修飾子をサポートします。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">LOW_PRIORITY</code> を指定した場合、サーバーは、ほかのどのクライアントもそのテーブルから読み取らなくなるまで <code class="literal">DELETE</code> の実行を遅延させます。これは、テーブルレベルロックのみを使用するストレージエンジン (<code class="literal">MyISAM</code>、<code class="literal">MEMORY</code>、および <code class="literal">MERGE</code>) にのみ影響を与えます。
        </p></li><li class="listitem"><p>
          <code class="literal">MyISAM</code> テーブルでは、<code class="literal">QUICK</code> キーワードを使用した場合、ストレージエンジンは削除中にインデックスリーフをマージしません。これにより、一部の種類の削除操作が高速化される可能性があります。
        </p></li><li class="listitem"><p>
          <code class="literal">IGNORE</code> キーワードを指定すると、MySQL は行削除プロセス中のエラーを無視します。(解析の段階で検出されたエラーは、通常の方法で処理されます。)<code class="literal">IGNORE</code> の使用のために無視されたエラーは、警告として返されます。
        </p></li></ul></div><h4><a name="idm139979085766960"></a>削除の順序</h4><p>
      <code class="literal">DELETE</code> ステートメントに <code class="literal">ORDER BY</code> 句が含まれている場合は、この句で指定されている順序で行が削除されます。これは、主に <code class="literal">LIMIT</code> と組み合わせて使用した場合に有効です。たとえば、次のステートメントは <code class="literal">WHERE</code> 句に一致する行を見つけ、それらを <code class="literal">timestamp_column</code> でソートしたあと、最初の (もっとも古い) 行を削除します。
    </p><pre class="programlisting">
DELETE FROM somelog WHERE user = 'jcole'
ORDER BY timestamp_column LIMIT 1;
</pre><p>
      <code class="literal">ORDER BY</code> はまた、参照整合性の違反を回避するために必要な順序で行を削除する場合も役立ちます。
    </p><h4><a name="idm139979085759216"></a>InnoDB テーブル</h4><p>
      大きなテーブルから多数の行を削除する場合は、<code class="literal">InnoDB</code> テーブルに対するロックテーブルのサイズを超える可能性があります。この問題を回避するために、または単にテーブルがロックされたままになる時間を最小限に抑えるために、<code class="literal">DELETE</code> をまったく使用しない次の方法が有効な場合があります。
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          削除<span class="emphasis"><em>されない</em></span>行を選択して、元のテーブルと同じ構造を持つ空のテーブルに格納します。
        </p><pre class="programlisting">
INSERT INTO t_copy SELECT * FROM t WHERE ... ;
</pre></li><li class="listitem"><p>
          <code class="literal">RENAME TABLE</code> を使用して元のテーブルを原子的に移動したあと、コピーの名前を元の名前に変更します。
        </p><pre class="programlisting">
RENAME TABLE t TO t_old, t_copy TO t;
</pre></li><li class="listitem"><p>
          元のテーブルを削除します。
        </p><pre class="programlisting">
DROP TABLE t_old;
</pre></li></ol></div><p>
      <code class="literal">RENAME TABLE</code> が実行されている間、関連するテーブルにはほかのどのセッションからもアクセスできないため、名前変更の操作は並列性の問題に制約されません。<a class="xref" href="sql-syntax.html#rename-table" title="13.1.32 RENAME TABLE 構文">セクション13.1.32「RENAME TABLE 構文」</a>を参照してください。
    </p><h4><a name="idm139979085745840"></a>MyISAM テーブル</h4><p>
      <code class="literal">MyISAM</code> テーブルでは、削除された行はリンクリスト内に保持され、以降の <code class="literal">INSERT</code> 操作は古い行の位置を再利用します。未使用領域を再利用し、ファイルサイズを減らすには、<code class="literal">OPTIMIZE TABLE</code> ステートメントまたは <span class="command"><strong>myisamchk</strong></span> ユーティリティーを使用してテーブルを再編成します。<code class="literal">OPTIMIZE TABLE</code> の方が使い方は簡単ですが、<span class="command"><strong>myisamchk</strong></span> の方が高速です。<a class="xref" href="sql-syntax.html#optimize-table" title="13.7.2.4 OPTIMIZE TABLE 構文">セクション13.7.2.4「OPTIMIZE TABLE 構文」</a>および<a class="xref" href="programs.html#myisamchk" title="4.6.3 myisamchk — MyISAM テーブルメンテナンスユーティリティー">セクション4.6.3「<span class="command"><strong>myisamchk</strong></span> — MyISAM テーブルメンテナンスユーティリティー」</a>を参照してください。
    </p><p>
      <code class="literal">QUICK</code> 修飾子は、削除操作でインデックスリーフがマージされるかどうかに影響を与えます。<code class="literal">DELETE QUICK</code> は、削除された行のインデックス値が、あとで挿入された行の同様のインデックス値に置き換えられるアプリケーションで、特に役立ちます。この場合、削除された値によって残された穴は再利用されます。
    </p><p>
      <code class="literal">DELETE QUICK</code> は、削除された値によって、新しい挿入が再度発生するインデックス値の範囲全体にわたって空きのあるインデックスブロックが残される場合には役立ちません。この場合は、<code class="literal">QUICK</code> を使用すると、再利用されないままのインデックスで領域が浪費される可能性があります。このようなシナリオの例を次に示します。
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          インデックス付き <code class="literal">AUTO_INCREMENT</code> カラムを含むテーブルを作成します。
        </p></li><li class="listitem"><p>
          このテーブルに多数の行を挿入します。各挿入によって、インデックスの先頭に追加されるインデックス値が生成されます。
        </p></li><li class="listitem"><p>
          <code class="literal">DELETE QUICK</code> を使用して、カラムの範囲の最後にある行のブロックを削除します。
        </p></li></ol></div><p>
      このシナリオでは、削除されたインデックス値に関連付けられたインデックスブロックに空きができますが、<code class="literal">QUICK</code> が使用されているため、ほかのインデックスブロックにはマージされません。新しい挿入が発生したとき、新しい行には削除された範囲内のインデックス値が含まれていないため、これらのインデックスブロックは空きがあるままになります。さらに、削除された一部のインデックス値が偶然に空きのあるブロック内か、またはその隣のインデックスブロックに含まれていないかぎり、あとで <code class="literal">QUICK</code> なしで <code class="literal">DELETE</code> を使用した場合でも空きがあるままになります。これらの状況で未使用のインデックス領域を再利用するには、<code class="literal">OPTIMIZE TABLE</code> を使用します。
    </p><p>
      テーブルから多数の行を削除しようとしている場合は、<code class="literal">DELETE QUICK</code> に続けて <code class="literal">OPTIMIZE TABLE</code> を使用した方が高速になることがあります。これにより、インデックスブロックの多数のマージ操作が実行されるのではなく、インデックスが再構築されます。
    </p><h4><a name="idm139979085719104"></a>複数テーブルの削除</h4><p>
      <code class="literal">WHERE</code> 句内の条件に応じて 1 つ以上のテーブルから行を削除するには、<code class="literal">DELETE</code> ステートメントで複数のテーブルを指定できます。複数テーブルの <code class="literal">DELETE</code> では、<code class="literal">ORDER BY</code> または <code class="literal">LIMIT</code> を使用できません。<a class="xref" href="sql-syntax.html#join" title="13.2.9.2 JOIN 構文">セクション13.2.9.2「JOIN 構文」</a>で説明されているように、<em class="replaceable"><code>table_references</code></em> 句は、結合に含まれるテーブルをリストします。
    </p><p>
      最初の複数テーブル構文では、<code class="literal">FROM</code> 句の前にリストされているテーブルの一致する行のみが削除されます。2 番目の複数テーブル構文では、<code class="literal">USING</code> 句の前にある <code class="literal">FROM</code> 句にリストされているテーブルの一致する行のみが削除されます。その効果は、多数のテーブルの行を同時に削除し、さらに検索にのみ使用される追加のテーブルを指定できることです。
    </p><pre class="programlisting">
DELETE t1, t2 FROM t1 INNER JOIN t2 INNER JOIN t3
WHERE t1.id=t2.id AND t2.id=t3.id;
</pre><p>
      または:
    </p><pre class="programlisting">
DELETE FROM t1, t2 USING t1 INNER JOIN t2 INNER JOIN t3
WHERE t1.id=t2.id AND t2.id=t3.id;
</pre><p>
      これらのステートメントは、削除する行を検索するときに 3 つのすべてのテーブルを使用しますが、テーブル <code class="literal">t1</code> と <code class="literal">t2</code> の一致する行のみを削除します。
    </p><p>
      前の例では <code class="literal">INNER JOIN</code> を使用していますが、複数テーブルの <code class="literal">DELETE</code> ステートメントは、<code class="literal">SELECT</code> ステートメント内で許可されているほかの型の結合 (<code class="literal">LEFT JOIN</code> など) を使用できます。たとえば、<code class="literal">t1</code> 内に存在する行で <code class="literal">t2</code> 内に一致するものがない行を削除するには、<code class="literal">LEFT JOIN</code> を使用します。
    </p><pre class="programlisting">
DELETE t1 FROM t1 LEFT JOIN t2 ON t1.id=t2.id WHERE t2.id IS NULL;
</pre><p>
      この構文では、<span class="command"><strong>Access</strong></span> との互換性のために、各 <em class="replaceable"><code>tbl_name</code></em> のあとに <code class="literal">.*</code> が許可されます。
    </p><p>
      外部キー制約が存在する <code class="literal">InnoDB</code> テーブルを含む、複数テーブルの <code class="literal">DELETE</code> ステートメントを使用した場合は、MySQL オプティマイザが、それらの親子関係の順序とは異なる順序でテーブルを処理する可能性があります。この場合、このステートメントは失敗し、ロールバックされます。代わりに、1 つのテーブルから削除したあと、<code class="literal">InnoDB</code> が提供する <code class="literal">ON DELETE</code> 機能を使用して、ほかのテーブルがそれに応じて変更されるようにしてください。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        テーブルのエイリアスを宣言した場合は、テーブルを参照するときにそのエイリアスを使用する必要があります。
      </p><pre class="programlisting">
DELETE t1 FROM test AS t1, test2 WHERE ...
</pre></div><p>
      複数テーブルの <code class="literal">DELETE</code> 内のテーブルエイリアスは、そのステートメントの <em class="replaceable"><code>table_references</code></em> 部分でのみ宣言するようにしてください。それ以外の場所では、エイリアス参照が許可されますが、エイリアス宣言は許可されません。
    </p><p>
      正しい:
    </p><pre class="programlisting">
DELETE a1, a2 FROM t1 AS a1 INNER JOIN t2 AS a2
WHERE a1.id=a2.id;

DELETE FROM a1, a2 USING t1 AS a1 INNER JOIN t2 AS a2
WHERE a1.id=a2.id;
</pre><p>
      正しくない:
    </p><pre class="programlisting">
DELETE t1 AS a1, t2 AS a2 FROM t1 INNER JOIN t2
WHERE a1.id=a2.id;

DELETE FROM t1 AS a1, t2 AS a2 USING t1 INNER JOIN t2
WHERE a1.id=a2.id;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="do"></a>13.2.3 DO 構文</h3></div></div></div><a class="indexterm" name="idm139979085682880"></a><pre class="programlisting">
DO <em class="replaceable"><code>expr</code></em> [, <em class="replaceable"><code>expr</code></em>] ...
</pre><p>
      <code class="literal">DO</code> は式を実行しますが、結果は何も返しません。ほとんどの点で、<code class="literal">DO</code> は <code class="literal">SELECT <em class="replaceable"><code>expr</code></em>, ...</code> の短縮形ですが、その結果に関心がない場合は少し高速であるという利点があります。
    </p><p>
      <code class="literal">DO</code> は主に、副作用がある関数 (<code class="literal">RELEASE_LOCK()</code> など) で役立ちます。
    </p><p>
      例: この <code class="literal">SELECT</code> ステートメントは一時停止しますが、結果セットの生成も行います。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT SLEEP(5);</code></strong>
+----------+
| SLEEP(5) |
+----------+
|        0 |
+----------+
1 row in set (5.02 sec)
</pre><p>
      それに対して、<code class="literal">DO</code> は、結果セットを生成することなく一時停止します。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>DO SLEEP(5);</code></strong>
Query OK, 0 rows affected (4.99 sec)
</pre><p>
      これは、たとえば、結果セットを生成するステートメントを禁止しているストアドファンクションまたはトリガーで役立つ場合があります。
    </p><p>
      <code class="literal">DO</code> は式を実行するだけです。<code class="literal">SELECT</code> を使用できるすべての場合に使用できるわけではありません。たとえば、<code class="literal">DO id FROM t1</code> は、テーブルを参照するため無効です。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="handler"></a>13.2.4 HANDLER 構文</h3></div></div></div><a class="indexterm" name="idm139979085659360"></a><pre class="programlisting">
HANDLER <em class="replaceable"><code>tbl_name</code></em> OPEN [ [AS] <em class="replaceable"><code>alias</code></em>]

HANDLER <em class="replaceable"><code>tbl_name</code></em> READ <em class="replaceable"><code>index_name</code></em> { = | &lt;= | &gt;= | &lt; | &gt; } (<em class="replaceable"><code>value1</code></em>,<em class="replaceable"><code>value2</code></em>,...)
    [ WHERE <em class="replaceable"><code>where_condition</code></em> ] [LIMIT ... ]
HANDLER <em class="replaceable"><code>tbl_name</code></em> READ <em class="replaceable"><code>index_name</code></em> { FIRST | NEXT | PREV | LAST }
    [ WHERE <em class="replaceable"><code>where_condition</code></em> ] [LIMIT ... ]
HANDLER <em class="replaceable"><code>tbl_name</code></em> READ { FIRST | NEXT }
    [ WHERE <em class="replaceable"><code>where_condition</code></em> ] [LIMIT ... ]

HANDLER <em class="replaceable"><code>tbl_name</code></em> CLOSE
</pre><p>
      <code class="literal">HANDLER</code> ステートメントは、テーブルストレージエンジンインタフェースへの直接アクセスを提供します。これは、<code class="literal">InnoDB</code> および <code class="literal">MyISAM</code> テーブルに使用できます。
    </p><p>
      <code class="literal">HANDLER ... OPEN</code> ステートメントはテーブルを開き、それを以降の <code class="literal">HANDLER ... READ</code> ステートメントを使用してアクセス可能にします。このテーブルオブジェクトはほかのセッションによって共有されておらず、このセッションが <code class="literal">HANDLER ... CLOSE</code> を呼び出すか、またはこのセッションが終了するまでクローズされません。エイリアスを使用してテーブルを開いた場合は、その開かれたテーブルへのほかの <code class="literal">HANDLER</code> ステートメントによるそれ以降の参照は、テーブル名ではなくエイリアスを使用する必要があります。
    </p><p>
      最初の <code class="literal">HANDLER ... READ</code> 構文は、指定されたインデックスが特定の値を満たし、かつ <code class="literal">WHERE</code> 条件が満たされている行をフェッチします。マルチカラムインデックスがある場合は、インデックスカラム値をカンマ区切りリストとして指定します。インデックス内のすべてのカラムの値を指定するか、またはインデックスカラムの左端のプリフィクスの値を指定します。インデックス <code class="literal">my_idx</code> に、<code class="literal">col_a</code>、<code class="literal">col_b</code>、および <code class="literal">col_c</code> という名前の 3 つのカラムがその順序で含まれているとします。<code class="literal">HANDLER</code> ステートメントは、そのインデックス内の 3 つのすべてのカラム、または左端のプリフィクス内のカラムの値を指定できます。例:
    </p><pre class="programlisting">
HANDLER ... READ my_idx = (col_a_val,col_b_val,col_c_val) ...
HANDLER ... READ my_idx = (col_a_val,col_b_val) ...
HANDLER ... READ my_idx = (col_a_val) ...
</pre><p>
      <code class="literal">HANDLER</code> インタフェースを使用してテーブルの <code class="literal">PRIMARY KEY</code> を参照するには、引用符で囲まれた識別子 <code class="literal">`PRIMARY`</code> を使用します。
    </p><pre class="programlisting">
HANDLER <em class="replaceable"><code>tbl_name</code></em> READ `PRIMARY` ...
</pre><p>
      2 番目の <code class="literal">HANDLER ... READ</code> 構文は、<code class="literal">WHERE</code> 条件に一致するインデックス順序でテーブルの行をフェッチします。
    </p><p>
      3 番目の <code class="literal">HANDLER ... READ</code> 構文は、<code class="literal">WHERE</code> 条件に一致する自然な行順序でテーブルの行をフェッチします。これは、フルテーブルスキャンが望ましい場合は、<code class="literal">HANDLER <em class="replaceable"><code>tbl_name</code></em> READ <em class="replaceable"><code>index_name</code></em></code> より高速です。自然な行順序とは、行が <code class="literal">MyISAM</code> テーブルデータファイル内に格納されている順序のことです。このステートメントは <code class="literal">InnoDB</code> テーブルに対しても機能しますが、個別のデータファイルが存在しないため、このような概念はありません。
    </p><p>
      <code class="literal">LIMIT</code> 句を使用しない場合は、すべての形式の <code class="literal">HANDLER ... READ</code> が単一行 (使用可能な場合) をフェッチします。特定の行数を返すには、<code class="literal">LIMIT</code> 句を含めます。その構文は、<code class="literal">SELECT</code> ステートメントの場合と同じです。<a class="xref" href="sql-syntax.html#select" title="13.2.9 SELECT 構文">セクション13.2.9「SELECT 構文」</a>を参照してください。
    </p><p>
      <code class="literal">HANDLER ... CLOSE</code> は、<code class="literal">HANDLER ... OPEN</code> でオープンされたテーブルをクローズします。
    </p><p>
      通常の <code class="literal">SELECT</code> ステートメントの代わりに <code class="literal">HANDLER</code> インタフェースを使用する理由として、次のいくつかがあります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">HANDLER</code> は <code class="literal">SELECT</code> より高速です。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">HANDLER ... OPEN</code> に対して、指定されたストレージエンジンハンドラオブジェクトが割り当てられます。このオブジェクトは、そのテーブルに対する以降の <code class="literal">HANDLER</code> ステートメントに再利用されます。ステートメントごとに再初期化する必要はありません。
            </p></li><li class="listitem"><p>
              関連する解析が少なくなります。
            </p></li><li class="listitem"><p>
              オプティマイザまたはクエリーチェックのオーバーヘッドがありません。
            </p></li><li class="listitem"><p>
              ハンドラインタフェースは (たとえば、<a class="link" href="glossary.html#glos_dirty_read" title="ダーティー読み取り">ダーティー読み取り</a>が許可されるような) データの整合性のある外観を提供する必要がないため、ストレージエンジンは、<code class="literal">SELECT</code> が通常は許可しない最適化を使用できます。
            </p></li></ul></div></li><li class="listitem"><p>
          <code class="literal">HANDLER</code> によって、<code class="literal">ISAM</code> に似た低レベルのインタフェースを使用する MySQL アプリケーションへの移植が容易になります。(キー値格納パラダイムを使用するアプリケーションを適応させるための代替手段については、<a class="xref" href="innodb-storage-engine.html#innodb-memcached" title="14.18 InnoDB と memcached の統合">セクション14.18「InnoDB と memcached の統合」</a>を参照してください。)
        </p></li><li class="listitem"><p>
          <code class="literal">HANDLER</code> を使用すると、<code class="literal">SELECT</code> では実現が困難な (または、不可能でさえある) 方法でデータベースをたどることができます。<code class="literal">HANDLER</code> インタフェースは、データベースに対話型ユーザーインタフェースを提供するアプリケーションの操作時にデータを調べるためのより自然な方法です。
        </p></li></ul></div><p>
      <code class="literal">HANDLER</code> は、やや低レベルのステートメントです。たとえば、一貫性が提供されません。つまり、<code class="literal">HANDLER ... OPEN</code> はテーブルのスナップショットを作成<span class="emphasis"><em>せず</em></span>、テーブルのロックも行い<span class="emphasis"><em>ません</em></span>。これは、<code class="literal">HANDLER ... OPEN</code> ステートメントが発行されたあと、テーブルデータを (現在のセッションまたはその他のセッションで) 変更することができ、これらの変更が <code class="literal">HANDLER ... NEXT</code> または <code class="literal">HANDLER ... PREV</code> スキャンに部分的にしか表示されない可能性があることを示します。
    </p><p>
      開かれたハンドラを閉じ、再度開くようにマークすることができます。その場合、このハンドラはテーブル内の位置を失います。これは、次の両方の状況が当てはまる場合に発生します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          このハンドラのテーブルに対して、いずれかのセッションが <code class="literal">FLUSH TABLES</code> または DDL ステートメントを実行している。
        </p></li><li class="listitem"><p>
          このハンドラを開いているセッションが、テーブルを使用する <code class="literal">HANDLER</code> 以外のステートメントを実行している。
        </p></li></ul></div><p>
      テーブルに対する <code class="literal">TRUNCATE TABLE</code> は、<code class="literal">HANDLER OPEN</code> で開かれたそのテーブルのすべてのハンドラを閉じます。
    </p><p>
      <code class="literal">FLUSH TABLES <em class="replaceable"><code>tbl_name</code></em> WITH READ LOCK</code> でフラッシュされたテーブルが <code class="literal">HANDLER</code> で開かれた場合、そのハンドラは暗黙的にフラッシュされ、その位置を失います。
    </p><p>
      <code class="literal">HANDLER</code> は、パーティション化されたテーブルではサポートされません。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="insert"></a>13.2.5 INSERT 構文</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-syntax.html#insert-select">13.2.5.1 INSERT ... SELECT 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#insert-delayed">13.2.5.2 INSERT DELAYED 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#insert-on-duplicate">13.2.5.3 INSERT ... ON DUPLICATE KEY UPDATE 構文</a></span></dt></dl></div><a class="indexterm" name="idm139979085574384"></a><a class="indexterm" name="idm139979085573072"></a><a class="indexterm" name="idm139979085571728"></a><pre class="programlisting">
INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]
    [INTO] <em class="replaceable"><code>tbl_name</code></em>
    [PARTITION (<em class="replaceable"><code>partition_name</code></em>,...)] 
    [(<em class="replaceable"><code>col_name</code></em>,...)]
    {VALUES | VALUE} ({<em class="replaceable"><code>expr</code></em> | DEFAULT},...),(...),...
    [ ON DUPLICATE KEY UPDATE
      <em class="replaceable"><code>col_name</code></em>=<em class="replaceable"><code>expr</code></em>
        [, <em class="replaceable"><code>col_name</code></em>=<em class="replaceable"><code>expr</code></em>] ... ]
</pre><p>
      または:
    </p><pre class="programlisting">
INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]
    [INTO] <em class="replaceable"><code>tbl_name</code></em>
    [PARTITION (<em class="replaceable"><code>partition_name</code></em>,...)]
    SET <em class="replaceable"><code>col_name</code></em>={<em class="replaceable"><code>expr</code></em> | DEFAULT}, ...
    [ ON DUPLICATE KEY UPDATE
      <em class="replaceable"><code>col_name</code></em>=<em class="replaceable"><code>expr</code></em>
        [, <em class="replaceable"><code>col_name</code></em>=<em class="replaceable"><code>expr</code></em>] ... ]
</pre><p>
      または:
    </p><pre class="programlisting">
INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]
    [INTO] <em class="replaceable"><code>tbl_name</code></em>
    [PARTITION (<em class="replaceable"><code>partition_name</code></em>,...)] 
    [(<em class="replaceable"><code>col_name</code></em>,...)]
    SELECT ...
    [ ON DUPLICATE KEY UPDATE
      <em class="replaceable"><code>col_name</code></em>=<em class="replaceable"><code>expr</code></em>
        [, <em class="replaceable"><code>col_name</code></em>=<em class="replaceable"><code>expr</code></em>] ... ]
</pre><p>
      <code class="literal">INSERT</code> は、既存のテーブルに新しい行を挿入します。このステートメントの <code class="literal">INSERT ... VALUES</code> および <code class="literal">INSERT ... SET</code> 形式は、明示的に指定された値に基づいて行を挿入します。<code class="literal">INSERT ... SELECT</code> 形式は、別の 1 つまたは複数のテーブルから選択された行を挿入します。<code class="literal">INSERT ... SELECT</code> については、<a class="xref" href="sql-syntax.html#insert-select" title="13.2.5.1 INSERT ... SELECT 構文">セクション13.2.5.1「INSERT ... SELECT 構文」</a>でさらに詳細に説明されています。
    </p><p>
      MySQL 5.6.2 以降では、パーティション化されたテーブルに挿入する場合、どのパーティションおよびサブパーティションが新しい行を受け入れるかを制御できます。<code class="literal">PARTITION</code> オプションは、テーブルの 1 つ以上のパーティションまたはサブパーティション (またはその両方) の名前のカンマ区切りリストを受け取ります。特定の <code class="literal">INSERT</code> ステートメントによって挿入される行がリストされているいずれかのパーティションに一致しない場合、<code class="literal">INSERT</code> ステートメントは <span class="errortext">Found a row not matching the given partition set</span> エラーで失敗します。詳細および例については、<a class="xref" href="partitioning.html#partitioning-selection" title="19.5 パーティション選択">セクション19.5「パーティション選択」</a>を参照してください。
    </p><p>
      古い行を上書きするには、<code class="literal">INSERT</code> の代わりに <code class="literal">REPLACE</code> を使用できます。<code class="literal">REPLACE</code> は、古い行を複製する一意のキー値を含む新しい行の処理において <code class="literal">INSERT IGNORE</code> に相当するものです。新しい行は、破棄されるのではなく、古い行を置き換えるために使用されます。<a class="xref" href="sql-syntax.html#replace" title="13.2.8 REPLACE 構文">セクション13.2.8「REPLACE 構文」</a>を参照してください。
    </p><p>
      <em class="replaceable"><code>tbl_name</code></em> は、行が挿入されるテーブルです。このステートメントによって値が提供されるカラムは、次のように指定できます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          テーブル名のあとにカラム名のカンマ区切りリストを指定できます。この場合は、指定された各カラムの値を <code class="literal">VALUES</code> リストまたは <code class="literal">SELECT</code> ステートメントで指定する必要があります。
        </p></li><li class="listitem"><p>
          <code class="literal">INSERT ... VALUES</code> または <code class="literal">INSERT ... SELECT</code> にカラム名のリストを指定しない場合は、テーブル内のすべてのカラムの値を <code class="literal">VALUES</code> リストまたは <code class="literal">SELECT</code> ステートメントで指定する必要があります。テーブル内のカラムの順序がわからない場合は、<code class="literal">DESCRIBE <em class="replaceable"><code>tbl_name</code></em></code> を使用して見つけます。
        </p></li><li class="listitem"><p>
          <code class="literal">SET</code> 句は、カラム名を明示的に示します。
        </p></li></ul></div><p>
      カラム値は、次のいくつかの方法で指定できます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="indexterm" name="idm139979085520112"></a> 厳密な SQL モードで実行していない場合、値が明示的に指定されていないカラムはすべて、デフォルトの (明示的または暗黙的な) 値に設定されます。たとえば、テーブル内のすべてのカラムを指定していないカラムリストを指定した場合、指定されていないカラムはそのデフォルト値に設定されます。デフォルト値の割り当てについては、<a class="xref" href="data-types.html#data-type-defaults" title="11.6 データ型デフォルト値">セクション11.6「データ型デフォルト値」</a>で説明されています。<a class="xref" href="introduction.html#constraint-invalid-data" title="1.8.3.3 無効データの制約">セクション1.8.3.3「無効データの制約」</a>も参照してください。
        </p><p>
          デフォルト値が含まれていないすべてのカラムの値を明示的に指定しないかぎり、<code class="literal">INSERT</code> ステートメントでエラーが生成されるようにする場合は、厳密モードを使用するようにしてください。<a class="xref" href="server-administration.html#sql-mode" title="5.1.7 サーバー SQL モード">セクション5.1.7「サーバー SQL モード」</a>を参照してください。
        </p></li><li class="listitem"><p>
          カラムを明示的にそのデフォルト値に設定するには、キーワード <code class="literal">DEFAULT</code> を使用します。これにより、テーブル内の各カラムの値が含まれていない不完全な <code class="literal">VALUES</code> リストを書かなくても済むため、いくつかのカラムを除くすべてのカラムに値を割り当てる <code class="literal">INSERT</code> ステートメントの記述が容易になります。そうでない場合は、<code class="literal">VALUES</code> リスト内の各値に対応するカラム名のリストを書き出す必要があります。
        </p><p>
          また、特定のカラムのデフォルト値を生成する式で使用できるより一般的な形式として <code class="literal">DEFAULT(<em class="replaceable"><code>col_name</code></em>)</code> を使用することもできます。
        </p></li><li class="listitem"><p>
          カラムリストと <code class="literal">VALUES</code> リストの両方が空である場合、<code class="literal">INSERT</code> は、各カラムがそのデフォルト値に設定された行を作成します。
        </p><pre class="programlisting">
INSERT INTO <em class="replaceable"><code>tbl_name</code></em> () VALUES();
</pre><p>
          厳密モードでは、いずれかのカラムにデフォルト値が含まれていない場合、エラーが発生します。それ以外の場合、MySQL は、明示的に定義されたデフォルト値が含まれていないすべてのカラムに対して暗黙のデフォルト値を使用します。
        </p></li><li class="listitem"><p>
          式 <em class="replaceable"><code>expr</code></em> を指定して、カラム値を指定できます。これには、式の型がカラムの型に一致しない場合は型変換が行われる可能性があり、特定の値の変換によって、データ型に応じて異なる値が挿入されることがあります。たとえば、文字列 <code class="literal">'1999.0e-2'</code> を <code class="literal">INT</code>、<code class="literal">FLOAT</code>、<code class="literal">DECIMAL(10,6)</code>、または <code class="literal">YEAR</code> カラムに挿入すると、それぞれ、値 <code class="literal">1999</code>、<code class="literal">19.9921</code>、<code class="literal">19.992100</code>、および <code class="literal">1999</code> が挿入されます。<code class="literal">INT</code> および <code class="literal">YEAR</code> カラムに格納される値が <code class="literal">1999</code> である理由は、文字列から整数への変換では、その文字列の最初の、有効な整数または年と見なすことができる部分だけが調べられるためです。浮動小数点および固定小数点数カラムの場合、文字列から浮動小数点への変換では、文字列全体を有効な浮動小数点値と見なします。
        </p><p>
          式 <em class="replaceable"><code>expr</code></em> は、以前に値リスト内に設定された任意のカラムを参照できます。たとえば、次のステートメントは、<code class="literal">col2</code> の値が、前に割り当てられている <code class="literal">col1</code> を参照しているため実行可能です。
        </p><pre class="programlisting">
INSERT INTO <em class="replaceable"><code>tbl_name</code></em> (col1,col2) VALUES(15,col1*2);
</pre><p>
          ただし、次のステートメントは、<code class="literal">col1</code> の値が、<code class="literal">col1</code> のあとに割り当てられている <code class="literal">col2</code> を参照しているため正当ではありません。
        </p><pre class="programlisting">
INSERT INTO <em class="replaceable"><code>tbl_name</code></em> (col1,col2) VALUES(col2*2,15);
</pre><p>
          1 つの例外として、<code class="literal">AUTO_INCREMENT</code> 値を含むカラムがあります。<code class="literal">AUTO_INCREMENT</code> 値はほかの値の割り当てのあとに生成されるため、割り当て内の <code class="literal">AUTO_INCREMENT</code> カラムへの参照はすべて <code class="literal">0</code> を返します。
        </p></li></ul></div><p>
      <code class="literal">VALUES</code> 構文を使用する <code class="literal">INSERT</code> ステートメントは複数の行を挿入できます。これを行うには、それぞれが括弧で囲まれ、カンマで区切られた、カラム値の複数のリストを含めます。例:
    </p><pre class="programlisting">
INSERT INTO <em class="replaceable"><code>tbl_name</code></em> (a,b,c) VALUES(1,2,3),(4,5,6),(7,8,9);
</pre><p>
      各行の値リストは、括弧で囲まれている必要があります。次のステートメントは、リスト内の値の数がカラム名の数に一致しないため不正です。
    </p><pre class="programlisting">
INSERT INTO <em class="replaceable"><code>tbl_name</code></em> (a,b,c) VALUES(1,2,3,4,5,6,7,8,9);
</pre><p>
      このコンテキストでは、<code class="literal">VALUE</code> は <code class="literal">VALUES</code> のシノニムです。どちらも、値リストの数については何も示しておらず、値リストが 1 つの場合でも複数の場合でも使用できます。
    </p><p>
      <code class="literal">INSERT</code> に関して影響を受けた行の値は、<code class="literal">ROW_COUNT()</code> 関数 (<a class="xref" href="functions.html#information-functions" title="12.14 情報関数">セクション12.14「情報関数」</a>を参照してください) または <code class="literal">mysql_affected_rows()</code> C API 関数 (<a class="xref" href="connectors-apis.html#mysql-affected-rows" title="23.8.7.1 mysql_affected_rows()">セクション23.8.7.1「mysql_affected_rows()」</a>を参照してください) を使用して取得できます。
    </p><p>
      <code class="literal">INSERT ... VALUES</code> ステートメントを複数の値リストまたは <code class="literal">INSERT ... SELECT</code> とともに使用した場合、このステートメントは、次の形式の情報文字列を返します。
    </p><pre class="programlisting">
Records: 100 Duplicates: 0 Warnings: 0
</pre><p>
      <code class="literal">Records</code> は、このステートメントによって処理された行数を示します。(これは、<code class="literal">Duplicates</code> が 0 以外であることがあるため、必ずしも実際に挿入された行数ではありません。)<code class="literal">Duplicates</code> は、何らかの既存の一意のインデックス値を複製しているために挿入できなかった行数を示します。<code class="literal">Warnings</code> は、何らかの点で問題があったカラム値を挿入するための試行回数を示します。警告は、次のいずれかの条件で発生する場合があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">NOT NULL</code> として宣言されているカラムへの <code class="literal">NULL</code> の挿入。複数行の <code class="literal">INSERT</code> ステートメントまたは <code class="literal">INSERT INTO ... SELECT</code> ステートメントの場合、このカラムは、そのカラムデータ型の暗黙のデフォルト値に設定されます。これは、数値型では <code class="literal">0</code>、文字列型では空の文字列 (<code class="literal">''</code>)、および日付と時間型では<span class="quote">「<span class="quote">0</span>」</span>の値です。サーバーは <code class="literal">SELECT</code> からの結果セットを検査して、それが単一行を返すかどうかを確認しないため、<code class="literal">INSERT INTO ... SELECT</code> ステートメントは複数行の挿入と同じ方法で処理されます。(単一行の <code class="literal">INSERT</code> の場合は、<code class="literal">NULL</code> が <code class="literal">NOT NULL</code> カラムに挿入されても警告は発生しません。代わりに、このステートメントがエラーで失敗します。)
        </p></li><li class="listitem"><p>
          数値カラムの、そのカラムの範囲外にある値への設定。この値は、その範囲のもっとも近い端点にクリップされます。
        </p></li><li class="listitem"><p>
          数値カラムへの <code class="literal">'10.34 a'</code> などの値の割り当て。後続の非数値のテキストは取り除かれ、残りの数値部分が挿入されます。文字列値に先頭の数値部分が含まれていない場合、このカラムは <code class="literal">0</code> に設定されます。
        </p></li><li class="listitem"><p>
          文字列カラム (<code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、<code class="literal">TEXT</code>、または <code class="literal">BLOB</code>) への、そのカラムの最大長を超える文字列の挿入。この値は、そのカラムの最大長に切り捨てられます。
        </p></li><li class="listitem"><p>
          日付または時間カラムへの、そのデータ型として不正な値の挿入。このカラムは、その型の適切な 0 の値に設定されます。
        </p></li></ul></div><a class="indexterm" name="idm139979085433696"></a><p>
      C API を使用している場合は、<code class="literal">mysql_info()</code> 関数を呼び出すことによって情報文字列を取得できます。<a class="xref" href="connectors-apis.html#mysql-info" title="23.8.7.35 mysql_info()">セクション23.8.7.35「mysql_info()」</a>を参照してください。
    </p><a class="indexterm" name="idm139979085430000"></a><a class="indexterm" name="idm139979085428688"></a><p>
      <code class="literal">INSERT</code> で <code class="literal">AUTO_INCREMENT</code> カラムを含むテーブルに行を挿入した場合、そのカラムに使用された値は SQL の <code class="literal">LAST_INSERT_ID()</code> 関数を使用して検索できます。C API 内からは、<code class="literal">mysql_insert_id()</code> 関数を使用します。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        これらの 2 つの関数が、必ずしも同じ動作を行うとは限りません。<code class="literal">AUTO_INCREMENT</code> カラムに関連した <code class="literal">INSERT</code> ステートメントの動作については、<a class="xref" href="functions.html#information-functions" title="12.14 情報関数">セクション12.14「情報関数」</a>および<a class="xref" href="connectors-apis.html#mysql-insert-id" title="23.8.7.37 mysql_insert_id()">セクション23.8.7.37「mysql_insert_id()」</a>でさらに詳細に説明されています。
      </p></div><p>
      <code class="literal">INSERT</code> ステートメントは、次の修飾子をサポートします。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">DELAYED</code> キーワードを使用した場合は、挿入される 1 つまたは複数の行をサーバーがバッファーに配置するため、<code class="literal">INSERT DELAYED</code> ステートメントを発行しているクライアントはただちに続行できます。そのテーブルが使用中である場合、サーバーはそれらの行を保持します。そのテーブルが未使用である場合、サーバーは行の挿入を開始する一方、そのテーブルに対する新しい読み取り要求が存在するかどうかを定期的にチェックします。存在する場合は、そのテーブルがふたたび未使用になるまで、遅延された行のキューは中断されます。<a class="xref" href="sql-syntax.html#insert-delayed" title="13.2.5.2 INSERT DELAYED 構文">セクション13.2.5.2「INSERT DELAYED 構文」</a>を参照してください。
        </p><a class="indexterm" name="idm139979085413024"></a><p>
          <code class="literal">DELAYED</code> は、<code class="literal">INSERT ... SELECT</code> または <code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> では無視されます。
        </p><a class="indexterm" name="idm139979085407296"></a><a class="indexterm" name="idm139979085405120"></a><p>
          <code class="literal">DELAYED</code> はまた、テーブルやトリガーにアクセスする関数を使用しているか、または関数やトリガーから呼び出された <code class="literal">INSERT</code> でも無視されます。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            MySQL 5.6.6 現在、<code class="literal">INSERT DELAYED</code> は非推奨であり、将来のリリースで削除されます。代わりに <code class="literal">INSERT</code> (<code class="literal">DELAYED</code> を付けない) を使用してください。
          </p></div></li><li class="listitem"><p>
          <code class="literal">LOW_PRIORITY</code> キーワードを使用した場合、<code class="literal">INSERT</code> の実行は、ほかのどのクライアントもそのテーブルから読み取らなくなるまで遅延されます。これには、既存のクライアントが読み取っている間や、<code class="literal">INSERT LOW_PRIORITY</code> ステートメントが待機している間に読み取りを開始したほかのクライアントが含まれます。そのため、読み取り負荷の高い環境では、<code class="literal">INSERT LOW_PRIORITY</code> ステートメントを発行したクライアントが非常に長い時間 (場合によっては無期限に) 待機することになるおそれがあります。(これは、クライアントをただちに続行できるようにする <code class="literal">INSERT DELAYED</code> とは対照的です。)<code class="literal">MyISAM</code> テーブルで <code class="literal">LOW_PRIORITY</code> を使用すると、並列挿入が無効になるため、通常はこれを行わないようにしてください。<a class="xref" href="optimization.html#concurrent-inserts" title="8.10.3 同時挿入">セクション8.10.3「同時挿入」</a>を参照してください。
        </p><p>
          <code class="literal">HIGH_PRIORITY</code> を指定すると、サーバーが <code class="option">--low-priority-updates</code> オプションで起動されている場合に、その効果がオーバーライドされます。また、同時挿入も使用されなくなります。<a class="xref" href="optimization.html#concurrent-inserts" title="8.10.3 同時挿入">セクション8.10.3「同時挿入」</a>を参照してください。
        </p><p>
          <code class="literal">LOW_PRIORITY</code> と <code class="literal">HIGH_PRIORITY</code> は、テーブルレベルのロックのみを使用するストレージエンジン (<code class="literal">MyISAM</code>、<code class="literal">MEMORY</code>、<code class="literal">MERGE</code> など) にのみ影響を与えます。
        </p></li><li class="listitem"><p>
          <code class="literal">IGNORE</code> キーワードを使用した場合、<code class="literal">INSERT</code> ステートメントの実行中に発生したエラーは無視されます。たとえば、<code class="literal">IGNORE</code> を使用しない場合は、テーブル内の既存の <code class="literal">UNIQUE</code> インデックスまたは <code class="literal">PRIMARY KEY</code> 値を複製する行によって重複キーエラーが発生し、このステートメントは中止されます。<code class="literal">IGNORE</code> を指定すると、その行が破棄され、エラーは発生しません。代わりに、無視されたエラーが警告を生成する可能性がありますが、重複キーエラーは生成しません。
        </p><p>
          <a class="indexterm" name="idm139979085374896"></a> <code class="literal">IGNORE</code> には、特定の値に一致するパーティションが見つからないパーティション化されたテーブルへの挿入でも同様の効果があります。<code class="literal">IGNORE</code> を指定しない場合、このような <code class="literal">INSERT</code> ステートメントはエラーで中止されます。ただし、<code class="literal">INSERT IGNORE</code> が使用されている場合は、一致しない値を含む行に対する挿入操作が暗黙のうちに失敗しますが、一致した行はすべて挿入されます。例については、<a class="xref" href="partitioning.html#partitioning-list" title="19.2.2 LIST パーティショニング">セクション19.2.2「LIST パーティショニング」</a>を参照してください。
        </p><p>
          <code class="literal">IGNORE</code> が指定されていない場合は、エラーをトリガーするデータ変換によってステートメントが中止されます。<code class="literal">IGNORE</code> を指定すると、無効な値はもっとも近い値に調整されて挿入されます。警告は生成されますが、ステートメントは中止されません。<code class="literal">mysql_info()</code> C API 関数を使用すると、テーブルに実際に挿入された行数を確認できます。
        </p></li><li class="listitem"><p>
          <code class="literal">ON DUPLICATE KEY UPDATE</code> を指定したとき、<code class="literal">UNIQUE</code> インデックスまたは <code class="literal">PRIMARY KEY</code> に重複した値を発生させる行が挿入された場合は、古い行の <code class="literal">UPDATE</code> が実行されます。行ごとの影響を受けた行の値は、その行が新しい行として挿入された場合は 1、既存の行が更新された場合は 2、既存の行がその現在の値に設定された場合は 0 です。<span class="command"><strong>mysqld</strong></span> への接続時に <code class="literal">CLIENT_FOUND_ROWS</code> フラグを <code class="literal">mysql_real_connect()</code> に指定すると、既存の行がその現在の値に設定された場合の影響を受けた行の値は (0 ではなく) 1 になります。<a class="xref" href="sql-syntax.html#insert-on-duplicate" title="13.2.5.3 INSERT ... ON DUPLICATE KEY UPDATE 構文">セクション13.2.5.3「INSERT ... ON DUPLICATE KEY UPDATE 構文」</a>を参照してください。
        </p></li></ul></div><p>
      テーブルに挿入するには、そのテーブルに対する <code class="literal">INSERT</code> 権限が必要です。<code class="literal">ON DUPLICATE KEY UPDATE</code> 句が使用されていて、重複キーのために代わりに <code class="literal">UPDATE</code> が実行される場合、このステートメントには、更新されるカラムに対する <code class="literal">UPDATE</code> 権限が必要です。読み取られるが、変更されないカラムの場合は、<code class="literal">SELECT</code> 権限のみが必要です (<code class="literal">ON DUPLICATE KEY UPDATE</code> 句にある <em class="replaceable"><code>col_name</code></em>=<em class="replaceable"><code>expr</code></em> 割り当ての右側でのみ参照されるカラムの場合など)。
    </p><p>
      MySQL 5.6.6 より前は、テーブルレベルのロックを採用した <code class="literal">MyISAM</code> などのストレージエンジンを使用しているパーティション化されたテーブルに影響を与える <code class="literal">INSERT</code> によって、そのテーブルのすべてのパーティションがロックされました。これは、<code class="literal">INSERT ... PARTITION</code> ステートメントにも当てはまりました。(これは、行レベルロックを採用した <code class="literal">InnoDB</code> などのストレージエンジンでは発生しておらず、現在も発生しません。)MySQL 5.6.6 以降では、MySQL はパーティションロックプルーニングを使用します。これにより、行が挿入されるパーティションだけが実際にロックされるようになります。詳細は、<a class="xref" href="partitioning.html#partitioning-limitations-locking" title="19.6.4 パーティショニングとロック">セクション19.6.4「パーティショニングとロック」</a>を参照してください。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="insert-select"></a>13.2.5.1 INSERT ... SELECT 構文</h4></div></div></div><a class="indexterm" name="idm139979085340704"></a><pre class="programlisting">
INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]
    [INTO] <em class="replaceable"><code>tbl_name</code></em> 
    [PARTITION (<em class="replaceable"><code>partition_name</code></em>,...)]
    [(<em class="replaceable"><code>col_name</code></em>,...)]
    SELECT ...
    [ ON DUPLICATE KEY UPDATE <em class="replaceable"><code>col_name</code></em>=<em class="replaceable"><code>expr</code></em>, ... ]
</pre><p>
        <code class="literal">INSERT ... SELECT</code> を使用すると、1 つまたは多数のテーブルから多数の行をテーブルにすばやく挿入できます。例:
      </p><pre class="programlisting">
INSERT INTO tbl_temp2 (fld_id)
  SELECT tbl_temp1.fld_order_id
  FROM tbl_temp1 WHERE tbl_temp1.fld_order_id &gt; 100;
</pre><p>
        <code class="literal">INSERT ... SELECT</code> ステートメントには、次の条件が適用されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            重複キー違反の原因になる行を無視するには、<code class="literal">IGNORE</code> を指定します。
          </p></li><li class="listitem"><p>
            <code class="literal">DELAYED</code> は、<code class="literal">INSERT ... SELECT</code> では無視されます。
          </p></li><li class="listitem"><p>
            <code class="literal">INSERT</code> ステートメントのターゲットテーブルが、クエリーの <code class="literal">SELECT</code> 部分の <code class="literal">FROM</code> 句に現れてもかまいません。(これは、一部の古いバージョンの MySQL では不可能でした。)ただし、テーブルに挿入し、さらにサブクエリーで同じテーブルから選択することはできません。
          </p><p>
            テーブルからの選択とそのテーブルへの挿入を同時に行う場合、MySQL は <code class="literal">SELECT</code> からの行を保持するための一時テーブルを作成してから、それらの行をターゲットテーブルに挿入します。ただし、<code class="literal">TEMPORARY</code> テーブルを同じステートメント内で 2 回参照することはできないため、<code class="literal">t</code> が <code class="literal">TEMPORARY</code> テーブルのときに <code class="literal">INSERT INTO t ... SELECT ... FROM t</code> を使用できない点は引き続き残ります (<a class="xref" href="error-handling.html#temporary-table-problems" title="B.5.7.2 TEMPORARY テーブルに関する問題">セクションB.5.7.2「TEMPORARY テーブルに関する問題」</a>を参照してください)。
          </p></li><li class="listitem"><p>
            <code class="literal">AUTO_INCREMENT</code> カラムは、通常どおりに機能します。
          </p></li><li class="listitem"><p>
            バイナリログを使用して元のテーブルを確実に再作成できるようにするために、MySQL では、<code class="literal">INSERT ... SELECT</code> ステートメントでの並列挿入が許可されません。
          </p></li><li class="listitem"><p>
            <code class="literal">SELECT</code> と <code class="literal">INSERT</code> が同じテーブルを参照している場合のあいまいなカラム参照の問題を回避するには、<code class="literal">SELECT</code> 部分で使用されている各テーブルの一意のエイリアスを指定し、その部分にあるカラム名を適切なエイリアスで修飾します。
          </p></li></ul></div><p>
        MySQL 5.6.2 からは、テーブルの名前に続く <code class="literal">PARTITION</code> オプションでソースまたはターゲットテーブル (またはその両方) のどのパーティションまたはサブパーティション (またはその両方) を使用するかを明示的に選択できます。<code class="literal">PARTITION</code> がこのステートメントの <code class="literal">SELECT</code> 部分にあるソーステーブルの名前とともに使用されている場合は、そのパーティションリストで指定されているパーティションまたはサブパーティションの行のみが選択されます。<code class="literal">PARTITION</code> がこのステートメントの <code class="literal">INSERT</code> 部分のターゲットテーブルの名前とともに使用されている場合は、選択されたすべての行を、このオプションに続くパーティションリストで指定されているパーティションまたはサブパーティションに挿入できる必要があります。そうでない場合、<code class="literal">INSERT ... SELECT</code> ステートメントは失敗します。詳細および例については、<a class="xref" href="partitioning.html#partitioning-selection" title="19.5 パーティション選択">セクション19.5「パーティション選択」</a>を参照してください。
      </p><p>
        <code class="literal">ON DUPLICATE KEY UPDATE</code> の値の部分では、<code class="literal">SELECT</code> 部分で <code class="literal">GROUP BY</code> を使用していないかぎり、ほかのテーブル内のカラムを参照できます。1 つの副作用として、値の部分にある一意でないカラム名を修飾しなければならない点があります。
      </p><p>
        <code class="literal">ORDER BY</code> 句のない <code class="literal">SELECT</code> ステートメントが行を返す順序は特定されていません。つまり、レプリケーションを使用している場合、このような <code class="literal">SELECT</code> がマスターとスレーブ上で行を同じ順序で返す保証はありません。これにより、マスターとスレーブの間で不整合が発生する場合があります。これが発生しないようにするために、レプリケートされる <code class="literal">INSERT ... SELECT</code> ステートメントは常に <code class="literal">INSERT ... SELECT ... ORDER BY <em class="replaceable"><code>column</code></em></code> として記述するようにしてください。<em class="replaceable"><code>column</code></em> の選択は、マスターとスレーブの両方で間違いなく行が同じ順序で返されるかぎり問題にはなりません。<a class="xref" href="replication.html#replication-features-limit" title="17.4.1.16 レプリケーションと LIMIT">セクション17.4.1.16「レプリケーションと LIMIT」</a>も参照してください。
      </p><p>
        この問題のために、MySQL 5.6.4 から、<code class="literal">INSERT ... SELECT ON DUPLICATE KEY UPDATE</code> および <code class="literal">INSERT IGNORE ... SELECT</code> ステートメントには、ステートメントベースのレプリケーションには安全でないというフラグが付けられます。この変更により、このようなステートメントは、ステートメントベースモードを使用しているときはログ内に警告を生成し、<code class="literal">MIXED</code> モードを使用しているときは行ベース形式を使用してログに記録されます。(Bug #11758262、Bug #50439)
      </p><p>
        <a class="xref" href="replication.html#replication-sbr-rbr" title="17.1.2.1 ステートメントベースおよび行ベースレプリケーションのメリットとデメリット">セクション17.1.2.1「ステートメントベースおよび行ベースレプリケーションのメリットとデメリット」</a>も参照してください。
      </p><p>
        MySQL 5.6.6 より前は、テーブルレベルのロックを採用した <code class="literal">MyISAM</code> などのストレージエンジンを使用しているパーティション化されたテーブルに対して機能した <code class="literal">INSERT ... SELECT</code> ステートメントによって、ソースおよびターゲットテーブルのすべてのパーティションがロックされました。(これは、行レベルロックを採用した <code class="literal">InnoDB</code> などのストレージエンジンを使用しているテーブルでは発生しておらず、現在も発生しません。)MySQL 5.6.6 以降では、ターゲットテーブルのすべてのパーティションがロックされますが、ソーステーブルは実際に読み取られたパーティションのみがロックされます。詳細は、<a class="xref" href="partitioning.html#partitioning-limitations-locking" title="19.6.4 パーティショニングとロック">セクション19.6.4「パーティショニングとロック」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="insert-delayed"></a>13.2.5.2 INSERT DELAYED 構文</h4></div></div></div><a class="indexterm" name="idm139979085274928"></a><a class="indexterm" name="idm139979085273616"></a><a class="indexterm" name="idm139979085272272"></a><pre class="programlisting">
INSERT DELAYED ...
</pre><p>
        <code class="literal">INSERT</code> ステートメントの <code class="literal">DELAYED</code> オプションは、特定の種類のテーブル (<code class="literal">MyISAM</code> など) に使用できる、標準 SQL への MySQL 拡張です。クライアントが <code class="literal">INSERT DELAYED</code> を使用すると、サーバーからはただちに了解が得られ、行は、そのテーブルがほかのどのスレッドによっても使用されていないときに挿入されるようにキューに入れられます。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">INSERT DELAYED</code> は、そのテーブルがほかで使用されていなければ、通常の <code class="literal">INSERT</code> より低速です。また、サーバーが、遅延された行が存在するテーブルごとに個別のスレッドを処理するための追加のオーバーヘッドもあります。つまり、<code class="literal">INSERT DELAYED</code> は、それが必要なことを実際に確信している場合にのみ使用するようにしてください。
        </p><p>
          MySQL 5.6.6 現在、<code class="literal">INSERT DELAYED</code> は非推奨であり、将来のリリースで削除されます。代わりに <code class="literal">INSERT</code> (<code class="literal">DELAYED</code> を付けない) を使用してください。
        </p></div><p>
        キューに入れられた行は、テーブルに挿入されるまで、メモリー内にのみ保持されます。つまり、<span class="command"><strong>mysqld</strong></span> を強制的に (たとえば、<code class="literal">kill -9</code> で) 終了した場合や、<span class="command"><strong>mysqld</strong></span> が予期せず終了した場合は、<span class="emphasis"><em>まだディスクに書き込まれていないキューに入れられたすべての行が失われます</em></span>。
      </p><p>
        <code class="literal">DELAYED</code> の使用には、次のいくつかの制約があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">INSERT DELAYED</code> は、<code class="literal">MyISAM</code>、<code class="literal">MEMORY</code>、<code class="literal">ARCHIVE</code>、および <code class="literal">BLACKHOLE</code> テーブルでのみ機能します。<code class="literal">DELAYED</code> をサポートしていないエンジンの場合は、エラーが発生します。
          </p></li><li class="listitem"><p>
            挿入は、ロックを保持するセッションではなく、別のスレッドによって処理される必要があるため、<code class="literal">LOCK TABLES</code> を使用してロックされたテーブルで使用された場合は、<code class="literal">INSERT DELAYED</code> に対してエラーが発生します。
          </p></li><li class="listitem"><p>
            <code class="literal">MyISAM</code> テーブルでは、データファイルの途中に空きブロックが存在しない場合は、並列 <code class="literal">SELECT</code> および <code class="literal">INSERT</code> ステートメントがサポートされます。これらの状況では、<code class="literal">MyISAM</code> で <code class="literal">INSERT DELAYED</code> を使用する必要はほとんどありません。
          </p></li><li class="listitem"><p>
            <code class="literal">INSERT DELAYED</code> は、値リストを指定する <code class="literal">INSERT</code> ステートメントでのみ使用するようにしてください。サーバーは、<code class="literal">INSERT ... SELECT</code> または <code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> ステートメントでの <code class="literal">DELAYED</code> を無視します。
          </p></li><li class="listitem"><p>
            <code class="literal">INSERT DELAYED</code> ステートメントはただちに復帰するため、行が挿入される前に、<code class="literal">LAST_INSERT_ID()</code> を使用して、このステートメントによって生成される可能性のある <code class="literal">AUTO_INCREMENT</code> 値を取得することはできません。
          </p></li><li class="listitem"><p>
            <code class="literal">DELAYED</code> 行は、実際に挿入されるまで、<code class="literal">SELECT</code> ステートメントには表示されません。
          </p></li><li class="listitem"><p>
            MySQL 5.6 より前は、ステートメントが複数の行を挿入し、バイナリロギングが有効になっており、かつグローバルロギング形式がステートメントベースである (つまり、<code class="literal">binlog_format</code> が <code class="literal">STATEMENT</code> に設定されているときは必ず) 場合、<code class="literal">INSERT DELAYED</code> は通常の <code class="literal">INSERT</code> として処理されました。MySQL 5.6 からは、<code class="literal">binlog_format</code> の値が <code class="literal">STATEMENT</code> または <code class="literal">MIXED</code> である場合は必ず、<code class="literal">INSERT DELAYED</code> は常に、単純な (つまり、<code class="literal">DELAYED</code> オプションのない) <code class="literal">INSERT</code> として処理されます。(後者の場合、このステートメントは行ベースのロギングへの切り替えをトリガーしなくなったため、そのステートメントベースの形式を使用してログに記録されます。)
          </p><p>
            これは、行ベースのバイナリロギングモードを使用している (<code class="literal">binlog_format</code> が <code class="literal">ROW</code> に設定されている) 場合は適用されません。この場合、<code class="literal">INSERT DELAYED</code> ステートメントは常に、指定のとおりに <code class="literal">DELAYED</code> オプションを使用して実行され、行更新イベントとしてログに記録されます。
          </p></li><li class="listitem"><p>
            <code class="literal">INSERT DELAYED</code> がスレーブ上で通常の <code class="literal">INSERT</code> として処理されるように、<code class="literal">DELAYED</code> はスレーブレプリケーションサーバー上で無視されます。これは、<code class="literal">DELAYED</code> のために、スレーブにマスターとは異なるデータが存在することになる場合があるためです。
          </p></li><li class="listitem"><p>
            テーブルが書き込みロックされているときに、そのテーブル構造を変更するために <code class="literal">ALTER TABLE</code> が使用されると、保留中の <code class="literal">INSERT DELAYED</code> ステートメントは失われます。
          </p></li><li class="listitem"><p>
            <code class="literal">INSERT DELAYED</code> は、ビューではサポートされません。
          </p></li><li class="listitem"><p>
            <code class="literal">INSERT DELAYED</code> は、パーティション化されたテーブルではサポートされません。
          </p></li></ul></div><p>
        次に、<code class="literal">INSERT</code> または <code class="literal">REPLACE</code> に対して <code class="literal">DELAYED</code> オプションを使用したときの動作について詳細に説明します。この説明では、<span class="quote">「<span class="quote">スレッド</span>」</span>は <code class="literal">INSERT DELAYED</code> ステートメントを受信したスレッドであり、<span class="quote">「<span class="quote">ハンドラ</span>」</span>は、特定のテーブルに対するすべての <code class="literal">INSERT DELAYED</code> ステートメントを処理するスレッドです。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            スレッドがあるテーブルに対する <code class="literal">DELAYED</code> ステートメントを実行すると、そのテーブルに対するすべての <code class="literal">DELAYED</code> ステートメントを処理するためのハンドラスレッドが作成されます (このようなハンドラがまだ存在しない場合)。
          </p></li><li class="listitem"><p>
            このスレッドは、そのハンドラが以前に <code class="literal">DELAYED</code> ロックを取得したかどうかをチェックします。取得していない場合は、それを行うようハンドラスレッドに指示します。<code class="literal">DELAYED</code> ロックは、ほかのスレッドがそのテーブルに対する <code class="literal">READ</code> または <code class="literal">WRITE</code> ロックを保持している場合でも取得できます。ただし、ハンドラはテーブル構造を確実に最新の状態にするために、すべての <code class="literal">ALTER TABLE</code> ロックまたは <code class="literal">FLUSH TABLES</code> ステートメントが完了するのを待機します。
          </p></li><li class="listitem"><p>
            このスレッドは <code class="literal">INSERT</code> ステートメントを実行しますが、行をテーブルに書き込む代わりに、最終行のコピーをそのハンドラスレッドによって管理されているキューに配置します。構文エラーはすべてスレッドによって検出され、クライアントプログラムにレポートされます。
          </p></li><li class="listitem"><p>
            <code class="literal">INSERT</code> は挿入操作が完了する前に復帰するため、クライアントは重複した行の数や、結果として得られる行の <code class="literal">AUTO_INCREMENT</code> 値をサーバーから取得できません。(C API を使用している場合も、同じ理由で、<code class="literal">mysql_info()</code> 関数は意味のある情報を何も返しません。)
          </p></li><li class="listitem"><p>
            バイナリログは、行がテーブルに挿入されたときにハンドラスレッドによって更新されます。複数行の挿入の場合、バイナリログは、先頭行が挿入されたときに更新されます。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979085170656"></a> <code class="literal">delayed_insert_limit</code> 行が書き込まれるたびに、ハンドラは、いずれかの <code class="literal">SELECT</code> ステートメントが引き続き保留中かどうかをチェックします。保留中の場合は、続行する前に、これらの実行を許可します。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979085166064"></a> ハンドラのキューにそれ以上行がなくなると、テーブルはロック解除されます。新しい <code class="literal">INSERT DELAYED</code> ステートメントが <code class="literal">delayed_insert_timeout</code> 秒以内に受信されなかった場合、ハンドラは終了します。
          </p></li><li class="listitem"><p>
            特定のハンドラキュー内で <code class="literal">delayed_queue_size</code> を超える行が保留中である場合、<code class="literal">INSERT DELAYED</code> を要求しているスレッドは、そのキューに空きができるまで待機します。これは、遅延されたメモリーキューのすべてのメモリーが <span class="command"><strong>mysqld</strong></span> によって使用されてしまわないようにするために行われます。
          </p></li><li class="listitem"><p>
            このハンドラスレッドは、MySQL プロセスリストの <code class="literal">Command</code> カラム内に <code class="literal">delayed_insert</code> として現れます。これは、<code class="literal">FLUSH TABLES</code> ステートメントを実行するか、または <code class="literal">KILL <em class="replaceable"><code>thread_id</code></em></code> で強制終了すると強制終了されます。ただし、終了する前に、まずキューに入れられたすべての行をテーブルに格納します。この時間中は、ほかのスレッドからの新しいどの <code class="literal">INSERT</code> ステートメントも受け入れません。このあとに <code class="literal">INSERT DELAYED</code> ステートメントを実行すると、新しいハンドラスレッドが作成されます。
          </p><p>
            つまり、実行中の <code class="literal">INSERT DELAYED</code> ハンドラが存在する場合、<code class="literal">INSERT DELAYED</code> ステートメントは通常の <code class="literal">INSERT</code> ステートメントより高い優先度を持っています。その他の更新ステートメントは、<code class="literal">INSERT DELAYED</code> キューが空になるか、だれかが (<code class="literal">KILL <em class="replaceable"><code>thread_id</code></em></code> で) このハンドラスレッドを終了するか、またはだれかが <code class="literal">FLUSH TABLES</code> を実行するまで待機する必要があります。
          </p></li><li class="listitem"><p>
            次のステータス変数は、<code class="literal">INSERT DELAYED</code> ステートメントに関する情報を提供します。
          </p><div class="informaltable"><table summary="この表は、INSERT DELAYED ステートメントのステータス変数を示し、それぞれの意味について説明しています。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">ステータス変数</th><th scope="col">意味</th></tr></thead><tbody><tr><td scope="row"><code class="literal">Delayed_insert_threads</code></td><td>ハンドラスレッドの数</td></tr><tr><td scope="row"><code class="literal">Delayed_writes</code></td><td><code class="literal">INSERT DELAYED</code> で書き込まれた行数</td></tr><tr><td scope="row"><code class="literal">Not_flushed_delayed_rows</code></td><td>書き込みを待機している行数</td></tr></tbody></table></div><p>
            これらの変数は、<code class="literal">SHOW STATUS</code> ステートメントを発行するか、または <span class="command"><strong>mysqladmin extended-status</strong></span> コマンドを実行することによって表示できます。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="insert-on-duplicate"></a>13.2.5.3 INSERT ... ON DUPLICATE KEY UPDATE 構文</h4></div></div></div><p>
        <code class="literal">ON DUPLICATE KEY UPDATE</code> を指定したとき、<code class="literal">UNIQUE</code> インデックスまたは <code class="literal">PRIMARY KEY</code> に重複した値を発生させる行が挿入された場合は、MySQL によって古い行の <code class="literal">UPDATE</code> が実行されます。たとえば、カラム <code class="literal">a</code> が <code class="literal">UNIQUE</code> として宣言され、値 <code class="literal">1</code> を含んでいる場合、次の 2 つのステートメントには同様の効果があります。
      </p><pre class="programlisting">
INSERT INTO table (a,b,c) VALUES (1,2,3)
  ON DUPLICATE KEY UPDATE c=c+1;

UPDATE table SET c=c+1 WHERE a=1;
</pre><p>
        (これらの効果は、<code class="literal">a</code> が自動インクリメントカラムである <code class="literal">InnoDB</code> テーブルに対して同じではありません。自動インクリメントカラムを使用した場合、<code class="literal">INSERT</code> ステートメントは自動インクリメント値を増やしますが、<code class="literal">UPDATE</code> は増やしません。)
      </p><p>
        <code class="literal">ON DUPLICATE KEY UPDATE</code> 句には、カンマで区切られた、複数のカラム割り当てを含めることができます。
      </p><p>
        <code class="literal">ON DUPLICATE KEY UPDATE</code> を使用した場合、行ごとの影響を受けた行の値は、その行が新しい行として挿入された場合は 1、既存の行が更新された場合は 2、既存の行がその現在の値に設定された場合は 0 です。<span class="command"><strong>mysqld</strong></span> への接続時に <code class="literal">CLIENT_FOUND_ROWS</code> フラグを <code class="literal">mysql_real_connect()</code> に指定すると、既存の行がその現在の値に設定された場合の影響を受けた行の値は (0 ではなく) 1 になります。
      </p><p>
        カラム <code class="literal">b</code> も一意である場合、<code class="literal">INSERT</code> は、代わりに次の <code class="literal">UPDATE</code> ステートメントと同等です。
      </p><pre class="programlisting">
UPDATE table SET c=c+1 WHERE a=1 OR b=2 LIMIT 1;
</pre><p>
        <code class="literal">a=1 OR b=2</code> が複数の行に一致する場合は、<span class="emphasis"><em>1 つ</em></span>の行だけが更新されます。一般に、一意のインデックスが複数含まれているテーブルに対して <code class="literal">ON DUPLICATE KEY UPDATE</code> 句を使用することは避けるようにしてください。
      </p><p>
        <code class="literal">UPDATE</code> 句で <code class="literal">VALUES(<em class="replaceable"><code>col_name</code></em>)</code> 関数を使用して、<code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> ステートメントの <code class="literal">INSERT</code> 部分からカラム値を参照できます。つまり、<code class="literal">ON DUPLICATE KEY UPDATE</code> 句にある <code class="literal">VALUES(<em class="replaceable"><code>col_name</code></em>)</code> は、重複キーの競合が発生していない場合に挿入される <em class="replaceable"><code>col_name</code></em> の値を参照します。この関数は、複数の行を挿入する際に特に役立ちます。<code class="literal">VALUES()</code> 関数は、<code class="literal">INSERT ... UPDATE</code> ステートメントの中でだけ意味を持ち、そうでなければ <code class="literal">NULL</code> を返します。例:
      </p><pre class="programlisting">
INSERT INTO table (a,b,c) VALUES (1,2,3),(4,5,6)
  ON DUPLICATE KEY UPDATE c=VALUES(a)+VALUES(b);
</pre><p>
        そのステートメントは、次の 2 つのステートメントと同一です。
      </p><pre class="programlisting">
INSERT INTO table (a,b,c) VALUES (1,2,3)
  ON DUPLICATE KEY UPDATE c=3;
INSERT INTO table (a,b,c) VALUES (4,5,6)
  ON DUPLICATE KEY UPDATE c=9;
</pre><p>
        テーブルに <code class="literal">AUTO_INCREMENT</code> カラムが含まれているときに、<code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> で行を挿入または更新した場合、<code class="literal">LAST_INSERT_ID()</code> 関数は <code class="literal">AUTO_INCREMENT</code> 値を返します。
      </p><p>
        <code class="literal">ON DUPLICATE KEY UPDATE</code> を使用している場合、<code class="literal">DELAYED</code> オプションは無視されます。
      </p><p>
        <code class="literal">INSERT ... SELECT</code> ステートメントの結果は <code class="literal">SELECT</code> からの行の順序に依存し、またこの順序を常に保証することはできないため、ロギング時に、<code class="literal">INSERT ... SELECT ON DUPLICATE KEY UPDATE</code> ステートメントがマスターとスレーブで異なる可能性があります。そのため、MySQL 5.6.4 以降では、<code class="literal">INSERT ... SELECT ON DUPLICATE KEY UPDATE</code> ステートメントには、ステートメントベースのレプリケーションには安全でないというフラグが付けられます。この変更により、このようなステートメントは、ステートメントベースモードを使用しているときはログ内に警告を生成し、<code class="literal">MIXED</code> モードを使用しているときは行ベース形式を使用してログに記録されます。さらに、MySQL 5.6.6 からは、一意のキーまたは主キーが複数含まれているテーブルに対する <code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> ステートメントも安全ではないとしてマークされます。(Bug #11765650、Bug #58637) <a class="xref" href="replication.html#replication-sbr-rbr" title="17.1.2.1 ステートメントベースおよび行ベースレプリケーションのメリットとデメリット">セクション17.1.2.1「ステートメントベースおよび行ベースレプリケーションのメリットとデメリット」</a>も参照してください。
      </p><p>
        MySQL 5.6.6 より前は、テーブルレベルのロックを採用した <code class="literal">MyISAM</code> などのストレージエンジンを使用しているパーティション化されたテーブルに対する <code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> によって、そのテーブルのすべてのパーティションがロックされました。(これは、行レベルロックを採用した <code class="literal">InnoDB</code> などのストレージエンジンを使用しているテーブルでは発生しておらず、現在も発生しません。)MySQL 5.6.6 以降では、このようなステートメントでは、パーティション化キーカラムが更新されたパーティションのみがロックされます。詳細は、<a class="xref" href="partitioning.html#partitioning-limitations-locking" title="19.6.4 パーティショニングとロック">セクション19.6.4「パーティショニングとロック」</a>を参照してください。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="load-data"></a>13.2.6 LOAD DATA INFILE 構文</h3></div></div></div><a class="indexterm" name="idm139979085066016"></a><a class="indexterm" name="idm139979085064704"></a><pre class="programlisting">
LOAD DATA [LOW_PRIORITY | CONCURRENT] [LOCAL] INFILE '<em class="replaceable"><code>file_name</code></em>'
    [REPLACE | IGNORE]
    INTO TABLE <em class="replaceable"><code>tbl_name</code></em>
    [PARTITION (<em class="replaceable"><code>partition_name</code></em>,...)]
    [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>]
    [{FIELDS | COLUMNS}
        [TERMINATED BY '<em class="replaceable"><code>string</code></em>']
        [[OPTIONALLY] ENCLOSED BY '<em class="replaceable"><code>char</code></em>']
        [ESCAPED BY '<em class="replaceable"><code>char</code></em>']
    ]
    [LINES
        [STARTING BY '<em class="replaceable"><code>string</code></em>']
        [TERMINATED BY '<em class="replaceable"><code>string</code></em>']
    ]
    [IGNORE <em class="replaceable"><code>number</code></em> {LINES | ROWS}]
    [(<em class="replaceable"><code>col_name_or_user_var</code></em>,...)]
    [SET <em class="replaceable"><code>col_name</code></em> = <em class="replaceable"><code>expr</code></em>,...]
</pre><p>
      <code class="literal">LOAD DATA INFILE</code> ステートメントは、非常に高速にテキストファイルからテーブルに行を読み取ります。<code class="literal">LOAD DATA INFILE</code> は、<code class="literal">SELECT ... INTO OUTFILE</code> を補完するものです。(<a class="xref" href="sql-syntax.html#select-into" title="13.2.9.1 SELECT ... INTO 構文">セクション13.2.9.1「SELECT ... INTO 構文」</a>を参照してください。)テーブルからファイルにデータを書き込むには、<code class="literal">SELECT ... INTO OUTFILE</code> を使用します。そのファイルをテーブルに読み戻すには、<code class="literal">LOAD DATA INFILE</code> を使用します。<code class="literal">FIELDS</code> および <code class="literal">LINES</code> 句の構文は、両方のステートメントで同じです。どちらの句もオプションですが、両方が指定される場合は、<code class="literal">FIELDS</code> を <code class="literal">LINES</code> の前に指定する必要があります。
    </p><a class="indexterm" name="idm139979085042096"></a><p>
      <span class="command"><strong>mysqlimport</strong></span> ユーティリティーを使用してデータファイルをロードすることもできます。これは、<code class="literal">LOAD DATA INFILE</code> ステートメントをサーバーに送信することによって動作します。<code class="option">--local</code> オプションを指定すると、<span class="command"><strong>mysqlimport</strong></span> は、クライアントホストからデータファイルを読み取ります。クライアントとサーバーが圧縮されたプロトコルをサポートしている場合は、<code class="option">--compress</code> オプションを指定すると、低速ネットワーク経由のパフォーマンスを向上させることができます。<a class="xref" href="programs.html#mysqlimport" title="4.5.5 mysqlimport — データインポートプログラム">セクション4.5.5「<span class="command"><strong>mysqlimport</strong></span> — データインポートプログラム」</a>を参照してください。
    </p><p>
      <code class="literal">INSERT</code> と <code class="literal">LOAD DATA INFILE</code> の効率の比較、および <code class="literal">LOAD DATA INFILE</code> の高速化の詳細は、<a class="xref" href="optimization.html#insert-speed" title="8.2.2.1 INSERT ステートメントの速度">セクション8.2.2.1「INSERT ステートメントの速度」</a>を参照してください。
    </p><p>
      ファイル名は、リテラル文字列として指定する必要があります。Windows では、パス名内のバックスラッシュをスラッシュまたは二重のバックスラッシュとして指定します。<code class="literal">character_set_filesystem</code> システム変数は、ファイル名の解釈を制御します。
    </p><p>
      MySQL 5.6.2 以降では、<code class="literal">LOAD DATA</code> は、パーティション、サブパーティション、またはその両方の 1 つ以上の名前のカンマ区切りリストを含む <code class="literal">PARTITION</code> オプションを使用した明示的なパーティション選択をサポートしています。このオプションが使用されているとき、リストで指定されているいずれかのパーティションまたはサブパーティションにファイルからの行を挿入できない場合、このステートメントは <span class="errortext">Found a row not matching the given partition set</span> エラーで失敗します。詳細は、<a class="xref" href="partitioning.html#partitioning-selection" title="19.5 パーティション選択">セクション19.5「パーティション選択」</a>を参照してください。
    </p><p>
      テーブルロックを採用したストレージエンジン (<code class="literal">MyISAM</code> など) を使用しているパーティション化されたテーブルの場合、<code class="literal">LOAD DATA</code> はどのパーティションロックも削除できません。これは、行レベルロックを採用したストレージエンジン (<code class="literal">InnoDB</code> など) を使用しているテーブルには適用されません。詳細は、<a class="xref" href="partitioning.html#partitioning-limitations-locking" title="19.6.4 パーティショニングとロック">セクション19.6.4「パーティショニングとロック」</a>を参照してください。
    </p><p>
      サーバーは、<code class="literal">character_set_database</code> システム変数によって示されている文字セットを使用してファイル内の情報を解釈します。<code class="literal">SET NAMES</code> や、<code class="literal">character_set_client</code> の設定は入力の解釈に影響を与えません。入力ファイルの内容にデフォルトとは異なる文字セットが使用されている場合は、通常、<code class="literal">CHARACTER SET</code> 句を使用してそのファイルの文字セットを指定することをお勧めします。<code class="literal">binary</code> の文字セットは、<span class="quote">「<span class="quote">変換なし</span>」</span>を指定します。
    </p><p>
      <code class="literal">LOAD DATA INFILE</code> は、フィールド値がロードされるカラムのデータ型には関係なく、ファイル内のすべてのフィールドに同じ文字セットが割り当てられていると解釈します。ファイルの内容が正しく解釈されるように、そのファイルが正しい文字セットで書き込まれていることを確認する必要があります。たとえば、<span class="command"><strong>mysqldump -T</strong></span> を使用して、または <span class="command"><strong>mysql</strong></span> で <code class="literal">SELECT ... INTO OUTFILE</code> ステートメントを発行することによってデータファイルを書き込む場合は、そのファイルが <code class="literal">LOAD DATA INFILE</code> でロードされるときに使用される文字セットで出力が書き込まれるように、必ず <code class="option">--default-character-set</code> オプションを使用してください。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">ucs2</code>、<code class="literal">utf16</code>、<code class="literal">utf16le</code>、または <code class="literal">utf32</code> 文字セットを使用するデータファイルはロードできません。
      </p></div><p>
      <code class="literal">LOW_PRIORITY</code> を使用した場合、<code class="literal">LOAD DATA</code> ステートメントの実行は、ほかのどのクライアントもそのテーブルから読み取らなくなるまで遅延されます。これは、テーブルレベルロックのみを使用するストレージエンジン (<code class="literal">MyISAM</code>、<code class="literal">MEMORY</code>、および <code class="literal">MERGE</code>) にのみ影響を与えます。
    </p><p>
      並列挿入の条件を満たす (つまり、途中に空きブロックが含まれていない) <code class="literal">MyISAM</code> テーブルで <code class="literal">CONCURRENT</code> を指定すると、ほかのスレッドは <code class="literal">LOAD DATA</code> の実行中にそのテーブルからデータを取得できます。このオプションは、そのテーブルがほかのスレッドから同時に使用されていない場合でも、<code class="literal">LOAD DATA</code> のパフォーマンスに少し影響を与えます。
    </p><p>
      行ベースのレプリケーションでは、<code class="literal">CONCURRENT</code> は MySQL バージョンにかかわらずレプリケートされます。ステートメントベースのレプリケーションでは、<code class="literal">CONCURRENT</code> は MySQL 5.5.1 より前ではレプリケートされません (Bug #34628 を参照してください)。詳細は、<a class="xref" href="replication.html#replication-features-load-data" title="17.4.1.17 レプリケーションと LOAD DATA INFILE">セクション17.4.1.17「レプリケーションと LOAD DATA INFILE」</a>を参照してください。
    </p><p>
      <code class="literal">LOCAL</code> キーワードは、あとで説明されているように、ファイルの予測される場所やエラー処理に影響を与えます。<code class="literal">LOCAL</code> は、サーバーとクライアントの両方がそれを許可するように構成されている場合にのみ機能します。たとえば、<span class="command"><strong>mysqld</strong></span> が <code class="literal">--local-infile=0</code> で起動された場合、<code class="literal">LOCAL</code> は機能しません。<a class="xref" href="security.html#load-data-local" title="6.1.6 LOAD DATA LOCAL のセキュリティーの問題">セクション6.1.6「LOAD DATA LOCAL のセキュリティーの問題」</a>を参照してください。
    </p><p>
      <code class="literal">LOCAL</code> キーワードは、ファイルが見つかることが予測される場所に影響を与えます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">LOCAL</code> が指定されている場合、ファイルはクライアントホスト上のクライアントプログラムによって読み取られ、サーバーに送信されます。このファイルは、その正確な場所を指定するためにフルパス名として指定できます。相対パス名として指定されている場合、その名前は、クライアントプログラムが起動されたディレクトリを基準にして解釈されます。
        </p><p>
          <code class="literal">LOCAL</code> を <code class="literal">LOAD DATA</code> とともに使用している場合は、そのファイルのコピーがサーバーの一時ディレクトリ内に作成されます。これは <code class="literal">tmpdir</code> または <code class="literal">slave_load_tmpdir</code> の値によって決定されるディレクトリ<span class="emphasis"><em>ではなく</em></span>、オペレーティングシステムの一時ディレクトリであり、MySQL Server では構成できません。(システムの一時ディレクトリは通常、Linux システムでは <code class="filename">/tmp</code>、Windows では <code class="filename">C:\WINDOWS\TEMP</code> です。)このディレクトリ内にコピーのための十分な領域がないと、<code class="literal">LOAD DATA LOCAL</code> ステートメントが失敗する場合があります。
        </p></li><li class="listitem"><p>
          <code class="literal">LOCAL</code> が指定されていない場合、ファイルはサーバーホスト上にある必要があり、直接サーバーによって読み取られます。サーバーは、次のルールを使用してファイルを見つけます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              ファイル名が絶対パス名である場合、サーバーはそれを指定されたとおりに使用します。
            </p></li><li class="listitem"><p>
              ファイル名が 1 つ以上の先行コンポーネントを含む相対パス名である場合、サーバーは、サーバーのデータディレクトリを基準にしてファイルを検索します。
            </p></li><li class="listitem"><p>
              先行コンポーネントを含まないファイル名が指定されている場合、サーバーは、デフォルトデータベースのデータベースディレクトリ内でそのファイルを探します。
            </p></li></ul></div></li></ul></div><p>
      <code class="literal">LOCAL</code> 以外のケースでは、これらのルールは、<code class="filename">./myfile.txt</code> という名前のファイルがサーバーのデータディレクトリから読み取られるのに対して、<code class="filename">myfile.txt</code> として指定されたファイルはデフォルトデータベースのデータベースディレクトリから読み取られることを示します。たとえば、<code class="literal">db1</code> がデフォルトデータベースである場合、次の <code class="literal">LOAD DATA</code> ステートメントは、このステートメントが明示的に <code class="literal">db2</code> データベース内のテーブルにファイルをロードしているにもかかわらず、<code class="literal">db1</code> のデータベースディレクトリからファイル <code class="filename">data.txt</code> を読み取ります。
    </p><pre class="programlisting">
LOAD DATA INFILE 'data.txt' INTO TABLE db2.my_table;
</pre><p>
      セキュリティー上の理由から、サーバー上にあるテキストファイルを読み取る場合、そのファイルはデータベースディレクトリ内に存在するか、またはすべてのユーザーから読み取り可能のどちらかである必要があります。また、サーバーファイルに対して <code class="literal">LOAD DATA INFILE</code> を使用するには、<code class="literal">FILE</code> 権限が必要です。<a class="xref" href="security.html#privileges-provided" title="6.2.1 MySQL で提供される権限">セクション6.2.1「MySQL で提供される権限」</a>を参照してください。<code class="literal">LOCAL</code> 以外のロード操作では、<code class="literal">secure_file_priv</code> システム変数が空以外のディレクトリ名に設定されている場合、ロードされるファイルはそのディレクトリ内に存在する必要があります。
    </p><p>
      <code class="literal">LOCAL</code> を使用すると、クライアントが接続を経由してファイルの内容をサーバーに送信する必要があるため、サーバーが直接ファイルにアクセスできるようにした場合より少し遅くなります。その一方で、ローカルファイルをロードするために <code class="literal">FILE</code> 権限は必要ありません。
    </p><p>
      <code class="literal">LOCAL</code> はまた、エラー処理にも影響を与えます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">LOAD DATA INFILE</code> では、データ解釈や重複キーのエラーによって操作が終了します。
        </p></li><li class="listitem"><p>
          <code class="literal">LOAD DATA LOCAL INFILE</code> では、操作の最中にファイルの転送を停止する方法がサーバーにはないため、データ解釈や重複キーのエラーは警告になり、操作は続行されます。重複キーエラーについては、これは <code class="literal">IGNORE</code> が指定されている場合と同じです。<code class="literal">IGNORE</code> については、このセクションのあとの方でさらに詳細に説明されています。
        </p></li></ul></div><p>
      <code class="literal">REPLACE</code> および <code class="literal">IGNORE</code> キーワードは、一意のキー値に関して既存の行を複製する入力行の処理を制御します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">REPLACE</code> を指定した場合は、入力行によって既存の行が置き換えられます。つまり、主キーまたは一意のインデックスに関して既存の行と同じ値を持つ行のことです。<a class="xref" href="sql-syntax.html#replace" title="13.2.8 REPLACE 構文">セクション13.2.8「REPLACE 構文」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">IGNORE</code> を指定した場合は、一意のキー値に関して既存の行を複製する行は破棄されます。
        </p></li><li class="listitem"><p>
          どちらのオプションも指定しない場合、その動作は <code class="literal">LOCAL</code> キーワードが指定されているかどうかによって異なります。<code class="literal">LOCAL</code> が指定されていない場合は、重複キー値が見つかるとエラーが発生し、テキストファイルの残りは無視されます。<code class="literal">LOCAL</code> が指定されている場合、デフォルトの動作は <code class="literal">IGNORE</code> が指定されている場合と同じです。これは、操作の最中にファイルの転送を停止する方法がサーバーにはないためです。
        </p></li></ul></div><p>
      ロード操作中に外部キー制約を無視するには、<code class="literal">LOAD DATA</code> を実行する前に <code class="literal">SET foreign_key_checks = 0</code> ステートメントを発行します。
    </p><p>
      空の <code class="literal">MyISAM</code> テーブルに対して <code class="literal">LOAD DATA INFILE</code> を使用した場合、一意でないインデックスはすべて (<code class="literal">REPAIR TABLE</code> として) 別のバッチに作成されます。通常、多くのインデックスがあるときは、この方法で <code class="literal">LOAD DATA INFILE</code> がはるかに早くなります。一部の極端なケースでは、ファイルをテーブルにロードする前に <code class="literal">ALTER TABLE ... DISABLE KEYS</code> でインデックスを無効にし、ファイルをロードしたあとに <code class="literal">ALTER TABLE ... ENABLE KEYS</code> を使用してインデックスを再作成することによって、インデックスをさらに高速に作成できます。<a class="xref" href="optimization.html#insert-speed" title="8.2.2.1 INSERT ステートメントの速度">セクション8.2.2.1「INSERT ステートメントの速度」</a>を参照してください。
    </p><p>
      <code class="literal">FIELDS</code> および <code class="literal">LINES</code> 句の構文は、<code class="literal">LOAD DATA INFILE</code> と <code class="literal">SELECT ... INTO OUTFILE</code> の両方のステートメントで同じです。どちらの句もオプションですが、両方が指定される場合は、<code class="literal">FIELDS</code> を <code class="literal">LINES</code> の前に指定する必要があります。
    </p><p>
      <code class="literal">FIELDS</code> 句を指定する場合は、その各サブ句 (<code class="literal">TERMINATED BY</code>、<code class="literal">[OPTIONALLY] ENCLOSED BY</code>、および <code class="literal">ESCAPED BY</code>) もオプションです。ただし、そのうちの少なくとも 1 つを指定する必要があります。
    </p><p>
      <code class="literal">FIELDS</code> または <code class="literal">LINES</code> 句を指定しない場合、そのデフォルトは、次を記述した場合と同じです。
    </p><pre class="programlisting">
FIELDS TERMINATED BY '\t' ENCLOSED BY '' ESCAPED BY '\\'
LINES TERMINATED BY '\n' STARTING BY ''
</pre><p>
      (バックスラッシュは SQL ステートメントの文字列内の MySQL のエスケープ文字であるため、リテラルバックスラッシュを指定するには、1 つのバックスラッシュとして解釈される値に対して 2 つのバックスラッシュを指定する必要があります。エスケープシーケンス <code class="literal">'\t'</code> と <code class="literal">'\n'</code> は、それぞれタブと改行文字を指定します。)
    </p><p>
      つまり、デフォルトでは、入力を読み取るとき <code class="literal">LOAD DATA INFILE</code> は次のように機能します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          改行の位置にある行の境界を探します。
        </p></li><li class="listitem"><p>
          どの行プリフィクスもスキップしません。
        </p></li><li class="listitem"><p>
          タブの位置で行をフィールドに分割します。
        </p></li><li class="listitem"><p>
          フィールドが引用文字で囲まれていることを期待しません。
        </p></li><li class="listitem"><p>
          前にエスケープ文字<span class="quote">「<span class="quote"><code class="literal">\</code></span>」</span>がある文字をエスケープシーケンスとして解釈します。たとえば、<span class="quote">「<span class="quote"><code class="literal">\t</code></span>」</span>、<span class="quote">「<span class="quote"><code class="literal">\n</code></span>」</span>、および<span class="quote">「<span class="quote"><code class="literal">\\</code></span>」</span>はそれぞれ、タブ、改行、およびバックスラッシュを示します。エスケープシーケンスの完全なリストについては、あとの <code class="literal">FIELDS ESCAPED BY</code> の説明を参照してください。
        </p></li></ul></div><p>
      逆に、デフォルトでは、出力を書き込むとき <code class="literal">SELECT ... INTO OUTFILE</code> は次のように機能します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          フィールド間にタブを書き込みます。
        </p></li><li class="listitem"><p>
          フィールドを引用文字で囲みません。
        </p></li><li class="listitem"><p>
          <span class="quote">「<span class="quote"><code class="literal">\</code></span>」</span>を使用して、フィールド値の中に現れるタブ、改行、または<span class="quote">「<span class="quote"><code class="literal">\</code></span>」</span>のインスタンスをエスケープします。
        </p></li><li class="listitem"><p>
          行の最後に改行を書き込みます。
        </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        Windows システム上でテキストファイルを生成した場合、Windows プログラムは通常、行ターミネータとして 2 文字を使用するため、そのファイルを正しく読み取るには <code class="literal">LINES TERMINATED BY '\r\n'</code> の使用が必要になることがあります。<span class="command"><strong>WordPad</strong></span> などの一部のプログラムは、ファイルを書き込むときに行ターミネータとして <code class="literal">\r</code> を使用する可能性があります。このようなファイルを読み取るには、<code class="literal">LINES TERMINATED BY '\r'</code> を使用します。
      </p></div><p>
      読み取るすべての行に、無視したい共通のプリフィクスが含まれている場合は、<code class="literal">LINES STARTING BY '<em class="replaceable"><code>prefix_string</code></em>'</code> を使用して、プリフィクス<span class="emphasis"><em>とその前にあるすべてのもの</em></span>をスキップできます。行にプリフィクスが含まれていない場合は、行全体がスキップされます。たとえば、次のステートメントを発行するとします。
    </p><pre class="programlisting">
LOAD DATA INFILE '/tmp/test.txt' INTO TABLE test
  FIELDS TERMINATED BY ','  LINES STARTING BY 'xxx';
</pre><p>
      データファイルは次のようになっています。
    </p><pre class="programlisting">
xxx"abc",1
something xxx"def",2
"ghi",3
</pre><p>
      結果として得られる行は、<code class="literal">("abc",1)</code> および <code class="literal">("def",2)</code> になります。ファイル内の 3 行目は、プリフィクスが含まれていないためスキップされます。
    </p><p>
      <code class="literal">IGNORE <em class="replaceable"><code>number</code></em> LINES</code> オプションを使用すると、ファイルの先頭にある行を無視できます。たとえば、<code class="literal">IGNORE 1 LINES</code> を使用すると、カラム名を含む開始ヘッダー行をスキップできます。
    </p><pre class="programlisting">
LOAD DATA INFILE '/tmp/test.txt' INTO TABLE test IGNORE 1 LINES;
</pre><p>
      <code class="literal">SELECT ... INTO OUTFILE</code> と <code class="literal">LOAD DATA INFILE</code> を連携して使用してデータベースからファイルにデータを書き込み、あとでそのファイルを元のデータベースに読み取る場合は、両方のステートメントのフィールド処理と行処理のオプションが一致している必要があります。そうしないと、<code class="literal">LOAD DATA INFILE</code> は、そのファイルの内容を正しく解釈しません。<code class="literal">SELECT ... INTO OUTFILE</code> を使用して、カンマで区切られたフィールドを含むファイルを書き込むとします。
    </p><pre class="programlisting">
SELECT * INTO OUTFILE 'data.txt'
  FIELDS TERMINATED BY ','
  FROM table2;
</pre><p>
      カンマで区切られたファイルを読み戻すための正しいステートメントは次のようになります。
    </p><pre class="programlisting">
LOAD DATA INFILE 'data.txt' INTO TABLE table2
  FIELDS TERMINATED BY ',';
</pre><p>
      代わりに、次に示すステートメントを使用してこのファイルを読み取ろうとしても、これはフィールド間のタブを探すよう <code class="literal">LOAD DATA INFILE</code> に指示するため機能しません。
    </p><pre class="programlisting">
LOAD DATA INFILE 'data.txt' INTO TABLE table2
  FIELDS TERMINATED BY '\t';
</pre><p>
      その結果、各入力行が 1 つのフィールドとして解釈される可能性があります。
    </p><a class="indexterm" name="idm139979084857984"></a><a class="indexterm" name="idm139979084856464"></a><p>
      <code class="literal">LOAD DATA INFILE</code> を使用すると、外部ソースから取得されたファイルを読み取ることができます。たとえば、多くのプログラムは、各行にカンマで区切られ、二重引用符で囲まれた複数のフィールドが含まれており、かつ開始行がカラム名になっているようなカンマ区切り値 (CSV) 形式でデータをエクスポートできます。このようなファイル内の行が復帰改行と改行のペアで終了している場合、次に示すステートメントは、このファイルをロードするために使用するフィールド処理と行処理のオプションを示しています。
    </p><pre class="programlisting">
LOAD DATA INFILE 'data.txt' INTO TABLE <em class="replaceable"><code>tbl_name</code></em>
  FIELDS TERMINATED BY ',' ENCLOSED BY '"'
  LINES TERMINATED BY '\r\n'
  IGNORE 1 LINES;
</pre><p>
      入力値が必ずしも引用符で囲まれていない場合は、<code class="literal">ENCLOSED BY</code> キーワードの前に <code class="literal">OPTIONALLY</code> を使用します。
    </p><p>
      フィールド処理または行処理のどのオプションにも、空の文字列 (<code class="literal">''</code>) を指定できます。空でない場合、<code class="literal">FIELDS [OPTIONALLY] ENCLOSED BY</code> および <code class="literal">FIELDS ESCAPED BY</code> 値は単一の文字である必要があります。<code class="literal">FIELDS TERMINATED BY</code>、<code class="literal">LINES STARTING BY</code>、および <code class="literal">LINES TERMINATED BY</code> 値は、複数の文字にすることができます。たとえば、復帰改行と改行のペアで終了する行を書き込むか、またはこのような行を含むファイルを読み取るには、<code class="literal">LINES TERMINATED BY '\r\n'</code> 句を指定します。
    </p><p>
      <code class="literal">%%</code> から成る行で区切られたジョークを含むファイルを読み取るには、次のようにできます。
    </p><pre class="programlisting">
CREATE TABLE jokes
  (a INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
  joke TEXT NOT NULL);
LOAD DATA INFILE '/tmp/jokes.txt' INTO TABLE jokes
  FIELDS TERMINATED BY ''
  LINES TERMINATED BY '\n%%\n' (joke);
</pre><p>
      <code class="literal">FIELDS [OPTIONALLY] ENCLOSED BY</code> は、フィールドの引用符を制御します。出力 (<code class="literal">SELECT ... INTO OUTFILE</code>) でワード <code class="literal">OPTIONALLY</code> を省略した場合は、すべてのフィールドが <code class="literal">ENCLOSED BY</code> 文字で囲まれます。フィールド区切り文字としてカンマを使用したこのような出力の例を次に示します。
    </p><pre class="programlisting">
"1","a string","100.20"
"2","a string containing a , comma","102.20"
"3","a string containing a \" quote","102.20"
"4","a string containing a \", quote and comma","102.20"
</pre><p>
      <code class="literal">OPTIONALLY</code> を指定した場合、<code class="literal">ENCLOSED BY</code> 文字は、文字列データ型 (<code class="literal">CHAR</code>、<code class="literal">BINARY</code>、<code class="literal">TEXT</code>、<code class="literal">ENUM</code> など) を持つカラムの値を囲むためにのみ使用されます。
    </p><pre class="programlisting">
1,"a string",100.20
2,"a string containing a , comma",102.20
3,"a string containing a \" quote",102.20
4,"a string containing a \", quote and comma",102.20
</pre><p>
      フィールド値の中に <code class="literal">ENCLOSED BY</code> 文字が現れると、その文字は、前に <code class="literal">ESCAPED BY</code> 文字を付けることによってエスケープされます。また、空の <code class="literal">ESCAPED BY</code> 値を指定した場合は、<code class="literal">LOAD DATA INFILE</code> で正しく読み取ることができない出力が誤って生成される可能性もあります。たとえば、エスケープ文字が空である場合、今示した前の出力は次のようになります。4 行目の 2 番目のフィールドに含まれる引用符のあとにカンマが続いていることに注目してください。これにより、このフィールドが (誤って) 終了するように見えます。
    </p><pre class="programlisting">
1,"a string",100.20
2,"a string containing a , comma",102.20
3,"a string containing a " quote",102.20
4,"a string containing a ", quote and comma",102.20
</pre><p>
      入力では、<code class="literal">ENCLOSED BY</code> 文字 (存在する場合) はフィールド値の最後から取り除かれます。(これは、<code class="literal">OPTIONALLY</code> が指定されているかどうかには関係しません。<code class="literal">OPTIONALLY</code> は、入力の解釈には影響を与えません。)<code class="literal">ENCLOSED BY</code> 文字が <code class="literal">ESCAPED BY</code> 文字のあとに現れた場合は、現在のフィールド値の一部として解釈されます。
    </p><p>
      フィールドが <code class="literal">ENCLOSED BY</code> 文字で始まったとき、その文字のインスタンスがフィールド値の終了として認識されるのは、そのあとにフィールドまたは行の <code class="literal">TERMINATED BY</code> シーケンスが続いている場合だけです。あいまいさを避けるために、フィールド値の中に <code class="literal">ENCLOSED BY</code> 文字が現れるときはそれを 2 文字にすることができ、それがその文字の単一インスタンスとして解釈されます。たとえば、<code class="literal">ENCLOSED BY '"'</code> が指定されている場合、引用符は次に示すように処理されます。
    </p><pre class="programlisting">
"The ""BIG"" boss"  -&gt; The "BIG" boss
The "BIG" boss      -&gt; The "BIG" boss
The ""BIG"" boss    -&gt; The ""BIG"" boss
</pre><p>
      <code class="literal">FIELDS ESCAPED BY</code> は、特殊文字の読み取りまたは書き込みの方法を制御します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          入力では、<code class="literal">FIELDS ESCAPED BY</code> 文字が空でない場合、その文字が現れると取り除かれ、それに続く文字がフィールド値の一部として文字どおりに解釈されます。最初の文字がエスケープ文字である一部の 2 文字シーケンスは例外です。これらのシーケンスを (エスケープ文字に<span class="quote">「<span class="quote"><code class="literal">\</code></span>」</span>を使用して) 次の表に示します。<code class="literal">NULL</code> 処理のルールについては、このセクションのあとの方で説明されています。
        </p><div class="informaltable"><table summary="この表は、最初の文字 (\) がエスケープ文字である 2 文字シーケンスを示しています。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">文字</th><th scope="col">エスケープシーケンス</th></tr></thead><tbody><tr><td scope="row"><code class="literal">\0</code> <a class="indexterm" name="idm139979084801152"></a> <a class="indexterm" name="idm139979084799808"></a></td><td>ASCII NUL (<code class="literal">0x00</code>) 文字</td></tr><tr><td scope="row"><code class="literal">\b</code> <a class="indexterm" name="idm139979084796224"></a> <a class="indexterm" name="idm139979084794720"></a></td><td>バックスペース文字</td></tr><tr><td scope="row"><code class="literal">\n</code> <a class="indexterm" name="idm139979084791856"></a> <a class="indexterm" name="idm139979084790400"></a> <a class="indexterm" name="idm139979084789056"></a> <a class="indexterm" name="idm139979084787664"></a></td><td>改行 (ラインフィード) 文字</td></tr><tr><td scope="row"><code class="literal">\r</code> <a class="indexterm" name="idm139979084784800"></a> <a class="indexterm" name="idm139979084783312"></a> <a class="indexterm" name="idm139979084781968"></a></td><td>復帰改行文字</td></tr><tr><td scope="row"><code class="literal">\t</code> <a class="indexterm" name="idm139979084779136"></a> <a class="indexterm" name="idm139979084777680"></a></td><td>タブ文字。</td></tr><tr><td scope="row"><code class="literal">\Z</code> <a class="indexterm" name="idm139979084774864"></a> <a class="indexterm" name="idm139979084773520"></a></td><td>ASCII 26 (Ctrl+Z)</td></tr><tr><td scope="row"><code class="literal">\N</code> <a class="indexterm" name="idm139979084770592"></a></td><td>NULL</td></tr></tbody></table></div><p>
          <span class="quote">「<span class="quote"><code class="literal">\</code></span>」</span>でのエスケープ構文の詳細は、<a class="xref" href="language-structure.html#string-literals" title="9.1.1 文字列リテラル">セクション9.1.1「文字列リテラル」</a>を参照してください。
        </p><p>
          <code class="literal">FIELDS ESCAPED BY</code> 文字が空である場合、エスケープシーケンスの解釈は実行されません。
        </p></li><li class="listitem"><p>
          出力では、<code class="literal">FIELDS ESCAPED BY</code> 文字が空でない場合、その文字は、出力上で次の文字の前に付けるために使用されます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">FIELDS ESCAPED BY</code> 文字
            </p></li><li class="listitem"><p>
              <code class="literal">FIELDS [OPTIONALLY] ENCLOSED BY</code> 文字
            </p></li><li class="listitem"><p>
              <code class="literal">FIELDS TERMINATED BY</code> および <code class="literal">LINES TERMINATED BY</code> 値の最初の文字
            </p></li><li class="listitem"><p>
              ASCII <code class="literal">0</code> (エスケープ文字のあとに実際に書き込まれる文字は 0 の値のバイトではなく、ASCII の<span class="quote">「<span class="quote"><code class="literal">0</code></span>」</span>です)
            </p></li></ul></div><p>
          <code class="literal">FIELDS ESCAPED BY</code> 文字が空である場合は、どの文字もエスケープされず、<code class="literal">NULL</code> は <code class="literal">\N</code> ではなく、<code class="literal">NULL</code> として出力されます。特に、データ内のフィールド値に今指定したリスト内のいずれかの文字が含まれている場合、空のエスケープ文字を指定することはおそらく適切な方法ではありません。
        </p></li></ul></div><p>
      特定のケースでは、フィールド処理と行処理のオプションは相互に作用します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">LINES TERMINATED BY</code> が空の文字列であり、かつ <code class="literal">FIELDS TERMINATED BY</code> が空以外である場合、行は <code class="literal">FIELDS TERMINATED BY</code> でも終了します。
        </p></li><li class="listitem"><p>
          <code class="literal">FIELDS TERMINATED BY</code> と <code class="literal">FIELDS ENCLOSED BY</code> の値がどちらも空 (<code class="literal">''</code>) である場合は、固定行 (区切られていない) フォーマットが使用されます。固定行フォーマットでは、フィールド間に区切り文字は使用されません (ただし、行ターミネータは引き続き存在できます)。代わりに、カラム値は、そのフィールド内のすべての値を保持するために十分に広いフィールド幅を使用して読み取りと書き込みが行われます。<code class="literal">TINYINT</code>、<code class="literal">SMALLINT</code>、<code class="literal">MEDIUMINT</code>、<code class="literal">INT</code>、および <code class="literal">BIGINT</code> では、宣言されている表示幅にかかわらず、フィールド幅はそれぞれ 4、6、8、11、および 20 です。
        </p><p>
          <code class="literal">LINES TERMINATED BY</code> は引き続き、行を区切るために使用されます。ある行にすべてのフィールドが含まれていない場合、カラムの残りの部分はそのデフォルト値に設定されます。行ターミネータが存在しない場合は、これを <code class="literal">''</code> に設定してください。この場合は、テキストファイルの各行にすべてのフィールドが含まれている必要があります。
        </p><p>
          固定行フォーマットはまた、あとで説明されているように、<code class="literal">NULL</code> 値の処理にも影響を与えます。複数バイトの文字セットを使用している場合は、固定サイズフォーマットが機能しません。
        </p></li></ul></div><p>
      <code class="literal">NULL</code> 値の処理は、使用されている <code class="literal">FIELDS</code> および <code class="literal">LINES</code> オプションによって異なります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          デフォルトの <code class="literal">FIELDS</code> および <code class="literal">LINES</code> 値では、<code class="literal">NULL</code> は出力として <code class="literal">\N</code> のフィールド値として書き込まれ、<code class="literal">\N</code> のフィールド値は入力として <code class="literal">NULL</code> として読み取られます (<code class="literal">ESCAPED BY</code> 文字は<span class="quote">「<span class="quote"><code class="literal">\</code></span>」</span>であると仮定します)。
        </p></li><li class="listitem"><p>
          <code class="literal">FIELDS ENCLOSED BY</code> が空でない場合、リテラルワード <code class="literal">NULL</code> をその値として含むフィールドは <code class="literal">NULL</code> 値として読み取られます。これは、文字列 <code class="literal">'NULL'</code> として読み取られる、<code class="literal">FIELDS ENCLOSED BY</code> 文字で囲まれたワード <code class="literal">NULL</code> とは異なります。
        </p></li><li class="listitem"><p>
          <code class="literal">FIELDS ESCAPED BY</code> が空である場合、<code class="literal">NULL</code> はワード <code class="literal">NULL</code> として書き込まれます。
        </p></li><li class="listitem"><p>
          固定行フォーマット (これは、<code class="literal">FIELDS TERMINATED BY</code> と <code class="literal">FIELDS ENCLOSED BY</code> がどちらも空であるときに使用されます) では、<code class="literal">NULL</code> は空の文字列として書き込まれます。これにより、<code class="literal">NULL</code> 値と空の文字列がどちらも空の文字列として書き込まれるため、ファイルに書き込まれた場合、テーブル内でこの両方を区別できなくなります。ファイルを読み戻したときにこの 2 つを区別できることが必要な場合は、固定行フォーマットを使用すべきではありません。
        </p></li></ul></div><p>
      <code class="literal">NULL</code> を <code class="literal">NOT NULL</code> カラムにロードしようとすると、そのカラムのデータ型の暗黙のデフォルト値の割り当てが行われて警告が発生するか、または厳密な SQL モードではエラーが発生します。暗黙のデフォルト値については、<a class="xref" href="data-types.html#data-type-defaults" title="11.6 データ型デフォルト値">セクション11.6「データ型デフォルト値」</a>で説明されています。
    </p><p>
      次の一部のケースは、<code class="literal">LOAD DATA INFILE</code> ではサポートされません。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          固定サイズ行 (<code class="literal">FIELDS TERMINATED BY</code> と <code class="literal">FIELDS ENCLOSED BY</code> がどちらも空) および <code class="literal">BLOB</code> または <code class="literal">TEXT</code> カラム。
        </p></li><li class="listitem"><p>
          別の区切り文字と同じか、または別の区切り文字のプリフィクスである区切り文字を指定した場合、<code class="literal">LOAD DATA INFILE</code> は入力を正しく解釈できません。たとえば、次の <code class="literal">FIELDS</code> 句では問題が発生します。
        </p><pre class="programlisting">
FIELDS TERMINATED BY '"' ENCLOSED BY '"'
</pre></li><li class="listitem"><p>
          <code class="literal">FIELDS ESCAPED BY</code> が空である場合、フィールド値の中に <code class="literal">FIELDS ENCLOSED BY</code> または <code class="literal">LINES TERMINATED BY</code> に続いて <code class="literal">FIELDS TERMINATED BY</code> 値が現れると、<code class="literal">LOAD DATA INFILE</code> はフィールドまたは行の読み取りを非常に早く停止します。これは、<code class="literal">LOAD DATA INFILE</code> が、フィールドまたは行の値がどこで終了するかを正しく判定できないために発生します。
        </p></li></ul></div><p>
      次の例では、<code class="literal">persondata</code> テーブルのすべてのカラムをロードします。
    </p><pre class="programlisting">
LOAD DATA INFILE 'persondata.txt' INTO TABLE persondata;
</pre><p>
      デフォルトでは、<code class="literal">LOAD DATA INFILE</code> ステートメントの最後にカラムリストが指定されていないときは、入力行にテーブルカラムごとのフィールドが含まれていることが期待されます。テーブルのカラムの一部のみをロードする場合は、カラムリストを指定します。
    </p><pre class="programlisting">
LOAD DATA INFILE 'persondata.txt' INTO TABLE persondata (col1,col2,...);
</pre><p>
      カラムリストはまた、入力ファイル内のフィールドの順序がテーブル内のカラムの順序と異なる場合にも指定する必要があります。そうしないと、MySQL は、入力フィールドとテーブルカラムを一致させる方法がわかりません。
    </p><p>
      カラムリストには、カラム名またはユーザー変数のどちらかを含めることができます。ユーザー変数では、<code class="literal">SET</code> 句を使用して、各値に対して変換を実行してからその結果をカラムに代入できます。
    </p><p>
      <code class="literal">SET</code> 句内のユーザー変数は、いくつかの方法で使用できます。次の例では、最初の入力カラムを直接 <code class="literal">t1.column1</code> の値に使用し、2 番目の入力カラムを、<code class="literal">t1.column2</code> の値に使用される前に除算演算の対象になるユーザー変数に割り当てます。
    </p><pre class="programlisting">
LOAD DATA INFILE 'file.txt'
  INTO TABLE t1
  (column1, @var1)
  SET column2 = @var1/100;
</pre><p>
      <code class="literal">SET</code> 句を使用すると、入力ファイルからは取得されない値を指定できます。次のステートメントは、<code class="literal">column3</code> を現在の日付と時間に設定します。
    </p><pre class="programlisting">
LOAD DATA INFILE 'file.txt'
  INTO TABLE t1
  (column1, column2)
  SET column3 = CURRENT_TIMESTAMP;
</pre><p>
      入力値をユーザー変数に割り当て、その変数をテーブルカラムには代入しないようにして、その値を破棄することもできます。
    </p><pre class="programlisting">
LOAD DATA INFILE 'file.txt'
  INTO TABLE t1
  (column1, @dummy, column2, @dummy, column3);
</pre><p>
      カラム/変数リストと <code class="literal">SET</code> 句の使用は、次の制限に従います。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">SET</code> 句の代入では、割り当て演算子の左側にカラム名のみを置くようにしてください。
        </p></li><li class="listitem"><p>
          <code class="literal">SET</code> の代入の右側では、サブクエリーを使用できます。カラムに代入される値を返すサブクエリーとして使用できるのは、スカラーサブクエリーだけです。また、サブクエリーを使用して、ロードされているテーブルから選択することはできません。
        </p></li><li class="listitem"><p>
          <code class="literal">IGNORE</code> 句によって無視された行は、カラム/変数リストや <code class="literal">SET</code> 句では処理されません。
        </p></li><li class="listitem"><p>
          ユーザー変数には表示幅がないため、固定行フォーマットのデータをロードする場合はユーザー変数を使用できません。
        </p></li></ul></div><p>
      入力行を処理する場合、<code class="literal">LOAD DATA</code> はそれをフィールドに分割し、カラム/変数リストと <code class="literal">SET</code> 句に応じた値 (存在する場合) を使用します。そのあと、結果として得られる行がテーブルに挿入されます。そのテーブルに <code class="literal">BEFORE INSERT</code> または <code class="literal">AFTER INSERT</code> トリガーが存在する場合、これらのトリガーはそれぞれ、行挿入の前またはあとにアクティブ化されます。
    </p><p>
      入力行に含まれるフィールドが多すぎる場合は、余分なフィールドが無視され、警告数が 1 増えます。
    </p><p>
      入力行に含まれるフィールドが少なすぎる場合、入力フィールドがないテーブルカラムはそのデフォルト値に設定されます。デフォルト値の割り当てについては、<a class="xref" href="data-types.html#data-type-defaults" title="11.6 データ型デフォルト値">セクション11.6「データ型デフォルト値」</a>で説明されています。
    </p><p>
      空のフィールド値はフィールドがないとは見なされず、次のように解釈されます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          文字列型の場合、このカラムは空の文字列に設定されます。
        </p></li><li class="listitem"><p>
          数値型の場合、このカラムは <code class="literal">0</code> に設定されます。
        </p></li><li class="listitem"><p>
          日付と時間型の場合、このカラムはその型の適切な<span class="quote">「<span class="quote">0</span>」</span>の値に設定されます。<a class="xref" href="data-types.html#date-and-time-types" title="11.3 日付と時間型">セクション11.3「日付と時間型」</a>を参照してください。
        </p></li></ul></div><p>
      これらは、<code class="literal">INSERT</code> または <code class="literal">UPDATE</code> ステートメントで空の文字列を文字列、数値、日付または時間の各型に明示的に割り当てた場合の結果と同じ値です。
    </p><p>
      空のフィールド値や正しくないフィールド値の処理は、SQL モードが制限的な値に設定されていると、今説明した処理とは異なってきます。たとえば、<code class="literal">sql_mode='TRADITIONAL</code> である場合は、空の値や <code class="literal">'x'</code> などの値を数値カラムに変換すると 0 に変換されるのではなく、エラーが発生します。(<code class="literal">LOCAL</code> が指定されている場合は、操作の最中にファイルの転送を停止する方法がサーバーにはないため、制限的な <code class="literal">sql_mode</code> 値が設定されていても、エラーではなく警告が発生します。)
    </p><p>
      <code class="literal">TIMESTAMP</code> カラムが現在の日付と時間に設定されるのは、そのカラムに <code class="literal">NULL</code> 値 (つまり、<code class="literal">\N</code>) が存在し、かつそのカラムが <code class="literal">NULL</code> 値を許可するように宣言されていない場合、または <code class="literal">TIMESTAMP</code> カラムのデフォルト値が現在のタイムスタンプであり、かつフィールドリストが指定されたときにこのカラムがフィールドリストから省略されている場合だけです。
    </p><p>
      <code class="literal">LOAD DATA INFILE</code> はすべての入力を文字列と見なすため、<code class="literal">ENUM</code> または <code class="literal">SET</code> カラムの数値を <code class="literal">INSERT</code> ステートメントと同じように使用することはできません。<code class="literal">ENUM</code> および <code class="literal">SET</code> 値はすべて、文字列として指定する必要があります。
    </p><p>
      <code class="literal">BIT</code> 値を、2 進表記 (<code class="literal">b'011010'</code> など) を使用してロードすることはできません。これを回避するには、その値を通常の整数として指定し、<code class="literal">SET</code> 句を使用して変換することにより、MySQL で数値型の変換が実行され、それが <code class="literal">BIT</code> カラムに正しくロードされるようにします。
    </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>cat /tmp/bit_test.txt</code></strong>
2
127
shell&gt; <strong class="userinput"><code>mysql test</code></strong>
mysql&gt; <strong class="userinput"><code>LOAD DATA INFILE '/tmp/bit_test.txt'</code></strong>
    -&gt; <strong class="userinput"><code>INTO TABLE bit_test (@var1) SET b = CAST(@var1 AS UNSIGNED);</code></strong>
Query OK, 2 rows affected (0.00 sec)
Records: 2  Deleted: 0  Skipped: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT BIN(b+0) FROM bit_test;</code></strong>
+----------+
| bin(b+0) |
+----------+
| 10       |
| 1111111  |
+----------+
2 rows in set (0.00 sec)
</pre><p>
      Unix では、<code class="literal">LOAD DATA</code> でパイプから読み取る必要がある場合は次の手法を使用できます (この例では、<code class="filename">/</code> ディレクトリのリストをテーブル <code class="literal">db1.t1</code> にロードします)。
    </p><pre class="programlisting">
mkfifo /mysql/data/db1/ls.dat
chmod 666 /mysql/data/db1/ls.dat
find / -ls &gt; /mysql/data/db1/ls.dat &amp;
mysql -e "LOAD DATA INFILE 'ls.dat' INTO TABLE t1" db1
</pre><p>
      ロードされるデータを生成するコマンドと <span class="command"><strong>mysql</strong></span> コマンドを別の端末で実行するか、または (前の例に示したように) バックグラウンドでデータ生成プロセスを実行する必要があります。これを行わないと、データが <span class="command"><strong>mysql</strong></span> プロセスから読み取られる準備ができるまで、パイプがブロックされます。
    </p><p>
      <code class="literal">LOAD DATA INFILE</code> ステートメントは、完了すると、次の形式の情報文字列を返します。
    </p><pre class="programlisting">
Records: 1  Deleted: 0  Skipped: 0  Warnings: 0
</pre><p>
      警告は、<code class="literal">INSERT</code> ステートメントを使用して値が挿入されるときと同じ状況で発生します (<a class="xref" href="sql-syntax.html#insert" title="13.2.5 INSERT 構文">セクション13.2.5「INSERT 構文」</a>を参照してください)。ただし、<code class="literal">LOAD DATA INFILE</code> では、入力行内のフィールドが少なすぎるか、または多すぎる場合にも警告が生成されます。
    </p><p>
      <code class="literal">SHOW WARNINGS</code> を使用すると、発生した問題に関する情報として最初の <code class="literal">max_error_count</code> 警告のリストを取得できます。<a class="xref" href="sql-syntax.html#show-warnings" title="13.7.5.41 SHOW WARNINGS 構文">セクション13.7.5.41「SHOW WARNINGS 構文」</a>を参照してください。
    </p><a class="indexterm" name="idm139979084607696"></a><p>
      C API を使用している場合は、<code class="literal">mysql_info()</code> 関数を呼び出すことによって、そのステートメントに関する情報を取得できます。<a class="xref" href="connectors-apis.html#mysql-info" title="23.8.7.35 mysql_info()">セクション23.8.7.35「mysql_info()」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="load-xml"></a>13.2.7 LOAD XML 構文</h3></div></div></div><a class="indexterm" name="idm139979084602736"></a><pre class="programlisting">
LOAD XML [LOW_PRIORITY | CONCURRENT] [LOCAL] INFILE '<em class="replaceable"><code>file_name</code></em>'
    [REPLACE | IGNORE]
    INTO TABLE [<em class="replaceable"><code>db_name</code></em>.]<em class="replaceable"><code>tbl_name</code></em>
    [PARTITION (<em class="replaceable"><code>partition_name</code></em>,...)]
    [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>]
    [ROWS IDENTIFIED BY '&lt;<em class="replaceable"><code>tagname</code></em>&gt;']
    [IGNORE <em class="replaceable"><code>number</code></em> {LINES | ROWS}]
    [(<em class="replaceable"><code>column_or_user_var</code></em>,...)]
    [SET <em class="replaceable"><code>col_name</code></em> = <em class="replaceable"><code>expr</code></em>,...]
</pre><p>
      <code class="literal">LOAD XML</code> ステートメントは、XML ファイルからテーブルにデータを読み取ります。<em class="replaceable"><code>file_name</code></em> は、リテラル文字列として指定する必要があります。オプションの <code class="literal">ROWS IDENTIFIED BY</code> 句内の <em class="replaceable"><code>tagname</code></em> もリテラル文字列として指定し、山括弧 (<code class="literal">&lt;</code> および <code class="literal">&gt;</code>) で囲む必要があります。
    </p><p>
      <code class="literal">LOAD XML</code> は、XML 出力モードでの <span class="command"><strong>mysql</strong></span> クライアントの実行 (つまり、<code class="option">--xml</code> オプションを使用したクライアントの起動) を補完するものとして機能します。テーブルから XML ファイルにデータを書き込むには、システムシェルから次のようなコマンドを使用します。
    </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>mysql --xml -e 'SELECT * FROM mytable' &gt; file.xml</code></strong>
</pre><p>
      そのファイルをテーブルに読み戻すには、<code class="literal">LOAD XML INFILE</code> を使用します。デフォルトでは、<code class="literal">&lt;row&gt;</code> 要素は、データベーステーブル行と同等であると見なされます。これは、<code class="literal">ROWS IDENTIFIED BY</code> 句を使用して変更できます。
    </p><p>
      このステートメントは、次の 3 つの異なる XML 形式をサポートします。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          属性としてのカラム名と、属性値としてのカラム値:
        </p><pre class="programlisting">
&lt;<em class="replaceable"><code>row</code></em> <em class="replaceable"><code>column1</code></em>="<em class="replaceable"><code>value1</code></em>" <em class="replaceable"><code>column2</code></em>="<em class="replaceable"><code>value2</code></em>" .../&gt;
</pre></li><li class="listitem"><p>
          タグとしてのカラム名と、これらのタグの内容としてのカラム値:
        </p><pre class="programlisting">
&lt;<em class="replaceable"><code>row</code></em>&gt;
  &lt;<em class="replaceable"><code>column1</code></em>&gt;<em class="replaceable"><code>value1</code></em>&lt;/<em class="replaceable"><code>column1</code></em>&gt;
  &lt;<em class="replaceable"><code>column2</code></em>&gt;<em class="replaceable"><code>value2</code></em>&lt;/<em class="replaceable"><code>column2</code></em>&gt;
&lt;/<em class="replaceable"><code>row</code></em>&gt;
</pre></li><li class="listitem"><p>
          カラム名は <code class="literal">&lt;field&gt;</code> タグの <code class="literal">name</code> 属性で、値はこれらのタグの内容:
        </p><pre class="programlisting">
&lt;row&gt;
  &lt;field name='<em class="replaceable"><code>column1</code></em>'&gt;<em class="replaceable"><code>value1</code></em>&lt;/field&gt;
  &lt;field name='<em class="replaceable"><code>column2</code></em>'&gt;<em class="replaceable"><code>value2</code></em>&lt;/field&gt;
&lt;/row&gt;
</pre><p>
          これは、<span class="command"><strong>mysqldump</strong></span> などのほかの MySQL ツールによって使用される形式です。
        </p></li></ul></div><p>
      同じ XML ファイルで 3 つのすべての形式を使用できます。インポートルーチンは各行の形式を自動的に検出し、それを正しく解釈します。タグは、タグまたは属性名とカラム名に基づいて照合されます。
    </p><p>
      次の句は、基本的に <code class="literal">LOAD XML</code> に対して <code class="literal">LOAD DATA</code> に対する場合と同じように機能します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">LOW_PRIORITY</code> または <code class="literal">CONCURRENT</code>
        </p></li><li class="listitem"><p>
          <code class="literal">LOCAL</code>
        </p></li><li class="listitem"><p>
          <code class="literal">REPLACE</code> または <code class="literal">IGNORE</code>
        </p></li><li class="listitem"><p>
          <code class="literal">PARTITION</code>
        </p></li><li class="listitem"><p>
          <code class="literal">CHARACTER SET</code>
        </p></li><li class="listitem"><p>
          <code class="literal">(<em class="replaceable"><code>column_or_user_var</code></em>,...)</code>
        </p></li><li class="listitem"><p>
          <code class="literal">SET</code>
        </p></li></ul></div><p>
      これらの句の詳細は、<a class="xref" href="sql-syntax.html#load-data" title="13.2.6 LOAD DATA INFILE 構文">セクション13.2.6「LOAD DATA INFILE 構文」</a>を参照してください。
    </p><p>
      <code class="literal">IGNORE <em class="replaceable"><code>number</code></em> LINES</code> または <code class="literal">IGNORE <em class="replaceable"><code>number</code></em> ROWS</code> 句を指定すると、XML ファイル内の最初の <em class="replaceable"><code>number</code></em> 行がスキップされます。これは、<code class="literal">LOAD DATA</code> ステートメントの <code class="literal">IGNORE ... LINES</code> 句に類似しています。
    </p><p>
      このステートメントがどのように使用されるかを示すために、次のように作成されたテーブルがあるとします。
    </p><pre class="programlisting">
USE test;

CREATE TABLE person (
    person_id INT NOT NULL PRIMARY KEY,
    fname VARCHAR(40) NULL,
    lname VARCHAR(40) NULL,
    created TIMESTAMP
);
</pre><p>
      さらに、このテーブルが最初は空であるとします。
    </p><p>
      ここで、次に示すような内容を持つ単純な XML ファイル <code class="filename">person.xml</code> があるとします。
    </p><pre class="programlisting">
&lt;?xml version="1.0"?&gt;
&lt;list&gt;
  &lt;person person_id="1" fname="Pekka" lname="Nousiainen"/&gt;
  &lt;person person_id="2" fname="Jonas" lname="Oreland"/&gt;
  &lt;person person_id="3"&gt;&lt;fname&gt;Mikael&lt;/fname&gt;&lt;lname&gt;Ronström&lt;/lname&gt;&lt;/person&gt;
  &lt;person person_id="4"&gt;&lt;fname&gt;Lars&lt;/fname&gt;&lt;lname&gt;Thalmann&lt;/lname&gt;&lt;/person&gt;
  &lt;person&gt;&lt;field name="person_id"&gt;5&lt;/field&gt;&lt;field name="fname"&gt;Tomas&lt;/field&gt;
  &lt;field name="lname"&gt;Ulin&lt;/field&gt;&lt;/person&gt;
  &lt;person&gt;&lt;field name="person_id"&gt;6&lt;/field&gt;&lt;field name="fname"&gt;Martin&lt;/field&gt;
  &lt;field name="lname"&gt;Sköld&lt;/field&gt;&lt;/person&gt;
&lt;/list&gt;
</pre><p>
      例として示したこのファイルには、前に説明した許可される各 XML 形式が表されています。
    </p><p>
      <code class="filename">person.xml</code> 内のデータを <code class="literal">person</code> テーブルにインポートするには、次のステートメントを使用できます。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>LOAD XML LOCAL INFILE 'person.xml'</code></strong>
    -&gt;   <strong class="userinput"><code>INTO TABLE person</code></strong>
    -&gt;   <strong class="userinput"><code>ROWS IDENTIFIED BY '&lt;person&gt;';</code></strong>

Query OK, 6 rows affected (0.00 sec)
Records: 6  Deleted: 0  Skipped: 0  Warnings: 0
</pre><p>
      ここでは、<code class="filename">person.xml</code> が MySQL データディレクトリ内に存在することを前提にしています。このファイルが見つからない場合は、次のエラーが発生します。
    </p><pre class="programlisting">
<span class="errortext">ERROR 2 (HY000): File '/person.xml' not found (Errcode: 2)</span>
</pre><p>
      <code class="literal">ROWS IDENTIFIED BY '&lt;person&gt;'</code> 句は、XML ファイル内の各 <code class="literal">&lt;person&gt;</code> 要素が、このデータがインポートされるテーブル内の各行と同等であると見なされることを示します。この場合、これは <code class="literal">test</code> データベース内の <code class="literal">person</code> テーブルです。
    </p><p>
      サーバーからの応答でわかるように、<code class="literal">test.person</code> テーブルには 6 行がインポートされました。これは、単純な <code class="literal">SELECT</code> ステートメントで確認できます。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT * FROM person;</code></strong>
+-----------+--------+------------+---------------------+
| person_id | fname  | lname      | created             |
+-----------+--------+------------+---------------------+
|         1 | Pekka  | Nousiainen | 2007-07-13 16:18:47 |
|         2 | Jonas  | Oreland    | 2007-07-13 16:18:47 |
|         3 | Mikael | Ronström   | 2007-07-13 16:18:47 |
|         4 | Lars   | Thalmann   | 2007-07-13 16:18:47 |
|         5 | Tomas  | Ulin       | 2007-07-13 16:18:47 |
|         6 | Martin | Sköld      | 2007-07-13 16:18:47 |
+-----------+--------+------------+---------------------+
6 rows in set (0.00 sec)
</pre><p>
      このセクションの前の方で説明したように、許可される 3 つの XML 形式のいずれかまたはすべてを 1 つのファイルに含め、それを <code class="literal">LOAD XML</code> を使用して読み取ることができます。
    </p><p>
      上の操作の逆、つまり、MySQL テーブルデータの XML ファイルへのダンプは、次に示すように、システムシェルから mysql クライアントを使用して実現できます。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="option">--xml</code> オプションを指定すると、<span class="command"><strong>mysql</strong></span> クライアントは、その出力として XML 形式を使用します。<code class="option">-e</code> オプションを指定すると、クライアントはそのオプションの直後にある SQL ステートメントを実行します。
      </p></div><pre class="programlisting">
shell&gt; <strong class="userinput"><code>mysql --xml -e "SELECT * FROM test.person" &gt; person-dump.xml</code></strong>
shell&gt; <strong class="userinput"><code>cat person-dump.xml</code></strong>
&lt;?xml version="1.0"?&gt;

&lt;resultset statement="SELECT * FROM test.person" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
  &lt;row&gt;
        &lt;field name="person_id"&gt;1&lt;/field&gt;
        &lt;field name="fname"&gt;Pekka&lt;/field&gt;
        &lt;field name="lname"&gt;Nousiainen&lt;/field&gt;
        &lt;field name="created"&gt;2007-07-13 16:18:47&lt;/field&gt;
  &lt;/row&gt;

  &lt;row&gt;
        &lt;field name="person_id"&gt;2&lt;/field&gt;
        &lt;field name="fname"&gt;Jonas&lt;/field&gt;
        &lt;field name="lname"&gt;Oreland&lt;/field&gt;
        &lt;field name="created"&gt;2007-07-13 16:18:47&lt;/field&gt;
  &lt;/row&gt;

  &lt;row&gt;
        &lt;field name="person_id"&gt;3&lt;/field&gt;
        &lt;field name="fname"&gt;Mikael&lt;/field&gt;
        &lt;field name="lname"&gt;Ronström&lt;/field&gt;
        &lt;field name="created"&gt;2007-07-13 16:18:47&lt;/field&gt;
  &lt;/row&gt;

  &lt;row&gt;
        &lt;field name="person_id"&gt;4&lt;/field&gt;
        &lt;field name="fname"&gt;Lars&lt;/field&gt;
        &lt;field name="lname"&gt;Thalmann&lt;/field&gt;
        &lt;field name="created"&gt;2007-07-13 16:18:47&lt;/field&gt;
  &lt;/row&gt;

  &lt;row&gt;
        &lt;field name="person_id"&gt;5&lt;/field&gt;
        &lt;field name="fname"&gt;Tomas&lt;/field&gt;
        &lt;field name="lname"&gt;Ulin&lt;/field&gt;
        &lt;field name="created"&gt;2007-07-13 16:18:47&lt;/field&gt;
  &lt;/row&gt;

  &lt;row&gt;
        &lt;field name="person_id"&gt;6&lt;/field&gt;
        &lt;field name="fname"&gt;Martin&lt;/field&gt;
        &lt;field name="lname"&gt;Sköld&lt;/field&gt;
        &lt;field name="created"&gt;2007-07-13 16:18:47&lt;/field&gt;
  &lt;/row&gt;
&lt;/resultset&gt;
</pre><p>
      次のように、<code class="literal">person</code> のコピーを作成したあと、ダンプファイルを新しいテーブルにインポートすることによって、このダンプが有効であることを確認できます。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE TABLE person2 LIKE person;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>LOAD XML LOCAL INFILE 'person-dump.xml'</code></strong>
    -&gt;   <strong class="userinput"><code>INTO TABLE person2;</code></strong>
Query OK, 6 rows affected (0.01 sec)
Records: 6  Deleted: 0  Skipped: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT * FROM person2;</code></strong>
+-----------+--------+------------+---------------------+
| person_id | fname  | lname      | created             |
+-----------+--------+------------+---------------------+
|         1 | Pekka  | Nousiainen | 2007-07-13 16:18:47 |
|         2 | Jonas  | Oreland    | 2007-07-13 16:18:47 |
|         3 | Mikael | Ronström   | 2007-07-13 16:18:47 |
|         4 | Lars   | Thalmann   | 2007-07-13 16:18:47 |
|         5 | Tomas  | Ulin       | 2007-07-13 16:18:47 |
|         6 | Martin | Sköld      | 2007-07-13 16:18:47 |
+-----------+--------+------------+---------------------+
6 rows in set (0.00 sec)
</pre><p>
      <code class="literal">ROWS IDENTIFIED BY '&lt;<em class="replaceable"><code>tagname</code></em>&gt;'</code> 句を使用すると、同じ XML ファイルのデータを定義の異なるデータベーステーブルにインポートできます。この例では、次の XML を含む <code class="filename">address.xml</code> という名前のファイルがあるとします。
    </p><pre class="programlisting">
&lt;?xml version="1.0"?&gt;

&lt;list&gt;
  &lt;person person_id="1"&gt;
    &lt;fname&gt;Robert&lt;/fname&gt;
    &lt;lname&gt;Jones&lt;/lname&gt;
    &lt;address address_id="1" street="Mill Creek Road" zip="45365" city="Sidney"/&gt;
    &lt;address address_id="2" street="Main Street" zip="28681" city="Taylorsville"/&gt;
  &lt;/person&gt;

  &lt;person person_id="2"&gt;
    &lt;fname&gt;Mary&lt;/fname&gt;
    &lt;lname&gt;Smith&lt;/lname&gt;
    &lt;address address_id="3" street="River Road" zip="80239" city="Denver"/&gt;
    &lt;!-- &lt;address address_id="4" street="North Street" zip="37920" city="Knoxville"/&gt; --&gt;
  &lt;/person&gt;

&lt;/list&gt;
</pre><p>
      ここでも、このセクションで前に定義された <code class="literal">test.person</code> テーブルを使用できます。テーブルの既存のすべてのレコードをクリアしたあと、次に示すようにその構造を表示します。
    </p><pre class="programlisting">
mysql&lt; <strong class="userinput"><code>TRUNCATE person;</code></strong>
Query OK, 0 rows affected (0.04 sec)

mysql&lt; <strong class="userinput"><code>SHOW CREATE TABLE person\G</code></strong>
*************************** 1. row ***************************
       Table: person
Create Table: CREATE TABLE `person` (
  `person_id` int(11) NOT NULL,
  `fname` varchar(40) DEFAULT NULL,
  `lname` varchar(40) DEFAULT NULL,
  `created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`person_id`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1
1 row in set (0.00 sec)
</pre><p>
      次に、次の <code class="literal">CREATE TABLE</code> ステートメントを使用して、<code class="literal">test</code> データベース内に <code class="literal">address</code> テーブルを作成します。
    </p><pre class="programlisting">
CREATE TABLE address (
    address_id INT NOT NULL PRIMARY KEY,
    person_id INT NULL,
    street VARCHAR(40) NULL,
    zip INT NULL,
    city VARCHAR(40) NULL,
    created TIMESTAMP
);
</pre><p>
      XML ファイルのデータを <code class="literal">person</code> テーブルにインポートするには、次に示すように、行が <code class="literal">&lt;person&gt;</code> 要素で指定されるように指定する次の <code class="literal">LOAD XML</code> ステートメントを実行します。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>LOAD XML LOCAL INFILE 'address.xml'</code></strong>
    -&gt;   <strong class="userinput"><code>INTO TABLE person</code></strong>
    -&gt;   <strong class="userinput"><code>ROWS IDENTIFIED BY '&lt;person&gt;';</code></strong>
Query OK, 2 rows affected (0.00 sec)
Records: 2  Deleted: 0  Skipped: 0  Warnings: 0
</pre><p>
      <code class="literal">SELECT</code> ステートメントを使用して、レコードがインポートされたことを確認できます。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT * FROM person;</code></strong>
+-----------+--------+-------+---------------------+
| person_id | fname  | lname | created             |
+-----------+--------+-------+---------------------+
|         1 | Robert | Jones | 2007-07-24 17:37:06 |
|         2 | Mary   | Smith | 2007-07-24 17:37:06 |
+-----------+--------+-------+---------------------+
2 rows in set (0.00 sec)
</pre><p>
      XML ファイル内の <code class="literal">&lt;address&gt;</code> 要素は、<code class="literal">person</code> テーブル内に対応するカラムがないためスキップされます。
    </p><p>
      <code class="literal">&lt;address&gt;</code> 要素のデータを <code class="literal">address</code> テーブルにインポートするには、次に示す <code class="literal">LOAD XML</code> ステートメントを使用します。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>LOAD XML LOCAL INFILE 'address.xml'</code></strong>
    -&gt;   <strong class="userinput"><code>INTO TABLE address</code></strong>
    -&gt;   <strong class="userinput"><code>ROWS IDENTIFIED BY '&lt;address&gt;';</code></strong>
Query OK, 3 rows affected (0.00 sec)
Records: 3  Deleted: 0  Skipped: 0  Warnings: 0
</pre><p>
      次のような <code class="literal">SELECT</code> ステートメントを使用して、データがインポートされたこと確認できます。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT * FROM address;</code></strong>
+------------+-----------+-----------------+-------+--------------+---------------------+
| address_id | person_id | street          | zip   | city         | created             |
+------------+-----------+-----------------+-------+--------------+---------------------+
|          1 |         1 | Mill Creek Road | 45365 | Sidney       | 2007-07-24 17:37:37 |
|          2 |         1 | Main Street     | 28681 | Taylorsville | 2007-07-24 17:37:37 |
|          3 |         2 | River Road      | 80239 | Denver       | 2007-07-24 17:37:37 |
+------------+-----------+-----------------+-------+--------------+---------------------+
3 rows in set (0.00 sec)
</pre><p>
      <code class="literal">&lt;address&gt;</code> 要素のデータのうち、XML コメントで囲まれているものはインポートされません。ただし、<code class="literal">address</code> テーブルには <code class="literal">person_id</code> カラムがあるため、各 <code class="literal">&lt;address&gt;</code> に対する親の <code class="literal">&lt;person&gt;</code> 要素の <code class="literal">person_id</code> 属性の値は <code class="literal">address</code> テーブルにインポートされ<span class="emphasis"><em>ます</em></span>。
    </p><p><b>セキュリティー上の考慮事項 </b>
        <code class="literal">LOAD DATA</code> ステートメントと同様に、クライアントホストからサーバーホストへの XML ファイルの転送は MySQL サーバーによって開始されます。理論上は、<code class="literal">LOAD XML</code> ステートメント内でクライアントによって指定されたファイルではなく、サーバーが選択したファイルを転送するようにクライアントプログラムに指示する、パッチが適用されたサーバーを構築できます。そのようなサーバーは、クライアントユーザーが読み取りアクセス権を持つクライアントホスト上のすべてのファイルにアクセスできます。
      </p><p>
      Web 環境では、クライアントは通常、Web サーバーから MySQL に接続します。MySQL サーバーに対して任意のコマンドを実行できるユーザーは、<code class="literal">LOAD XML LOCAL</code> を使用して、Web サーバープロセスが読み取りアクセス権を持つどのファイルでも読み取ることができます。この環境では、そのクライアントは MySQL サーバーに対して、Web サーバーに接続するユーザーによって実行されているリモートプログラムではなく、実際に Web サーバーです。
    </p><p>
      <code class="literal">--local-infile=0</code> または <code class="literal">--local-infile=OFF</code> を使用してサーバーを起動することによって、クライアントからの XML ファイルのロードを無効にすることができます。このオプションはまた、クライアントセッションの期間中は <code class="literal">LOAD XML</code> を無効にするように <span class="command"><strong>mysql</strong></span> クライアントを起動する場合にも使用できます。
    </p><p>
      クライアントがサーバーから XML ファイルをロードしないようにするために、対応する MySQL ユーザーアカウントには <code class="literal">FILE</code> 権限を付与しないようにするか、またはクライアントユーザーアカウントがすでにこの権限を持っている場合は取り消してください。
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        <code class="literal">FILE</code> 権限を取り消した (または、最初から付与しない) 場合、そのユーザーは <code class="literal">LOAD XML INFILE</code> ステートメント (および <code class="literal">LOAD_FILE()</code> 関数) を実行できなくなるだけです。<code class="literal">LOAD XML LOCAL INFILE</code> の実行は妨げられ<span class="emphasis"><em>ません</em></span>。このステートメントを禁止するには、サーバーまたはクライアントを <code class="option">--local-infile=OFF</code> で起動する必要があります。
      </p><p>
        つまり、<code class="literal">FILE</code> 権限は、そのクライアントがサーバー上のファイルを読み取れるかどうかにのみ影響を与えます。そのクライアントがローカルファイルシステム上のファイルを読み取れるかどうかには関係しません。
      </p></div><p>
      テーブルロックを採用したストレージエンジン (<code class="literal">MyISAM</code> など) を使用しているパーティション化されたテーブルの場合、<code class="literal">LOAD XML</code> はどのパーティションロックもプルーニングできません。これは、行レベルロックを採用したストレージエンジン (<code class="literal">InnoDB</code> など) を使用しているテーブルには適用されません。詳細は、<a class="xref" href="partitioning.html#partitioning-limitations-locking" title="19.6.4 パーティショニングとロック">セクション19.6.4「パーティショニングとロック」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replace"></a>13.2.8 REPLACE 構文</h3></div></div></div><a class="indexterm" name="idm139979084432432"></a><pre class="programlisting">
REPLACE [LOW_PRIORITY | DELAYED]
    [INTO] <em class="replaceable"><code>tbl_name</code></em>
    [PARTITION (<em class="replaceable"><code>partition_name</code></em>,...)] 
    [(<em class="replaceable"><code>col_name</code></em>,...)]
    {VALUES | VALUE} ({<em class="replaceable"><code>expr</code></em> | DEFAULT},...),(...),...
</pre><p>
      または:
    </p><pre class="programlisting">
REPLACE [LOW_PRIORITY | DELAYED]
    [INTO] <em class="replaceable"><code>tbl_name</code></em>
    [PARTITION (<em class="replaceable"><code>partition_name</code></em>,...)] 
    SET <em class="replaceable"><code>col_name</code></em>={<em class="replaceable"><code>expr</code></em> | DEFAULT}, ...
</pre><p>
      または:
    </p><pre class="programlisting">
REPLACE [LOW_PRIORITY | DELAYED]
    [INTO] <em class="replaceable"><code>tbl_name</code></em>
    [PARTITION (<em class="replaceable"><code>partition_name</code></em>,...)]  
    [(<em class="replaceable"><code>col_name</code></em>,...)]
    SELECT ...
</pre><p>
      <code class="literal">REPLACE</code> は、<code class="literal">INSERT</code> とまったく同じように機能します。ただし、テーブル内の古い行に、<code class="literal">PRIMARY KEY</code> または <code class="literal">UNIQUE</code> インデックスに関して新しい行と同じ値が含まれている場合、その古い行は新しい行が挿入される前に削除されます。<a class="xref" href="sql-syntax.html#insert" title="13.2.5 INSERT 構文">セクション13.2.5「INSERT 構文」</a>を参照してください。
    </p><p>
      <code class="literal">REPLACE</code> は、SQL 標準への MySQL 拡張です。これは挿入を行うか、または<span class="emphasis"><em>削除</em></span>と挿入を行います。標準 SQL への別の MySQL 拡張 (挿入または<span class="emphasis"><em>更新</em></span>を行います) については、<a class="xref" href="sql-syntax.html#insert-on-duplicate" title="13.2.5.3 INSERT ... ON DUPLICATE KEY UPDATE 構文">セクション13.2.5.3「INSERT ... ON DUPLICATE KEY UPDATE 構文」</a>を参照してください。
    </p><p>
      テーブルに <code class="literal">PRIMARY KEY</code> または <code class="literal">UNIQUE</code> インデックスが存在しないかぎり、<code class="literal">REPLACE</code> ステートメントを使用しても何も意味がありません。新しい行が別の行を複製したかどうかを判定するために使用されるインデックスが存在しないため、それは <code class="literal">INSERT</code> と同等になります。
    </p><p>
      すべてのカラムの値が <code class="literal">REPLACE</code> ステートメントで指定されている値から取得されます。カラムがない場合は、<code class="literal">INSERT</code> での処理と同様に、そのカラムはそのデフォルト値に設定されます。現在の行の値を参照し、それを新しい行で使用することはできません。<code class="literal">SET <em class="replaceable"><code>col_name</code></em> = <em class="replaceable"><code>col_name</code></em> + 1</code> などの代入を使用した場合、右側にあるカラム名への参照は <code class="literal">DEFAULT(<em class="replaceable"><code>col_name</code></em>)</code> として処理されるため、この代入は <code class="literal">SET <em class="replaceable"><code>col_name</code></em> = DEFAULT(<em class="replaceable"><code>col_name</code></em>) + 1</code> と同等です。
    </p><p>
      <code class="literal">REPLACE</code> を使用するには、このテーブルに対する <code class="literal">INSERT</code> 権限と <code class="literal">DELETE</code> 権限の両方が必要です。
    </p><p>
      MySQL 5.6.2 から、<code class="literal">REPLACE</code> は、パーティション、サブパーティション、またはその両方の名前のカンマ区切りリストを含む <code class="literal">PARTITION</code> オプションを使用した明示的なパーティション選択をサポートしています。<code class="literal">INSERT</code> と同様に、これらのいずれかのパーティションまたはサブパーティションに新しい行を挿入できない場合、<code class="literal">REPLACE</code> ステートメントは <span class="errortext">Found a row not matching the given partition set</span>.エラーで失敗します。詳細は、<a class="xref" href="partitioning.html#partitioning-selection" title="19.5 パーティション選択">セクション19.5「パーティション選択」</a>を参照してください。
    </p><p>
      <code class="literal">REPLACE</code> は、影響を受けた行数を示す数を返します。これは、削除された行と挿入された行の合計です。この数が単一行の <code class="literal">REPLACE</code> に対して 1 である場合は、行が挿入され、削除された行はありませんでした。この数が 1 より大きい場合は、新しい行が挿入される前に 1 つ以上の古い行が削除されました。テーブルに複数の一意のインデックスが存在するときに、新しい行が異なる一意のインデックス内の別の古い行の値を複製した場合は、単一行が複数の古い行を置き換えることがあります。
    </p><p>
      影響を受けた行数により、<code class="literal">REPLACE</code> が行を追加しただけか、または行の置き換えも行なったかを判定することが容易になります。その数が 1 (追加した) か、またはそれより大きい (置き換えた) かをチェックします。
    </p><p>
      C API を使用している場合は、<code class="literal">mysql_affected_rows()</code> 関数を使用して、影響を受けた行数を取得できます。
    </p><p>
      現在、テーブルへの置き換えを行い、さらにサブクエリーで同じテーブルから選択することはできません。
    </p><p>
      MySQL は、<code class="literal">REPLACE</code> (および <code class="literal">LOAD DATA ... REPLACE</code>) に次のアルゴリズムを使用します。
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          テーブルへの新しい行の挿入を試みます
        </p></li><li class="listitem"><p>
          主キーまたは一意のインデックスに関する重複キーエラーが発生したために挿入が失敗している間、次のことを行います。
        </p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>
              重複キー値を含む競合している行をテーブルから削除します
            </p></li><li class="listitem"><p>
              テーブルへの新しい行の挿入を再試行します
            </p></li></ol></div></li></ol></div><p>
      重複キーエラーが発生した場合、ストレージエンジンが削除と挿入ではなく、更新として <code class="literal">REPLACE</code> を実行する可能性がありますが、そのセマンティクスは同じです。ストレージエンジンが <code class="literal">Handler_<em class="replaceable"><code>xxx</code></em></code> ステータス変数を増分する方法が異なる可能性がある以外、ユーザーに見える影響はありません。
    </p><p>
      <code class="literal">REPLACE ... SELECT</code> ステートメントの結果は <code class="literal">SELECT</code> からの行の順序に依存し、またこの順序を常に保証することはできないため、ロギング時に、これらのステートメントがマスターとスレーブで異なる可能性があります。このため、MySQL 5.6.4 以降では、<code class="literal">REPLACE ... SELECT</code> ステートメントには、ステートメントベースのレプリケーションには安全でないというフラグが付けられます。この変更により、このようなステートメントは、<code class="literal">STATEMENT</code> バイナリロギングモードを使用しているときはログ内に警告を生成し、<code class="literal">MIXED</code> モードを使用しているときは行ベース形式を使用してログに記録されます。<a class="xref" href="replication.html#replication-sbr-rbr" title="17.1.2.1 ステートメントベースおよび行ベースレプリケーションのメリットとデメリット">セクション17.1.2.1「ステートメントベースおよび行ベースレプリケーションのメリットとデメリット」</a>も参照してください。
    </p><p>
      パーティション化されていない既存のテーブルをパーティション化に対応するように変更しているときや、すでにパーティション化されたテーブルのパーティション化を変更しているときに、そのテーブルの主キーの変更を検討する可能性があります (<a class="xref" href="partitioning.html#partitioning-limitations-partitioning-keys-unique-keys" title="19.6.1 パーティショニングキー、主キー、および一意キー">セクション19.6.1「パーティショニングキー、主キー、および一意キー」</a>を参照してください)。これを行うと、パーティション化されていないテーブルの主キーを変更した場合と同様に、<code class="literal">REPLACE</code> ステートメントの結果が影響を受ける可能性があります。次の <code class="literal">CREATE TABLE</code> ステートメントによって作成されたテーブルを考えてみます。
    </p><pre class="programlisting">
CREATE TABLE test (
  id INT UNSIGNED NOT NULL AUTO_INCREMENT,
  data VARCHAR(64) DEFAULT NULL,
  ts TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (id)
);
</pre><p>
      このテーブルを作成し、mysql クライアントに示されているステートメントを実行すると、結果は次のようになります。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>REPLACE INTO test VALUES (1, 'Old', '2014-08-20 18:47:00');</code></strong>
Query OK, 1 row affected (0.04 sec)

mysql&gt; <strong class="userinput"><code>REPLACE INTO test VALUES (1, 'New', '2014-08-20 18:47:42');</code></strong>
Query OK, 2 rows affected (0.04 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM test;</code></strong> 
+----+------+---------------------+
| id | data | ts                  |
+----+------+---------------------+
|  1 | New  | 2014-08-20 18:47:42 |
+----+------+---------------------+
1 row in set (0.00 sec)
</pre><p>
      ここで、次に示すように (強調表示されたテキスト) 主キーが 2 つのカラムになっている点を除き、最初のテーブルとほぼ同一の 2 番目のテーブルを作成します。
    </p><pre class="programlisting">
CREATE TABLE test2 (
  id INT UNSIGNED NOT NULL AUTO_INCREMENT,
  data VARCHAR(64) DEFAULT NULL,
  ts TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  <span class="emphasis"><em>PRIMARY KEY (id, ts)</em></span>
);
</pre><p>
      元の <code class="literal">test</code> テーブルに対して実行したのと同じ 2 つの <code class="literal">REPLACE</code> ステートメントを <code class="literal">test2</code> に対して実行すると、異なる結果が得られます。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>REPLACE INTO test2 VALUES (1, 'Old', '2014-08-20 18:47:00');</code></strong>
Query OK, 1 row affected (0.05 sec)

mysql&gt; <strong class="userinput"><code>REPLACE INTO test2 VALUES (1, 'New', '2014-08-20 18:47:42');</code></strong>
Query OK, 1 row affected (0.06 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM test2;</code></strong>
+----+------+---------------------+
| id | data | ts                  |
+----+------+---------------------+
|  1 | Old  | 2014-08-20 18:47:00 |
|  1 | New  | 2014-08-20 18:47:42 |
+----+------+---------------------+
2 rows in set (0.00 sec)
</pre><p>
      これは、<code class="literal">test2</code> に対して実行した場合は <code class="literal">id</code> カラムと <code class="literal">ts</code> カラムの両方の値が、置き換えられる行に対する既存の行の値に一致している必要があり、そうでないと行が挿入されるためです。
    </p><p>
      MySQL 5.6.6 より前は、テーブルレベルのロックを採用した <code class="literal">MyISAM</code> などのストレージエンジンを使用しているパーティション化されたテーブルに影響を与える <code class="literal">REPLACE</code> によって、そのテーブルのすべてのパーティションがロックされました。これは、<code class="literal">REPLACE ... PARTITION</code> ステートメントにも当てはまりました。(これは、行レベルロックを採用した <code class="literal">InnoDB</code> などのストレージエンジンでは発生しておらず、現在も発生しません。)MySQL 5.6.6 以降では、MySQL はパーティションロックプルーニングを使用します。これにより、そのテーブルのどのパーティション化カラムも更新されないかぎり、<code class="literal">REPLACE</code> ステートメントの <code class="literal">WHERE</code> 句に一致する行を含むパーティションだけが実際にロックされるようになります。そうでなければ、テーブル全体がロックされます。詳細は、<a class="xref" href="partitioning.html#partitioning-limitations-locking" title="19.6.4 パーティショニングとロック">セクション19.6.4「パーティショニングとロック」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="select"></a>13.2.9 SELECT 構文</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-syntax.html#select-into">13.2.9.1 SELECT ... INTO 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#join">13.2.9.2 JOIN 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#index-hints">13.2.9.3 インデックスヒントの構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#union">13.2.9.4 UNION 構文</a></span></dt></dl></div><a class="indexterm" name="idm139979084335888"></a><pre class="programlisting">
SELECT
    [ALL | DISTINCT | DISTINCTROW ]
      [HIGH_PRIORITY]
      [STRAIGHT_JOIN]
      [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]
      [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS]
    <em class="replaceable"><code>select_expr</code></em> [, <em class="replaceable"><code>select_expr</code></em> ...]
    [FROM <em class="replaceable"><code>table_references</code></em>
      [PARTITION <em class="replaceable"><code>partition_list</code></em>]
    [WHERE <em class="replaceable"><code>where_condition</code></em>]
    [GROUP BY {<em class="replaceable"><code>col_name</code></em> | <em class="replaceable"><code>expr</code></em> | <em class="replaceable"><code>position</code></em>}
      [ASC | DESC], ... [WITH ROLLUP]]
    [HAVING <em class="replaceable"><code>where_condition</code></em>]
    [ORDER BY {<em class="replaceable"><code>col_name</code></em> | <em class="replaceable"><code>expr</code></em> | <em class="replaceable"><code>position</code></em>}
      [ASC | DESC], ...]
    [LIMIT {[<em class="replaceable"><code>offset</code></em>,] <em class="replaceable"><code>row_count</code></em> | <em class="replaceable"><code>row_count</code></em> OFFSET <em class="replaceable"><code>offset</code></em>}]
    [PROCEDURE <em class="replaceable"><code>procedure_name</code></em>(<em class="replaceable"><code>argument_list</code></em>)]
    [INTO OUTFILE '<em class="replaceable"><code>file_name</code></em>'
        [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>]
        <em class="replaceable"><code>export_options</code></em>
      | INTO DUMPFILE '<em class="replaceable"><code>file_name</code></em>'
      | INTO <em class="replaceable"><code>var_name</code></em> [, <em class="replaceable"><code>var_name</code></em>]]
    [FOR UPDATE | LOCK IN SHARE MODE]]
</pre><p>
      <code class="literal">SELECT</code> は、1 つ以上のテーブルから選択された行を取得するために使用され、<code class="literal">UNION</code> ステートメントとサブクエリーを含めることができます。<a class="xref" href="sql-syntax.html#union" title="13.2.9.4 UNION 構文">セクション13.2.9.4「UNION 構文」</a>および<a class="xref" href="sql-syntax.html#subqueries" title="13.2.10 サブクエリー構文">セクション13.2.10「サブクエリー構文」</a>を参照してください。
    </p><p>
      <code class="literal">SELECT</code> ステートメントのもっとも一般的に使用される句は次のとおりです。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          各 <em class="replaceable"><code>select_expr</code></em> は、取得するカラムを示します。少なくとも 1 つの <em class="replaceable"><code>select_expr</code></em> が存在する必要があります。
        </p></li><li class="listitem"><p>
          <em class="replaceable"><code>table_references</code></em> は、行を取得する 1 つまたは複数のテーブルを示します。その構文については、<a class="xref" href="sql-syntax.html#join" title="13.2.9.2 JOIN 構文">セクション13.2.9.2「JOIN 構文」</a>で説明されています。
        </p></li><li class="listitem"><p>
          MySQL 5.6.2 から、<code class="literal">SELECT</code> は、<em class="replaceable"><code>table_reference</code></em> 内のテーブル名のあとにパーティションまたはサブパーティション (またはその両方) のリストを含む <code class="literal">PARTITION</code> キーワードを使用した明示的なパーティション選択をサポートしています (<a class="xref" href="sql-syntax.html#join" title="13.2.9.2 JOIN 構文">セクション13.2.9.2「JOIN 構文」</a>を参照してください)。この場合、行はリストされているパーティションからのみ選択され、テーブルのほかのパーティションはすべて無視されます。詳細および例については、<a class="xref" href="partitioning.html#partitioning-selection" title="19.5 パーティション選択">セクション19.5「パーティション選択」</a>を参照してください。
        </p><p>
          MySQL 5.6.6 以降では、テーブルレベルのロック (つまり、パーティションロック) を実行する <code class="literal">MyISAM</code> などのストレージエンジンを使用しているテーブルからの <code class="literal">SELECT ... PARTITION</code> では、<code class="literal">PARTITION</code> オプションで指定されているパーティションまたはサブパーティションのみがロックされます。
        </p><p>
          詳細は、<a class="xref" href="partitioning.html#partitioning-limitations-locking" title="19.6.4 パーティショニングとロック">セクション19.6.4「パーティショニングとロック」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">WHERE</code> 句 (指定されている場合) は、選択されるために行が満たす必要のある 1 つまたは複数の条件を示します。<em class="replaceable"><code>where_condition</code></em> は、選択される各行に対して true に評価される式です。<code class="literal">WHERE</code> 句がない場合、このステートメントはすべての行を選択します。
        </p><p>
          <code class="literal">WHERE</code> 式では、集約 (サマリー) 関数を除き、MySQL がサポートするすべての関数および演算子を使用できます。<a class="xref" href="language-structure.html#expressions" title="9.5 式の構文">セクション9.5「式の構文」</a>および<a class="xref" href="functions.html" title="第 12 章 関数と演算子">第12章「<i>関数と演算子</i>」</a>を参照してください。
        </p></li></ul></div><p>
      <code class="literal">SELECT</code> を使用して、どのテーブルも参照せずに計算された行を取得することもできます。
    </p><p>
      例:
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT 1 + 1;</code></strong>
        -&gt; 2
</pre><p>
      <a class="indexterm" name="idm139979084287648"></a> テーブルが参照されない状況では、ダミーのテーブル名として <code class="literal">DUAL</code> を指定することが許可されます。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT 1 + 1 FROM DUAL;</code></strong>
        -&gt; 2
</pre><p>
      <code class="literal">DUAL</code> は純粋に、すべての <code class="literal">SELECT</code> ステートメントに <code class="literal">FROM</code> や、場合によってはその他の句が存在することを要求するユーザーの便宜のために用意されています。MySQL は、これらの句を無視する可能性があります。MySQL では、テーブルが参照されない場合でも <code class="literal">FROM DUAL</code> は必要ありません。
    </p><p>
      一般に、使用される句は、正確に構文の説明で示されている順序で指定する必要があります。たとえば、<code class="literal">HAVING</code> 句は、すべての <code class="literal">GROUP BY</code> 句のあとで、かつすべての <code class="literal">ORDER BY</code> 句の前にある必要があります。例外として、<code class="literal">INTO</code> 句は、構文の説明で示されている位置か、または <em class="replaceable"><code>select_expr</code></em> リストの直後のどちらにも現れることができます。<code class="literal">INTO</code> の詳細は、<a class="xref" href="sql-syntax.html#select-into" title="13.2.9.1 SELECT ... INTO 構文">セクション13.2.9.1「SELECT ... INTO 構文」</a>を参照してください。
    </p><p>
      <em class="replaceable"><code>select_expr</code></em> 項のリストは、どのカラムを取得するかを示す選択リストで構成されています。これらの項はカラムや式を指定するか、または <code class="literal">*</code> の短縮形を使用できます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          1 つの修飾されていない <code class="literal">*</code> のみから成る選択リストは、すべてのテーブルのすべてのカラムを選択するための短縮形として使用できます。
        </p><pre class="programlisting">
SELECT * FROM t1 INNER JOIN t2 ...
</pre></li><li class="listitem"><p>
          <code class="literal"><em class="replaceable"><code>tbl_name</code></em>.*</code> は、指定されたテーブルのすべてのカラムを選択するための修飾された短縮形として使用できます。
        </p><pre class="programlisting">
SELECT t1.*, t2.* FROM t1 INNER JOIN t2 ...
</pre></li><li class="listitem"><p>
          修飾されていない <code class="literal">*</code> を選択リスト内のほかの項目とともに使用すると、解析エラーが生成される可能性があります。この問題を回避するには、修飾された <code class="literal"><em class="replaceable"><code>tbl_name</code></em>.*</code> 参照を使用します。
        </p><pre class="programlisting">
SELECT AVG(score), t1.* FROM t1 ...
</pre></li></ul></div><p>
      次のリストは、その他の <code class="literal">SELECT</code> 句に関する追加情報を示しています。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="indexterm" name="idm139979084259808"></a> <a class="indexterm" name="idm139979084257664"></a> <code class="literal">AS <em class="replaceable"><code>alias_name</code></em></code> を使用して、<em class="replaceable"><code>select_expr</code></em> にエイリアスを指定できます。エイリアスは式のカラム名として使用され、<code class="literal">GROUP BY</code>、<code class="literal">ORDER BY</code>、または <code class="literal">HAVING</code> 句で使用できます。例:
        </p><pre class="programlisting">
SELECT CONCAT(last_name,', ',first_name) AS full_name
  FROM mytable ORDER BY full_name;
</pre><p>
          <em class="replaceable"><code>select_expr</code></em> にエイリアスとして識別子を指定する場合、<code class="literal">AS</code> キーワードはオプションです。前の例は、次のように記述することもできました。
        </p><pre class="programlisting">
SELECT CONCAT(last_name,', ',first_name) full_name
  FROM mytable ORDER BY full_name;
</pre><p>
          ただし、<code class="literal">AS</code> はオプションであるため、2 つの <em class="replaceable"><code>select_expr</code></em> 式の間のカンマを忘れると、軽微な問題が発生する可能性があります。MySQL は、2 番目の式をエイリアスとして解釈します。たとえば、次のステートメントでは、<code class="literal">columnb</code> はエイリアスとして処理されます。
        </p><pre class="programlisting">
SELECT columna columnb FROM mytable;
</pre><p>
          このため、カラムのエイリアスを指定するときは <code class="literal">AS</code> を明示的に使用するようにすることをお勧めします。
        </p><p>
          <code class="literal">WHERE</code> 句が実行されるときはまだカラム値が決定されていない可能性があるため、<code class="literal">WHERE</code> 句内でカラムのエイリアスを参照することは許可されません。<a class="xref" href="error-handling.html#problems-with-alias" title="B.5.5.4 カラムエイリアスに関する問題">セクションB.5.5.4「カラムエイリアスに関する問題」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979084240304"></a> <a class="indexterm" name="idm139979084238992"></a> <code class="literal">FROM <em class="replaceable"><code>table_references</code></em></code> 句は、行を取得する 1 つまたは複数のテーブルを示します。複数のテーブルを指定すると、結合が実行されます。結合構文については、<a class="xref" href="sql-syntax.html#join" title="13.2.9.2 JOIN 構文">セクション13.2.9.2「JOIN 構文」</a>を参照してください。指定されたテーブルごとに、オプションでエイリアスを指定できます。
        </p><pre class="programlisting">
<em class="replaceable"><code>tbl_name</code></em> [[AS] <em class="replaceable"><code>alias</code></em>] [<em class="replaceable"><code>index_hint</code></em>]
</pre><a class="indexterm" name="idm139979084233504"></a><a class="indexterm" name="idm139979084232016"></a><p>
          インデックスヒントを使用すると、クエリー処理中にインデックスを選択する方法に関する情報がオプティマイザに提供されます。これらのヒントを指定するための構文については、<a class="xref" href="sql-syntax.html#index-hints" title="13.2.9.3 インデックスヒントの構文">セクション13.2.9.3「インデックスヒントの構文」</a>を参照してください。
        </p><p>
          代わりの方法として <code class="literal">SET max_seeks_for_key=<em class="replaceable"><code>value</code></em></code> を使用して、MySQL にテーブルスキャンの代わりにキースキャンを強制的に実行させることができます。<a class="xref" href="server-administration.html#server-system-variables" title="5.1.4 サーバーシステム変数">セクション5.1.4「サーバーシステム変数」</a>を参照してください。
        </p></li><li class="listitem"><p>
          データベースを明示的に指定するために、デフォルトデータベース内でテーブルを <em class="replaceable"><code>tbl_name</code></em> または <em class="replaceable"><code>db_name</code></em>.<em class="replaceable"><code>tbl_name</code></em> として参照できます。カラムを <em class="replaceable"><code>col_name</code></em>、<em class="replaceable"><code>tbl_name</code></em>.<em class="replaceable"><code>col_name</code></em> または <em class="replaceable"><code>db_name</code></em>.<em class="replaceable"><code>tbl_name</code></em>.<em class="replaceable"><code>col_name</code></em> として参照できます。参照があいまいにならないかぎり、カラム参照のために <em class="replaceable"><code>tbl_name</code></em> または <em class="replaceable"><code>db_name</code></em>.<em class="replaceable"><code>tbl_name</code></em> プリフィクスを指定する必要はありません。より明示的なカラム参照形式を必要とするあいまいさの例については、<a class="xref" href="language-structure.html#identifier-qualifiers" title="9.2.1 識別子の修飾子">セクション9.2.1「識別子の修飾子」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979084217824"></a> <a class="indexterm" name="idm139979084215712"></a> <code class="literal"><em class="replaceable"><code>tbl_name</code></em> AS <em class="replaceable"><code>alias_name</code></em></code> または <em class="replaceable"><code>tbl_name alias_name</code></em> を使用して、テーブル参照にエイリアスを指定できます。
        </p><pre class="programlisting">
SELECT t1.name, t2.salary FROM employee AS t1, info AS t2
  WHERE t1.name = t2.name;

SELECT t1.name, t2.salary FROM employee t1, info t2
  WHERE t1.name = t2.name;
</pre></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979084210944"></a> カラム名、カラムのエイリアス、またはカラム位置を使用して、出力のために選択されたカラムを <code class="literal">ORDER BY</code> および <code class="literal">GROUP BY</code> 句で参照できます。カラム位置は整数であり、1 から始まります。
        </p><pre class="programlisting">
SELECT college, region, seed FROM tournament
  ORDER BY region, seed;

SELECT college, region AS r, seed AS s FROM tournament
  ORDER BY r, s;

SELECT college, region, seed FROM tournament
  ORDER BY 2, 3;
</pre><p>
          逆の順序でソートするには、ソートに使用する <code class="literal">ORDER BY</code> 句内のカラムの名前に <code class="literal">DESC</code> (降順) キーワードを追加します。デフォルトは昇順です。これは、<code class="literal">ASC</code> キーワードを使用して明示的に指定できます。
        </p><p>
          <code class="literal">ORDER BY</code> がサブクエリー内で発生し、外側のクエリー内でも適用される場合は、もっとも外側の <code class="literal">ORDER BY</code> が優先されます。たとえば、次のステートメントの結果は昇順ではなく、降順でソートされます。
        </p><pre class="programlisting">
(SELECT ... ORDER BY a) ORDER BY a DESC;
</pre><p>
          カラム位置の使用は、この構文が SQL 標準から削除されたため非推奨です。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979084199360"></a> <a class="indexterm" name="idm139979084197328"></a> <code class="literal">GROUP BY</code> を使用すると、出力行は、同じカラムに対して <code class="literal">ORDER BY</code> を指定したかのように <code class="literal">GROUP BY</code> カラムに従ってソートされます。<code class="literal">GROUP BY</code> によって生成されるソートのオーバーヘッドを回避するには、<code class="literal">ORDER BY NULL</code> を追加します。
        </p><pre class="programlisting">
SELECT a, COUNT(b) FROM test_table GROUP BY a ORDER BY NULL;
</pre><p>
          MySQL 5.6 における暗黙の <code class="literal">GROUP BY</code> ソートへの依存は、非推奨になっています。グループ化された結果の特定のソート順序を実現するには、明示的な <code class="literal">ORDER BY</code> 句を使用することをお勧めします。<code class="literal">GROUP BY</code> ソートは、たとえば、オプティマイザがもっとも効率的であると考えるどのような方法でも、グループ化を指示できるようにしたり、ソートオーバーヘッドを回避したりするためなどに、今後のリリースで変更される可能性のある MySQL 拡張機能です。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979084186144"></a> MySQL では <code class="literal">GROUP BY</code> 句が拡張され、この句で指定されているカラムのあとに <code class="literal">ASC</code> と <code class="literal">DESC</code> も指定できるようになっています。
        </p><pre class="programlisting">
SELECT a, COUNT(b) FROM test_table GROUP BY a DESC;
</pre></li><li class="listitem"><p>
          MySQL では、<code class="literal">GROUP BY</code> の使用が、<code class="literal">GROUP BY</code> 句で指定されていないフィールドの選択を許可するように拡張されています。クエリーから期待する結果が得られない場合は、<a class="xref" href="functions.html#group-by-functions-and-modifiers" title="12.19 GROUP BY 句で使用される関数と修飾子">セクション12.19「GROUP BY 句で使用される関数と修飾子」</a>にある <code class="literal">GROUP BY</code> の説明を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">GROUP BY</code> では、<code class="literal">WITH ROLLUP</code> 修飾子が許可されます。<a class="xref" href="functions.html#group-by-modifiers" title="12.19.2 GROUP BY 修飾子">セクション12.19.2「GROUP BY 修飾子」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979084172944"></a> <code class="literal">HAVING</code> 句は、ほぼ最後 (項目がクライアントに送信される直前) に最適化なしで適用されます。(<code class="literal">LIMIT</code> は <code class="literal">HAVING</code> のあとに適用されます。)
        </p><p>
          SQL 標準では、<code class="literal">HAVING</code> は <code class="literal">GROUP BY</code> 句内のカラムか、または集約関数で使用されるカラムしか参照できません。ただし、MySQL ではこの動作への拡張がサポートされており、<code class="literal">HAVING</code> が <code class="literal">SELECT</code> リスト内のカラムや外側サブクエリー内のカラムを参照することも許可されます。
        </p><p>
          <code class="literal">HAVING</code> 句があいまいなカラムを参照している場合は、警告が発生します。次のステートメントにある <code class="literal">col2</code> は、エイリアスとカラム名の両方として使用されているため、あいまいです。
        </p><pre class="programlisting">
SELECT COUNT(col1) AS col2 FROM t GROUP BY col2 HAVING col2 = 2;
</pre><p>
          標準 SQL の動作の方が優先されるため、<code class="literal">HAVING</code> のカラム名が <code class="literal">GROUP BY</code> で使用されると同時に、出力カラムリスト内のエイリアスが指定されたカラムとしても使用されている場合は、<code class="literal">GROUP BY</code> カラム内のカラムが優先されます。
        </p></li><li class="listitem"><p>
          <code class="literal">WHERE</code> 句に含めるべき項目には <code class="literal">HAVING</code> を使用しないでください。たとえば、次のように記述しないでください。
        </p><pre class="programlisting">
SELECT <em class="replaceable"><code>col_name</code></em> FROM <em class="replaceable"><code>tbl_name</code></em> HAVING <em class="replaceable"><code>col_name</code></em> &gt; 0;
</pre><p>
          代わりに、次のように記述してください。
        </p><pre class="programlisting">
SELECT <em class="replaceable"><code>col_name</code></em> FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>col_name</code></em> &gt; 0;
</pre></li><li class="listitem"><p>
          <code class="literal">HAVING</code> 句は、<code class="literal">WHERE</code> 句が参照できない集約関数を参照できます。
        </p><pre class="programlisting">
SELECT user, MAX(salary) FROM users
  GROUP BY user HAVING MAX(salary) &gt; 10;
</pre><p>
          (これは、一部の古いバージョンの MySQL では機能しませんでした。)
        </p></li><li class="listitem"><p>
          MySQL では、重複したカラム名が許可されます。つまり、同じ名前を持つ複数の <em class="replaceable"><code>select_expr</code></em> が存在できます。これは、標準 SQL の拡張です。MySQL では <code class="literal">GROUP BY</code> や <code class="literal">HAVING</code> が <em class="replaceable"><code>select_expr</code></em> 値を参照することも許可されるため、これにより、あいまいさが発生する場合があります。
        </p><pre class="programlisting">
SELECT 12 AS a, a FROM t GROUP BY a;
</pre><p>
          このステートメントでは、どちらのカラムの名前も <code class="literal">a</code> です。グループ化のために正しいカラムが使用されるようにするために、<em class="replaceable"><code>select_expr</code></em> ごとに異なる名前を使用してください。
        </p></li><li class="listitem"><p>
          MySQL は、<code class="literal">ORDER BY</code> 句内の修飾されていないカラムまたはエイリアス参照を、まず <em class="replaceable"><code>select_expr</code></em> 値、次に <code class="literal">FROM</code> 句内のテーブルのカラム内を検索することによって解決します。<code class="literal">GROUP BY</code> または <code class="literal">HAVING</code> 句の場合は、<em class="replaceable"><code>select_expr</code></em> 値内を検索する前に <code class="literal">FROM</code> 句を検索します。(<code class="literal">GROUP BY</code> と <code class="literal">HAVING</code> について、これは、<code class="literal">ORDER BY</code>) の場合と同じルールを使用していた MySQL 5.0 より前の動作とは異なります。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979084132592"></a> <code class="literal">LIMIT</code> 句を使用すると、<code class="literal">SELECT</code> ステートメントによって返される行数を制約できます。<code class="literal">LIMIT</code> は 1 つまたは 2 つの数値引数を受け取ります。これは、どちらも負ではない整定数である必要があります。ただし、次の例外があります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              準備済みステートメント内では、<code class="literal">?</code> プレースホルダマーカーを使用して <code class="literal">LIMIT</code> パラメータを指定できます。
            </p></li><li class="listitem"><p>
              ストアドプログラム内では、整数値のルーチンパラメータまたはローカル変数を使用して <code class="literal">LIMIT</code> パラメータを指定できます。
            </p></li></ul></div><p>
          引数が 2 つの場合、最初の引数は返す先頭行のオフセットを指定し、2 番目の引数は返す行の最大数を指定します。最初の行のオフセットは (1 ではなく) 0 です。
        </p><pre class="programlisting">
SELECT * FROM tbl LIMIT 5,10;  # Retrieve rows 6-15
</pre><p>
          特定のオフセットから結果セットの最後までのすべての行を取得するために、2 番目のパラメータにある程度大きい数字を使用できます。次のステートメントは、96 行目から最後の行までのすべての行を取得します。
        </p><pre class="programlisting">
SELECT * FROM tbl LIMIT 95,18446744073709551615;
</pre><p>
          引数が 1 つの場合、この値は、結果セットの先頭から返す行数を指定します。
        </p><pre class="programlisting">
SELECT * FROM tbl LIMIT 5;     # Retrieve first 5 rows
</pre><p>
          つまり、<code class="literal">LIMIT <em class="replaceable"><code>row_count</code></em></code> は <code class="literal">LIMIT 0, <em class="replaceable"><code>row_count</code></em></code> と同等です。
        </p><p>
          準備済みステートメントでは、プレースホルダを使用できます。次のステートメントは、<code class="literal">tbl</code> テーブルの 1 行を返します。
        </p><pre class="programlisting">
SET @a=1;
PREPARE STMT FROM 'SELECT * FROM tbl LIMIT ?';
EXECUTE STMT USING @a;
</pre><p>
          次のステートメントは、<code class="literal">tbl</code> テーブルの 2 行目から 6 行目までを返します。
        </p><pre class="programlisting">
SET @skip=1; SET @numrows=5;
PREPARE STMT FROM 'SELECT * FROM tbl LIMIT ?, ?';
EXECUTE STMT USING @skip, @numrows;
</pre><p>
          PostgreSQL との互換性のために、MySQL は <code class="literal">LIMIT <em class="replaceable"><code>row_count</code></em> OFFSET <em class="replaceable"><code>offset</code></em></code> 構文もサポートしています。
        </p><p>
          <code class="literal">LIMIT</code> がサブクエリー内に現れ、また外部クエリーでも適用される場合は、もっとも外側の <code class="literal">LIMIT</code> が優先されます。たとえば、次のステートメントは、1 行ではなく 2 行を生成します。
        </p><pre class="programlisting">
(SELECT ... LIMIT 1) LIMIT 2;
</pre></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979084106112"></a> <code class="literal">PROCEDURE</code> 句は、結果セット内のデータを処理するプロシージャーを指定します。例については、<a class="xref" href="optimization.html#procedure-analyse" title="8.4.2.4 PROCEDURE ANALYSE の使用">セクション8.4.2.4「PROCEDURE ANALYSE の使用」</a>を参照してください。ここでは、テーブルサイズの削減に役立つ可能性のある最適なカラムデータ型に関する提案を得るために使用できるプロシージャーである <code class="literal">ANALYSE</code> について説明しています。
        </p></li><li class="listitem"><p>
          <code class="literal">SELECT</code> の <code class="literal">SELECT ... INTO</code> 形式を使用すると、クエリー結果をファイルに書き込んだり、変数に格納したりできます。詳細は、<a class="xref" href="sql-syntax.html#select-into" title="13.2.9.1 SELECT ... INTO 構文">セクション13.2.9.1「SELECT ... INTO 構文」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979084097376"></a> <a class="indexterm" name="idm139979084096064"></a> ページまたは行ロックを使用するストレージエンジンで <code class="literal">FOR UPDATE</code> を使用した場合、クエリーによって検査される行は、現在のトランザクションの最後まで書き込みがロックされます。<code class="literal">LOCK IN SHARE MODE</code> を使用すると、その検査される行のほかのトランザクションによる読み取りは許可するが、その更新または削除を許可しない共有ロックが設定されます。<a class="xref" href="innodb-storage-engine.html#innodb-locking-reads" title="14.2.5 ロック読み取り (SELECT ... FOR UPDATE および SELECT ... LOCK IN SHARE MODE)">セクション14.2.5「ロック読み取り (SELECT ... FOR UPDATE および SELECT ... LOCK IN SHARE MODE)」</a>を参照してください。
        </p><p>
          さらに、<code class="literal">CREATE TABLE <em class="replaceable"><code>new_table</code></em> SELECT ... FROM <em class="replaceable"><code>old_table</code></em> ...</code> などのステートメントで <code class="literal">SELECT</code> の一部として <code class="literal">FOR UPDATE</code> を使用することはできません。(それを行おうとすると、このステートメントはエラー <span class="errortext">Can't update table '<em class="replaceable"><code>old_table</code></em>' while '<em class="replaceable"><code>new_table</code></em>' is being created</span> で拒否されます。)これは、<code class="literal">CREATE TABLE ... SELECT</code> ステートメントが作成されているテーブル以外のテーブルで変更を行うことを許可していた、MySQL 5.5 およびそれ以前からの動作の変更です。
        </p></li></ul></div><p>
      <code class="literal">SELECT</code> キーワードのあとに、このステートメントの操作に影響を与えるいくつかのオプションを使用できます。<code class="literal">HIGH_PRIORITY</code>、<code class="literal">STRAIGHT_JOIN</code>、および <code class="literal">SQL_</code> で始まるオプションは、標準 SQL への MySQL 拡張です。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="indexterm" name="idm139979084078816"></a> <a class="indexterm" name="idm139979084077536"></a> <a class="indexterm" name="idm139979084076192"></a> <code class="literal">ALL</code> および <code class="literal">DISTINCT</code> オプションは、重複した行を返すかどうかを指定します。<code class="literal">ALL</code> (デフォルト) は、重複を含め、一致するすべての行を返すように指定します。<code class="literal">DISTINCT</code> は、重複した行の結果セットからの削除を指定します。両方のオプションを指定するとエラーになります。<code class="literal">DISTINCTROW</code> は <code class="literal">DISTINCT</code> のシノニムです。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979084069168"></a> <code class="literal">HIGH_PRIORITY</code> は <code class="literal">SELECT</code> に、テーブルを更新するステートメントより高い優先度を与えます。これは、非常に高速であり、かつただちに実行する必要のあるクエリーにのみ使用するようにしてください。テーブルが読み取りに対してロックされている間に発行された <code class="literal">SELECT HIGH_PRIORITY</code> クエリーは、そのテーブルが未使用になるのを待機している更新ステートメントが存在する場合でも実行されます。これは、テーブルレベルロックのみを使用するストレージエンジン (<code class="literal">MyISAM</code>、<code class="literal">MEMORY</code>、および <code class="literal">MERGE</code>) にのみ影響を与えます。
        </p><p>
          <code class="literal">HIGH_PRIORITY</code> を、<code class="literal">UNION</code> の一部である <code class="literal">SELECT</code> ステートメントで使用することはできません。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979084058064"></a> <code class="literal">STRAIGHT_JOIN</code> は、オプティマイザに、テーブルを <code class="literal">FROM</code> 句にリストされている順序で強制的に結合させます。オプティマイザがテーブルを最適でない順序で結合する場合は、これを使用してクエリーを高速化できます。<code class="literal">STRAIGHT_JOIN</code> はまた、<em class="replaceable"><code>table_references</code></em> リストでも使用できます。<a class="xref" href="sql-syntax.html#join" title="13.2.9.2 JOIN 構文">セクション13.2.9.2「JOIN 構文」</a>を参照してください。
        </p><p>
          <a class="indexterm" name="idm139979084052416"></a> <a class="indexterm" name="idm139979084050288"></a> <code class="literal">STRAIGHT_JOIN</code> は、オプティマイザが <code class="literal">const</code> テーブルまたは <code class="literal">system</code> テーブルとして処理するテーブルには適用されません。このようなテーブルは単一行を生成し、クエリー実行の最適化フェーズ中に読み取られます。また、そのカラムへの参照は、クエリー実行が続行される前に適切なカラム値で置き換えられます。これらのテーブルは、<code class="literal">EXPLAIN</code> によって表示されるクエリー計画に最初に表示されます。「<a class="xref" href="optimization.html#using-explain" title="8.8.1 EXPLAIN によるクエリーの最適化">セクション8.8.1「EXPLAIN によるクエリーの最適化」</a>」を参照してください。この例外は、外部結合の <code class="literal">NULL</code> で補完された側で使用されている <code class="literal">const</code> テーブルまたは <code class="literal">system</code> テーブル (つまり、<code class="literal">LEFT JOIN</code> の右側のテーブルまたは <code class="literal">RIGHT JOIN</code> の左側のテーブル) には適用されない可能性があります。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979084037856"></a> <a class="indexterm" name="idm139979084036512"></a> <code class="literal">SQL_BIG_RESULT</code> または <code class="literal">SQL_SMALL_RESULT</code> は、結果セットの行数がそれぞれ多いこと、または少ないことをオプティマイザに通知するために <code class="literal">GROUP BY</code> または <code class="literal">DISTINCT</code> とともに使用できます。<code class="literal">SQL_BIG_RESULT</code> の場合、MySQL は、必要に応じてディスクベースの一時テーブルを直接使用し、ソートでは <code class="literal">GROUP BY</code> 要素に関するキーで一時テーブルを使用することを優先します。<code class="literal">SQL_SMALL_RESULT</code> の場合、MySQL はソートを使用する代わりに、高速な一時テーブルを使用して結果のテーブルを格納します。これは、通常は必要ないはずです。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979084028288"></a> <code class="literal">SQL_BUFFER_RESULT</code> は、結果を強制的に一時テーブルに配置します。これは、MySQL がテーブルロックを早期に解放する場合や、結果セットをクライアントに送信するのに長い時間がかかる場合に役立ちます。このオプションは、サブクエリーまたは後続の <code class="literal">UNION</code> ではなく、トップレベルの <code class="literal">SELECT</code> ステートメントでのみ使用できます。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979084022704"></a> <code class="literal">SQL_CALC_FOUND_ROWS</code> は MySQL に、<code class="literal">LIMIT</code> 句をすべて無視して、結果セットに含まれる行数を計算するよう指示します。そのあと、行数は <code class="literal">SELECT FOUND_ROWS()</code> を使用して取得できます。<a class="xref" href="functions.html#information-functions" title="12.14 情報関数">セクション12.14「情報関数」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979084017376"></a> <a class="indexterm" name="idm139979084016064"></a> <code class="literal">SQL_CACHE</code> および <code class="literal">SQL_NO_CACHE</code> オプションは、クエリーキャッシュ内のクエリー結果のキャッシュに影響を与えます (<a class="xref" href="optimization.html#query-cache" title="8.9.3 MySQL クエリーキャッシュ">セクション8.9.3「MySQL クエリーキャッシュ」</a>を参照してください)。<code class="literal">SQL_CACHE</code> は MySQL に、結果がキャッシュ可能であり、<code class="literal">query_cache_type</code> システム変数の値が <code class="literal">2</code> または <code class="literal">DEMAND</code> である場合は、結果をクエリーキャッシュに格納するよう指示します。<code class="literal">SQL_NO_CACHE</code> を指定すると、サーバーはクエリーキャッシュを使用しません。それは、結果がすでにキャッシュされているかどうかを確認するためにクエリーキャッシュをチェックせず、クエリー結果もキャッシュしません。(パーサーの制限のため、スペース文字の前後に <code class="literal">SQL_NO_CACHE</code> キーワードを付ける必要があります。改行などのスペース以外では、結果がすでにキャッシュされているかどうかを確認するために、サーバーにクエリーキャッシュをチェックさせます。)
        </p><p>
          ビューの場合、<code class="literal">SQL_NO_CACHE</code> は、クエリー内のいずれかの <code class="literal">SELECT</code> に現れた場合に適用されます。キャッシュ可能なクエリーでは、<code class="literal">SQL_CACHE</code> は、そのクエリーによって参照されるビューの最初の <code class="literal">SELECT</code> に現れた場合に適用されます。
        </p><p>
          MySQL 5.6 では、これらの 2 つのオプションは相互に排他的であり、両方が指定された場合はエラーが発生します。また、これらのオプションは、サブクエリー (<code class="literal">FROM</code> 句内のサブクエリーを含む) や、最初の <code class="literal">SELECT</code> を除く和集合内の <code class="literal">SELECT</code> ステートメント内では許可されません。
        </p></li></ul></div><p>
      MySQL 5.6.6 より前は、テーブルレベルのロックを採用した <code class="literal">MyISAM</code> などのストレージエンジンを使用しているパーティション化されたテーブルからの <code class="literal">SELECT</code> によって、そのテーブルのすべてのパーティションがロックされました。これは、<code class="literal">SELECT ... PARTITION</code> クエリーにも当てはまりました。(これは、行レベルロックを採用した <code class="literal">InnoDB</code> などのストレージエンジンでは発生しておらず、現在も発生しません。)MySQL 5.6.6 以降では、MySQL はパーティションロックプルーニングを使用します。これにより、<code class="literal">SELECT</code> ステートメントの <code class="literal">WHERE</code> 句に一致する行を含むパーティションだけが実際にロックされるようになります。詳細は、<a class="xref" href="partitioning.html#partitioning-limitations-locking" title="19.6.4 パーティショニングとロック">セクション19.6.4「パーティショニングとロック」</a>を参照してください。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="select-into"></a>13.2.9.1 SELECT ... INTO 構文</h4></div></div></div><a class="indexterm" name="idm139979083989328"></a><a class="indexterm" name="idm139979083987328"></a><p>
        <code class="literal">SELECT</code> の <code class="literal">SELECT ... INTO</code> 形式を使用すると、クエリー結果を変数に格納したり、ファイルに書き込んだりできます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">SELECT ... INTO <em class="replaceable"><code>var_list</code></em></code> はカラム値を選択し、それらを変数に格納します。
          </p></li><li class="listitem"><p>
            <code class="literal">SELECT ... INTO OUTFILE</code> は、選択された行をファイルに書き込みます。カラムおよび行ターミネータを指定すると、特定の出力形式を生成できます。
          </p></li><li class="listitem"><p>
            <code class="literal">SELECT ... INTO DUMPFILE</code> は、単一行をファイルに形式設定なしで書き込みます。
          </p></li></ul></div><p>
        <code class="literal">SELECT</code> の構文の説明 (<a class="xref" href="sql-syntax.html#select" title="13.2.9 SELECT 構文">セクション13.2.9「SELECT 構文」</a>を参照してください) では、<code class="literal">INTO</code> 句がステートメントの最後の近くに示されています。<code class="literal">INTO</code> はまた、<em class="replaceable"><code>select_expr</code></em> リストの直後に使用することもできます。
      </p><p>
        ネストされた <code class="literal">SELECT</code> はその結果を外側のコンテキストに返す必要があるため、このような <code class="literal">SELECT</code> では <code class="literal">INTO</code> 句を使用してはいけません。
      </p><p>
        <code class="literal">INTO</code> 句は、1 つ以上の変数のリストを指定できます。この変数には、ユーザー定義変数、ストアドプロシージャーやストアドファンクションのパラメータ、またはストアドプログラムのローカル変数を指定できます。(準備済み <code class="literal">SELECT ... INTO OUTFILE</code> ステートメント内では、ユーザー定義変数のみが許可されます。<a class="xref" href="sql-syntax.html#local-variable-scope" title="13.6.4.2 ローカル変数のスコープと解決">セクション13.6.4.2「ローカル変数のスコープと解決」</a>を参照してください。)
      </p><p>
        選択された値は変数に割り当てられます。変数の数がカラム数に一致している必要があります。クエリーは、単一行を返すようにしてください。クエリーが行を返さない場合は、エラーコード 1329 で警告が発生し (<code class="literal">No data</code>)、変数値は変更されないままになります。クエリーが複数の行を返す場合は、エラー 1172 が発生します (<code class="literal">結果が 2 行以上です</code>)。このステートメントが複数の行を取得する可能性がある場合は、<code class="literal">LIMIT 1</code> を使用して結果セットを単一行に制限できます。
      </p><pre class="programlisting">
SELECT id, data INTO @x, @y FROM test.t1 LIMIT 1;
</pre><p>
        ユーザー変数名では大文字と小文字を区別しません。<a class="xref" href="language-structure.html#user-variables" title="9.4 ユーザー定義変数">セクション9.4「ユーザー定義変数」</a>を参照してください。
      </p><a class="indexterm" name="idm139979083959856"></a><a class="indexterm" name="idm139979083958544"></a><p>
        <code class="literal">SELECT</code> の <code class="literal">SELECT ... INTO OUTFILE '<em class="replaceable"><code>file_name</code></em>'</code> 形式は、選択された行をファイルに書き込みます。このファイルはサーバーホスト上で作成されるため、この構文を使用するには <code class="literal">FILE</code> 権限が必要です。<em class="replaceable"><code>file_name</code></em> を既存のファイルにすることはできません。これにより、特に <code class="filename">/etc/passwd</code> などのファイルやデータベーステーブルが破棄されることが回避されます。<code class="literal">character_set_filesystem</code> システム変数は、ファイル名の解釈を制御します。
      </p><p>
        <code class="literal">SELECT ... INTO OUTFILE</code> ステートメントは、主に、テーブルをサーバーマシン上のテキストファイルに非常にすばやくダンプできるようにすることを目的にしています。結果として得られるファイルをサーバーホスト以外のホスト上で作成する場合は通常、そのサーバーホストのファイルシステムを基準にしたファイルへのパスを記述する方法が存在しないため、<code class="literal">SELECT ... INTO OUTFILE</code> は使用できません。
      </p><p>
        ただし、MySQL クライアントソフトウェアがリモートマシンにインストールされている場合は、代わりに <code class="literal">mysql -e "SELECT ..." &gt; <em class="replaceable"><code>file_name</code></em></code> などのクライアントコマンドを使用してクライアントホスト上にファイルを生成できます。
      </p><p>
        また、サーバーのファイルシステム上でネットワークにマップされたパスを使用してリモートホスト上のファイルの場所にアクセスできる場合も、結果として得られるファイルをサーバーホストとは異なるホスト上に作成できます。この場合は、ターゲットホスト上に <span class="command"><strong>mysql</strong></span> (または、その他の何らかの MySQL クライアントプログラム) が存在する必要はありません。
      </p><p>
        <code class="literal">SELECT ... INTO OUTFILE</code> は、<code class="literal">LOAD DATA INFILE</code> を補完するものです。カラム値は、<code class="literal">CHARACTER SET</code> 句で指定されている文字セットに変換されて書き込まれます。このような句が存在しない場合、値は <code class="literal">binary</code> 文字セットを使用してダンプされます。事実上、文字セットの変換は実行されません。結果セットにカラムが複数の文字セットで含まれている場合は、出力データファイルにもそのまま含まれるため、そのファイルを正しくリロードできない可能性があります。
      </p><p>
        このステートメントの <em class="replaceable"><code>export_options</code></em> 部分の構文は、<code class="literal">LOAD DATA INFILE</code> ステートメントで使用されるのと同じ <code class="literal">FIELDS</code> および <code class="literal">LINES</code> 句で構成されています。<code class="literal">FIELDS</code> および <code class="literal">LINES</code> 句 (それぞれのデフォルト値と許可される値を含む) については、<a class="xref" href="sql-syntax.html#load-data" title="13.2.6 LOAD DATA INFILE 構文">セクション13.2.6「LOAD DATA INFILE 構文」</a>を参照してください。
      </p><p>
        <code class="literal">FIELDS ESCAPED BY</code> は、特殊文字を書き込む方法を制御します。<code class="literal">FIELDS ESCAPED BY</code> 文字が空でない場合、その文字は、出力上で次の文字の前に付けられるプリフィクスとして、あいまいさを避けるために必要な場合に使用されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">FIELDS ESCAPED BY</code> 文字
          </p></li><li class="listitem"><p>
            <code class="literal">FIELDS [OPTIONALLY] ENCLOSED BY</code> 文字
          </p></li><li class="listitem"><p>
            <code class="literal">FIELDS TERMINATED BY</code> および <code class="literal">LINES TERMINATED BY</code> 値の最初の文字
          </p></li><li class="listitem"><p>
            ASCII <code class="literal">NUL</code> (0 の値のバイト。エスケープ文字のあとに実際に書き込まれる文字は 0 の値のバイトではなく、ASCII の<span class="quote">「<span class="quote"><code class="literal">0</code></span>」</span>です)
          </p></li></ul></div><p>
        <code class="literal">FIELDS TERMINATED BY</code>、<code class="literal">ENCLOSED BY</code>、<code class="literal">ESCAPED BY</code>、または <code class="literal">LINES TERMINATED BY</code> 文字は、そのファイルを確実に読み戻すことができるように、エスケープする<span class="emphasis"><em>必要があります</em></span>。ASCII <code class="literal">NUL</code> は、一部のページャーで見やすくなるようにエスケープされます。
      </p><p>
        結果として得られるファイルは SQL 構文に準拠する必要はないため、ほかは何もエスケープする必要がありません。
      </p><p>
        <code class="literal">FIELDS ESCAPED BY</code> 文字が空である場合は、どの文字もエスケープされず、<code class="literal">NULL</code> は <code class="literal">\N</code> ではなく、<code class="literal">NULL</code> として出力されます。特に、データ内のフィールド値に今指定したリスト内のいずれかの文字が含まれている場合、空のエスケープ文字を指定することはおそらく適切な方法ではありません。
      </p><a class="indexterm" name="idm139979083911232"></a><a class="indexterm" name="idm139979083909712"></a><p>
        多くのプログラムで使用されているカンマ区切り値 (CSV) 形式のファイルを生成する例を次に示します。
      </p><pre class="programlisting">
SELECT a,b,a+b INTO OUTFILE '/tmp/result.txt'
  FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
  LINES TERMINATED BY '\n'
  FROM test_table;
</pre><a class="indexterm" name="idm139979083906896"></a><p>
        <code class="literal">INTO OUTFILE</code> の代わりに <code class="literal">INTO DUMPFILE</code> を使用した場合、MySQL はエスケープ処理を実行することなく、カラムや行の終了のない 1 行のみをファイルに書き込みます。これは、ファイルに <code class="literal">BLOB</code> 値を格納する場合に役立ちます。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">INTO OUTFILE</code> または <code class="literal">INTO DUMPFILE</code> によって作成されたファイルはすべて、サーバーホスト上のすべてのユーザーから書き込み可能です。これは、MySQL サーバーが、それを実行しているアカウントを持つユーザー以外のどのユーザーによって所有されるファイルも作成できないためです。(これらの理由のために、<span class="command"><strong>mysqld</strong></span> を <code class="literal">root</code> としては<span class="emphasis"><em>決して実行しないでください</em></span>。) したがって、このファイルは、その内容を操作できるようにすべてのユーザーから書き込み可能である必要があります。
        </p><p>
          <code class="literal">secure_file_priv</code> システム変数が空以外のディレクトリ名に設定されている場合、書き込まれるファイルはそのディレクトリ内に存在する必要があります。
        </p></div><p>
        イベントスケジューラによって実行されるイベントの一部として実行された <code class="literal">SELECT ... INTO</code> ステートメントのコンテキストでは、診断メッセージ (エラーだけでなく、警告も含みます) がエラーログに (Windows ではアプリケーションイベントログにも) 書き込まれます。詳細は、<a class="xref" href="stored-programs-views.html#events-status-info" title="20.4.5 イベントスケジューラのステータス">セクション20.4.5「イベントスケジューラのステータス」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="join"></a>13.2.9.2 JOIN 構文</h4></div></div></div><a class="indexterm" name="idm139979083891312"></a><a class="indexterm" name="idm139979083889968"></a><a class="indexterm" name="idm139979083888624"></a><a class="indexterm" name="idm139979083887280"></a><a class="indexterm" name="idm139979083885936"></a><a class="indexterm" name="idm139979083884592"></a><a class="indexterm" name="idm139979083883248"></a><a class="indexterm" name="idm139979083881904"></a><a class="indexterm" name="idm139979083880560"></a><a class="indexterm" name="idm139979083879216"></a><a class="indexterm" name="idm139979083877872"></a><a class="indexterm" name="idm139979083876496"></a><a class="indexterm" name="idm139979083875152"></a><p>
        MySQL は、<code class="literal">SELECT</code> ステートメントと複数テーブルの <code class="literal">DELETE</code> および <code class="literal">UPDATE</code> ステートメントの <em class="replaceable"><code>table_references</code></em> 部分に対して次の <code class="literal">JOIN</code> 構文をサポートします。
      </p><pre class="programlisting">
<em class="replaceable"><code>table_references:</code></em>
    <em class="replaceable"><code>escaped_table_reference</code></em> [, <em class="replaceable"><code>escaped_table_reference</code></em>] ...

<em class="replaceable"><code>escaped_table_reference</code></em>:
    <em class="replaceable"><code>table_reference</code></em>
  | { OJ <em class="replaceable"><code>table_reference</code></em> }

<em class="replaceable"><code>table_reference</code></em>:
    <em class="replaceable"><code>table_factor</code></em>
  | <em class="replaceable"><code>join_table</code></em>

<em class="replaceable"><code>table_factor</code></em>:
    <em class="replaceable"><code>tbl_name</code></em> [PARTITION (<em class="replaceable"><code>partition_names</code></em>)] 
        [[AS] <em class="replaceable"><code>alias</code></em>] [<em class="replaceable"><code>index_hint_list</code></em>]
  | <em class="replaceable"><code>table_subquery</code></em> [AS] <em class="replaceable"><code>alias</code></em>
  | ( <em class="replaceable"><code>table_references</code></em> )

<em class="replaceable"><code>join_table</code></em>:
    <em class="replaceable"><code>table_reference</code></em> [INNER | CROSS] JOIN <em class="replaceable"><code>table_factor</code></em> [<em class="replaceable"><code>join_condition</code></em>]
  | <em class="replaceable"><code>table_reference</code></em> STRAIGHT_JOIN <em class="replaceable"><code>table_factor</code></em>
  | <em class="replaceable"><code>table_reference</code></em> STRAIGHT_JOIN <em class="replaceable"><code>table_factor</code></em> ON <em class="replaceable"><code>conditional_expr</code></em>
  | <em class="replaceable"><code>table_reference</code></em> {LEFT|RIGHT} [OUTER] JOIN <em class="replaceable"><code>table_reference</code></em> <em class="replaceable"><code>join_condition</code></em>
  | <em class="replaceable"><code>table_reference</code></em> NATURAL [{LEFT|RIGHT} [OUTER]] JOIN <em class="replaceable"><code>table_factor</code></em>

<em class="replaceable"><code>join_condition</code></em>:
    ON <em class="replaceable"><code>conditional_expr</code></em>
  | USING (<em class="replaceable"><code>column_list</code></em>)

<em class="replaceable"><code>index_hint_list</code></em>:
    <em class="replaceable"><code>index_hint</code></em> [, <em class="replaceable"><code>index_hint</code></em>] ...

<em class="replaceable"><code>index_hint</code></em>:
    USE {INDEX|KEY}
      [FOR {JOIN|ORDER BY|GROUP BY}] ([<em class="replaceable"><code>index_list</code></em>])
  | IGNORE {INDEX|KEY}
      [FOR {JOIN|ORDER BY|GROUP BY}] (<em class="replaceable"><code>index_list</code></em>)
  | FORCE {INDEX|KEY}
      [FOR {JOIN|ORDER BY|GROUP BY}] (<em class="replaceable"><code>index_list</code></em>)

<em class="replaceable"><code>index_list</code></em>:
    <em class="replaceable"><code>index_name</code></em> [, <em class="replaceable"><code>index_name</code></em>] ...
</pre><p>
        テーブル参照は、結合式とも呼ばれます。
      </p><p>
        MySQL 5.6.2 以降では、テーブル参照 (パーティション化されたテーブルを参照する場合) には、パーティション、サブパーティション、またはその両方のカンマ区切りリストを含む <code class="literal">PARTITION</code> オプションを含めることができます。このオプションはテーブルの名前のあとで、かつエイリアス宣言 (存在する場合) の前に指定されます。このオプションの効果は、リストされているパーティションまたはサブパーティションからのみ行が選択されることです。つまり、そのリストで指定されていないパーティションまたはサブパーティションはすべて無視されます。詳細は、<a class="xref" href="partitioning.html#partitioning-selection" title="19.5 パーティション選択">セクション19.5「パーティション選択」</a>を参照してください。
      </p><p>
        <em class="replaceable"><code>table_factor</code></em> の構文は SQL 標準と比較して拡張されています。後者は <em class="replaceable"><code>table_reference</code></em> のみを受け付け、かっこ内のそれらのリストは受け付けません。
      </p><p>
        これは、<em class="replaceable"><code>table_reference</code></em> 項目のリストの各カンマを内部結合と同等とみなす場合、保守的な拡張です。例:
      </p><pre class="programlisting">
SELECT * FROM t1 LEFT JOIN (t2, t3, t4)
                 ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)
</pre><p>
        次と同等です。
      </p><pre class="programlisting">
SELECT * FROM t1 LEFT JOIN (t2 CROSS JOIN t3 CROSS JOIN t4)
                 ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)
</pre><p>
        MySQL では、<code class="literal">JOIN</code>、<code class="literal">CROSS JOIN</code>、および <code class="literal">INNER JOIN</code> は構文上同等です (互いに置き換えることができます)。標準 SQL では、それらは同等ではありません。<code class="literal">INNER JOIN</code> は <code class="literal">ON</code> 句とともに使用され、<code class="literal">CROSS JOIN</code> はそれ以外のときに使用されます。
      </p><p>
        一般に、内部結合操作のみを含む結合式内のかっこは無視できます。MySQL はまた、ネストされた結合もサポートしています (<a class="xref" href="optimization.html#nested-join-optimization" title="8.2.1.11 ネストした結合の最適化">セクション8.2.1.11「ネストした結合の最適化」</a>を参照してください)。
      </p><p>
        インデックスヒントを指定すると、MySQL オプティマイザによるインデックスの使用方法に影響を与えることができます。詳細は、<a class="xref" href="sql-syntax.html#index-hints" title="13.2.9.3 インデックスヒントの構文">セクション13.2.9.3「インデックスヒントの構文」</a>を参照してください。
      </p><p>
        次のリストは、結合を記述するときに考慮に入れるべき一般的な要因について説明しています。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            テーブル参照には、<code class="literal"><em class="replaceable"><code>tbl_name</code></em> AS <em class="replaceable"><code>alias_name</code></em></code> または <em class="replaceable"><code>tbl_name alias_name</code></em> を使用してエイリアスを指定できます。
          </p><pre class="programlisting">
SELECT t1.name, t2.salary
  FROM employee AS t1 INNER JOIN info AS t2 ON t1.name = t2.name;

SELECT t1.name, t2.salary
  FROM employee t1 INNER JOIN info t2 ON t1.name = t2.name;
</pre></li><li class="listitem"><p>
            <em class="replaceable"><code>table_subquery</code></em> は、<code class="literal">FROM</code> 句内のサブクエリーとも呼ばれます。サブクエリー結果にテーブル名を付けるには、このようなサブクエリーにエイリアスを含める<span class="emphasis"><em>必要があります</em></span>。簡単な例を次に示します。<a class="xref" href="sql-syntax.html#from-clause-subqueries" title="13.2.10.8 FROM 句内のサブクエリー">セクション13.2.10.8「FROM 句内のサブクエリー」</a>も参照してください。
          </p><pre class="programlisting">
SELECT * FROM (SELECT 1, 2, 3) AS t1;
</pre></li><li class="listitem"><p>
            結合条件が存在しない場合、<code class="literal">INNER JOIN</code> と <code class="literal">,</code> (カンマ) は意味的に同等です。どちらも、指定されたテーブル間のデカルト積を生成します (つまり、最初のテーブル内のすべての各行が 2 番目のテーブル内のすべての各行に結合されます)。
          </p><p>
            ただし、カンマ演算子の優先順位は、<code class="literal">INNER JOIN</code>、<code class="literal">CROSS JOIN</code>、<code class="literal">LEFT JOIN</code> などの優先順位より低くなります。結合条件が存在するときにカンマ結合をほかの結合型と混在させた場合は、<code class="literal">「カラム '<em class="replaceable"><code>col_name</code></em>' は 'on clause' にはありません」</code>という形式のエラーが発生する可能性があります。この問題への対処に関する情報は、このセクションのあとの方で提供します。
          </p></li><li class="listitem"><p>
            <code class="literal">ON</code> とともに使用される <em class="replaceable"><code>conditional_expr</code></em> は、<code class="literal">WHERE</code> 句で使用できる形式の任意の条件式です。一般に、テーブルの結合方法を指定する条件には <code class="literal">ON</code> 句を、また結果セット内に必要な行を制限するには <code class="literal">WHERE</code> 句を使用してください。
          </p></li><li class="listitem"><p>
            <code class="literal">LEFT JOIN</code> 内の <code class="literal">ON</code> または <code class="literal">USING</code> 部分にある右側のテーブルに一致する行が存在しない場合は、すべてのカラムが <code class="literal">NULL</code> に設定された行が右側のテーブルに使用されます。このことを使用して、別のテーブルに対応する行が存在しないテーブル内の行を検索できます。
          </p><pre class="programlisting">
SELECT left_tbl.*
  FROM left_tbl LEFT JOIN right_tbl ON left_tbl.id = right_tbl.id
  WHERE right_tbl.id IS NULL;
</pre><p>
            この例では、<code class="literal">right_tbl</code> に存在しない <code class="literal">id</code> 値を持つ <code class="literal">left_tbl</code> 内のすべての行 (つまり、<code class="literal">right_tbl</code> 内に対応する行のない <code class="literal">left_tbl</code> 内のすべての行) を検索します。これは、<code class="literal">right_tbl.id</code> が <code class="literal">NOT NULL</code> として宣言されていることを前提にしています。<a class="xref" href="optimization.html#left-join-optimization" title="8.2.1.9 LEFT JOIN および RIGHT JOIN の最適化">セクション8.2.1.9「LEFT JOIN および RIGHT JOIN の最適化」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">USING(<em class="replaceable"><code>column_list</code></em>)</code> 句は、両方のテーブル内に存在する必要のあるカラムのリストを指定します。テーブル <code class="literal">a</code> と <code class="literal">b</code> の両方にカラム <code class="literal">c1</code>、<code class="literal">c2</code>、および <code class="literal">c3</code> が含まれている場合、次の結合は、この 2 つのテーブルの対応するカラムを比較します。
          </p><pre class="programlisting">
a LEFT JOIN b USING (c1,c2,c3)
</pre></li><li class="listitem"><p>
            2 つのテーブルの <code class="literal">NATURAL [LEFT] JOIN</code> は、両方のテーブル内に存在するすべてのカラムを指定する <code class="literal">USING</code> 句を含む <code class="literal">INNER JOIN</code> または <code class="literal">LEFT JOIN</code> と意味的に同等であるとして定義されます。
          </p></li><li class="listitem"><p>
            <code class="literal">RIGHT JOIN</code> は、<code class="literal">LEFT JOIN</code> と同じように機能します。コードをデータベース間で移植可能な状態に維持するため、<code class="literal">RIGHT JOIN</code> の代わりに <code class="literal">LEFT JOIN</code> を使用することをお勧めします。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979083781984"></a> <a class="indexterm" name="idm139979083780512"></a> 結合構文の説明に示されている <code class="literal">{ OJ ... }</code> 構文は、ODBC との互換性のためにのみ存在します。構文内のカールした中括弧は文字どおりに書き込まれる必要があります。それらは構文説明の別の部分で利用されているようなメタ構文ではありません。
          </p><pre class="programlisting">
SELECT left_tbl.*
    FROM { OJ left_tbl LEFT OUTER JOIN right_tbl ON left_tbl.id = right_tbl.id }
    WHERE right_tbl.id IS NULL;
</pre><p>
            <code class="literal">{ OJ ... }</code> 内では、<code class="literal">INNER JOIN</code> や <code class="literal">RIGHT OUTER JOIN</code> などのほかの型の結合を使用できます。これは、一部のサードパーティー製アプリケーションとの互換性に役立ちますが、正式な ODBC 構文ではありません。
          </p></li><li class="listitem"><p>
            <code class="literal">STRAIGHT_JOIN</code> は、左側のテーブルが常に右側のテーブルの前に読み取られる点を除き、<code class="literal">JOIN</code> と同じです。これは、結合オプティマイザがテーブルを間違った順序で配置する (数少ない) 場合に使用できます。
          </p></li></ul></div><p>
        結合のいくつかの例:
      </p><pre class="programlisting">
SELECT * FROM table1, table2;

SELECT * FROM table1 INNER JOIN table2 ON table1.id=table2.id;

SELECT * FROM table1 LEFT JOIN table2 ON table1.id=table2.id;

SELECT * FROM table1 LEFT JOIN table2 USING (id);

SELECT * FROM table1 LEFT JOIN table2 ON table1.id=table2.id
  LEFT JOIN table3 ON table2.id=table3.id;
</pre><p>
        <span class="bold"><strong>MySQL 5.0.12 での結合処理の変更</strong></span>
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          自然結合や <code class="literal">USING</code> を使用した結合 (外部結合のバリアントを含む) は、SQL:2003 標準に従って処理されます。その目標は、<code class="literal">NATURAL JOIN</code> と <code class="literal">JOIN ... USING</code> に関連した MySQL の構文とセマンティクスを SQL:2003 に合わせることでした。ただし、結合処理でのこれらの変更によって、一部の結合で異なる出力カラムが生成される可能性があります。また、古いバージョン (5.0.12 より前) では正しく機能するように見えた一部のクエリーを、この標準に準拠するように書き換える必要があります。
        </p></div><p>
        これらの変更の主要な側面として、次の 5 つがあります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            MySQL が <code class="literal">NATURAL</code> または <code class="literal">USING</code> 結合操作の結果カラム (したがって、<code class="literal">FROM</code> 句全体の結果) を決定する方法。
          </p></li><li class="listitem"><p>
            <code class="literal">SELECT *</code> および <code class="literal">SELECT <em class="replaceable"><code>tbl_name</code></em>.*</code> の選択されたカラムのリストへの展開。
          </p></li><li class="listitem"><p>
            <code class="literal">NATURAL</code> または <code class="literal">USING</code> 結合でのカラム名の解決。
          </p></li><li class="listitem"><p>
            <code class="literal">NATURAL</code> または <code class="literal">USING</code> 結合の <code class="literal">JOIN ... ON</code> への変換。
          </p></li><li class="listitem"><p>
            <code class="literal">JOIN ... ON</code> の <code class="literal">ON</code> 条件でのカラム名の解決。
          </p></li></ul></div><p>
        次のリストは、現在の結合処理のいくつかの効果を古いバージョンでの結合処理と比較した場合のさらに詳細な情報を示しています。<span class="quote">「<span class="quote">以前</span>」</span>という用語は、<span class="quote">「<span class="quote">MySQL 5.0.12 より前</span>」</span>を示しています。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">NATURAL</code> 結合または <code class="literal">USING</code> 結合のカラムが以前とは異なる可能性があります。具体的には、冗長な出力カラムが表示されなくなっており、また <code class="literal">SELECT *</code> の展開でのカラムの順序が以前とは異なる可能性があります。
          </p><p>
            次の一連のステートメントを考えてみます。
          </p><pre class="programlisting">
CREATE TABLE t1 (i INT, j INT);
CREATE TABLE t2 (k INT, j INT);
INSERT INTO t1 VALUES(1,1);
INSERT INTO t2 VALUES(1,1);
SELECT * FROM t1 NATURAL JOIN t2;
SELECT * FROM t1 JOIN t2 USING (j);
</pre><p>
            以前は、これらのステートメントによって次の出力が生成されました。
          </p><pre class="programlisting">
+------+------+------+------+
| i    | j    | k    | j    |
+------+------+------+------+
|    1 |    1 |    1 |    1 |
+------+------+------+------+
+------+------+------+------+
| i    | j    | k    | j    |
+------+------+------+------+
|    1 |    1 |    1 |    1 |
+------+------+------+------+
</pre><p>
            最初の <code class="literal">SELECT</code> ステートメントでは、カラム <code class="literal">j</code> は両方のテーブルに現れるため、結合カラムになります。そのため、標準 SQL に従って、出力には 2 回ではなく 1 回だけ表示されるべきです。同様に、2 番目の SELECT ステートメントでは、カラム <code class="literal">j</code> は <code class="literal">USING</code> 句で指定されているため、出力には 2 回ではなく 1 回だけ表示されるべきです。ただし、どちらの場合も、冗長なカラムは削除されていません。また、標準 SQL に従うとカラムの順序も正しくありません。
          </p><p>
            現在は、このステートメントによって次の出力が生成されます。
          </p><pre class="programlisting">
+------+------+------+
| j    | i    | k    |
+------+------+------+
|    1 |    1 |    1 |
+------+------+------+
+------+------+------+
| j    | i    | k    |
+------+------+------+
|    1 |    1 |    1 |
+------+------+------+
</pre><p>
            冗長なカラムは削除され、カラムの順序も標準 SQL に従って正しくなっています。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                最初に、結合された 2 つのテーブルの合体した共通カラムが、最初のテーブルに現れた順序で
              </p></li><li class="listitem"><p>
                2 番目に、最初のテーブルに一意のカラムが、そのテーブルに現れた順序で
              </p></li><li class="listitem"><p>
                3 番目に、2 番目のテーブルに一意のカラムが、そのテーブルに現れた順序で
              </p></li></ul></div><p>
            2 つの共通カラムを置き換える 1 つの結果カラムは、合体操作を使用して定義されます。つまり、<code class="literal">t1.a</code> と <code class="literal">t2.a</code> の 2 つに対して、結果として得られる 1 つの結合カラム <code class="literal">a</code> は <code class="literal">a = COALESCE(t1.a, t2.a)</code> として定義されます。ここでは:
          </p><pre class="programlisting">
COALESCE(x, y) = (CASE WHEN V1 IS NOT NULL THEN V1 ELSE V2 END)
</pre><p>
            この結合操作がほかのいずれかの結合である場合、その結合の結果カラムは、結合されたテーブルのすべてのカラムの連結で構成されます。これは以前と同じです。
          </p><p>
            合体したカラムの定義の結果として、外部結合では、2 つのカラムのいずれかが常に <code class="literal">NULL</code> である場合、合体したカラムには <code class="literal">NULL</code> 以外のカラムの値が含まれます。どちらのカラムも <code class="literal">NULL</code> でないか、または両方のカラムがこの値である場合、両方の共通カラムに同じ値が含まれているため、合体したカラムの値としてどちらが選択されるかは問題にはなりません。これを解釈するための簡単な方法として、外部結合の合体したカラムが <code class="literal">JOIN</code> の内部テーブルの共通カラムによって表されると考えてみます。テーブル <code class="literal">t1(a,b)</code> と <code class="literal">t2(a,c)</code> に次の内容が含まれているとします。
          </p><pre class="programlisting">
t1    t2
----  ----
1 x   2 z
2 y   3 w
</pre><p>
            このとき、次のようになります。
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT * FROM t1 NATURAL LEFT JOIN t2;</code></strong>
+------+------+------+
| a    | b    | c    |
+------+------+------+
|    1 | x    | NULL |
|    2 | y    | z    |
+------+------+------+
</pre><p>
            ここでは、カラム <code class="literal">a</code> に <code class="literal">t1.a</code> の値が含まれています。
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT * FROM t1 NATURAL RIGHT JOIN t2;</code></strong>
+------+------+------+
| a    | c    | b    |
+------+------+------+
|    2 | z    | y    |
|    3 | w    | NULL |
+------+------+------+
</pre><p>
            ここでは、カラム <code class="literal">a</code> に <code class="literal">t2.a</code> の値が含まれています。
          </p><p>
            これらの結果を、<code class="literal">JOIN ... ON</code> を使用した、それ以外では同等のクエリーと比較してください。
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT * FROM t1 LEFT JOIN t2 ON (t1.a = t2.a);</code></strong>
+------+------+------+------+
| a    | b    | a    | c    |
+------+------+------+------+
|    1 | x    | NULL | NULL |
|    2 | y    |    2 | z    |
+------+------+------+------+
</pre><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT * FROM t1 RIGHT JOIN t2 ON (t1.a = t2.a);</code></strong>
+------+------+------+------+
| a    | b    | a    | c    |
+------+------+------+------+
|    2 | y    |    2 | z    |
| NULL | NULL |    3 | w    |
+------+------+------+------+
</pre></li><li class="listitem"><p>
            以前は、<code class="literal">USING</code> 句を、対応するカラムを比較する <code class="literal">ON</code> 句として書き換えることができました。たとえば、次の 2 つの句は意味的に同一でした。
          </p><pre class="programlisting">
a LEFT JOIN b USING (c1,c2,c3)
a LEFT JOIN b ON a.c1=b.c1 AND a.c2=b.c2 AND a.c3=b.c3
</pre><p>
            現在、この 2 つの句はまったく同じではなくなっています。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                どの行が結合条件を満たすかの判定に関しては、どちらの結合も意味的に同一のままです。
              </p></li><li class="listitem"><p>
                <code class="literal">SELECT *</code> の展開に対してどのカラムを表示するかの判定に関しては、この 2 つの結合は意味的に同一ではありません。<code class="literal">USING</code> 結合が対応するカラムの合体した値を選択するのに対して、<code class="literal">ON</code> 結合は、すべてのテーブルのすべてのカラムを選択します。前の <code class="literal">USING</code> 結合の場合、<code class="literal">SELECT *</code> は次の値を選択します。
              </p><pre class="programlisting">
COALESCE(a.c1,b.c1), COALESCE(a.c2,b.c2), COALESCE(a.c3,b.c3)
</pre><p>
                <code class="literal">ON</code> 結合の場合、<code class="literal">SELECT *</code> は次の値を選択します。
              </p><pre class="programlisting">
a.c1, a.c2, a.c3, b.c1, b.c2, b.c3
</pre><p>
                内部結合では、<code class="literal">a.c1</code> と <code class="literal">b.c1</code> の両方のカラムに同じ値が含まれるため、<code class="literal">COALESCE(a.c1,b.c1)</code> はどちらのカラムとも同じです。外部結合 (<code class="literal">LEFT JOIN</code> など) では、2 つのカラムのどちらかが <code class="literal">NULL</code> になる場合があります。そのカラムは結果から省略されます。
              </p></li></ul></div></li><li class="listitem"><p>
            多方向自然結合の評価は、<code class="literal">NATURAL</code> または <code class="literal">USING</code> 結合の結果に影響を与え、さらにはクエリーの書き換えが必要になる場合もある非常に重要な点で異なります。3 つのテーブル <code class="literal">t1(a,b)</code>、<code class="literal">t2(c,b)</code>、および <code class="literal">t3(a,c)</code> があり、各テーブルに <code class="literal">t1(1,2)</code>、<code class="literal">t2(10,2)</code>、および <code class="literal">t3(7,10)</code> の 1 行が含まれているとします。また、これらの 3 つのテーブルに対して次の <code class="literal">NATURAL JOIN</code> を実行するとします。
          </p><pre class="programlisting">
SELECT ... FROM t1 NATURAL JOIN t2 NATURAL JOIN t3;
</pre><p>
            以前は、2 番目の結合の左のオペランドが <code class="literal">t2</code> であると見なされたのに対して、現在はネストされた結合 <code class="literal">(t1 NATURAL JOIN t2)</code> であると見なされます。その結果、<code class="literal">t3</code> のカラムは <code class="literal">t2</code> でのみ共通カラムに対してチェックされ、さらに <code class="literal">t3</code> に <code class="literal">t1</code> との共通カラムが含まれている場合、これらのカラムは等価結合カラムとして使用されません。そのため、以前は、前のクエリーは次の等価結合に変換されました。
          </p><pre class="programlisting">
SELECT ... FROM t1, t2, t3
  WHERE t1.b = t2.b AND t2.c = t3.c;
</pre><p>
            その結合には、もう 1 つの等価結合述語 <code class="literal">(t1.a = t3.a)</code> がありません。その結果、本来生成すべき空の結果ではなく、1 行が生成されます。正しい同等のクエリーは次のとおりです。
          </p><pre class="programlisting">
SELECT ... FROM t1, t2, t3
  WHERE t1.b = t2.b AND t2.c = t3.c AND t1.a = t3.a;
</pre><p>
            現在のバージョンの MySQL で古いバージョンと同じクエリー結果が必要な場合は、自然結合を最初の等価結合として書き換えてください。
          </p></li><li class="listitem"><p>
            以前は、カンマ演算子 (<code class="literal">,</code>) と <code class="literal">JOIN</code> はどちらも同じ優先順位を持っていたため、結合式 <code class="literal">t1, t2 JOIN t3</code> は <code class="literal">((t1, t2) JOIN t3)</code> として解釈されました。現在は、<code class="literal">JOIN</code> の優先順位の方が高いため、この式は <code class="literal">(t1, (t2 JOIN t3))</code> として解釈されます。<code class="literal">ON</code> 句は結合のオペランド内のカラムしか参照できず、また優先順位の変更によってそれらのオペランドが示す内容の解釈が変更されるため、この変更はその句を使用するステートメントに影響を与えます。
          </p><p>
            例:
          </p><pre class="programlisting">
CREATE TABLE t1 (i1 INT, j1 INT);
CREATE TABLE t2 (i2 INT, j2 INT);
CREATE TABLE t3 (i3 INT, j3 INT);
INSERT INTO t1 VALUES(1,1);
INSERT INTO t2 VALUES(1,1);
INSERT INTO t3 VALUES(1,1);
SELECT * FROM t1, t2 JOIN t3 ON (t1.i1 = t3.i3);
</pre><p>
            以前は、この <code class="literal">SELECT</code> は、<code class="literal">(t1,t2)</code> として <code class="literal">t1,t2</code> の暗黙的なグループ化のために正当でした。現在は、<code class="literal">JOIN</code> が優先されるため、<code class="literal">ON</code> 句のオペランドは <code class="literal">t2</code> と <code class="literal">t3</code> になります。<code class="literal">t1.i1</code> はどのオペランドのカラムでもないため、その結果は<code class="literal">「カラム 't1.i1' は 'on clause' にはありません」</code>というエラーになります。この結合の処理を可能にするには、<code class="literal">ON</code> 句のオペランドが <code class="literal">(t1,t2)</code> と <code class="literal">t3</code> になるように、最初の 2 つのテーブルを明示的に括弧でグループ化します。
          </p><pre class="programlisting">
SELECT * FROM (t1, t2) JOIN t3 ON (t1.i1 = t3.i3);
</pre><p>
            あるいは、カンマ演算子の使用を避け、代わりに <code class="literal">JOIN</code> を使用します。
          </p><pre class="programlisting">
SELECT * FROM t1 JOIN t2 JOIN t3 ON (t1.i1 = t3.i3);
</pre><p>
            この変更はまた、カンマ演算子を <code class="literal">INNER JOIN</code>、<code class="literal">CROSS JOIN</code>、<code class="literal">LEFT JOIN</code>、および <code class="literal">RIGHT JOIN</code> (これらはすべて現在、カンマ演算子より高い優先順位を持っています) と混在させているステートメントにも適用されます。
          </p></li><li class="listitem"><p>
            以前は、<code class="literal">ON</code> 句は、その右側で指定されているテーブル内のカラムを参照することができました。現在は、<code class="literal">ON</code> 句は自身のオペランドしか参照できません。
          </p><p>
            例:
          </p><pre class="programlisting">
CREATE TABLE t1 (i1 INT);
CREATE TABLE t2 (i2 INT);
CREATE TABLE t3 (i3 INT);
SELECT * FROM t1 JOIN t2 ON (i1 = i3) JOIN t3;
</pre><p>
            以前は、この <code class="literal">SELECT</code> ステートメントは正当でした。現在は、<code class="literal">i3</code> が <code class="literal">ON</code> 句のオペランドではない <code class="literal">t3</code> 内のカラムであるため、このステートメントは<code class="literal">「カラム 'i3' は 'on clause' にはありません」</code>というエラーで失敗します。このステートメントを次のように書き換えるようにしてください。
          </p><pre class="programlisting">
SELECT * FROM t1 JOIN t2 JOIN t3 ON (i1 = i3);
</pre></li><li class="listitem"><p>
            <code class="literal">NATURAL</code> または <code class="literal">USING</code> 結合でのカラム名の解決が以前とは異なります。<code class="literal">FROM</code> 句の外部にあるカラム名の場合、MySQL は現在、以前と比較してクエリーのスーパーセットを処理します。つまり、MySQL が以前、一部のカラムがあいまいであるというエラーを発行したケースでも、そのクエリーは現在、正しく処理されます。これは、MySQL が現在、<code class="literal">NATURAL</code> または <code class="literal">USING</code> 結合の共通カラムを単一カラムとして処理するため、クエリーがこのようなカラムを参照しても、クエリーコンパイラがそのカラムをあいまいであるとは見なさないことによります。
          </p><p>
            例:
          </p><pre class="programlisting">
SELECT * FROM t1 NATURAL JOIN t2 WHERE b &gt; 1;
</pre><p>
            以前は、このクエリーによってエラー <code class="literal">ERROR 1052 (23000): Column 'b' in where clause is ambiguous</code> が生成されました。現在は、このクエリーによって正しい結果が生成されます。
          </p><pre class="programlisting">
+------+------+------+
| b    | c    | y    |
+------+------+------+
|    4 |    2 |    3 |
+------+------+------+
</pre><p>
            SQL:2003 標準と比べた場合の MySQL の 1 つの拡張として、MySQL では、<code class="literal">NATURAL</code> または <code class="literal">USING</code> 結合の共通 (合体した) カラムを (以前と同様に) 修飾できるのに対して、標準ではそれが禁止される点があります。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="index-hints"></a>13.2.9.3 インデックスヒントの構文</h4></div></div></div><a class="indexterm" name="idm139979083622656"></a><a class="indexterm" name="idm139979083621200"></a><a class="indexterm" name="idm139979083619168"></a><a class="indexterm" name="idm139979083617936"></a><a class="indexterm" name="idm139979083616592"></a><a class="indexterm" name="idm139979083615248"></a><a class="indexterm" name="idm139979083613904"></a><a class="indexterm" name="idm139979083612560"></a><p>
        クエリー処理中にインデックスを選択する方法に関する情報をオプティマイザに提供するためのヒントを指定できます。<a class="xref" href="sql-syntax.html#join" title="13.2.9.2 JOIN 構文">セクション13.2.9.2「JOIN 構文」</a>では、<code class="literal">SELECT</code> ステートメントでテーブルを指定するための一般的な構文について説明しています。個々のテーブルの構文 (インデックスヒントの構文を含む) は次のようになります。
      </p><pre class="programlisting">
<em class="replaceable"><code>tbl_name</code></em> [[AS] <em class="replaceable"><code>alias</code></em>] [<em class="replaceable"><code>index_hint_list</code></em>]

<em class="replaceable"><code>index_hint_list</code></em>:
    <em class="replaceable"><code>index_hint</code></em> [, <em class="replaceable"><code>index_hint</code></em>] ...

<em class="replaceable"><code>index_hint</code></em>:
    USE {INDEX|KEY}
      [FOR {JOIN|ORDER BY|GROUP BY}] ([<em class="replaceable"><code>index_list</code></em>])
  | IGNORE {INDEX|KEY}
      [FOR {JOIN|ORDER BY|GROUP BY}] (<em class="replaceable"><code>index_list</code></em>)
  | FORCE {INDEX|KEY}
      [FOR {JOIN|ORDER BY|GROUP BY}] (<em class="replaceable"><code>index_list</code></em>)

<em class="replaceable"><code>index_list</code></em>:
    <em class="replaceable"><code>index_name</code></em> [, <em class="replaceable"><code>index_name</code></em>] ...
</pre><p>
        <code class="literal">USE INDEX (<em class="replaceable"><code>index_list</code></em>)</code> を指定することによって、テーブル内の行を検索するために、指定されたインデックスの 1 つのみを使用するよう MySQL に指示できます。代わりの構文 <code class="literal">IGNORE INDEX (<em class="replaceable"><code>index_list</code></em>)</code> を使用すると、いくつかの特定の (1 つまたは複数の) インデックスを使用しないよう MySQL に指示できます。これらのヒントは、<code class="literal">EXPLAIN</code> によって、MySQL が可能性のあるインデックスのリストから間違ったインデックスを使用していることが示された場合に役立ちます。
      </p><p>
        また、<code class="literal">USE INDEX (<em class="replaceable"><code>index_list</code></em>)</code> と同様の機能を持つが、テーブルスキャンが<span class="emphasis"><em>非常に</em></span>負荷が大きいと見なされる点が追加された <code class="literal">FORCE INDEX</code> を使用することもできます。つまり、テーブルスキャンは、指定されたインデックスのいずれかを使用してテーブル内の行を検索する方法がない場合にのみ使用されます。
      </p><p>
        各ヒントには、カラムの名前ではなく、<span class="emphasis"><em>インデックス</em></span>の名前が必要です。<code class="literal">PRIMARY KEY</code> の名前は <code class="literal">PRIMARY</code> です。テーブルのインデックス名を表示するには、<code class="literal">SHOW INDEX</code> を使用します。
      </p><p>
        <em class="replaceable"><code>index_name</code></em> 値は、完全なインデックス名である必要はありません。インデックス名のあいまいでないプリフィクスにすることができます。プリフィクスがあいまいな場合は、エラーが発生します。
      </p><p>
        例:
      </p><pre class="programlisting">
SELECT * FROM table1 USE INDEX (col1_index,col2_index)
  WHERE col1=1 AND col2=2 AND col3=3;

SELECT * FROM table1 IGNORE INDEX (col3_index)
  WHERE col1=1 AND col2=2 AND col3=3;
</pre><p>
        インデックスヒントの構文には、次の特性があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">USE INDEX</code> に空の <em class="replaceable"><code>index_list</code></em> を指定する (つまり、<span class="quote">「<span class="quote">インデックスを使用しない</span>」</span>) ことは構文として有効です。<code class="literal">FORCE INDEX</code> または <code class="literal">IGNORE INDEX</code> に空の <em class="replaceable"><code>index_list</code></em> を指定することは構文エラーです。
          </p></li><li class="listitem"><p>
            ヒントに <code class="literal">FOR</code> 句を追加することによって、インデックスヒントのスコープを指定できます。これにより、クエリー処理のさまざまなフェーズに対するオプティマイザの実行計画の選択をよりきめ細かく制御できるようになります。MySQL がテーブル内の行の検索方法および結合の処理方法を決定するときに使用されるインデックスにのみ影響を与えるには、<code class="literal">FOR JOIN</code> を使用します。行をソートまたはグループ化するためのインデックス使用に影響を与えるには、<code class="literal">FOR ORDER BY</code> または <code class="literal">FOR GROUP BY</code> を使用します。(ただし、テーブルを範囲に含むインデックスが存在し、それがテーブルへのアクセスに使用されている場合、オプティマイザは、そのインデックスを無効にする <code class="literal">IGNORE INDEX FOR {ORDER BY|GROUP BY}</code> ヒントを無視します。) 
          </p></li><li class="listitem"><p>
            複数のインデックスヒントを指定できます。
          </p><pre class="programlisting">
SELECT * FROM t1 USE INDEX (i1) IGNORE INDEX FOR ORDER BY (i2) ORDER BY a;
</pre><p>
            複数のヒントで同じインデックスを指定することは (同じヒント内であっても) エラーではありません。
          </p><pre class="programlisting">
SELECT * FROM t1 USE INDEX (i1) USE INDEX (i1,i1);
</pre><p>
            ただし、同じテーブルに対して <code class="literal">USE INDEX</code> と <code class="literal">FORCE INDEX</code> を混在させると、エラーが発生します。
          </p><pre class="programlisting">
SELECT * FROM t1 USE INDEX FOR JOIN (i1) FORCE INDEX FOR JOIN (i2);
</pre></li></ul></div><p>
        インデックスヒントで <code class="literal">FOR</code> 句を指定しない場合、デフォルトでは、そのヒントはステートメントのすべての部分に適用されます。たとえば、次のヒント
      </p><pre class="programlisting">
IGNORE INDEX (i1)
</pre><p>
        は次のヒントの組み合わせと同等です。
      </p><pre class="programlisting">
IGNORE INDEX FOR JOIN (i1)
IGNORE INDEX FOR ORDER BY (i1)
IGNORE INDEX FOR GROUP BY (i1)
</pre><p>
        サーバーで、<code class="literal">FOR</code> 句が存在しないときに (ヒントが行の取得にのみ適用されるように) ヒントスコープに対する古い動作が使用されるようにするには、サーバーの起動時に<code class="literal">古い</code>システム変数を有効にします。レプリケーションセットアップでこの変数を有効にする場合は注意してください。ステートメントベースのバイナリロギングで、マスターとスレーブに異なるモードを指定するとレプリケーションエラーが発生する場合があります。
      </p><p>
        インデックスヒントが処理されるとき、これらのインデックスヒントは、型 (<code class="literal">USE</code>、<code class="literal">FORCE</code>、<code class="literal">IGNORE</code>) およびスコープ (<code class="literal">FOR JOIN</code>、<code class="literal">FOR ORDER BY</code>、<code class="literal">FOR GROUP BY</code>) ごとに 1 つのリストに収集されます。例:
      </p><pre class="programlisting">
SELECT * FROM t1
  USE INDEX () IGNORE INDEX (i2) USE INDEX (i1) USE INDEX (i2);
</pre><p>
        次と同等です。
      </p><pre class="programlisting">
SELECT * FROM t1
   USE INDEX (i1,i2) IGNORE INDEX (i2);
</pre><p>
        そのあと、インデックスヒントは、スコープごとに次の順序で適用されます。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            <code class="literal">{USE|FORCE} INDEX</code> が存在する場合は、これが適用されます。(存在しない場合は、オプティマイザによって決定されたインデックスのセットが使用されます。) 
          </p></li><li class="listitem"><p>
            前の手順の結果に対して、<code class="literal">IGNORE INDEX</code> が適用されます。たとえば、次の 2 つのクエリーは同等です。
          </p><pre class="programlisting">
SELECT * FROM t1 USE INDEX (i1) IGNORE INDEX (i2) USE INDEX (i2);

SELECT * FROM t1 USE INDEX (i1);
</pre></li></ol></div><p>
        <code class="literal">FULLTEXT</code> の検索の場合、インデックスヒントは次のように機能します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            自然言語モードの検索の場合、インデックスヒントは暗黙のうちに無視されます。たとえば、<code class="literal">IGNORE INDEX(i)</code> は警告なしで無視され、インデックスが引き続き使用されます。
          </p><p>
            ブールモードの検索の場合、<code class="literal">FOR ORDER BY</code> または <code class="literal">FOR GROUP BY</code> を含むインデックスヒントは暗黙のうちに無視されます。<code class="literal">FOR JOIN</code> を含むインデックスヒント、または <code class="literal">FOR</code> 修飾子を含まないインデックスヒントは受け付けられます。ヒントが <code class="literal">FULLTEXT</code> 以外の検索に適用される場合とは異なり、このヒントは、クエリー実行のすべてのフェーズ (行の検索と取得、グループ化、および順序付け) に使用されます。これは、ヒントが <code class="literal">FULLTEXT</code> 以外のインデックスに対して指定されている場合でも当てはまります。
          </p></li></ul></div><p>
        たとえば、次の 2 つのクエリーは同等です。
      </p><pre class="programlisting">
SELECT * FROM t
  USE INDEX (index1)
  IGNORE INDEX (index1) FOR ORDER BY
  IGNORE INDEX (index1) FOR GROUP BY
  WHERE ... IN BOOLEAN MODE ... ;

SELECT * FROM t
  USE INDEX (index1)
  WHERE ... IN BOOLEAN MODE ... ;
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="union"></a>13.2.9.4 UNION 構文</h4></div></div></div><a class="indexterm" name="idm139979083538048"></a><pre class="programlisting">
SELECT ...
UNION [ALL | DISTINCT] SELECT ...
[UNION [ALL | DISTINCT] SELECT ...]
</pre><p>
        <code class="literal">UNION</code> は、複数の <code class="literal">SELECT</code> ステートメントからの結果を 1 つの結果セットに結合するために使用されます。
      </p><p>
        最初の <code class="literal">SELECT</code> ステートメントからのカラム名が、返される結果のカラム名として使用されます。各 <code class="literal">SELECT</code> ステートメントの対応する位置にリストされている選択されるカラムは、データ型が同じになるようにしてください。(たとえば、最初のステートメントによって選択される最初のカラムが、ほかのステートメントによって選択される最初のカラムと型が同じになるようにしてください。) 
      </p><p>
        対応する <code class="literal">SELECT</code> カラムのデータ型が一致しない場合、<code class="literal">UNION</code> の結果内のカラムの型と長さは、すべての <code class="literal">SELECT</code> ステートメントによって取得された値を考慮に入れて決定されます。たとえば、次の例を考えてみます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT REPEAT('a',1) UNION SELECT REPEAT('b',10);</code></strong>
+---------------+
| REPEAT('a',1) |
+---------------+
| a             |
| bbbbbbbbbb    |
+---------------+
</pre><p>
        これらの <code class="literal">SELECT</code> ステートメントは通常の選択ステートメントですが、次の制限があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">INTO OUTFILE</code> を使用できるのは、最後の <code class="literal">SELECT</code> ステートメントだけです。(ただし、<code class="literal">UNION</code> の結果全体がファイルに書き込まれます。) 
          </p></li><li class="listitem"><p>
            <code class="literal">HIGH_PRIORITY</code> を、<code class="literal">UNION</code> の一部である <code class="literal">SELECT</code> ステートメントで使用することはできません。それを最初の <code class="literal">SELECT</code> に対して指定しても、何の効果もありません。それを以降のいずれかの <code class="literal">SELECT</code> ステートメントに対して指定すると、構文エラーが発生します。
          </p></li></ul></div><p>
        <code class="literal">UNION</code> のデフォルトの動作では、重複した行が結果から削除されます。オプションの <code class="literal">DISTINCT</code> キーワードは、これも重複した行の削除を指定するため、デフォルト以外の効果は何もありません。オプションの <code class="literal">ALL</code> キーワードを指定すると、重複した行の削除は実行されず、その結果には、すべての <code class="literal">SELECT</code> ステートメントからの一致するすべての行が含まれます。
      </p><p>
        <code class="literal">UNION ALL</code> と <code class="literal">UNION DISTINCT</code> を同じクエリー内で混在させることができます。混在した <code class="literal">UNION</code> 型は、<code class="literal">DISTINCT</code> 和集合がその左側にある <code class="literal">ALL</code> 和集合をすべてオーバーライドするように処理されます。<code class="literal">DISTINCT</code> 和集合は、<code class="literal">UNION DISTINCT</code> を使用して明示的に、あるいはそのあとに <code class="literal">DISTINCT</code> または <code class="literal">ALL</code> キーワードのない <code class="literal">UNION</code> を使用して暗黙的に生成できます。
      </p><p>
        個々の <code class="literal">SELECT</code> に <code class="literal">ORDER BY</code> または <code class="literal">LIMIT</code> を適用するには、この句を <code class="literal">SELECT</code> を囲む括弧内に配置します。
      </p><pre class="programlisting">
(SELECT a FROM t1 WHERE a=10 AND B=1 ORDER BY a LIMIT 10)
UNION
(SELECT a FROM t2 WHERE a=11 AND B=2 ORDER BY a LIMIT 10);
</pre><p>
        ただし、個々の <code class="literal">SELECT</code> ステートメントに対して <code class="literal">ORDER BY</code> を使用しても、<code class="literal">UNION</code> がデフォルトでは、順序付けされていない行のセットを生成するため、最終的な結果に行が現れる順序には何も影響を与えません。そのため、このコンテキストでは通常、<code class="literal">ORDER BY</code> は <code class="literal">LIMIT</code> と組み合わせて使用されます。それにより、選択された行の <code class="literal">UNION</code> の最終結果での順序に必ずしも影響を与えるわけではないにもかかわらず、<code class="literal">SELECT</code> で取得するためのこれらの行のサブセットを決定するために使用されるようになります。<code class="literal">ORDER BY</code> が <code class="literal">SELECT</code> 内に <code class="literal">LIMIT</code> なしで現れた場合、この句はいずれにしても何も効果がないため、最適化によって削除されます。
      </p><p>
        <code class="literal">ORDER BY</code> または <code class="literal">LIMIT</code> 句を使用して <code class="literal">UNION</code> の結果全体をソートまたは制限するには、個々の <code class="literal">SELECT</code> ステートメントを括弧で囲み、最後のステートメントのあとに <code class="literal">ORDER BY</code> または <code class="literal">LIMIT</code> を配置します。次の例では、この両方の句を使用しています。
      </p><pre class="programlisting">
(SELECT a FROM t1 WHERE a=10 AND B=1)
UNION
(SELECT a FROM t2 WHERE a=11 AND B=2)
ORDER BY a LIMIT 10;
</pre><p>
        括弧のないステートメントは、今示した括弧で囲まれたステートメントと同等です。
      </p><p>
        この種の <code class="literal">ORDER BY</code> は、テーブル名 (つまり、<em class="replaceable"><code>tbl_name</code></em>.<em class="replaceable"><code>col_name</code></em> という形式の名前) を含むカラム参照を使用できません。代わりに、最初の <code class="literal">SELECT</code> ステートメント内にカラムのエイリアスを指定し、そのエイリアスを <code class="literal">ORDER BY</code> 内で参照します。(あるいは、<code class="literal">ORDER BY</code> 内でカラムを、そのカラム位置を使用して参照します。ただし、カラム位置の使用は非推奨です。) 
      </p><p>
        また、ソートされるカラムにエイリアスが指定されている場合、<code class="literal">ORDER BY</code> 句はそのカラム名ではなく、エイリアスを参照する<span class="emphasis"><em>必要があります</em></span>。次のうちの最初のステートメントは機能しますが、2 番目は<code class="literal">「カラム 'a' は 'order clause' にはありません」</code>というエラーで失敗します。
      </p><pre class="programlisting">
(SELECT a AS b FROM t) UNION (SELECT ...) ORDER BY b;
(SELECT a AS b FROM t) UNION (SELECT ...) ORDER BY a;
</pre><p>
        <code class="literal">UNION</code> の結果内の行が、各 <code class="literal">SELECT</code> によって 1 つずつ取得された行のセットで構成されるようにするには、ソートカラムとして使用する各 <code class="literal">SELECT</code> 内の追加のカラムを選択し、最後の <code class="literal">SELECT</code> のあとに <code class="literal">ORDER BY</code> を追加します。
      </p><pre class="programlisting">
(SELECT 1 AS sort_col, col1a, col1b, ... FROM t1)
UNION
(SELECT 2, col2a, col2b, ... FROM t2) ORDER BY sort_col;
</pre><p>
        さらに個々の <code class="literal">SELECT</code> の結果内のソート順序を維持するには、<code class="literal">ORDER BY</code> 句にセカンダリカラムを追加します。
      </p><pre class="programlisting">
(SELECT 1 AS sort_col, col1a, col1b, ... FROM t1)
UNION
(SELECT 2, col2a, col2b, ... FROM t2) ORDER BY sort_col, col1a;
</pre><p>
        また、追加のカラムを使用すると、各行がどの <code class="literal">SELECT</code> から取得されるかを決定することもできます。追加のカラムでは、テーブル名を示す文字列などのほかの識別情報も指定できます。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="subqueries"></a>13.2.10 サブクエリー構文</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-syntax.html#scalar-subqueries">13.2.10.1 スカラーオペランドとしてのサブクエリー</a></span></dt><dt><span class="section"><a href="sql-syntax.html#comparisons-using-subqueries">13.2.10.2 サブクエリーを使用した比較</a></span></dt><dt><span class="section"><a href="sql-syntax.html#any-in-some-subqueries">13.2.10.3 ANY、IN、または SOME を使用したサブクエリー</a></span></dt><dt><span class="section"><a href="sql-syntax.html#all-subqueries">13.2.10.4 ALL を使用したサブクエリー</a></span></dt><dt><span class="section"><a href="sql-syntax.html#row-subqueries">13.2.10.5 行サブクエリー</a></span></dt><dt><span class="section"><a href="sql-syntax.html#exists-and-not-exists-subqueries">13.2.10.6 EXISTS または NOT EXISTS を使用したサブクエリー</a></span></dt><dt><span class="section"><a href="sql-syntax.html#correlated-subqueries">13.2.10.7 相関サブクエリー</a></span></dt><dt><span class="section"><a href="sql-syntax.html#from-clause-subqueries">13.2.10.8 FROM 句内のサブクエリー</a></span></dt><dt><span class="section"><a href="sql-syntax.html#subquery-errors">13.2.10.9 サブクエリーのエラー</a></span></dt><dt><span class="section"><a href="sql-syntax.html#optimizing-subqueries">13.2.10.10 サブクエリーの最適化</a></span></dt><dt><span class="section"><a href="sql-syntax.html#rewriting-subqueries">13.2.10.11 サブクエリーの結合としての書き換え</a></span></dt></dl></div><a class="indexterm" name="idm139979083451024"></a><a class="indexterm" name="idm139979083449600"></a><a class="indexterm" name="idm139979083448256"></a><a class="indexterm" name="idm139979083446496"></a><p>
      サブクエリーは、別のステートメント内の <code class="literal">SELECT</code> ステートメントです。
    </p><p>
      MySQL 4.1 から、SQL 標準に必要なサブクエリーのすべての形式および操作だけでなく、MySQL 固有のいくつかの機能がサポートされています。
    </p><p>
      サブクエリーの例を次に示します。
    </p><pre class="programlisting">
SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2);
</pre><p>
      この例では、<code class="literal">SELECT * FROM t1 ...</code> が<span class="emphasis"><em>外部クエリー</em></span> (または <span class="emphasis"><em>外部ステートメント</em></span>) であり、<code class="literal">(SELECT column1 FROM t2)</code> が<span class="emphasis"><em>サブクエリー</em></span>です。これを、このサブクエリーは外部クエリー内で<span class="emphasis"><em>ネストされている</em></span>と表現し、また実際、サブクエリーをほかのサブクエリー内で (かなりの深さまで) ネストできます。サブクエリーは常に、括弧内に指定する必要があります。
    </p><p>
      サブクエリーの主な利点は次のとおりです。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ステートメントの各部分を分離できるように、<span class="emphasis"><em>構造化された</em></span>クエリーを可能にします。
        </p></li><li class="listitem"><p>
          通常であれば複雑な結合や和集合を必要とする操作を実行するための代替手段を提供します。
        </p></li><li class="listitem"><p>
          多くの人びとが、サブクエリーを複雑な結合や和集合より読みやすいと感じています。実際、早期の SQL である<span class="quote">「<span class="quote">構造化クエリー言語</span>」</span>を呼び出すという元の考え方を人びとに提供したのは、サブクエリーの技術革新でした。
        </p></li></ul></div><p>
      SQL 標準で指定され、MySQL でサポートされているサブクエリー構文に関する主なポイントを示すステートメントの例を次に示します。
    </p><pre class="programlisting">
DELETE FROM t1
WHERE s11 &gt; ANY
 (SELECT COUNT(*) /* no hint */ FROM t2
  WHERE NOT EXISTS
   (SELECT * FROM t3
    WHERE ROW(5*t2.s1,77)=
     (SELECT 50,11*s1 FROM t4 UNION SELECT 50,77 FROM
      (SELECT * FROM t5) AS t5)));
</pre><p>
      サブクエリーは、スカラー (単一値)、単一行、単一カラム、またはテーブル (1 つ以上のカラムの 1 つ以上の行) を返すことができます。これらは、スカラー、カラム、行、およびテーブルサブクエリーと呼ばれます。特定の種類の結果を返すサブクエリーは多くの場合、次の各セクションで説明されているように、特定のコンテキストでのみ使用できます。
    </p><p>
      サブクエリーを使用できるステートメントのタイプに関する制限はほとんどありません。サブクエリーには、<code class="literal">DISTINCT</code>、<code class="literal">GROUP BY</code>、<code class="literal">ORDER BY</code>、<code class="literal">LIMIT</code>、結合、インデックスヒント、<code class="literal">UNION</code> 構造構文、コメント、関数などの、通常の <code class="literal">SELECT</code> に含めることのできる多くのキーワードや句を含めることができます。
    </p><p>
      サブクエリーの外部ステートメントは、<code class="literal">SELECT</code>、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、<code class="literal">DELETE</code>、<code class="literal">SET</code>、<code class="literal">DO</code> のいずれでもかまいません。
    </p><p>
      MySQL では、テーブルを変更し、さらにサブクエリーで同じテーブルから選択することはできません。これは、<code class="literal">DELETE</code>、<code class="literal">INSERT</code>、<code class="literal">REPLACE</code>、<code class="literal">UPDATE</code>、<code class="literal">LOAD DATA INFILE</code> (サブクエリーは <code class="literal">SET</code> 句で使用できるため) などのステートメントに適用されます。
    </p><p>
      オプティマイザによるサブクエリーの処理方法については、<a class="xref" href="optimization.html#subquery-optimization" title="8.2.1.18 サブクエリーの最適化">セクション8.2.1.18「サブクエリーの最適化」</a>を参照してください。サブクエリーの使用に関する制限の説明 (特定の形式のサブクエリー構文でのパフォーマンスの問題を含む) については、<a class="xref" href="restrictions.html#subquery-restrictions" title="D.4 サブクエリーの制約">セクションD.4「サブクエリーの制約」</a>を参照してください。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="scalar-subqueries"></a>13.2.10.1 スカラーオペランドとしてのサブクエリー</h4></div></div></div><p>
        もっとも単純な形式のサブクエリーは、単一値を返すスカラーサブクエリーです。スカラーサブクエリーは単純なオペランドであるため、単一カラム値またはリテラルが正当である場所であればほぼどこでも使用できるほか、データ型、長さ、<code class="literal">NULL</code> にできることの表示などの、すべてのオペランドが持っている特性を持つことを期待できます。例:
      </p><pre class="programlisting">
CREATE TABLE t1 (s1 INT, s2 CHAR(5) NOT NULL);
INSERT INTO t1 VALUES(100, 'abcde');
SELECT (SELECT s2 FROM t1);
</pre><p>
        この <code class="literal">SELECT</code> 内のサブクエリーは、<code class="literal">CHAR</code> のデータ型、5 の長さ、<code class="literal">CREATE TABLE</code> の時点で有効なデフォルトに等しい文字セットと照合順序、およびこのカラム内の値を <code class="literal">NULL</code> にできることの表示を持つ単一値 (<code class="literal">'abcde'</code>) を返します。サブクエリー結果が空であればその結果は <code class="literal">NULL</code> になるため、スカラーサブクエリーによって選択された値の NULL 可能性はコピーされません。今示したサブクエリーで <code class="literal">t1</code> が空であった場合は、<code class="literal">s2</code> が <code class="literal">NOT NULL</code> であるにもかかわらず、その結果は <code class="literal">NULL</code> になります。
      </p><p>
        スカラーサブクエリーを使用できないコンテキストがいくつか存在します。ステートメントでリテラル値のみが許可されている場合は、サブクエリーを使用できません。たとえば、<code class="literal">LIMIT</code> にはリテラル整数の引数が必要であり、<code class="literal">LOAD DATA INFILE</code> にはリテラル文字列のファイル名が必要です。サブクエリーを使用してこれらの値を指定することはできません。
      </p><p>
        次の各セクションにある、やや簡素な構造構文 <code class="literal">(SELECT column1 FROM t1)</code> が含まれた例を参照するときは、はるかに多様で、かつ複雑な構造構文を含む独自のコードがあるものと考えてください。
      </p><p>
        次の 2 つのテーブルを作成するとします。
      </p><pre class="programlisting">
CREATE TABLE t1 (s1 INT);
INSERT INTO t1 VALUES (1);
CREATE TABLE t2 (s1 INT);
INSERT INTO t2 VALUES (2);
</pre><p>
        次に、<code class="literal">SELECT</code> を実行します。
      </p><pre class="programlisting">
SELECT (SELECT s1 FROM t2) FROM t1;
</pre><p>
        <code class="literal">t2</code> には、<code class="literal">2</code> の値を持つカラム <code class="literal">s1</code> が含まれている行が存在するため、その結果は <code class="literal">2</code> になります。
      </p><p>
        スカラーサブクエリーを式の一部にすることはできますが、そのサブクエリーが関数への引数を提供するオペランドである場合でも、括弧を忘れないでください。例:
      </p><pre class="programlisting">
SELECT UPPER((SELECT s1 FROM t1)) FROM t2;
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="comparisons-using-subqueries"></a>13.2.10.2 サブクエリーを使用した比較</h4></div></div></div><p>
        サブクエリーのもっとも一般的な使用の形式は次のとおりです。
      </p><pre class="programlisting">
<em class="replaceable"><code>non_subquery_operand</code></em> <em class="replaceable"><code>comparison_operator</code></em> (<em class="replaceable"><code>subquery</code></em>)
</pre><p>
        ここで、<em class="replaceable"><code>comparison_operator</code></em> は次の演算子のいずれかです。
      </p><pre class="programlisting">
=  &gt;  &lt;  &gt;=  &lt;=  &lt;&gt;  !=  &lt;=&gt;
</pre><p>
        例:
      </p><pre class="programlisting">
... WHERE 'a' = (SELECT column1 FROM t1)
</pre><p>
        MySQL では、次の構造構文も許可されます。
      </p><pre class="programlisting">
<em class="replaceable"><code>non_subquery_operand</code></em> LIKE (<em class="replaceable"><code>subquery</code></em>)
</pre><p>
        以前は、サブクエリーの唯一の正当な場所は比較の右側であり、この方法にこだわったいくつかの古い DBMS がまだ見つかることもあります。
      </p><p>
        結合では実行できない一般的な形式のサブクエリー比較の例を次に示します。これは、<code class="literal">column1</code> 値がテーブル <code class="literal">t2</code> 内の最大値に等しいテーブル <code class="literal">t1</code> 内のすべての行を検索します。
      </p><pre class="programlisting">
SELECT * FROM t1
  WHERE column1 = (SELECT MAX(column2) FROM t2);
</pre><p>
        次に別の例を示します。これもまた、いずれかのテーブルに対する集約が含まれているため、結合では実行できません。これは、特定のカラムに 2 回現れる値を含むテーブル <code class="literal">t1</code> 内のすべての行を検索します。
      </p><pre class="programlisting">
SELECT * FROM t1 AS t
  WHERE 2 = (SELECT COUNT(*) FROM t1 WHERE t1.id = t.id);
</pre><p>
        スカラーに対するサブクエリーの比較の場合、サブクエリーはスカラーを返す必要があります。行コンストラクタに対するサブクエリーの比較の場合、サブクエリーは、その行コンストラクタと同じ数の値を含む行を返す行サブクエリーである必要があります。<a class="xref" href="sql-syntax.html#row-subqueries" title="13.2.10.5 行サブクエリー">セクション13.2.10.5「行サブクエリー」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="any-in-some-subqueries"></a>13.2.10.3 ANY、IN、または SOME を使用したサブクエリー</h4></div></div></div><a class="indexterm" name="idm139979083362560"></a><a class="indexterm" name="idm139979083360384"></a><a class="indexterm" name="idm139979083359216"></a><a class="indexterm" name="idm139979083357936"></a><p>
        構文:
      </p><pre class="programlisting">
<em class="replaceable"><code>operand</code></em> <em class="replaceable"><code>comparison_operator</code></em> ANY (<em class="replaceable"><code>subquery</code></em>)
<em class="replaceable"><code>operand</code></em> IN (<em class="replaceable"><code>subquery</code></em>)
<em class="replaceable"><code>operand</code></em> <em class="replaceable"><code>comparison_operator</code></em> SOME (<em class="replaceable"><code>subquery</code></em>)
</pre><p>
        ここで、<em class="replaceable"><code>comparison_operator</code></em> は次の演算子のいずれかです。
      </p><pre class="programlisting">
=  &gt;  &lt;  &gt;=  &lt;=  &lt;&gt;  !=
</pre><p>
        <code class="literal">ANY</code> キーワード (これは比較演算子のあとに指定する必要があります) は、<span class="quote">「<span class="quote">このサブクエリーが返すカラム内の値の <code class="literal">ANY</code> (いずれか) に対して比較が <code class="literal">TRUE</code> である場合は <code class="literal">TRUE</code> を返す</span>」</span>ことを示します。例:
      </p><pre class="programlisting">
SELECT s1 FROM t1 WHERE s1 &gt; ANY (SELECT s1 FROM t2);
</pre><p>
        テーブル <code class="literal">t1</code> 内に <code class="literal">(10)</code> を含む行が存在するとします。テーブル <code class="literal">t2</code> に <code class="literal">(21,14,7)</code> が含まれている場合、<code class="literal">t2</code> には <code class="literal">10</code> より小さい値 <code class="literal">7</code> が存在するため、この式は <code class="literal">TRUE</code> です。テーブル <code class="literal">t2</code> に <code class="literal">(20,10)</code> が含まれている場合、またはテーブル <code class="literal">t2</code> が空である場合、この式は <code class="literal">FALSE</code> です。テーブル <code class="literal">t2</code> に <code class="literal">(NULL,NULL,NULL)</code> が含まれている場合、この式は<span class="emphasis"><em>不明</em></span> (つまり、<code class="literal">NULL</code>) です。
      </p><p>
        サブクエリーで使用されている場合、ワード <code class="literal">IN</code> は <code class="literal">= ANY</code> のエイリアスです。そのため、次の 2 つのステートメントは同じです。
      </p><pre class="programlisting">
SELECT s1 FROM t1 WHERE s1 = ANY (SELECT s1 FROM t2);
SELECT s1 FROM t1 WHERE s1 IN    (SELECT s1 FROM t2);
</pre><p>
        式リストで使用されている場合、<code class="literal">IN</code> と <code class="literal">= ANY</code> はシノニムではありません。<code class="literal">IN</code> は式リストを取得できますが、<code class="literal">= ANY</code> はできません。<a class="xref" href="functions.html#comparison-operators" title="12.3.2 比較関数と演算子">セクション12.3.2「比較関数と演算子」</a>を参照してください。
      </p><p>
        <code class="literal">NOT IN</code> は <code class="literal">&lt;&gt; ANY</code> ではなく、<code class="literal">&lt;&gt; ALL</code> のエイリアスです。<a class="xref" href="sql-syntax.html#all-subqueries" title="13.2.10.4 ALL を使用したサブクエリー">セクション13.2.10.4「ALL を使用したサブクエリー」</a>を参照してください。
      </p><p>
        ワード <code class="literal">SOME</code> は <code class="literal">ANY</code> のエイリアスです。そのため、次の 2 つのステートメントは同じです。
      </p><pre class="programlisting">
SELECT s1 FROM t1 WHERE s1 &lt;&gt; ANY  (SELECT s1 FROM t2);
SELECT s1 FROM t1 WHERE s1 &lt;&gt; SOME (SELECT s1 FROM t2);
</pre><p>
        ワード <code class="literal">SOME</code> はほとんど使用されませんが、この例は、これがなぜ役立つ可能性があるかを示しています。ほとんどの人びとにとって、<span class="quote">「<span class="quote">a is not equal to any b</span>」</span>(a はどの b にも等しくない) という英語のフレーズは<span class="quote">「<span class="quote">there is no b which is equal to a</span>」</span>(a に等しい b は存在しない) を示しますが、それはこの SQL 構文が示す内容とは異なります。この構文は、<span class="quote">「<span class="quote">there is some b to which a is not equal</span>」</span>(a に等しくない b がいくつか存在する) を示します。代わりに <code class="literal">&lt;&gt; SOME</code> を使用すると、このクエリーの本当の意味がすべての人に理解されるようにするのに役立ちます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="all-subqueries"></a>13.2.10.4 ALL を使用したサブクエリー</h4></div></div></div><a class="indexterm" name="idm139979083314384"></a><a class="indexterm" name="idm139979083312256"></a><p>
        構文:
      </p><pre class="programlisting">
<em class="replaceable"><code>operand</code></em> <em class="replaceable"><code>comparison_operator</code></em> ALL (<em class="replaceable"><code>subquery</code></em>)
</pre><p>
        ワード <code class="literal">ALL</code> (これは比較演算子のあとに指定する必要があります) は、<span class="quote">「<span class="quote">このサブクエリーが返すカラム内の値の <code class="literal">ALL</code> (すべて) に対して比較が <code class="literal">TRUE</code> である場合は <code class="literal">TRUE</code> を返す</span>」</span>ことを示します。例:
      </p><pre class="programlisting">
SELECT s1 FROM t1 WHERE s1 &gt; ALL (SELECT s1 FROM t2);
</pre><p>
        テーブル <code class="literal">t1</code> 内に <code class="literal">(10)</code> を含む行が存在するとします。テーブル <code class="literal">t2</code> に <code class="literal">(-5,0,+5)</code> が含まれている場合、<code class="literal">10</code> が <code class="literal">t2</code> 内の 3 つのすべての値より大きいため、この式は <code class="literal">TRUE</code> です。テーブル <code class="literal">t2</code> に <code class="literal">(12,6,NULL,-100)</code> が含まれている場合、テーブル <code class="literal">t2</code> には <code class="literal">10</code> より大きい単一値 <code class="literal">12</code> が存在するため、この式は <code class="literal">FALSE</code> です。テーブル <code class="literal">t2</code> に <code class="literal">(0,NULL,1)</code> が含まれている場合、この式は<span class="emphasis"><em>不明</em></span> (つまり、<code class="literal">NULL</code>) です。
      </p><p>
        最後に、テーブル <code class="literal">t2</code> が空である場合、この式は <code class="literal">TRUE</code> です。そのため、テーブル <code class="literal">t2</code> が空であるとき、次の式は <code class="literal">TRUE</code> です。
      </p><pre class="programlisting">
SELECT * FROM t1 WHERE 1 &gt; ALL (SELECT s1 FROM t2);
</pre><p>
        ただし、テーブル <code class="literal">t2</code> が空であるとき、次の式は <code class="literal">NULL</code> です。
      </p><pre class="programlisting">
SELECT * FROM t1 WHERE 1 &gt; (SELECT s1 FROM t2);
</pre><p>
        さらに、テーブル <code class="literal">t2</code> が空であるとき、次の式は <code class="literal">NULL</code> です。
      </p><pre class="programlisting">
SELECT * FROM t1 WHERE 1 &gt; ALL (SELECT MAX(s1) FROM t2);
</pre><p>
        一般に、<span class="emphasis"><em><code class="literal">NULL</code> 値を含むテーブル</em></span>と<span class="emphasis"><em>空のテーブル</em></span>は<span class="quote">「<span class="quote">エッジケース</span>」</span>です。サブクエリーを記述するときは、常に、これらの 2 つの可能性を考慮に入れたかどうかを考慮してください。
      </p><p>
        <code class="literal">NOT IN</code> は <code class="literal">&lt;&gt; ALL</code> のエイリアスです。そのため、次の 2 つのステートメントは同じです。
      </p><pre class="programlisting">
SELECT s1 FROM t1 WHERE s1 &lt;&gt; ALL (SELECT s1 FROM t2);
SELECT s1 FROM t1 WHERE s1 NOT IN (SELECT s1 FROM t2);
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="row-subqueries"></a>13.2.10.5 行サブクエリー</h4></div></div></div><a class="indexterm" name="idm139979083274848"></a><a class="indexterm" name="idm139979083273376"></a><a class="indexterm" name="idm139979083272208"></a><p>
        ここまでの説明は、スカラーまたはカラムサブクエリー、つまり、単一値または値のカラムを返すサブクエリーについてでした。<span class="emphasis"><em>行サブクエリー</em></span>は、単一行を返し、そのために複数のカラム値を返すことができるサブクエリーバリアントです。行サブクエリーの比較のための正当な演算子は次のとおりです。
      </p><pre class="programlisting">
=  &gt;  &lt;  &gt;=  &lt;=  &lt;&gt;  !=  &lt;=&gt;
</pre><p>
        次に、2 つの例を示します。
      </p><pre class="programlisting">
SELECT * FROM t1
  WHERE (col1,col2) = (SELECT col3, col4 FROM t2 WHERE id = 10);
SELECT * FROM t1
  WHERE ROW(col1,col2) = (SELECT col3, col4 FROM t2 WHERE id = 10);
</pre><p>
        どちらのクエリーでも、テーブル <code class="literal">t2</code> に <code class="literal">id = 10</code> を持つ単一行が含まれている場合、このサブクエリーは単一行を返します。この行に <code class="literal">t1</code> 内のいずれかの行の <code class="literal">col1</code> および <code class="literal">col2</code> 値に等しい <code class="literal">col3</code> および <code class="literal">col4</code> 値が含まれている場合、<code class="literal">WHERE</code> 式は <code class="literal">TRUE</code> であり、各クエリーはこれらの <code class="literal">t1</code> 行を返します。<code class="literal">t2</code> 行の <code class="literal">col3</code> および <code class="literal">col4</code> 値が、いずれの <code class="literal">t1</code> 行の <code class="literal">col1</code> および <code class="literal">col2</code> 値にも等しくない場合、この式は <code class="literal">FALSE</code> であり、このクエリーは空の結果セットを返します。サブクエリーによって行が生成されない場合、この式は<span class="emphasis"><em>不明</em></span> (つまり、<code class="literal">NULL</code>) です。サブクエリーによって複数の行が生成される場合は、行サブクエリーが最大で 1 行しか返すことができないため、エラーが発生します。
      </p><p>
        式 <code class="literal">(1,2)</code> や <code class="literal">ROW(1,2)</code> は、<em class="firstterm">行コンストラクタ</em>とも呼ばれます。この 2 つは同等です。行コンストラクタと、サブクエリーによって返される行には、同じ数の値が含まれている必要があります。
      </p><p>
        行コンストラクタは、2 つ以上のカラムを返すサブクエリーとの比較に使用されます。サブクエリーが単一カラムを返すと、これは行ではなく、スカラー値として見なされるため、少なくとも 2 つのカラムを返さないサブクエリーで行コンストラクタを使用することはできません。そのため、次のクエリーは構文エラーで失敗します。
      </p><pre class="programlisting">
SELECT * FROM t1 WHERE ROW(1) = (SELECT column1 FROM t2)
</pre><p>
        行コンストラクタは、ほかのコンテキストでも正当です。たとえば、次の 2 つのステートメントは意味的に同等です (また、オプティマイザによって同じように処理されます)。
      </p><pre class="programlisting">
SELECT * FROM t1 WHERE (column1,column2) = (1,1);
SELECT * FROM t1 WHERE column1 = 1 AND column2 = 1;
</pre><p>
        次のクエリーは、<span class="quote">「<span class="quote">テーブル <code class="literal">t2</code> 内にも存在するテーブル <code class="literal">t1</code> 内のすべての行を検索する</span>」</span>という要求にこたえます。
      </p><pre class="programlisting">
SELECT column1,column2,column3
  FROM t1
  WHERE (column1,column2,column3) IN
         (SELECT column1,column2,column3 FROM t2);
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="exists-and-not-exists-subqueries"></a>13.2.10.6 EXISTS または NOT EXISTS を使用したサブクエリー</h4></div></div></div><a class="indexterm" name="idm139979083240960"></a><a class="indexterm" name="idm139979083238832"></a><a class="indexterm" name="idm139979083236752"></a><a class="indexterm" name="idm139979083234688"></a><p>
        サブクエリーが少なくとも 1 行を返す場合、<code class="literal">EXISTS <em class="replaceable"><code>subquery</code></em></code> は <code class="literal">TRUE</code> であり、<code class="literal">NOT EXISTS <em class="replaceable"><code>subquery</code></em></code> は <code class="literal">FALSE</code> です。例:
      </p><pre class="programlisting">
SELECT column1 FROM t1 WHERE EXISTS (SELECT * FROM t2);
</pre><p>
        従来より、<code class="literal">EXISTS</code> サブクエリーは <code class="literal">SELECT *</code> で始まりますが、<code class="literal">SELECT 5</code> や <code class="literal">SELECT column1</code>、あるいはほかの何で始まってもかまいません。MySQL はこのようなサブクエリー内の <code class="literal">SELECT</code> リストを無視するため、何も違いは生まれません。
      </p><p>
        前の例では、<code class="literal">t2</code> に何らかの行が含まれている場合 (<code class="literal">NULL</code> 値以外は何も含まれていない行でも)、<code class="literal">EXISTS</code> 条件は <code class="literal">TRUE</code> です。<code class="literal">[NOT] EXISTS</code> サブクエリーには、ほぼ常に相互関係が含まれるため、これは実際にはありそうにもない例です。次に、より現実的な例をいくつか示します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            1 つ以上の市に存在するのはどのような種類のお店ですか?
          </p><pre class="programlisting">
SELECT DISTINCT store_type FROM stores
  WHERE EXISTS (SELECT * FROM cities_stores
                WHERE cities_stores.store_type = stores.store_type);
</pre></li><li class="listitem"><p>
            どの市にも存在しないのはどのような種類のお店ですか?
          </p><pre class="programlisting">
SELECT DISTINCT store_type FROM stores
  WHERE NOT EXISTS (SELECT * FROM cities_stores
                    WHERE cities_stores.store_type = stores.store_type);
</pre></li><li class="listitem"><p>
            すべての市に存在するのはどのような種類のお店ですか?
          </p><pre class="programlisting">
SELECT DISTINCT store_type FROM stores s1
  WHERE NOT EXISTS (
    SELECT * FROM cities WHERE NOT EXISTS (
      SELECT * FROM cities_stores
       WHERE cities_stores.city = cities.city
       AND cities_stores.store_type = stores.store_type));
</pre></li></ul></div><p>
        最後の例は、二重にネストされた <code class="literal">NOT EXISTS</code> クエリーです。つまり、<code class="literal">NOT EXISTS</code> 句の中に <code class="literal">NOT EXISTS</code> 句が存在します。これは正式には、<span class="quote">「<span class="quote"><code class="literal">Stores</code> にないお店が含まれている市は存在しますか</span>」</span>? という質問に答えます。ただし、ネストされた <code class="literal">NOT EXISTS</code> が、<span class="quote">「<span class="quote"><em class="replaceable"><code>x</code></em> はすべての <em class="replaceable"><code>y</code></em> に対して <code class="literal">TRUE</code> ですか?</span>」</span>という質問に答えるという方が簡単です。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="correlated-subqueries"></a>13.2.10.7 相関サブクエリー</h4></div></div></div><a class="indexterm" name="idm139979083204832"></a><a class="indexterm" name="idm139979083203376"></a><p>
        <span class="emphasis"><em>相関サブクエリー</em></span>は、外部クエリーにも現れるテーブルへの参照を含むサブクエリーです。例:
      </p><pre class="programlisting">
SELECT * FROM t1
  WHERE column1 = ANY (SELECT column1 FROM t2
                       WHERE t2.column2 = t1.column2);
</pre><p>
        このサブクエリーには、サブクエリーの <code class="literal">FROM</code> 句でテーブル <code class="literal">t1</code> が指定されていない場合でも、<code class="literal">t1</code> のカラムへの参照が含まれます。そのため、MySQL はこのサブクエリーの外部を探し、外部クエリー内の <code class="literal">t1</code> を見つけます。
      </p><p>
        テーブル <code class="literal">t1</code> に <code class="literal">column1 = 5</code> かつ <code class="literal">column2 = 6</code> である行が含まれている一方、テーブル <code class="literal">t2</code> に <code class="literal">column1 = 5</code> かつ <code class="literal">column2 = 7</code> である行が含まれているとします。単純な式 <code class="literal">... WHERE column1 = ANY (SELECT column1 FROM t2)</code> は <code class="literal">TRUE</code> になりますが、この例では、サブクエリー内の <code class="literal">WHERE</code> 句は (<code class="literal">(5,6)</code> が <code class="literal">(5,7)</code> に等しくないため) <code class="literal">FALSE</code> です。そのため、全体としての式は <code class="literal">FALSE</code> です。
      </p><p>
        <span class="bold"><strong>スコープルール:</strong></span> MySQL は、内部から外部に評価します。例:
      </p><pre class="programlisting">
SELECT column1 FROM t1 AS x
  WHERE x.column1 = (SELECT column1 FROM t2 AS x
    WHERE x.column1 = (SELECT column1 FROM t3
      WHERE x.column2 = t3.column1));
</pre><p>
        このステートメントでは、<code class="literal">SELECT column1 FROM t2 AS x ...</code> が <code class="literal">t2</code> の名前を変更するため、<code class="literal">x.column2</code> はテーブル <code class="literal">t2</code> 内のカラムである必要があります。<code class="literal">SELECT column1 FROM t1 ...</code> が<span class="emphasis"><em>さらに外部にある</em></span>外部クエリーであるため、これはテーブル <code class="literal">t1</code> 内のカラムではありません。
      </p><p>
        <code class="literal">HAVING</code> または <code class="literal">ORDER BY</code> 句内のサブクエリーの場合、MySQL は外部選択リスト内でもカラム名を探します。
      </p><p>
        特定のケースでは、相関サブクエリーが最適化されます。例:
      </p><pre class="programlisting">
<em class="replaceable"><code>val</code></em> IN (SELECT <em class="replaceable"><code>key_val</code></em> FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>correlated_condition</code></em>)
</pre><p>
        そうしないと、これらは非効率的であり、遅くなる可能性があります。クエリーを結合として書き換えると、パフォーマンスが向上することがあります。
      </p><p>
        相関サブクエリー内の集約関数には、その関数に外部参照以外は何も含まれておらず、かつその関数が別の関数または式に含まれていない場合、外部参照を含めることができます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="from-clause-subqueries"></a>13.2.10.8 FROM 句内のサブクエリー</h4></div></div></div><a class="indexterm" name="idm139979083170144"></a><a class="indexterm" name="idm139979083168720"></a><p>
        サブクエリーは、<code class="literal">SELECT</code> ステートメントの <code class="literal">FROM</code> 句内で正当です。その実際の構文は次のとおりです。
      </p><pre class="programlisting">
SELECT ... FROM (<em class="replaceable"><code>subquery</code></em>) [AS] <em class="replaceable"><code>name</code></em> ...
</pre><p>
        <code class="literal">FROM</code> 句内のどのテーブルも名前を持っている必要があるため、<code class="literal">[AS] <em class="replaceable"><code>name</code></em></code> 句は必須です。<em class="replaceable"><code>subquery</code></em> 選択リスト内にカラムが存在する場合は、それが一意の名前を持っている必要があります。
      </p><p>
        説明のために、次のテーブルがあるとします。
      </p><pre class="programlisting">
CREATE TABLE t1 (s1 INT, s2 CHAR(5), s3 FLOAT);
</pre><p>
        このテーブルの例を使用して、<code class="literal">FROM</code> 句内のサブクエリーを使用する方法を次に示します。
      </p><pre class="programlisting">
INSERT INTO t1 VALUES (1,'1',1.0);
INSERT INTO t1 VALUES (2,'2',2.0);
SELECT sb1,sb2,sb3
  FROM (SELECT s1 AS sb1, s2 AS sb2, s3*2 AS sb3 FROM t1) AS sb
  WHERE sb1 &gt; 1;
</pre><p>
        結果: <code class="literal">2, '2', 4.0</code>。
      </p><p>
        次に別の例を示します。グループ化されたテーブルに関する一連の合計の平均を知りたいとします。次のクエリーは機能しません。
      </p><pre class="programlisting">
SELECT AVG(SUM(column1)) FROM t1 GROUP BY column1;
</pre><p>
        ただし、次のクエリーは目的の情報を提供します。
      </p><pre class="programlisting">
SELECT AVG(sum_column1)
  FROM (SELECT SUM(column1) AS sum_column1
        FROM t1 GROUP BY column1) AS t1;
</pre><p>
        サブクエリー内で使用されているカラム名 (<code class="literal">sum_column1</code>) は外部クエリーで認識されます。
      </p><p>
        <code class="literal">FROM</code> 句内のサブクエリーは、スカラー、カラム、行、またはテーブルを返すことができます。<code class="literal">FROM</code> 句内のサブクエリーは、<code class="literal">JOIN</code> 操作の <code class="literal">ON</code> 句内で使用されないかぎり、相関サブクエリーにすることはできません。
      </p><p>
        MySQL 5.6.3 より前は、<code class="literal">FROM</code> 句内のサブクエリーは <code class="literal">EXPLAIN</code> ステートメントに対しても実行されます (つまり、派生した一時テーブルが実体化されます)。これは、最適化フェーズ中に上位レベルのクエリーにすべてのテーブルに関する情報が必要であり、かつサブクエリーが実行されないかぎり <code class="literal">FROM</code> 句内のサブクエリーによって表されているテーブルを使用できないために発生します。MySQL 5.6.3 の時点では、オプティマイザは派生テーブルに関する情報を別の方法で特定するため、それらの実体化が <code class="literal">EXPLAIN</code> に対して発生しません。<a class="xref" href="optimization.html#from-clause-subquery-optimization" title="8.2.1.18.3 FROM 句内のサブクエリー (派生テーブル) の最適化">セクション8.2.1.18.3「FROM 句内のサブクエリー (派生テーブル) の最適化」</a>を参照してください。
      </p><p>
        特定の状況では、<code class="literal">EXPLAIN SELECT</code> を使用してテーブルデータを変更できます。これは、外部クエリーがいずれかのテーブルにアクセスし、内部クエリーが、テーブルの 1 つ以上の行を変更するストアドファンクションを呼び出す場合に発生する可能性があります。データベース <code class="literal">d1</code> 内に、次に示すように作成された 2 つのテーブル <code class="literal">t1</code> と <code class="literal">t2</code> があるとします。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE DATABASE d1;</code></strong>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>USE d1;</code></strong>
Database changed

mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT);</code></strong>
Query OK, 0 rows affected (0.15 sec)

mysql&gt; <strong class="userinput"><code>CREATE TABLE t2 (c1 INT);</code></strong>
Query OK, 0 rows affected (0.08 sec)
</pre><p>
        ここで、<code class="literal">t2</code> を変更するストアドファンクション <code class="literal">f1</code> を作成します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>DELIMITER //</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE FUNCTION f1(p1 INT) RETURNS INT</code></strong>
mysql&gt;   <strong class="userinput"><code>BEGIN</code></strong>
mysql&gt;     <strong class="userinput"><code>INSERT INTO t2 VALUES (p1);</code></strong>
mysql&gt;     <strong class="userinput"><code>RETURN p1;</code></strong>
mysql&gt;   <strong class="userinput"><code>END //</code></strong>
Query OK, 0 rows affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>DELIMITER ;</code></strong>
</pre><p>
        次に示すように、<code class="literal">EXPLAIN SELECT</code> でこの関数を直接参照しても、<code class="literal">t2</code> には何も影響を与えません。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT * FROM t2;</code></strong>
Empty set (0.00 sec)

mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT f1(5);</code></strong>
+----+-------------+-------+------+---------------+------+---------+------+------+----------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra          |
+----+-------------+-------+------+---------------+------+---------+------+------+----------------+
|  1 | SIMPLE      | NULL  | NULL | NULL          | NULL | NULL    | NULL | NULL | No tables used |
+----+-------------+-------+------+---------------+------+---------+------+------+----------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM t2;</code></strong>
Empty set (0.00 sec)
</pre><p>
        これは、出力の <code class="literal">table</code> および <code class="literal">Extra</code> カラムでわかるように、<code class="literal">SELECT</code> ステートメントがどのテーブルも参照しなかったためです。これはまた、次のネストされた <code class="literal">SELECT</code> にも当てはまります。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT NOW() AS a1, (SELECT f1(5)) AS a2;</code></strong>
+----+-------------+-------+------+---------------+------+---------+------+------+----------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra          |
+----+-------------+-------+------+---------------+------+---------+------+------+----------------+
|  1 | PRIMARY     | NULL  | NULL | NULL          | NULL | NULL    | NULL | NULL | No tables used |
+----+-------------+-------+------+---------------+------+---------+------+------+----------------+
1 row in set, 1 warning (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+-------+------+------------------------------------------+
| Level | Code | Message                                  |
+-------+------+------------------------------------------+
| Note  | 1249 | Select 2 was reduced during optimization |
+-------+------+------------------------------------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM t2;</code></strong>
Empty set (0.00 sec)
</pre><p>
        ただし、外部の <code class="literal">SELECT</code> がいずれかのテーブルを参照している場合、オプティマイザはそのサブクエリー内のステートメントも実行します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT * FROM t1 AS a1, (SELECT f1(5)) AS a2;</code></strong>
+----+-------------+------------+--------+---------------+------+---------+------+------+---------------------+
| id | select_type | table      | type   | possible_keys | key  | key_len | ref  | rows | Extra               |
+----+-------------+------------+--------+---------------+------+---------+------+------+---------------------+
|  1 | PRIMARY     | a1         | system | NULL          | NULL | NULL    | NULL |    0 | const row not found |
|  1 | PRIMARY     | &lt;derived2&gt; | system | NULL          | NULL | NULL    | NULL |    1 |                     |
|  2 | DERIVED     | NULL       | NULL   | NULL          | NULL | NULL    | NULL | NULL | No tables used      |
+----+-------------+------------+--------+---------------+------+---------+------+------+---------------------+
3 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM t2;</code></strong>
+------+
| c1   |
+------+
|    5 |
+------+
1 row in set (0.00 sec)
</pre><p>
        これはまた、次に示すような <code class="literal">EXPLAIN SELECT</code> ステートメントは、<code class="literal">t1</code> 内の行ごとに 1 回 <code class="literal">BENCHMARK()</code> 関数が実行されるため、実行に長い時間がかかる可能性があることも示しています。
      </p><pre class="programlisting">
EXPLAIN SELECT * FROM t1 AS a1, (SELECT BENCHMARK(1000000, MD5(NOW())));
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="subquery-errors"></a>13.2.10.9 サブクエリーのエラー</h4></div></div></div><a class="indexterm" name="idm139979083099760"></a><a class="indexterm" name="idm139979083097648"></a><p>
        サブクエリーにのみ適用されるエラーがいくつか存在します。このセクションでは、これらについて説明します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            サポートされていないサブクエリー構文:
          </p><pre class="programlisting">
ERROR 1235 (ER_NOT_SUPPORTED_YET)
SQLSTATE = 42000
Message = "This version of MySQL doesn't yet support
'LIMIT &amp; IN/ALL/ANY/SOME subquery'"
</pre><p>
            これは、MySQL が次の形式のステートメントをサポートしていないことを示しています。
          </p><pre class="programlisting">
SELECT * FROM t1 WHERE s1 IN (SELECT s2 FROM t2 ORDER BY s1 LIMIT 1)
</pre></li><li class="listitem"><p>
            サブクエリーからの正しくないカラム数:
          </p><pre class="programlisting">
ERROR 1241 (ER_OPERAND_COL)
SQLSTATE = 21000
Message = "Operand should contain 1 column(s)"
</pre><p>
            このエラーは、次のような場合に発生します。
          </p><pre class="programlisting">
SELECT (SELECT column1, column2 FROM t2) FROM t1;
</pre><p>
            目的が行の比較である場合は、複数のカラムを返すサブクエリーを使用できます。ほかのコンテキストでは、サブクエリーはスカラーオペランドである必要があります。<a class="xref" href="sql-syntax.html#row-subqueries" title="13.2.10.5 行サブクエリー">セクション13.2.10.5「行サブクエリー」</a>を参照してください。
          </p></li><li class="listitem"><p>
            サブクエリーからの正しくない行数:
          </p><pre class="programlisting">
ERROR 1242 (ER_SUBSELECT_NO_1_ROW)
SQLSTATE = 21000
Message = "Subquery returns more than 1 row"
</pre><p>
            このエラーは、サブクエリーが最大で 1 行しか返す必要がないにもかかわらず、複数の行を返すステートメントで発生します。次の例を考えてみます。
          </p><pre class="programlisting">
SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2);
</pre><p>
            <code class="literal">SELECT column1 FROM t2</code> が 1 行だけを返す場合、前のクエリーは機能します。このサブクエリーが複数の行を返す場合は、エラー 1242 が発生します。その場合は、このクエリーを次のように書き換えてください。
          </p><pre class="programlisting">
SELECT * FROM t1 WHERE column1 = ANY (SELECT column1 FROM t2);
</pre></li><li class="listitem"><p>
            サブクエリー内の誤って使用されているテーブル:
          </p><pre class="programlisting">
Error 1093 (ER_UPDATE_TABLE_USED)
SQLSTATE = HY000
Message = "You can't specify target table 'x'
for update in FROM clause"
</pre><p>
            このエラーは、テーブルを変更し、さらにサブクエリーで同じテーブルから選択しようとする次のような場合に発生します。
          </p><pre class="programlisting">
UPDATE t1 SET column2 = (SELECT MAX(column1) FROM t1);
</pre><p>
            サブクエリーは <code class="literal">SELECT</code> ステートメントだけでなく、<code class="literal">UPDATE</code> および <code class="literal">DELETE</code> ステートメント内でも正当であるため、<code class="literal">UPDATE</code> ステートメント内の割り当てのためにサブクエリーを使用できます。ただし、サブクエリーの <code class="literal">FROM</code> 句と更新のターゲットの両方に同じテーブル (この場合は、テーブル <code class="literal">t1</code>) を使用することはできません。
          </p></li></ul></div><p>
        トランザクションストレージエンジンの場合は、サブクエリーが失敗するとステートメント全体が失敗します。非トランザクションストレージエンジンの場合は、エラーが検出される前に行われたデータ変更が保持されます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="optimizing-subqueries"></a>13.2.10.10 サブクエリーの最適化</h4></div></div></div><p>
        開発が進行中であるため、長期にわたって信頼できる最適化のヒントはありません。次のリストは、試してみる価値のある、興味深いいくつかのコツを示しています。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            サブクエリーで、行の数や順序に影響を与えるサブクエリー句を使用します。例:
          </p><pre class="programlisting">
SELECT * FROM t1 WHERE t1.column1 IN
  (SELECT column1 FROM t2 ORDER BY column1);
SELECT * FROM t1 WHERE t1.column1 IN
  (SELECT DISTINCT column1 FROM t2);
SELECT * FROM t1 WHERE EXISTS
  (SELECT * FROM t2 LIMIT 1);
</pre></li><li class="listitem"><p>
            結合をサブクエリーに置き換えます。たとえば、次を試してみてください:
          </p><pre class="programlisting">
SELECT DISTINCT column1 FROM t1 WHERE t1.column1 IN (
  SELECT column1 FROM t2);
</pre><p>
            次の代替として:
          </p><pre class="programlisting">
SELECT DISTINCT t1.column1 FROM t1, t2
  WHERE t1.column1 = t2.column1;
</pre></li><li class="listitem"><p>
            サブクエリーをサポートしていない古いバージョンの MySQL との互換性のために、一部のサブクエリーを結合に変換できます。ただし、場合によっては、サブクエリーを結合に変換するとパフォーマンスが向上することがあります。<a class="xref" href="sql-syntax.html#rewriting-subqueries" title="13.2.10.11 サブクエリーの結合としての書き換え">セクション13.2.10.11「サブクエリーの結合としての書き換え」</a>を参照してください。
          </p></li><li class="listitem"><p>
            句をサブクエリーの外部から内部に移動します。たとえば、次のクエリーを使用してください:
          </p><pre class="programlisting">
SELECT * FROM t1
  WHERE s1 IN (SELECT s1 FROM t1 UNION ALL SELECT s1 FROM t2);
</pre><p>
            次のクエリーの代替として:
          </p><pre class="programlisting">
SELECT * FROM t1
  WHERE s1 IN (SELECT s1 FROM t1) OR s1 IN (SELECT s1 FROM t2);
</pre><p>
            別の例として、このクエリーを使用してください:
          </p><pre class="programlisting">
SELECT (SELECT column1 + 5 FROM t1) FROM t2;
</pre><p>
            次のクエリーの代替として:
          </p><pre class="programlisting">
SELECT (SELECT column1 FROM t1) + 5 FROM t2;
</pre></li><li class="listitem"><p>
            相関サブクエリーの代わりに行サブクエリーを使用します。たとえば、次のクエリーを使用してください:
          </p><pre class="programlisting">
SELECT * FROM t1
  WHERE (column1,column2) IN (SELECT column1,column2 FROM t2);
</pre><p>
            次のクエリーの代替として:
          </p><pre class="programlisting">
SELECT * FROM t1
  WHERE EXISTS (SELECT * FROM t2 WHERE t2.column1=t1.column1
                AND t2.column2=t1.column2);
</pre></li><li class="listitem"><p>
            <code class="literal">a &lt;&gt; ALL (...)</code> ではなく、<code class="literal">NOT (a = ANY (...))</code> を使用します。
          </p></li><li class="listitem"><p>
            <code class="literal">x=1 OR x=2</code> ではなく、<code class="literal">x = ANY (<em class="replaceable"><code>table containing (1,2)</code></em>)</code> を使用します。
          </p></li><li class="listitem"><p>
            <code class="literal">EXISTS</code> ではなく、<code class="literal">= ANY</code> を使用します。
          </p></li><li class="listitem"><p>
            常に 1 行を返す非相関サブクエリーの場合、<code class="literal">IN</code> は常に <code class="literal">=</code> より低速です。たとえば、次のクエリーを使用してください:
          </p><pre class="programlisting">
SELECT * FROM t1
  WHERE t1.<em class="replaceable"><code>col_name</code></em> = (SELECT a FROM t2 WHERE b = <em class="replaceable"><code>some_const</code></em>);
</pre><p>
            次のクエリーの代替として:
          </p><pre class="programlisting">
SELECT * FROM t1
  WHERE t1.<em class="replaceable"><code>col_name</code></em> IN (SELECT a FROM t2 WHERE b = <em class="replaceable"><code>some_const</code></em>);
</pre></li></ul></div><p>
        これらのコツにより、プログラムは速くなる場合も遅くなる場合もあります。<code class="literal">BENCHMARK()</code> 関数などの MySQL 機能を使用すると、現在の状況に何が役立つかについてのアイデアを得ることができます。<a class="xref" href="functions.html#information-functions" title="12.14 情報関数">セクション12.14「情報関数」</a>を参照してください。
      </p><p>
        MySQL 自体が行ういくつかの最適化を次に示します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            MySQL は、非相関サブクエリーを 1 回だけ実行します。特定のサブクエリーが実際に非相関になるようにするには、<code class="literal">EXPLAIN</code> を使用します。
          </p></li><li class="listitem"><p>
            MySQL は、サブクエリー内の選択リストカラムにインデックスが設定される可能性を利用しようとして、<code class="literal">IN</code>、<code class="literal">ALL</code>、<code class="literal">ANY</code>、および <code class="literal">SOME</code> サブクエリーを書き換えます。
          </p></li><li class="listitem"><p>
            MySQL は、次の形式のサブクエリーをインデックス検索関数に置き換えます。この関数は、<code class="literal">EXPLAIN</code> によって特殊な結合型 (<code class="literal">unique_subquery</code> または <code class="literal">index_subquery</code>) として記述されます。
          </p><pre class="programlisting">
... IN (SELECT <em class="replaceable"><code>indexed_column</code></em> FROM <em class="replaceable"><code>single_table</code></em> ...)
</pre></li><li class="listitem"><p>
            MySQL は次の形式の式を、<code class="literal">NULL</code> 値または空のセットが含まれていないかぎり、<code class="literal">MIN()</code> または <code class="literal">MAX()</code> を含む式に拡張します。
          </p><pre class="programlisting">
<em class="replaceable"><code>value</code></em> {ALL|ANY|SOME} {&gt; | &lt; | &gt;= | &lt;=} (<em class="replaceable"><code>uncorrelated subquery</code></em>)
</pre><p>
            たとえば、次の <code class="literal">WHERE</code> 句
          </p><pre class="programlisting">
WHERE 5 &gt; ALL (SELECT x FROM t)
</pre><p>
            は、オプティマイザによって次のように処理される可能性があります。
          </p><pre class="programlisting">
WHERE 5 &gt; (SELECT MAX(x) FROM t)
</pre></li></ul></div><p>
        「<a class="ulink" href="http://dev.mysql.com/doc/internals/en/transformations.html" target="_top">MySQL Internals: How MySQL Transforms Subqueries</a>」も参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="rewriting-subqueries"></a>13.2.10.11 サブクエリーの結合としての書き換え</h4></div></div></div><a class="indexterm" name="idm139979083011552"></a><p>
        場合によっては、一連の値におけるメンバーシップをテストするために、サブクエリーを使用する以外の方法が存在することがあります。また、クエリーをサブクエリーなしで書き換えることが可能なだけでなく、サブクエリーを使用する代わりにこれらの手法のいくつかを使用する方が効率的になる場合もあります。これらのうちの 1 つが <code class="literal">IN()</code> 構造構文です。
      </p><p>
        たとえば、次のクエリー
      </p><pre class="programlisting">
SELECT * FROM t1 WHERE id IN (SELECT id FROM t2);
</pre><p>
        は次のように書き換えることができます。
      </p><pre class="programlisting">
SELECT DISTINCT t1.* FROM t1, t2 WHERE t1.id=t2.id;
</pre><p>
        次のクエリー
      </p><pre class="programlisting">
SELECT * FROM t1 WHERE id NOT IN (SELECT id FROM t2);
SELECT * FROM t1 WHERE NOT EXISTS (SELECT id FROM t2 WHERE t1.id=t2.id);
</pre><p>
        は次のように書き換えることができます。
      </p><pre class="programlisting">
SELECT table1.*
  FROM table1 LEFT JOIN table2 ON table1.id=table2.id
  WHERE table2.id IS NULL;
</pre><p>
        <code class="literal">LEFT [OUTER] JOIN</code> は、サーバーがそれをより適切に最適化できる可能性がある (MySQL Server だけに特有の事実ではありません) ため、同等のサブクエリーより高速になる場合があります。SQL-92 より前は、外部結合が存在しなかったため、サブクエリーが特定の処理を実行するための唯一の方法でした。今日では、MySQL Server やその他の多くの最新データベースシステムがさまざまなタイプの外部結合を提供しています。
      </p><p>
        MySQL Server は、1 つのテーブルからの情報や、場合によっては一度に多数のテーブルからの情報に基づいて行を効率的に削除するために使用できる複数テーブルの <code class="literal">DELETE</code> ステートメントをサポートしています。また、複数テーブルの <code class="literal">UPDATE</code> ステートメントもサポートされています。<a class="xref" href="sql-syntax.html#delete" title="13.2.2 DELETE 構文">セクション13.2.2「DELETE 構文」</a>および<a class="xref" href="sql-syntax.html#update" title="13.2.11 UPDATE 構文">セクション13.2.11「UPDATE 構文」</a>を参照してください。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="update"></a>13.2.11 UPDATE 構文</h3></div></div></div><a class="indexterm" name="idm139979082995120"></a><a class="indexterm" name="idm139979082993808"></a><p>
      単一テーブル構文:
    </p><pre class="programlisting">
UPDATE [LOW_PRIORITY] [IGNORE] <em class="replaceable"><code>table_reference</code></em>
    SET <em class="replaceable"><code>col_name1</code></em>={<em class="replaceable"><code>expr1</code></em>|DEFAULT} [, <em class="replaceable"><code>col_name2</code></em>={<em class="replaceable"><code>expr2</code></em>|DEFAULT}] ...
    [WHERE <em class="replaceable"><code>where_condition</code></em>]
    [ORDER BY ...]
    [LIMIT <em class="replaceable"><code>row_count</code></em>]
</pre><p>
      複数テーブル構文:
    </p><pre class="programlisting">
UPDATE [LOW_PRIORITY] [IGNORE] <em class="replaceable"><code>table_references</code></em>
    SET <em class="replaceable"><code>col_name1</code></em>={<em class="replaceable"><code>expr1</code></em>|DEFAULT} [, <em class="replaceable"><code>col_name2</code></em>={<em class="replaceable"><code>expr2</code></em>|DEFAULT}] ...
    [WHERE <em class="replaceable"><code>where_condition</code></em>]
</pre><p>
      単一テーブル構文の場合、<code class="literal">UPDATE</code> ステートメントは、指定されたテーブル内の既存の行のカラムを新しい値に更新します。<code class="literal">SET</code> 句は、変更するカラムと、それらのカラムに指定される値を示します。各値は式か、またはカラムを明示的にそのデフォルト値に設定するキーワード <code class="literal">DEFAULT</code> として指定できます。<code class="literal">WHERE</code> 句 (指定されている場合) は、どの行を更新するかを識別する条件を指定します。<code class="literal">WHERE</code> 句がない場合は、すべての行が更新されます。<code class="literal">ORDER BY</code> 句が指定されている場合は、指定されている順序で行が更新されます。<code class="literal">LIMIT</code> 句は、更新できる行数に制限を設定します。
    </p><p>
      複数テーブル構文の場合、<code class="literal">UPDATE</code> は、条件を満たす <em class="replaceable"><code>table_references</code></em> で指定されている各テーブル内の行を更新します。一致した各行は、条件に複数回一致した場合でも、1 回更新されます。複数テーブル構文の場合は、<code class="literal">ORDER BY</code> および <code class="literal">LIMIT</code> を使用できません。
    </p><p>
      パーティション化されたテーブルの場合は、このステートメントの単一テーブルと複数テーブルの両方の形式で、テーブル参照の一部としての <code class="literal">PARTITION</code> オプションの使用がサポートされます。このオプションは、1 つ以上のパーティションまたはサブパーティション (またはその両方) のリストを受け取ります。リストされているパーティション (またはサブパーティション) だけが一致をチェックされ、これらのパーティションまたはサブパーティションのいずれにも存在しない行は、<em class="replaceable"><code>where_condition</code></em> を満たすかどうかにかかわらず更新されません。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">INSERT</code> または <code class="literal">REPLACE</code> ステートメントで <code class="literal">PARTITION</code> を使用している場合とは異なり、それ以外は有効な <code class="literal">UPDATE ... PARTITION</code> ステートメントは、リストされているパーティション (またはサブパーティション) 内のどの行も <em class="replaceable"><code>where_condition</code></em> に一致しない場合でも成功したと見なされます。
      </p></div><p>
      詳細および例については、<a class="xref" href="partitioning.html#partitioning-selection" title="19.5 パーティション選択">セクション19.5「パーティション選択」</a>を参照してください。
    </p><p>
      <em class="replaceable"><code>where_condition</code></em> は、更新される各行に対して true に評価される式です。式の構文については、<a class="xref" href="language-structure.html#expressions" title="9.5 式の構文">セクション9.5「式の構文」</a>を参照してください。
    </p><p>
      <em class="replaceable"><code>table_references</code></em> と <em class="replaceable"><code>where_condition</code></em> は、<a class="xref" href="sql-syntax.html#select" title="13.2.9 SELECT 構文">セクション13.2.9「SELECT 構文」</a>で説明されているように指定されます。
    </p><p>
      実際に更新された、<code class="literal">UPDATE</code> 内で参照されているカラムに対してのみ <code class="literal">UPDATE</code> 権限が必要です。読み取られるが、変更されないカラムに対しては、<code class="literal">SELECT</code> 権限のみが必要です。
    </p><p>
      <code class="literal">UPDATE</code> ステートメントは、次の修飾子をサポートします。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">LOW_PRIORITY</code> キーワードを使用すると、<code class="literal">UPDATE</code> の実行は、ほかのどのクライアントもそのテーブルから読み取らなくなるまで遅延されます。これは、テーブルレベルロックのみを使用するストレージエンジン (<code class="literal">MyISAM</code>、<code class="literal">MEMORY</code>、および <code class="literal">MERGE</code>) にのみ影響を与えます。
        </p></li><li class="listitem"><p>
          <code class="literal">IGNORE</code> キーワードを指定すると、更新中にエラーが発生した場合でも、更新ステートメントは中止されません。一意のキー値に関して重複キーの競合が発生した行は更新されません。データ変換エラーの原因になる値に更新された行は、代わりに、もっとも近い有効な値に更新されます。
        </p></li></ul></div><p>
      MySQL 5.6.4 以降では、<code class="literal">UPDATE IGNORE</code> ステートメント (<code class="literal">ORDER BY</code> 句が存在するものを含む)、には、ステートメントベースのレプリケーションには安全でないというフラグが付けられます。(これは、どの行が無視されるかが、行が更新される順序によって決定されるためです。)この変更により、このようなステートメントは、ステートメントベースモードを使用しているときはログ内に警告を生成し、<code class="literal">MIXED</code> モードを使用しているときは行ベース形式を使用してログに記録されます。(Bug #11758262、Bug #50439) 詳細は、<a class="xref" href="replication.html#replication-rbr-safe-unsafe" title="17.1.2.3 バイナリロギングでの安全および安全でないステートメントの判断">セクション17.1.2.3「バイナリロギングでの安全および安全でないステートメントの判断」</a>を参照してください。
    </p><p>
      式で更新されるテーブルのカラムにアクセスする場合、<code class="literal">UPDATE</code> はそのカラムの現在の値を使用します。たとえば、次のステートメントは、<code class="literal">col1</code> をその現在の値より 1 大きい値に設定します。
    </p><pre class="programlisting">
UPDATE t1 SET col1 = col1 + 1;
</pre><p>
      次のステートメントの 2 番目の割り当ては、<code class="literal">col2</code> を元の <code class="literal">col1</code> 値ではなく、現在の (更新された) <code class="literal">col1</code> 値に設定します。この結果、<code class="literal">col1</code> と <code class="literal">col2</code> の値が同じになります。この動作は標準 SQL とは異なります。
    </p><pre class="programlisting">
UPDATE t1 SET col1 = col1 + 1, col2 = col1;
</pre><p>
      単一テーブルの <code class="literal">UPDATE</code> の割り当ては一般に、左から右に評価されます。複数テーブルの更新では、割り当てが特定の順序で実行される保証はありません。
    </p><p>
      カラムをその現在の値に設定した場合は、MySQL がこれに気付き、その更新を行いません。
    </p><p>
      <code class="literal">NOT NULL</code> として宣言されているカラムを <code class="literal">NULL</code> に設定することによって更新すると、厳密な SQL モードが有効になっている場合は、エラーが発生します。そうでない場合、カラムはそのカラムデータ型の暗黙のデフォルト値に設定され、警告数が 1 増やされます。暗黙のデフォルト値は、数値型では <code class="literal">0</code>、文字列型では空の文字列 (<code class="literal">''</code>)、および日付と時間型では<span class="quote">「<span class="quote">0</span>」</span>の値です。<a class="xref" href="data-types.html#data-type-defaults" title="11.6 データ型デフォルト値">セクション11.6「データ型デフォルト値」</a>を参照してください。
    </p><a class="indexterm" name="idm139979082922544"></a><p>
      <code class="literal">UPDATE</code> は、実際に変更された行数を返します。<code class="literal">mysql_info()</code> C API 関数は、一致して更新された行数と、<code class="literal">UPDATE</code> 中に発生した警告の数を返します。
    </p><p>
      <code class="literal">LIMIT <em class="replaceable"><code>row_count</code></em></code> を使用すると、<code class="literal">UPDATE</code> のスコープを制限できます。<code class="literal">LIMIT</code> 句は、一致した行の制限です。このステートメントは、実際に変更されたかどうかにかかわらず、<code class="literal">WHERE</code> 句を満たす <em class="replaceable"><code>row_count</code></em> 行を見つけるとすぐに停止します。
    </p><p>
      <code class="literal">UPDATE</code> ステートメントに <code class="literal">ORDER BY</code> 句が含まれている場合は、この句で指定されている順序で行が更新されます。これは、通常であればエラーが発生する可能性のある特定の状況で役立つ場合があります。テーブル <code class="literal">t</code> に、一意のインデックスを持つカラム <code class="literal">id</code> が含まれているとします。次のステートメントは、行が更新される順序によっては、重複キーエラーで失敗する可能性があります。
    </p><pre class="programlisting">
UPDATE t SET id = id + 1;
</pre><p>
      たとえば、このテーブルの <code class="literal">id</code> カラムに 1 と 2 が含まれており、2 が 3 に更新される前に 1 が 2 に更新された場合は、エラーが発生します。この問題を回避するには、大きな <code class="literal">id</code> 値を持つ行が小さな値を持つ行の前に更新されるように、<code class="literal">ORDER BY</code> 句を追加します。
    </p><pre class="programlisting">
UPDATE t SET id = id + 1 ORDER BY id DESC;
</pre><p>
      また、複数のテーブルを範囲に含む <code class="literal">UPDATE</code> 操作を実行することもできます。ただし、複数テーブルの <code class="literal">UPDATE</code> では <code class="literal">ORDER BY</code> または <code class="literal">LIMIT</code> を使用できません。<em class="replaceable"><code>table_references</code></em> 句は、結合に含まれるテーブルをリストします。その構文については、<a class="xref" href="sql-syntax.html#join" title="13.2.9.2 JOIN 構文">セクション13.2.9.2「JOIN 構文」</a>で説明されています。次に例を示します。
    </p><pre class="programlisting">
UPDATE items,month SET items.price=month.price
WHERE items.id=month.id;
</pre><p>
      前の例は、カンマ演算子を使用する内部結合を示していますが、複数テーブルの <code class="literal">UPDATE</code> ステートメントは、<code class="literal">SELECT</code> ステートメント内で許可されている任意の型の結合 (<code class="literal">LEFT JOIN</code> など) を使用できます。
    </p><p>
      外部キー制約が存在する <code class="literal">InnoDB</code> テーブルを含む、複数テーブルの <code class="literal">UPDATE</code> ステートメントを使用した場合は、MySQL オプティマイザが、それらの親子関係の順序とは異なる順序でテーブルを処理する可能性があります。この場合、このステートメントは失敗し、ロールバックされます。代わりに、1 つのテーブルを更新したあと、<code class="literal">InnoDB</code> が提供する <code class="literal">ON UPDATE</code> 機能を使用して、ほかのテーブルがそれに応じて変更されるようにします。<a class="xref" href="innodb-storage-engine.html#innodb-foreign-key-constraints" title="14.6.6 InnoDB と FOREIGN KEY 制約">セクション14.6.6「InnoDB と FOREIGN KEY 制約」</a>を参照してください。
    </p><p>
      現在、テーブルを更新し、さらにサブクエリーで同じテーブルから選択することはできません。
    </p><p>
      MySQL 5.6.6 より前は、テーブルレベルのロックを採用した <code class="literal">MyISAM</code> などのストレージエンジンを使用しているパーティション化されたテーブルに対する <code class="literal">UPDATE</code> によって、そのテーブルのすべてのパーティションがロックされました。これは、<code class="literal">UPDATE ... PARTITION</code> クエリーにも当てはまりました。(これは、行レベルロックを採用した <code class="literal">InnoDB</code> などのストレージエンジンでは発生しておらず、現在も発生しません。)MySQL 5.6.6 以降では、MySQL はパーティションロックプルーニングを使用します。これにより、そのテーブルのいずれかのパーティション化カラムが更新されないかぎり、<code class="literal">UPDATE</code> ステートメントの <code class="literal">WHERE</code> 句に一致する行を含むパーティションだけが実際にロックされるようになります。詳細は、<a class="xref" href="partitioning.html#partitioning-limitations-locking" title="19.6.4 パーティショニングとロック">セクション19.6.4「パーティショニングとロック」</a>を参照してください。
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sql-syntax-transactions"></a>13.3 MySQL トランザクションおよびロックステートメント</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-syntax.html#commit">13.3.1 START TRANSACTION、COMMIT、および ROLLBACK 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#cannot-roll-back">13.3.2 ロールバックできないステートメント</a></span></dt><dt><span class="section"><a href="sql-syntax.html#implicit-commit">13.3.3 暗黙的なコミットを発生させるステートメント</a></span></dt><dt><span class="section"><a href="sql-syntax.html#savepoint">13.3.4 SAVEPOINT、ROLLBACK TO SAVEPOINT、および RELEASE SAVEPOINT 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#lock-tables">13.3.5 LOCK TABLES および UNLOCK TABLES 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#set-transaction">13.3.6 SET TRANSACTION 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#xa">13.3.7 XA トランザクション</a></span></dt></dl></div><p>
    MySQL は、<code class="literal">SET autocommit</code>、<code class="literal">START TRANSACTION</code>、<code class="literal">COMMIT</code>、<code class="literal">ROLLBACK</code> などのステートメントを介して (特定のクライアントセッション内の) ローカルトランザクションをサポートしています。<a class="xref" href="sql-syntax.html#commit" title="13.3.1 START TRANSACTION、COMMIT、および ROLLBACK 構文">セクション13.3.1「START TRANSACTION、COMMIT、および ROLLBACK 構文」</a>を参照してください。XA トランザクションサポートにより、MySQL は分散トランザクションにも参加できます。<a class="xref" href="sql-syntax.html#xa" title="13.3.7 XA トランザクション">セクション13.3.7「XA トランザクション」</a>を参照してください。
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="commit"></a>13.3.1 START TRANSACTION、COMMIT、および ROLLBACK 構文</h3></div></div></div><a class="indexterm" name="idm139979082870032"></a><a class="indexterm" name="idm139979082868720"></a><a class="indexterm" name="idm139979082867376"></a><a class="indexterm" name="idm139979082866032"></a><pre class="programlisting">
START TRANSACTION
    [<em class="replaceable"><code>transaction_characteristic</code></em> [, <em class="replaceable"><code>transaction_characteristic</code></em>] ...]

<em class="replaceable"><code>transaction_characteristic</code></em>:
    WITH CONSISTENT SNAPSHOT
  | READ WRITE
  | READ ONLY

BEGIN [WORK]
COMMIT [WORK] [AND [NO] CHAIN] [[NO] RELEASE]
ROLLBACK [WORK] [AND [NO] CHAIN] [[NO] RELEASE]
SET autocommit = {0 | 1}
</pre><p>
      次のステートメントにより、<a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a>の使用を制御できます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">START TRANSACTION</code> または <code class="literal">BEGIN</code> は、新しいトランザクションを開始します。
        </p></li><li class="listitem"><p>
          <code class="literal">COMMIT</code> は、現在のトランザクションをコミットして、その変更を永続的なものにします。
        </p></li><li class="listitem"><p>
          <code class="literal">ROLLBACK</code> は、現在のトランザクションをロールバックして、その変更を取り消します。
        </p></li><li class="listitem"><p>
          <code class="literal">SET autocommit</code> は、現在のセッションのデフォルトの自動コミットモードを無効または有効にします。
        </p></li></ul></div><p>
      デフォルトでは、MySQL は<a class="link" href="glossary.html#glos_autocommit" title="自動コミット">自動コミット</a>モードが有効になった状態で動作します。つまり、テーブルを更新 (変更) するステートメントを実行するとすぐに、MySQL によってその更新がディスクに格納されて永続的になります。この変更はロールバックできません。
    </p><p>
      一連のステートメントに対して自動コミットモードを暗黙的に無効にするには、<code class="literal">START TRANSACTION</code> ステートメントを使用します。
    </p><pre class="programlisting">
START TRANSACTION;
SELECT @A:=SUM(salary) FROM table1 WHERE type=1;
UPDATE table2 SET summary=@A WHERE type=1;
COMMIT;
</pre><p>
      <code class="literal">START TRANSACTION</code> を使用すると、そのトランザクションを <code class="literal">COMMIT</code> または <code class="literal">ROLLBACK</code> で終了するまで、自動コミットは無効のままになります。そのあと、自動コミットモードはその以前の状態に戻ります。
    </p><p>
      <code class="literal">START TRANSACTION</code> では、トランザクションの特性を制御するいくつかの修飾子が許可されます。複数の修飾子を指定するには、それらをカンマで区切ります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">WITH CONSISTENT SNAPSHOT</code> 修飾子は、この機能に対応しているストレージエンジンでの<a class="link" href="glossary.html#glos_consistent_read" title="一貫性読み取り">一貫性読み取り</a>を開始します。これは、<code class="literal">InnoDB</code> にのみ適用されます。その効果は、任意の <code class="literal">InnoDB</code> テーブルから <code class="literal">START TRANSACTION</code> に続けて <code class="literal">SELECT</code> を発行することと同じです。<a class="xref" href="innodb-storage-engine.html#innodb-consistent-read" title="14.2.4 一貫性非ロック読み取り">セクション14.2.4「一貫性非ロック読み取り」</a>を参照してください。<code class="literal">WITH CONSISTENT SNAPSHOT</code> 修飾子は、現在のトランザクション<a class="link" href="glossary.html#glos_isolation_level" title="分離レベル">分離レベル</a>を変更しないため、現在の分離レベルが一貫性読み取りを許可するものである場合にのみ、整合性のあるスナップショットを提供します。一貫性読み取りを許可する分離レベルは、<code class="literal">REPEATABLE READ</code> だけです。その他のすべての分離レベルの場合、<code class="literal">WITH CONSISTENT SNAPSHOT</code> 句は無視されます。
        </p></li><li class="listitem"><p>
          <code class="literal">READ WRITE</code> および <code class="literal">READ ONLY</code> 修飾子は、トランザクションアクセスモードを設定します。これらは、そのトランザクションで使用されるテーブルへの変更を許可または禁止します。<code class="literal">READ ONLY</code> の制限は、そのトランザクションが、ほかのトランザクションに表示されるトランザクションテーブルと非トランザクションテーブルの両方を変更またはロックしないようにします。このトランザクションは引き続き、一時テーブルを変更またはロックできます。これらの修飾子は、MySQL 5.6.5 の時点で使用できます。
        </p><p>
          MySQL では、トランザクションが読み取り専用であることがわかっている場合、<code class="literal">InnoDB</code> テーブルに対するクエリーの追加の最適化が可能です。<code class="literal">READ ONLY</code> を指定すると、読み取り専用ステータスを自動的に特定できない場合に、これらの最適化が適用されることが保証されます。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-ro-txn" title="14.13.14 InnoDB の読み取り専用トランザクションの最適化">セクション14.13.14「InnoDB の読み取り専用トランザクションの最適化」</a>を参照してください。
        </p><p>
          アクセスモードが指定されていない場合は、デフォルトモードが適用されます。デフォルトが変更されていないかぎり、それは読み取り/書き込みです。同じステートメント内で <code class="literal">READ WRITE</code> と <code class="literal">READ ONLY</code> の両方を指定することは許可されません。
        </p><p>
          読み取り専用モードでは、DML ステートメントを使用して <code class="literal">TEMPORARY</code> キーワードで作成されたテーブルは引き続き変更できます。永続的なテーブルと同様に、DDL ステートメントによって行われる変更は許可されません。
        </p><p>
          トランザクションアクセスモードの詳細 (デフォルトモードを変更する方法を含む) は、<a class="xref" href="sql-syntax.html#set-transaction" title="13.3.6 SET TRANSACTION 構文">セクション13.3.6「SET TRANSACTION 構文」</a>を参照してください。
        </p><p>
          <code class="literal">read_only</code> システム変数が有効になっている場合、トランザクションを <code class="literal">START TRANSACTION READ WRITE</code> で明示的に開始するには、<code class="literal">SUPER</code> 権限が必要です。
        </p></li></ul></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        MySQL クライアントアプリケーションを記述するために使用される多くの API (JDBC など) は、クライアントから <code class="literal">START TRANSACTION</code> ステートメントを送信する代わりに使用できる (また、場合によっては使用すべき)、トランザクションを開始するための独自のメソッドを提供しています。詳細は、<a class="xref" href="connectors-apis.html" title="第 23 章 Connector および API">第23章「<i>Connector および API</i>」</a>または API のドキュメントを参照してください。
      </p></div><p>
      自動コミットモードを明示的に無効にするには、次のステートメントを使用します。
    </p><pre class="programlisting">
SET autocommit=0;
</pre><p>
      <code class="literal">autocommit</code> 変数を 0 に設定することによって自動コミットモードを無効にしたあと、トランザクションセーフテーブル (<code class="literal">InnoDB</code> または <code class="literal">NDB</code> のテーブルなど) への変更がただちに永続的になることはありません。<code class="literal">COMMIT</code> を使用して変更をディスクに格納するか、または <code class="literal">ROLLBACK</code> を使用して変更を無視する必要があります。
    </p><p>
      <code class="literal">autocommit</code> はセッション変数であるため、セッションごとに設定する必要があります。新しい接続ごとに自動コミットモードを無効にするには、<a class="xref" href="server-administration.html#server-system-variables" title="5.1.4 サーバーシステム変数">セクション5.1.4「サーバーシステム変数」</a>にある <code class="literal">autocommit</code> システム変数の説明を参照してください。
    </p><p>
      <code class="literal">BEGIN</code> と <code class="literal">BEGIN WORK</code> は、トランザクションを開始するための <code class="literal">START TRANSACTION</code> のエイリアスとしてサポートされています。標準の SQL 構文である <code class="literal">START TRANSACTION</code> は、アドホックトランザクションを開始するための推奨される方法であり、<code class="literal">BEGIN</code> では許可されない修飾子が許可されます。
    </p><p>
      <code class="literal">BEGIN</code> ステートメントは、<code class="literal">BEGIN ... END</code> 複合ステートメントを開始する <code class="literal">BEGIN</code> キーワードの使用とは異なります。後者はトランザクションを開始しません。<a class="xref" href="sql-syntax.html#begin-end" title="13.6.1 BEGIN ... END 複合ステートメント構文">セクション13.6.1「BEGIN ... END 複合ステートメント構文」</a>を参照してください。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        すべてのストアドプログラム (ストアドプロシージャーとストアドファンクション、トリガー、およびイベント) 内で、パーサーは、<code class="literal">BEGIN [WORK]</code> を <code class="literal">BEGIN ... END</code> ブロックの開始として扱います。このコンテキストでは、代わりに <code class="literal">START TRANSACTION</code> を使用してトランザクションを開始します。
      </p></div><p>
      オプションの <code class="literal">WORK</code> キーワードは、<code class="literal">CHAIN</code> および <code class="literal">RELEASE</code> 句と同様に、<code class="literal">COMMIT</code> と <code class="literal">ROLLBACK</code> に対してサポートされています。<code class="literal">CHAIN</code> と <code class="literal">RELEASE</code> は、トランザクションの完了に対する追加の制御に使用できます。<code class="literal">completion_type</code> システム変数の値によって、デフォルトの完了動作が決定されます。<a class="xref" href="server-administration.html#server-system-variables" title="5.1.4 サーバーシステム変数">セクション5.1.4「サーバーシステム変数」</a>を参照してください。
    </p><p>
      <code class="literal">AND CHAIN</code> 句を指定すると、現在のトランザクションが終了するとすぐに新しいトランザクションが開始され、新しいトランザクションの分離レベルは終了したばかりのトランザクションと同じになります。<code class="literal">RELEASE</code> 句を指定すると、サーバーは、現在のトランザクションを終了したあと現在のクライアントセッションを切り離します。<code class="literal">NO</code> キーワードを含めると、<code class="literal">CHAIN</code> または <code class="literal">RELEASE</code> の完了が抑制されます。これは、<code class="literal">completion_type</code> システム変数がデフォルトで、チェーンまたはリリースの完了が実行されるように設定されている場合に役立つことがあります。
    </p><p>
      トランザクションを開始すると、保留中のトランザクションはすべてコミットされます。詳細は、<a class="xref" href="sql-syntax.html#implicit-commit" title="13.3.3 暗黙的なコミットを発生させるステートメント">セクション13.3.3「暗黙的なコミットを発生させるステートメント」</a>を参照してください。
    </p><p>
      また、トランザクションを開始すると、ユーザーが <code class="literal">UNLOCK TABLES</code> を実行したかのように、<code class="literal">LOCK TABLES</code> によって取得されたテーブルロックも解放されます。トランザクションを開始しても、<code class="literal">FLUSH TABLES WITH READ LOCK</code> によって取得されたグローバルな読み取りロックは解放されません。
    </p><p>
      最適な結果を得るために、トランザクションは、1 つのトランザクションセーフストレージエンジンによって管理されているテーブルのみを使用して実行するようにしてください。そうしないと、次の問題が発生する場合があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          複数のトランザクションセーフストレージエンジン (<code class="literal">InnoDB</code> など) からのテーブルを使用しており、かつトランザクション分離レベルが <code class="literal">SERIALIZABLE</code> でない場合は、あるトランザクションがコミットしたときに、同じテーブルを使用している別の進行中のトランザクションに最初のトランザクションによって行われた変更の一部しか表示されない可能性があります。つまり、混在したエンジンではトランザクションのアトミック性が保証されないため、不整合が発生する場合があります。(混在したエンジンでのトランザクションの頻度が低い場合は、<code class="literal">SET TRANSACTION ISOLATION LEVEL</code> を使用して、必要に応じてトランザクションごとに分離レベルを <code class="literal">SERIALIZABLE</code> に設定できます。) 
        </p></li><li class="listitem"><p>
          トランザクション内でトランザクションセーフでないテーブルを使用する場合は、自動コミットモードのステータスには関係なく、それらのテーブルへの変更が一度に格納されます。
        </p></li><li class="listitem"><p>
          トランザクション内で非トランザクションテーブルを更新したあとに <code class="literal">ROLLBACK</code> ステートメントを発行すると、<code class="literal">ER_WARNING_NOT_COMPLETE_ROLLBACK</code> 警告が発生します。トランザクションセーフテーブルへの変更はロールバックされますが、非トランザクションセーフテーブルへの変更はロールバックされません。
        </p></li></ul></div><p>
      各トランザクションは、<code class="literal">COMMIT</code> 時に、1 つのまとまりでバイナリログに格納されます。ロールバックされたトランザクションはログに記録されません。(<span class="bold"><strong>例外</strong></span>: 非トランザクションテーブルへの変更はロールバックできません。ロールバックされるトランザクションに非トランザクションテーブルへの変更が含まれている場合は、非トランザクションテーブルへの変更が確実にレプリケートされるようにするために、最後に <code class="literal">ROLLBACK</code> ステートメントを使用してトランザクション全体がログに記録されます。) <a class="xref" href="server-administration.html#binary-log" title="5.2.4 バイナリログ">セクション5.2.4「バイナリログ」</a>を参照してください。
    </p><p>
      トランザクションの分離レベルまたはアクセスモードは、<code class="literal">SET TRANSACTION</code> ステートメントを使用して変更できます。<a class="xref" href="sql-syntax.html#set-transaction" title="13.3.6 SET TRANSACTION 構文">セクション13.3.6「SET TRANSACTION 構文」</a>を参照してください。
    </p><p>
      ロールバックは、ユーザーが明示的に求めることなく (たとえば、エラーの発生時に) 暗黙的に発生する可能性のある低速な操作になる場合があります。このため、<code class="literal">ROLLBACK</code> ステートメントを使用して実行された明示的なロールバックに対してだけでなく、暗黙のロールバックに対しても、<code class="literal">SHOW PROCESSLIST</code> はセッションの <code class="literal">State</code> カラムに <code class="literal">Rolling back</code> を表示します。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        MySQL 5.6 では、<code class="literal">BEGIN</code>、<code class="literal">COMMIT</code>、および <code class="literal">ROLLBACK</code> は <code class="option">--replicate-do-db</code> または <code class="option">--replicate-ignore-db</code> ルールによって影響を受けません。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="cannot-roll-back"></a>13.3.2 ロールバックできないステートメント</h3></div></div></div><p>
      いくつかのステートメントはロールバックできません。これには一般に、データベースを作成または削除したり、テーブルやストアドルーチンを作成、削除、または変更したりするデータ定義言語 (DDL) ステートメントが含まれます。
    </p><p>
      このようなステートメントを含まないようにトランザクションを設計してください。ロールバックできないステートメントをトランザクション内で早期に発行し、そのあと別のステートメントが失敗したとすると、このような場合に <code class="literal">ROLLBACK</code> ステートメントを発行してもそのトランザクションのすべての効果をロールバックすることはできません。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="implicit-commit"></a>13.3.3 暗黙的なコミットを発生させるステートメント</h3></div></div></div><p>
      このセクションに示されているステートメント (およびそのすべてのシノニム) は、ユーザーがこのステートメントを実行する前に <code class="literal">COMMIT</code> を実行したかのように、現在のセッション内でアクティブなすべてのトランザクションを暗黙的に終了します。MySQL 5.5.3 の時点では、これらのステートメントのほとんどが、実行後に暗黙的なコミットも発生させます。詳細は、このセクションの最後を参照してください。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <span class="bold"><strong>データベースオブジェクトを定義または変更するデータ定義言語 (DDL) ステートメント。</strong></span><code class="literal">ALTER DATABASE ... UPGRADE DATA DIRECTORY NAME</code>、<code class="literal">ALTER EVENT</code>、<code class="literal">ALTER PROCEDURE</code>、<code class="literal">ALTER SERVER</code>、<code class="literal">ALTER TABLE</code>、<code class="literal">ALTER VIEW</code>、<code class="literal">CREATE DATABASE</code>、<code class="literal">CREATE EVENT</code>、<code class="literal">CREATE INDEX</code>、<code class="literal">CREATE PROCEDURE</code>、<code class="literal">CREATE SERVER</code>、<code class="literal">CREATE TABLE</code>、<code class="literal">CREATE TRIGGER</code>、<code class="literal">CREATE VIEW</code>、<code class="literal">DROP DATABASE</code>、<code class="literal">DROP EVENT</code>、<code class="literal">DROP INDEX</code>、<code class="literal">DROP PROCEDURE</code>、<code class="literal">DROP SERVER</code>、<code class="literal">DROP TABLE</code>、<code class="literal">DROP TRIGGER</code>、<code class="literal">DROP VIEW</code>、<code class="literal">RENAME TABLE</code>、<code class="literal">TRUNCATE TABLE</code>。
        </p><p>
          <code class="literal">ALTER FUNCTION</code>、<code class="literal">CREATE FUNCTION</code>、および <code class="literal">DROP FUNCTION</code> もまた、ストアドファンクション (ただし、UDF を除く) で使用された場合は暗黙的なコミットを発生させます。(<code class="literal">ALTER FUNCTION</code> は、ストアドファンクションでのみ使用できます。) 
        </p><p>
          <code class="literal">CREATE TABLE</code> および <code class="literal">DROP TABLE</code> ステートメントは、<code class="literal">TEMPORARY</code> キーワードが使用されている場合はトランザクションをコミットしません。(これは、コミットを発生させる <code class="literal">ALTER TABLE</code> や <code class="literal">CREATE INDEX</code> などの、一時テーブルに対するその他の操作には適用されません。) ただし、暗黙的なコミットは発生しませんが、ステートメントのロールバックもできません。つまり、このようなステートメントを使用すると、トランザクションのアトミック性が侵害されます。たとえば、<code class="literal">CREATE TEMPORARY TABLE</code> を使用したあとにトランザクションをロールバックしても、そのテーブルは存在し続けます。
        </p><p>
          <code class="literal">InnoDB</code> での <code class="literal">CREATE TABLE</code> ステートメントは、1 つのトランザクションとして処理されます。つまり、ユーザーが <code class="literal">ROLLBACK</code> を発行しても、ユーザーがそのトランザクション中に実行した <code class="literal">CREATE TABLE</code> ステートメントは元に戻されません。
        </p><p>
          <code class="literal">CREATE TABLE ... SELECT</code> は、一時テーブル以外のテーブルを作成している場合、そのステートメントが実行される前後に暗黙的なコミットを発生させます。(<code class="literal">CREATE TEMPORARY TABLE ... SELECT</code> に対してコミットは発生しません。)これは、ロールバック後にマスター上でテーブルを作成できたが、バイナリログへの記録に失敗したため、スレーブにはレプリケートされないというレプリケーション中の問題を回避するために行われます。詳細は、Bug #22865 を参照してください。
        </p></li><li class="listitem"><p>
          <span class="bold"><strong><code class="literal">mysql</code> データベース内のテーブルを暗黙的に使用または変更するステートメント。</strong></span><code class="literal">CREATE USER</code>、<code class="literal">DROP USER</code>、<code class="literal">GRANT</code>、<code class="literal">RENAME USER</code>、<code class="literal">REVOKE</code>、<code class="literal">SET PASSWORD</code>。
        </p></li><li class="listitem"><p>
          <span class="bold"><strong>トランザクション制御およびロックステートメント。</strong></span><code class="literal">BEGIN</code>、<code class="literal">LOCK TABLES</code>、<code class="literal">SET autocommit = 1</code> (この値がまだ 1 でない場合)、<code class="literal">START TRANSACTION</code>、<code class="literal">UNLOCK TABLES</code>。
        </p><p>
          <code class="literal">UNLOCK TABLES</code> は、非トランザクションテーブルロックを取得するために現在 <code class="literal">LOCK TABLES</code> でロックされているテーブルがある場合にのみ、トランザクションをコミットします。<code class="literal">FLUSH TABLES WITH READ LOCK</code> はテーブルレベルのロックを取得しないため、このステートメントに続く <code class="literal">UNLOCK TABLES</code> に対してコミットは発生しません。
        </p><p>
          トランザクションをネストすることはできません。これは、<code class="literal">START TRANSACTION</code> ステートメントまたはそのシノニムのいずれかを発行するときに、現在のすべてのトランザクションに対して実行される暗黙的なコミットの結果です。
        </p><p>
          XA トランザクションが <code class="literal">ACTIVE</code> 状態にある間に、暗黙的なコミットを発生させるステートメントをそのトランザクションで使用することはできません。
        </p><p>
          <code class="literal">BEGIN</code> ステートメントは、<code class="literal">BEGIN ... END</code> 複合ステートメントを開始する <code class="literal">BEGIN</code> キーワードの使用とは異なります。後者は暗黙的なコミットを発生させません。<a class="xref" href="sql-syntax.html#begin-end" title="13.6.1 BEGIN ... END 複合ステートメント構文">セクション13.6.1「BEGIN ... END 複合ステートメント構文」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <span class="bold"><strong>データロードステートメント。</strong></span><code class="literal">LOAD DATA INFILE</code>。<code class="literal">LOAD DATA INFILE</code> は、<code class="literal">NDB</code> ストレージエンジンを使用しているテーブルに対してのみ暗黙的なコミットを発生させます。詳細は、Bug #11151 を参照してください。
        </p></li><li class="listitem"><p>
          <span class="bold"><strong>管理ステートメント。</strong></span><code class="literal">ANALYZE TABLE</code>、<code class="literal">CACHE INDEX</code>、<code class="literal">CHECK TABLE</code>、<code class="literal">LOAD INDEX INTO CACHE</code>、<code class="literal">OPTIMIZE TABLE</code>、<code class="literal">REPAIR TABLE</code>。
        </p></li><li class="listitem"><p>
          <span class="bold"><strong>レプリケーション制御ステートメント</strong></span>。MySQL 5.6.7 から: <code class="literal">START SLAVE</code>、<code class="literal">STOP SLAVE</code>、<code class="literal">RESET SLAVE</code>、<code class="literal">CHANGE MASTER TO</code>。(Bug #13858841)
        </p></li></ul></div><p>
      MySQL 5.5.3 の時点では、以前は実行前に暗黙的なコミットを発生させたステートメントのほとんどが、実行後にも発生させます。その目的は、このような各ステートメントはいずれにしてもロールバックできないため、それを独自の特殊なトランザクションで処理することにあります。次のリストは、この変更に関連する追加の詳細を示しています。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          以前は特殊なケースであった <code class="literal">CREATE TABLE</code> バリアント (<code class="literal">InnoDB</code> テーブルに対する <code class="literal">CREATE TABLE</code> や <code class="literal">CREATE TABLE ... SELECT</code>) は、<code class="literal">CREATE TABLE</code> が一様に実行の前後に暗黙的なコミットを発生させるため、現在では特殊ではなくなっています。
        </p></li><li class="listitem"><p>
          <code class="literal">FLUSH</code> および <code class="literal">RESET</code> ステートメントは暗黙的なコミットを発生させます。
        </p></li><li class="listitem"><p>
          トランザクション制御およびロックステートメントは、以前と同様に動作します。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="savepoint"></a>13.3.4 SAVEPOINT、ROLLBACK TO SAVEPOINT、および RELEASE SAVEPOINT 構文</h3></div></div></div><a class="indexterm" name="idm139979082623312"></a><a class="indexterm" name="idm139979082622000"></a><a class="indexterm" name="idm139979082620656"></a><pre class="programlisting">
SAVEPOINT <em class="replaceable"><code>identifier</code></em>
ROLLBACK [WORK] TO [SAVEPOINT] <em class="replaceable"><code>identifier</code></em>
RELEASE SAVEPOINT <em class="replaceable"><code>identifier</code></em>
</pre><p>
      <code class="literal">InnoDB</code> は、SQL ステートメント <code class="literal">SAVEPOINT</code>、<code class="literal">ROLLBACK TO SAVEPOINT</code>、<code class="literal">RELEASE SAVEPOINT</code> のほか、<code class="literal">ROLLBACK</code> のオプションの <code class="literal">WORK</code> キーワードをサポートしています。
    </p><p>
      <code class="literal">SAVEPOINT</code> ステートメントは、<em class="replaceable"><code>identifier</code></em> の名前を持つ名前付きのトランザクションセーブポイントを設定します。現在のトランザクションに同じ名前を持つセーブポイントが含まれている場合、古いセーブポイントは削除され、新しいセーブポイントが設定されます。
    </p><p>
      <code class="literal">ROLLBACK TO SAVEPOINT</code> ステートメントは、トランザクションを終了することなく、そのトランザクションを指定されたセーブポイントにロールバックします。セーブポイントが設定されたあとに現在のトランザクションが行に対して行なった変更はロールバックで元に戻されますが、<code class="literal">InnoDB</code> は、セーブポイントのあとにメモリーに格納された行ロックを解放<span class="emphasis"><em>しません</em></span>。(新しく挿入された行の場合、ロック情報は、その行に格納されているトランザクション ID によって伝達されます。ロックが個別にメモリーに格納されるわけではありません。この場合、行ロックは Undo で解放されます。)指定されたセーブポイントよりあとで設定されたセーブポイントは削除されます。
    </p><p>
      <code class="literal">ROLLBACK TO SAVEPOINT</code> ステートメントが次のエラーを返した場合は、指定された名前を持つセーブポイントが存在しないことを示しています。
    </p><pre class="programlisting">
ERROR 1305 (42000): SAVEPOINT <em class="replaceable"><code>identifier</code></em> does not exist
</pre><p>
      <code class="literal">RELEASE SAVEPOINT</code> ステートメントは、指定されたセーブポイントを現在のトランザクションの一連のセーブポイントから削除します。コミットまたはロールバックは発生しません。そのセーブポイントが存在しない場合はエラーになります。
    </p><p>
      <code class="literal">COMMIT</code>、またはセーブポイントを指定しない <code class="literal">ROLLBACK</code> を実行した場合は、現在のトランザクションのすべてのセーブポイントが削除されます。
    </p><p>
      ストアドファンクションが呼び出されるか、またはトリガーがアクティブ化されると、新しいセーブポイントレベルが作成されます。以前のレベルにあるセーブポイントは使用できなくなるため、新しいレベルのセーブポイントとは競合しません。関数またはトリガーが終了すると、その関数またはトリガーによって作成されたセーブポイントはすべて解放され、以前のセーブポイントレベルがリストアされます。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="lock-tables"></a>13.3.5 LOCK TABLES および UNLOCK TABLES 構文</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-syntax.html#lock-tables-and-transactions">13.3.5.1 テーブルロックとトランザクションの通信</a></span></dt><dt><span class="section"><a href="sql-syntax.html#lock-tables-and-triggers">13.3.5.2 LOCK TABLES とトリガー</a></span></dt><dt><span class="section"><a href="sql-syntax.html#lock-tables-restrictions">13.3.5.3 テーブルロックの制限と条件</a></span></dt></dl></div><a class="indexterm" name="idm139979082589136"></a><a class="indexterm" name="idm139979082587824"></a><pre class="programlisting">
LOCK TABLES
    <em class="replaceable"><code>tbl_name</code></em> [[AS] <em class="replaceable"><code>alias</code></em>] <em class="replaceable"><code>lock_type</code></em>
    [, <em class="replaceable"><code>tbl_name</code></em> [[AS] <em class="replaceable"><code>alias</code></em>] <em class="replaceable"><code>lock_type</code></em>] ...

<em class="replaceable"><code>lock_type</code></em>:
    READ [LOCAL]
  | [LOW_PRIORITY] WRITE

UNLOCK TABLES
</pre><p>
      MySQL では、クライアントセッションは、ほかのセッションと連携してテーブルにアクセスするために、またはそのセッションにテーブルへの排他的アクセスが必要な期間中はほかのセッションによってそのテーブルが変更されないようにするために、明示的にテーブルロックを取得できます。セッションがロックを取得または解放できるのは、それ自体のためだけです。あるセッションが別のセッションのためにロックを取得したり、別のセッションによって保持されているロックを解放したりすることはできません。
    </p><p>
      ロックを使用すると、トランザクションをエミュレートするか、またはテーブル更新時の速度を向上させることができます。これについては、このセクションのあとの方でさらに詳細に説明されています。
    </p><p>
      <code class="literal">LOCK TABLES</code> は、現在のクライアントセッションのテーブルロックを明示的に取得します。テーブルロックは、ベーステーブルまたはビューに対して取得できます。ロックされる各オブジェクトに対する <code class="literal">LOCK TABLES</code> 権限と <code class="literal">SELECT</code> 権限が必要です。
    </p><p>
      ビューのロックの場合、<code class="literal">LOCK TABLES</code> は、そのビューで使用されているすべてのベーステーブルをロックされるテーブルのセットに追加し、それらのテーブルを自動的にロックします。<a class="xref" href="sql-syntax.html#lock-tables-and-triggers" title="13.3.5.2 LOCK TABLES とトリガー">セクション13.3.5.2「LOCK TABLES とトリガー」</a>で説明されているように、<code class="literal">LOCK TABLES</code> によって明示的にテーブルをロックした場合は、トリガーで使用されているテーブルもすべて暗黙的にロックされます。
    </p><p>
      <code class="literal">UNLOCK TABLES</code> は、現在のセッションによって保持されているテーブルロックをすべて明示的に解放します。<code class="literal">LOCK TABLES</code> は、新しいロックを取得する前に、現在のセッションによって保持されているテーブルロックをすべて暗黙的に解放します。
    </p><p>
      <code class="literal">UNLOCK TABLES</code> の別の使用法として、すべてのデータベース内のすべてのテーブルをロックできる <code class="literal">FLUSH TABLES WITH READ LOCK</code> ステートメントによって取得されたグローバルな読み取りロックの解放があります。<a class="xref" href="sql-syntax.html#flush" title="13.7.6.3 FLUSH 構文">セクション13.7.6.3「FLUSH 構文」</a>を参照してください。(これは、特定時点のスナップショットを取得できる、Veritas などのファイルシステムがある場合にバックアップを取得するための非常に便利な方法です。)
    </p><p>
      テーブルロックでは、ほかのセッションによる不適切な読み取りまたは書き込みからのみ保護されます。<code class="literal">WRITE</code> ロックを保持しているセッションは、<code class="literal">DROP TABLE</code> や <code class="literal">TRUNCATE TABLE</code> などのテーブルレベルの操作を実行できます。<code class="literal">READ</code> ロックを保持しているセッションの場合、<code class="literal">DROP TABLE</code> および <code class="literal">TRUNCATE TABLE</code> 操作は許可されません。<code class="literal">TRUNCATE TABLE</code> 操作はトランザクションセーフではないため、セッションがアクティブなトランザクション中または <code class="literal">READ</code> ロックを保持している間にこの操作を行おうとすると、エラーが発生します。
    </p><p>
      次の説明は、<code class="literal">TEMPORARY</code> 以外のテーブルにのみ適用されます。<code class="literal">LOCK TABLES</code> は <code class="literal">TEMPORARY</code> テーブルに対して許可されます (ただし、無視されます)。テーブルは、ほかのどのようなロックが有効になっているかには関係なく、そのテーブルが作成されたセッションから自由にアクセスできます。ほかのどのセッションもそのテーブルを参照できないため、ロックは必要ありません。
    </p><p>
      <code class="literal">LOCK TABLES</code> の使用に関するその他の条件や、<code class="literal">LOCK TABLES</code> が有効になっている間は使用できないステートメントについては、<a class="xref" href="sql-syntax.html#lock-tables-restrictions" title="13.3.5.3 テーブルロックの制限と条件">セクション13.3.5.3「テーブルロックの制限と条件」</a>を参照してください。
    </p><p>
      <span class="bold"><strong>ロック取得のルール</strong></span>
    </p><p>
      現在のセッション内でテーブルロックを取得するには、<code class="literal">LOCK TABLES</code> ステートメントを使用します。次のロックタイプを使用できます。
    </p><p>
      <code class="literal">READ [LOCAL]</code> ロック:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          このロックを保持しているセッションは、テーブルを読み取ることができます (ただし、書き込みはできません)。
        </p></li><li class="listitem"><p>
          複数のセッションが同時にテーブルに対する <code class="literal">READ</code> ロックを取得できます。
        </p></li><li class="listitem"><p>
          ほかのセッションは、<code class="literal">READ</code> ロックを明示的に取得することなく、テーブルを読み取ることができます。
        </p></li><li class="listitem"><p>
          <code class="literal">LOCAL</code> 修飾子を使用すると、ロックが保持されている間、ほかのセッションによる競合しない <code class="literal">INSERT</code> ステートメント (並列挿入) を実行できます。(<a class="xref" href="optimization.html#concurrent-inserts" title="8.10.3 同時挿入">セクション8.10.3「同時挿入」</a>を参照してください。)ただし、ロックを保持している間、サーバーの外部にあるプロセスを使用してデータベースを操作しようとしている場合は、<code class="literal">READ LOCAL</code> を使用できません。<code class="literal">InnoDB</code> テーブルの場合、<code class="literal">READ LOCAL</code> は <code class="literal">READ</code> と同じです。
        </p></li></ul></div><p>
      <code class="literal">[LOW_PRIORITY] WRITE</code> ロック:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          このロックを保持しているセッションは、テーブルの読み取りおよび書き込みが可能です。
        </p></li><li class="listitem"><p>
          このロックを保持しているセッションだけがテーブルにアクセスできます。ロックが解放されるまで、ほかのどのセッションもアクセスできません。
        </p></li><li class="listitem"><p>
          <code class="literal">WRITE</code> ロックが保持されている間、テーブルに対するほかのセッションからのロック要求はブロックされます。
        </p></li><li class="listitem"><p>
          <code class="literal">LOW_PRIORITY</code> 修飾子は何の効果もありません。以前のバージョンの MySQL では、ロックの動作に影響を与えましたが、これは当てはまらなくなっています。MySQL 5.6.5 の時点では、これは非推奨であり、使用すると警告が生成されます。代わりに、<code class="literal">LOW_PRIORITY</code> のない <code class="literal">WRITE</code> を使用してください。
        </p></li></ul></div><p>
      <code class="literal">LOCK TABLES</code> ステートメントが、いずれかのテーブルに対するほかのセッションによって保持されているロックのために待機する必要がある場合、このステートメントはすべてのロックを取得できるまでブロックされます。
    </p><p>
      ロックが必要なセッションは、必要なすべてのロックを 1 つの <code class="literal">LOCK TABLES</code> ステートメントで取得する必要があります。このように取得されたロックが保持されている間、このセッションは、ロックされたテーブルにのみアクセスできます。たとえば、次のステートメントシーケンスでは、<code class="literal">t2</code> が <code class="literal">LOCK TABLES</code> ステートメントでロックされていないため、このテーブルにアクセスしようとするとエラーが発生します。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>LOCK TABLES t1 READ;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT COUNT(*) FROM t1;</code></strong>
+----------+
| COUNT(*) |
+----------+
|        3 |
+----------+
mysql&gt; <strong class="userinput"><code>SELECT COUNT(*) FROM t2;</code></strong>
ERROR 1100 (HY000): Table 't2' was not locked with LOCK TABLES
</pre><p>
      <code class="literal">INFORMATION_SCHEMA</code> データベース内のテーブルは例外です。これらのテーブルは、セッションが <code class="literal">LOCK TABLES</code> によって取得されたテーブルロックを保持している間であっても、明示的にロックされることなくアクセスできます。
    </p><p>
      ロックされたテーブルを、同じ名前を使用して 1 つのクエリーで複数回参照することはできません。代わりにエイリアスを使用し、そのテーブルと各エイリアスのための個別のロックを取得します。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>LOCK TABLE t WRITE, t AS t1 READ;</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t SELECT * FROM t;</code></strong>
ERROR 1100: Table 't' was not locked with LOCK TABLES
mysql&gt; <strong class="userinput"><code>INSERT INTO t SELECT * FROM t AS t1;</code></strong>
</pre><p>
      最初の <code class="literal">INSERT</code> では、ロックされたテーブルに対する同じ名前への参照が 2 つ存在するため、エラーが発生します。2 番目の <code class="literal">INSERT</code> は、テーブルへの参照で異なる名前が使用されるため、成功します。
    </p><p>
      ステートメントがエイリアスを使用してテーブルを参照する場合は、その同じエイリアスを使用してテーブルをロックする必要があります。エイリアスを指定しないでテーブルをロックすることはできません。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>LOCK TABLE t READ;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT * FROM t AS myalias;</code></strong>
ERROR 1100: Table 'myalias' was not locked with LOCK TABLES
</pre><p>
      逆に、エイリアスを使用してテーブルをロックする場合は、ステートメント内でそのエイリアスを使用してテーブルを参照する必要があります。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>LOCK TABLE t AS myalias READ;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT * FROM t;</code></strong>
ERROR 1100: Table 't' was not locked with LOCK TABLES
mysql&gt; <strong class="userinput"><code>SELECT * FROM t AS myalias;</code></strong>
</pre><p>
      <code class="literal">WRITE</code> ロックは通常、更新ができるだけ早く処理されるように、<code class="literal">READ</code> ロックより高い優先度を持っています。つまり、あるセッションが <code class="literal">READ</code> ロックを取得したあと、別のセッションが <code class="literal">WRITE</code> ロックを要求した場合は、<code class="literal">WRITE</code> ロックを要求したセッションがロックを取得して解放するまで、以降の <code class="literal">READ</code> ロック要求が待たされます。
    </p><p>
      <code class="literal">LOCK TABLES</code> は、次のようにロックを取得します。
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          ロックされるすべてのテーブルを内部で定義された順序でソートします。ユーザーから見て、この順序は定義されていません。
        </p></li><li class="listitem"><p>
          テーブルを読み取りおよび書き込みロックでロックする場合は、書き込みロック要求を読み取りロック要求の前に配置します。
        </p></li><li class="listitem"><p>
          セッションがすべてのロックを取得するまで、1 回につき 1 つのテーブルをロックします。
        </p></li></ol></div><p>
      このポリシーによって、テーブルロックでデッドロックが発生しないことが保証されます。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">LOCK TABLES</code> または <code class="literal">UNLOCK TABLES</code> は、パーティション化されたテーブルに適用された場合、常にテーブル全体をロックまたはロック解除します。これらのステートメントは、パーティションロックプルーニングをサポートしていません。<a class="xref" href="partitioning.html#partitioning-limitations-locking" title="19.6.4 パーティショニングとロック">セクション19.6.4「パーティショニングとロック」</a>を参照してください。
      </p></div><p>
      <span class="bold"><strong>ロック解放のルール</strong></span>
    </p><p>
      セッションによって保持されているテーブルロックが解放される場合は、すべてのテーブルロックが一度に解放されます。セッションは明示的にロックを解放できます。また、特定の状況で、ロックが暗黙的に解放される場合もあります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          セッションは、<code class="literal">UNLOCK TABLES</code> によって明示的にロックを解放できます。
        </p></li><li class="listitem"><p>
          セッションがすでにロックを保持している間にロックを取得するために <code class="literal">LOCK TABLES</code> ステートメントを発行した場合は、新しいロックが付与される前に、その既存のロックが暗黙的に解放されます。
        </p></li><li class="listitem"><p>
          セッションが (たとえば、<code class="literal">START TRANSACTION</code> で) トランザクションを開始した場合は、暗黙的な <code class="literal">UNLOCK TABLES</code> が実行され、既存のロックが解放されます。(テーブルロックとトランザクションの間の通信の詳細は、<a class="xref" href="sql-syntax.html#lock-tables-and-transactions" title="13.3.5.1 テーブルロックとトランザクションの通信">セクション13.3.5.1「テーブルロックとトランザクションの通信」</a>を参照してください。) 
        </p></li></ul></div><p>
      クライアントセッションの接続が (正常または異常にかかわらず) 終了した場合、サーバーは、そのセッションによって保持されているすべてのテーブルロック (トランザクションおよび非トランザクション) を暗黙的に解放します。そのクライアントが再接続した場合、ロックは有効でなくなります。さらに、クライアントにアクティブなトランザクションがある場合、サーバーは切断時にそのトランザクションをロールバックし、再接続が発生した場合は、自動コミットが有効になった状態で新しいセッションが開始されます。このため、クライアントは自動再接続を無効にすることが必要になる場合があります。自動再接続が有効な場合、再接続が発生してもクライアントには通知されませんが、すべてのテーブルロックまたは現在のトランザクションが失われます。自動再接続が無効になっている場合は、接続が削除されると、発行された次のステートメントに対してエラーが発生します。クライアントはそのエラーを検出し、ロックの再取得やトランザクションの再実行などの適切なアクションを実行できます。<a class="xref" href="connectors-apis.html#auto-reconnect" title="23.8.16 自動再接続動作の制御">セクション23.8.16「自動再接続動作の制御」</a>を参照してください。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        ロックされたテーブル上で <code class="literal">ALTER TABLE</code> を使用すると、そのテーブルがロック解除される場合があります。たとえば、2 番目の <code class="literal">ALTER TABLE</code> 操作を試みると、エラー<code class="literal">「テーブル '<em class="replaceable"><code>tbl_name</code></em>' は LOCK TABLES でロックされていません」</code>が発生する場合があります。これに対処するには、2 番目の変更の前にテーブルを再度ロックします。<a class="xref" href="error-handling.html#alter-table-problems" title="B.5.7.1 ALTER TABLE での問題">セクションB.5.7.1「ALTER TABLE での問題」</a>も参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="lock-tables-and-transactions"></a>13.3.5.1 テーブルロックとトランザクションの通信</h4></div></div></div><a class="indexterm" name="idm139979082459088"></a><p>
        <code class="literal">LOCK TABLES</code> および <code class="literal">UNLOCK TABLES</code> は、トランザクションの使用との間で次のように通信します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">LOCK TABLES</code> はトランザクションセーフではないため、テーブルをロックしようとする前に、アクティブなトランザクションをすべて暗黙的にコミットします。
          </p></li><li class="listitem"><p>
            <code class="literal">UNLOCK TABLES</code> は、アクティブなトランザクションをすべて暗黙的にコミットしますが、これが行われるのは、テーブルロックを取得するために <code class="literal">LOCK TABLES</code> が使用された場合のみです。たとえば、次の一連のステートメントでは、<code class="literal">UNLOCK TABLES</code> がグローバルな読み取りロックを解放しますが、有効なテーブルロックがないためにトランザクションはコミットされません。
          </p><pre class="programlisting">
FLUSH TABLES WITH READ LOCK;
START TRANSACTION;
SELECT ... ;
UNLOCK TABLES;
</pre></li><li class="listitem"><p>
            トランザクションを (たとえば、<code class="literal">START TRANSACTION</code> で) 開始すると、現在のトランザクションはすべて暗黙的にコミットされ、既存のテーブルロックが解放されます。
          </p></li><li class="listitem"><p>
            <code class="literal">FLUSH TABLES WITH READ LOCK</code> は、グローバルな読み取りロックを取得しますが、テーブルロックは取得しないため、テーブルロックと暗黙的なコミットに関して <code class="literal">LOCK TABLES</code> および <code class="literal">UNLOCK TABLES</code> と同じ動作には従いません。たとえば、<code class="literal">START TRANSACTION</code> は、グローバルな読み取りロックを解放しません。<a class="xref" href="sql-syntax.html#flush" title="13.7.6.3 FLUSH 構文">セクション13.7.6.3「FLUSH 構文」</a>を参照してください。
          </p></li><li class="listitem"><p>
            暗黙的にトランザクションのコミットを発生させるその他のステートメントは、既存のテーブルロックを解放しません。このようなステートメントのリストについては、<a class="xref" href="sql-syntax.html#implicit-commit" title="13.3.3 暗黙的なコミットを発生させるステートメント">セクション13.3.3「暗黙的なコミットを発生させるステートメント」</a>を参照してください。
          </p></li><li class="listitem"><p>
            トランザクションテーブル (<code class="literal">InnoDB</code> テーブルなど) で <code class="literal">LOCK TABLES</code> および <code class="literal">UNLOCK TABLES</code> を使用するための正しい方法は、<code class="literal">SET autocommit = 0</code> (<code class="literal">START TRANSACTION</code> ではなく) に続けて <code class="literal">LOCK TABLES</code> を指定することによってトランザクションを開始し、そのトランザクションを明示的にコミットするまで <code class="literal">UNLOCK TABLES</code> を呼び出さないことです。たとえば、テーブル <code class="literal">t1</code> に書き込み、テーブル <code class="literal">t2</code> から読み取る必要がある場合は、次のように実行できます。
          </p><pre class="programlisting">
SET autocommit=0;
LOCK TABLES t1 WRITE, t2 READ, ...;
<em class="replaceable"><code>... do something with tables t1 and t2 here ...</code></em>
COMMIT;
UNLOCK TABLES;
</pre><p>
            <code class="literal">LOCK TABLES</code> を呼び出すと、<code class="literal">InnoDB</code> は内部的に独自のテーブルロックを取得し、MySQL は独自のテーブルロックを取得します。<code class="literal">InnoDB</code> は次のコミット時に内部のテーブルロックを解放しますが、MySQL でテーブルロックが解放されるようにするには、<code class="literal">UNLOCK TABLES</code> を呼び出す必要があります。<code class="literal">autocommit = 1</code> を指定すると、<code class="literal">LOCK TABLES</code> の呼び出しの直後に <code class="literal">InnoDB</code> によって内部のテーブルロックが解放され、デッドロックが非常に発生しやすくなる場合があるため、この指定は行わないようにしてください。<code class="literal">autocommit = 1</code> が指定された場合、古いアプリケーションが不必要なデッドロックを回避するのに役立つように、<code class="literal">InnoDB</code> は内部のテーブルロックをまったく取得しません。
          </p></li><li class="listitem"><p>
            <code class="literal">ROLLBACK</code> は、テーブルロックを解放しません。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="lock-tables-and-triggers"></a>13.3.5.2 LOCK TABLES とトリガー</h4></div></div></div><p>
        <code class="literal">LOCK TABLES</code> によって明示的にテーブルをロックした場合は、トリガーで使用されているテーブルもすべて暗黙的にロックされます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            これらのロックは、<code class="literal">LOCK TABLES</code> ステートメントによって明示的に取得されるロックと同時に取得されます。
          </p></li><li class="listitem"><p>
            トリガーで使用されているテーブルに対するロックは、そのテーブルが読み取りのみに使用されているかどうかによって異なります。読み取りのみに使用されている場合は、読み取りロックで十分です。そうでない場合は、書き込みロックが使用されます。
          </p></li><li class="listitem"><p>
            テーブルが <code class="literal">LOCK TABLES</code> によって読み取りに対して明示的にロックされているが、トリガー内で変更される可能性があるために書き込みに対してロックする必要がある場合は、読み取りロックではなく書き込みロックが取得されます。(つまり、トリガー内でのテーブルの表示のために必要な暗黙の書き込みロックによって、テーブルに対する明示的な読み取りロック要求が書き込みロック要求に変換されます。) 
          </p></li></ul></div><p>
        次のステートメントを使用して、2 つのテーブル <code class="literal">t1</code> と <code class="literal">t2</code> をロックするとします。
      </p><pre class="programlisting">
LOCK TABLES t1 WRITE, t2 READ;
</pre><p>
        <code class="literal">t1</code> または <code class="literal">t2</code> にトリガーが含まれている場合は、そのトリガー内で使用されているテーブルもロックされます。<code class="literal">t1</code> に、次のように定義されたトリガーが含まれているとします。
      </p><pre class="programlisting">
CREATE TRIGGER t1_a_ins AFTER INSERT ON t1 FOR EACH ROW
BEGIN
  UPDATE t4 SET count = count+1
      WHERE id = NEW.id AND EXISTS (SELECT a FROM t3);
  INSERT INTO t2 VALUES(1, 2);
END;
</pre><p>
        <code class="literal">LOCK TABLES</code> ステートメントの結果として、<code class="literal">t1</code> と <code class="literal">t2</code> は、このステートメントに現れるためにロックされます。また、<code class="literal">t3</code> と <code class="literal">t4</code> は、トリガー内で使用されているためにロックされます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">t1</code> は、<code class="literal">WRITE</code> ロック要求ごとに、書き込みに対してロックされます。
          </p></li><li class="listitem"><p>
            <code class="literal">t2</code> は、要求が <code class="literal">READ</code> ロックに対するものであったとしても、書き込みに対してロックされます。これは、トリガー内で <code class="literal">t2</code> に挿入されるために発生します。したがって、<code class="literal">READ</code> 要求は <code class="literal">WRITE</code> 要求に変換されます。
          </p></li><li class="listitem"><p>
            <code class="literal">t3</code> は、トリガー内から読み取られるだけであるため、読み取りに対してロックされます。
          </p></li><li class="listitem"><p>
            <code class="literal">t4</code> は、トリガー内で更新される可能性があるため、書き込みに対してロックされます。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="lock-tables-restrictions"></a>13.3.5.3 テーブルロックの制限と条件</h4></div></div></div><p>
        テーブルロックを待機しているセッションを終了するために、<code class="literal">KILL</code> を安全に使用できます。<a class="xref" href="sql-syntax.html#kill" title="13.7.6.4 KILL 構文">セクション13.7.6.4「KILL 構文」</a>を参照してください。
      </p><p>
        <code class="literal">INSERT DELAYED</code> で使用しているテーブルはロック<span class="emphasis"><em>しないでください</em></span>。挿入は、ロックを保持するセッションではなく、別のスレッドによって処理される必要があるため、この場合の <code class="literal">INSERT DELAYED</code> はエラーになります。
      </p><p>
        <code class="literal">LOCK TABLES</code> および <code class="literal">UNLOCK TABLES</code> は、ストアドプログラム内では使用できません。
      </p><p>
        <code class="literal">performance_schema</code> データベース内のテーブルは、<code class="literal">setup_<em class="replaceable"><code>xxx</code></em></code> テーブルを除き、<code class="literal">LOCK TABLES</code> ではロックできません。
      </p><p>
        <code class="literal">LOCK TABLES</code> ステートメントが有効になっている間、次のステートメントは禁止されます。<code class="literal">CREATE TABLE</code>、<code class="literal">CREATE TABLE ... LIKE</code>、<code class="literal">CREATE VIEW</code>、<code class="literal">DROP VIEW</code>、およびストアドファンクション、ストアドプロシージャー、イベントでの DDL ステートメント。
      </p><p>
        一部の操作では、<code class="literal">mysql</code> データベース内のシステムテーブルにアクセスする必要があります。たとえば、<code class="literal">HELP</code> ステートメントにはサーバー側のヘルプテーブルの内容が必要であり、また <code class="literal">CONVERT_TZ()</code> はタイムゾーンテーブルの読み取りが必要になる可能性があります。サーバーは、ユーザーが明示的にロックしなくても済むように、必要に応じてシステムテーブルを読み取りに対して暗黙的にロックします。次のテーブルは、今説明したように処理されます。
      </p><pre class="programlisting">
mysql.help_category
mysql.help_keyword
mysql.help_relation
mysql.help_topic
mysql.proc
mysql.time_zone
mysql.time_zone_leap_second
mysql.time_zone_name
mysql.time_zone_transition
mysql.time_zone_transition_type
</pre><p>
        これらのテーブルのいずれかに対する <code class="literal">WRITE</code> ロックを <code class="literal">LOCK TABLES</code> ステートメントで明示的に設定する場合は、そのテーブルがロックされる唯一のテーブルである必要があります。ほかのどのテーブルも、同じステートメントではロックできません。
      </p><p>
        1 つの <code class="literal">UPDATE</code> ステートメントはすべてアトミックであるため、通常、テーブルをロックする必要はありません。現在実行中の SQL ステートメントを、ほかのどのセッションも妨げることはできません。ただし、テーブルのロックによって利点が得られる可能性のある場合がいくつかあります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            一連の <code class="literal">MyISAM</code> テーブルに対して多くの操作を実行しようとしている場合は、使用しようとしているテーブルをロックする方がはるかに高速です。<code class="literal">MyISAM</code> テーブルをロックすると、MySQL はロックされたテーブルのキーキャッシュを <code class="literal">UNLOCK TABLES</code> が呼び出されるまでフラッシュしないため、そのテーブルに対する挿入、更新、または削除が高速化されます。通常、キーキャッシュは各 SQL ステートメントのあとでフラッシュされます。
          </p><p>
            テーブルロックのマイナス面は、<code class="literal">READ</code> によってロックされたテーブルをどのセッションも更新できず (ロックを保持しているセッションを含む)、ロックを保持しているセッションを除き、<code class="literal">WRITE</code> によってロックされたテーブルにどのセッションもアクセスできない点です。
          </p></li><li class="listitem"><p>
            非トランザクションストレージエンジンに対してテーブルを使用している場合、<code class="literal">SELECT</code> と <code class="literal">UPDATE</code> の間にテーブルがほかのセッションによって変更されないようにするには、<code class="literal">LOCK TABLES</code> を使用する必要があります。次に示す例では、安全に実行するために <code class="literal">LOCK TABLES</code> が必要です。
          </p><pre class="programlisting">
LOCK TABLES trans READ, customer WRITE;
SELECT SUM(value) FROM trans WHERE customer_id=<em class="replaceable"><code>some_id</code></em>;
UPDATE customer
  SET total_value=<em class="replaceable"><code>sum_from_previous_statement</code></em>
  WHERE customer_id=<em class="replaceable"><code>some_id</code></em>;
UNLOCK TABLES;
</pre><p>
            <code class="literal">LOCK TABLES</code> を使用しない場合は、<code class="literal">SELECT</code> ステートメントと <code class="literal">UPDATE</code> ステートメントの実行の間に、別のセッションによって <code class="literal">trans</code> テーブルに新しい行が挿入される可能性があります。
          </p></li></ul></div><p>
        多くの場合は、相対的な更新 (<code class="literal">UPDATE customer SET <em class="replaceable"><code>value</code></em>=<em class="replaceable"><code>value</code></em>+<em class="replaceable"><code>new_value</code></em></code>) または <code class="literal">LAST_INSERT_ID()</code> 関数を使用することによって <code class="literal">LOCK TABLES</code> の使用を回避できます。<a class="xref" href="introduction.html#ansi-diff-transactions" title="1.8.2.3 トランザクションおよびアトミック操作の違い">セクション1.8.2.3「トランザクションおよびアトミック操作の違い」</a>を参照してください。
      </p><p>
        場合によっては、ユーザーレベルのアドバイザリロック関数 <code class="literal">GET_LOCK()</code> および <code class="literal">RELEASE_LOCK()</code> を使用してテーブルのロックを回避することもできます。高速化のために、これらのロックはサーバーのハッシュテーブル内に保存され、<code class="literal">pthread_mutex_lock()</code> と <code class="literal">pthread_mutex_unlock()</code> で実装されます。<a class="xref" href="functions.html#miscellaneous-functions" title="12.18 その他の関数">セクション12.18「その他の関数」</a>を参照してください。
      </p><p>
        ロックポリシーの詳細は、<a class="xref" href="optimization.html#internal-locking" title="8.10.1 内部ロック方法">セクション8.10.1「内部ロック方法」</a>を参照してください。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="set-transaction"></a>13.3.6 SET TRANSACTION 構文</h3></div></div></div><a class="indexterm" name="idm139979082319760"></a><a class="indexterm" name="idm139979082318288"></a><a class="indexterm" name="idm139979082316880"></a><a class="indexterm" name="idm139979082315648"></a><pre class="programlisting">
SET [GLOBAL | SESSION] TRANSACTION
    <em class="replaceable"><code>transaction_characteristic</code></em> [, <em class="replaceable"><code>transaction_characteristic</code></em>] ...

<em class="replaceable"><code>transaction_characteristic</code></em>:
    ISOLATION LEVEL <em class="replaceable"><code>level</code></em>
  | READ WRITE
  | READ ONLY

<em class="replaceable"><code>level</code></em>:
     REPEATABLE READ
   | READ COMMITTED
   | READ UNCOMMITTED
   | SERIALIZABLE
</pre><p>
      このステートメントは、<a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a>の特性を指定します。これは、カンマで区切られた 1 つ以上の特性値のリストを受け取ります。これらの特性は、トランザクションの<a class="link" href="glossary.html#glos_isolation_level" title="分離レベル">分離レベル</a>またはアクセスモードを設定します。分離レベルは、<code class="literal">InnoDB</code> テーブルに対する操作に使用されます。アクセスモードは MySQL 5.6.5 の時点で指定することができ、トランザクションが読み取り/書き込みまたは読み取り専用のどちらのモードで動作するかを示します。
    </p><p>
      さらに、<code class="literal">SET TRANSACTION</code> には、ステートメントのスコープを示すオプションの <code class="literal">GLOBAL</code> または <code class="literal">SESSION</code> キーワードを含めることができます。
    </p><h4><a name="set-transaction-scope"></a>トランザクションの特性のスコープ</h4><p>
      トランザクションの特性はグローバルに、現在のセッションに対して、または次のトランザクションに対して設定できます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">GLOBAL</code> キーワードを指定すると、このステートメントは、以降のすべてのセッションに対してグローバルに適用されます。既存のセッションは影響を受けません。
        </p></li><li class="listitem"><p>
          <code class="literal">SESSION</code> キーワードを指定すると、このステートメントは、現在のセッション内で実行される以降のすべてのトランザクションに適用されます。
        </p></li><li class="listitem"><p>
          <code class="literal">SESSION</code> または <code class="literal">GLOBAL</code> キーワードのどちらも指定しない場合、このステートメントは、現在のセッション内で実行される次の (開始されていない) トランザクションに適用されます。
        </p></li></ul></div><p>
      トランザクションの特性をグローバルに変更するには、<code class="literal">SUPER</code> 権限が必要です。どのセッションも、そのセッションの特性 (トランザクションの途中であっても)、または次のトランザクションの特性を自由に変更できます。
    </p><p>
      アクティブなトランザクションが存在する間は、<code class="literal">GLOBAL</code> または <code class="literal">SESSION</code> を指定しない <code class="literal">SET TRANSACTION</code> は許可されません。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>START TRANSACTION;</code></strong>
Query OK, 0 rows affected (0.02 sec)

mysql&gt; <strong class="userinput"><code>SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;</code></strong>
ERROR 1568 (25001): Transaction characteristics can't be changed
while a transaction is in progress
</pre><p>
      サーバーの起動時にグローバルなデフォルトの分離レベルを設定するには、コマンド行またはオプションファイルで <span class="command"><strong>mysqld</strong></span> に対して <code class="option">--transaction-isolation=<em class="replaceable"><code>level</code></em></code> オプションを使用します。このオプションの <em class="replaceable"><code>level</code></em> の値では、スペースではなくダッシュが使用されるため、許可される値は <code class="literal">READ-UNCOMMITTED</code>、<code class="literal">READ-COMMITTED</code>、<code class="literal">REPEATABLE-READ</code>、または <code class="literal">SERIALIZABLE</code> です。たとえば、デフォルトの分離レベルを <code class="literal">REPEATABLE READ</code> に設定するには、オプションファイルの <code class="literal">[mysqld]</code> セクションで次の行を使用します。
    </p><pre class="programlisting">
[mysqld]
transaction-isolation = REPEATABLE-READ
</pre><p>
      グローバルなトランザクション分離レベルやセッションのトランザクション分離レベルは、<code class="literal">tx_isolation</code> システム変数を使用して、実行時にチェックまたは設定できます。
    </p><pre class="programlisting">
SELECT @@GLOBAL.tx_isolation, @@tx_isolation;
SET GLOBAL tx_isolation='REPEATABLE-READ';
SET SESSION tx_isolation='SERIALIZABLE';
</pre><p>
      同様に、サーバーの起動時または実行時にトランザクションアクセスモードを設定するには、<code class="option">--transaction-read-only</code> オプションまたは <code class="literal">tx_read_only</code> システム変数を使用します。デフォルトでは、これらは <code class="literal">OFF</code> (モードは読み取り/書き込み) ですが、<code class="literal">ON</code> に設定して読み取り専用のデフォルトモードにすることができます。
    </p><p>
      <code class="literal">tx_isolation</code> または <code class="literal">tx_read_only</code> のグローバルまたはセッション値を設定することは、<code class="literal">SET GLOBAL TRANSACTION</code> または <code class="literal">SET SESSION TRANSACTION</code> で分離レベルまたはアクセスモードを設定することと同等です。
    </p><h4><a name="set-transaction-isolation-level"></a>分離レベルの詳細および使用方法</h4><p>
      <code class="literal">InnoDB</code> は、ここで説明されている各トランザクション分離レベルを、異なる<a class="link" href="glossary.html#glos_locking" title="ロック">ロック</a>の方法を使用してサポートしています。<a class="link" href="glossary.html#glos_acid" title="ACID">ACID</a> 準拠が重要な要件である重要なデータに対する操作の場合は、デフォルトの <code class="literal">REPEATABLE READ</code> レベルを使用して高度な一貫性を適用できます。あるいは、正確な一貫性や繰り返し可能な結果がロックのためのオーバーヘッドの量の最少化ほど重要でない一括レポートなどの状況では、<code class="literal">READ COMMITTED</code> や場合によっては <code class="literal">READ UNCOMMITTED</code> を使用して一貫性のルールを緩和できます。<code class="literal">SERIALIZABLE</code> は <code class="literal">REPEATABLE READ</code> よりさらに厳密なルールを適用し、主に <a class="link" href="glossary.html#glos_xa" title="XA">XA</a> トランザクションのほか、並列性や<a class="link" href="glossary.html#glos_deadlock" title="デッドロック">デッドロック</a>に関する問題のトラブルシューティングなどの特殊な状況で使用されます。
    </p><p>
      これらの分離レベルが <code class="literal">InnoDB</code> トランザクションと連携する方法に関する完全な情報については、<a class="xref" href="innodb-storage-engine.html#innodb-transaction-model" title="14.2.2 InnoDB のトランザクションモデルおよびロック">セクション14.2.2「InnoDB のトランザクションモデルおよびロック」</a>を参照してください。特に、<code class="literal">InnoDB</code> のレコードレベルのロック、およびそれを使用してさまざまな種類のステートメントが実行される方法の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-record-level-locks" title="14.2.6 InnoDB のレコード、ギャップ、およびネクストキーロック">セクション14.2.6「InnoDB のレコード、ギャップ、およびネクストキーロック」</a>および<a class="xref" href="innodb-storage-engine.html#innodb-locks-set" title="14.2.8 InnoDB のさまざまな SQL ステートメントで設定されたロック">セクション14.2.8「InnoDB のさまざまな SQL ステートメントで設定されたロック」</a>を参照してください。
    </p><p>
      次のリストは、MySQL が各種のトランザクションレベルをどのようにサポートするかについて説明しています。このリストは、もっとも一般的に使用されるレベルから使用頻度の低い順に並べられています。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="isolevel_repeatable-read"></a>
          <a class="indexterm" name="idm139979082243952"></a> <a class="indexterm" name="idm139979082241840"></a> <code class="literal">REPEATABLE READ</code>
        </p><p>
          これが <code class="literal">InnoDB</code> のデフォルトの分離レベルです。<a class="link" href="glossary.html#glos_consistent_read" title="一貫性読み取り">一貫性読み取り</a>では、<code class="literal">READ COMMITTED</code> 分離レベルとの重要な違いがあります。同じトランザクション内の一貫性読み取りはすべて、最初の読み取りによって確立されたスナップショットを読み取ります。この規則は、同じトランザクション内で複数のプレーン (非ロック) <code class="literal">SELECT</code> ステートメントを発行した場合、これらの <code class="literal">SELECT</code> ステートメントは互いに関しても一貫性があることを示します。<a class="xref" href="innodb-storage-engine.html#innodb-consistent-read" title="14.2.4 一貫性非ロック読み取り">セクション14.2.4「一貫性非ロック読み取り」</a>を参照してください。
        </p><p>
          <a class="link" href="glossary.html#glos_locking_read" title="ロック読み取り">ロック読み取り</a> (<code class="literal">FOR UPDATE</code> または <code class="literal">LOCK IN SHARE MODE</code> を含む <code class="literal">SELECT</code>)、<code class="literal">UPDATE</code>、および <code class="literal">DELETE</code> ステートメントの場合、ロックは、そのステートメントが一意のインデックスを一意の検索条件または範囲タイプの検索条件のどちらで使用しているかによって異なります。一意の検索条件を使用した一意のインデックスの場合、<code class="literal">InnoDB</code> は見つかったインデックスレコードのみをロックし、その前にある<a class="link" href="glossary.html#glos_gap" title="ギャップ">ギャップ</a>はロックしません。その他の検索条件の場合、<code class="literal">InnoDB</code> は、<a class="link" href="glossary.html#glos_gap_lock" title="ギャップロック">ギャップロック</a>または<a class="link" href="glossary.html#glos_next_key_lock" title="ネクストキーロック">ネクストキーロック</a>を使用して、範囲に含まれるギャップへのほかのセッションによる挿入をブロックすることによって、スキャンされたインデックス範囲をロックします。
        </p></li><li class="listitem"><p><a name="isolevel_read-committed"></a>
          <a class="indexterm" name="idm139979082220112"></a> <a class="indexterm" name="idm139979082217952"></a> <code class="literal">READ COMMITTED</code>
        </p><p>
          一貫性 (非ロック) 読み取りに関して、いくぶん Oracle に似た分離レベルです。各<a class="link" href="glossary.html#glos_consistent_read" title="一貫性読み取り">一貫性読み取り</a>が (同じトランザクション内であっても)、独自の新しい<a class="link" href="glossary.html#glos_snapshot" title="スナップショット">スナップショット</a>を設定して読み取ります。<a class="xref" href="innodb-storage-engine.html#innodb-consistent-read" title="14.2.4 一貫性非ロック読み取り">セクション14.2.4「一貫性非ロック読み取り」</a>を参照してください。
        </p><p>
          <a class="link" href="glossary.html#glos_locking_read" title="ロック読み取り">ロック読み取り</a> (<code class="literal">FOR UPDATE</code> または <code class="literal">LOCK IN SHARE MODE</code> を含む <code class="literal">SELECT</code>)、<code class="literal">UPDATE</code> ステートメント、および <code class="literal">DELETE</code> ステートメントの場合、<code class="literal">InnoDB</code> はインデックスレコードのみをロックし、その前にある<a class="link" href="glossary.html#glos_gap" title="ギャップ">ギャップ</a>はロックしないため、ロックされたレコードの横への新しいレコードの自由な挿入が許可されます。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            MySQL 5.6 では、<code class="literal">READ COMMITTED</code> 分離レベルが使用されている場合、または非推奨の <code class="literal">innodb_locks_unsafe_for_binlog</code> システム変数が有効になっている場合、外部キー制約チェックと重複キーチェックを除き、<code class="literal">InnoDB</code> のギャップロックは存在しません。また、一致しない行に対するレコードロックも、MySQL が <code class="literal">WHERE</code> 条件を評価したあとに解放されます。
          </p><p>
            <code class="literal">READ COMMITTED</code> を使用するか、または <code class="literal">innodb_locks_unsafe_for_binlog</code> を有効にする場合は、行ベースのバイナリロギングを使用する<span class="emphasis"><em>必要があります</em></span>。
          </p></div></li><li class="listitem"><p><a name="isolevel_read-uncommitted"></a>
          <a class="indexterm" name="idm139979082195744"></a> <a class="indexterm" name="idm139979082193600"></a> <code class="literal">READ UNCOMMITTED</code>
        </p><p>
          <code class="literal">SELECT</code> ステートメントは非ロックの方法で実行されますが、以前のバージョンの行が使用される可能性もあります。そのため、この分離レベルを使用すると、このような読み取りには一貫性がありません。これは、<a class="link" href="glossary.html#glos_dirty_read" title="ダーティー読み取り">ダーティー読み取り</a>とも呼ばれます。そうでなければ、この分離レベルは <code class="literal">READ COMMITTED</code> のように機能します。
        </p></li><li class="listitem"><p><a name="isolevel_serializable"></a>
          <a class="indexterm" name="idm139979082185776"></a> <a class="indexterm" name="idm139979082183616"></a> <code class="literal">SERIALIZABLE</code>
        </p><p>
          このレベルは <code class="literal">REPEATABLE READ</code> に似ていますが、自動コミットが無効になっている場合、<code class="literal">InnoDB</code> はすべてのプレーン <code class="literal">SELECT</code> ステートメントを <code class="literal">SELECT ... LOCK IN SHARE MODE</code> に暗黙的に変換します。自動コミットが有効になっている場合、<code class="literal">SELECT</code> は独自のトランザクションです。したがって、読み取り専用であることがわかっているため、一貫性のある (非ロック) 読み取りとして実行された場合は直列化することができ、ほかのトランザクションのためのブロックは必要ありません。(選択された行がほかのトランザクションによって変更された場合、プレーン <code class="literal">SELECT</code> で強制的にブロックするには、自動コミットを無効にします。) 
        </p></li></ul></div><h4><a name="set-transaction-access-mode"></a>トランザクションアクセスモード</h4><p>
      MySQL 5.6.5 の時点では、トランザクションアクセスモードは <code class="literal">SET TRANSACTION</code> で指定できます。デフォルトでは、トランザクションは読み取り/書き込みモードで実行され、そのトランザクションで使用されるテーブルに対して読み取りと書き込みの両方が許可されます。このモードは、<code class="literal">READ WRITE</code> のアクセスモードを使用して明示的に指定できます。
    </p><p>
      トランザクションアクセスモードが <code class="literal">READ ONLY</code> に設定されている場合は、テーブルへの変更が禁止されます。これにより、書き込みが許可されていない場合に可能になる、ストレージエンジンのパフォーマンス向上が実現される可能性があります。
    </p><p>
      同じステートメント内で <code class="literal">READ WRITE</code> と <code class="literal">READ ONLY</code> の両方を指定することは許可されません。
    </p><p>
      読み取り専用モードでは、DML ステートメントを使用して <code class="literal">TEMPORARY</code> キーワードで作成されたテーブルは引き続き変更できます。永続的なテーブルと同様に、DDL ステートメントによって行われる変更は許可されません。
    </p><p>
      <code class="literal">READ WRITE</code> および <code class="literal">READ ONLY</code> アクセスモードは、<code class="literal">START TRANSACTION</code> ステートメントを使用して個々のトランザクションに対しても指定できます。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="xa"></a>13.3.7 XA トランザクション</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-syntax.html#xa-statements">13.3.7.1 XA トランザクションの SQL 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#xa-states">13.3.7.2 XA トランザクションの状態</a></span></dt></dl></div><a class="indexterm" name="idm139979082158064"></a><p>
      <a class="link" href="glossary.html#glos_xa" title="XA">XA</a> トランザクションのサポートは、<code class="literal">InnoDB</code> ストレージエンジンに対して使用できます。MySQL XA 実装は、X/Open CAE ドキュメント<em class="citetitle">分散トランザクション処理: XA 仕様</em>に基づいています。このドキュメントは The Open Group によって発行されており、<a class="ulink" href="http://www.opengroup.org/public/pubs/catalog/c193.htm" target="_top">http://www.opengroup.org/public/pubs/catalog/c193.htm</a> で入手できます。現在の XA 実装の制限については、<a class="xref" href="restrictions.html#xa-restrictions" title="D.6 XA トランザクションの制約">セクションD.6「XA トランザクションの制約」</a>で説明されています。
    </p><p>
      クライアント側には、特殊な要件は何もありません。MySQL サーバーへの XA インタフェースは、<code class="literal">XA</code> キーワードで始まる SQL ステートメントで構成されています。MySQL クライアントプログラムは、SQL ステートメントを送信したり、XA ステートメントインタフェースのセマンティクスを理解したりできる必要があります。これらが、最新のクライアントライブラリに対してリンクされている必要はありません。古いクライアントライブラリも機能します。
    </p><p>
      現在、MySQL Connector の中で、MySQL Connector/J 5.0.0 以降は、XA SQL ステートメントインタフェースを自動的に処理するクラスインタフェースを使用して XA を直接サポートします。
    </p><p>
      XA は分散トランザクション、つまり、複数の個別のトランザクションリソースがグローバルトランザクションに参加することを許可する機能をサポートしています。トランザクションリソースは多くの場合 RDBMS ですが、ほかの種類のリソースであってもかまいません。
    </p><p>
      グローバルトランザクションには、それ自体でトランザクションである複数のアクションが含まれますが、そのすべてがグループとして正常に完了するか、またはすべてがグループとしてロールバックされるかのどちらかである必要があります。基本的に、これは ACID プロパティーを<span class="quote">「<span class="quote">1 レベル上に</span>」</span>拡張することにより、複数の ACID トランザクションを、同じく ACID プロパティーを持つグローバル操作のコンポーネントとして連携して実行できるようにします。(ただし、分散トランザクションに対しては、<code class="literal">SERIALIZABLE</code> 分離レベルを使用して ACID プロパティーを実現する必要があります。非分散トランザクションに対しては <code class="literal">REPEATABLE READ</code> を使用すれば十分ですが、分散トランザクションに対しては不十分です。) 
    </p><p>
      分散トランザクションのいくつかの例:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          あるアプリケーションが、メッセージングサービスを RDBMS と組み合わせる統合ツールとして機能する場合があります。このアプリケーションは、同じくトランザクションデータベースを含む、メッセージの送信、取得、および処理を行うトランザクションがすべて、確実にグローバルトランザクション内で実行されるようにします。これは、<span class="quote">「<span class="quote">トランザクション電子メール</span>」</span>と考えることができます。
        </p></li><li class="listitem"><p>
          アプリケーションが、MySQL サーバーや Oracle サーバー (または複数の MySQL サーバー) などの異なるデータベースサーバーに関連するアクションを実行します。ここで、複数のサーバーに関連するアクションは、各サーバーに対してローカルな個別のトランザクションとしてではなく、グローバルトランザクションの一部として実行する必要があります。
        </p></li><li class="listitem"><p>
          銀行が口座情報を RDBMS 内に保持し、現金自動預け払い機 (ATM) を通して現金を出し入れしています。ATM のアクションが口座に正しく反映されるように保証することが必要ですが、これは RDBMS だけでは実行できません。グローバルなトランザクションマネージャーが ATM とデータベースリソースを統合して、財務トランザクションの全体的な一貫性を確保します。
        </p></li></ul></div><p>
      グローバルトランザクションを使用するアプリケーションには、1 つまたは複数のリソースマネージャーと 1 つのトランザクションマネージャーが含まれています。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          リソースマネージャー (RM) は、トランザクションリソースへのアクセスを提供します。データベースサーバーは、1 つの種類のリソースマネージャーです。これは、RM によって管理されているトランザクションをコミットまたはロールバックできる必要があります。
        </p></li><li class="listitem"><p>
          トランザクションマネージャー (TM) は、グローバルトランザクションの一部であるトランザクションを調整します。これは、これらの各トランザクションを処理する RM と通信します。グローバルトランザクション内の個々のトランザクションは、グローバルトランザクションの<span class="quote">「<span class="quote">ブランチ</span>」</span>です。グローバルトランザクションとそのブランチは、あとで説明されている名付けスキームによって識別されます。
        </p></li></ul></div><p>
      XA MySQL の MySQL 実装では、MySQL サーバーは、グローバルトランザクション内の XA トランザクションを処理するリソースマネージャーとして機能できます。MySQL サーバーに接続するクライアントプログラムは、トランザクションマネージャーとして機能します。
    </p><p>
      グローバルトランザクションを実行するには、どのコンポーネントが関連しているかを知り、各コンポーネントをそのコミットまたはロールバックが可能なポイントに持っていくことが必要です。各コンポーネントが自身の成功する能力に関してレポートする内容に応じて、それらのすべてが、アトミックグループとしてコミットまたはロールバックする必要があります。つまり、すべてのコンポーネントがコミットするか、またはすべてのコンポーネントがロールバックする必要があります。グローバルトランザクションを管理するには、いずれかのコンポーネントまたは接続しているネットワークが失敗する可能性があることを考慮に入れる必要があります。
    </p><p>
      グローバルトランザクションを実行するためのプロセスでは、2 フェーズコミット (2PC) が使用されます。これは、グローバルトランザクションのブランチによって実行されるアクションが実行されたあとに行われます。
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          最初のフェーズでは、すべてのブランチが準備されます。つまり、これらは TM からコミットの準備を行うよう指示されます。これは通常、ブランチを管理する各 RM が、そのブランチのアクションを安定したストレージ内に記録することを示します。これらのブランチはこれを実行できるかどうかを示し、これらの結果が 2 番目のフェーズに使用されます。
        </p></li><li class="listitem"><p>
          2 番目のフェーズでは、TM が RM にコミットまたはロールバックのどちらを行うかを指示します。すべてのブランチが、準備できたときにコミットできることを示した場合は、すべてのブランチがコミットするよう指示されます。いずれかのブランチが、準備できたときにコミットできないことを示した場合は、すべてのブランチがロールバックするよう指示されます。
        </p></li></ol></div><p>
      場合によっては、グローバルトランザクションで 1 フェーズコミット (1PC) が使用されることがあります。たとえば、グローバルトランザクションが 1 つのトランザクションリソース (つまり、1 つのブランチ) だけで構成されていることがトランザクションマネージャーによって検出された場合は、そのリソースに準備とコミットを一度に行うよう指示できます。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="xa-statements"></a>13.3.7.1 XA トランザクションの SQL 構文</h4></div></div></div><a class="indexterm" name="idm139979082123056"></a><a class="indexterm" name="idm139979082121744"></a><a class="indexterm" name="idm139979082119552"></a><a class="indexterm" name="idm139979082118320"></a><a class="indexterm" name="idm139979082116128"></a><a class="indexterm" name="idm139979082114896"></a><a class="indexterm" name="idm139979082112704"></a><a class="indexterm" name="idm139979082111472"></a><a class="indexterm" name="idm139979082109280"></a><a class="indexterm" name="idm139979082108048"></a><a class="indexterm" name="idm139979082105856"></a><a class="indexterm" name="idm139979082104624"></a><a class="indexterm" name="idm139979082102432"></a><a class="indexterm" name="idm139979082100320"></a><p>
        MySQL で XA トランザクションを実行するには、次のステートメントを使用します。
      </p><pre class="programlisting">
XA {START|BEGIN} <em class="replaceable"><code>xid</code></em> [JOIN|RESUME]

XA END <em class="replaceable"><code>xid</code></em> [SUSPEND [FOR MIGRATE]]

XA PREPARE <em class="replaceable"><code>xid</code></em>

XA COMMIT <em class="replaceable"><code>xid</code></em> [ONE PHASE]

XA ROLLBACK <em class="replaceable"><code>xid</code></em>

XA RECOVER
</pre><p>
        <code class="literal">XA START</code> では、<code class="literal">JOIN</code> および <code class="literal">RESUME</code> 句はサポートされていません。
      </p><p>
        <code class="literal">XA END</code> では、<code class="literal">SUSPEND [FOR MIGRATE]</code> 句はサポートされていません。
      </p><p>
        各 XA ステートメントは <code class="literal">XA</code> キーワードで始まり、そのほとんどに <em class="replaceable"><code>xid</code></em> 値が必要です。<em class="replaceable"><code>xid</code></em> は XA トランザクション識別子です。これは、このステートメントがどのトランザクションに適用されるかを示します。<em class="replaceable"><code>xid</code></em> 値はクライアントによって指定されるか、または MySQL サーバーによって生成されます。<em class="replaceable"><code>xid</code></em> 値には、1 つから 3 つの部分が含まれています。
      </p><pre class="programlisting">
<em class="replaceable"><code>xid</code></em>: <em class="replaceable"><code>gtrid</code></em> [, <em class="replaceable"><code>bqual</code></em> [, <em class="replaceable"><code>formatID</code></em> ]]
</pre><p>
        <em class="replaceable"><code>gtrid</code></em> はグローバルトランザクション識別子であり、<em class="replaceable"><code>bqual</code></em> はブランチ修飾子であり、<em class="replaceable"><code>formatID</code></em> は、<em class="replaceable"><code>gtrid</code></em> および <em class="replaceable"><code>bqual</code></em> 値で使用される形式を識別する数値です。構文で示されているように、<em class="replaceable"><code>bqual</code></em> と <em class="replaceable"><code>formatID</code></em> はオプションです。<em class="replaceable"><code>bqual</code></em> が指定されていない場合、そのデフォルト値は <code class="literal">''</code> です。<em class="replaceable"><code>formatID</code></em> が指定されていない場合、そのデフォルト値は 1 です。
      </p><p>
        <em class="replaceable"><code>gtrid</code></em> と <em class="replaceable"><code>bqual</code></em> はそれぞれ、最大 64 バイト長 (64 文字ではありません) の文字列リテラルである必要があります。<em class="replaceable"><code>gtrid</code></em> と <em class="replaceable"><code>bqual</code></em> は、いくつかの方法で指定できます。引用符で囲まれた文字列 (<code class="literal">'ab'</code>)、16 進文字列 (<code class="literal">0x6162</code>、<code class="literal">X'ab'</code>)、またはビット値 (<code class="literal">b'<em class="replaceable"><code>nnnn</code></em>'</code>) を使用できます。
      </p><p>
        <em class="replaceable"><code>formatID</code></em> は符号なし整数です。
      </p><p>
        <em class="replaceable"><code>gtrid</code></em> および <em class="replaceable"><code>bqual</code></em> 値は、MySQL サーバーのベースとなる XA サポートルーチンによってバイト単位で解釈されます。ただし、XA ステートメントを含む SQL ステートメントが解析されている間、サーバーは何からの特定の文字セットで動作します。安全のために、<em class="replaceable"><code>gtrid</code></em> と <em class="replaceable"><code>bqual</code></em> は 16 進文字列として記述してください。
      </p><p>
        <em class="replaceable"><code>xid</code></em> 値は通常、トランザクションマネージャーによって生成されます。ある TM によって生成される値は、ほかの TM によって生成される値とは異なっている必要があります。特定の TM は、<code class="literal">XA RECOVER</code> ステートメントによって返された値のリスト内の自身の <em class="replaceable"><code>xid</code></em> 値を認識できる必要があります。
      </p><p>
        <code class="literal">XA START <em class="replaceable"><code>xid</code></em></code> は、指定された <em class="replaceable"><code>xid</code></em> 値を使用して XA トランザクションを開始します。各 XA トランザクションが一意の <em class="replaceable"><code>xid</code></em> 値を持っている必要があるため、その値が現在、別の XA トランザクションによって使用されていてはいけません。一意性は、<em class="replaceable"><code>gtrid</code></em> および <em class="replaceable"><code>bqual</code></em> 値を使用して評価されます。XA トランザクションに対する以降のすべての XA ステートメントを、<code class="literal">XA START</code> ステートメントで指定されたものと同じ <em class="replaceable"><code>xid</code></em> 値を使用して指定する必要があります。これらのステートメントのいずれかを使用しているが、既存の XA トランザクションに対応していない <em class="replaceable"><code>xid</code></em> 値を指定した場合は、エラーが発生します。
      </p><p>
        1 つ以上の XA トランザクションを同じグローバルトランザクションの一部にすることができます。特定のグローバルトランザクション内のすべての XA トランザクションが <em class="replaceable"><code>xid</code></em> 値内の同じ <em class="replaceable"><code>gtrid</code></em> 値を使用する必要があります。このため、特定の XA トランザクションがどのグローバルトランザクションの一部であるかについてのあいまいさがないように、<em class="replaceable"><code>gtrid</code></em> 値はグローバルに一意である必要があります。<em class="replaceable"><code>xid</code></em> 値の <em class="replaceable"><code>bqual</code></em> 部分は、グローバルトランザクション内の XA トランザクションごとに異なっている必要があります。(<em class="replaceable"><code>bqual</code></em> 値が異なっているという要件は、現在の MySQL XA 実装の制限です。これは XA 仕様の一部ではありません。) 
      </p><p>
        <code class="literal">XA RECOVER</code> ステートメントは、<code class="literal">PREPARED</code> 状態にある MySQL サーバー上の XA トランザクションに関する情報を返します。(<a class="xref" href="sql-syntax.html#xa-states" title="13.3.7.2 XA トランザクションの状態">セクション13.3.7.2「XA トランザクションの状態」</a>を参照してください。) この出力には、どのクライアントによって開始されたかには関係なく、サーバー上のこのような XA トランザクションごとの行が含まれています。
      </p><p>
        <code class="literal">XA RECOVER</code> の出力行は次のようになります (<code class="literal">'abc'</code>、<code class="literal">'def'</code>、<code class="literal">7</code> の各部分から成る <em class="replaceable"><code>xid</code></em> 値の例の場合)。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>XA RECOVER;</code></strong>
+----------+--------------+--------------+--------+
| formatID | gtrid_length | bqual_length | data   |
+----------+--------------+--------------+--------+
|        7 |            3 |            3 | abcdef |
+----------+--------------+--------------+--------+
</pre><p>
        出力カラムには次の意味があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">formatID</code> は、トランザクション <em class="replaceable"><code>xid</code></em> の <em class="replaceable"><code>formatID</code></em> 部分です。
          </p></li><li class="listitem"><p>
            <code class="literal">gtrid_length</code> は、<em class="replaceable"><code>xid</code></em> の <em class="replaceable"><code>gtrid</code></em> 部分の長さ (バイト単位) です。
          </p></li><li class="listitem"><p>
            <code class="literal">bqual_length</code> は、<em class="replaceable"><code>xid</code></em> の <em class="replaceable"><code>bqual</code></em> 部分の長さ (バイト単位) です。
          </p></li><li class="listitem"><p>
            <code class="literal">data</code> は、<em class="replaceable"><code>xid</code></em> の <em class="replaceable"><code>gtrid</code></em> および <em class="replaceable"><code>bqual</code></em> 部分の連結です。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="xa-states"></a>13.3.7.2 XA トランザクションの状態</h4></div></div></div><p>
        XA トランザクションは、次の各状態を経由して処理されます。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            <code class="literal">XA START</code> を使用して、XA トランザクションを開始し、それを <code class="literal">ACTIVE</code> 状態にします。
          </p></li><li class="listitem"><p>
            <code class="literal">ACTIVE</code> XA トランザクションに対しては、トランザクションを構成する SQL ステートメントを発行したあと、<code class="literal">XA END</code> ステートメントを発行します。<code class="literal">XA END</code> は、トランザクションを <code class="literal">IDLE</code> 状態にします。
          </p></li><li class="listitem"><p>
            <code class="literal">IDLE</code> XA トランザクションに対しては、<code class="literal">XA PREPARE</code> ステートメントまたは <code class="literal">XA COMMIT ... ONE PHASE</code> ステートメントのどちらかを発行できます。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <code class="literal">XA PREPARE</code> は、トランザクションを <code class="literal">PREPARED</code> 状態にします。この時点での <code class="literal">XA RECOVER</code> ステートメントは、<code class="literal">XA RECOVER</code> が <code class="literal">PREPARED</code> 状態にあるすべての XA トランザクションをリストするため、その出力にトランザクションの <em class="replaceable"><code>xid</code></em> 値が含まれます。
              </p></li><li class="listitem"><p>
                <code class="literal">XA COMMIT ... ONE PHASE</code> は、トランザクションの準備とコミットを行います。トランザクションが終了するため、<em class="replaceable"><code>xid</code></em> 値は <code class="literal">XA RECOVER</code> によってリストされません。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">PREPARED</code> XA トランザクションに対しては、<code class="literal">XA COMMIT</code> ステートメントを発行してトランザクションをコミットおよび終了するか、または <code class="literal">XA ROLLBACK</code> を発行してトランザクションをロールバックおよび終了することができます。
          </p></li></ol></div><p>
        グローバルトランザクションの一部としてテーブルに行を挿入する単純な XA トランザクションを次に示します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>XA START 'xatest';</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO mytable (i) VALUES(10);</code></strong>
Query OK, 1 row affected (0.04 sec)

mysql&gt; <strong class="userinput"><code>XA END 'xatest';</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>XA PREPARE 'xatest';</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>XA COMMIT 'xatest';</code></strong>
Query OK, 0 rows affected (0.00 sec)
</pre><p>
        特定のクライアント接続のコンテキスト内では、XA トランザクションとローカル (非 XA) トランザクションは相互に排他的です。たとえば、XA トランザクションを開始するために <code class="literal">XA START</code> が発行された場合は、その XA トランザクションがコミットまたはロールバックされるまでローカルトランザクションを開始できません。逆に、<code class="literal">START TRANSACTION</code> を使用してローカルトランザクションが開始された場合は、そのトランザクションがコミットまたはロールバックされるまで XA ステートメントを使用できません。
      </p><p>
        XA トランザクションが <code class="literal">ACTIVE</code> 状態にある場合は、暗黙的なコミットを発生させるどのステートメントも発行できません。その XA トランザクションをロールバックできないため、それを行うことは XA 規約に違反します。このようなステートメントを実行しようとすると、次のエラーが表示されます。
      </p><pre class="programlisting">
ERROR 1399 (XAE07): XAER_RMFAIL: The command cannot be executed
when global transaction is in the ACTIVE state
</pre><p>
        前の注意事項が適用されるステートメントは、<a class="xref" href="sql-syntax.html#implicit-commit" title="13.3.3 暗黙的なコミットを発生させるステートメント">セクション13.3.3「暗黙的なコミットを発生させるステートメント」</a>に示されています。
      </p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sql-syntax-replication"></a>13.4 レプリケーションステートメント</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-syntax.html#replication-master-sql">13.4.1 マスターサーバーを制御するための SQL ステートメント</a></span></dt><dt><span class="section"><a href="sql-syntax.html#replication-slave-sql">13.4.2 スレーブサーバーを制御するための SQL ステートメント</a></span></dt></dl></div><p>
    レプリケーションは、このセクションで説明されているステートメントを使用した SQL インタフェースを通して制御できます。ステートメントの 1 つのグループがマスターサーバーを制御し、もう 1 つのグループがスレーブサーバーを制御します。
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-master-sql"></a>13.4.1 マスターサーバーを制御するための SQL ステートメント</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-syntax.html#purge-binary-logs">13.4.1.1 PURGE BINARY LOGS 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#reset-master">13.4.1.2 RESET MASTER 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#set-sql-log-bin">13.4.1.3 SET sql_log_bin 構文</a></span></dt></dl></div><a class="indexterm" name="idm139979081981040"></a><a class="indexterm" name="idm139979081978848"></a><a class="indexterm" name="idm139979081976784"></a><p>
      このセクションでは、マスターレプリケーションサーバーを管理するためのステートメントについて説明します。<a class="xref" href="sql-syntax.html#replication-slave-sql" title="13.4.2 スレーブサーバーを制御するための SQL ステートメント">セクション13.4.2「スレーブサーバーを制御するための SQL ステートメント」</a>では、スレーブサーバーを管理するためのステートメントについて説明しています。
    </p><p>
      ここで説明されているステートメントに加えて、レプリケーションのマスターサーバーでは次の <code class="literal">SHOW</code> ステートメントが使用されます。これらのステートメントについては、<a class="xref" href="sql-syntax.html#show" title="13.7.5 SHOW 構文">セクション13.7.5「SHOW 構文」</a>を参照してください。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">SHOW BINARY LOGS</code>
        </p></li><li class="listitem"><p>
          <code class="literal">SHOW BINLOG EVENTS</code>
        </p></li><li class="listitem"><p>
          <code class="literal">SHOW MASTER STATUS</code>
        </p></li><li class="listitem"><p>
          <code class="literal">SHOW SLAVE HOSTS</code>
        </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="purge-binary-logs"></a>13.4.1.1 PURGE BINARY LOGS 構文</h4></div></div></div><a class="indexterm" name="idm139979081962176"></a><a class="indexterm" name="idm139979081960864"></a><pre class="programlisting">
PURGE { BINARY | MASTER } LOGS
    { TO '<em class="replaceable"><code>log_name</code></em>' | BEFORE <em class="replaceable"><code>datetime_expr</code></em> }
</pre><p>
        バイナリログは、MySQL サーバーによって行われたデータ変更に関する情報を含む一連のファイルです。このログは一連のバイナリログファイルのほか、インデックスファイルで構成されています (<a class="xref" href="server-administration.html#binary-log" title="5.2.4 バイナリログ">セクション5.2.4「バイナリログ」</a>を参照してください)。
      </p><p>
        <code class="literal">PURGE BINARY LOGS</code> ステートメントは、指定されたログファイル名または日付の前にあるログインデックスファイルにリストされているすべてのバイナリログファイルを削除します。<code class="literal">BINARY</code> と <code class="literal">MASTER</code> はシノニムです。削除されたログファイルはインデックスファイル内に記録されているリストからも削除されるため、特定のログファイルがそのリスト内の先頭になります。
      </p><p>
        このステートメントは、サーバーがバイナリロギングを有効にする <code class="option">--log-bin</code> オプションで起動されていない場合は何の効果もありません。
      </p><p>
        例:
      </p><pre class="programlisting">
PURGE BINARY LOGS TO 'mysql-bin.010';
PURGE BINARY LOGS BEFORE '2008-04-02 22:46:26';
</pre><p>
        <code class="literal">BEFORE</code> バリアントの <em class="replaceable"><code>datetime_expr</code></em> 引数は、<code class="literal">DATETIME</code> 値 (<code class="literal">'YYYY-MM-DD hh:mm:ss'</code> 形式の値) に評価されます。
      </p><p>
        このステートメントは、スレーブがレプリケートしている間も安全に実行できます。それらを停止する必要はありません。削除しようとしているログファイルのいずれかを現在読み取っているアクティブなスレーブが存在する場合、このステートメントは何もしません。MySQL 5.6.12 以降では、このような場合はエラーで失敗します。(Bug #13727933) ただし、スレーブが接続されていないときに、そのスレーブがまだ読み取っていないログファイルのいずれかを偶然にパージした場合、そのスレーブは再接続したあとにレプリケートできなくなります。
      </p><p>
        バイナリログファイルを安全にパージするには、次の手順に従います。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            各スレーブサーバー上で、<code class="literal">SHOW SLAVE STATUS</code> を使用して、そのスレーブサーバーがどのログファイルを読み取っているかをチェックします。
          </p></li><li class="listitem"><p>
            <code class="literal">SHOW BINARY LOGS</code> を使用して、マスターサーバー上のバイナリログファイルのリストを取得します。
          </p></li><li class="listitem"><p>
            すべてのスレーブ間でもっとも早いログファイルを特定します。これがターゲットファイルです。すべてのスレーブが最新である場合は、そのリスト上の最後のログファイルになります。
          </p></li><li class="listitem"><p>
            削除しようとしているすべてのログファイルのバックアップを作成します。(この手順はオプションですが、常に実行することをお勧めします。) 
          </p></li><li class="listitem"><p>
            ターゲットファイルの直前までのすべてのログファイルをパージします。
          </p></li></ol></div><p>
        また、特定の日数が経過したらバイナリログファイルが自動的に期限切れになるように、<code class="literal">expire_logs_days</code> システム変数を設定することもできます (<a class="xref" href="server-administration.html#server-system-variables" title="5.1.4 サーバーシステム変数">セクション5.1.4「サーバーシステム変数」</a>を参照してください)。レプリケーションを使用している場合、スレーブがマスターよりも遅延できる最大日数を下回らないような変数を設定するようにしてください。
      </p><p>
        <code class="literal">PURGE BINARY LOGS TO</code> と <code class="literal">PURGE BINARY LOGS BEFORE</code> はどちらも、<code class="filename">.index</code> ファイルにリストされているバイナリログファイルが、ほかの何らかの手段 (Linux 上での <span class="command"><strong>rm</strong></span> の使用など) によってシステムから削除されている場合はエラーで失敗します。(Bug #18199、Bug #18453) このようなエラーに対処するには、<code class="filename">.index</code> ファイル (これは単純なテキストファイルです) を手動で編集して、実際に存在するバイナリログファイルのみがリストされていることを確認したあと、失敗した <code class="literal">PURGE BINARY LOGS</code> ステートメントを再度実行します。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="reset-master"></a>13.4.1.2 RESET MASTER 構文</h4></div></div></div><a class="indexterm" name="idm139979081921664"></a><pre class="programlisting">
RESET MASTER
</pre><p>
        インデックスファイルにリストされているすべてのバイナリログファイルを削除し、バイナリログインデックスファイルを空にリセットして、新しいバイナリログファイルを作成します。
      </p><p>
        MySQL 5.6.5 以降では、<code class="literal">RESET MASTER</code> は <code class="literal">gtid_purged</code> システム変数 (MySQL 5.6.8 以前では <code class="literal">gtid_lost</code> と呼ばれます) の値や、<code class="literal">gtid_executed</code> (MySQL 5.6.9 より前では <code class="literal">gtid_done</code>) システム変数のグローバル値 (ただし、そのセッション値を除きます) もクリアします。つまり、このステートメントを実行すると、これらの各値が空の文字列 (<code class="literal">''</code>) に設定されます。
      </p><p>
        このステートメントは、マスターがはじめて起動された場合にのみ使用されるように考慮されています。
      </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          <code class="literal">RESET MASTER</code> の効果は、<code class="literal">PURGE BINARY LOGS</code> の効果とは次の 2 つの重要な点で異なります。
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              <code class="literal">RESET MASTER</code> が、インデックスファイルにリストされている<span class="emphasis"><em>すべての</em></span>バイナリログファイルを削除し、<code class="literal">.000001</code> の数字のサフィクスを持つ 1 つの空のバイナリログファイルだけを残すのに対して、<code class="literal">PURGE BINARY LOGS</code> では番号はリセットされません。
            </p></li><li class="listitem"><p>
              <code class="literal">RESET MASTER</code> は、いずれかのレプリケーションスレーブの実行中に使用されるようには考慮されて<span class="emphasis"><em>いません</em></span>。スレーブの実行中に使用された場合の <code class="literal">RESET MASTER</code> の動作は不定です (そのため、サポートされていません)。これに対して、<code class="literal">PURGE BINARY LOGS</code> はレプリケーションスレーブの実行中にも安全に使用できます。
            </p></li></ol></div><p>
          <a class="xref" href="sql-syntax.html#purge-binary-logs" title="13.4.1.1 PURGE BINARY LOGS 構文">セクション13.4.1.1「PURGE BINARY LOGS 構文」</a>も参照してください。
        </p></div><p>
        <code class="literal">RESET MASTER</code> は、最初にマスターとスレーブを設定する場合に役立つことがあります。その場合は、設定を次のように確認できます。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            マスターとスレーブを起動し、レプリケーションを開始します (<a class="xref" href="replication.html#replication-howto" title="17.1.1 レプリケーションのセットアップ方法">セクション17.1.1「レプリケーションのセットアップ方法」</a>を参照してください)。
          </p></li><li class="listitem"><p>
            マスター上でいくつかのテストクエリーを実行します。
          </p></li><li class="listitem"><p>
            それらのクエリーがスレーブにレプリケートされたことを確認します。
          </p></li><li class="listitem"><p>
            レプリケーションが正しく実行されている場合は、スレーブ上で <code class="literal">STOP SLAVE</code> に続けて <code class="literal">RESET SLAVE</code> を発行したあと、不要なすべてのデータがスレーブ上に存在しなくなっていることを確認します。
          </p></li><li class="listitem"><p>
            マスター上で <code class="literal">RESET MASTER</code> を発行して、テストクエリーをクリーンアップします。
          </p></li></ol></div><p>
        設定を確認し、テストによって生成された不要なファイルやログファイルをすべて削除したら、スレーブを起動してレプリケーションを開始できます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="set-sql-log-bin"></a>13.4.1.3 SET sql_log_bin 構文</h4></div></div></div><a class="indexterm" name="idm139979081880512"></a><pre class="programlisting">
SET sql_log_bin = {0|1}
</pre><p>
        <code class="literal">sql_log_bin</code> 変数は、バイナリログへのロギングを実行するかどうかを制御します。デフォルト値は 1 (ロギングを実行する) です。現在のセッションのロギングを変更するには、この変数のセッション値を変更します。この変数を設定するには、セッションユーザーが <code class="literal">SUPER</code> 権限を持つ必要があります。スレーブにはレプリケートしたくない変更をマスターに対して行なっている間、セッションでバイナリロギングを一時的に無効にするには、この変数を 0 に設定します。
      </p><p>
        MySQL 5.5 の時点では、<code class="literal">sql_log_bin</code> はグローバルまたはセッション変数として設定できます。<code class="literal">sql_log_bin</code> のグローバルな設定は、新しいセッションが開始された時点でのみ検出されます。<code class="literal">sql_log_bin</code> をグローバルに設定した場合、以前から実行されているセッションは影響を受けません。
      </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
          グローバルスコープで <code class="literal">sql_log_bin</code> を誤って使用すると、すでに実行されているセッションで行われたすべての変更が<span class="emphasis"><em>引き続き</em></span>バイナリログに記録され、そのためにレプリケートされてしまいます。この状況によって、レプリケーションの失敗を含む予期しない結果が発生する可能性があるため、グローバルスコープで <code class="literal">sql_log_bin</code> を使用する場合は特に注意してください。
        </p></div><p>
        MySQL 5.6 では、トランザクションまたはサブクエリー内で <code class="literal">@@session.sql_log_bin</code> を設定することはできません。(バグ #53437)
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replication-slave-sql"></a>13.4.2 スレーブサーバーを制御するための SQL ステートメント</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-syntax.html#change-master-to">13.4.2.1 CHANGE MASTER TO 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#master-pos-wait">13.4.2.2 MASTER_POS_WAIT() 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#reset-slave">13.4.2.3 RESET SLAVE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#set-global-sql-slave-skip-counter">13.4.2.4 SET GLOBAL sql_slave_skip_counter 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#start-slave">13.4.2.5 START SLAVE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#stop-slave">13.4.2.6 STOP SLAVE 構文</a></span></dt></dl></div><a class="indexterm" name="idm139979081861152"></a><a class="indexterm" name="idm139979081858960"></a><a class="indexterm" name="idm139979081856896"></a><p>
      このセクションでは、スレーブレプリケーションサーバーを管理するためのステートメントについて説明します。<a class="xref" href="sql-syntax.html#replication-master-sql" title="13.4.1 マスターサーバーを制御するための SQL ステートメント">セクション13.4.1「マスターサーバーを制御するための SQL ステートメント」</a>では、マスターサーバーを管理するためのステートメントについて説明しています。
    </p><p>
      ここで説明されているステートメントに加えて、レプリケーションスレーブでは <code class="literal">SHOW SLAVE STATUS</code> および <code class="literal">SHOW RELAYLOG EVENTS</code> も使用されます。これらのステートメントについては、<a class="xref" href="sql-syntax.html#show-slave-status" title="13.7.5.35 SHOW SLAVE STATUS 構文">セクション13.7.5.35「SHOW SLAVE STATUS 構文」</a>および<a class="xref" href="sql-syntax.html#show-relaylog-events" title="13.7.5.33 SHOW RELAYLOG EVENTS 構文">セクション13.7.5.33「SHOW RELAYLOG EVENTS 構文」</a>を参照してください。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="change-master-to"></a>13.4.2.1 CHANGE MASTER TO 構文</h4></div></div></div><a class="indexterm" name="idm139979081847808"></a><pre class="programlisting">
CHANGE MASTER TO <em class="replaceable"><code>option</code></em> [, <em class="replaceable"><code>option</code></em>] ...

<em class="replaceable"><code>option</code></em>:
    MASTER_BIND = '<em class="replaceable"><code>interface_name</code></em>'
  | MASTER_HOST = '<em class="replaceable"><code>host_name</code></em>'
  | MASTER_USER = '<em class="replaceable"><code>user_name</code></em>'
  | MASTER_PASSWORD = '<em class="replaceable"><code>password</code></em>'
  | MASTER_PORT = <em class="replaceable"><code>port_num</code></em>
  | MASTER_CONNECT_RETRY = <em class="replaceable"><code>interval</code></em>
  | MASTER_RETRY_COUNT = <em class="replaceable"><code>count</code></em>
  | MASTER_DELAY = <em class="replaceable"><code>interval</code></em>
  | MASTER_HEARTBEAT_PERIOD = <em class="replaceable"><code>interval</code></em>
  | MASTER_LOG_FILE = '<em class="replaceable"><code>master_log_name</code></em>'
  | MASTER_LOG_POS = <em class="replaceable"><code>master_log_pos</code></em>
  | MASTER_AUTO_POSITION = {0|1}
  | RELAY_LOG_FILE = '<em class="replaceable"><code>relay_log_name</code></em>'
  | RELAY_LOG_POS = <em class="replaceable"><code>relay_log_pos</code></em>
  | MASTER_SSL = {0|1}
  | MASTER_SSL_CA = '<em class="replaceable"><code>ca_file_name</code></em>'
  | MASTER_SSL_CAPATH = '<em class="replaceable"><code>ca_directory_name</code></em>'
  | MASTER_SSL_CERT = '<em class="replaceable"><code>cert_file_name</code></em>'
  | MASTER_SSL_CRL = '<em class="replaceable"><code>crl_file_name</code></em>'
  | MASTER_SSL_CRLPATH = '<em class="replaceable"><code>crl_directory_name</code></em>'
  | MASTER_SSL_KEY = '<em class="replaceable"><code>key_file_name</code></em>'
  | MASTER_SSL_CIPHER = '<em class="replaceable"><code>cipher_list</code></em>'
  | MASTER_SSL_VERIFY_SERVER_CERT = {0|1}
  | IGNORE_SERVER_IDS = (<em class="replaceable"><code>server_id_list</code></em>)

<em class="replaceable"><code>server_id_list</code></em>:
    [<em class="replaceable"><code>server_id</code></em> [, <em class="replaceable"><code>server_id</code></em>] ... ]
</pre><p>
        <code class="literal">CHANGE MASTER TO</code> は、スレーブサーバーがマスターサーバーへの接続、マスターバイナリログの読み取り、およびスレーブリレーログの読み取りに使用するパラメータを変更します。また、マスター情報およびリレーログ情報リポジトリの内容も更新します (<a class="xref" href="replication.html#slave-logs" title="17.2.2 レプリケーションリレーおよびステータスログ">セクション17.2.2「レプリケーションリレーおよびステータスログ」</a>を参照してください)。<code class="literal">CHANGE MASTER TO</code> を使用するには、スレーブレプリケーションスレッドを停止する必要があります (必要に応じて <code class="literal">STOP SLAVE</code> を使用します)。MySQL 5.6.11 以降では、<code class="literal">gtid_next</code> も <code class="literal">AUTOMATIC</code> に設定する必要があります (Bug #16062608)。
      </p><p>
        次の説明に示されているものを除き、指定されていないオプションはその値を保持します。そのため、ほとんどの場合、変更されないオプションを指定する必要はありません。たとえば、MySQL マスターに接続するためのパスワードが変更された場合は、新しいパスワードについてスレーブに通知するために次のステートメントを発行するだけで済みます。
      </p><pre class="programlisting">
STOP SLAVE; -- if replication was running
CHANGE MASTER TO MASTER_PASSWORD='new3cret';
START SLAVE; -- if you want to restart replication
</pre><p>
        <code class="literal">MASTER_HOST</code>、<code class="literal">MASTER_USER</code>、<code class="literal">MASTER_PASSWORD</code>、および <code class="literal">MASTER_PORT</code> はスレーブに、そのマスターに接続する方法に関する情報を提供します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">MASTER_HOST</code> と <code class="literal">MASTER_PORT</code> は、マスターホストのホスト名 (または IP アドレス) とその TCP/IP ポートです。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              レプリケーションでは、Unix ソケットファイルを使用できません。また、TCP/IP を使用してマスター MySQL サーバーに接続できる必要があります。
            </p></div><p>
            <code class="literal">MASTER_HOST</code> または <code class="literal">MASTER_PORT</code> オプションを指定すると、スレーブは (そのオプション値が現在の値と同じ場合でも) マスターサーバーが以前とは異なっていると見なします。この場合、マスターバイナリログファイルの名前と位置の古い値は適用されなくなったと見なされるため、このステートメントで <code class="literal">MASTER_LOG_FILE</code> と <code class="literal">MASTER_LOG_POS</code> を指定しないと、そのあとに <code class="literal">MASTER_LOG_FILE=''</code> と <code class="literal">MASTER_LOG_POS=4</code> が暗黙のうちに付加されます。
          </p><p>
            <code class="literal">MASTER_HOST=''</code> を設定する (つまり、その値を明示的に空の文字列に設定する) ことは、<code class="literal">MASTER_HOST</code> をまったく設定しないことと同じでは<span class="emphasis"><em>ありません</em></span>。MySQL 5.5 からは、<code class="literal">MASTER_HOST</code> を空の文字列に設定しようとするとエラーで失敗します。以前は、<code class="literal">MASTER_HOST</code> を空の文字列に設定すると、そのあとの <code class="literal">START SLAVE</code> が失敗しました。(Bug #28796)
          </p><p>
            MySQL 5.6.5 以降では、<code class="literal">MASTER_HOST</code> やその他の <code class="literal">CHANGE MASTER TO</code> オプションに使用されている値にラインフィード (<code class="literal">\n</code> または <code class="literal">0x0A</code>) 文字が含まれていないかがチェックされます。このような文字がこれらの値に含まれていると、ステートメントが <span class="errorname">ER_MASTER_INFO</span> で失敗します。(Bug #11758581、Bug #50801)
          </p></li><li class="listitem"><p>
            <code class="literal">MASTER_USER</code> と <code class="literal">MASTER_PASSWORD</code> は、マスターへの接続に使用するアカウントのユーザー名とパスワードです。
          </p><p>
            MySQL 5.6.4 以降では、<code class="literal">MASTER_USER</code> を空にすることはできません。<code class="literal">MASTER_PASSWORD</code> の値を設定するときに <code class="literal">MASTER_USER = ''</code> を設定するか、または未設定のままにするとエラーが発生します (Bug #13427949)。
          </p><p>
            <code class="literal">CHANGE MASTER TO</code> ステートメントで MySQL レプリケーションスレーブアカウントに使用されるパスワードは、長さが 32 文字に制限されます。パスワードがこれより長い場合、このステートメントは成功しますが、超過した文字はすべて暗黙のうちに切り捨てられます。これは MySQL レプリケーションに固有の問題であり、MySQL 5.7 で修正されています。(Bug #11752299、Bug #43439)
          </p><p>
            実行中の <code class="literal">CHANGE MASTER TO</code> ステートメントのテキスト (<code class="literal">MASTER_USER</code> と <code class="literal">MASTER_PASSWORD</code> の値を含む) は、並列 <code class="literal">SHOW PROCESSLIST</code> ステートメントの出力で確認できます。(<code class="literal">SHOW PROCESSLIST</code> には <code class="literal">START SLAVE</code> ステートメントの完全なテキストも表示されます。) 
          </p></li></ul></div><p>
        <code class="literal">MASTER_SSL_<em class="replaceable"><code>xxx</code></em></code> オプションは、接続での SSL の使用に関する情報を提供します。これらは、<a class="xref" href="security.html#ssl-options" title="6.3.10.4 SSL コマンドのオプション">セクション6.3.10.4「SSL コマンドのオプション」</a>および<a class="xref" href="replication.html#replication-solutions-ssl" title="17.3.7 SSL を使用してレプリケーションをセットアップする">セクション17.3.7「SSL を使用してレプリケーションをセットアップする」</a>で説明されている <code class="option">--ssl-<em class="replaceable"><code>xxx</code></em></code> オプションに対応します。これらのオプションは、SSL サポートなしでコンパイルされたスレーブ上でも変更できます。これらはマスター情報リポジトリに保存されますが、スレーブで SSL サポートが有効になっていない場合は無視されます。<code class="literal">MASTER_SSL_CRL</code> と <code class="literal">MASTER_SSL_CRLPATH</code> は MySQL 5.6.3 で追加されました。
      </p><p>
        <code class="literal">MASTER_CONNECT_RETRY</code> は、接続再試行の間で待機する秒数を指定します。デフォルトは 60 です。
      </p><p>
        <code class="literal">MASTER_RETRY_COUNT</code> (MySQL 5.6.1 で追加されました) は、再接続の試行の<span class="emphasis"><em>回数</em></span>を制限し、<code class="literal">SHOW SLAVE STATUS</code> (これも MySQL 5.6.1 で追加されました) の出力内の <code class="literal">Master_Retry_Count</code> カラムの値を更新します。デフォルト値は 24 * 3600 = 86400 です。<code class="literal">MASTER_RETRY_COUNT</code> は古い <code class="option">--master-retry-count</code> サーバーオプションの置き換えを目的にしており、現在ではこの制限を設定するための推奨される方法です。新しいアプリケーションでは <code class="option">--master-retry-count</code> に依存しないようにするとともに、以前のバージョンの MySQL から MySQL 5.6.1 以降にアップグレードする場合は、これに依存する既存のすべてのアプリケーションを、代わりに <code class="literal">CHANGE MASTER TO ... MASTER_RETRY_COUNT</code> を使用するように更新することをお勧めします。
      </p><p>
        <code class="literal">MASTER_DELAY</code> は、スレーブがマスターから遅延する必要がある秒数を指定します。マスターから受信されたイベントは、そのマスター上での実行より少なくとも <em class="replaceable"><code>interval</code></em> 秒あとになるまで実行されません。デフォルトは 0 です。<em class="replaceable"><code>interval</code></em> が 0 から 2<sup>31</sup>-1 までの範囲の負ではない整数でない場合は、エラーが発生します。詳細は、<a class="xref" href="replication.html#replication-delayed" title="17.3.9 遅延レプリケーション">セクション17.3.9「遅延レプリケーション」</a>を参照してください。このオプションは MySQL 5.6.0 で追加されました。
      </p><p>
        <code class="literal">MASTER_BIND</code> は、複数のネットワークインタフェースを備えたレプリケーションスレーブ上で使用されることを目的にしており、マスターへの接続にそのスレーブのどのネットワークインタフェースが選択されるかを決定します。
      </p><p>
        このオプションを使用して構成されたアドレス (存在する場合) は、<code class="literal">SHOW SLAVE STATUS</code> からの出力の <code class="literal">Master_Bind</code> カラムで確認できます。スレーブステータスログテーブルを使用している (サーバーを <code class="option">--master-info-repository=TABLE</code> で起動している) 場合、この値はまた、<code class="literal">mysql.slave_master_info</code> テーブルの <code class="literal">Master_bind</code> カラムとしても確認できます。
      </p><p>
        レプリケーションスレーブを特定のネットワークインタフェースにバインドする機能は、MySQL 5.6.2 で追加されました。これはまた、MySQL Cluster NDB 7.3.1 以降でもサポートされています。
      </p><p>
        <code class="literal">MASTER_HEARTBEAT_PERIOD</code> は、レプリケーションハートビートの間の間隔 (秒単位) を設定します。イベントによってマスターのバイナリログが更新されると常に、次のハートビートの待機中の期間がリセットされます。<em class="replaceable"><code>interval</code></em> は、0 から 4294967 秒までの範囲とミリ秒単位の分解能を持つ 10 進数値です。0 以外の最小の値は 0.001 です。ハートビートがマスターによって送信されるのは、バイナリログファイル内に未送信のイベントが <em class="replaceable"><code>interval</code></em> より長い期間にわたって存在しない場合だけです。
      </p><p>
        マスター接続情報をテーブルにロギングしている場合、<code class="literal">MASTER_HEARTBEAT_PERIOD</code> は、<code class="literal">mysql.slave_master_info</code> テーブルの <code class="literal">Heartbeat</code> カラムの値として確認できます。
      </p><p>
        <em class="replaceable"><code>interval</code></em> を 0 に設定すると、ハートビートが完全に無効になります。<em class="replaceable"><code>interval</code></em> のデフォルト値は、<code class="literal">slave_net_timeout</code> を 2 で割った値に等しくなります。
      </p><p>
        <code class="literal">@@global.slave_net_timeout</code> を現在のハートビート間隔より小さい値に設定すると、警告が発行されます。ハートビート間隔に対して <code class="literal">RESET SLAVE</code> を発行する効果は、その間隔のデフォルト値へのリセットです。
      </p><p>
        <code class="literal">MASTER_LOG_FILE</code> と <code class="literal">MASTER_LOG_POS</code> は、スレーブ I/O スレッドが、次回そのスレッドが起動されたときにマスターからの読み取りを開始すべき座標です。<code class="literal">RELAY_LOG_FILE</code> と <code class="literal">RELAY_LOG_POS</code> は、スレーブ SQL スレッドが、次回そのスレッドが起動されたときにリレーログからの読み取りを開始すべき座標です。<code class="literal">MASTER_LOG_FILE</code> または <code class="literal">MASTER_LOG_POS</code> のどちらかを指定する場合は、<code class="literal">RELAY_LOG_FILE</code> や <code class="literal">RELAY_LOG_POS</code> を指定できません。MySQL 5.6.5 以降では、<code class="literal">MASTER_LOG_FILE</code> または <code class="literal">MASTER_LOG_POS</code> のどちらかを指定する場合は、<code class="literal">MASTER_AUTO_POSITION = 1</code> (このセクションのあとの方で説明されています) も指定できません。<code class="literal">MASTER_LOG_FILE</code> と <code class="literal">MASTER_LOG_POS</code> のどちらも指定されていない場合、スレーブは、<code class="literal">CHANGE MASTER TO</code> が発行される前の<span class="emphasis"><em>スレーブ SQL スレッド</em></span>の最後の座標を使用します。これにより、たとえば、単に使用するパスワードだけを変更する場合、スレーブ SQL スレッドがスレーブ I/O スレッドに比べて遅くなったとしても、レプリケーションに不連続性が発生しないことが保証されます。
      </p><p>
        <code class="literal">MASTER_AUTO_POSITION</code> は、MySQL 5.6.5 で追加されました。<code class="literal">MASTER_AUTO_POSITION = 1</code> が <code class="literal">CHANGE MASTER TO</code> とともに使用された場合、スレーブは、GTID ベースのレプリケーションプロトコルを使用してマスターに接続しようとします。
      </p><p>
        GTID を使用している場合、スレーブは、どのトランザクションの受信または実行、あるいはその両方をすでに行なっているかをマスターに通知します。このセットを計算するために、スレーブは、<code class="literal">gtid_executed</code> のグローバル値と <code class="literal">SHOW SLAVE STATUS</code> からの <code class="literal">Retrieved_gtid_set</code> カラムの値を読み取ります。<code class="literal">Retrieved_gtid_set</code> には最後に転送されたトランザクションの GTID が、そのトランザクションが部分的にしか転送されなかった場合でも含まれているため、最後に受信された GTID はこのセットから除かれます。そのため、スレーブは次のセットを計算します。
      </p><pre class="programlisting">
UNION(@@global.gtid_executed, Retrieved_gtid_set - <em class="replaceable"><code>last_received_GTID</code></em>)
</pre><p>
        このセットは初期ハンドシェークの一部としてマスターに送信され、マスターは実行したうちの、そのセットに含まれていないすべてのトランザクションを戻します。これらのトランザクションのいずれかがすでにマスターのバイナリログからパージされている場合は、マスターからスレーブにエラー <span class="errorname">ER_MASTER_HAS_PURGED_REQUIRED_GTIDS</span> が送信され、レプリケーションは開始されません。
      </p><p>
        GTID ベースのレプリケーションが使用されている場合、<code class="literal">MASTER_LOG_FILE</code> と <code class="literal">MASTER_LOG_POS</code> によって表された座標は使用されず、代わりにグローバルトランザクション識別子が使用されます。そのため、これらのオプションのどちらかまたは両方を <code class="literal">MASTER_AUTO_POSITION</code> とともに使用するとエラーが発生します。
      </p><p>
        MySQL 5.6.10 からは、<code class="literal">SHOW SLAVE STATUS</code> の出力をチェックすることによって、自動ポジショニングが有効な状態でレプリケーションが実行されているかどうかを確認できます。(Bug #15992220)
      </p><p>
        <code class="literal">CHANGE MASTER TO ... MASTER_AUTO_POSITION = 1</code> を発行する前に、<code class="literal">gtid_mode</code> も有効にする必要があります。そうしないと、このステートメントはエラーで失敗します。
      </p><p>
        GTID を使用したあとに古いファイルベースのレプリケーションプロトコルに戻すには、<code class="literal">MASTER_LOG_FILE</code> または <code class="literal">MASTER_LOG_POSITION</code> のうちの少なくとも 1 つだけでなく、<code class="literal">MASTER_AUTO_POSITION = 0</code> を指定する新しい <code class="literal">CHANGE MASTER TO</code> ステートメントを発行できます。
      </p><p>
        <code class="literal">CHANGE MASTER TO</code> は、<code class="literal">RELAY_LOG_FILE</code> または <code class="literal">RELAY_LOG_POS</code> が指定されていないかぎり、<span class="emphasis"><em>すべてのリレーログファイルを削除し</em></span>、新しいリレーログファイルを開始します。指定されている場合、リレーログファイルは保持され、<code class="literal">relay_log_purge</code> グローバル変数は暗黙のうちに 0 に設定されます。
      </p><p>
        MySQL 5.6.2 より前は、<code class="literal">RELAY_LOG_FILE</code> には絶対パスが必要でした。MySQL 5.6.2 からは、パスを相対パスにすることができます。その場合は、スレーブのデータディレクトリを基準にしていると見なされます。(Bug #12190)
      </p><p>
        <code class="literal">IGNORE_SERVER_IDS</code> は、0 個以上のサーバー ID のカンマ区切りリストを受け取ります。対応するサーバーから発信されているイベントは、引き続リレーログ内に記録されるログのローテーションおよび削除イベントを除いて無視されます。
      </p><p>
        循環レプリケーションでは、発信元のサーバーは通常、独自のイベントのターミネータとして機能するため、これらのイベントが複数回適用されることはありません。そのため、このオプションは、循環内のいずれかのサーバーが削除されたときの循環レプリケーションで役立ちます。1、2、3、および 4 のサーバー ID を持つ 4 台のサーバーを含む循環レプリケーションセットアップが存在するとき、サーバー 3 に障害が発生したとします。サーバー 2 からサーバー 4 へのレプリケーションを開始してこのギャップをブリッジする場合、サーバー 4 上で発行する <code class="literal">CHANGE MASTER TO</code> ステートメント内に <code class="literal">IGNORE_SERVER_IDS = (3)</code> を含めることにより、サーバー 4 にそのマスターとしてサーバー 3 の代わりにサーバー 2 を使用するよう指示できます。それにより、サーバー 4 は、使用されなくなっているサーバーで発信されたすべてのステートメントを無視し、伝播しなくなります。
      </p><p>
        <code class="literal">CHANGE MASTER TO</code> ステートメントが <code class="literal">IGNORE_SERVER_IDS</code> オプションなしで発行された場合は、既存のリストがすべて保持されます。無視されるサーバーのリストをクリアするには、このオプションを空のリストとともに使用する必要があります。
      </p><pre class="programlisting">
CHANGE MASTER TO IGNORE_SERVER_IDS = ();
</pre><p>
        <code class="literal">RESET SLAVE ALL</code> は、サーバー ID リストには影響を与えません。この問題は MySQL 5.7 で修正されています。(Bug #18816897)
      </p><p>
        <code class="literal">IGNORE_SERVER_IDS</code> にサーバーの独自の ID が含まれているときに、<code class="option">--replicate-same-server-id</code> オプションが有効な状態でそのサーバーが起動された場合は、エラーが発生します。
      </p><p>
        MySQL 5.6 では、マスター情報リポジトリおよび <code class="literal">SHOW SLAVE STATUS</code> の出力によって、現在無視されているサーバーのリストが提供されます。詳細は、<a class="xref" href="replication.html#slave-logs-status" title="17.2.2.2 スレーブステータスログ">セクション17.2.2.2「スレーブステータスログ」</a>および<a class="xref" href="sql-syntax.html#show-slave-status" title="13.7.5.35 SHOW SLAVE STATUS 構文">セクション13.7.5.35「SHOW SLAVE STATUS 構文」</a>を参照してください。
      </p><p>
        MySQL 5.6 では、<code class="literal">CHANGE MASTER TO</code> を呼び出すと、<code class="literal">MASTER_HOST</code>、<code class="literal">MASTER_PORT</code>、<code class="literal">MASTER_LOG_FILE</code>、および <code class="literal">MASTER_LOG_POS</code> の以前の値が、実行の前のスレーブの状態に関するその他の情報とともにエラーログに書き込まれます。
      </p><p>
        MySQL 5.6.7 以降では、<code class="literal">CHANGE MASTER TO</code> によって進行中のトランザクションの暗黙的なコミットが発生します。<a class="xref" href="sql-syntax.html#implicit-commit" title="13.3.3 暗黙的なコミットを発生させるステートメント">セクション13.3.3「暗黙的なコミットを発生させるステートメント」</a>を参照してください。
      </p><p>
        <code class="literal">CHANGE MASTER TO</code> は、マスターのスナップショットが存在し、かつそのスナップショットの時間に対応するマスターバイナリログの座標が記録されている場合のスレーブの設定に役立ちます。そのスナップショットをスレーブにロードしてスレーブをマスターと同期させたあと、スレーブ上で <code class="literal">CHANGE MASTER TO MASTER_LOG_FILE='<em class="replaceable"><code>log_name</code></em>'、MASTER_LOG_POS=<em class="replaceable"><code>log_pos</code></em></code> を実行して、スレーブがマスターバイナリログの読み取りを開始すべき座標を指定できます。
      </p><p>
        次の例では、スレーブが使用するマスターサーバーを変更し、スレーブが読み取りを開始するマスターバイナリログの座標を確立します。これは、マスターをレプリケートするスレーブを設定する場合に使用されます。
      </p><pre class="programlisting">
CHANGE MASTER TO
  MASTER_HOST='master2.mycompany.com',
  MASTER_USER='replication',
  MASTER_PASSWORD='bigs3cret',
  MASTER_PORT=3306,
  MASTER_LOG_FILE='master2-bin.001',
  MASTER_LOG_POS=4,
  MASTER_CONNECT_RETRY=10;
</pre><p>
        次の例は、使用される頻度の低い操作を示しています。これは、何らかの理由で再度実行したいリレーログファイルがスレーブに存在する場合に使用されます。これを行うために、マスターに到達できる必要はありません。<code class="literal">CHANGE MASTER TO</code> を使用し、SQL スレッドを開始する (<code class="literal">START SLAVE SQL_THREAD</code>) だけで済みます。
      </p><pre class="programlisting">
CHANGE MASTER TO
  RELAY_LOG_FILE='slave-relay-bin.006',
  RELAY_LOG_POS=4025;
</pre><p>
        この 2 番目の操作は、クラッシュのあとのリカバリのために、スレーブ以外のスタンドアロンサーバーを含む非レプリケーションセットアップで使用することもできます。サーバーがクラッシュし、それをバックアップからリストアしたとします。そのサーバーの独自の (たとえば、<code class="filename">myhost-bin.*</code> という名前の) バイナリログファイル (リレーログファイルではなく、通常のバイナリログファイル) を再実行しようとしています。まず、下の手順のとおりに実行せず、バイナリログがサーバーで誤ってパージされた場合に備えて、これらのバイナリログファイルのバックアップコピーをどこか安全な場所に作成します。さらに安全にするために、<code class="literal">SET GLOBAL relay_log_purge=0</code> を使用します。次に、<code class="option">--log-bin</code> オプションなしでサーバーを起動します。代わりに、<code class="option">--replicate-same-server-id</code>、<code class="option">--relay-log=myhost-bin</code> (サーバーに、これらの通常のバイナリログファイルがリレーログファイルであると信じ込ませるため)、および <code class="option">--skip-slave-start</code> オプションを使用します。サーバーが起動したら、次のステートメントを発行します。
      </p><pre class="programlisting">
CHANGE MASTER TO
  RELAY_LOG_FILE='myhost-bin.153',
  RELAY_LOG_POS=410,
  MASTER_HOST='some_dummy_string';
START SLAVE SQL_THREAD;
</pre><p>
        サーバーは独自のバイナリログファイルを読み取って実行し、それによりクラッシュリカバリを実現します。リカバリが完了したら、<code class="literal">STOP SLAVE</code> を実行し、サーバーをシャットダウンし、マスター情報およびリレーログ情報リポジトリをクリアして、サーバーをその元のオプションで再起動します。
      </p><p>
        <code class="literal">MASTER_HOST</code> オプションの指定 (ダミー値であっても) は、サーバーにそれがスレーブであると思わせるために必要です。
      </p><p>
        次の表は、文字列値のオプションに許可される最大長を示しています。
      </p><div class="informaltable"><table summary="この表は、MASTER_POS_WAIT() 文字列値のオプションに許可される最大長を示しています。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">オプション</th><th scope="col">最大長</th></tr></thead><tbody><tr><td scope="row"><code class="literal">MASTER_HOST</code></td><td>60</td></tr><tr><td scope="row"><code class="literal">MASTER_USER</code></td><td>16</td></tr><tr><td scope="row"><code class="literal">MASTER_PASSWORD</code></td><td>32</td></tr><tr><td scope="row"><code class="literal">MASTER_LOG_FILE</code></td><td>255</td></tr><tr><td scope="row"><code class="literal">RELAY_LOG_FILE</code></td><td>255</td></tr><tr><td scope="row"><code class="literal">MASTER_SSL_CA</code></td><td>255</td></tr><tr><td scope="row"><code class="literal">MASTER_SSL_CAPATH</code></td><td>255</td></tr><tr><td scope="row"><code class="literal">MASTER_SSL_CERT</code></td><td>255</td></tr><tr><td scope="row"><code class="literal">MASTER_SSL_CRL</code></td><td>255</td></tr><tr><td scope="row"><code class="literal">MASTER_SSL_CRLPATH</code></td><td>255</td></tr><tr><td scope="row"><code class="literal">MASTER_SSL_KEY</code></td><td>255</td></tr><tr><td scope="row"><code class="literal">MASTER_SSL_CIPHER</code></td><td>511</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="master-pos-wait"></a>13.4.2.2 MASTER_POS_WAIT() 構文</h4></div></div></div><a class="indexterm" name="idm139979081636320"></a><pre class="programlisting">
SELECT MASTER_POS_WAIT('<em class="replaceable"><code>master_log_file</code></em>', <em class="replaceable"><code>master_log_pos</code></em> [, <em class="replaceable"><code>timeout</code></em>])
</pre><p>
        これはステートメントではなく、実際には関数です。これは、スレーブがマスターのバイナリログ内の特定の位置までのイベントを読み取って実行したことを確認するために使用されます。完全な説明については、<a class="xref" href="functions.html#miscellaneous-functions" title="12.18 その他の関数">セクション12.18「その他の関数」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="reset-slave"></a>13.4.2.3 RESET SLAVE 構文</h4></div></div></div><a class="indexterm" name="idm139979081630016"></a><a class="indexterm" name="idm139979081628704"></a><pre class="programlisting">
RESET SLAVE [ALL]
</pre><p>
        <code class="literal">RESET SLAVE</code> は、スレーブに、マスターのバイナリログ内のそのレプリケーション位置を忘れさせます。このステートメントは、クリーンな開始に使用されるように考慮されています。つまり、マスター情報およびリレーログ情報リポジトリをクリアし、すべてのリレーログファイルを削除して、新しいリレーログファイルを開始します。また、<code class="literal">CHANGE MASTER TO</code> の <code class="literal">MASTER_DELAY</code> オプションで指定されたレプリケーション遅延も 0 にリセットします。<code class="literal">RESET SLAVE</code> を使用するには、スレーブレプリケーションスレッドを停止する必要があります (必要に応じて <code class="literal">STOP SLAVE</code> を使用します)。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          スレーブ SQL スレッドによってリレーログファイルが完全には実行されていない場合でも、すべてのリレーログファイルが削除されます。(これは、<code class="literal">STOP SLAVE</code> ステートメントを発行した場合や、スレーブの負荷が高い場合に、レプリケーションスレーブ上に存在する可能性がある条件です。) 
        </p></div><p>
        MySQL 5.6 では (MySQL 5.1 以前の場合とは異なり)、<code class="literal">RESET SLAVE</code> は、メモリー内に保持されているマスターホスト、マスターポート、マスターユーザー、マスターパスワードなどのレプリケーション接続パラメータを変更しません。つまり、<code class="literal">RESET SLAVE</code> のあとに <code class="literal">CHANGE MASTER TO</code> ステートメントを必要とすることなく <code class="literal">START SLAVE</code> を発行できます。
      </p><p>
        <code class="literal">RESET SLAVE</code> に続いてスレーブの <span class="command"><strong>mysqld</strong></span> がシャットダウンされた場合は、接続パラメータがリセットされます。MySQL 5.6.3 以降では、代わりに <code class="literal">RESET SLAVE ALL</code> を使用して、これらの接続パラメータをリセットできます (Bug #11809016)。
      </p><p>
        <code class="literal">RESET SLAVE ALL</code> は、<code class="literal">CHANGE MASTER TO</code> によって設定された <code class="literal">IGNORE_SERVER_IDS</code> リストをクリアしません。この問題は MySQL 5.7 で修正されています。(Bug #18816897)
      </p><p>
        MySQL 5.6.7 以降では、<code class="literal">RESET SLAVE</code> によって進行中のトランザクションの暗黙的なコミットが発生します。<a class="xref" href="sql-syntax.html#implicit-commit" title="13.3.3 暗黙的なコミットを発生させるステートメント">セクション13.3.3「暗黙的なコミットを発生させるステートメント」</a>を参照してください。
      </p><p>
        スレーブ SQL スレッドが停止され、<code class="literal">RESET SLAVE</code> が発行されたときにそのスレッドが一時テーブルをレプリケートしている最中であった場合、これらのレプリケートされた一時テーブルはスレーブ上で削除されます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="set-global-sql-slave-skip-counter"></a>13.4.2.4 SET GLOBAL sql_slave_skip_counter 構文</h4></div></div></div><a class="indexterm" name="idm139979081598480"></a><a class="indexterm" name="idm139979081597152"></a><a class="indexterm" name="idm139979081595792"></a><a class="indexterm" name="idm139979081594304"></a><pre class="programlisting">
SET GLOBAL sql_slave_skip_counter = <em class="replaceable"><code>N</code></em>
</pre><p>
        このステートメントは、マスターからの次の <em class="replaceable"><code>N</code></em> 個のイベントをスキップします。これは、あるステートメントによって発生したレプリケーション停止からのリカバリに役立ちます。
      </p><p>
        このステートメントは、スレーブスレッドが実行されていない場合にのみ有効です。そうでないと、エラーが生成されます。
      </p><p>
        このステートメントを使用する場合は、バイナリログが実際には、<em class="firstterm">イベントグループ</em>と呼ばれるグループのシーケンスとして構成される点を理解することが重要です。各イベントグループは、イベントのシーケンスで構成されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            トランザクションテーブルの場合、イベントグループはトランザクションに対応しています。
          </p></li><li class="listitem"><p>
            非トランザクションテーブルの場合、イベントグループは 1 つの SQL ステートメントに対応しています。
          </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          1 つのトランザクションに、トランザクションテーブルと非トランザクションテーブルの両方の変更を含めることができます。
        </p></div><p>
        <code class="literal">SET GLOBAL sql_slave_skip_counter</code> を使用してイベントをスキップした結果がグループの途中である場合、スレーブは、そのグループの最後に達するまで引き続きイベントをスキップします。そのあと、次のイベントグループから実行が開始されます。
      </p><p>
        MySQL 5.6 では、このステートメントを発行すると、<code class="literal">RELAY_LOG_FILE</code>、<code class="literal">RELAY_LOG_POS</code>、および <code class="literal">sql_slave_skip_counter</code> の以前の値がエラーログに書き込まれます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="start-slave"></a>13.4.2.5 START SLAVE 構文</h4></div></div></div><a class="indexterm" name="idm139979081574672"></a><pre class="programlisting">
START SLAVE [<em class="replaceable"><code>thread_types</code></em>] [<em class="replaceable"><code>until_option</code></em>] [<em class="replaceable"><code>connection_options</code></em>]

<em class="replaceable"><code>thread_types</code></em>:
    [<em class="replaceable"><code>thread_type</code></em> [, <em class="replaceable"><code>thread_type</code></em>] ... ]

<em class="replaceable"><code>thread_type</code></em>: 
    IO_THREAD | SQL_THREAD

<em class="replaceable"><code>until_option</code></em>:
    UNTIL {   {SQL_BEFORE_GTIDS | SQL_AFTER_GTIDS} = <em class="replaceable"><code>gtid_set</code></em>
          |   MASTER_LOG_FILE = '<em class="replaceable"><code>log_name</code></em>', MASTER_LOG_POS = <em class="replaceable"><code>log_pos</code></em>
          |   RELAY_LOG_FILE = '<em class="replaceable"><code>log_name</code></em>', RELAY_LOG_POS = <em class="replaceable"><code>log_pos</code></em>
          |   SQL_AFTER_MTS_GAPS  }

<em class="replaceable"><code>connection_options</code></em>: 
    [USER='<em class="replaceable"><code>user_name</code></em>'] [PASSWORD='<em class="replaceable"><code>user_pass</code></em>'] [DEFAULT_AUTH='<em class="replaceable"><code>plugin_name</code></em>'] [PLUGIN_DIR='<em class="replaceable"><code>plugin_dir</code></em>']


<em class="replaceable"><code>gtid_set</code></em>:
    <em class="replaceable"><code>uuid_set</code></em> [, <em class="replaceable"><code>uuid_set</code></em>] ...
    | ''

<em class="replaceable"><code>uuid_set</code></em>:
    <em class="replaceable"><code>uuid</code></em>:<em class="replaceable"><code>interval</code></em>[:<em class="replaceable"><code>interval</code></em>]...

<em class="replaceable"><code>uuid</code></em>:
    <em class="replaceable"><code>hhhhhhhh</code></em>-<em class="replaceable"><code>hhhh</code></em>-<em class="replaceable"><code>hhhh</code></em>-<em class="replaceable"><code>hhhh</code></em>-<em class="replaceable"><code>hhhhhhhhhhhh</code></em>

<em class="replaceable"><code>h</code></em>:
    [0-9,A-F]

<em class="replaceable"><code>interval</code></em>:
    <em class="replaceable"><code>n</code></em>[-<em class="replaceable"><code>n</code></em>]

    (<em class="replaceable"><code>n</code></em> &gt;= 1) 
</pre><p>
        <em class="replaceable"><code>thread_type</code></em> オプションのない <code class="literal">START SLAVE</code> は、両方のスレーブスレッドを開始します。I/O スレッドはマスターサーバーからのイベントを読み取り、それをリレーログ内に格納します。SQL スレッドはリレーログからのイベントを読み取り、それを実行します。<code class="literal">START SLAVE</code> には、<code class="literal">SUPER</code> 権限が必要です。
      </p><p>
        <code class="literal">START SLAVE</code> は、スレーブスレッドの開始に成功すると、エラーなしで復帰します。ただし、その場合でも、それらのスレーブスレッドは開始したあとに (たとえば、マスターに接続できない、そのバイナリログを読み取れない、またはその他の何らかの問題のために) 停止する可能性があります。<code class="literal">START SLAVE</code> では、これについての警告が発生されません。スレーブのエラーログでスレーブスレッドによって生成されたエラーメッセージをチェックするか、または <code class="literal">SHOW SLAVE STATUS</code> を使用してスレーブスレッドが正常に実行されていることをチェックする必要があります。
      </p><p>
        MySQL 5.6.7 以降では、<code class="literal">START SLAVE</code> によって進行中のトランザクションの暗黙的なコミットが発生します。<a class="xref" href="sql-syntax.html#implicit-commit" title="13.3.3 暗黙的なコミットを発生させるステートメント">セクション13.3.3「暗黙的なコミットを発生させるステートメント」</a>を参照してください。
      </p><p>
        MySQL 5.6.11 からは、このステートメントを発行する前に、<code class="literal">gtid_next</code> を <code class="literal">AUTOMATIC</code> に設定する必要があります (Bug #16062608)。
      </p><p>
        MySQL 5.6.4 以降では、次のリストで説明されているように、<code class="literal">START SLAVE</code> を <code class="literal">USER</code>、<code class="literal">PASSWORD</code>、<code class="literal">DEFAULT_AUTH</code> および <code class="literal">PLUGIN_DIR</code> オプションとともに使用したプラガブルなユーザーパスワード認証がサポートされます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">USER</code>: ユーザー名。<code class="literal">PASSWORD</code> が使用されている場合は、空または NULL 文字列に設定したり、未設定のままにしたりすることはできません。
          </p></li><li class="listitem"><p>
            <code class="literal">PASSWORD</code>: パスワード。
          </p></li><li class="listitem"><p>
            <code class="literal">DEFAULT_AUTH</code>: プラグインの名前。デフォルトは MySQL ネイティブ認証です。
          </p></li><li class="listitem"><p>
            <code class="literal">PLUGIN_DIR</code>: プラグインの場所。
          </p></li></ul></div><p>
        MySQL 5.6.4 からは、<code class="literal">USER</code>、<code class="literal">PASSWORD</code>、<code class="literal">DEFAULT_AUTH</code>、<code class="literal">PLUGIN_DIR</code> のいずれかを指定するときは、<code class="literal">IO_THREAD</code> オプションも同時に指定されていないかぎり、<code class="literal">SQL_THREAD</code> オプションを使用できません (Bug #13083642)。
      </p><p>
        詳細は、<a class="xref" href="security.html#pluggable-authentication" title="6.3.7 プラガブル認証">セクション6.3.7「プラガブル認証」</a>を参照してください。
      </p><p>
        これらのいずれかのオプションとともにセキュアでない接続が使用されている場合、サーバーは次の警告を発行します: <span class="errortext">Sending passwords in plain text without SSL/TLS is extremely insecure</span>
      </p><p>
        MySQL 5.6.6 から、<code class="literal">START SLAVE ... UNTIL</code> は、グローバルトランザクション識別子 (GTID) で使用するための 2 つの追加オプションをサポートしています (<a class="xref" href="replication.html#replication-gtids" title="17.1.3 グローバルトランザクション識別子を使用したレプリケーション">セクション17.1.3「グローバルトランザクション識別子を使用したレプリケーション」</a>を参照してください)。これらの各オプションは、引数として 1 つ以上のグローバルトランザクション識別子のセット <em class="replaceable"><code>gtid_set</code></em> を受け取ります (詳細は、<a class="xref" href="replication.html#replication-gtids-concepts-gtid-sets" title="GTID セット">GTID セット</a>を参照してください)。
      </p><p>
        <em class="replaceable"><code>thread_type</code></em> が指定されていない場合は、<code class="literal">START SLAVE UNTIL SQL_BEFORE_GTIDS</code> を指定すると、スレーブ SQL スレッドは、<em class="replaceable"><code>gtid_set</code></em> に GTID がリストされている<span class="emphasis"><em>最初の</em></span>トランザクションに達するまでトランザクションを処理します。<code class="literal">START SLAVE UNTIL SQL_AFTER_GTIDS</code> を指定すると、スレーブスレッドは、<em class="replaceable"><code>gtid_set</code></em> 内の<em class="replaceable"><code>最後の</code></em>トランザクションが両方のスレッドによって処理されるまですべてのトランザクションを処理します。つまり、<code class="literal">START SLAVE UNTIL SQL_BEFORE_GTIDS</code> を指定すると、スレーブ SQL スレッドは <em class="replaceable"><code>gtid_set</code></em> 内の最初の GTID に達する前に現れたすべてのトランザクションを処理し、<code class="literal">START SLAVE UNTIL SQL_AFTER_GTIDS</code> を指定すると、スレーブスレッドはそれぞれがこのセットに GTID が含まれていないトランザクションを見つけるまで、<em class="replaceable"><code>gtid_set</code></em> 内に GTID が見つかったトランザクションを含むすべてのトランザクションを処理します。<code class="literal">SQL_BEFORE_GTIDS</code> と <code class="literal">SQL_AFTER_GTIDS</code> はそれぞれ、<code class="literal">SQL_THREAD</code> および <code class="literal">IO_THREAD</code> オプションをサポートしますが、<code class="literal">IO_THREAD</code> を一緒に使用しても現在は何の効果もありません。
      </p><p>
        たとえば、<code class="literal">START SLAVE SQL_THREAD UNTIL SQL_BEFORE_GTIDS = 3E11FA47-71CA-11E1-9E33-C80AA9429562:11-56</code> を指定すると、スレーブ SQL スレッドはシーケンス番号 11 を持つトランザクションを見つけるまで、<code class="literal">server_uuid</code> が <code class="literal">3E11FA47-71CA-11E1-9E33-C80AA9429562</code> であるマスターから発信されているすべてのトランザクションを処理したあと、このトランザクションを処理することなく停止します。つまり、シーケンス番号 10 を持つトランザクションまでのすべてのトランザクションが処理されます。これに対して、<code class="literal">START SLAVE SQL_THREAD UNTIL SQL_AFTER_GTIDS = 3E11FA47-71CA-11E1-9E33-C80AA9429562:11-56</code> を実行すると、スレーブ SQL スレッドは 11 から 56 までのシーケンス番号を持つすべてのトランザクションを含む、マスターから今指定されたすべてのトランザクションを取得したあと、追加のどのトランザクションも処理することなく停止します。つまり、シーケンス番号 56 を持つトランザクションは、スレーブ SQL スレッドによってフェッチされた最後のトランザクションになります。
      </p><p>
        MySQL 5.6.14 より前は、示されたトランザクションが完了しても <code class="literal">SQL_AFTER_GTIDS</code> はスレーブを停止せず、別の GTID イベントが受信されるまで待機しました (Bug #14767986)。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">SQL_BEFORE_GTIDS</code> および <code class="literal">SQL_AFTER_GTIDS</code> キーワードは MySQL 5.6.5 サーバー内に存在します。ただし、そのどちらのキーワードも、そのバージョンでは <code class="literal">START SLAVE [SQL_THREAD | IO_THREAD] UNTIL</code> のオプションとして正しく機能せず、サポートされたのは MySQL 5.6.6 からのみでした。(Bug#13810456)
        </p></div><p>
        <code class="literal">START SLAVE UNTIL SQL_AFTER_MTS_GAPS</code> は、MySQL 5.6.6 以降で使用できます。このステートメントを発行すると、マルチスレッドスレーブの SQL スレッドはリレーログ内にそれ以上ギャップが見つからなくなるまで実行してから、停止します。このステートメントは <code class="literal">SQL_THREAD</code> オプションを受け取ることができますが、ステートメントの効果は変更されないままです。スレーブ I/O スレッドには影響を与えません (また、<code class="literal">IO_THREAD</code> オプションとともに使用することはできません)。<code class="literal">START SLAVE UNTIL SQL_AFTER_MTS_GAPS</code> は、スレーブがマルチスレッドモードでエラーで失敗したあと、そのスレーブをマルチスレッドモードからシングルスレッドモードに切り替える前に (つまり、<code class="literal">slave_parallel_workers</code> を 0 以外の正の値から元の 0 にリセットするときに) 使用するようにしてください。
      </p><p>
        失敗したマルチスレッドスレーブをシングルスレッドモードに変更するには、次の一連のステートメントを示されている順序で発行できます。
      </p><pre class="programlisting">
START SLAVE UNTIL SQL_AFTER_MTS_GAPS;

SET @@GLOBAL.slave_parallel_workers = 0;

START SLAVE SQL_THREAD;
</pre><p>
        失敗したマルチスレッドスレーブを <code class="literal">relay_log_recovery</code> が有効になった状態で実行していた場合は、<code class="literal">START SLAVE UNTIL SQL_AFTER_MTS_GAPS</code> を発行してから <code class="literal">CHANGE MASTER TO</code> を実行する必要があります。そうしないと、後者のステートメントが失敗します。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          実行中の <code class="literal">START SLAVE ...</code> ステートメントのテキスト全体 (使用された <code class="literal">USER</code> または <code class="literal">PASSWORD</code> 値を含む) を <code class="literal">SHOW PROCESSLIST</code> の出力で表示できます。これはまた、実行中の <code class="literal">CHANGE MASTER TO</code> ステートメントのテキスト (<code class="literal">MASTER_USER</code> または <code class="literal">MASTER_PASSWORD</code> に使用されたすべての値を含む) にも当てはまります。
        </p></div><p>
        <code class="literal">START SLAVE</code> は、I/O スレッドと SQL スレッドの両方が開始されたあと、ユーザーに肯定応答を送信します。ただし、I/O スレッドはまだ接続していない可能性があります。このため、正常な <code class="literal">START SLAVE</code> により <code class="literal">SHOW SLAVE STATUS</code> は <code class="literal">Slave_SQL_Running=Yes</code> を示しますが、これによって <code class="literal">Slave_IO_Running=Yes</code> が保証されるわけではありません (<code class="literal">Slave_IO_Running=Yes</code> は I/O スレッドが実行中で<span class="emphasis"><em>かつ接続されている</em></span>場合だけであるため)。詳細は、<a class="xref" href="sql-syntax.html#show-slave-status" title="13.7.5.35 SHOW SLAVE STATUS 構文">セクション13.7.5.35「SHOW SLAVE STATUS 構文」</a>および<a class="xref" href="replication.html#replication-administration-status" title="17.1.5.1 レプリケーションステータスの確認">セクション17.1.5.1「レプリケーションステータスの確認」</a>を参照してください。
      </p><p>
        どちらのスレッドを開始するかを指定するために、このステートメントに <code class="literal">IO_THREAD</code> および <code class="literal">SQL_THREAD</code> オプションを追加できます。MySQL 5.6.4 以降では、<code class="literal">USER</code>、<code class="literal">PASSWORD</code>、<code class="literal">DEFAULT_AUTH</code>、<code class="literal">PLUGIN_DIR</code> のいずれかを指定するときは、<code class="literal">IO_THREAD</code> オプションも同時に指定されていないかぎり、<code class="literal">SQL_THREAD</code> オプションが許可されません (Bug #13083642)。
      </p><p>
        <code class="literal">UNTIL</code> 句 (前の文法では <em class="replaceable"><code>until_option</code></em>) を追加することにより、スレーブを起動し、SQL スレッドが <code class="literal">MASTER_LOG_POS</code> および MASTER_LOG_FILE オプションで指定されているマスターバイナリログ内の特定のポイント、または <code class="literal">RELAY_LOG_POS</code> および <code class="literal">RELAY_LOG_FILE</code> オプションで示されているスレーブリレーログ内の特定のポイントに達するまで実行するように指定できます。SQL スレッドは、指定されたポイントに達すると停止します。このステートメントで <code class="literal">SQL_THREAD</code> オプションが指定されている場合、このオプションは SQL スレッドのみを開始します。それ以外の場合は、両方のスレーブスレッドを開始します。SQL スレッドが実行中である場合、<code class="literal">UNTIL</code> 句は無視され、警告が発行されます。<code class="literal">UNTIL</code> 句を <code class="literal">IO_THREAD</code> オプションとともに使用することはできません。
      </p><p>
        MySQL 5.6.6 以降では、このセクションの前の方で説明されているように、オプション <code class="literal">SQL_BEFORE_GTIDS</code> または <code class="literal">SQL_AFTER_GTIDS</code> のいずれかを使用して、<code class="literal">START SLAVE UNTIL</code> で特定の GTID または GTID のセットを基準にした停止ポイントを指定することもできます。これらのオプションのいずれかを使用している場合は、<code class="literal">SQL_THREAD</code> または <code class="literal">IO_THREAD</code>、あるいはこれらの両方を指定できます。また、どちらも指定しないことも可能です。<code class="literal">SQL_THREAD</code> のみを指定した場合は、スレーブ SQL スレッドのみがこのステートメントの影響を受けます。<code class="literal">IO_THREAD</code> のみが使用された場合は、スレーブ I/O のみが影響を受けます。<code class="literal">SQL_THREAD</code> と <code class="literal">IO_THREAD</code> の両方が使用されている場合、またはそのどちらも使用されていない場合は、SQL スレッドと I/O スレッドの両方がこのステートメントの影響を受けます。
      </p><p>
        <code class="literal">UNTIL</code> 句は、<code class="literal">SQL_AFTER_MTS_GAPS</code> も同時に使用している場合を除き、マルチスレッドスレーブではサポートされません。MySQL 5.6.6 より前は、<code class="literal">UNTIL</code> はマルチスレッドスレーブではまったくサポートされていませんでした。
      </p><p>
        <code class="literal">UNTIL</code> 句では、次のいずれかを指定する必要があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            ログファイル名とそのファイル内の位置<span class="emphasis"><em>の両方</em></span>
          </p></li><li class="listitem"><p>
            (MySQL 5.6.6 以降:) <code class="literal">SQL_BEFORE_GTIDS</code> または <code class="literal">SQL_AFTER_GTIDS</code> の<span class="emphasis"><em>いずれか</em></span>
          </p></li><li class="listitem"><p>
            (MySQL 5.6.6 以降:) <code class="literal">SQL_AFTER_MTS_GAPS</code>
          </p></li></ul></div><p>
        マスターとリレーログのオプションを混在させないでください。MySQL 5.6.6 以降では、ログファイルのオプションを GTID オプションと混在させないでください。
      </p><p>
        <code class="literal">UNTIL</code> 条件は、以降の <code class="literal">STOP SLAVE</code> ステートメント、<code class="literal">UNTIL</code> 句を含まない <code class="literal">START SLAVE</code> ステートメント、またはサーバーの再起動によってすべてリセットされます。
      </p><p>
        ログファイルと位置を指定する場合は、SQL スレッドのみがこのステートメントの影響を受けるにもかかわらず、<code class="literal">START SLAVE ... UNTIL</code> で <code class="literal">IO_THREAD</code> オプションを使用できます。このような場合、<code class="literal">IO_THREAD</code> オプションは無視されます。前の制限は、MySQL 5.6.6 で導入された GTID オプション (<code class="literal">SQL_BEFORE_GTIDS</code> および <code class="literal">SQL_AFTER_GTIDS</code>) のいずれかを使用している場合は適用されません。このセクションの前の方で説明されているように、GTID オプションは <code class="literal">SQL_THREAD</code> と <code class="literal">IO_THREAD</code> の両方をサポートします。
      </p><p>
        <code class="literal">UNTIL</code> 句は、レプリケーションのデバッグや、あるイベントがスレーブによってレプリケートされないようにしたいポイントの直前までレプリケーションを続行させるために役立つ場合があります。たとえば、適切でない <code class="literal">DROP TABLE</code> ステートメントがマスター上で実行された場合は、<code class="literal">UNTIL</code> を使用して、スレーブにそのポイントの直前までしか実行しないよう指示できます。そのイベントがどのようなものかを見つけるには、マスターバイナリログまたはスレーブリレーログに対して <span class="command"><strong>mysqlbinlog</strong></span> を使用するか、または <code class="literal">SHOW BINLOG EVENTS</code> ステートメントを使用します。
      </p><p>
        セクション内でレプリケートされたクエリーをスレーブに処理させるために <code class="literal">UNTIL</code> を使用している場合は、スレーブサーバーが起動したときに SQL スレッドが実行されるのを回避するために、スレーブを <code class="option">--skip-slave-start</code> オプションで起動することをお勧めします。このオプションはおそらく、予期しないサーバーの再起動によって忘れてしまうことがないように、コマンド行ではなく、オプションファイルで使用することが最善です。
      </p><p>
        <code class="literal">SHOW SLAVE STATUS</code> ステートメントには、<code class="literal">UNTIL</code> 条件の現在の値を表示する出力フィールドが含まれています。
      </p><p>
        非常に古いバージョンの MySQL (4.0.5 より前) では、このステートメントは <code class="literal">SLAVE START</code> と呼ばれていました。その構文は、MySQL 5.6.1 の時点で受け入れられなくなりました。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="stop-slave"></a>13.4.2.6 STOP SLAVE 構文</h4></div></div></div><a class="indexterm" name="idm139979081409568"></a><pre class="programlisting">
STOP SLAVE [<em class="replaceable"><code>thread_types</code></em>]

<em class="replaceable"><code>thread_types</code></em>:
    [<em class="replaceable"><code>thread_type</code></em> [, <em class="replaceable"><code>thread_type</code></em>] ... ]

<em class="replaceable"><code>thread_type</code></em>: IO_THREAD | SQL_THREAD
</pre><p>
        スレーブスレッドを停止します。<code class="literal">STOP SLAVE</code> には、<code class="literal">SUPER</code> 権限が必要です。推奨されるベストプラクティスとして、スレーブサーバーを停止する前に、スレーブ上で <code class="literal">STOP SLAVE</code> を実行してください (詳細は、<a class="xref" href="server-administration.html#server-shutdown" title="5.1.12 シャットダウンプロセス">セクション5.1.12「シャットダウンプロセス」</a>を参照してください)。
      </p><p>
        <span class="emphasis"><em>行ベースのロギング形式を使用している場合</em></span>: 非トランザクションストレージエンジンを使用するいずれかのテーブルをレプリケートしている場合は、スレーブサーバーをシャットダウンする前にスレーブ上で <code class="literal">STOP SLAVE</code> または <code class="literal">STOP SLAVE SQL_THREAD</code> を実行するようにしてください (このセクションのあとの方にある「<em class="citetitle">注</em>」を参照してください)。
      </p><p>
        <code class="literal">START SLAVE</code> と同様に、このステートメントを <code class="literal">IO_THREAD</code> および <code class="literal">SQL_THREAD</code> オプションとともに使用すると、停止される 1 つまたは複数のスレッドを指定できます。
      </p><p>
        MySQL 5.6.7 以降では、<code class="literal">STOP SLAVE</code> によって進行中のトランザクションの暗黙的なコミットが発生します。<a class="xref" href="sql-syntax.html#implicit-commit" title="13.3.3 暗黙的なコミットを発生させるステートメント">セクション13.3.3「暗黙的なコミットを発生させるステートメント」</a>を参照してください。
      </p><p>
        MySQL 5.6.11 からは、このステートメントを発行する前に、<code class="literal">gtid_next</code> を <code class="literal">AUTOMATIC</code> に設定する必要があります (Bug #16062608)。
      </p><p>
        MySQL 5.6.13 以降では、<code class="literal">rpl_stop_slave_timeout</code> システム変数を設定することによって、タイムアウトまでに <code class="literal">STOP SLAVE</code> が待機する時間を制御できます。これは、<code class="literal">STOP SLAVE</code> ステートメントと、スレーブへのさまざまなクライアント接続を使用するほかのスレーブ SQL ステートメントとの間のデッドロックを回避するために使用できます。(Bug #16856735)
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          MySQL 5.6 では、<code class="literal">STOP SLAVE</code> は、1 つ以上の非トランザクションテーブルに影響を与えている現在のレプリケーションイベントグループが実行を完了する (このようなレプリケーショングループが存在する場合) か、あるいはユーザーが <code class="literal">KILL QUERY</code> または <code class="literal">KILL CONNECTION</code> ステートメントを発行するまで待機します。(Bug #319、Bug #38205)
        </p></div><p>
        古いバージョンの MySQL (4.0.5 より前) では、このステートメントは <code class="literal">SLAVE STOP</code> と呼ばれていました。その構文は、MySQL 5.6.1 の時点で受け入れられなくなりました。
      </p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sql-syntax-prepared-statements"></a>13.5 準備済みステートメントのための SQL 構文</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-syntax.html#prepare">13.5.1 PREPARE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#execute">13.5.2 EXECUTE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#deallocate-prepare">13.5.3 DEALLOCATE PREPARE 構文</a></span></dt></dl></div><a class="indexterm" name="idm139979081374992"></a><a class="indexterm" name="idm139979081373552"></a><a class="indexterm" name="idm139979081372320"></a><a class="indexterm" name="idm139979081370976"></a><p>
    MySQL 5.6 は、サーバー側の準備済みステートメントをサポートしています。このサポートでは、MySQL 4.1 から使用可能な、効率的なクライアント/サーバーのバイナリプロトコルを利用しています。パラメータ値のためのプレースホルダを含む準備済みステートメントの使用には、次の利点があります。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        ステートメントを実行のたびに解析するためのオーバーヘッドが少なくなります。通常、データベースアプリケーションは、クエリーや削除の場合の <code class="literal">WHERE</code>、更新の場合の <code class="literal">SET</code>、挿入の場合の <code class="literal">VALUES</code> などの句でリテラルまたは変数値しか変更されていない、ほぼ同一の大量のステートメントを処理します。
      </p></li><li class="listitem"><p>
        SQL インジェクション攻撃からの保護。パラメータ値には、エスケープされていない SQL 引用符および区切り文字を含めることができます。
      </p></li></ul></div><h3><a name="idm139979081363296"></a>アプリケーションプログラムでの準備済みステートメント</h3><p>
    サーバー側の準備済みステートメントは、C プログラムのための <a class="link" href="connectors-apis.html#c-api" title="23.8 MySQL C API">MySQL C API クライアントライブラリ</a>または <a class="ulink" href="http://dev.mysql.com/doc/connector-c/en/index.html" target="_top">MySQL Connector/C</a>、Java プログラムのための <a class="ulink" href="http://dev.mysql.com/doc/connector-j/en/index.html" target="_top">MySQL Connector/J</a>、.NET テクノロジを使用したプログラムのための <a class="ulink" href="http://dev.mysql.com/doc/connector-net/en/index.html" target="_top">MySQL Connector/Net</a> などのクライアントプログラミングインタフェース経由で使用できます。たとえば、C API は、その準備済みステートメント API を構成する一連の関数呼び出しを提供しています。<a class="xref" href="connectors-apis.html#c-api-prepared-statements" title="23.8.8 C API プリペアドステートメント">セクション23.8.8「C API プリペアドステートメント」</a>を参照してください。ほかの言語インタフェースは、C クライアントライブラリ内でリンクすることによって、バイナリプロトコルを使用する準備済みステートメントに対するサポートを提供できます。その 1 つの例が、PHP 5.0 以降で使用可能な <a class="ulink" href="http://php.net/mysqli" target="_top"><code class="literal">mysqli</code> 拡張機能</a>です。
  </p><h3><a name="idm139979081355504"></a>SQL スクリプトでの準備済みステートメント</h3><p>
    準備済みステートメントへの代替 SQL インタフェースを使用できます。このインタフェースは、準備済みステートメント API 経由でのバイナリプロトコルの使用ほど効率的ではありませんが、SQL レベルで直接使用できるためプログラミングが必要ありません。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        使用できるプログラミングインタフェースが存在しない場合でも使用できます。
      </p></li><li class="listitem"><p>
        <span class="command"><strong>mysql</strong></span> クライアントプログラムなどの、サーバーに SQL ステートメントを送信して実行させることのできる任意のプログラムから使用できます。
      </p></li><li class="listitem"><p>
        MySQL 4.1 以降を実行しているサーバーに接続しているかぎり、クライアントが古いバージョンのクライアントライブラリを使用している場合でも使用できます。
      </p></li></ul></div><p>
    準備済みステートメントのための SQL 構文は、次のような状況で使用されるように考慮されています。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        準備済みステートメントのコーディングの前に、それがアプリケーションでどのように動作するかをテストする場合。
      </p></li><li class="listitem"><p>
        サポートしているプログラミング API にアクセスできないときに準備済みステートメントを使用する場合。
      </p></li><li class="listitem"><p>
        準備済みステートメントに関するアプリケーションの問題を対話的にトラブルシューティングする場合。
      </p></li><li class="listitem"><p>
        バグレポートを提出できるように、準備済みステートメントに関する問題を再現するテストケースを作成する場合。
      </p></li></ul></div><h3><a name="idm139979081343584"></a>PREPARE、EXECUTE、および DEALLOCATE PREPARE ステートメント</h3><p>
    準備済みステートメントのための SQL 構文は、次の 3 つの SQL ステートメントに基づいています。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="literal">PREPARE</code> は、ステートメントを実行のために準備します (<a class="xref" href="sql-syntax.html#prepare" title="13.5.1 PREPARE 構文">セクション13.5.1「PREPARE 構文」</a>を参照してください)。
      </p></li><li class="listitem"><p>
        <code class="literal">EXECUTE</code> は、準備済みステートメントを実行します (<a class="xref" href="sql-syntax.html#execute" title="13.5.2 EXECUTE 構文">セクション13.5.2「EXECUTE 構文」</a>を参照してください)。
      </p></li><li class="listitem"><p>
        <code class="literal">DEALLOCATE PREPARE</code> は、準備済みステートメントを解放します (<a class="xref" href="sql-syntax.html#deallocate-prepare" title="13.5.3 DEALLOCATE PREPARE 構文">セクション13.5.3「DEALLOCATE PREPARE 構文」</a>を参照してください)。
      </p></li></ul></div><p>
    次の例は、2 辺の長さが与えられた三角形の斜辺を計算するステートメントを準備するための 2 つの同等の方法を示しています。
  </p><p>
    最初の例は、文字列リテラルを使用してステートメントのテキストを指定することによって準備済みステートメントを作成する方法を示しています。
  </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>PREPARE stmt1 FROM 'SELECT SQRT(POW(?,2) + POW(?,2)) AS hypotenuse';</code></strong>
mysql&gt; <strong class="userinput"><code>SET @a = 3;</code></strong>
mysql&gt; <strong class="userinput"><code>SET @b = 4;</code></strong>
mysql&gt; <strong class="userinput"><code>EXECUTE stmt1 USING @a, @b;</code></strong>
+------------+
| hypotenuse |
+------------+
|          5 |
+------------+
mysql&gt; <strong class="userinput"><code>DEALLOCATE PREPARE stmt1;</code></strong>
</pre><p>
    2 番目の例も同様ですが、ステートメントのテキストをユーザー変数として指定します。
  </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET @s = 'SELECT SQRT(POW(?,2) + POW(?,2)) AS hypotenuse';</code></strong>
mysql&gt; <strong class="userinput"><code>PREPARE stmt2 FROM @s;</code></strong>
mysql&gt; <strong class="userinput"><code>SET @a = 6;</code></strong>
mysql&gt; <strong class="userinput"><code>SET @b = 8;</code></strong>
mysql&gt; <strong class="userinput"><code>EXECUTE stmt2 USING @a, @b;</code></strong>
+------------+
| hypotenuse |
+------------+
|         10 |
+------------+
mysql&gt; <strong class="userinput"><code>DEALLOCATE PREPARE stmt2;</code></strong>
</pre><p>
    次の追加の例は、クエリーを実行する対象となるテーブルの名前をユーザー変数として格納することによって、実行時にそのテーブルを選択する方法を示しています。
  </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (a INT NOT NULL);</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t1 VALUES (4), (8), (11), (32), (80);</code></strong>

mysql&gt; <strong class="userinput"><code>SET @table = 't1';</code></strong>
mysql&gt; <strong class="userinput"><code>SET @s = CONCAT('SELECT * FROM ', @table);</code></strong>

mysql&gt; <strong class="userinput"><code>PREPARE stmt3 FROM @s;</code></strong>
mysql&gt; <strong class="userinput"><code>EXECUTE stmt3;</code></strong>
+----+
| a  |
+----+
|  4 |
|  8 |
| 11 |
| 32 |
| 80 |
+----+

mysql&gt; <strong class="userinput"><code>DEALLOCATE PREPARE stmt3;</code></strong>
</pre><p>
    準備済みステートメントは、そのステートメントが作成されたセッションに固有です。以前に作成された準備済みステートメントを解放せずにセッションを終了した場合、そのステートメントはサーバーによって自動的に解放されます。
  </p><p>
    準備済みステートメントはまた、セッションに対してグローバルでもあります。ストアドルーチン内で準備済みステートメントを作成した場合、そのステートメントはストアドルーチンが終了しても解放されません。
  </p><p>
    同時に作成される準備済みステートメントが多くなりすぎないようにするには、<code class="literal">max_prepared_stmt_count</code> システム変数を設定します。準備済みステートメントの使用を回避するには、この値を 0 に設定します。
  </p><h3><a name="idm139979081310368"></a>準備済みステートメント内で許可される SQL 構文</h3><p>
    次の SQL ステートメントは、準備済みステートメントとして使用できます。
  </p><pre class="programlisting">
ALTER TABLE
ALTER USER (as of MySQL 5.6.8)
ANALYZE TABLE
CACHE INDEX
CALL
CHANGE MASTER
CHECKSUM {TABLE | TABLES}
COMMIT
{CREATE | RENAME | DROP} DATABASE
{CREATE | DROP} INDEX
{CREATE | RENAME | DROP} TABLE
{CREATE | RENAME | DROP} USER
{CREATE | DROP} VIEW
DELETE
DO
FLUSH {TABLE | TABLES | TABLES WITH READ LOCK | HOSTS | PRIVILEGES
  | LOGS | STATUS | MASTER | SLAVE | DES_KEY_FILE | USER_RESOURCES}
GRANT
INSERT
INSTALL PLUGIN
KILL
LOAD INDEX INTO CACHE
OPTIMIZE TABLE
REPAIR TABLE
REPLACE
RESET {MASTER | SLAVE | QUERY CACHE}
REVOKE
SELECT
SET
SHOW {AUTHORS | CONTRIBUTORS | WARNINGS | ERRORS}
SHOW BINLOG EVENTS
SHOW CREATE {PROCEDURE | FUNCTION | EVENT | TABLE | VIEW}
SHOW {MASTER | BINARY} LOGS
SHOW {MASTER | SLAVE} STATUS
SLAVE {START | STOP}
TRUNCATE TABLE
UNINSTALL PLUGIN
UPDATE
</pre><p>
    その他のステートメントは、MySQL 5.6 ではサポートされていません。
  </p><p>
    通常、SQL 準備済みステートメントで許可されていないステートメントは、ストアドプログラムでも許可されません。例外については、<a class="xref" href="restrictions.html#stored-program-restrictions" title="D.1 ストアドプログラムの制約">セクションD.1「ストアドプログラムの制約」</a>に示されています。
  </p><p>
    プリペアドステートメントによって参照されているテーブルやビューのメタデータの変更が検出され、それが次に実行されるときに、ステートメントが自動再準備されます。詳細については、<a class="xref" href="optimization.html#statement-caching" title="8.9.4 プリペアドステートメントおよびストアドプログラムのキャッシュ">セクション8.9.4「プリペアドステートメントおよびストアドプログラムのキャッシュ」</a>を参照してください。
  </p><p>
    準備済みステートメントを使用する場合は、<code class="literal">LIMIT</code> 句の引数にプレースホルダを使用できます。<a class="xref" href="sql-syntax.html#select" title="13.2.9 SELECT 構文">セクション13.2.9「SELECT 構文」</a>を参照してください。
  </p><p>
    <code class="literal">PREPARE</code> および <code class="literal">EXECUTE</code> とともに使用される準備済み <code class="literal">CALL</code> ステートメントでは、<code class="literal">OUT</code> および <code class="literal">INOUT</code> パラメータに対するプレースホルダのサポートが MySQL 5.6 から使用できます。例および以前のバージョンでの回避方法については、<a class="xref" href="sql-syntax.html#call" title="13.2.1 CALL 構文">セクション13.2.1「CALL 構文」</a>を参照してください。<code class="literal">IN</code> パラメータには、バージョンには関係なくプレースホルダを使用できます。
  </p><p>
    準備済みステートメントのための SQL 構文は、ネストされた方法では使用できません。つまり、<code class="literal">PREPARE</code> に渡されるステートメント自体を、<code class="literal">PREPARE</code>、<code class="literal">EXECUTE</code>、または <code class="literal">DEALLOCATE PREPARE</code> ステートメントにすることはできません。
  </p><p>
    準備済みステートメントのための SQL 構文は、準備済みステートメント API 呼び出しの使用とは異なります。たとえば、<code class="literal">mysql_stmt_prepare()</code> C API 関数を使用して、<code class="literal">PREPARE</code>、<code class="literal">EXECUTE</code>、または <code class="literal">DEALLOCATE PREPARE</code> ステートメントを準備することはできません。
  </p><p>
    準備済みステートメントのための SQL 構文はストアドプロシージャー内で使用できますが、ストアドファンクションまたはトリガー内では使用できません。ただし、<code class="literal">PREPARE</code> と <code class="literal">EXECUTE</code> で準備および実行される動的なステートメントにはカーソルを使用できません。カーソルのステートメントはカーソル作成時にチェックされるため、そのステートメントを動的にすることはできません。
  </p><p>
    準備済みステートメントのための SQL 構文は、マルチステートメント (つまり、<span class="quote">「<span class="quote"><code class="literal">;</code></span>」</span>文字で区切られた 1 つの文字列内の複数のステートメント) をサポートしていません。
  </p><p>
    プリペアドステートメントは、<a class="xref" href="optimization.html#query-cache-operation" title="8.9.3.1 クエリーキャッシュの動作">セクション8.9.3.1「クエリーキャッシュの動作」</a>に説明する状況でクエリーキャッシュを使用します。
  </p><p>
    <code class="literal">CALL</code> SQL ステートメントを使用して、準備済みステートメントを含むストアドプロシージャーを実行する C プログラムを記述するには、<code class="literal">CLIENT_MULTI_RESULTS</code> フラグが有効になっている必要があります。これは、各 <code class="literal">CALL</code> によって、プロシージャー内で実行されるステートメントによって返される可能性のある結果セットに加えて、呼び出しステータスを示すための結果が返されるためです。
  </p><p>
    <code class="literal">CLIENT_MULTI_RESULTS</code> は、<code class="literal">mysql_real_connect()</code> を呼び出すときに、<code class="literal">CLIENT_MULTI_RESULTS</code> フラグ自体を渡すことによって明示的に、または <code class="literal">CLIENT_MULTI_STATEMENTS</code> を渡すことによって暗黙的に有効にする (これによって <code class="literal">CLIENT_MULTI_RESULTS</code> も有効になります) ことができます。詳細は、<a class="xref" href="sql-syntax.html#call" title="13.2.1 CALL 構文">セクション13.2.1「CALL 構文」</a>を参照してください。
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="prepare"></a>13.5.1 PREPARE 構文</h3></div></div></div><a class="indexterm" name="idm139979081268688"></a><a class="indexterm" name="idm139979081267232"></a><pre class="programlisting">
PREPARE <em class="replaceable"><code>stmt_name</code></em> FROM <em class="replaceable"><code>preparable_stmt</code></em>
</pre><p>
      <code class="literal">PREPARE</code> ステートメントは SQL ステートメントを準備し、それに名前 <em class="replaceable"><code>stmt_name</code></em> を割り当てます。この名前は、あとでそのステートメントを参照するために使用されます。この準備済みステートメントは <code class="literal">EXECUTE</code> で実行され、<code class="literal">DEALLOCATE PREPARE</code> で解放されます。例については、<a class="xref" href="sql-syntax.html#sql-syntax-prepared-statements" title="13.5 準備済みステートメントのための SQL 構文">セクション13.5「準備済みステートメントのための SQL 構文」</a>を参照してください。
    </p><p>
      ステートメント名は大文字と小文字が区別されません。<em class="replaceable"><code>preparable_stmt</code></em> は、SQL ステートメントのテキストを含む文字列リテラルまたはユーザー変数のどちらかです。このテキストは複数のステートメントではなく、1 つのステートメントを表している必要があります。このステートメント内では、<code class="literal">?</code> 文字を、あとでクエリーを実行するときに、そのクエリーのどこにデータ値をバインドするかを示すパラメータマーカーとして使用できます。文字列値にバインドしようとしている場合でも、<code class="literal">?</code> 文字を引用符で囲んではいけません。パラメータマーカーは、SQL キーワードや識別子などではなく、データ値を指定するべき場所にしか使用できません。
    </p><p>
      指定された名前を持つ準備済みステートメントがすでに存在する場合、そのステートメントは、新しいステートメントが準備される前に暗黙的に解放されます。つまり、新しいステートメントにエラーが含まれていて準備できない場合は、エラーが返され、指定された名前を持つステートメントは存在しなくなります。
    </p><p>
      準備済みステートメントのスコープは、そのステートメントが作成されたセッションです。これには、次のいくつかの注意点があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          あるセッションで作成された準備済みステートメントを別のセッションで使用することはできません。
        </p></li><li class="listitem"><p>
          セッションが (正常または異常にかかわらず) 終了すると、その準備済みステートメントは存在しなくなります。自動再接続が有効になっていると、クライアントには接続が失われたことが通知されません。このため、クライアントは自動再接続を無効にすることが必要になる場合があります。<a class="xref" href="connectors-apis.html#auto-reconnect" title="23.8.16 自動再接続動作の制御">セクション23.8.16「自動再接続動作の制御」</a>を参照してください。
        </p></li><li class="listitem"><p>
          ストアドプログラム内で作成された準備済みステートメントは、そのプログラムが実行を完了したあとも引き続き存在し、あとでそのプログラムの外部で実行できます。
        </p></li><li class="listitem"><p>
          ストアドプログラムのコンテキストで準備されたステートメントは、ストアドプロシージャーやストアドファンクションのパラメータまたはローカル変数を参照できません。これらは、そのプログラムが終了するとスコープから外れ、このステートメントがあとでプログラムの外部で実行されたときに使用できなくなるためです。回避方法として、代わりに、同様にセッションスコープを持つユーザー定義変数を参照します。<a class="xref" href="language-structure.html#user-variables" title="9.4 ユーザー定義変数">セクション9.4「ユーザー定義変数」</a>を参照してください。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="execute"></a>13.5.2 EXECUTE 構文</h3></div></div></div><a class="indexterm" name="idm139979081241824"></a><a class="indexterm" name="idm139979081240368"></a><pre class="programlisting">
EXECUTE <em class="replaceable"><code>stmt_name</code></em>
    [USING @<em class="replaceable"><code>var_name</code></em> [, @<em class="replaceable"><code>var_name</code></em>] ...]
</pre><p>
      <code class="literal">PREPARE</code> でステートメントを準備したあと、準備済みステートメント名を参照する <code class="literal">EXECUTE</code> ステートメントでそのステートメントを実行します。準備済みステートメントにパラメータマーカーが含まれている場合は、そのパラメータにバインドされる値を含むユーザー変数をリストした <code class="literal">USING</code> 句を指定する必要があります。パラメータ値はユーザー変数でのみ提供することができ、<code class="literal">USING</code> 句では、このステートメント内のパラメータマーカーの数とまったく同じ数の変数を指定する必要があります。
    </p><p>
      特定の準備済みステートメントを複数回実行できます。それには、各ステートメントに異なる変数を渡すか、または各実行の前にその変数を異なる値に設定します。
    </p><p>
      例については、<a class="xref" href="sql-syntax.html#sql-syntax-prepared-statements" title="13.5 準備済みステートメントのための SQL 構文">セクション13.5「準備済みステートメントのための SQL 構文」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="deallocate-prepare"></a>13.5.3 DEALLOCATE PREPARE 構文</h3></div></div></div><a class="indexterm" name="idm139979081225104"></a><a class="indexterm" name="idm139979081223648"></a><a class="indexterm" name="idm139979081222416"></a><pre class="programlisting">
{DEALLOCATE | DROP} PREPARE <em class="replaceable"><code>stmt_name</code></em>
</pre><p>
      <code class="literal">PREPARE</code> で生成された準備済みステートメントを解放するには、その準備済みステートメント名を参照する <code class="literal">DEALLOCATE PREPARE</code> ステートメントを使用します。準備済みステートメントを解放したあとにそのステートメントを実行しようとすると、エラーが発生します。多すぎる準備済みステートメントが作成され、<code class="literal">DEALLOCATE PREPARE</code> ステートメントまたはセッションの終了のどちらによっても解放されない場合は、<code class="literal">max_prepared_stmt_count</code> システム変数によって上限が適用されることがあります。
    </p><p>
      例については、<a class="xref" href="sql-syntax.html#sql-syntax-prepared-statements" title="13.5 準備済みステートメントのための SQL 構文">セクション13.5「準備済みステートメントのための SQL 構文」</a>を参照してください。
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sql-syntax-compound-statements"></a>13.6 MySQL 複合ステートメント構文</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-syntax.html#begin-end">13.6.1 BEGIN ... END 複合ステートメント構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#statement-labels">13.6.2 ステートメントラベルの構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#declare">13.6.3 DECLARE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#stored-program-variables">13.6.4 ストアドプログラム内の変数</a></span></dt><dt><span class="section"><a href="sql-syntax.html#flow-control-statements">13.6.5 フロー制御ステートメント</a></span></dt><dt><span class="section"><a href="sql-syntax.html#cursors">13.6.6 カーソル</a></span></dt><dt><span class="section"><a href="sql-syntax.html#condition-handling">13.6.7 条件の処理</a></span></dt></dl></div><a class="indexterm" name="idm139979081208448"></a><a class="indexterm" name="idm139979081207008"></a><a class="indexterm" name="idm139979081204976"></a><a class="indexterm" name="idm139979081203600"></a><p>
    このセクションでは、<code class="literal">BEGIN ... END</code> 複合ステートメントや、ストアドプログラム (ストアドプロシージャーとストアドファンクション、トリガー、およびイベント) の本体で使用できるその他のステートメントの構文について説明します。これらのオブジェクトは、あとで呼び出すためにサーバー上に格納されている SQL コードに対して定義されます (<a class="xref" href="stored-programs-views.html" title="第 20 章 ストアドプログラムおよびビュー">第20章「<i>ストアドプログラムおよびビュー</i>」</a>を参照してください)。
  </p><p>
    複合ステートメントとは、ほかのブロック、つまり、変数、条件ハンドラ、およびカーソルの宣言、ループや条件付きテストなどのフロー制御構造構文を含めることのできるブロックのことです。
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="begin-end"></a>13.6.1 BEGIN ... END 複合ステートメント構文</h3></div></div></div><a class="indexterm" name="idm139979081195712"></a><a class="indexterm" name="idm139979081194400"></a><pre class="programlisting">
[<em class="replaceable"><code>begin_label</code></em>:] BEGIN
    [<em class="replaceable"><code>statement_list</code></em>]
END [<em class="replaceable"><code>end_label</code></em>]
</pre><p>
      <code class="literal">BEGIN ... END</code> 構文は、ストアドプログラム (ストアドプロシージャーとストアドファンクション、トリガー、およびイベント) 内に指定できる複合ステートメントを記述するために使用されます。複合ステートメントには、<code class="literal">BEGIN</code> および <code class="literal">END</code> キーワードで囲まれた複数のステートメントを含めることができます。<em class="replaceable"><code>statement_list</code></em> は、それぞれがセミコロン (<code class="literal">;</code>) ステートメント区切り文字で終了する 1 つ以上のステートメントのリストを表します。<em class="replaceable"><code>statement_list</code></em> 自体がオプションであるため、空の複合ステートメント (<code class="literal">BEGIN END</code>) は正当です。
    </p><p>
      <code class="literal">BEGIN ... END</code> ブロックはネストできます。
    </p><p>
      複数のステートメントを使用するには、クライアントが <code class="literal">;</code> ステートメント区切り文字を含むステートメント文字列を送信できる必要があります。<span class="command"><strong>mysql</strong></span> コマンド行クライアントでは、これは <code class="literal">delimiter</code> コマンドで処理されます。ステートメント終了の区切り文字 <code class="literal">;</code> を (たとえば、<code class="literal">//</code> に) 変更すると、プログラム本体での <code class="literal">;</code> の使用が許可されます。例については、<a class="xref" href="stored-programs-views.html#stored-programs-defining" title="20.1 ストアドプログラムの定義">セクション20.1「ストアドプログラムの定義」</a>を参照してください。
    </p><p>
      <code class="literal">BEGIN ... END</code> ブロックにはラベルを付けることができます。<a class="xref" href="sql-syntax.html#statement-labels" title="13.6.2 ステートメントラベルの構文">セクション13.6.2「ステートメントラベルの構文」</a>を参照してください。
    </p><p>
      オプションの <code class="literal">[NOT] ATOMIC</code> 句はサポートされていません。つまり、この命令ブロックの先頭でトランザクションセーブポイントは設定されず、このコンテキストで使用されている <code class="literal">BEGIN</code> 句は現在のトランザクションに影響を与えません。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        すべてのストアドプログラム内で、パーサーは、<code class="literal">BEGIN [WORK]</code> を <code class="literal">BEGIN ... END</code> ブロックの開始として扱います。このコンテキストでトランザクションを開始するには、代わりに <code class="literal">START TRANSACTION</code> を使用します。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="statement-labels"></a>13.6.2 ステートメントラベルの構文</h3></div></div></div><a class="indexterm" name="idm139979081162256"></a><a class="indexterm" name="idm139979081160112"></a><a class="indexterm" name="idm139979081158080"></a><a class="indexterm" name="idm139979081156048"></a><a class="indexterm" name="idm139979081154016"></a><pre class="programlisting">
[<em class="replaceable"><code>begin_label</code></em>:] BEGIN
    [<em class="replaceable"><code>statement_list</code></em>]
END [<em class="replaceable"><code>end_label</code></em>]

[<em class="replaceable"><code>begin_label</code></em>:] LOOP
    <em class="replaceable"><code>statement_list</code></em>
END LOOP [<em class="replaceable"><code>end_label</code></em>]

[<em class="replaceable"><code>begin_label</code></em>:] REPEAT
    <em class="replaceable"><code>statement_list</code></em>
UNTIL <em class="replaceable"><code>search_condition</code></em>
END REPEAT [<em class="replaceable"><code>end_label</code></em>]

[<em class="replaceable"><code>begin_label</code></em>:] WHILE <em class="replaceable"><code>search_condition</code></em> DO
    <em class="replaceable"><code>statement_list</code></em>
END WHILE [<em class="replaceable"><code>end_label</code></em>]
</pre><p>
      <code class="literal">BEGIN ... END</code> ブロックや、<code class="literal">LOOP</code>、<code class="literal">REPEAT</code>、および <code class="literal">WHILE</code> ステートメントに対してラベルが許可されます。これらのステートメントに使用されるラベルは、次のルールに従います。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <em class="replaceable"><code>begin_label</code></em> のあとにコロンを付ける必要があります。
        </p></li><li class="listitem"><p>
          <em class="replaceable"><code>begin_label</code></em> は、<em class="replaceable"><code>end_label</code></em> なしでも指定できます。<em class="replaceable"><code>end_label</code></em> が存在する場合、それは <em class="replaceable"><code>begin_label</code></em> と同じである必要があります。
        </p></li><li class="listitem"><p>
          <em class="replaceable"><code>end_label</code></em> は、<em class="replaceable"><code>begin_label</code></em> なしでは指定できません。
        </p></li><li class="listitem"><p>
          同じネストレベルにあるラベルは異なっている必要があります。
        </p></li><li class="listitem"><p>
          ラベルは最大 16 文字の長さで指定できます。
        </p></li></ul></div><p>
      ラベルが付けられた構造構文内でラベルを参照するには、<code class="literal">ITERATE</code> または <code class="literal">LEAVE</code> ステートメントを使用します。次の例では、これらのステートメントを使用して繰り返しを続行するか、またはループを終了します。
    </p><pre class="programlisting">
CREATE PROCEDURE doiterate(p1 INT)
BEGIN
  label1: LOOP
    SET p1 = p1 + 1;
    IF p1 &lt; 10 THEN ITERATE label1; END IF;
    LEAVE label1;
  END LOOP label1;
END;
</pre><p>
      ブロックラベルのスコープには、そのブロック内で宣言されているハンドラのコードは含まれません。詳細は、<a class="xref" href="sql-syntax.html#declare-handler" title="13.6.7.2 DECLARE ... HANDLER 構文">セクション13.6.7.2「DECLARE ... HANDLER 構文」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="declare"></a>13.6.3 DECLARE 構文</h3></div></div></div><a class="indexterm" name="idm139979081123104"></a><p>
      <code class="literal">DECLARE</code> ステートメントは、プログラムにローカルな、次のさまざまな項目を定義するために使用されます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ローカル変数。<a class="xref" href="sql-syntax.html#stored-program-variables" title="13.6.4 ストアドプログラム内の変数">セクション13.6.4「ストアドプログラム内の変数」</a>を参照してください。
        </p></li><li class="listitem"><p>
          条件とハンドラ。<a class="xref" href="sql-syntax.html#condition-handling" title="13.6.7 条件の処理">セクション13.6.7「条件の処理」</a>を参照してください。
        </p></li><li class="listitem"><p>
          カーソル。<a class="xref" href="sql-syntax.html#cursors" title="13.6.6 カーソル">セクション13.6.6「カーソル」</a>を参照してください。
        </p></li></ul></div><p>
      <code class="literal">DECLARE</code> は、<code class="literal">BEGIN ... END</code> 複合ステートメントの内部でのみ許可され、ほかのどのステートメントよりも前の、その複合ステートメントの先頭に存在する必要があります。
    </p><p>
      宣言は、特定の順序に従う必要があります。カーソル宣言は、ハンドラ宣言の前に指定する必要があります。変数および条件宣言は、カーソルまたはハンドラ宣言の前に指定する必要があります。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="stored-program-variables"></a>13.6.4 ストアドプログラム内の変数</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-syntax.html#declare-local-variable">13.6.4.1 ローカル変数の DECLARE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#local-variable-scope">13.6.4.2 ローカル変数のスコープと解決</a></span></dt></dl></div><p>
      システム変数とユーザー定義変数は、ストアドプログラムのコンテキストの外部で使用できるのと同様に、ストアドプログラム内で使用できます。さらに、ストアドプログラムは <code class="literal">DECLARE</code> を使用してローカル変数を定義でき、またストアドルーチン (プロシージャーおよびファンクション) は、そのルーチンとその呼び出し元の間で値を通信するパラメータを受け取るように宣言できます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="xref" href="sql-syntax.html#declare-local-variable" title="13.6.4.1 ローカル変数の DECLARE 構文">セクション13.6.4.1「ローカル変数の DECLARE 構文」</a>で説明されているように、ローカル変数を宣言するには、<code class="literal">DECLARE</code> ステートメントを使用します。
        </p></li><li class="listitem"><p>
          変数は、<code class="literal">SET</code> ステートメントを使用して直接設定できます。<a class="xref" href="sql-syntax.html#set-statement" title="13.7.4 SET 構文">セクション13.7.4「SET 構文」</a>を参照してください。
        </p></li><li class="listitem"><p>
          クエリーからの結果は、<code class="literal">SELECT ... INTO <em class="replaceable"><code>var_list</code></em></code> を使用するか、またはカーソルを開き、<code class="literal">FETCH ... INTO <em class="replaceable"><code>var_list</code></em></code> を使用することによってローカル変数に取得できます。<a class="xref" href="sql-syntax.html#select-into" title="13.2.9.1 SELECT ... INTO 構文">セクション13.2.9.1「SELECT ... INTO 構文」</a>および<a class="xref" href="sql-syntax.html#cursors" title="13.6.6 カーソル">セクション13.6.6「カーソル」</a>を参照してください。
        </p></li></ul></div><p>
      ローカル変数のスコープ、および MySQL があいまいな名前を解決する方法については、<a class="xref" href="sql-syntax.html#local-variable-scope" title="13.6.4.2 ローカル変数のスコープと解決">セクション13.6.4.2「ローカル変数のスコープと解決」</a>を参照してください。
    </p><p>
      ストアドプロシージャーやストアドファンクションのパラメータまたはストアドプログラムのローカル変数に (たとえば、<code class="literal">SET <em class="replaceable"><code>var_name</code></em> = DEFAULT</code> ステートメントを使用して) 値 <code class="literal">DEFAULT</code> を割り当てることは許可されません。MySQL 5.6.6 の時点では、これは構文エラーになります。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="declare-local-variable"></a>13.6.4.1 ローカル変数の DECLARE 構文</h4></div></div></div><pre class="programlisting">
DECLARE <em class="replaceable"><code>var_name</code></em> [, <em class="replaceable"><code>var_name</code></em>] ... <em class="replaceable"><code>type</code></em> [DEFAULT <em class="replaceable"><code>value</code></em>]
</pre><p>
        このステートメントは、ストアドプログラム内のローカル変数を宣言します。変数のデフォルト値を指定するには、<code class="literal">DEFAULT</code> 句を含めます。この値は式として指定できます。定数である必要はありません。<code class="literal">DEFAULT</code> 句がない場合、初期値は <code class="literal">NULL</code> になります。
      </p><p>
        ローカル変数は、データ型やオーバーフローチェックに関して、ストアドルーチンパラメータと同様に処理されます。<a class="xref" href="sql-syntax.html#create-procedure" title="13.1.15 CREATE PROCEDURE および CREATE FUNCTION 構文">セクション13.1.15「CREATE PROCEDURE および CREATE FUNCTION 構文」</a>を参照してください。
      </p><p>
        変数宣言は、カーソルまたはハンドラ宣言の前に指定する必要があります。
      </p><p>
        ローカル変数名は大文字と小文字が区別されません。<a class="xref" href="language-structure.html#identifiers" title="9.2 スキーマオブジェクト名">セクション9.2「スキーマオブジェクト名」</a>で説明されているように、許可される文字や引用符のルールはほかの識別子の場合と同じです。
      </p><p>
        ローカル変数のスコープは、それが宣言されている <code class="literal">BEGIN ... END</code> ブロックです。この変数は、同じ名前を持つ変数を宣言しているブロックを除き、宣言しているブロック内でネストされたブロック内で参照できます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="local-variable-scope"></a>13.6.4.2 ローカル変数のスコープと解決</h4></div></div></div><p>
        ローカル変数のスコープは、それが宣言されている <code class="literal">BEGIN ... END</code> ブロックです。この変数は、同じ名前を持つ変数を宣言しているブロックを除き、宣言しているブロック内でネストされたブロック内で参照できます。
      </p><p>
        ローカル変数はストアドプログラムの実行中にのみスコープ内にあるので、これらの参照は、ストアドプログラム内で作成された準備済みステートメントでは許可されていません。準備済みステートメントのスコープは現在のセッションであり、ストアドプログラムではないので、ステートメントはプログラムの終了後に実行でき、この時点で変数はスコープ内に存在しなくなります。たとえば、<code class="literal">SELECT ... INTO <em class="replaceable"><code>local_var</code></em></code> は準備済みステートメントとして使用できません。この制約は、ストアドプロシージャーおよびストアドファンクションのパラメータにも適用されます。<a class="xref" href="sql-syntax.html#prepare" title="13.5.1 PREPARE 構文">セクション13.5.1「PREPARE 構文」</a>を参照してください。
      </p><p>
        ローカル変数にテーブルカラムと同じ名前を付けてはいけません。<code class="literal">SELECT ... INTO</code> ステートメントなどの SQL ステートメントに、カラムおよび同じ名前を持つ宣言されたローカル変数への参照が含まれている場合、MySQL は現在、その参照を変数の名前として解釈します。次のプロシージャー定義を考えてみます。
      </p><pre class="programlisting">
CREATE PROCEDURE sp1 (x VARCHAR(5))
BEGIN
  DECLARE xname VARCHAR(5) DEFAULT 'bob';
  DECLARE newname VARCHAR(5);
  DECLARE xid INT;

  SELECT xname, id INTO newname, xid
    FROM table1 WHERE xname = xname;
  SELECT newname;
END;
</pre><p>
        MySQL は、<code class="literal">SELECT</code> ステートメント内の <code class="literal">xname</code> を、<code class="literal">xname</code> <span class="emphasis"><em>カラム</em></span>ではなく <code class="literal">xname</code> <span class="emphasis"><em>変数</em></span>への参照として解釈します。その結果、プロシージャー <code class="literal">sp1()</code> が呼び出されると、<code class="literal">table1.xname</code> カラムの値には関係なく、<code class="literal">newname</code> 変数は値 <code class="literal">'bob'</code> を返します。
      </p><p>
        同様に、次のプロシージャー内のカーソル定義には、<code class="literal">xname</code> を参照する <code class="literal">SELECT</code> ステートメントが含まれています。MySQL はこれをカラム参照ではなく、その名前の変数への参照として解釈します。
      </p><pre class="programlisting">
CREATE PROCEDURE sp2 (x VARCHAR(5))
BEGIN
  DECLARE xname VARCHAR(5) DEFAULT 'bob';
  DECLARE newname VARCHAR(5);
  DECLARE xid INT;
  DECLARE done TINYINT DEFAULT 0;
  DECLARE cur1 CURSOR FOR SELECT xname, id FROM table1;
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

  OPEN cur1;
  read_loop: LOOP
    FETCH FROM cur1 INTO newname, xid;
    IF done THEN LEAVE read_loop; END IF;
    SELECT newname;
  END LOOP;
  CLOSE cur1;
END;
</pre><p>
        <a class="xref" href="restrictions.html#stored-program-restrictions" title="D.1 ストアドプログラムの制約">セクションD.1「ストアドプログラムの制約」</a>も参照してください。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="flow-control-statements"></a>13.6.5 フロー制御ステートメント</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-syntax.html#case">13.6.5.1 CASE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#if">13.6.5.2 IF 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#iterate">13.6.5.3 ITERATE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#leave">13.6.5.4 LEAVE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#loop">13.6.5.5 LOOP 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#repeat">13.6.5.6 REPEAT 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#return">13.6.5.7 RETURN 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#while">13.6.5.8 WHILE 構文</a></span></dt></dl></div><p>
      MySQL は、ストアドプログラム内のフロー制御のために、<code class="literal">IF</code>、<code class="literal">CASE</code>、<code class="literal">ITERATE</code>、<code class="literal">LEAVE</code> <code class="literal">LOOP</code>、<code class="literal">WHILE</code>、および <code class="literal">REPEAT</code> 構造構文をサポートしています。また、ストアドファンクション内の <code class="literal">RETURN</code> もサポートしています。
    </p><p>
      これらの構造構文の多くには、次の各セクションの文法仕様に示されているその他のステートメントが含まれています。このような構造構文はネストできます。たとえば、<code class="literal">IF</code> ステートメントには、それ自体に <code class="literal">CASE</code> ステートメントを含む <code class="literal">WHILE</code> ループが含まれている可能性があります。
    </p><p>
      MySQL は、<code class="literal">FOR</code> ループをサポートしていません。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="case"></a>13.6.5.1 CASE 構文</h4></div></div></div><a class="indexterm" name="idm139979081036992"></a><pre class="programlisting">
CASE <em class="replaceable"><code>case_value</code></em>
    WHEN <em class="replaceable"><code>when_value</code></em> THEN <em class="replaceable"><code>statement_list</code></em>
    [WHEN <em class="replaceable"><code>when_value</code></em> THEN <em class="replaceable"><code>statement_list</code></em>] ...
    [ELSE <em class="replaceable"><code>statement_list</code></em>]
END CASE
</pre><p>
        または:
      </p><pre class="programlisting">
CASE
    WHEN <em class="replaceable"><code>search_condition</code></em> THEN <em class="replaceable"><code>statement_list</code></em>
    [WHEN <em class="replaceable"><code>search_condition</code></em> THEN <em class="replaceable"><code>statement_list</code></em>] ...
    [ELSE <em class="replaceable"><code>statement_list</code></em>]
END CASE
</pre><p>
        ストアドプログラムの <code class="literal">CASE</code> ステートメントは、複雑な条件構造構文を実装します。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          ここで説明されている <code class="literal">CASE</code> <span class="emphasis"><em>ステートメント</em></span>とは異なる <code class="literal">CASE</code> <span class="emphasis"><em>式</em></span>も存在します。<a class="xref" href="functions.html#control-flow-functions" title="12.4 制御フロー関数">セクション12.4「制御フロー関数」</a>を参照してください。<code class="literal">CASE</code> ステートメントは <code class="literal">ELSE NULL</code> 句を持つことができず、<code class="literal">END</code> でなく、<code class="literal">END CASE</code> で終了します。
        </p></div><p>
        最初の構文の場合、<em class="replaceable"><code>case_value</code></em> は式です。この値は、各 <code class="literal">WHEN</code> 句内の <em class="replaceable"><code>when_value</code></em> 式のいずれかに等しくなるまで、それらの式と比較されます。等しい <em class="replaceable"><code>when_value</code></em> が見つかると、対応する <code class="literal">THEN</code> 句の <em class="replaceable"><code>statement_list</code></em> が実行されます。どの <em class="replaceable"><code>when_value</code></em> も等しくない場合は、<code class="literal">ELSE</code> 句の <em class="replaceable"><code>statement_list</code></em> が実行されます (この句が存在する場合)。
      </p><p>
        <code class="literal">NULL = NULL</code> は false であるため、この構文を <code class="literal">NULL</code> と等しいかどうかのテストに使用することはできません。<a class="xref" href="tutorial.html#working-with-null" title="3.3.4.6 NULL 値の操作">セクション3.3.4.6「NULL 値の操作」</a>を参照してください。
      </p><p>
        2 番目の構文の場合、各 <code class="literal">WHEN</code> 句の <em class="replaceable"><code>search_condition</code></em> 式のいずれかが true になるまでそれらの式が評価され、いずれかが true になった時点で、それに対応する <code class="literal">THEN</code> 句の <em class="replaceable"><code>statement_list</code></em> が実行されます。どの <em class="replaceable"><code>search_condition</code></em> も等しくない場合は、<code class="literal">ELSE</code> 句の <em class="replaceable"><code>statement_list</code></em> が実行されます (この句が存在する場合)。
      </p><p>
        どの <em class="replaceable"><code>when_value</code></em> も <em class="replaceable"><code>search_condition</code></em> もテストされた値に一致せず、かつ <code class="literal">CASE</code> ステートメントに <code class="literal">ELSE</code> 句が含まれていない場合は、<span class="errortext">Case not found for CASE statement</span> エラーになります。
      </p><p>
        各 <em class="replaceable"><code>statement_list</code></em> は、1 つ以上の SQL ステートメントで構成されます。空の <em class="replaceable"><code>statement_list</code></em> は許可されません。
      </p><p>
        どの <code class="literal">WHEN</code> 句でも値が一致しない状況を処理するには、次の例に示すように、空の <code class="literal">BEGIN ... END</code> ブロックを含む <code class="literal">ELSE</code> を使用します。(ここの <code class="literal">ELSE</code> 句で使用されているインデントは透明性のみを目的にしており、それ以外の意味はありません。) 
      </p><pre class="programlisting">
DELIMITER |

CREATE PROCEDURE p()
  BEGIN
    DECLARE v INT DEFAULT 1;

    CASE v
      WHEN 2 THEN SELECT v;
      WHEN 3 THEN SELECT 0;
      ELSE
        BEGIN
        END;
    END CASE;
  END;
  |
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="if"></a>13.6.5.2 IF 構文</h4></div></div></div><a class="indexterm" name="idm139979080990912"></a><pre class="programlisting">
IF <em class="replaceable"><code>search_condition</code></em> THEN <em class="replaceable"><code>statement_list</code></em>
    [ELSEIF <em class="replaceable"><code>search_condition</code></em> THEN <em class="replaceable"><code>statement_list</code></em>] ...
    [ELSE <em class="replaceable"><code>statement_list</code></em>]
END IF
</pre><p>
        ストアドプログラムの <code class="literal">IF</code> ステートメントは、基本的な条件構造構文を実装します。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          ここで説明されている <code class="literal">IF</code> <span class="emphasis"><em>ステートメント</em></span>とは異なる <code class="literal">IF()</code> <span class="emphasis"><em>関数</em></span>も存在します。<a class="xref" href="functions.html#control-flow-functions" title="12.4 制御フロー関数">セクション12.4「制御フロー関数」</a>を参照してください。<code class="literal">IF</code> ステートメントは <code class="literal">THEN</code>、<code class="literal">ELSE</code>、および <code class="literal">ELSEIF</code> 句を含むことができ、<code class="literal">END IF</code> で終了します。
        </p></div><p>
        <em class="replaceable"><code>search_condition</code></em> が true に評価された場合は、対応する <code class="literal">THEN</code> または <code class="literal">ELSEIF</code> 句の <em class="replaceable"><code>statement_list</code></em> が実行されます。どの <em class="replaceable"><code>search_condition</code></em> も一致しない場合は、<code class="literal">ELSE</code> 句の <em class="replaceable"><code>statement_list</code></em> が実行されます。
      </p><p>
        各 <em class="replaceable"><code>statement_list</code></em> は、1 つ以上の SQL ステートメントで構成されます。空の <em class="replaceable"><code>statement_list</code></em> は許可されません。
      </p><p>
        <code class="literal">IF ... END IF</code> ブロックは、次の例に示すように、ストアドプログラム内で使用されるその他のすべてのフロー制御ブロックと同様にセミコロンで終了する必要があります。
      </p><pre class="programlisting">
DELIMITER //

CREATE FUNCTION SimpleCompare(n INT, m INT)
  RETURNS VARCHAR(20)

  BEGIN
    DECLARE s VARCHAR(20);

    IF n &gt; m THEN SET s = '&gt;';
    ELSEIF n = m THEN SET s = '=';
    ELSE SET s = '&lt;';
    END IF;

    SET s = CONCAT(n, ' ', s, ' ', m);

    RETURN s;
  END //

DELIMITER ;
</pre><p>
        ほかのフロー制御構造構文と同様に、<code class="literal">IF ... END IF</code> ブロックは、ほかのフロー制御構造構文 (ほかの <code class="literal">IF</code> ステートメントを含む) 内にネストできます。各 <code class="literal">IF</code> は、独自の <code class="literal">END IF</code> とそれに続くセミコロンで終了する必要があります。次に示すように、インデントを使用して、ネストされたフロー制御ブロックを人間が読みやすくすることができます (ただし、これが MySQL に必要なわけではありません)。
      </p><pre class="programlisting">
DELIMITER //

CREATE FUNCTION VerboseCompare (n INT, m INT)
  RETURNS VARCHAR(50)

  BEGIN
    DECLARE s VARCHAR(50);

    IF n = m THEN SET s = 'equals';
    ELSE
      IF n &gt; m THEN SET s = 'greater';
      ELSE SET s = 'less';
      END IF;

      SET s = CONCAT('is ', s, ' than');
    END IF;

    SET s = CONCAT(n, ' ', s, ' ', m, '.');

    RETURN s;
  END //

DELIMITER ;
</pre><p>
        この例では、内側の <code class="literal">IF</code> は <code class="literal">n</code> が <code class="literal">m</code> に等しくない場合にのみ評価されます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="iterate"></a>13.6.5.3 ITERATE 構文</h4></div></div></div><a class="indexterm" name="idm139979080954000"></a><pre class="programlisting">
ITERATE <em class="replaceable"><code>label</code></em>
</pre><p>
        <code class="literal">ITERATE</code> は、<code class="literal">LOOP</code>、<code class="literal">REPEAT</code>、および <code class="literal">WHILE</code> ステートメント内にのみ指定できます。<code class="literal">ITERATE</code> は、<span class="quote">「<span class="quote">ループをふたたび開始する</span>」</span>ことを示します。
      </p><p>
        例については、<a class="xref" href="sql-syntax.html#loop" title="13.6.5.5 LOOP 構文">セクション13.6.5.5「LOOP 構文」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="leave"></a>13.6.5.4 LEAVE 構文</h4></div></div></div><a class="indexterm" name="idm139979080939936"></a><pre class="programlisting">
LEAVE <em class="replaceable"><code>label</code></em>
</pre><p>
        このステートメントは、特定のラベルを持つフロー制御構造構文を終了するために使用されます。そのラベルがもっとも外側のストアドプログラムブロックのものである場合、<code class="literal">LEAVE</code> はプログラムを終了します。
      </p><p>
        <code class="literal">LEAVE</code> は、<code class="literal">BEGIN ... END</code> またはループ構造構文 (<code class="literal">LOOP</code>、<code class="literal">REPEAT</code>、<code class="literal">WHILE</code>) 内で使用できます。
      </p><p>
        例については、<a class="xref" href="sql-syntax.html#loop" title="13.6.5.5 LOOP 構文">セクション13.6.5.5「LOOP 構文」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="loop"></a>13.6.5.5 LOOP 構文</h4></div></div></div><a class="indexterm" name="idm139979080924432"></a><pre class="programlisting">
[<em class="replaceable"><code>begin_label</code></em>:] LOOP
    <em class="replaceable"><code>statement_list</code></em>
END LOOP [<em class="replaceable"><code>end_label</code></em>]
</pre><p>
        <code class="literal">LOOP</code> は単純なループ構造構文を実装し、それぞれがセミコロン (<code class="literal">;</code>) ステートメント区切り文字で終了する 1 つ以上のステートメントで構成されたステートメントリストの繰り返し実行を可能にします。ループ内の各ステートメントは、そのループが終了するまで繰り返されます。通常、これは <code class="literal">LEAVE</code> ステートメントで実行されます。ストアドファンクション内では、<code class="literal">RETURN</code> も使用できます。これにより、そのストアドファンクションが完全に終了します。
      </p><p>
        ループ終了ステートメントが含まれていない場合は、無限ループが発生します。
      </p><p>
        <code class="literal">LOOP</code> ステートメントにはラベルを付けることができます。ラベルの使用に関連したルールについては、<a class="xref" href="sql-syntax.html#statement-labels" title="13.6.2 ステートメントラベルの構文">セクション13.6.2「ステートメントラベルの構文」</a>を参照してください。
      </p><p>
        例:
      </p><pre class="programlisting">
CREATE PROCEDURE doiterate(p1 INT)
BEGIN
  label1: LOOP
    SET p1 = p1 + 1;
    IF p1 &lt; 10 THEN
      ITERATE label1;
    END IF;
    LEAVE label1;
  END LOOP label1;
  SET @x = p1;
END;
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="repeat"></a>13.6.5.6 REPEAT 構文</h4></div></div></div><a class="indexterm" name="idm139979080905888"></a><a class="indexterm" name="idm139979080904576"></a><pre class="programlisting">
[<em class="replaceable"><code>begin_label</code></em>:] REPEAT
    <em class="replaceable"><code>statement_list</code></em>
UNTIL <em class="replaceable"><code>search_condition</code></em>
END REPEAT [<em class="replaceable"><code>end_label</code></em>]
</pre><p>
        <code class="literal">REPEAT</code> ステートメント内のステートメントリストは、<em class="replaceable"><code>search_condition</code></em> 式が true になるまで繰り返されます。そのため、<code class="literal">REPEAT</code> は常に、少なくとも 1 回はループに入ります。<em class="replaceable"><code>statement_list</code></em> は、それぞれがセミコロン (<code class="literal">;</code>) ステートメント区切り文字で終了する 1 つ以上のステートメントで構成されます。
      </p><p>
        <code class="literal">REPEAT</code> ステートメントにはラベルを付けることができます。ラベルの使用に関連したルールについては、<a class="xref" href="sql-syntax.html#statement-labels" title="13.6.2 ステートメントラベルの構文">セクション13.6.2「ステートメントラベルの構文」</a>を参照してください。
      </p><p>
        例:
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>delimiter //</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE PROCEDURE dorepeat(p1 INT)</code></strong>
    -&gt; <strong class="userinput"><code>BEGIN</code></strong>
    -&gt;   <strong class="userinput"><code>SET @x = 0;</code></strong>
    -&gt;   <strong class="userinput"><code>REPEAT</code></strong>
    -&gt;     <strong class="userinput"><code>SET @x = @x + 1;</code></strong>
    -&gt;   <strong class="userinput"><code>UNTIL @x &gt; p1 END REPEAT;</code></strong>
    -&gt; <strong class="userinput"><code>END</code></strong>
    -&gt; <strong class="userinput"><code>//</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>CALL dorepeat(1000)//</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT @x//</code></strong>
+------+
| @x   |
+------+
| 1001 |
+------+
1 row in set (0.00 sec)
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="return"></a>13.6.5.7 RETURN 構文</h4></div></div></div><a class="indexterm" name="idm139979080879232"></a><pre class="programlisting">
RETURN <em class="replaceable"><code>expr</code></em>
</pre><p>
        <code class="literal">RETURN</code> ステートメントはストアドファンクションの実行を終了し、そのストアドファンクションの呼び出し元に値 <em class="replaceable"><code>expr</code></em> を返します。ストアドファンクション内には、少なくとも 1 つの <code class="literal">RETURN</code> ステートメントが存在する必要があります。そのストアドファンクションに複数の終了ポイントがある場合は、複数存在してもかまいません。
      </p><p>
        このステートメントは、ストアドプロシージャー、トリガー、またはイベントでは使用されません。<code class="literal">LEAVE</code> ステートメントを使用すると、これらのタイプのストアドプログラムを終了できます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="while"></a>13.6.5.8 WHILE 構文</h4></div></div></div><a class="indexterm" name="idm139979080866864"></a><pre class="programlisting">
[<em class="replaceable"><code>begin_label</code></em>:] WHILE <em class="replaceable"><code>search_condition</code></em> DO
    <em class="replaceable"><code>statement_list</code></em>
END WHILE [<em class="replaceable"><code>end_label</code></em>]
</pre><p>
        <code class="literal">WHILE</code> ステートメント内のステートメントリストは、<em class="replaceable"><code>search_condition</code></em> 式が true であるかぎり繰り返されます。<em class="replaceable"><code>statement_list</code></em> は、それぞれがセミコロン (<code class="literal">;</code>) ステートメント区切り文字で終了する 1 つ以上の SQL ステートメントで構成されます。
      </p><p>
        <code class="literal">WHILE</code> ステートメントにはラベルを付けることができます。ラベルの使用に関連したルールについては、<a class="xref" href="sql-syntax.html#statement-labels" title="13.6.2 ステートメントラベルの構文">セクション13.6.2「ステートメントラベルの構文」</a>を参照してください。
      </p><p>
        例:
      </p><pre class="programlisting">
CREATE PROCEDURE dowhile()
BEGIN
  DECLARE v1 INT DEFAULT 5;

  WHILE v1 &gt; 0 DO
    ...
    SET v1 = v1 - 1;
  END WHILE;
END;
</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="cursors"></a>13.6.6 カーソル</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-syntax.html#close">13.6.6.1 カーソルの CLOSE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#declare-cursor">13.6.6.2 カーソルの DECLARE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#fetch">13.6.6.3 カーソルの FETCH 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#open">13.6.6.4 カーソルの OPEN 構文</a></span></dt></dl></div><a class="indexterm" name="idm139979080850640"></a><p>
      MySQL は、ストアドプログラム内部のカーソルをサポートします。その構文は、組み込み SQL の場合と同様です。カーソルには次のプロパティーがあります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          Asensitive: サーバーは、結果テーブルのコピーを作成する場合としない場合があります
        </p></li><li class="listitem"><p>
          読み取り専用: 更新できません
        </p></li><li class="listitem"><p>
          スクロール不可: 1 方向にしかトラバースできず、行をスキップできません
        </p></li></ul></div><p>
      カーソル宣言は、ハンドラ宣言の前で、かつ変数および条件宣言のあとに指定する必要があります。
    </p><p>
      例:
    </p><pre class="programlisting">
CREATE PROCEDURE curdemo()
BEGIN
  DECLARE done INT DEFAULT FALSE;
  DECLARE a CHAR(16);
  DECLARE b, c INT;
  DECLARE cur1 CURSOR FOR SELECT id,data FROM test.t1;
  DECLARE cur2 CURSOR FOR SELECT i FROM test.t2;
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

  OPEN cur1;
  OPEN cur2;

  read_loop: LOOP
    FETCH cur1 INTO a, b;
    FETCH cur2 INTO c;
    IF done THEN
      LEAVE read_loop;
    END IF;
    IF b &lt; c THEN
      INSERT INTO test.t3 VALUES (a,b);
    ELSE
      INSERT INTO test.t3 VALUES (a,c);
    END IF;
  END LOOP;

  CLOSE cur1;
  CLOSE cur2;
END;
</pre><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="close"></a>13.6.6.1 カーソルの CLOSE 構文</h4></div></div></div><a class="indexterm" name="idm139979080841216"></a><pre class="programlisting">
CLOSE <em class="replaceable"><code>cursor_name</code></em>
</pre><p>
        このステートメントは、以前に開かれたカーソルを閉じます。例については、<a class="xref" href="sql-syntax.html#cursors" title="13.6.6 カーソル">セクション13.6.6「カーソル」</a>を参照してください。
      </p><p>
        カーソルが開いていない場合は、エラーが発生します。
      </p><p>
        明示的に閉じられない場合は、そのカーソルが宣言された <code class="literal">BEGIN ... END</code> ブロックの最後に閉じられます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="declare-cursor"></a>13.6.6.2 カーソルの DECLARE 構文</h4></div></div></div><pre class="programlisting">
DECLARE <em class="replaceable"><code>cursor_name</code></em> CURSOR FOR <em class="replaceable"><code>select_statement</code></em>
</pre><p>
        このステートメントはカーソルを宣言し、そのカーソルによってトラバースされる行を取得する <code class="literal">SELECT</code> ステートメントに関連付けます。行をあとでフェッチするには、<code class="literal">FETCH</code> ステートメントを使用します。<code class="literal">SELECT</code> ステートメントによって取得されるカラムの数が、<code class="literal">FETCH</code> ステートメントで指定された出力変数の数に一致している必要があります。
      </p><p>
        <code class="literal">SELECT</code> ステートメントに <code class="literal">INTO</code> 句を含めることはできません。
      </p><p>
        カーソル宣言は、ハンドラ宣言の前で、かつ変数および条件宣言のあとに指定する必要があります。
      </p><p>
        ストアドプログラムには複数のカーソル宣言を含めることができますが、特定のブロック内で宣言された各カーソルが一意の名前を持っている必要があります。例については、<a class="xref" href="sql-syntax.html#cursors" title="13.6.6 カーソル">セクション13.6.6「カーソル」</a>を参照してください。
      </p><p>
        <code class="literal">SHOW</code> ステートメントで入手できる情報については、多くの場合、<code class="literal">INFORMATION_SCHEMA</code> テーブルでカーソルを使用することによって同等の情報を取得できます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="fetch"></a>13.6.6.3 カーソルの FETCH 構文</h4></div></div></div><a class="indexterm" name="idm139979080812512"></a><pre class="programlisting">
FETCH [[NEXT] FROM] <em class="replaceable"><code>cursor_name</code></em> INTO <em class="replaceable"><code>var_name</code></em> [, <em class="replaceable"><code>var_name</code></em>] ...
</pre><p>
        このステートメントは、指定されたカーソル (これは開いている必要があります) に関連付けられた <code class="literal">SELECT</code> ステートメントの次の行をフェッチし、そのカーソルのポインタを進めます。行が存在する場合は、フェッチされたカラムが指定された変数に格納されます。<code class="literal">SELECT</code> ステートメントによって取得されるカラムの数が、<code class="literal">FETCH</code> ステートメントで指定された出力変数の数に一致している必要があります。
      </p><p>
        それ以上の行を取得できない場合は、SQLSTATE 値 <code class="literal">'02000'</code> で「データなし」状況が発生します。この状況を検出するには、その状況 (または、<code class="literal">NOT FOUND</code> 状況) のハンドラを設定できます。例については、<a class="xref" href="sql-syntax.html#cursors" title="13.6.6 カーソル">セクション13.6.6「カーソル」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="open"></a>13.6.6.4 カーソルの OPEN 構文</h4></div></div></div><a class="indexterm" name="idm139979080797344"></a><pre class="programlisting">
OPEN <em class="replaceable"><code>cursor_name</code></em>
</pre><p>
        このステートメントは、以前に宣言されたカーソルを開きます。例については、<a class="xref" href="sql-syntax.html#cursors" title="13.6.6 カーソル">セクション13.6.6「カーソル」</a>を参照してください。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="condition-handling"></a>13.6.7 条件の処理</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-syntax.html#declare-condition">13.6.7.1 DECLARE ... CONDITION 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#declare-handler">13.6.7.2 DECLARE ... HANDLER 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#get-diagnostics">13.6.7.3 GET DIAGNOSTICS 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#resignal">13.6.7.4 RESIGNAL 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#signal">13.6.7.5 SIGNAL 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#handler-scope">13.6.7.6 ハンドラのスコープに関するルール</a></span></dt><dt><span class="section"><a href="sql-syntax.html#diagnostics-area">13.6.7.7 MySQL の診断領域</a></span></dt></dl></div><p>
      条件は、現在のプログラムブロックの終了や実行の続行などの、特殊な処理が必要なストアドプログラムの実行中に発生する可能性があります。警告や例外などの一般的な条件、または特定のエラーコードなどの具体的な条件に対してハンドラを定義できます。具体的な条件には名前を割り当てることができるため、ハンドラではその名前で参照できます。
    </p><p>
      条件に名前を付けるには、<code class="literal">DECLARE ... CONDITION</code> ステートメントを使用します。ハンドラを宣言するには、<code class="literal">DECLARE ... HANDLER</code> ステートメントを使用します。<a class="xref" href="sql-syntax.html#declare-condition" title="13.6.7.1 DECLARE ... CONDITION 構文">セクション13.6.7.1「DECLARE ... CONDITION 構文」</a>および<a class="xref" href="sql-syntax.html#declare-handler" title="13.6.7.2 DECLARE ... HANDLER 構文">セクション13.6.7.2「DECLARE ... HANDLER 構文」</a>を参照してください。条件が発生したときにサーバーがハンドラを選択する方法については、<a class="xref" href="sql-syntax.html#handler-scope" title="13.6.7.6 ハンドラのスコープに関するルール">セクション13.6.7.6「ハンドラのスコープに関するルール」</a>を参照してください。
    </p><p>
      条件を発生させるには、<code class="literal">SIGNAL</code> ステートメントを使用します。条件ハンドラ内で条件情報を変更するには、<code class="literal">RESIGNAL</code> を使用します。<a class="xref" href="sql-syntax.html#declare-condition" title="13.6.7.1 DECLARE ... CONDITION 構文">セクション13.6.7.1「DECLARE ... CONDITION 構文」</a>および<a class="xref" href="sql-syntax.html#declare-handler" title="13.6.7.2 DECLARE ... HANDLER 構文">セクション13.6.7.2「DECLARE ... HANDLER 構文」</a>を参照してください。
    </p><p>
      診断領域から情報を取得するには、<code class="literal">GET DIAGNOSTICS</code> ステートメントを使用します (<a class="xref" href="sql-syntax.html#get-diagnostics" title="13.6.7.3 GET DIAGNOSTICS 構文">セクション13.6.7.3「GET DIAGNOSTICS 構文」</a>を参照してください)。診断領域については、<a class="xref" href="sql-syntax.html#diagnostics-area" title="13.6.7.7 MySQL の診断領域">セクション13.6.7.7「MySQL の診断領域」</a>を参照してください。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="declare-condition"></a>13.6.7.1 DECLARE ... CONDITION 構文</h4></div></div></div><a class="indexterm" name="idm139979080774240"></a><pre class="programlisting">
DECLARE <em class="replaceable"><code>condition_name</code></em> CONDITION FOR <em class="replaceable"><code>condition_value</code></em>

<em class="replaceable"><code>condition_value</code></em>:
    <em class="replaceable"><code>mysql_error_code</code></em>
  | SQLSTATE [VALUE] <em class="replaceable"><code>sqlstate_value</code></em>
</pre><p>
        <code class="literal">DECLARE ... CONDITION</code> ステートメントは名前付きエラー条件を宣言し、特定の処理が必要な条件に名前を関連付けます。この名前は、以降の <code class="literal">DECLARE ... HANDLER</code> ステートメントで参照できます (<a class="xref" href="sql-syntax.html#declare-handler" title="13.6.7.2 DECLARE ... HANDLER 構文">セクション13.6.7.2「DECLARE ... HANDLER 構文」</a>を参照してください)。
      </p><p>
        条件宣言は、カーソルまたはハンドラ宣言の前に指定する必要があります。
      </p><p>
        <code class="literal">DECLARE ... CONDITION</code> の <em class="replaceable"><code>condition_value</code></em> は、MySQL エラーコード (番号) または SQLSTATE 値 (5 文字の文字列リテラル) にすることができます。MySQL エラーコード 0 または <code class="literal">'00'</code> で始まる SQLSTATE 値は、エラー条件ではなく成功を示すため、使用すべきではありません。MySQL エラーコードおよび SQLSTATE 値のリストについては、<a class="xref" href="error-handling.html#error-messages-server" title="B.3 サーバーのエラーコードおよびメッセージ">セクションB.3「サーバーのエラーコードおよびメッセージ」</a>を参照してください。
      </p><p>
        条件に名前を使用すると、ストアドプログラムのコードの明確化に役立つ場合があります。たとえば、次のハンドラは存在しないテーブルを削除しようとする試みに適用されますが、それが明らかなのは MySQL エラーコード 1051 の意味がわかっている場合だけです。
      </p><pre class="programlisting">
DECLARE CONTINUE HANDLER FOR 1051
  BEGIN
    -- body of handler
  END;
</pre><p>
        条件の名前を宣言することによって、このハンドラの目的がより簡単にわかるようになります。
      </p><pre class="programlisting">
DECLARE no_such_table CONDITION FOR 1051;
DECLARE CONTINUE HANDLER FOR no_such_table
  BEGIN
    -- body of handler
  END;
</pre><p>
        これは、同じ条件の、MySQL エラーコードではなく、対応する SQLSTATE 値に基づく名前付き条件です。
      </p><pre class="programlisting">
DECLARE no_such_table CONDITION FOR SQLSTATE '42S02';
DECLARE CONTINUE HANDLER FOR no_such_table
  BEGIN
    -- body of handler
  END;
</pre><p>
        <code class="literal">SIGNAL</code> で参照されるか、または <code class="literal">RESIGNAL</code> ステートメントで使用される条件名は MySQL エラーコードではなく、SQLSTATE 値に関連付けられている必要があります。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="declare-handler"></a>13.6.7.2 DECLARE ... HANDLER 構文</h4></div></div></div><a class="indexterm" name="idm139979080749328"></a><pre class="programlisting">
DECLARE <em class="replaceable"><code>handler_action</code></em> HANDLER
    FOR <em class="replaceable"><code>condition_value</code></em> [, <em class="replaceable"><code>condition_value</code></em>] ...
    <em class="replaceable"><code>statement</code></em>

<em class="replaceable"><code>handler_action</code></em>:
    CONTINUE
  | EXIT
  | UNDO

<em class="replaceable"><code>condition_value</code></em>:
    <em class="replaceable"><code>mysql_error_code</code></em>
  | SQLSTATE [VALUE] <em class="replaceable"><code>sqlstate_value</code></em>
  | <em class="replaceable"><code>condition_name</code></em>
  | SQLWARNING
  | NOT FOUND
  | SQLEXCEPTION
</pre><p>
        <code class="literal">DECLARE ... HANDLER</code> ステートメントは、1 つ以上の条件を処理するハンドラを指定します。これらの条件のいずれかが発生した場合は、指定された <em class="replaceable"><code>statement</code></em> が実行されます。<em class="replaceable"><code>statement</code></em> は <code class="literal">SET <em class="replaceable"><code>var_name</code></em> = <em class="replaceable"><code>value</code></em></code> などの単純なステートメントでも、<code class="literal">BEGIN</code> と <code class="literal">END</code> を使用して記述された複合ステートメントでもかまいません (<a class="xref" href="sql-syntax.html#begin-end" title="13.6.1 BEGIN ... END 複合ステートメント構文">セクション13.6.1「BEGIN ... END 複合ステートメント構文」</a>を参照してください)。
      </p><p>
        ハンドラ宣言は、変数または条件宣言のあとに指定する必要があります。
      </p><p>
        <em class="replaceable"><code>handler_action</code></em> 値は、ハンドラステートメントの実行後にハンドラがどのようなアクションを実行するかを示します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CONTINUE</code>: 現在のプログラムの実行が続行されます。
          </p></li><li class="listitem"><p>
            <code class="literal">EXIT</code>: このハンドラが宣言されている <code class="literal">BEGIN ... END</code> 複合ステートメントの実行が終了します。これは、この条件が内側のブロックで発生した場合にも当てはまります。
          </p></li><li class="listitem"><p>
            <code class="literal">UNDO</code>: サポートされていません。
          </p></li></ul></div><p>
        <code class="literal">DECLARE ... HANDLER</code> の <em class="replaceable"><code>condition_value</code></em> は、このハンドラをアクティブ化する具体的な条件または条件のクラスを示します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            MySQL エラーコード (番号) または SQLSTATE 値 (5 文字の文字列リテラル)。MySQL エラーコード 0 または <code class="literal">'00'</code> で始まる SQLSTATE 値は、エラー条件ではなく成功を示すため、使用すべきではありません。MySQL エラーコードおよび SQLSTATE 値のリストについては、<a class="xref" href="error-handling.html#error-messages-server" title="B.3 サーバーのエラーコードおよびメッセージ">セクションB.3「サーバーのエラーコードおよびメッセージ」</a>を参照してください。
          </p></li><li class="listitem"><p>
            以前に <code class="literal">DECLARE ... CONDITION</code> で指定された条件名。条件名は MySQL エラーコードまたは SQLSTATE 値に関連付けることができます。<a class="xref" href="sql-syntax.html#declare-condition" title="13.6.7.1 DECLARE ... CONDITION 構文">セクション13.6.7.1「DECLARE ... CONDITION 構文」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">SQLWARNING</code> は、<code class="literal">'01'</code> で始まる SQLSTATE 値のクラスの短縮形です。
          </p></li><li class="listitem"><p>
            <code class="literal">NOT FOUND</code> は、<code class="literal">'02'</code> で始まる SQLSTATE 値のクラスの短縮形です。これは、カーソルのコンテキストに関係しており、カーソルがデータセットの最後に達したときの動作を制御するために使用します。それ以上の行を取得できない場合は、SQLSTATE 値 <code class="literal">'02000'</code> で「データなし」状況が発生します。この状況を検出するには、その状況 (または、<code class="literal">NOT FOUND</code> 状況) のハンドラを設定できます。例については、<a class="xref" href="sql-syntax.html#cursors" title="13.6.6 カーソル">セクション13.6.6「カーソル」</a>を参照してください。この状況は、行が取得されない <code class="literal">SELECT ... INTO <em class="replaceable"><code>var_list</code></em></code> ステートメントでも発生します。
          </p></li><li class="listitem"><p>
            <code class="literal">SQLEXCEPTION</code> は、<code class="literal">'00'</code>、<code class="literal">'01'</code>、または <code class="literal">'02'</code> で始まらない SQLSTATE 値のクラスの短縮形です。
          </p></li></ul></div><p>
        条件が発生したときにサーバーがハンドラを選択する方法については、<a class="xref" href="sql-syntax.html#handler-scope" title="13.6.7.6 ハンドラのスコープに関するルール">セクション13.6.7.6「ハンドラのスコープに関するルール」</a>を参照してください。
      </p><p>
        対応するハンドラが宣言されていない条件が発生した場合、実行されるアクションはその条件のクラスによって異なります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">SQLEXCEPTION</code> 条件の場合は、<code class="literal">EXIT</code> ハンドラが存在するかのように、ストアドプログラムはその条件を発生させたステートメントで終了します。そのプログラムが別のストアドプログラムから呼び出されていた場合は、呼び出し元プログラムが、独自のハンドラに適用されるハンドラ選択ルールを使用してその条件を処理します。
          </p></li><li class="listitem"><p>
            <code class="literal">SQLWARNING</code> 条件の場合は、<code class="literal">CONTINUE</code> ハンドラが存在するかのように、プログラムは実行を続行します。
          </p></li><li class="listitem"><p>
            <code class="literal">NOT FOUND</code> 条件では、その条件が正常に発生した場合、アクションは <code class="literal">CONTINUE</code> です。<code class="literal">SIGNAL</code> または <code class="literal">RESIGNAL</code> によって発生した場合、アクションは <code class="literal">EXIT</code> です。
          </p></li></ul></div><p>
        次の例では、重複キーエラーに対して発生する <code class="literal">SQLSTATE '23000'</code> のハンドラを使用します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE test.t (s1 INT, PRIMARY KEY (s1));</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>delimiter //</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE PROCEDURE handlerdemo ()</code></strong>
    -&gt; <strong class="userinput"><code>BEGIN</code></strong>
    -&gt;   <strong class="userinput"><code>DECLARE CONTINUE HANDLER FOR SQLSTATE '23000' SET @x2 = 1;</code></strong>
    -&gt;   <strong class="userinput"><code>SET @x = 1;</code></strong>
    -&gt;   <strong class="userinput"><code>INSERT INTO test.t VALUES (1);</code></strong>
    -&gt;   <strong class="userinput"><code>SET @x = 2;</code></strong>
    -&gt;   <strong class="userinput"><code>INSERT INTO test.t VALUES (1);</code></strong>
    -&gt;   <strong class="userinput"><code>SET @x = 3;</code></strong>
    -&gt; <strong class="userinput"><code>END;</code></strong>
    -&gt; <strong class="userinput"><code>//</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>CALL handlerdemo()//</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT @x//</code></strong>
    +------+
    | @x   |
    +------+
    | 3    |
    +------+
    1 row in set (0.00 sec)
</pre><p>
        このプロシージャーの実行後、<code class="literal">@x</code> が <code class="literal">3</code> になっていることを確認してください。これは、エラーが発生したあと、プロシージャーの最後まで実行が続行されたことを示しています。<code class="literal">DECLARE ... HANDLER</code> ステートメントが存在しなかったとすると、<code class="literal">PRIMARY KEY</code> 制約のために 2 番目の <code class="literal">INSERT</code> が失敗したあとに MySQL はデフォルトのアクション (<code class="literal">EXIT</code>) を実行するため、<code class="literal">SELECT @x</code> は <code class="literal">2</code> を返していました。
      </p><p>
        条件を無視するには、その条件の <code class="literal">CONTINUE</code> ハンドラを宣言し、それを空のブロックに関連付けます。例:
      </p><pre class="programlisting">
DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN END;
</pre><p>
        ブロックラベルのスコープには、そのブロック内で宣言されているハンドラのコードは含まれません。そのため、ハンドラに関連付けられたステートメントは、<code class="literal">ITERATE</code> または <code class="literal">LEAVE</code> を使用して、そのハンドラ宣言を囲むブロックのラベルを参照することができません。<code class="literal">REPEAT</code> ブロックに <code class="literal">retry</code> のラベルが含まれている次の例を考えてみます。
      </p><pre class="programlisting">
CREATE PROCEDURE p ()
BEGIN
  DECLARE i INT DEFAULT 3;
  retry:
    REPEAT
      BEGIN
        DECLARE CONTINUE HANDLER FOR SQLWARNING
          BEGIN
            ITERATE retry;    # illegal
          END;
        IF i &lt; 0 THEN
          LEAVE retry;        # legal
        END IF;
        SET i = i - 1;
      END;
    UNTIL FALSE END REPEAT;
END;
</pre><p>
        <code class="literal">retry</code> ラベルは、そのブロック内の <code class="literal">IF</code> ステートメントのスコープ内にあります。<code class="literal">CONTINUE</code> ハンドラのスコープ内にはないため、そこでの参照は無効であり、エラーが発生します。
      </p><pre class="programlisting">
ERROR 1308 (42000): LEAVE with no matching label: retry
</pre><p>
        ハンドラ内の外側のラベルへの参照を回避するには、次の方法のいずれかを使用します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            このブロックを離れるには、<code class="literal">EXIT</code> ハンドラを使用します。ブロックのクリーンアップが必要ない場合は、<code class="literal">BEGIN ... END</code> ハンドラ本体を空にすることができます。
          </p><pre class="programlisting">
DECLARE EXIT HANDLER FOR SQLWARNING BEGIN END;
</pre><p>
            そうでない場合は、ハンドラ本体内にクリーンアップステートメントを配置します。
          </p><pre class="programlisting">
DECLARE EXIT HANDLER FOR SQLWARNING
  BEGIN
    <em class="replaceable"><code>block cleanup statements</code></em>
  END;
</pre></li><li class="listitem"><p>
            実行を続行するには、<code class="literal">CONTINUE</code> ハンドラ内に、囲んでいるブロック内でチェックすることによってそのハンドラが呼び出されたかどうかを判定できるステータス変数を設定します。次の例では、この目的のために変数 <code class="literal">done</code> を使用します。
          </p><pre class="programlisting">
CREATE PROCEDURE p ()
BEGIN
  DECLARE i INT DEFAULT 3;
  DECLARE done INT DEFAULT FALSE;
  retry:
    REPEAT
      BEGIN
        DECLARE CONTINUE HANDLER FOR SQLWARNING
          BEGIN
            SET done = TRUE;
          END;
        IF done OR i &lt; 0 THEN
          LEAVE retry;
        END IF;
        SET i = i - 1;
      END;
    UNTIL FALSE END REPEAT;
END;
</pre></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="get-diagnostics"></a>13.6.7.3 GET DIAGNOSTICS 構文</h4></div></div></div><a class="indexterm" name="idm139979080645440"></a><pre class="programlisting">
GET [CURRENT] DIAGNOSTICS
{
    <em class="replaceable"><code>statement_information_item</code></em>
    [, <em class="replaceable"><code>statement_information_item</code></em>] ... 
  | CONDITION <em class="replaceable"><code>condition_number</code></em>
    <em class="replaceable"><code>condition_information_item</code></em>
    [, <em class="replaceable"><code>condition_information_item</code></em>] ...
}

<em class="replaceable"><code>statement_information_item</code></em>:
    <em class="replaceable"><code>target</code></em> = <em class="replaceable"><code>statement_information_item_name</code></em>

<em class="replaceable"><code>condition_information_item</code></em>:
    <em class="replaceable"><code>target</code></em> = <em class="replaceable"><code>condition_information_item_name</code></em>

<em class="replaceable"><code>statement_information_item_name</code></em>:
    NUMBER
  | ROW_COUNT

<em class="replaceable"><code>condition_information_item_name</code></em>:
    CLASS_ORIGIN
  | SUBCLASS_ORIGIN
  | RETURNED_SQLSTATE
  | MESSAGE_TEXT
  | MYSQL_ERRNO
  | CONSTRAINT_CATALOG
  | CONSTRAINT_SCHEMA
  | CONSTRAINT_NAME
  | CATALOG_NAME
  | SCHEMA_NAME
  | TABLE_NAME
  | COLUMN_NAME
  | CURSOR_NAME

<em class="replaceable"><code>condition_number</code></em>, <em class="replaceable"><code>target</code></em>:
    (see following discussion)
</pre><p>
        SQL ステートメントは、診断領域を移入する診断情報を生成します。<code class="literal">GET DIAGNOSTICS</code> ステートメントを使用すると、アプリケーションでこの情報を検査できます。これは、MySQL 5.6.4 の時点で使用できます。(<code class="literal">SHOW WARNINGS</code> または <code class="literal">SHOW ERRORS</code> を使用して、条件またはエラーを確認することもできます。) 
      </p><p>
        <code class="literal">GET DIAGNOSTICS</code> を実行するために特殊な権限は必要ありません。
      </p><p>
        キーワード <code class="literal">CURRENT</code> は、現在の診断領域から情報を取得することを示します。MySQL では、それがデフォルトの動作であるため、これは何の効果もありません。
      </p><p>
        <code class="literal">GET DIAGNOSTICS</code> は通常、ストアドプログラム内のハンドラで使用されますが、これは、任意の SQL ステートメントの実行をチェックするためにハンドラのコンテキストの外部で許可される MySQL 拡張です。たとえば、<span class="command"><strong>mysql</strong></span> クライアントプログラムを呼び出す場合は、プロンプトで次のステートメントを入力できます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>DROP TABLE test.no_such_table;</code></strong>
ERROR 1051 (42S02): Unknown table 'test.no_such_table'
mysql&gt; <strong class="userinput"><code>GET DIAGNOSTICS CONDITION 1</code></strong>
    -&gt;   <strong class="userinput"><code>@p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT @p1, @p2;</code></strong>
+-------+------------------------------------+
| @p1   | @p2                                |
+-------+------------------------------------+
| 42S02 | Unknown table 'test.no_such_table' |
+-------+------------------------------------+
</pre><p>
        診断領域については、<a class="xref" href="sql-syntax.html#diagnostics-area" title="13.6.7.7 MySQL の診断領域">セクション13.6.7.7「MySQL の診断領域」</a>を参照してください。簡単に言うと、ここには次の 2 種類の情報が含まれています。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            発生した条件の数や、影響を受けた行数などのステートメント情報。
          </p></li><li class="listitem"><p>
            エラーコードやメッセージなどの条件情報。ステートメントが複数の条件を発生させた場合、診断領域のこの部分には条件ごとの条件領域が含まれています。ステートメントがどの条件も発生させない場合、診断領域のこの部分は空です。
          </p></li></ul></div><p>
        3 つの条件を生成するステートメントの場合、診断領域には、次のようなステートメント情報と条件情報が含まれています。
      </p><pre class="programlisting">
Statement information:
  row count
  ... other statement information items ...
Condition area list:
  Condition area 1:
    error code for condition 1
    error message for condition 1
    ... other condition information items ...
  Condition area 2:
    error code for condition 2:
    error message for condition 2
    ... other condition information items ...
  Condition area 3:
    error code for condition 3
    error message for condition 3
    ... other condition information items ...
</pre><p>
        <code class="literal">GET DIAGNOSTICS</code> はステートメントまたは条件情報のどちらかを取得できますが、同じステートメントで両方を取得することはできません。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            ステートメント情報を取得するには、目的のステートメント項目をターゲット変数に取得します。<code class="literal">GET DIAGNOSTICS</code> の次の例では、使用可能な条件の数と影響を受けた行数をユーザー変数 <code class="literal">@p1</code> と <code class="literal">@p2</code> に割り当てます。
          </p><pre class="programlisting">
GET DIAGNOSTICS @p1 = NUMBER, @p2 = ROW_COUNT;
</pre></li><li class="listitem"><p>
            条件情報を取得するには、条件番号を指定し、目的の条件項目をターゲット変数に取得します。<code class="literal">GET DIAGNOSTICS</code> の次の例では、SQLSTATE 値とエラーメッセージをユーザー変数 <code class="literal">@p3</code> と <code class="literal">@p4</code> に割り当てます。
          </p><pre class="programlisting">
GET DIAGNOSTICS CONDITION 1
  @p3 = RETURNED_SQLSTATE, @p4 = MESSAGE_TEXT;
</pre></li></ul></div><p>
        取得リストには、カンマで区切られた 1 つ以上の <code class="literal"><em class="replaceable"><code>target</code></em> = <em class="replaceable"><code>item_name</code></em></code> 代入を指定します。各代入では、ターゲット変数と、このステートメントがステートメントまたは条件情報のどちらを取得するかに応じて <em class="replaceable"><code>statement_information_item_name</code></em> または <em class="replaceable"><code>condition_information_item_name</code></em> 指示子のどちらかを指定します。
      </p><p>
        項目情報を格納するための有効な <em class="replaceable"><code>target</code></em> 指示子は、ストアドプロシージャーやストアドファンクションのパラメータ、<code class="literal">DECLARE</code> で宣言されたストアドプログラムのローカル変数、ユーザー定義変数のいずれかです。
      </p><p>
        有効な <em class="replaceable"><code>condition_number</code></em> 指示子は、ストアドプロシージャーやストアドファンクションのパラメータ、<code class="literal">DECLARE</code> で宣言されたストアドプログラムのローカル変数、ユーザー定義変数、システム変数、リテラルのいずれかです。文字リテラルには、<em class="replaceable"><code>_charset</code></em> イントロデューサを含めることができます。条件番号が 1 から、情報が含まれている条件領域の数までの範囲にない場合は、警告が発生します。この場合、この警告は、診断領域にその領域をクリアすることなく追加されます。
      </p><p>
        現在は、条件が発生したときに、MySQL が <code class="literal">GET DIAGNOSTICS</code> によって認識されるすべての条件項目を移入するわけではありません。例:
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>GET DIAGNOSTICS CONDITION 1</code></strong>
    -&gt;   <strong class="userinput"><code>@p5 = SCHEMA_NAME, @p6 = TABLE_NAME;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT @p5, @p6;</code></strong>
+------+------+
| @p5  | @p6  |
+------+------+
|      |      |
+------+------+
</pre><p>
        標準 SQL では、複数の条件が存在する場合、最初の条件は前の SQL ステートメントに対して返された <code class="literal">SQLSTATE</code> 値に関連しています。MySQL では、これが保証されません。メインのエラーを取得するために、次のように行うことはできません。
      </p><pre class="programlisting">
GET DIAGNOSTICS CONDITION 1 @errno = MYSQL_ERRNO;
</pre><p>
        代わりに、まず条件数を取得し、次にそれを使用してどの条件番号を検査するかを指定します。
      </p><pre class="programlisting">
GET DIAGNOSTICS @cno = NUMBER;
GET DIAGNOSTICS CONDITION @cno @errno = MYSQL_ERRNO;
</pre><p>
        許可されるステートメント情報と条件情報の項目、および条件が発生したときにどの項目が移入されるかについては、<a class="xref" href="sql-syntax.html#diagnostics-area-information-items" title="13.6.7.7.2 診断領域の情報項目">セクション13.6.7.7.2「診断領域の情報項目」</a>を参照してください。
      </p><p>
        ストアドプロシージャーのコンテキストで <code class="literal">GET DIAGNOSTICS</code> と例外ハンドラを使用して、挿入操作の結果を評価する例を次に示します。挿入が成功した場合、このプロシージャーは <code class="literal">GET DIAGNOSTICS</code> を使用して、影響を受けた行数を取得します。これは、診断領域がクリアされていないかぎり、<code class="literal">GET DIAGNOSTICS</code> を複数回使用してステートメントに関する情報を取得できることを示しています。
      </p><pre class="programlisting">
CREATE PROCEDURE do_insert(value INT)
BEGIN
  -- Declare variables to hold diagnostics area information
  DECLARE code CHAR(5) DEFAULT '00000';
  DECLARE msg TEXT;
  DECLARE rows INT;
  DECLARE result TEXT;
  -- Declare exception handler for failed insert
  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
      GET DIAGNOSTICS CONDITION 1
        code = RETURNED_SQLSTATE, msg = MESSAGE_TEXT;
    END;

  -- Perform the insert
  INSERT INTO t1 (int_col) VALUES(value);
  -- Check whether the insert was successful
  IF code = '00000' THEN
    GET DIAGNOSTICS rows = ROW_COUNT;
    SET result = CONCAT('insert succeeded, row count = ',rows);
  ELSE
    SET result = CONCAT('insert failed, error = ',code,', message = ',msg);
  END IF;
  -- Say what happened
  SELECT result;
END;
</pre><p>
        <code class="literal">t1.int_col</code> が、<code class="literal">NOT NULL</code> として宣言された整数カラムであるとします。このプロシージャーは、<code class="literal">NULL</code> 以外の値と <code class="literal">NULL</code> 値を挿入するために呼び出されると、それぞれ次の結果を生成します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CALL do_insert(1);</code></strong>
+---------------------------------+
| result                          |
+---------------------------------+
| insert succeeded, row count = 1 |
+---------------------------------+

mysql&gt; <strong class="userinput"><code>CALL do_insert(NULL);</code></strong>
+-------------------------------------------------------------------------+
| result                                                                  |
+-------------------------------------------------------------------------+
| insert failed, error = 23000, message = Column 'int_col' cannot be null |
+-------------------------------------------------------------------------+
</pre><p>
        <code class="literal">GET DIAGNOSTICS</code> は、条件ハンドラ内で、診断領域をクリアしたり、そのハンドラをアクティブ化した条件に関する情報が失われたりする可能性のあるほかのステートメントの前に使用するようにしてください。診断領域がいつ設定およびクリアされるかについては、<a class="xref" href="sql-syntax.html#diagnostics-area" title="13.6.7.7 MySQL の診断領域">セクション13.6.7.7「MySQL の診断領域」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="resignal"></a>13.6.7.4 RESIGNAL 構文</h4></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-syntax.html#resignal-alone">13.6.7.4.1 RESIGNAL のみ</a></span></dt><dt><span class="section"><a href="sql-syntax.html#resignal-with-new-signal">13.6.7.4.2 新しいシグナル情報を含む RESIGNAL</a></span></dt><dt><span class="section"><a href="sql-syntax.html#resignal-with-condition">13.6.7.4.3 条件値とオプションの新しいシグナル情報を含む RESIGNAL</a></span></dt><dt><span class="section"><a href="sql-syntax.html#resignal-handler">13.6.7.4.4 RESIGNAL には条件ハンドラのコンテキストが必要</a></span></dt></dl></div><a class="indexterm" name="idm139979080566592"></a><pre class="programlisting">
RESIGNAL [<em class="replaceable"><code>condition_value</code></em>]
    [SET <em class="replaceable"><code>signal_information_item</code></em>
    [, <em class="replaceable"><code>signal_information_item</code></em>] ...]

<em class="replaceable"><code>condition_value</code></em>:
    SQLSTATE [VALUE] <em class="replaceable"><code>sqlstate_value</code></em>
  | <em class="replaceable"><code>condition_name</code></em>

<em class="replaceable"><code>signal_information_item</code></em>:
    <em class="replaceable"><code>condition_information_item_name</code></em> = <em class="replaceable"><code>simple_value_specification</code></em>

<em class="replaceable"><code>condition_information_item_name</code></em>:
    CLASS_ORIGIN
  | SUBCLASS_ORIGIN
  | MESSAGE_TEXT
  | MYSQL_ERRNO
  | CONSTRAINT_CATALOG
  | CONSTRAINT_SCHEMA
  | CONSTRAINT_NAME
  | CATALOG_NAME
  | SCHEMA_NAME
  | TABLE_NAME
  | COLUMN_NAME
  | CURSOR_NAME

<em class="replaceable"><code>condition_name</code></em>, <em class="replaceable"><code>simple_value_specification</code></em>:
    (see following discussion)
</pre><p>
        <code class="literal">RESIGNAL</code> は、ストアドプロシージャーやストアドファンクションの内部にある複合ステートメント内の条件ハンドラ、トリガー、またはイベントの実行中に使用可能なエラー条件情報を渡します。<code class="literal">RESIGNAL</code> は、その情報の一部またはすべてを、渡す前に変更する可能性があります。<code class="literal">RESIGNAL</code> は <code class="literal">SIGNAL</code> に関連していますが、<code class="literal">SIGNAL</code> のように条件を発信する代わりに、<code class="literal">RESIGNAL</code> は既存の条件情報を (おそらく、変更してから) 中継します。
      </p><p>
        <code class="literal">RESIGNAL</code> は、エラーを処理することと、エラー情報を返すことの両方を可能にします。それ以外の場合は、ハンドラ内の SQL ステートメントを実行することによって、そのハンドラのアクティブ化を発生させた情報が破棄されます。<code class="literal">RESIGNAL</code> は、指定されたハンドラが状況の一部を処理できる場合はプロシージャーの一部を短くしてから、条件を<span class="quote">「<span class="quote">遡って</span>」</span>別のハンドラに渡すことができます。
      </p><p>
        <code class="literal">RESIGNAL</code> ステートメントを実行するために特殊な権限は必要ありません。
      </p><p>
        <code class="literal">RESIGNAL</code> のすべての形式で、現在のコンテキストが条件ハンドラである必要があります。そうでない場合、<code class="literal">RESIGNAL</code> は不正であり、<code class="literal">RESIGNAL when handler not active</code> エラーが発生します。
      </p><p>
        診断領域から情報を取得するには、<code class="literal">GET DIAGNOSTICS</code> ステートメントを使用します (<a class="xref" href="sql-syntax.html#get-diagnostics" title="13.6.7.3 GET DIAGNOSTICS 構文">セクション13.6.7.3「GET DIAGNOSTICS 構文」</a>を参照してください)。診断領域については、<a class="xref" href="sql-syntax.html#diagnostics-area" title="13.6.7.7 MySQL の診断領域">セクション13.6.7.7「MySQL の診断領域」</a>を参照してください。
      </p><p>
        <code class="literal">RESIGNAL</code> に対する <em class="replaceable"><code>condition_value</code></em> と <em class="replaceable"><code>signal_information_item</code></em> の定義やルールは、<code class="literal">SIGNAL</code> に対するものと同じです。たとえば、<em class="replaceable"><code>condition_value</code></em> を <code class="literal">SQLSTATE</code> 値にすることができ、この値は、エラー、警告、または<span class="quote">「<span class="quote">見つからない</span>」</span>を示す場合があります。詳細は、<a class="xref" href="sql-syntax.html#signal" title="13.6.7.5 SIGNAL 構文">セクション13.6.7.5「SIGNAL 構文」</a>を参照してください。
      </p><p>
        <code class="literal">RESIGNAL</code> ステートメントは、どちらもオプションである <em class="replaceable"><code>condition_value</code></em> と <code class="literal">SET</code> 句を受け取ります。このため、次のいくつかの使用法が考えられます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">RESIGNAL</code> のみ:
          </p><pre class="programlisting">
RESIGNAL;
</pre></li><li class="listitem"><p>
            新しいシグナル情報を含む <code class="literal">RESIGNAL</code>:
          </p><pre class="programlisting">
RESIGNAL SET <em class="replaceable"><code>signal_information_item</code></em> [, <em class="replaceable"><code>signal_information_item</code></em>] ...;
</pre></li><li class="listitem"><p>
            条件値と場合によっては新しいシグナル情報を含む <code class="literal">RESIGNAL</code>:
          </p><pre class="programlisting">
RESIGNAL <em class="replaceable"><code>condition_value</code></em>
    [SET <em class="replaceable"><code>signal_information_item</code></em> [, <em class="replaceable"><code>signal_information_item</code></em>] ...];
</pre></li></ul></div><p>
        これらのユースケースはすべて、診断および条件領域の変更を発生させます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            診断領域には 1 つ以上の条件領域が含まれています。
          </p></li><li class="listitem"><p>
            条件領域には、<code class="literal">SQLSTATE</code> 値、<code class="literal">MYSQL_ERRNO</code>、<code class="literal">MESSAGE_TEXT</code> などの条件情報項目が含まれています。
          </p></li></ul></div><p>
        診断領域内の条件領域の最大数は、<code class="literal">max_error_count</code> システム変数の値によって決定されます。<a class="xref" href="sql-syntax.html#diagnostics-area-system-variables" title="13.6.7.7.4 診断領域関連のシステム変数">セクション13.6.7.7.4「診断領域関連のシステム変数」</a>を参照してください。
      </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="resignal-alone"></a>13.6.7.4.1 RESIGNAL のみ</h5></div></div></div><p>
          単純な <code class="literal">RESIGNAL</code> のみとは、<span class="quote">「<span class="quote">エラーを変更せずに渡す</span>」</span>ことを示します。これは最後の診断領域をリストアし、それを現在の診断領域にします。つまり、診断領域スタックを<span class="quote">「<span class="quote">ポップします</span>」</span>。
        </p><p>
          条件をキャッチする条件ハンドラ内での <code class="literal">RESIGNAL</code> のみの 1 つの使用法として、ほかのいくつかのアクションを実行したあと、元の条件情報 (ハンドラに入る前に存在していた情報) を変更せずに渡す方法があります。
        </p><p>
          例:
        </p><pre class="programlisting">
DROP TABLE IF EXISTS xx;
delimiter //
CREATE PROCEDURE p ()
BEGIN
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    SET @error_count = @error_count + 1;
    IF @a = 0 THEN RESIGNAL; END IF;
  END;
  DROP TABLE xx;
END//
delimiter ;
SET @error_count = 0;
SET @a = 0;
CALL p();
</pre><p>
          <code class="literal">DROP TABLE xx</code> ステートメントが失敗したとします。診断領域スタックは次のようになります。
        </p><pre class="programlisting">
DA 1. ERROR 1051 (42S02): Unknown table 'xx'
</pre><p>
          次に、実行が <code class="literal">EXIT</code> ハンドラに入ります。このハンドラは最初に、診断領域をスタックの先頭にプッシュします。これで、診断領域スタックは次のようになります。
        </p><pre class="programlisting">
DA 1. ERROR 1051 (42S02): Unknown table 'xx'
DA 2. ERROR 1051 (42S02): Unknown table 'xx'
</pre><p>
          この時点で、最初の (現在の) 診断領域と 2 番目の (スタックされた) 診断領域の内容は同じです。最初の診断領域は、そのあとにハンドラ内で実行されるステートメントによって変更される可能性があります。
        </p><p>
          通常、プロシージャーステートメントは最初の診断領域をクリアします。<code class="literal">BEGIN</code> は例外です。これはクリアせず、何も行いません。<code class="literal">SET</code> は例外ではありません。これはクリアし、操作を実行して、<span class="quote">「<span class="quote">成功</span>」</span>の結果を生成します。これで、診断領域スタックは次のようになります。
        </p><pre class="programlisting">
DA 1. ERROR 0000 (00000): Successful operation
DA 2. ERROR 1051 (42S02): Unknown table 'xx'
</pre><p>
          この時点で、<code class="literal">@a = 0</code> の場合、<code class="literal">RESIGNAL</code> は診断領域スタックをポップします。これで、診断領域スタックは次のようになります。
        </p><pre class="programlisting">
DA 1. ERROR 1051 (42S02): Unknown table 'xx'
</pre><p>
          そして、これが呼び出し元に表示される内容です。
        </p><p>
          <code class="literal">@a</code> が 0 でない場合、このハンドラは単純に終了します。つまり、現在の診断領域はそれ以上使用されなくなる (<span class="quote">「<span class="quote">処理済み</span>」</span>になった) ため、破棄することが可能になり、スタックされた診断領域がふたたび現在の診断領域になります。診断領域スタックは次のようになります。
        </p><pre class="programlisting">
DA 1. ERROR 0000 (00000): Successful operation
</pre><p>
          詳細を調べると複雑に見えますが、最終結果はきわめて有効です。ハンドラは、そのハンドラのアクティブ化を発生させた条件に関する情報を破棄することなく実行できます。
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="resignal-with-new-signal"></a>13.6.7.4.2 新しいシグナル情報を含む RESIGNAL</h5></div></div></div><p>
          <code class="literal">SET</code> 句を含む <code class="literal">RESIGNAL</code> は新しいシグナル情報を指定するため、このステートメントは、<span class="quote">「<span class="quote">エラーを変更してから渡す</span>」</span>ことを示します。
        </p><pre class="programlisting">
RESIGNAL SET <em class="replaceable"><code>signal_information_item</code></em> [, <em class="replaceable"><code>signal_information_item</code></em>] ...;
</pre><p>
          <code class="literal">RESIGNAL</code> のみと同様に、考え方としては、元の情報が消えるように診断領域スタックをポップします。<code class="literal">RESIGNAL</code> のみとは異なり、<code class="literal">SET</code> 句で指定されたものはすべて変更されます。
        </p><p>
          例:
        </p><pre class="programlisting">
DROP TABLE IF EXISTS xx;
delimiter //
CREATE PROCEDURE p ()
BEGIN
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    SET @error_count = @error_count + 1;
    IF @a = 0 THEN RESIGNAL SET MYSQL_ERRNO = 5; END IF;
  END;
  DROP TABLE xx;
END//
delimiter ;
SET @error_count = 0;
SET @a = 0;
CALL p();
</pre><p>
          前の説明から、<code class="literal">RESIGNAL</code> のみによって、診断領域スタックが次のようになることを思い出してください。
        </p><pre class="programlisting">
DA 1. ERROR 1051 (42S02): Unknown table 'xx'
</pre><p>
          <code class="literal">RESIGNAL SET MYSQL_ERRNO = 5</code> ステートメントでは、代わりに、スタックが次のようになります。これが呼び出し元に表示される内容です。
        </p><pre class="programlisting">
DA 1. ERROR 5 (42S02): Unknown table 'xx'
</pre><p>
          つまり、エラー番号だけが変更され、ほかは何も変更されません。
        </p><p>
          <code class="literal">RESIGNAL</code> ステートメントはシグナル情報項目のいずれかまたはすべてを変更できるため、診断領域の最初の条件領域がまったく異なっているように見えます。
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="resignal-with-condition"></a>13.6.7.4.3 条件値とオプションの新しいシグナル情報を含む RESIGNAL</h5></div></div></div><p>
          条件値を含む <code class="literal">RESIGNAL</code> は、<span class="quote">「<span class="quote">条件を現在の診断領域にプッシュする</span>」</span>ことを示します。<code class="literal">SET</code> 句が存在する場合は、エラー情報も変更されます。
        </p><pre class="programlisting">
RESIGNAL <em class="replaceable"><code>condition_value</code></em>
    [SET <em class="replaceable"><code>signal_information_item</code></em> [, <em class="replaceable"><code>signal_information_item</code></em>] ...];
</pre><p>
          この形式の <code class="literal">RESIGNAL</code> は最後の診断領域をリストアし、それを現在の診断領域にします。つまり、診断領域スタックを<span class="quote">「<span class="quote">ポップします</span>」</span>。これは、単純な <code class="literal">RESIGNAL</code> のみが行う動作と同じです。ただし、条件値またはシグナル情報に応じて、診断領域も変更されます。
        </p><p>
          例:
        </p><pre class="programlisting">
DROP TABLE IF EXISTS xx;
delimiter //
CREATE PROCEDURE p ()
BEGIN
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    SET @error_count = @error_count + 1;
    IF @a = 0 THEN RESIGNAL SQLSTATE '45000' SET MYSQL_ERRNO=5; END IF;
  END;
  DROP TABLE xx;
END//
delimiter ;
SET @error_count = 0;
SET @a = 0;
SET @@max_error_count = 2;
CALL p();
SHOW ERRORS;
</pre><p>
          これは前の例に似ていて、その効果も同じですが、<code class="literal">RESIGNAL</code> が発生した場合は、現在の条件領域が最後には異なっているように見える点が異なります。(この条件が既存の条件を置き換えるのではなく、それに追加される理由は、条件値が使用されているためです。) 
        </p><p>
          この <code class="literal">RESIGNAL</code> ステートメントには条件値 (<code class="literal">SQLSTATE '45000'</code>) が含まれているため、新しい条件領域が追加され、診断領域スタックは次のようになります。
        </p><pre class="programlisting">
DA 1. (condition 2) ERROR 1051 (42S02): Unknown table 'xx'
      (condition 1) ERROR 5 (45000) Unknown table 'xx'
</pre><p>
          この例での <code class="literal">CALL p()</code> と <code class="literal">SHOW ERRORS</code> の結果は次のとおりです。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CALL p();</code></strong>
ERROR 5 (45000): Unknown table 'xx'
mysql&gt; <strong class="userinput"><code>SHOW ERRORS;</code></strong>
+-------+------+----------------------------------+
| Level | Code | Message                          |
+-------+------+----------------------------------+
| Error | 1051 | Unknown table 'xx'               |
| Error |    5 | Unknown table 'xx'               |
+-------+------+----------------------------------+
</pre></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="resignal-handler"></a>13.6.7.4.4 RESIGNAL には条件ハンドラのコンテキストが必要</h5></div></div></div><p>
          <code class="literal">RESIGNAL</code> のすべての形式で、現在のコンテキストが条件ハンドラである必要があります。そうでない場合、<code class="literal">RESIGNAL</code> は不正であり、<code class="literal">RESIGNAL when handler not active</code> エラーが発生します。例:
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE PROCEDURE p () RESIGNAL;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>CALL p();</code></strong>
ERROR 1645 (0K000): RESIGNAL when handler not active
</pre><p>
          さらに難しい例を次に示します。
        </p><pre class="programlisting">
delimiter //
CREATE FUNCTION f () RETURNS INT
BEGIN
  RESIGNAL;
  RETURN 5;
END//
CREATE PROCEDURE p ()
BEGIN
  DECLARE EXIT HANDLER FOR SQLEXCEPTION SET @a=f();
  SIGNAL SQLSTATE '55555';
END//
delimiter ;
CALL p();
</pre><p>
          <code class="literal">RESIGNAL</code> がストアドファンクション <code class="literal">f()</code> 内に現れています。<code class="literal">f()</code> 自体は <code class="literal">EXIT</code> ハンドラのコンテキスト内で呼び出されますが、<code class="literal">f()</code> 内での実行は独自のコンテキストを持ち、それはハンドラのコンテキストではありません。そのため、<code class="literal">f()</code> 内での <code class="literal">RESIGNAL</code> によって、<span class="quote">「<span class="quote">handler not active</span>」</span> エラーが発生します。
        </p><p>
          MySQL 5.5 では、ハンドラのスコープに関するルールが十分に発達していません。<code class="literal">f()</code> はハンドラのコンテキスト内で実行されると見なされ、<code class="literal">f()</code> 内での <code class="literal">RESIGNAL</code> は正当です。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="signal"></a>13.6.7.5 SIGNAL 構文</h4></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-syntax.html#signal-condition-information-items">13.6.7.5.1 シグナルの条件情報項目</a></span></dt><dt><span class="section"><a href="sql-syntax.html#signal-effects">13.6.7.5.2 ハンドラ、カーソル、およびステートメントに対するシグナルの影響</a></span></dt></dl></div><a class="indexterm" name="idm139979080427696"></a><pre class="programlisting">
SIGNAL <em class="replaceable"><code>condition_value</code></em>
    [SET <em class="replaceable"><code>signal_information_item</code></em>
    [, <em class="replaceable"><code>signal_information_item</code></em>] ...]

<em class="replaceable"><code>condition_value</code></em>:
    SQLSTATE [VALUE] <em class="replaceable"><code>sqlstate_value</code></em>
  | <em class="replaceable"><code>condition_name</code></em>

<em class="replaceable"><code>signal_information_item</code></em>:
    <em class="replaceable"><code>condition_information_item_name</code></em> = <em class="replaceable"><code>simple_value_specification</code></em>

<em class="replaceable"><code>condition_information_item_name</code></em>:
    CLASS_ORIGIN
  | SUBCLASS_ORIGIN
  | MESSAGE_TEXT
  | MYSQL_ERRNO
  | CONSTRAINT_CATALOG
  | CONSTRAINT_SCHEMA
  | CONSTRAINT_NAME
  | CATALOG_NAME
  | SCHEMA_NAME
  | TABLE_NAME
  | COLUMN_NAME
  | CURSOR_NAME

<em class="replaceable"><code>condition_name</code></em>, <em class="replaceable"><code>simple_value_specification</code></em>:
    (see following discussion)
</pre><p>
        <code class="literal">SIGNAL</code> は、エラー<span class="quote">「<span class="quote">を返す</span>」</span>ための方法です。<code class="literal">SIGNAL</code> は、ハンドラ、アプリケーションの外側の部分、またはクライアントにエラー情報を提供します。また、エラーの特性 (エラー番号、<code class="literal">SQLSTATE</code> 値、メッセージ) に対する制御も提供します。<code class="literal">SIGNAL</code> を使用しない場合は、存在しないテーブルを意図的に参照してルーチンがエラーを返すようにする、などの回避方法に頼る必要があります。
      </p><p>
        <code class="literal">SIGNAL</code> ステートメントを実行するために特殊な権限は必要ありません。
      </p><p>
        診断領域から情報を取得するには、<code class="literal">GET DIAGNOSTICS</code> ステートメントを使用します (<a class="xref" href="sql-syntax.html#get-diagnostics" title="13.6.7.3 GET DIAGNOSTICS 構文">セクション13.6.7.3「GET DIAGNOSTICS 構文」</a>を参照してください)。診断領域については、<a class="xref" href="sql-syntax.html#diagnostics-area" title="13.6.7.7 MySQL の診断領域">セクション13.6.7.7「MySQL の診断領域」</a>を参照してください。
      </p><p>
        <code class="literal">SIGNAL</code> ステートメント内の <em class="replaceable"><code>condition_value</code></em> は、返されるエラー値を示します。これは、<code class="literal">SQLSTATE</code> 値 (5 文字の文字列リテラル) か、または以前に <code class="literal">DECLARE ... CONDITION</code> で定義された名前付き条件を参照する <em class="replaceable"><code>condition_name</code></em> にすることができます (<a class="xref" href="sql-syntax.html#declare-condition" title="13.6.7.1 DECLARE ... CONDITION 構文">セクション13.6.7.1「DECLARE ... CONDITION 構文」</a>を参照してください)。
      </p><p>
        <code class="literal">SQLSTATE</code> 値は、エラー、警告、または<span class="quote">「<span class="quote">見つからない</span>」</span>を示す場合があります。<a class="xref" href="sql-syntax.html#signal-condition-information-items" title="13.6.7.5.1 シグナルの条件情報項目">セクション13.6.7.5.1「シグナルの条件情報項目」</a>で説明されているように、この値の最初の 2 文字はそのエラークラスを示します。一部のシグナル値はステートメントを終了させます。<a class="xref" href="sql-syntax.html#signal-effects" title="13.6.7.5.2 ハンドラ、カーソル、およびステートメントに対するシグナルの影響">セクション13.6.7.5.2「ハンドラ、カーソル、およびステートメントに対するシグナルの影響」</a>を参照してください。
      </p><p>
        <code class="literal">'00'</code> は成功を示し、エラーの通知には有効でないため、<code class="literal">SIGNAL</code> ステートメントの <code class="literal">SQLSTATE</code> 値をこのような値で始めるべきではありません。これは、<code class="literal">SQLSTATE</code> 値が <code class="literal">SIGNAL</code> ステートメントで直接、またはこのステートメントで参照されている名前付き条件のどちらで指定されている場合にも当てはまります。この値が無効である場合は、<code class="literal">Bad SQLSTATE</code> エラーが発生します。
      </p><p>
        一般的な <code class="literal">SQLSTATE</code> 値を通知するには、<code class="literal">'45000'</code> を使用します。これは、<span class="quote">「<span class="quote">未処理のユーザー定義の例外</span>」</span>を示します。
      </p><p>
        <code class="literal">SIGNAL</code> ステートメントには、オプションで、複数のシグナル項目が <em class="replaceable"><code>condition_information_item_name</code></em> = <em class="replaceable"><code>simple_value_specification</code></em> 代入のカンマ区切りリストで含まれている <code class="literal">SET</code> 句が含まれます。
      </p><p>
        各 <em class="replaceable"><code>condition_information_item_name</code></em> は、<code class="literal">SET</code> 句内で 1 回だけ指定できます。そうでない場合は、<code class="literal">Duplicate condition information item</code> エラーが発生します。
      </p><p>
        有効な <em class="replaceable"><code>simple_value_specification</code></em> 指示子は、ストアドプロシージャーやストアドファンクションのパラメータ、<code class="literal">DECLARE</code> で宣言されたストアドプログラムのローカル変数、ユーザー定義変数、システム変数、またはリテラルを使用して指定できます。文字リテラルには、<em class="replaceable"><code>_charset</code></em> イントロデューサを含めることができます。
      </p><p>
        許可される <em class="replaceable"><code>condition_information_item_name</code></em> 値については、<a class="xref" href="sql-syntax.html#signal-condition-information-items" title="13.6.7.5.1 シグナルの条件情報項目">セクション13.6.7.5.1「シグナルの条件情報項目」</a>を参照してください。
      </p><p>
        次のプロシージャーは、その入力パラメータである <code class="literal">pval</code> の値に応じて、エラーまたは警告を通知します。
      </p><pre class="programlisting">
CREATE PROCEDURE p (pval INT)
BEGIN
  DECLARE specialty CONDITION FOR SQLSTATE '45000';
  IF pval = 0 THEN
    SIGNAL SQLSTATE '01000';
  ELSEIF pval = 1 THEN
    SIGNAL SQLSTATE '45000'
      SET MESSAGE_TEXT = 'An error occurred';
  ELSEIF pval = 2 THEN
    SIGNAL specialty
      SET MESSAGE_TEXT = 'An error occurred';
  ELSE
    SIGNAL SQLSTATE '01000'
      SET MESSAGE_TEXT = 'A warning occurred', MYSQL_ERRNO = 1000;
    SIGNAL SQLSTATE '45000'
      SET MESSAGE_TEXT = 'An error occurred', MYSQL_ERRNO = 1001;
  END IF;
END;
</pre><p>
        <code class="literal">pval</code> が 0 である場合、<code class="literal">'01'</code> で始まる <code class="literal">SQLSTATE</code> 値は警告クラス内のシグナルであるため、<code class="literal">p()</code> は警告を通知します。この警告はプロシージャーを終了させず、そのプロシージャーから戻ったあとに <code class="literal">SHOW WARNINGS</code> で確認できます。
      </p><p>
        <code class="literal">pval</code> が 1 である場合、<code class="literal">p()</code> はエラーを通知し、<code class="literal">MESSAGE_TEXT</code> 条件情報項目を設定します。このエラーはプロシージャーを終了させ、そのテキストがエラー情報とともに返されます。
      </p><p>
        <code class="literal">pval</code> が 2 である場合、この場合は名前付き条件を使用して <code class="literal">SQLSTATE</code> 値が指定されているにもかかわらず、同じエラーが通知されます。
      </p><p>
        <code class="literal">pval</code> がその他の任意の値である場合、<code class="literal">p()</code> は最初に警告を通知し、メッセージテキストとエラー番号の条件情報項目を設定します。この警告はプロシージャーを終了させないため、実行が続行され、そのあと <code class="literal">p()</code> はエラーを通知します。このエラーはプロシージャーを終了させます。警告によって設定されたメッセージテキストとエラー番号は、エラーによって設定された値によって置き換えられ、それがエラー情報とともに返されます。
      </p><p>
        <code class="literal">SIGNAL</code> は通常、ストアドプログラム内で使用されますが、これはハンドラのコンテキストの外部で許可される MySQL 拡張です。たとえば、<span class="command"><strong>mysql</strong></span> クライアントプログラムを呼び出す場合は、プロンプトで次のステートメントのいずれかを入力できます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SIGNAL SQLSTATE '77777';</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE TRIGGER t_bi BEFORE INSERT ON t</code></strong>
    -&gt; <strong class="userinput"><code>FOR EACH ROW SIGNAL SQLSTATE '77777';</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE EVENT e ON SCHEDULE EVERY 1 SECOND</code></strong>
    -&gt; <strong class="userinput"><code>DO SIGNAL SQLSTATE '77777';</code></strong>
</pre><p>
        <code class="literal">SIGNAL</code> は、次のルールに従って実行されます。
      </p><p>
        <code class="literal">SIGNAL</code> ステートメントが特定の <code class="literal">SQLSTATE</code> 値を示している場合、その値は、指定された条件を通知するために使用されます。例:
      </p><pre class="programlisting">
CREATE PROCEDURE p (divisor INT)
BEGIN
  IF divisor = 0 THEN
    SIGNAL SQLSTATE '22012';
  END IF;
END;
</pre><p>
        <code class="literal">SIGNAL</code> ステートメントが名前付き条件を使用している場合、その条件は <code class="literal">SIGNAL</code> ステートメントに適用される何らかのスコープ内で宣言される必要があり、また MySQL エラー番号ではなく <code class="literal">SQLSTATE</code> 値を使用して定義される必要があります。例:
      </p><pre class="programlisting">
CREATE PROCEDURE p (divisor INT)
BEGIN
  DECLARE divide_by_zero CONDITION FOR SQLSTATE '22012';
  IF divisor = 0 THEN
    SIGNAL divide_by_zero;
  END IF;
END;
</pre><p>
        その名前付き条件が <code class="literal">SIGNAL</code> ステートメントのスコープ内に存在しない場合は、<code class="literal">Undefined CONDITION</code> エラーが発生します。
      </p><p>
        <code class="literal">SIGNAL</code> が、<code class="literal">SQLSTATE</code> 値ではなく MySQL エラー番号で定義された名前付き条件を参照している場合は、<code class="literal">SIGNAL/RESIGNAL can only use a CONDITION defined with SQLSTATE</code> エラーが発生します。次のステートメントを発行すると、名前付き条件が MySQL エラー番号に関連付けられているため、そのエラーが発生します。
      </p><pre class="programlisting">
DECLARE no_such_table CONDITION FOR 1051;
SIGNAL no_such_table;
</pre><p>
        特定の名前を持つ条件が異なるスコープで複数回宣言されている場合は、もっともローカルなスコープを持つ宣言が適用されます。次のプロシージャーを考えてみます。
      </p><pre class="programlisting">
CREATE PROCEDURE p (divisor INT)
BEGIN
  DECLARE my_error CONDITION FOR SQLSTATE '45000';
  IF divisor = 0 THEN
    BEGIN
      DECLARE my_error CONDITION FOR SQLSTATE '22012';
      SIGNAL my_error;
    END;
  END IF;
  SIGNAL my_error;
END;
</pre><p>
        <code class="literal">divisor</code> が 0 である場合は、最初の <code class="literal">SIGNAL</code> ステートメントが実行されます。もっとも内側の <code class="literal">my_error</code> 条件宣言が適用され、<code class="literal">SQLSTATE</code> <code class="literal">'22012'</code> が発生します。
      </p><p>
        <code class="literal">divisor</code> が 0 でない場合は、2 番目の <code class="literal">SIGNAL</code> ステートメントが実行されます。もっとも外側の <code class="literal">my_error</code> 条件宣言が適用され、<code class="literal">SQLSTATE</code> <code class="literal">'45000'</code> が発生します。
      </p><p>
        条件が発生したときにサーバーがハンドラを選択する方法については、<a class="xref" href="sql-syntax.html#handler-scope" title="13.6.7.6 ハンドラのスコープに関するルール">セクション13.6.7.6「ハンドラのスコープに関するルール」</a>を参照してください。
      </p><p>
        シグナルが例外ハンドラ内で発生する場合があります。
      </p><pre class="programlisting">
CREATE PROCEDURE p ()
BEGIN
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    SIGNAL SQLSTATE VALUE '99999'
      SET MESSAGE_TEXT = 'An error occurred';
  END;
  DROP TABLE no_such_table;
END;
</pre><p>
        <code class="literal">CALL p()</code> が <code class="literal">DROP TABLE</code> ステートメントに達します。<code class="literal">no_such_table</code> という名前のテーブルが存在しないため、エラーハンドラがアクティブ化されます。エラーハンドラは元のエラー (<span class="quote">「<span class="quote">このようなテーブルがない</span>」</span>) を破棄し、<code class="literal">SQLSTATE</code> <code class="literal">'99999'</code> の新しいエラーとメッセージ <code class="literal">An error occurred</code> を作成します。
      </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="signal-condition-information-items"></a>13.6.7.5.1 シグナルの条件情報項目</h5></div></div></div><p>
          次の表は、<code class="literal">SIGNAL</code> (または <code class="literal">RESIGNAL</code>) ステートメントで設定できる診断領域条件情報項目の名前を一覧表示しています。MySQL 拡張である <code class="literal">MYSQL_ERRNO</code> を除き、すべての項目が標準 SQL です。これらの項目の詳細は、<a class="xref" href="sql-syntax.html#diagnostics-area" title="13.6.7.7 MySQL の診断領域">セクション13.6.7.7「MySQL の診断領域」</a>を参照してください。
        </p><pre class="programlisting">
Item Name             Definition
---------             ----------
CLASS_ORIGIN          VARCHAR(64)
SUBCLASS_ORIGIN       VARCHAR(64)
CONSTRAINT_CATALOG    VARCHAR(64)
CONSTRAINT_SCHEMA     VARCHAR(64)
CONSTRAINT_NAME       VARCHAR(64)
CATALOG_NAME          VARCHAR(64)
SCHEMA_NAME           VARCHAR(64)
TABLE_NAME            VARCHAR(64)
COLUMN_NAME           VARCHAR(64)
CURSOR_NAME           VARCHAR(64)
MESSAGE_TEXT          VARCHAR(128)
MYSQL_ERRNO           SMALLINT UNSIGNED
</pre><p>
          文字項目の文字セットは UTF-8 です。
        </p><p>
          <code class="literal">SIGNAL</code> ステートメント内で条件情報項目に <code class="literal">NULL</code> を割り当てることはできません。
        </p><p>
          <code class="literal">SIGNAL</code> ステートメントは直接にか、または <code class="literal">SQLSTATE</code> 値で定義された名前付き条件を参照することによって間接的にかにかかわらず、常に <code class="literal">SQLSTATE</code> 値を指定します。<code class="literal">SQLSTATE</code> 値の最初の 2 文字はそのクラスであり、このクラスによって、その条件情報項目のデフォルト値が決定されます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              クラス = <code class="literal">'00'</code> (成功)
            </p><p>
              不正です。<code class="literal">'00'</code> で始まる <code class="literal">SQLSTATE</code> 値は成功を示すため、<code class="literal">SIGNAL</code> には有効でありません。
            </p></li><li class="listitem"><p>
              クラス = <code class="literal">'01'</code> (警告)
            </p><pre class="programlisting">
MESSAGE_TEXT = 'Unhandled user-defined warning condition';
MYSQL_ERRNO = <code class="literal">ER_SIGNAL_WARN</code>
</pre></li><li class="listitem"><p>
              クラス = <code class="literal">'02'</code> (見つからない)
            </p><pre class="programlisting">
MESSAGE_TEXT = 'Unhandled user-defined not found condition';
MYSQL_ERRNO = <code class="literal">ER_SIGNAL_NOT_FOUND</code>
</pre></li><li class="listitem"><p>
              クラス &gt; <code class="literal">'02'</code> (例外)
            </p><pre class="programlisting">
MESSAGE_TEXT = 'Unhandled user-defined exception condition';
MYSQL_ERRNO = <code class="literal">ER_SIGNAL_EXCEPTION</code>
</pre></li></ul></div><p>
          正当なクラスの場合は、その他の条件情報項目が次のように設定されます。
        </p><pre class="programlisting">
CLASS_ORIGIN = SUBCLASS_ORIGIN = '';
CONSTRAINT_CATALOG = CONSTRAINT_SCHEMA = CONSTRAINT_NAME = '';
CATALOG_NAME = SCHEMA_NAME = TABLE_NAME = COLUMN_NAME = '';
CURSOR_NAME = '';
</pre><p>
          <code class="literal">SIGNAL</code> が実行されたあとにアクセスできるエラー値は、<code class="literal">SIGNAL</code> ステートメントによって発生した <code class="literal">SQLSTATE</code> 値と、<code class="literal">MESSAGE_TEXT</code> および <code class="literal">MYSQL_ERRNO</code> 項目です。これらの値は、次の C API から取得できます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">SQLSTATE</code> 値: <code class="literal">mysql_sqlstate()</code> の呼び出し
            </p></li><li class="listitem"><p>
              <code class="literal">MYSQL_ERRNO</code> 値: <code class="literal">mysql_errno()</code> の呼び出し
            </p></li><li class="listitem"><p>
              <code class="literal">MESSAGE_TEXT</code> 値: <code class="literal">mysql_error()</code> の呼び出し
            </p></li></ul></div><p>
          SQL からは、<code class="literal">SHOW WARNINGS</code> と <code class="literal">SHOW ERRORS</code> からの出力の <code class="literal">Code</code> および <code class="literal">Message</code> カラムに <code class="literal">MYSQL_ERRNO</code> および <code class="literal">MESSAGE_TEXT</code> 値が示されます。
        </p><p>
          診断領域から情報を取得するには、<code class="literal">GET DIAGNOSTICS</code> ステートメントを使用します (<a class="xref" href="sql-syntax.html#get-diagnostics" title="13.6.7.3 GET DIAGNOSTICS 構文">セクション13.6.7.3「GET DIAGNOSTICS 構文」</a>を参照してください)。診断領域については、<a class="xref" href="sql-syntax.html#diagnostics-area" title="13.6.7.7 MySQL の診断領域">セクション13.6.7.7「MySQL の診断領域」</a>を参照してください。
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="signal-effects"></a>13.6.7.5.2 ハンドラ、カーソル、およびステートメントに対するシグナルの影響</h5></div></div></div><p>
          ステートメントの実行に対するシグナルの影響は、そのシグナルのクラスによって異なります。このクラスによって、エラーの重大性が決定されます。MySQL は、<code class="literal">sql_mode</code> システム変数の値を無視します。特に、厳密な SQL モードは問題になりません。MySQL は <code class="literal">IGNORE</code> も無視します。<code class="literal">SIGNAL</code> の目的はユーザーが生成したエラーを明示的に発生させることであるため、シグナルが無視されることはありません。
        </p><p>
          次の説明で、<span class="quote">「<span class="quote">未処理</span>」</span>は、通知された <code class="literal">SQLSTATE</code> 値に対するハンドラが <code class="literal">DECLARE ... HANDLER</code> で定義されていないことを示します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              クラス = <code class="literal">'00'</code> (成功)
            </p><p>
              不正です。<code class="literal">'00'</code> で始まる <code class="literal">SQLSTATE</code> 値は成功を示すため、<code class="literal">SIGNAL</code> には有効でありません。
            </p></li><li class="listitem"><p>
              クラス = <code class="literal">'01'</code> (警告)
            </p><p>
              <code class="literal">warning_count</code> システム変数の値が増やされます。<code class="literal">SHOW WARNINGS</code> がシグナルを示します。<code class="literal">SQLWARNING</code> ハンドラがシグナルをキャッチします。このシグナルが関数内で未処理である場合、ステートメントは終了しません。
            </p></li><li class="listitem"><p>
              クラス = <code class="literal">'02'</code> (見つからない)
            </p><p>
              <code class="literal">NOT FOUND</code> ハンドラがシグナルをキャッチします。カーソルには影響しません。このシグナルが関数内で未処理である場合、ステートメントは終了します。
            </p></li><li class="listitem"><p>
              クラス &gt; <code class="literal">'02'</code> (例外)
            </p><p>
              <code class="literal">SQLEXCEPTION</code> ハンドラがシグナルをキャッチします。このシグナルが関数内で未処理である場合、ステートメントは終了します。
            </p></li><li class="listitem"><p>
              クラス = <code class="literal">'40'</code>
            </p><p>
              通常の例外として処理されます。
            </p></li></ul></div><p>
          例:
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>delimiter //</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE FUNCTION f () RETURNS INT</code></strong>
    -&gt; <strong class="userinput"><code>BEGIN</code></strong>
    -&gt;   <strong class="userinput"><code>SIGNAL SQLSTATE '01234';  -- signal a warning</code></strong>
    -&gt;   <strong class="userinput"><code>RETURN 5;</code></strong>
    -&gt; <strong class="userinput"><code>END//</code></strong>
mysql&gt; <strong class="userinput"><code>delimiter ;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE TABLE t (s1 INT);</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t VALUES (f());</code></strong>
</pre><p>
          結果として、5 を含む行がテーブル <code class="literal">t</code> に挿入されます。通知された警告は、<code class="literal">SHOW WARNINGS</code> で表示できます。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="handler-scope"></a>13.6.7.6 ハンドラのスコープに関するルール</h4></div></div></div><p>
        ストアドプログラムには、そのプログラム内で特定の条件が発生したときに呼び出されるハンドラを含めることができます。各ハンドラの適用性は、プログラム定義の中でのそのハンドラの場所や、そのハンドラが処理する 1 つまたは複数の条件によって異なります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">BEGIN ... END</code> ブロック内で宣言されたハンドラは、そのブロック内でハンドラ宣言のあとにある SQL ステートメントのスコープ内にしかありません。そのハンドラ自体が条件を発生させた場合は、そのハンドラも、そのブロック内で宣言されているほかのどのハンドラもその条件を処理できません。次の例では、ハンドラ <code class="literal">H1</code> と <code class="literal">H2</code> は、ステートメント <em class="replaceable"><code>stmt1</code></em> および <em class="replaceable"><code>stmt2</code></em> によって発生した条件のスコープ内にあります。ただし、<code class="literal">H1</code> も <code class="literal">H2</code> も、<code class="literal">H1</code> または <code class="literal">H2</code> の本体で発生した条件のスコープ内にはありません。
          </p><pre class="programlisting">
BEGIN -- outer block
  DECLARE EXIT HANDLER FOR ...;  -- handler H1
  DECLARE EXIT HANDLER FOR ...;  -- handler H2
  <em class="replaceable"><code>stmt1</code></em>;
  <em class="replaceable"><code>stmt2</code></em>;
END;
</pre></li><li class="listitem"><p>
            ハンドラは、それが宣言されているブロックのスコープ内にしかなく、そのブロックの外部で発生した条件に対してアクティブ化することはできません。次の例では、ハンドラ <code class="literal">H1</code> は内側のブロックにある <em class="replaceable"><code>stmt1</code></em> のスコープ内にありますが、外側のブロックにある <em class="replaceable"><code>stmt2</code></em> のスコープ内にはありません。
          </p><pre class="programlisting">
BEGIN -- outer block
  BEGIN -- inner block
    DECLARE EXIT HANDLER FOR ...;  -- handler H1
    <em class="replaceable"><code>stmt1</code></em>;
  END;
  <em class="replaceable"><code>stmt2</code></em>;
END;
</pre></li><li class="listitem"><p>
            ハンドラは、特定のハンドラまたは一般的なハンドラのどちらかです。特定のハンドラとは、MySQL エラーコード、<code class="literal">SQLSTATE</code> 値、または条件名を処理するためのものです。一般的なハンドラとは、<code class="literal">SQLWARNING</code>、<code class="literal">SQLEXCEPTION</code>、または <code class="literal">NOT FOUND</code> クラス内の条件を処理するためのものです。あとで説明されているように、条件の特定性は条件の優先順位に関連しています。
          </p></li></ul></div><p>
        複数のハンドラを異なるスコープ内で、かつ異なる特定性で宣言できます。たとえば、外側のブロックには特定の MySQL エラーコードハンドラが、また内側のブロックには一般的な <code class="literal">SQLWARNING</code> ハンドラが存在する可能性があります。あるいは、特定の MySQL エラーコードのハンドラと、一般的な <code class="literal">SQLWARNING</code> クラスのハンドラが同じブロック内に存在することもあります。
      </p><p>
        あるハンドラがアクティブ化されるかどうかは、それ自体のスコープや条件値だけでなく、ほかにどのようなハンドラが存在するかによっても異なります。ストアドプログラム内で条件が発生すると、サーバーは、適用可能なハンドラを現在のスコープ (現在の <code class="literal">BEGIN ... END</code> ブロック) 内で検索します。適用可能なハンドラが存在しない場合は、連続した包含する各スコープ (ブロック) 内のハンドラに関して外側に検索を続行します。特定のスコープで適用可能なハンドラを 1 つ以上見つけると、サーバーは、次の条件の優先順位に基づいてそれらのハンドラから選択します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            MySQL エラーコードハンドラは、<code class="literal">SQLSTATE</code> 値ハンドラより優先されます。
          </p></li><li class="listitem"><p>
            <code class="literal">SQLSTATE</code> 値ハンドラは、一般的な <code class="literal">SQLWARNING</code>、<code class="literal">SQLEXCEPTION</code>、または <code class="literal">NOT FOUND</code> ハンドラより優先されます。
          </p></li><li class="listitem"><p>
            <code class="literal">SQLEXCEPTION</code> ハンドラは、<code class="literal">SQLWARNING</code> ハンドラより優先されます。
          </p></li><li class="listitem"><p>
            <code class="literal">NOT FOUND</code> の優先順位は、その条件がどのように発生したかによって異なります。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                通常、<code class="literal">NOT FOUND</code> クラス内の条件は <code class="literal">SQLWARNING</code> または <code class="literal">NOT FOUND</code> ハンドラで処理することができ、その両方が存在する場合は <code class="literal">SQLWARNING</code> ハンドラが優先されます。<code class="literal">NOT FOUND</code> は通常、一連の行をフェッチするために使用されるカーソルがデータセットの最後に達した場合か、または <code class="literal">WHERE</code> 句で行が見つからない <code class="literal">SELECT ... INTO <em class="replaceable"><code>var_list</code></em></code> のインスタンスに対して発生します。
              </p></li><li class="listitem"><p>
                <code class="literal">NOT FOUND</code> 条件が <code class="literal">SIGNAL</code> (または <code class="literal">RESIGNAL</code>) ステートメントによって発生した場合、その条件は <code class="literal">NOT FOUND</code> ハンドラで処理できますが、<code class="literal">SQLWARNING</code> ハンドラでは処理できません。
              </p></li></ul></div></li><li class="listitem"><p>
            同じ優先順位を持つ適用可能なハンドラが複数存在する可能性があります。たとえば、ステートメントが、それぞれに対してエラー固有のハンドラが存在する、異なるエラーコードを持つ複数の警告を生成する可能性があります。この場合は、サーバーがどのハンドラをアクティブ化するかの選択は不確定であり、その条件が発生した状況に応じて変わることがあります。
          </p></li></ul></div><p>
        ハンドラ選択ルールの 1 つの側面として、複数の適用可能なハンドラが異なるスコープ内に存在する場合は、もっともローカルなスコープを持つハンドラが外側のスコープにあるハンドラより (それが、より具体的な条件のハンドラであっても) 優先される点があります。
      </p><p>
        ある条件が発生したときに適切なハンドラが存在しない場合、実行されるアクションはその条件のクラスによって異なります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">SQLEXCEPTION</code> 条件の場合は、<code class="literal">EXIT</code> ハンドラが存在するかのように、ストアドプログラムはその条件を発生させたステートメントで終了します。そのプログラムが別のストアドプログラムから呼び出されていた場合は、呼び出し元プログラムが、独自のハンドラに適用されるハンドラ選択ルールを使用してその条件を処理します。
          </p></li><li class="listitem"><p>
            <code class="literal">SQLWARNING</code> 条件の場合は、<code class="literal">CONTINUE</code> ハンドラが存在するかのように、プログラムは実行を続行します。
          </p></li><li class="listitem"><p>
            <code class="literal">NOT FOUND</code> 条件では、その条件が正常に発生した場合、アクションは <code class="literal">CONTINUE</code> です。<code class="literal">SIGNAL</code> または <code class="literal">RESIGNAL</code> によって発生した場合、アクションは <code class="literal">EXIT</code> です。
          </p></li></ul></div><p>
        次の例は、MySQL によってハンドラ選択ルールがどのように適用されるかを示しています。
      </p><p>
        次のプロシージャーには 2 つのハンドラが含まれています。つまり、存在しないテーブルを削除しようとする試みに対して発生する特定の <code class="literal">SQLSTATE</code> 値 (<code class="literal">'42S02'</code>) 用に 1 つと、一般的な <code class="literal">SQLEXCEPTION</code> クラス用に 1 つです。
      </p><pre class="programlisting">
CREATE PROCEDURE p1()
BEGIN
  DECLARE CONTINUE HANDLER FOR SQLSTATE '42S02'
    SELECT 'SQLSTATE handler was activated' AS msg;
  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    SELECT 'SQLEXCEPTION handler was activated' AS msg;

  DROP TABLE test.t;
END;
</pre><p>
        両方のハンドラが同じブロック内で宣言され、同じスコープを持っています。ただし、<code class="literal">SQLSTATE</code> ハンドラは <code class="literal">SQLEXCEPTION</code> ハンドラより優先されるため、テーブル <code class="literal">t</code> が存在しない場合、<code class="literal">DROP TABLE</code> ステートメントは <code class="literal">SQLSTATE</code> ハンドラをアクティブ化する条件を発生させます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CALL p1();</code></strong>
+--------------------------------+
| msg                            |
+--------------------------------+
| SQLSTATE handler was activated |
+--------------------------------+
</pre><p>
        次のプロシージャーにも、同じ 2 つのハンドラが含まれています。ただし、今回は、<code class="literal">DROP TABLE</code> ステートメントと <code class="literal">SQLEXCEPTION</code> ハンドラが <code class="literal">SQLSTATE</code> ハンドラに対して内側のブロック内にあります。
      </p><pre class="programlisting">
CREATE PROCEDURE p2()
BEGIN -- outer block
    DECLARE CONTINUE HANDLER FOR SQLSTATE '42S02'
      SELECT 'SQLSTATE handler was activated' AS msg;
  BEGIN -- inner block
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
      SELECT 'SQLEXCEPTION handler was activated' AS msg;

    DROP TABLE test.t; -- occurs within inner block
  END;
END;
</pre><p>
        この場合は、条件が発生した場所に対してよりローカルなハンドラが優先されます。<code class="literal">SQLSTATE</code> ハンドラより一般的であるにもかかわらず、<code class="literal">SQLEXCEPTION</code> ハンドラがアクティブ化されます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CALL p2();</code></strong>
+------------------------------------+
| msg                                |
+------------------------------------+
| SQLEXCEPTION handler was activated |
+------------------------------------+
</pre><p>
        次のプロシージャーでは、ハンドラの 1 つが、<code class="literal">DROP TABLE</code> ステートメントのスコープに対して内側のブロック内で宣言されています。
      </p><pre class="programlisting">
CREATE PROCEDURE p3()
BEGIN -- outer block
  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    SELECT 'SQLEXCEPTION handler was activated' AS msg;
  BEGIN -- inner block
    DECLARE CONTINUE HANDLER FOR SQLSTATE '42S02'
      SELECT 'SQLSTATE handler was activated' AS msg;
  END;

  DROP TABLE test.t; -- occurs within outer block
END;
</pre><p>
        もう一方のハンドラが <code class="literal">DROP TABLE</code> によって発生した条件のスコープ内にないため、<code class="literal">SQLEXCEPTION</code> ハンドラのみが適用されます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CALL p3();</code></strong>
+------------------------------------+
| msg                                |
+------------------------------------+
| SQLEXCEPTION handler was activated |
+------------------------------------+
</pre><p>
        次のプロシージャーでは、両方のハンドラが、<code class="literal">DROP TABLE</code> ステートメントのスコープに対して内側のブロック内で宣言されています。
      </p><pre class="programlisting">
CREATE PROCEDURE p4()
BEGIN -- outer block
  BEGIN -- inner block
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
      SELECT 'SQLEXCEPTION handler was activated' AS msg;
    DECLARE CONTINUE HANDLER FOR SQLSTATE '42S02'
      SELECT 'SQLSTATE handler was activated' AS msg;
  END;

  DROP TABLE test.t; -- occurs within outer block
END;
</pre><p>
        <code class="literal">DROP TABLE</code> のスコープ内にないため、どちらのハンドラも適用されません。このステートメントによって発生した条件は未処理になり、プロシージャーをエラーで終了させます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CALL p4();</code></strong>
ERROR 1051 (42S02): Unknown table 'test.t'
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="diagnostics-area"></a>13.6.7.7 MySQL の診断領域</h4></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-syntax.html#diagnostics-area-structure">13.6.7.7.1 診断領域の構造</a></span></dt><dt><span class="section"><a href="sql-syntax.html#diagnostics-area-information-items">13.6.7.7.2 診断領域の情報項目</a></span></dt><dt><span class="section"><a href="sql-syntax.html#diagnostics-area-populating">13.6.7.7.3 診断領域が移入される方法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#diagnostics-area-system-variables">13.6.7.7.4 診断領域関連のシステム変数</a></span></dt></dl></div><p>
        SQL ステートメントは、診断領域を移入する診断情報を生成します。標準 SQL には、ネスト化された実行のコンテキストごとの診断領域を含んだ、診断領域スタックがあります。標準 SQL はまた、条件ハンドラの実行中に 2 番目の診断領域を参照するための <code class="literal">GET STACKED DIAGNOSTICS</code> 構文もサポートしています。MySQL は、MySQL 5.7 まで <code class="literal">STACKED</code> キーワードをサポートしていません。MySQL 5.6 では、診断領域への書き込みを行なった最新のステートメントからの情報を含む 1 つの診断領域が存在します。
      </p><p>
        このセクションでは、MySQL の診断領域の構造、MySQL によって認識される情報項目、およびステートメントで診断領域をクリアおよび設定する方法について説明します。
      </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="diagnostics-area-structure"></a>13.6.7.7.1 診断領域の構造</h5></div></div></div><p>
          診断領域には、次の 2 種類の情報が含まれています。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              発生した条件の数や、影響を受けた行数などのステートメント情報。
            </p></li><li class="listitem"><p>
              エラーコードやメッセージなどの条件情報。ステートメントが複数の条件を発生させた場合、診断領域のこの部分には条件ごとの条件領域が含まれています。ステートメントがどの条件も発生させない場合、診断領域のこの部分は空です。
            </p></li></ul></div><p>
          3 つの条件を生成するステートメントの場合、診断領域には、次のようなステートメント情報と条件情報が含まれています。
        </p><pre class="programlisting">
Statement information:
  row count
  ... other statement information items ...
Condition area list:
  Condition area 1:
    error code for condition 1
    error message for condition 1
    ... other condition information items ...
  Condition area 2:
    error code for condition 2:
    error message for condition 2
    ... other condition information items ...
  Condition area 3:
    error code for condition 3
    error message for condition 3
    ... other condition information items ...
</pre></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="diagnostics-area-information-items"></a>13.6.7.7.2 診断領域の情報項目</h5></div></div></div><p>
          診断領域には、ステートメント情報と条件情報項目が含まれています。数値項目は整数です。文字項目の文字セットは UTF-8 です。どの項目も <code class="literal">NULL</code> にはできません。診断領域を移入するステートメントによってステートメントまたは条件項目が設定されていない場合、その値は、その項目のデータ型に応じて 0 または空の文字列になります。
        </p><p>
          診断領域のステートメント情報の部分には、次の項目が含まれています。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">NUMBER</code>: 情報が含まれている条件領域の数を示す整数。
            </p></li><li class="listitem"><p>
              <code class="literal">ROW_COUNT</code>: このステートメントによって影響を受けた行数を示す整数。<code class="literal">ROW_COUNT</code> には、<code class="literal">ROW_COUNT()</code> 関数と同じ値が含まれています (<a class="xref" href="functions.html#information-functions" title="12.14 情報関数">セクション12.14「情報関数」</a>を参照してください)。
            </p></li></ul></div><p>
          診断領域の条件情報の部分には、条件ごとの条件領域が含まれています。条件領域には、1 から <code class="literal">NUMBER</code> ステートメント条件項目の値の番号が付けられています。<code class="literal">NUMBER</code> が 0 である場合、条件領域は存在しません。
        </p><p>
          各条件領域には、次のリスト内の項目が含まれています。MySQL 拡張である <code class="literal">MYSQL_ERRNO</code> を除き、すべての項目が標準 SQL です。これらの定義は、シグナル以外によって (つまり、<code class="literal">SIGNAL</code> または <code class="literal">RESIGNAL</code> ステートメントによって) 生成された条件に適用されます。シグナル以外の条件の場合、MySQL は、常に空であるとは示されていない条件項目のみを移入します。条件領域に対するシグナルの影響については、あとで説明されています。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">CLASS_ORIGIN</code> <code class="literal">RETURNED_SQLSTATE</code> 値のクラスを含む文字列。<code class="literal">RETURNED_SQLSTATE</code> 値が SQL 標準のドキュメント ISO 9075-2 (セクション 24.1、SQLSTATE) で定義されているクラス値で始まる場合、<code class="literal">CLASS_ORIGIN</code> は <code class="literal">'ISO 9075'</code> です。それ以外の場合、<code class="literal">CLASS_ORIGIN</code> は <code class="literal">'MySQL'</code> です。
            </p></li><li class="listitem"><p>
              <code class="literal">SUBCLASS_ORIGIN</code>: <code class="literal">RETURNED_SQLSTATE</code> 値のサブクラスを含む文字列。<code class="literal">CLASS_ORIGIN</code> が <code class="literal">'ISO 9075'</code> であるか、または <code class="literal">RETURNED_SQLSTATE</code> が <code class="literal">'000'</code> で終わる場合、<code class="literal">SUBCLASS_ORIGIN</code> は <code class="literal">'ISO 9075'</code> です。それ以外の場合、<code class="literal">SUBCLASS_ORIGIN</code> は <code class="literal">'MySQL'</code> です。
            </p></li><li class="listitem"><p>
              <code class="literal">RETURNED_SQLSTATE</code>: この条件の <code class="literal">SQLSTATE</code> 値を示す文字列。
            </p></li><li class="listitem"><p>
              <code class="literal">MESSAGE_TEXT</code>: この条件のエラーメッセージを示す文字列。
            </p></li><li class="listitem"><p>
              <code class="literal">MYSQL_ERRNO</code>: この条件の MySQL エラーコードを示す整数。
            </p></li><li class="listitem"><p>
              <code class="literal">CONSTRAINT_CATALOG</code>、<code class="literal">CONSTRAINT_SCHEMA</code>、<code class="literal">CONSTRAINT_NAME</code>: 違反した制約のカタログ、スキーマ、および名前を示す文字列。これらは常に空です。
            </p></li><li class="listitem"><p>
              <code class="literal">CATALOG_NAME</code>、<code class="literal">SCHEMA_NAME</code>、<code class="literal">TABLE_NAME</code>、<code class="literal">COLUMN_NAME</code>: この条件に関連したカタログ、スキーマ、テーブル、およびカラムを示す文字列。これらは常に空です。
            </p></li><li class="listitem"><p>
              <code class="literal">CURSOR_NAME</code>: カーソル名を示す文字列。これは常に空です。
            </p></li></ul></div><p>
          <code class="literal">RETURNED_SQLSTATE</code>、<code class="literal">MESSAGE_TEXT</code>、および <code class="literal">MYSQL_ERRNO</code> 値の特定のエラーについては、<a class="xref" href="error-handling.html#error-messages-server" title="B.3 サーバーのエラーコードおよびメッセージ">セクションB.3「サーバーのエラーコードおよびメッセージ」</a>を参照してください。
        </p><p>
          <code class="literal">SIGNAL</code> (または <code class="literal">RESIGNAL</code>) ステートメントが診断領域を移入する場合、その <code class="literal">SET</code> 句は、<code class="literal">RETURNED_SQLSTATE</code> を除く任意の条件情報項目に、その項目のデータ型に対して正当な任意の値を割り当てることができます。<code class="literal">SIGNAL</code> はまた、<code class="literal">RETURNED_SQLSTATE</code> 値も設定しますが、その <code class="literal">SET</code> 句で直接設定するわけではありません。その値は、<code class="literal">SIGNAL</code> ステートメントの <code class="literal">SQLSTATE</code> 引数から取得されます。
        </p><p>
          <code class="literal">SIGNAL</code> は、ステートメント情報項目も設定します。<code class="literal">NUMBER</code> を 1 に設定し、<code class="literal">ROW_COUNT</code> については、エラーの場合は -1、それ以外の場合は 0 に設定します。
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="diagnostics-area-populating"></a>13.6.7.7.3 診断領域が移入される方法</h5></div></div></div><p>
          診断以外のほとんどの SQL ステートメントは診断領域を自動的に移入しますが、その内容は <code class="literal">SIGNAL</code> および <code class="literal">RESIGNAL</code> ステートメントを使用して明示的に設定できます。診断領域は、特定の項目を抽出するために <code class="literal">GET DIAGNOSTICS</code> を使用して、あるいは条件またはエラーを確認するために <code class="literal">SHOW WARNINGS</code> または <code class="literal">SHOW ERRORS</code> を使用して検査できます。
        </p><p>
          SQL ステートメントは、次のように診断領域をクリアおよび設定します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              サーバーは、ステートメントを解析してからその実行を開始するとき、テーブルを使用する診断以外のステートメントについては診断領域をクリアします。診断ステートメントは、診断領域をクリアしません (<code class="literal">SHOW WARNINGS</code>、<code class="literal">SHOW ERRORS</code>、<code class="literal">GET DIAGNOSTICS</code>)。
            </p></li><li class="listitem"><p>
              ステートメントが条件を発生させた場合は、以前のステートメントに属する条件の診断領域がクリアされます。例外として、<code class="literal">GET DIAGNOSTICS</code> および <code class="literal">RESIGNAL</code> によって発生した条件は、診断領域にその領域をクリアすることなく追加されます。
            </p></li></ul></div><p>
          そのため、通常は実行開始時に診断領域をクリアしないステートメントであっても、そのステートメントが条件を発生させた場合は診断領域をクリアします。
        </p><p>
          次の例は、診断領域に対するさまざまなステートメントの影響を、<code class="literal">SHOW WARNINGS</code> を使用して、そこに格納されている条件に関する情報を表示することによって示しています。
        </p><p>
          次の <code class="literal">DROP TABLE</code> ステートメントはテーブルを使用するため、診断領域をクリアし、条件が発生した場合はそれを移入します。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>DROP TABLE IF EXISTS test.no_such_table;</code></strong>
Query OK, 0 rows affected, 1 warning (0.01 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+-------+------+------------------------------------+
| Level | Code | Message                            |
+-------+------+------------------------------------+
| Note  | 1051 | Unknown table 'test.no_such_table' |
+-------+------+------------------------------------+
1 row in set (0.00 sec)
</pre><p>
          次の <code class="literal">SET</code> ステートメントはテーブルを使用せず、警告も生成しないため、診断領域を変更されないままにします。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET @x = 1;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+-------+------+------------------------------------+
| Level | Code | Message                            |
+-------+------+------------------------------------+
| Note  | 1051 | Unknown table 'test.no_such_table' |
+-------+------+------------------------------------+
1 row in set (0.00 sec)
</pre><p>
          次の <code class="literal">SET</code> ステートメントはエラーを生成するため、診断領域をクリアして移入します。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET @x = @@x;</code></strong>
ERROR 1193 (HY000): Unknown system variable 'x'

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+-------+------+-----------------------------+
| Level | Code | Message                     |
+-------+------+-----------------------------+
| Error | 1193 | Unknown system variable 'x' |
+-------+------+-----------------------------+
1 row in set (0.00 sec)
</pre><p>
          前の <code class="literal">SET</code> ステートメントは 1 つの条件を生成したため、1 がこの時点での <code class="literal">GET DIAGNOSTICS</code> の唯一の有効な条件番号です。次のステートメントは 2 の条件番号を使用しています。これにより、診断領域にその領域をクリアすることなく追加される警告が生成されます。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>GET DIAGNOSTICS CONDITION 2 @p = MESSAGE_TEXT;</code></strong>
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+-------+------+------------------------------+
| Level | Code | Message                      |
+-------+------+------------------------------+
| Error | 1193 | Unknown system variable 'xx' |
| Error | 1753 | Invalid condition number     |
+-------+------+------------------------------+
2 rows in set (0.00 sec)
</pre><p>
          これで、診断領域には 2 つの条件が存在するようになったため、同じ <code class="literal">GET DIAGNOSTICS</code> ステートメントが成功します。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>GET DIAGNOSTICS CONDITION 2 @p = MESSAGE_TEXT;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT @p;</code></strong>
+--------------------------+
| @p                       |
+--------------------------+
| Invalid condition number |
+--------------------------+
1 row in set (0.01 sec)
</pre></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="diagnostics-area-system-variables"></a>13.6.7.7.4 診断領域関連のシステム変数</h5></div></div></div><p>
          特定のシステム変数が診断領域のいくつかの側面を制御するか、またはそれに関連しています。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">max_error_count</code> は、診断領域内の条件領域の数を制御します。これより多い条件が発生した場合、MySQL は、超過した条件に関する情報を暗黙のうちに破棄します。(<code class="literal">RESIGNAL</code> によって追加された条件は、常に追加されます。空きを作るために、古い条件が必要に応じて破棄されます。)
            </p></li><li class="listitem"><p>
              <code class="literal">warning_count</code> は、発生した条件の数を示します。これには、エラー、警告、および注意が含まれます。通常、<code class="literal">NUMBER</code> と <code class="literal">warning_count</code> は同じです。ただし、生成された条件の数が <code class="literal">max_error_count</code> を超えると、診断領域にはそれ以上の条件が格納されないため、<code class="literal">warning_count</code> の値が引き続き増えるのに対して、<code class="literal">NUMBER</code> は <code class="literal">max_error_count</code> に上限が設定されたままになります。
            </p></li><li class="listitem"><p>
              <code class="literal">error_count</code> は、発生したエラーの数を示します。この値には<span class="quote">「<span class="quote">見つからない</span>」</span>と例外条件が含まれますが、警告と注意は除外されます。<code class="literal">warning_count</code> と同様に、その値は <code class="literal">max_error_count</code> を超えることができます。
            </p></li><li class="listitem"><p>
              <code class="literal">sql_notes</code> システム変数が 0 に設定されている場合、注意は格納されず、<code class="literal">warning_count</code> も増分しません。
            </p></li></ul></div><p>
          例: <code class="literal">max_error_count</code> が 10 である場合、診断領域には最大 10 個の条件領域を含めることができます。ステートメントが 20 個の条件を発生させ、そのうちの 12 個がエラーであるとします。その場合、診断領域には最初の 10 個の条件が含まれ、<code class="literal">NUMBER</code> は 10、<code class="literal">warning_count</code> は 20、<code class="literal">error_count</code> は 12 です。
        </p><p>
          <code class="literal">max_error_count</code> の値を変更しても、次に診断領域を変更しようとするまでは何の効果もありません。診断領域に 10 個の条件領域が含まれているときに <code class="literal">max_error_count</code> が 5 に設定された場合、その診断領域のサイズまたは内容への即座の影響は何もありません。
        </p><p>
          MySQL 5.6 より前は、ステートメント情報項目を直接使用できません。<code class="literal">ROW_COUNT</code> は、<code class="literal">ROW_COUNT()</code> 関数を呼び出すことによって取得できます。<code class="literal">NUMBER</code> は、<code class="literal">warning_count</code> システム変数の値によって近似されます。ただし、<code class="literal">NUMBER</code> が <code class="literal">max_error_count</code> の値に上限が設定されるのに対して、<code class="literal">warning_count</code> には上限がありません。
        </p></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sql-syntax-server-administration"></a>13.7 データベース管理ステートメント</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-syntax.html#account-management-sql">13.7.1 アカウント管理ステートメント</a></span></dt><dt><span class="section"><a href="sql-syntax.html#table-maintenance-sql">13.7.2 テーブル保守ステートメント</a></span></dt><dt><span class="section"><a href="sql-syntax.html#plugin-sql">13.7.3 プラグインおよびユーザー定義関数ステートメント</a></span></dt><dt><span class="section"><a href="sql-syntax.html#set-statement">13.7.4 SET 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show">13.7.5 SHOW 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#other-administrative-sql">13.7.6 その他の管理ステートメント</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="account-management-sql"></a>13.7.1 アカウント管理ステートメント</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-syntax.html#alter-user">13.7.1.1 ALTER USER 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-user">13.7.1.2 CREATE USER 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-user">13.7.1.3 DROP USER 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#grant">13.7.1.4 GRANT 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#rename-user">13.7.1.5 RENAME USER 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#revoke">13.7.1.6 REVOKE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#set-password">13.7.1.7 SET PASSWORD 構文</a></span></dt></dl></div><p>
      MySQL アカウント情報は、<code class="literal">mysql</code> データベースのテーブルに格納されています。このデータベースとアクセス制御システムについては、<a class="xref" href="server-administration.html" title="第 5 章 MySQL サーバーの管理">第5章「<i>MySQL サーバーの管理</i>」</a>で広範囲にわたって説明されています。詳細は、この章を参照するようにしてください。
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        MySQL の一部のリリースでは、新たな権限や機能を追加するために付与テーブルの構造に変更を加えているものもあります。すべての新しい機能を確実に活用できるようにするには、新しいバージョンの MySQL に更新するときに常に付与テーブルを更新して、最新の構造を持つようにします。<a class="xref" href="programs.html#mysql-upgrade" title="4.4.7 mysql_upgrade — MySQL テーブルのチェックとアップグレード">セクション4.4.7「<span class="command"><strong>mysql_upgrade</strong></span> — MySQL テーブルのチェックとアップグレード」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="alter-user"></a>13.7.1.1 ALTER USER 構文</h4></div></div></div><a class="indexterm" name="idm139979079976528"></a><a class="indexterm" name="idm139979079975216"></a><a class="indexterm" name="idm139979079973040"></a><pre class="programlisting">
ALTER USER <em class="replaceable"><code>user_specification</code></em> [, <em class="replaceable"><code>user_specification</code></em>] ...

<em class="replaceable"><code>user_specification</code></em>:
    <em class="replaceable"><code>user</code></em> PASSWORD EXPIRE
</pre><p>
        <code class="literal">ALTER USER</code> ステートメントは、MySQL アカウントを変更します。これを使用するには、<code class="literal">mysql</code> データベースに対するグローバルな <code class="literal">CREATE USER</code> 権限または <code class="literal">INSERT</code> 権限が必要です。
      </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
          <code class="literal">ALTER USER</code> は、MySQL 5.6.6 で追加されました。ただし、5.6.6 で <code class="literal">ALTER USER</code> は <code class="literal">Password</code> カラムも空の文字列に設定するため、このステートメントは 5.6.7 まで使用しないでください。
        </p></div><p>
        各アカウントについて、<code class="literal">ALTER USER</code> はそのパスワードを期限切れにします。例:
      </p><pre class="programlisting">
ALTER USER 'jeffrey'@'localhost' PASSWORD EXPIRE;
</pre><p>
        各アカウント名には、<a class="xref" href="security.html#account-names" title="6.2.3 アカウント名の指定">セクション6.2.3「アカウント名の指定」</a>で説明されている形式が使用されます。アカウント名のユーザー名の部分のみを指定した場合は、<code class="literal">'%'</code> のホスト名の部分が使用されます。
      </p><p>
        アカウントのパスワードを期限切れにすると、<code class="literal">mysql.user</code> テーブルの対応する行に影響を与えます。サーバーは、<code class="literal">password_expired</code> カラムを <code class="literal">'Y'</code> に設定します。
      </p><p>
        アカウントのパスワードが期限切れになった場合は、クライアントセッションが制限モードで動作します。制限モードでは、ユーザーが <code class="literal">SET PASSWORD</code> ステートメントを発行してアカウントの新しいパスワードを確立するまで、そのセッションで実行された操作はエラーになります。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT 1;</code></strong>
ERROR 1820 (HY000): You must SET PASSWORD before executing this statement

mysql&gt; <strong class="userinput"><code>SET PASSWORD = PASSWORD('<em class="replaceable"><code>new_password</code></em>');</code></strong>
Query OK, 0 rows affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>SELECT 1;</code></strong>
+---+
| 1 |
+---+
| 1 |
+---+
1 row in set (0.00 sec)
</pre><p>
        MySQL 5.6.8 の時点では、この制限された動作モードでは <code class="literal">SET</code> ステートメントが許可されます。これは、そのアカウントのパスワードが、<code class="literal">old_passwords</code> をそのデフォルトとは異なる値に設定する必要のあるハッシュ形式を使用している場合に役立ちます。
      </p><p>
        管理ユーザーがアカウントのパスワードをリセットすることも可能ですが、そのアカウントの既存のセッションはすべて制限されたままになります。ステートメントを正常に実行するには、そのアカウントを使用しているクライアントは切断し、再接続する必要があります。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">SET PASSWORD</code> を使用してパスワードをその現在の値に設定することによって、パスワードを<span class="quote">「<span class="quote">リセット</span>」</span>できます。適切なポリシーとして、別のパスワードを選択することをお勧めします。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="create-user"></a>13.7.1.2 CREATE USER 構文</h4></div></div></div><a class="indexterm" name="idm139979079937008"></a><a class="indexterm" name="idm139979079935696"></a><a class="indexterm" name="idm139979079933520"></a><pre class="programlisting">
CREATE USER <em class="replaceable"><code>user_specification</code></em> [, <em class="replaceable"><code>user_specification</code></em>] ...

<em class="replaceable"><code>user_specification</code></em>:
    <em class="replaceable"><code>user</code></em>
    [
      | IDENTIFIED WITH <em class="replaceable"><code>auth_plugin</code></em> [AS '<em class="replaceable"><code>auth_string</code></em>']
        IDENTIFIED BY [PASSWORD] '<em class="replaceable"><code>password</code></em>'
    ]
</pre><p>
        <code class="literal">CREATE USER</code> ステートメントは、新しい MySQL アカウントを作成します。すでに存在するアカウントに対しては、エラーが発生します。このステートメントを使用するには、<code class="literal">mysql</code> データベースに対するグローバルな <code class="literal">CREATE USER</code> 権限または <code class="literal">INSERT</code> 権限が必要です。各アカウントについて、<code class="literal">CREATE USER</code> は、権限のない新しい行を <code class="literal">mysql.user</code> テーブル内に作成し、そのアカウントに認証プラグインを割り当てます。使用されている構文に応じて、<code class="literal">CREATE USER</code> はそのアカウントにパスワードも割り当てる可能性があります。
      </p><p>
        各 <em class="replaceable"><code>user_specification</code></em> 句は、アカウント名と、そのアカウントを使用するクライアントの認証方法に関する情報で構成されます。<code class="literal">CREATE USER</code> 構文のこの部分は <code class="literal">GRANT</code> と共有されるため、ここでの説明は <code class="literal">GRANT</code> にも適用されます。
      </p><p>
        各アカウント名には、<a class="xref" href="security.html#account-names" title="6.2.3 アカウント名の指定">セクション6.2.3「アカウント名の指定」</a>で説明されている形式が使用されます。例:
      </p><pre class="programlisting">
CREATE USER 'jeffrey'@'localhost' IDENTIFIED BY 'mypass';
</pre><p>
        アカウント名のユーザー名の部分のみを指定した場合は、<code class="literal">'%'</code> のホスト名の部分が使用されます。
      </p><p>
        サーバーは、ユーザー指定句にプラグインを指定するための <code class="literal">IDENTIFIED WITH</code> またはパスワードを指定するための <code class="literal">IDENTIFIED BY</code> が含まれているかどうかに応じて、各アカウントに認証プラグインとパスワードを次のように割り当てます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">IDENTIFIED WITH</code> を指定すると、サーバーは指定されたプラグインを割り当てますが、そのアカウントにパスワードはありません。
          </p></li><li class="listitem"><p>
            <code class="literal">IDENTIFIED BY</code> を指定すると、サーバーはプラグインを暗黙的に割り当て、さらに指定されたパスワードを割り当てます。
          </p></li><li class="listitem"><p>
            <code class="literal">IDENTIFIED WITH</code> と <code class="literal">IDENTIFIED BY</code> のどちらも指定しない場合、サーバーはプラグインを暗黙的に割り当てますが、そのアカウントにパスワードはありません。
          </p></li></ul></div><p>
        アカウントにパスワードがない場合は、そのアカウントの <code class="literal">mysql.user</code> テーブル行内の <code class="literal">Password</code> カラムが空のままになります。これはセキュアではありません。パスワードを設定するには、<code class="literal">SET PASSWORD</code> を使用します。<a class="xref" href="sql-syntax.html#set-password" title="13.7.1.7 SET PASSWORD 構文">セクション13.7.1.7「SET PASSWORD 構文」</a>を参照してください。
      </p><p>
        認証プラグインの暗黙的な割り当てでは、サーバーは次のルールを使用します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            MySQL 5.6.6 の時点では、サーバーはそのアカウントにデフォルトのプラグインを割り当てます。このプラグインが、そのアカウントの <code class="literal">mysql.user</code> テーブル行内の <code class="literal">plugin</code> カラムの値になります。デフォルトのプラグインは、サーバーの起動時に <code class="option">--default-authentication-plugin</code> オプションがほかの値に設定されないかぎり、<code class="literal">mysql_native_password</code> です。
          </p></li><li class="listitem"><p>
            MySQL 5.6.6 より前は、サーバーはそのアカウントにプラグインを割り当てません。そのアカウントの <code class="literal">mysql.user</code> テーブル行内の <code class="literal">plugin</code> カラムが空のままになります。
          </p></li></ul></div><p>
        特定のアカウントを使用するクライアント接続の場合は、サーバーがそのアカウントに割り当てられた認証プラグインを呼び出すと、クライアントは、そのプラグインが実装している認証方法によって要求される資格証明を指定する必要があります。サーバーが (アカウントの作成時または接続時に) そのプラグインを見つけることができない場合は、エラーが発生します。
      </p><p>
        アカウントの <code class="literal">mysql.user</code> テーブル行に空以外の <code class="literal">plugin</code> カラムが含まれている場合:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            サーバーは、指定されたプラグインを使用してクライアントの接続試行を認証します。
          </p></li><li class="listitem"><p>
            <code class="literal">SET PASSWORD</code> を <code class="literal">PASSWORD()</code> とともに使用したアカウントのパスワードへの変更は、<code class="literal">PASSWORD()</code> で適切なパスワードハッシュ方式が使用されるように、<code class="literal">old_passwords</code> システム変数が認証プラグインに必要な値に設定された状態で実行する必要があります。プラグインが <code class="literal">mysql_old_password</code> である場合は、<code class="literal">SET PASSWORD</code> を、<code class="literal">old_passwords</code> の値には関係なく 4.1 より前のパスワードハッシュを使用する <code class="literal">OLD_PASSWORD()</code> とともに使用してパスワードを変更することもできます。
          </p></li></ul></div><p>
        アカウントの <code class="literal">mysql.user</code> テーブル行に空の <code class="literal">plugin</code> カラムが含まれている場合:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            サーバーは、<code class="literal">Password</code> カラムに格納されているパスワードのハッシュ形式に応じて、<code class="literal">mysql_native_password</code> または <code class="literal">mysql_old_password</code> 認証プラグインを使用してクライアントの接続試行を認証します。
          </p></li><li class="listitem"><p>
            <code class="literal">SET PASSWORD</code> を使用したアカウントのパスワードへの変更は、<code class="literal">old_passwords</code> が 4.1 または 4.1 より前のパスワードハッシュを示す、それぞれ 0 または 1 に設定された状態で <code class="literal">PASSWORD()</code> とともに、あるいは <code class="literal">old_passwords</code> の値には関係なく 4.1 より前のパスワードハッシュを使用する <code class="literal">OLD_PASSWORD()</code> とともに実行できます。
          </p></li></ul></div><p>
        <code class="literal">CREATE USER</code> の例:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            アカウントの認証プラグインを指定するには、<code class="literal">IDENTIFIED WITH <em class="replaceable"><code>auth_plugin</code></em></code> を使用します。プラグイン名は、引用符で囲まれた文字列リテラルまたは引用符で囲まれていない名前にすることができます。<code class="literal">'<em class="replaceable"><code>auth_string</code></em>'</code> は、プラグインに渡すオプションの引用符で囲まれた文字列リテラルです。その文字列の意味はプラグインによって解釈されるため、その形式はプラグイン固有です。特定のプラグインが受け入れる認証文字列の値 (存在する場合) については、そのプラグインのドキュメントを参照してください。
          </p><pre class="programlisting">
CREATE USER 'jeffrey'@'localhost' IDENTIFIED WITH mysql_native_password;
</pre><p>
            サーバーは、そのアカウントに指定された認証プラグインを割り当てますが、パスワードは割り当てません。クライアントは、接続時にパスワードを指定する必要がありません。ただし、パスワードのないアカウントはセキュアではありません。アカウントが確実に特定の認証プラグインを使用し、かつ対応するハッシュ形式を持つパスワードが設定されるようにするには、<code class="literal">IDENTIFIED WITH</code> でプラグインを明示的に指定したあと、<code class="literal">SET PASSWORD</code> を使用してパスワードを設定します。
          </p><pre class="programlisting">
CREATE USER 'jeffrey'@'localhost' IDENTIFIED WITH mysql_native_password;
SET old_passwords = 0;
SET PASSWORD FOR 'jeffrey'@'localhost' = PASSWORD('mypass');
</pre><p>
            <code class="literal">SET PASSWORD</code> を <code class="literal">PASSWORD()</code> とともに使用したアカウントのパスワードへの変更は、<code class="literal">PASSWORD()</code> で適切なパスワードハッシュ方式が使用されるように、<code class="literal">old_passwords</code> システム変数がアカウントの認証プラグインに必要な値に設定された状態で実行する必要があります。そのため、代わりに <code class="literal">sha256_password</code> または <code class="literal">mysql_old_password</code> プラグインを使用するには、<code class="literal">CREATE USER</code> ステートメントでそのプラグインを指定し、<code class="literal">SET PASSWORD</code> を使用する前に <code class="literal">old_passwords</code> をそれぞれ 2 または 1 に設定します。(<code class="literal">mysql_old_password</code> の使用はお勧めできません。これは非推奨であり、そのサポートは将来の MySQL リリースで削除される予定です。) 
          </p></li><li class="listitem"><p>
            アカウントの作成時にアカウントのパスワードを指定するには、<code class="literal">IDENTIFIED BY</code> をプレーンテキストのパスワードのリテラル値とともに使用します。
          </p><pre class="programlisting">
CREATE USER 'jeffrey'@'localhost' IDENTIFIED BY 'mypass';
</pre><p>
            サーバーは、前に説明したようにそのアカウントに認証プラグインを暗黙的に割り当て、さらに特定のパスワードを割り当てます。クライアントは、接続時に特定のパスワードを指定する必要があります。
          </p><p>
            暗黙的に割り当てられたプラグインが <code class="literal">mysql_native_password</code> である場合は、<code class="literal">old_passwords</code> システム変数が 0 に設定されている必要があります。そうでない場合、<code class="literal">CREATE USER</code> はそのプラグインに必要な形式でパスワードをハッシュしないため、エラーが発生します。
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET old_passwords = 1;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE USER 'jeffrey'@'localhost' IDENTIFIED BY 'mypass';</code></strong>
ERROR 1827 (HY000): The password hash doesn't have the expected
format. Check if the correct password algorithm is being used with
the PASSWORD() function.

mysql&gt; <strong class="userinput"><code>SET old_passwords = 0;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE USER 'jeffrey'@'localhost' IDENTIFIED BY 'mypass';</code></strong>
Query OK, 0 rows affected (0.00 sec)
</pre></li><li class="listitem"><p>
            パスワードのハッシュ値 (パスワードに対して <code class="literal">PASSWORD()</code> が返す値) がわかっている場合にプレーンテキストのパスワードを指定しないようにするには、そのハッシュ値の前にキーワード <code class="literal">PASSWORD</code> を指定します。
          </p><pre class="programlisting">
CREATE USER 'jeffrey'@'localhost'
IDENTIFIED BY PASSWORD '*90E462C37378CED12064BB3388827D2BA3A9B689';
</pre><p>
            サーバーは、前に説明したようにそのアカウントに認証プラグインを暗黙的に割り当て、さらに特定のパスワードを割り当てます。このパスワードハッシュは、割り当てられたプラグインに必要な形式である必要があります。クライアントは、接続時にそのパスワードを指定する必要があります。
          </p></li><li class="listitem"><p>
            ユーザーがパスワードなしで接続できるようにするには、<code class="literal">IDENTIFIED BY</code> 句を含めないようにします。
          </p><pre class="programlisting">
CREATE USER 'jeffrey'@'localhost';
</pre><p>
            サーバーは、前に説明したようにそのアカウントに認証プラグインを暗黙的に割り当てますが、パスワードは割り当てません。クライアントは、接続時にパスワードを指定する必要がありません。ただし、パスワードのないアカウントはセキュアではありません。これを回避するには、<code class="literal">SET PASSWORD</code> を使用してアカウントのパスワードを設定します。
          </p></li></ul></div><p>
        先に説明したように、プラグインの暗黙的な割り当ては、デフォルトの認証プラグインによって異なります。<code class="option">--default-authentication-plugin</code> の許可される値は <code class="literal">mysql_native_plugin</code> と <code class="literal">sha256_password</code> であり、<code class="literal">mysql_old_password</code> は許可されません。つまり、<code class="literal">CREATE USER ... IDENTIFIED BY</code> 構文で <code class="literal">mysql_old_password</code> を使用するアカウントを作成できるように、デフォルトのプラグインを設定することはできません。<code class="literal">mysql_old_password</code> を使用するアカウントを作成するには、<code class="literal">CREATE USER ... IDENTIFIED WITH</code> を使用してプラグインを明示的に指定したあと、そのパスワードを設定します。

</p><pre class="programlisting">
CREATE USER 'jeffrey'@'localhost' IDENTIFIED WITH mysql_old_password;
SET old_passwords = 1;
SET PASSWORD FOR 'jeffrey'@'localhost' = PASSWORD('mypass');
</pre><p>
      </p><p>
        ただし、<code class="literal">mysql_old_password</code> は非推奨であるため、前の手順はお勧めできません。
      </p><p>
        パスワードと認証プラグインの設定の詳細は、<a class="xref" href="security.html#assigning-passwords" title="6.3.5 アカウントパスワードの割り当て">セクション6.3.5「アカウントパスワードの割り当て」</a>および<a class="xref" href="security.html#pluggable-authentication" title="6.3.7 プラガブル認証">セクション6.3.7「プラガブル認証」</a>を参照してください。
      </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          状況によっては、<code class="literal">CREATE USER</code> がサーバーログ、またはクライアント側にある <code class="filename">~/.mysql_history</code> などの履歴ファイル内に記録されることがあります。つまり、平文のパスワードが、その情報に対する読み取りアクセス権を持つ任意のユーザーによって読み取られる可能性があります。これがサーバーログで発生する条件およびこれを制御する方法については、<a class="xref" href="security.html#password-logging" title="6.1.2.3 パスワードおよびロギング">セクション6.1.2.3「パスワードおよびロギング」</a>を参照してください。クライアント側のロギングに関する同様の情報については、<a class="xref" href="programs.html#mysql-logging" title="4.5.1.3 mysql のロギング">セクション4.5.1.3「mysql のロギング」</a>を参照してください。
        </p></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          MySQL の一部のリリースでは、新たな権限や機能を追加するために付与テーブルの構造に変更を加えているものもあります。すべての新しい機能を確実に活用できるようにするには、新しいバージョンの MySQL に更新するときに常に付与テーブルを更新して、最新の構造を持つようにします。<a class="xref" href="programs.html#mysql-upgrade" title="4.4.7 mysql_upgrade — MySQL テーブルのチェックとアップグレード">セクション4.4.7「<span class="command"><strong>mysql_upgrade</strong></span> — MySQL テーブルのチェックとアップグレード」</a>を参照してください。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="drop-user"></a>13.7.1.3 DROP USER 構文</h4></div></div></div><a class="indexterm" name="idm139979079801456"></a><a class="indexterm" name="idm139979079800144"></a><a class="indexterm" name="idm139979079798000"></a><a class="indexterm" name="idm139979079795968"></a><a class="indexterm" name="idm139979079793936"></a><a class="indexterm" name="idm139979079791888"></a><a class="indexterm" name="idm139979079789856"></a><a class="indexterm" name="idm139979079787808"></a><a class="indexterm" name="idm139979079785776"></a><pre class="programlisting">
DROP USER <em class="replaceable"><code>user</code></em> [, <em class="replaceable"><code>user</code></em>] ...
</pre><p>
        <code class="literal">DROP USER</code> ステートメントは、1 つ以上の MySQL アカウントとその権限を削除します。これにより、そのアカウントの権限行がすべての付与テーブルから削除されます。存在しないアカウントに対しては、エラーが発生します。このステートメントを使用するには、<code class="literal">mysql</code> データベースに対するグローバルな <code class="literal">CREATE USER</code> 権限または <code class="literal">DELETE</code> 権限が必要です。
      </p><p>
        各アカウント名には、<a class="xref" href="security.html#account-names" title="6.2.3 アカウント名の指定">セクション6.2.3「アカウント名の指定」</a>で説明されている形式が使用されます。例:
      </p><pre class="programlisting">
DROP USER 'jeffrey'@'localhost';
</pre><p>
        アカウント名のユーザー名の部分のみを指定した場合は、<code class="literal">'%'</code> のホスト名の部分が使用されます。
      </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          <code class="literal">DROP USER</code> は、開かれたどのユーザーセッションも自動的には閉じません。さらに、開かれたセッションを持つユーザーが削除されても、このステートメントはそのユーザーのセッションが閉じられるまで有効になりません。セッションが閉じられると、そのユーザーは削除され、そのユーザーが次にログインしようとすると失敗します。<span class="emphasis"><em>これは意図的なものです</em></span>。
        </p></div><p>
        <code class="literal">DROP USER</code> は、古いユーザーが作成したどのデータベースまたはそれらのデータベース内のどのオブジェクトも自動的には削除したり、無効にしたりしません。これには、<code class="literal">DEFINER</code> 属性に削除されたユーザーが指定されているストアドプログラムまたはビューが含まれます。このようなオブジェクトにアクセスしようとすると、それが定義者のセキュリティーコンテキストで実行された場合は、エラーが生成される可能性があります。(セキュリティーコンテキストについては、<a class="xref" href="stored-programs-views.html#stored-programs-security" title="20.6 ストアドプログラムおよびビューのアクセスコントロール">セクション20.6「ストアドプログラムおよびビューのアクセスコントロール」</a>を参照してください。) 
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="grant"></a>13.7.1.4 GRANT 構文</h4></div></div></div><a class="indexterm" name="idm139979079763184"></a><a class="indexterm" name="idm139979079761872"></a><a class="indexterm" name="idm139979079760544"></a><a class="indexterm" name="idm139979079758400"></a><a class="indexterm" name="idm139979079757040"></a><pre class="programlisting">
GRANT
    <em class="replaceable"><code>priv_type</code></em> [(<em class="replaceable"><code>column_list</code></em>)]
      [, <em class="replaceable"><code>priv_type</code></em> [(<em class="replaceable"><code>column_list</code></em>)]] ...
    ON [<em class="replaceable"><code>object_type</code></em>] <em class="replaceable"><code>priv_level</code></em>
    TO <em class="replaceable"><code>user_specification</code></em> [, <em class="replaceable"><code>user_specification</code></em>] ...
    [REQUIRE {NONE | <em class="replaceable"><code>ssl_option</code></em> [[AND] <em class="replaceable"><code>ssl_option</code></em>] ...}]
    [WITH <em class="replaceable"><code>with_option</code></em> ...]

GRANT PROXY ON <em class="replaceable"><code>user_specification</code></em>
    TO <em class="replaceable"><code>user_specification</code></em> [, <em class="replaceable"><code>user_specification</code></em>] ...
    [WITH GRANT OPTION]

<em class="replaceable"><code>object_type</code></em>:
    TABLE
  | FUNCTION
  | PROCEDURE

<em class="replaceable"><code>priv_level</code></em>:
    *
  | *.*
  | <em class="replaceable"><code>db_name</code></em>.*
  | <em class="replaceable"><code>db_name.tbl_name</code></em>
  | <em class="replaceable"><code>tbl_name</code></em>
  | <em class="replaceable"><code>db_name</code></em>.<em class="replaceable"><code>routine_name</code></em>

<em class="replaceable"><code>user_specification</code></em>:
    <em class="replaceable"><code>user</code></em>
    [
      | IDENTIFIED WITH <em class="replaceable"><code>auth_plugin</code></em> [AS '<em class="replaceable"><code>auth_string</code></em>']
        IDENTIFIED BY [PASSWORD] '<em class="replaceable"><code>password</code></em>'
    ]

<em class="replaceable"><code>ssl_option</code></em>:
    SSL
  | X509
  | CIPHER '<em class="replaceable"><code>cipher</code></em>'
  | ISSUER '<em class="replaceable"><code>issuer</code></em>'
  | SUBJECT '<em class="replaceable"><code>subject</code></em>'

<em class="replaceable"><code>with_option</code></em>:
    GRANT OPTION
  | MAX_QUERIES_PER_HOUR <em class="replaceable"><code>count</code></em>
  | MAX_UPDATES_PER_HOUR <em class="replaceable"><code>count</code></em>
  | MAX_CONNECTIONS_PER_HOUR <em class="replaceable"><code>count</code></em>
  | MAX_USER_CONNECTIONS <em class="replaceable"><code>count</code></em>
</pre><p>
        <code class="literal">GRANT</code> ステートメントは、MySQL ユーザーアカウントに権限を付与します。<code class="literal">GRANT</code> にはまた、セキュア接続の使用やサーバーリソースへのアクセスに関する制限などの、その他のアカウント特性を指定する機能もあります。<code class="literal">GRANT</code> を使用するには、<code class="literal">GRANT OPTION</code> 権限が必要であり、かつ付与しようとしている権限を持っている必要があります。
      </p><p>
        通常、データベース管理者は最初に <code class="literal">CREATE USER</code> を使用してアカウントを作成し、次に <code class="literal">GRANT</code> を使用してその権限や特性を定義します。例:
      </p><pre class="programlisting">
CREATE USER 'jeffrey'@'localhost' IDENTIFIED BY 'mypass';
GRANT ALL ON db1.* TO 'jeffrey'@'localhost';
GRANT SELECT ON db2.invoice TO 'jeffrey'@'localhost';
GRANT USAGE ON *.* TO 'jeffrey'@'localhost' WITH MAX_QUERIES_PER_HOUR 90;
</pre><p>
        ただし、<code class="literal">GRANT</code> ステートメントで指定されたアカウントがまだ存在しない場合、<code class="literal">GRANT</code> は、あとで <code class="literal">NO_AUTO_CREATE_USER</code> SQL モードの説明に示されている条件の下でそのアカウントを作成する可能性があります。
      </p><p>
        <code class="literal">REVOKE</code> ステートメントは <code class="literal">GRANT</code> に関連しており、管理者がアカウントの権限を削除できるようにします。<a class="xref" href="sql-syntax.html#revoke" title="13.7.1.6 REVOKE 構文">セクション13.7.1.6「REVOKE 構文」</a>を参照してください。
      </p><p>
        <span class="command"><strong>mysql</strong></span> プログラムから正常に実行された場合、<code class="literal">GRANT</code> は <code class="literal">Query OK, 0 rows affected</code> で応答します。この操作によってどのような権限が付与されたかを判定するには、<code class="literal">SHOW GRANTS</code> を使用します。<a class="xref" href="sql-syntax.html#show-grants" title="13.7.5.22 SHOW GRANTS 構文">セクション13.7.5.22「SHOW GRANTS 構文」</a>を参照してください。
      </p><p>
        <code class="literal">GRANT</code> ステートメントには、このセクションの次のトピックで説明されているいくつかの側面があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <a class="link" href="sql-syntax.html#grant-privileges" title="MySQL によってサポートされる権限">MySQL によってサポートされる権限</a>
          </p></li><li class="listitem"><p>
            <a class="link" href="sql-syntax.html#grant-global-privileges" title="グローバル権限">グローバル権限</a>
          </p></li><li class="listitem"><p>
            <a class="link" href="sql-syntax.html#grant-database-privileges" title="データベース権限">データベース権限</a>
          </p></li><li class="listitem"><p>
            <a class="link" href="sql-syntax.html#grant-table-privileges" title="テーブル権限">テーブル権限</a>
          </p></li><li class="listitem"><p>
            <a class="link" href="sql-syntax.html#grant-column-privileges" title="カラム権限">カラム権限</a>
          </p></li><li class="listitem"><p>
            <a class="link" href="sql-syntax.html#grant-routine-privileges" title="ストアドルーチン権限">ストアドルーチン権限</a>
          </p></li><li class="listitem"><p>
            <a class="link" href="sql-syntax.html#grant-proxy-privileges" title="プロキシユーザー権限">プロキシユーザー権限</a>
          </p></li><li class="listitem"><p>
            <a class="link" href="sql-syntax.html#grant-accounts-passwords" title="アカウント名とパスワード">アカウント名とパスワード</a>
          </p></li><li class="listitem"><p>
            <a class="link" href="sql-syntax.html#grant-other-characteristics" title="その他のアカウント特性">その他のアカウント特性</a>
          </p></li><li class="listitem"><p>
            <a class="link" href="sql-syntax.html#grant-mysql-vs-standard-sql" title="MySQL バージョンと標準 SQL バージョンの GRANT">MySQL バージョンと標準 SQL バージョンの <code class="literal">GRANT</code></a>
          </p></li></ul></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          MySQL の一部のリリースでは、新たな権限や機能を追加するために付与テーブルの構造に変更を加えているものもあります。すべての新しい機能を確実に活用できるようにするには、新しいバージョンの MySQL に更新するときに常に付与テーブルを更新して、最新の構造を持つようにします。<a class="xref" href="programs.html#mysql-upgrade" title="4.4.7 mysql_upgrade — MySQL テーブルのチェックとアップグレード">セクション4.4.7「<span class="command"><strong>mysql_upgrade</strong></span> — MySQL テーブルのチェックとアップグレード」</a>を参照してください。
        </p></div><h5><a name="grant-privileges"></a>MySQL によってサポートされる権限</h5><p>
        次の表は、<code class="literal">GRANT</code> および <code class="literal">REVOKE</code> ステートメントに対して指定できる許可される <em class="replaceable"><code>priv_type</code></em> 権限タイプと、各権限を付与できるレベルについて要約したものです。これらの権限の詳細は、<a class="xref" href="security.html#privileges-provided" title="6.2.1 MySQL で提供される権限">セクション6.2.1「MySQL で提供される権限」</a>を参照してください。
      </p><div class="table"><a name="idm139979079686496"></a><p class="title"><b>表 13.1 GRANT および REVOKE に対して許容可能な権限</b></p><div class="table-contents"><table summary="GRANT および REVOKE に対して許容可能な権限" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">権限</th><th scope="col">意味と付与可能なレベル</th></tr></thead><tbody><tr><td scope="row"><code class="literal">ALL [PRIVILEGES]</code></td><td><code class="literal">GRANT OPTION</code> を除き、指定されたアクセスレベルにあるすべての権限を付与します</td></tr><tr><td scope="row"><code class="literal">ALTER</code></td><td><code class="literal">ALTER TABLE</code> の使用を有効にします。レベル: グローバル、データベース、テーブル。</td></tr><tr><td scope="row"><code class="literal">ALTER ROUTINE</code></td><td>ストアドルーチンの変更または削除を有効にします。レベル: グローバル、データベース、プロシージャー。</td></tr><tr><td scope="row"><code class="literal">CREATE</code></td><td>データベースおよびテーブルの作成を有効にします。レベル: グローバル、データベース、テーブル。</td></tr><tr><td scope="row"><code class="literal">CREATE ROUTINE</code></td><td>ストアドルーチンの作成を有効にします。レベル: グローバル、データベース。</td></tr><tr><td scope="row"><code class="literal">CREATE TABLESPACE</code></td><td>テーブルスペースおよびログファイルグループの作成、変更、または削除を有効にします。レベル: グローバル。</td></tr><tr><td scope="row"><code class="literal">CREATE TEMPORARY TABLES</code></td><td><code class="literal">CREATE TEMPORARY TABLE</code> の使用を有効にします。レベル: グローバル、データベース。</td></tr><tr><td scope="row"><code class="literal">CREATE USER</code></td><td><code class="literal">CREATE USER</code>、<code class="literal">DROP USER</code>、<code class="literal">RENAME USER</code>、および <code class="literal">REVOKE ALL PRIVILEGES</code> の使用を有効にします。レベル: グローバル。</td></tr><tr><td scope="row"><code class="literal">CREATE VIEW</code></td><td>ビューの作成または変更を有効にします。レベル: グローバル、データベース、テーブル。</td></tr><tr><td scope="row"><code class="literal">DELETE</code></td><td><code class="literal">DELETE</code> の使用を有効にします。レベル: グローバル、データベース、テーブル。</td></tr><tr><td scope="row"><code class="literal">DROP</code></td><td>データベース、テーブル、およびビューの削除を有効にします。レベル: グローバル、データベース、テーブル。</td></tr><tr><td scope="row"><code class="literal">EVENT</code></td><td>イベントスケジューラでのイベントの使用を有効にします。レベル: グローバル、データベース。</td></tr><tr><td scope="row"><code class="literal">EXECUTE</code></td><td>ユーザーがストアドルーチンを実行できるようにします。レベル: グローバル、データベース、テーブル。</td></tr><tr><td scope="row"><code class="literal">FILE</code></td><td>ユーザーがサーバーにファイルを読み取らせたり書き込ませたりできるようにします。レベル: グローバル。</td></tr><tr><td scope="row"><code class="literal">GRANT OPTION</code></td><td>権限のほかのアカウントへの付与、またはほかのアカウントからの削除を有効にします。レベル: グローバル、データベース、テーブル、プロシージャー、プロキシ。</td></tr><tr><td scope="row"><code class="literal">INDEX</code></td><td>インデックスの作成または削除を有効にします。レベル: グローバル、データベース、テーブル。</td></tr><tr><td scope="row"><code class="literal">INSERT</code></td><td><code class="literal">INSERT</code> の使用を有効にします。レベル: グローバル、データベース、テーブル、カラム。</td></tr><tr><td scope="row"><code class="literal">LOCK TABLES</code></td><td>ユーザーが <code class="literal">SELECT</code> 権限を持っているテーブルに対する <code class="literal">LOCK TABLES</code> の使用を有効にします。レベル: グローバル、データベース。</td></tr><tr><td scope="row"><code class="literal">PROCESS</code></td><td>ユーザーが <code class="literal">SHOW PROCESSLIST</code> を使用してすべてのプロセスを表示できるようにします。レベル: グローバル。</td></tr><tr><td scope="row"><code class="literal">PROXY</code></td><td>ユーザーのプロキシ設定を有効にします。レベル: ユーザーからユーザーへ。</td></tr><tr><td scope="row"><code class="literal">REFERENCES</code></td><td>実装されていません</td></tr><tr><td scope="row"><code class="literal">RELOAD</code></td><td><code class="literal">FLUSH</code> 操作の使用を有効にします。レベル: グローバル。</td></tr><tr><td scope="row"><code class="literal">REPLICATION CLIENT</code></td><td>ユーザーがマスターまたはスレーブサーバーの場所を問い合わせできるようにします。レベル: グローバル。</td></tr><tr><td scope="row"><code class="literal">REPLICATION SLAVE</code></td><td>レプリケーションスレーブがマスターからバイナリログイベントを読み取れるようにします。レベル: グローバル。</td></tr><tr><td scope="row"><code class="literal">SELECT</code></td><td><code class="literal">SELECT</code> の使用を有効にします。レベル: グローバル、データベース、テーブル、カラム。</td></tr><tr><td scope="row"><code class="literal">SHOW DATABASES</code></td><td><code class="literal">SHOW DATABASES</code> がすべてのデータベースを表示できるようにします。レベル: グローバル。</td></tr><tr><td scope="row"><code class="literal">SHOW VIEW</code></td><td><code class="literal">SHOW CREATE VIEW</code> の使用を有効にします。レベル: グローバル、データベース、テーブル。</td></tr><tr><td scope="row"><code class="literal">SHUTDOWN</code></td><td><span class="command"><strong>mysqladmin shutdown</strong></span> の使用を有効にします。レベル: グローバル。</td></tr><tr><td scope="row"><code class="literal">SUPER</code></td><td><code class="literal">CHANGE MASTER TO</code>、<code class="literal">KILL</code>、<code class="literal">PURGE BINARY LOGS</code>、<code class="literal">SET GLOBAL</code>、<span class="command"><strong>mysqladmin debug</strong></span> コマンドなどのその他の管理操作の使用を有効にします。レベル: グローバル。</td></tr><tr><td scope="row"><code class="literal">TRIGGER</code></td><td>トリガー操作を有効にします。レベル: グローバル、データベース、テーブル。</td></tr><tr><td scope="row"><code class="literal">UPDATE</code></td><td><code class="literal">UPDATE</code> の使用を有効にします。レベル: グローバル、データベース、テーブル、カラム。</td></tr><tr><td scope="row"><code class="literal">USAGE</code></td><td><span class="quote">「<span class="quote">権限なし</span>」</span>のシノニムです</td></tr></tbody></table></div></div><br class="table-break"><p>
        トリガーはテーブルに関連付けられているため、トリガーを作成または削除するには、そのトリガーではなく、このテーブルに対する <code class="literal">TRIGGER</code> 権限が必要です。
      </p><p>
        <code class="literal">GRANT</code> ステートメントでは、<code class="literal">ALL [PRIVILEGES]</code> または <code class="literal">PROXY</code> 権限は単独で指定する必要があり、ほかの権限とともに指定することはできません。<code class="literal">ALL [PRIVILEGES]</code> は、<code class="literal">GRANT OPTION</code> および <code class="literal">PROXY</code> 権限を除き、権限が付与されるレベルで使用可能なすべての権限を表します。
      </p><p>
        <code class="literal">USAGE</code> を指定すると、権限を持っていないユーザーを作成したり、あるアカウントの <code class="literal">REQUIRE</code> または <code class="literal">WITH</code> 句を、その既存の権限を変更することなく指定したりできます。
      </p><p>
        MySQL アカウント情報は、<code class="literal">mysql</code> データベースのテーブルに格納されています。このデータベースとアクセス制御システムについては、<a class="xref" href="security.html#privilege-system" title="6.2 MySQL アクセス権限システム">セクション6.2「MySQL アクセス権限システム」</a>で広範囲にわたって説明されています。詳細は、このセクションを参照するようにしてください。
      </p><p>
        付与テーブルに、大文字と小文字が混在したデータベースまたはテーブル名を含む権限行が保持されており、かつ <code class="literal">lower_case_table_names</code> システム変数が 0 以外の値に設定されている場合は、<code class="literal">REVOKE</code> を使用してこれらの権限を取り消すことはできません。付与テーブルを直接操作することが必要になります。(<code class="literal">lower_case_table_names</code> が設定されているとき、<code class="literal">GRANT</code> はこのような行を作成しませんが、その変数が設定される前にこのような行が作成されていた可能性があります。) 
      </p><p>
        権限は、<code class="literal">ON</code> 句に使用される構文に応じて、いくつかのレベルで付与できます。<code class="literal">REVOKE</code> の場合は、その同じ <code class="literal">ON</code> 構文で、どの権限を取り消すかを指定します。次に示す例には、簡略化のために <code class="literal">IDENTIFIED BY '<em class="replaceable"><code>password</code></em>'</code> 句が含まれていませんが、そのアカウントがまだ存在しない場合は、パスワードのないセキュアでないアカウントが作成されないようにこの句を含めるようにしてください。
      </p><h5><a name="grant-global-privileges"></a>グローバル権限</h5><p>
        グローバル権限は管理権限です。つまり、特定のサーバー上のすべてのデータベースに適用されます。グローバル権限を割り当てるには、<code class="literal">ON *.*</code> 構文を使用します。
      </p><pre class="programlisting">
GRANT ALL ON *.* TO 'someuser'@'somehost';
GRANT SELECT, INSERT ON *.* TO 'someuser'@'somehost';
</pre><p>
        <code class="literal">CREATE TABLESPACE</code>、<code class="literal">CREATE USER</code>、<code class="literal">FILE</code>、<code class="literal">PROCESS</code>、<code class="literal">RELOAD</code>、<code class="literal">REPLICATION CLIENT</code>、<code class="literal">REPLICATION SLAVE</code>、<code class="literal">SHOW DATABASES</code>、<code class="literal">SHUTDOWN</code>、および <code class="literal">SUPER</code> 権限は管理権限であり、グローバルにのみ付与できます。
      </p><p>
        その他の権限はグローバルに、またはより具体的なレベルで付与できます。
      </p><p>
        MySQL は、グローバル権限を <code class="literal">mysql.user</code> テーブル内に格納します。
      </p><h5><a name="grant-database-privileges"></a>データベース権限</h5><p>
        データベース権限は、特定のデータベース内のすべてのオブジェクトに適用されます。データベースレベルの権限を割り当てるには、<code class="literal">ON <em class="replaceable"><code>db_name</code></em>.*</code> 構文を使用します。
      </p><pre class="programlisting">
GRANT ALL ON mydb.* TO 'someuser'@'somehost';
GRANT SELECT, INSERT ON mydb.* TO 'someuser'@'somehost';
</pre><p>
        <code class="literal">ON *.*</code> ではなく <code class="literal">ON *</code> 構文を使用し、かつデフォルトデータベースを選択した場合、権限はデフォルトデータベースのデータベースレベルで割り当てられます。デフォルトデータベースが存在しない場合は、エラーが発生します。
      </p><p>
        <code class="literal">CREATE</code>、<code class="literal">DROP</code>、<code class="literal">EVENT</code>、<code class="literal">GRANT OPTION</code>、および <code class="literal">LOCK TABLES</code> 権限は、データベースレベルで指定できます。また、テーブルまたはルーチン権限もデータベースレベルで指定できます。この場合、これらの権限はデータベース内のすべてのテーブルまたはルーチンに適用されます。
      </p><p>
        MySQL は、データベース権限を <code class="literal">mysql.db</code> テーブル内に格納します。
      </p><h5><a name="grant-table-privileges"></a>テーブル権限</h5><p>
        テーブル権限は、特定のテーブル内のすべてのカラムに適用されます。テーブルレベルの権限を割り当てるには、<code class="literal">ON <em class="replaceable"><code>db_name.tbl_name</code></em></code> 構文を使用します。
      </p><pre class="programlisting">
GRANT ALL ON mydb.mytbl TO 'someuser'@'somehost';
GRANT SELECT, INSERT ON mydb.mytbl TO 'someuser'@'somehost';
</pre><p>
        <em class="replaceable"><code>db_name.tbl_name</code></em> ではなく <em class="replaceable"><code>tbl_name</code></em> を指定した場合、このステートメントは、デフォルトデータベース内の <em class="replaceable"><code>tbl_name</code></em> に適用されます。デフォルトデータベースが存在しない場合は、エラーが発生します。
      </p><p>
        テーブルレベルで許可される <em class="replaceable"><code>priv_type</code></em> 値は、<code class="literal">ALTER</code>、<code class="literal">CREATE VIEW</code>、<code class="literal">CREATE</code>、<code class="literal">DELETE</code>、<code class="literal">DROP</code>、<code class="literal">GRANT OPTION</code>、<code class="literal">INDEX</code>、<code class="literal">INSERT</code>、<code class="literal">SELECT</code>、<code class="literal">SHOW VIEW</code>、<code class="literal">TRIGGER</code>、および <code class="literal">UPDATE</code> です。
      </p><p>
        MySQL は、テーブル権限を <code class="literal">mysql.tables_priv</code> テーブル内に格納します。
      </p><h5><a name="grant-column-privileges"></a>カラム権限</h5><p>
        カラム権限は、特定のテーブル内の単一カラムに適用されます。カラムレベルで付与される各権限のあとに、括弧で囲まれた 1 つまたは複数のカラムを指定する必要があります。
      </p><pre class="programlisting">
GRANT SELECT (col1), INSERT (col1,col2) ON mydb.mytbl TO 'someuser'@'somehost';
</pre><p>
        カラムに対して (つまり、<em class="replaceable"><code>column_list</code></em> 句を使用するときに) 許可される <em class="replaceable"><code>priv_type</code></em> 値は、<code class="literal">INSERT</code>、<code class="literal">SELECT</code>、および <code class="literal">UPDATE</code> です。
      </p><p>
        MySQL は、カラム権限を <code class="literal">mysql.columns_priv</code> テーブル内に格納します。
      </p><h5><a name="grant-routine-privileges"></a>ストアドルーチン権限</h5><p>
        <code class="literal">ALTER ROUTINE</code>、<code class="literal">CREATE ROUTINE</code>、<code class="literal">EXECUTE</code>、および <code class="literal">GRANT OPTION</code> 権限は、ストアドルーチン (プロシージャーおよびファンクション) に適用されます。これらの権限は、グローバルおよびデータベースレベルで付与できます。<code class="literal">CREATE ROUTINE</code> を除き、これらの権限は、個々のルーチンに対してルーチンレベルで付与できます。
      </p><pre class="programlisting">
GRANT CREATE ROUTINE ON mydb.* TO 'someuser'@'somehost';
GRANT EXECUTE ON PROCEDURE mydb.myproc TO 'someuser'@'somehost';
</pre><p>
        ルーチンレベルで許可される <em class="replaceable"><code>priv_type</code></em> 値は、<code class="literal">ALTER ROUTINE</code>、<code class="literal">EXECUTE</code>、および <code class="literal">GRANT OPTION</code> です。<code class="literal">CREATE ROUTINE</code> は、最初にルーチンを作成するためにこの権限が必要であるため、ルーチンレベルの権限ではありません。
      </p><p>
        MySQL は、ルーチンレベルの権限を <code class="literal">mysql.procs_priv</code> テーブル内に格納します。
      </p><h5><a name="grant-proxy-privileges"></a>プロキシユーザー権限</h5><p>
        <code class="literal">PROXY</code> 権限は、あるユーザーを別のユーザーのプロキシにできるようにします。プロキシユーザーは、プロキシ設定されたユーザーになりすますか、またはそのユーザーの識別情報を取得します。
      </p><pre class="programlisting">
GRANT PROXY ON 'localuser'@'localhost' TO 'externaluser'@'somehost';
</pre><p>
        <code class="literal">PROXY</code> が付与される場合、その権限は <code class="literal">GRANT</code> ステートメントで指定されている唯一の権限である必要があり、<code class="literal">REQUIRE</code> 句は指定できず、また許可される唯一の <code class="literal">WITH</code> オプションは <code class="literal">WITH GRANT OPTION</code> です。
      </p><p>
        プロキシ設定では、プロキシユーザーが、接続時にプロキシ設定されたユーザーの名前をサーバーに返すプラグイン経由で認証すること、およびプロキシユーザーがプロキシ設定されたユーザーに対する <code class="literal">PROXY</code> 権限を持っていることが必要です。詳細および例については、<a class="xref" href="security.html#proxy-users" title="6.3.9 プロキシユーザー">セクション6.3.9「プロキシユーザー」</a>を参照してください。
      </p><p>
        MySQL は、プロキシ権限を <code class="literal">mysql.proxies_priv</code> テーブル内に格納します。
      </p><p>
        グローバル、データベース、テーブル、およびルーチンレベルの場合、<code class="literal">GRANT ALL</code> は、付与しようとしているレベルに存在する権限のみを割り当てます。たとえば、<code class="literal">GRANT ALL ON <em class="replaceable"><code>db_name</code></em>.*</code> はデータベースレベルのステートメントであるため、<code class="literal">FILE</code> などのグローバルのみの権限を付与しません。<code class="literal">ALL</code> を付与しても、<code class="literal">PROXY</code> 権限が割り当てられるわけではありません。
      </p><p>
        <em class="replaceable"><code>object_type</code></em> 句 (存在する場合) は、それに続くオブジェクトがテーブル、ストアドファンクション、またはストアドプロシージャーであるときは <code class="literal">TABLE</code>、<code class="literal">FUNCTION</code>、または <code class="literal">PROCEDURE</code> として指定するようにしてください。
      </p><p>
        データベース、テーブル、カラム、またはルーチンに対する権限は、各権限レベルにある権限の論理 <code class="literal">OR</code> として付加的に形成されます。たとえば、ユーザーがグローバルな <code class="literal">SELECT</code> 権限を持っている場合は、データベース、テーブル、またはカラムレベルの権限がないことによってその権限を拒否することはできません。権限確認手順の詳細については、<a class="xref" href="security.html#request-access" title="6.2.5 アクセス制御、ステージ 2: リクエストの確認">セクション6.2.5「アクセス制御、ステージ 2: リクエストの確認」</a>で説明されています。
      </p><p>
        MySQL では、存在しないデータベースまたはテーブルに対する権限を付与できます。テーブルの場合は、付与される権限に <code class="literal">CREATE</code> 権限が含まれている必要があります。<span class="emphasis"><em>この動作は設計によるものであり</em></span>、データベース管理者がユーザーアカウントと、あとで作成されるデータベースまたはテーブルに対する権限を準備できるようにすることを目的にしています。
      </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          <span class="emphasis"><em>MySQL では、データベースまたはテーブルを削除しても、どの権限も自動的には取り消されません</em></span>。ただし、ルーチンを削除した場合は、そのルーチンに付与されたルーチンレベルの権限がすべて取り消されます。
        </p></div><h5><a name="grant-accounts-passwords"></a>アカウント名とパスワード</h5><p>
        <em class="replaceable"><code>user</code></em> 値は、<code class="literal">GRANT</code> ステートメントが適用される MySQL アカウントを示します。任意のホストのユーザーへの権利の付与に対応するために、MySQL は、<code class="literal"><em class="replaceable"><code>user_name</code></em>@<em class="replaceable"><code>host_name</code></em></code> という形式での <em class="replaceable"><code>user</code></em> 値の指定をサポートしています。<em class="replaceable"><code>user_name</code></em> または <em class="replaceable"><code>host_name</code></em> 値が引用符で囲まれていない識別子として正当である場合、それを引用符で囲む必要はありません。ただし、特殊文字 (<span class="quote">「<span class="quote"><code class="literal">-</code></span>」</span>など) を含む <em class="replaceable"><code>user_name</code></em> 文字列、または特殊文字やワイルドカード文字 (<span class="quote">「<span class="quote"><code class="literal">%</code></span>」</span>など) を含む <em class="replaceable"><code>host_name</code></em> 文字列 (たとえば、<code class="literal">'test-user'@'%.com'</code>) を指定するには引用符が必要です。ユーザー名とホスト名は個別に引用符で囲みます。
      </p><p>
        ホスト名には、ワイルドカードを指定できます。たとえば、<code class="literal"><em class="replaceable"><code>user_name</code></em>@'%.example.com'</code> は <code class="literal">example.com</code> ドメイン内の任意のホストの <em class="replaceable"><code>user_name</code></em> に適用され、<code class="literal"><em class="replaceable"><code>user_name</code></em>@'192.168.1.%'</code> は <code class="literal">192.168.1</code> クラス C サブネット内の任意のホストの <em class="replaceable"><code>user_name</code></em> に適用されます。
      </p><p>
        単純な形式 <em class="replaceable"><code>user_name</code></em> は、<code class="literal"><em class="replaceable"><code>user_name</code></em>@'%'</code> のシノニムです。
      </p><p>
        <span class="emphasis"><em>MySQL は、ユーザー名でのワイルドカードをサポートしていません</em></span>。匿名ユーザーを参照するには、<code class="literal">GRANT</code> ステートメントで空のユーザー名を含むアカウントを指定します。
      </p><pre class="programlisting">
GRANT ALL ON test.* TO ''@'localhost' ...
</pre><p>
        この場合は、匿名ユーザーの正しいパスワードを使用してローカルホストから接続するすべてのユーザーに、匿名ユーザーアカウントに関連付けられた権限でのアクセスが許可されます。
      </p><p>
        アカウント名内のユーザー名とホスト名の値の詳細は、<a class="xref" href="security.html#account-names" title="6.2.3 アカウント名の指定">セクション6.2.3「アカウント名の指定」</a>を参照してください。
      </p><p>
        引用符で囲まれた値を指定するには、データベース、テーブル、カラム、およびルーチン名は識別子として引用符で囲みます。ユーザー名とホスト名は識別子または文字列として引用符で囲みます。パスワードは文字列として引用符で囲みます。文字列および識別子として引用符で囲む方法のガイドラインについては、<a class="xref" href="language-structure.html#string-literals" title="9.1.1 文字列リテラル">セクション9.1.1「文字列リテラル」</a>および<a class="xref" href="language-structure.html#identifiers" title="9.2 スキーマオブジェクト名">セクション9.2「スキーマオブジェクト名」</a>を参照してください。
      </p><p>
        グローバルまたはデータベースレベルの権限を付与する <code class="literal">GRANT</code> ステートメントでデータベース名を指定する場合は、<span class="quote">「<span class="quote"><code class="literal">_</code></span>」</span>や<span class="quote">「<span class="quote"><code class="literal">%</code></span>」</span>のワイルドカードが許可されます。つまり、たとえば、データベース名の一部として<span class="quote">「<span class="quote"><code class="literal">_</code></span>」</span>文字を使用する場合は、そのユーザーがワイルドカードパターンに一致する追加のデータベースにアクセスできないようにするために、その文字を <code class="literal">GRANT</code> ステートメントで<span class="quote">「<span class="quote"><code class="literal">\_</code></span>」</span>として指定するようにしてください (たとえば、<code class="literal">GRANT ... ON `foo\_bar`.* TO ...</code>)。
      </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
          匿名ユーザーから MySQL サーバーへの接続を許可する場合は、<code class="literal"><em class="replaceable"><code>user_name</code></em>@localhost</code> として、すべてのローカルユーザーにも権限を付与するようにしてください。それ以外の場合は、指定されたユーザーがローカルマシンから MySQL サーバーにログインしようとすると、(MySQL のインストール中に作成された) <code class="literal">mysql.user</code> テーブル内の <code class="literal">localhost</code> の匿名ユーザーアカウントが使用されます。詳細は、<a class="xref" href="security.html#connection-access" title="6.2.4 アクセス制御、ステージ 1: 接続の検証">セクション6.2.4「アクセス制御、ステージ 1: 接続の検証」</a>を参照してください。
        </p></div><p>
        前の警告が適用されるかどうかを判定するには、すべての匿名ユーザーを一覧表示する次のクエリーを実行します。
      </p><pre class="programlisting">
SELECT Host, User FROM mysql.user WHERE User='';
</pre><p>
        今説明した問題を回避するには、次のステートメントを使用して、ローカルの匿名ユーザーアカウントを削除します。
      </p><pre class="programlisting">
DROP USER ''@'localhost';
</pre><p>
        <code class="literal">GRANT</code> は、最大 60 文字の長さのホスト名をサポートしています。データベース、テーブル、カラム、およびルーチン名には、最大 64 文字を指定できます。ユーザー名には、最大 16 文字を指定できます。
      </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
          <span class="emphasis"><em><code class="literal">mysql.user</code> テーブルを変更しても、ユーザー名に許可される長さは変更できません。それを行おうとすると、予測できない動作が発生し、ユーザーが MySQL サーバーにログインできなくなる可能性さえあります</em></span>。<code class="literal">mysql</code> データベース内のどのテーブルも、<a class="xref" href="programs.html#mysql-upgrade" title="4.4.7 mysql_upgrade — MySQL テーブルのチェックとアップグレード">セクション4.4.7「<span class="command"><strong>mysql_upgrade</strong></span> — MySQL テーブルのチェックとアップグレード」</a>で説明されている手順による場合を除き、どのような方法でも決して変更しないようにしてください。
        </p></div><a class="indexterm" name="idm139979079422624"></a><p>
        ユーザーのサーバー接続時の認証方法を示すために、<em class="replaceable"><code>user_specification</code></em> 句には、認証プラグインを指定するための <code class="literal">IDENTIFIED WITH</code> またはパスワードを指定するための <code class="literal">IDENTIFIED BY</code> を含めることができます。ユーザー指定の構文は、<code class="literal">CREATE USER</code> ステートメントの場合と同じです。詳細は、<a class="xref" href="sql-syntax.html#create-user" title="13.7.1.2 CREATE USER 構文">セクション13.7.1.2「CREATE USER 構文」</a>を参照してください。
      </p><p>
        <code class="literal">IDENTIFIED BY</code> が存在し、かつグローバルな付与権限 (<code class="literal">GRANT OPTION</code>) を指定しているときは、アカウントが存在し、すでにパスワードが設定されている場合でも、そのパスワードがアカウントの新しいパスワードになります。<code class="literal">IDENTIFIED BY</code> を指定しない場合、アカウントのパスワードは変更されないままになります。
      </p><p>
        <code class="literal">GRANT</code> ステートメントで指定されたアカウントが存在しない場合、実行されるアクションは <code class="literal">NO_AUTO_CREATE_USER</code> SQL モードによって異なります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">NO_AUTO_CREATE_USER</code> が有効になっていない場合、<code class="literal">GRANT</code> はこのアカウントを作成します。<code class="literal">IDENTIFIED BY</code> を使用して空以外のパスワードを指定していないかぎり、<span class="emphasis"><em>これはまったくセキュアではありません</em></span>。
          </p></li><li class="listitem"><p>
            <code class="literal">NO_AUTO_CREATE_USER</code> が有効になっている場合は、<code class="literal">IDENTIFIED BY</code> を使用して空以外のパスワードを指定するか、または <code class="literal">IDENTIFIED WITH</code> を使用して認証プラグインを指定していないかぎり、<code class="literal">GRANT</code> は失敗し、このアカウントを作成しません。
          </p></li></ul></div><p>
        MySQL 5.6.12 の時点では、アカウントがすでに存在する場合、<code class="literal">IDENTIFIED WITH</code> は、新しいアカウントの作成時に使用されることのみを目的にしているため禁止されます。
      </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          状況によっては、<code class="literal">GRANT</code> がサーバーログ、またはクライアント側にある <code class="filename">~/.mysql_history</code> などの履歴ファイル内に記録されることがあります。つまり、平文のパスワードが、その情報に対する読み取りアクセス権を持つ任意のユーザーによって読み取られる可能性があります。これがサーバーログで発生する条件およびこれを制御する方法については、<a class="xref" href="security.html#password-logging" title="6.1.2.3 パスワードおよびロギング">セクション6.1.2.3「パスワードおよびロギング」</a>を参照してください。クライアント側のロギングに関する同様の情報については、<a class="xref" href="programs.html#mysql-logging" title="4.5.1.3 mysql のロギング">セクション4.5.1.3「mysql のロギング」</a>を参照してください。
        </p></div><h5><a name="grant-other-characteristics"></a>その他のアカウント特性</h5><p>
        <code class="literal">WITH</code> 句は、次のいくつかの目的に使用されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            ユーザーがほかのユーザーに権限を付与できるようにするため
          </p></li><li class="listitem"><p>
            ユーザーに対するリソース制限を指定するため
          </p></li><li class="listitem"><p>
            ユーザーがサーバーへのセキュア接続を使用する必要があるかどうか、およびその方法を指定するため
          </p></li></ul></div><p>
        <code class="literal">WITH GRANT OPTION</code> 句は、ユーザーが、そのユーザーの持つ指定された権限レベルにある任意の権限をほかのユーザーに与えることができるようにします。異なる権限を持つ 2 人のユーザーが権限を組み合わせることができる可能性があるため、<code class="literal">GRANT OPTION</code> 権限を与える相手には十分に注意してください。
      </p><p>
        自分が保持していない権限を別のユーザーに付与することはできません。<code class="literal">GRANT OPTION</code> 権限を使用して割り当てることができるのは、自分が保持している権限だけです。
      </p><p>
        あるユーザーに特定の権限レベルにある <code class="literal">GRANT OPTION</code> 権限を付与すると、そのユーザーがそのレベルに保持している (または、将来与えられる可能性のある) すべての権限も、そのユーザーからほかのユーザーに付与される場合があることに注意してください。あるユーザーに、データベースに対する <code class="literal">INSERT</code> 権限を付与するとします。次に、そのデータベースに対する <code class="literal">SELECT</code> 権限を付与し、<code class="literal">WITH GRANT OPTION</code> を指定した場合、そのユーザーはほかのユーザーに <code class="literal">SELECT</code> 権限だけでなく、<code class="literal">INSERT</code> 権限も与えることができます。そのあと、そのユーザーにデータベースに対する <code class="literal">UPDATE</code> 権限を付与すると、そのユーザーは <code class="literal">INSERT</code>、<code class="literal">SELECT</code>、および <code class="literal">UPDATE</code> を付与できます。
      </p><p>
        管理者以外のユーザーには、グローバルな、または <code class="literal">mysql</code> データベースに対する <code class="literal">ALTER</code> 権限を付与してはいけません。それを行うと、そのユーザーはテーブルの名前を変更することによって権限システムの破壊を試みることができます。
      </p><p>
        特定の権限に関連付けられたセキュリティーリスクの詳細は、<a class="xref" href="security.html#privileges-provided" title="6.2.1 MySQL で提供される権限">セクション6.2.1「MySQL で提供される権限」</a>を参照してください。
      </p><a class="indexterm" name="idm139979079368416"></a><a class="indexterm" name="idm139979079366256"></a><p>
        いくつかの <code class="literal">WITH</code> 句オプションは、アカウントによるサーバーリソースの使用に関する制限を指定します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">MAX_QUERIES_PER_HOUR <em class="replaceable"><code>count</code></em></code>、<code class="literal">MAX_UPDATES_PER_HOUR <em class="replaceable"><code>count</code></em></code>、および <code class="literal">MAX_CONNECTIONS_PER_HOUR <em class="replaceable"><code>count</code></em></code> 制限は、いずれかの特定の 1 時間の間にこのアカウントに対して許可されるサーバーへのクエリー、更新、および接続の数を制限します。(結果がクエリーキャッシュから得られたクエリーは、<code class="literal">MAX_QUERIES_PER_HOUR</code> 制限に対してカウントされません。) <em class="replaceable"><code>count</code></em> が <code class="literal">0</code> (デフォルト) である場合、これは、このアカウントに対する制限が存在しないことを示します。
          </p></li><li class="listitem"><p>
            <code class="literal">MAX_USER_CONNECTIONS <em class="replaceable"><code>count</code></em></code> 制限は、このアカウントによるサーバーへの同時接続の最大数を制限します。0 以外の <em class="replaceable"><code>count</code></em> は、このアカウントに対する制限を明示的に指定します。<em class="replaceable"><code>count</code></em> が <code class="literal">0</code> (デフォルト) である場合、サーバーは、<code class="literal">max_user_connections</code> システム変数のグローバル値からこのアカウントの同時接続の数を決定します。<code class="literal">max_user_connections</code> もゼロである場合は、アカウントに制限がありません。
          </p></li></ul></div><p>
        既存の権限に影響を与えることなく既存のユーザーに対するリソース制限を指定するには、<code class="literal">GRANT USAGE</code> をグローバルレベルで使用し (<code class="literal">ON *.*</code>)、変更される制限を指定します。例:
      </p><pre class="programlisting">
GRANT USAGE ON *.* TO ...
  WITH MAX_QUERIES_PER_HOUR 500 MAX_UPDATES_PER_HOUR 100;
</pre><p>
        指定されない制限は、その現在の値を保持します。
      </p><p>
        サーバーリソースへのアクセス制限の詳細は、<a class="xref" href="security.html#user-resources" title="6.3.4 アカウントリソース制限の設定">セクション6.3.4「アカウントリソース制限の設定」</a>を参照してください。
      </p><a class="indexterm" name="idm139979079344384"></a><a class="indexterm" name="idm139979079342912"></a><p>
        MySQL は、ユーザー名とパスワードに基づいた通常の認証に加えて、X509 証明書の属性を確認できます。MySQL アカウントの SSL 関連オプションを指定するには、<code class="literal">GRANT</code> ステートメントの <code class="literal">REQUIRE</code> 句を使用します。(MySQL での SSL の使用に関する背景情報については、<a class="xref" href="security.html#ssl-connections" title="6.3.10 セキュアな接続のための SSL の使用">セクション6.3.10「セキュアな接続のための SSL の使用」</a>を参照してください。) 
      </p><p>
        特定のアカウントの接続タイプを制限するには、次のいくつかの可能性があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">REQUIRE NONE</code> は、このアカウントに SSL または X509 の要件がないことを示します。これは、SSL 関連の <code class="literal">REQUIRE</code> オプションが指定されていない場合のデフォルトです。ユーザー名とパスワードが有効であれば、暗号化されていない接続が許可されます。ただし、クライアントに適切な証明書と鍵ファイルが存在する場合は、そのクライアントのオプションで暗号化された接続も使用できます。つまり、クライアントはどの SSL コマンドオプションも指定する必要がなく、その場合は接続が暗号化されません。暗号化された接続を使用するには、クライアントは <code class="option">--ssl-ca</code> オプションか、または <code class="option">--ssl-ca</code>、<code class="option">--ssl-key</code>、<code class="option">--ssl-cert</code> の 3 つのすべてのオプションを指定する必要があります。
          </p></li><li class="listitem"><p>
            <code class="literal">REQUIRE SSL</code> オプションは、このアカウントの SSL 暗号化接続のみを許可するようサーバーに指示します。
          </p><pre class="programlisting">
GRANT ALL PRIVILEGES ON test.* TO 'root'@'localhost'
  IDENTIFIED BY 'goodsecret' REQUIRE SSL;
</pre><p>
            接続するには、クライアントはサーバー証明書を認証するための <code class="option">--ssl-ca</code> オプションを指定する必要があり、さらに <code class="option">--ssl-key</code> および <code class="option">--ssl-cert</code> オプションを指定する可能性があります。<code class="option">--ssl-ca</code> オプションと <code class="option">--ssl-capath</code> オプションのどちらも指定されていない場合、クライアントはサーバー証明書を認証しません。
          </p></li><li class="listitem"><p>
            <code class="literal">REQUIRE X509</code> は、クライアントに有効な証明書が存在する必要があるが、正確な証明書、発行者、およびサブジェクトは問題にならないことを示します。唯一の要件は、いずれかの CA 証明書でその署名を検証できるべきであるということです。
          </p><pre class="programlisting">
GRANT ALL PRIVILEGES ON test.* TO 'root'@'localhost'
  IDENTIFIED BY 'goodsecret' REQUIRE X509;
</pre><p>
            接続するには、クライアントは <code class="option">--ssl-ca</code>、<code class="option">--ssl-key</code>、および <code class="option">--ssl-cert</code> オプションを指定する必要があります。<code class="literal">REQUIRE</code> のオプション <code class="literal">ISSUER</code> や <code class="literal">SUBJECT</code> は暗黙的に <code class="literal">X509</code> を示しているため、これはまた、これらのオプションにも当てはまります。
          </p></li><li class="listitem"><p>
            <code class="literal">REQUIRE ISSUER '<em class="replaceable"><code>issuer</code></em>'</code> は、接続試行に対して、クライアントが CA <code class="literal">'<em class="replaceable"><code>issuer</code></em>'</code> によって発行された有効な X509 証明書を提供する必要があるという制限を設定します。クライアントが、有効ではあるが、別の発行者を含む証明書を提供した場合、サーバーはその接続を拒否します。X509 証明書の使用には常に暗号化が含まれるため、この場合、<code class="literal">SSL</code> オプションは必要ありません。
          </p><pre class="programlisting">
GRANT ALL PRIVILEGES ON test.* TO 'root'@'localhost'
  IDENTIFIED BY 'goodsecret'
  REQUIRE ISSUER '/C=FI/ST=Some-State/L=Helsinki/
    O=MySQL Finland AB/CN=Tonu Samuel/emailAddress=tonu@example.com';
</pre><p>
            <code class="literal">'<em class="replaceable"><code>issuer</code></em>'</code> 値は、1 つの文字列として入力するようにしてください。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              MySQL が 0.9.6h より古いバージョンの OpenSSL に対してリンクされている場合、<code class="literal">'<em class="replaceable"><code>issuer</code></em>'</code> 値には <code class="literal">emailAddress</code> ではなく <code class="literal">Email</code> を使用します。
            </p></div></li><li class="listitem"><p>
            <code class="literal">REQUIRE SUBJECT '<em class="replaceable"><code>subject</code></em>'</code> は、接続試行に対して、クライアントがサブジェクト <em class="replaceable"><code>subject</code></em> を含む有効な X509 証明書を提供する必要があるという制限を設定します。クライアントが、有効ではあるが、別のサブジェクトを含む証明書を提供した場合、サーバーはその接続を拒否します。
          </p><pre class="programlisting">
GRANT ALL PRIVILEGES ON test.* TO 'root'@'localhost'
  IDENTIFIED BY 'goodsecret'
  REQUIRE SUBJECT '/C=EE/ST=Some-State/L=Tallinn/
    O=MySQL demo client certificate/
    CN=Tonu Samuel/emailAddress=tonu@example.com';
</pre><p>
            <code class="literal">'<em class="replaceable"><code>subject</code></em>'</code> 値は、1 つの文字列として入力するようにしてください。MySQL は、この値と証明書内の値の単純な文字列比較を実行するため、大文字と小文字の区別やコンポーネントの順序は、証明書内に存在するものと正確に同じように指定する必要があります。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              <code class="literal">emailAddress</code> については、<code class="literal">REQUIRE ISSUER</code> の説明にある注を参照してください。
            </p></div></li><li class="listitem"><p>
            十分な強度の暗号化と鍵の長さが確実に使用されるようにするには、<code class="literal">REQUIRE CIPHER '<em class="replaceable"><code>cipher</code></em>'</code> が必要です。短い暗号化鍵を使用する古いアルゴリズムが使用されると、SSL 自体が弱くなる場合があります。このオプションを使用すると、接続に特定の暗号化方式を使用するように要求できます。
          </p><pre class="programlisting">
GRANT ALL PRIVILEGES ON test.* TO 'root'@'localhost'
  IDENTIFIED BY 'goodsecret'
  REQUIRE CIPHER 'EDH-RSA-DES-CBC3-SHA';
</pre></li></ul></div><p>
        <code class="literal">SUBJECT</code>、<code class="literal">ISSUER</code>、および <code class="literal">CIPHER</code> オプションを <code class="literal">REQUIRE</code> 句内で次のように組み合わせることができます。
      </p><pre class="programlisting">
GRANT ALL PRIVILEGES ON test.* TO 'root'@'localhost'
  IDENTIFIED BY 'goodsecret'
  REQUIRE SUBJECT '/C=EE/ST=Some-State/L=Tallinn/
    O=MySQL demo client certificate/
    CN=Tonu Samuel/emailAddress=tonu@example.com'
  AND ISSUER '/C=FI/ST=Some-State/L=Helsinki/
    O=MySQL Finland AB/CN=Tonu Samuel/emailAddress=tonu@example.com'
  AND CIPHER 'EDH-RSA-DES-CBC3-SHA';
</pre><p>
        これらのオプションの順序は問題になりませんが、どのオプションも 2 回指定することはできません。<code class="literal">AND</code> キーワードは、<code class="literal">REQUIRE</code> オプション間のオプションです。
      </p><p>
        1 人のユーザーのテーブル、カラム、またはルーチン権限を使用している場合でも、サーバーはすべてのユーザーのテーブル、カラム、およびルーチン権限を検査するため、これにより MySQL が少し遅くなります。同様に、いずれかのユーザーのクエリー、更新、または接続の数を制限した場合、サーバーはこれらの値をモニターする必要があります。
      </p><h5><a name="grant-mysql-vs-standard-sql"></a>MySQL バージョンと標準 SQL バージョンの GRANT</h5><a class="indexterm" name="idm139979079282832"></a><p>
        MySQL バージョンと標準 SQL バージョンの <code class="literal">GRANT</code> の最大の違いは次のとおりです。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            MySQL は、権限をユーザー名だけではなく、ホスト名とユーザー名の組み合わせに関連付けます。
          </p></li><li class="listitem"><p>
            標準 SQL はグローバルまたはデータベースレベルの権限を持たず、また MySQL がサポートするすべての権限タイプをサポートしているわけでもありません。
          </p></li><li class="listitem"><p>
            MySQL は、標準 SQL の <code class="literal">UNDER</code> 権限をサポートしていません。
          </p></li><li class="listitem"><p>
            標準 SQL の権限は、階層的な方法で構造化されています。ユーザーを削除した場合は、そのユーザーに付与されていたすべての権限が取り消されます。これはまた、<code class="literal">DROP USER</code> を使用した場合の MySQL にも当てはまります。<a class="xref" href="sql-syntax.html#drop-user" title="13.7.1.3 DROP USER 構文">セクション13.7.1.3「DROP USER 構文」</a>を参照してください。
          </p></li><li class="listitem"><p>
            標準 SQL では、テーブルを削除すると、そのテーブルに対するすべての権限が取り消されます。標準 SQL では、権限を取り消すと、その権限に基づいて付与されていたすべての権限も取り消されます。MySQL では、権限は明示的な <code class="literal">DROP USER</code> または <code class="literal">REVOKE</code> ステートメントを使用するか、あるいは MySQL 付与テーブルを直接操作することによってのみ削除できます。
          </p></li><li class="listitem"><p>
            MySQL では、テーブル内の一部のカラムに対してのみ <code class="literal">INSERT</code> 権限を持つことができます。この場合、<code class="literal">INSERT</code> 権限を持っているカラムの値のみを挿入するのであれば、そのテーブルに対して引き続き <code class="literal">INSERT</code> ステートメントを実行できます。厳密な SQL モードが有効になっていない場合、省略されたカラムはその暗黙のデフォルト値に設定されます。厳密モードでは、省略されたカラムのいずれかにデフォルト値がない場合、このステートメントは拒否されます。(標準 SQL では、すべてのカラムに対して <code class="literal">INSERT</code> 権限を持つ必要があります。) <a class="xref" href="server-administration.html#sql-mode" title="5.1.7 サーバー SQL モード">セクション5.1.7「サーバー SQL モード」</a>では、厳密モードについて説明しています。<a class="xref" href="data-types.html#data-type-defaults" title="11.6 データ型デフォルト値">セクション11.6「データ型デフォルト値」</a>では、暗黙のデフォルト値について説明しています。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="rename-user"></a>13.7.1.5 RENAME USER 構文</h4></div></div></div><a class="indexterm" name="idm139979079259568"></a><a class="indexterm" name="idm139979079258256"></a><a class="indexterm" name="idm139979079256064"></a><pre class="programlisting">
RENAME USER <em class="replaceable"><code>old_user</code></em> TO <em class="replaceable"><code>new_user</code></em>
    [, <em class="replaceable"><code>old_user</code></em> TO <em class="replaceable"><code>new_user</code></em>] ...
</pre><p>
        <code class="literal">RENAME USER</code> ステートメントは、既存の MySQL アカウントの名前を変更します。存在しない古いアカウント、またはすでに存在する新しいアカウントに対しては、エラーが発生します。このステートメントを使用するには、<code class="literal">mysql</code> データベースに対するグローバルな <code class="literal">CREATE USER</code> 権限または <code class="literal">UPDATE</code> 権限が必要です。
      </p><p>
        各アカウント名には、<a class="xref" href="security.html#account-names" title="6.2.3 アカウント名の指定">セクション6.2.3「アカウント名の指定」</a>で説明されている形式が使用されます。例:
      </p><pre class="programlisting">
RENAME USER 'jeffrey'@'localhost' TO 'jeff'@'127.0.0.1';
</pre><p>
        アカウント名のユーザー名の部分のみを指定した場合は、<code class="literal">'%'</code> のホスト名の部分が使用されます。
      </p><p>
        <code class="literal">RENAME USER</code> により、古いユーザーによって保持されていた権限は新しいユーザーによって保持される権限になります。ただし、<code class="literal">RENAME USER</code> は、古いユーザーが作成したどのデータベースまたはそれらのデータベース内のどのオブジェクトも自動的には削除したり、無効にしたりしません。これには、<code class="literal">DEFINER</code> 属性に古いユーザーが指定されているストアドプログラムまたはビューが含まれます。このようなオブジェクトにアクセスしようとすると、それが定義者のセキュリティーコンテキストで実行された場合は、エラーが生成される可能性があります。(セキュリティーコンテキストについては、<a class="xref" href="stored-programs-views.html#stored-programs-security" title="20.6 ストアドプログラムおよびビューのアクセスコントロール">セクション20.6「ストアドプログラムおよびビューのアクセスコントロール」</a>を参照してください。) 
      </p><p>
        権限の変更は、<a class="xref" href="security.html#privilege-changes" title="6.2.6 権限変更が有効化される時期">セクション6.2.6「権限変更が有効化される時期」</a>に示されているように有効になります。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="revoke"></a>13.7.1.6 REVOKE 構文</h4></div></div></div><a class="indexterm" name="idm139979079233616"></a><a class="indexterm" name="idm139979079232304"></a><a class="indexterm" name="idm139979079231024"></a><a class="indexterm" name="idm139979079228880"></a><a class="indexterm" name="idm139979079227520"></a><pre class="programlisting">
REVOKE
    <em class="replaceable"><code>priv_type</code></em> [(<em class="replaceable"><code>column_list</code></em>)]
      [, <em class="replaceable"><code>priv_type</code></em> [(<em class="replaceable"><code>column_list</code></em>)]] ...
    ON [<em class="replaceable"><code>object_type</code></em>] <em class="replaceable"><code>priv_level</code></em>
    FROM <em class="replaceable"><code>user</code></em> [, <em class="replaceable"><code>user</code></em>] ...

REVOKE ALL PRIVILEGES, GRANT OPTION
    FROM <em class="replaceable"><code>user</code></em> [, <em class="replaceable"><code>user</code></em>] ...

REVOKE PROXY ON <em class="replaceable"><code>user</code></em>
    FROM <em class="replaceable"><code>user</code></em> [, <em class="replaceable"><code>user</code></em>] ...
</pre><p>
        <code class="literal">REVOKE</code> ステートメントを使用すると、システム管理者は MySQL アカウントから権限を取り消すことができます。各アカウント名には、<a class="xref" href="security.html#account-names" title="6.2.3 アカウント名の指定">セクション6.2.3「アカウント名の指定」</a>で説明されている形式が使用されます。例:
      </p><pre class="programlisting">
REVOKE INSERT ON *.* FROM 'jeffrey'@'localhost';
</pre><p>
        アカウント名のユーザー名の部分のみを指定した場合は、<code class="literal">'%'</code> のホスト名の部分が使用されます。
      </p><p>
        各権限が存在するレベル、<em class="replaceable"><code>priv_type</code></em> と <em class="replaceable"><code>priv_level</code></em> の許可される値、およびユーザーとパスワードを指定するための構文の詳細は、<a class="xref" href="sql-syntax.html#grant" title="13.7.1.4 GRANT 構文">セクション13.7.1.4「GRANT 構文」</a>を参照してください。
      </p><p>
        最初の <code class="literal">REVOKE</code> 構文を使用するには、<code class="literal">GRANT OPTION</code> 権限が必要であり、かつ取り消そうとしている権限を持っている必要があります。
      </p><p>
        すべての権限を取り消すには、2 番目の構文を使用します。これにより、指定された 1 人または複数のユーザーのすべてのグローバル、データベース、テーブル、カラム、およびルーチン権限が削除されます。
      </p><pre class="programlisting">
REVOKE ALL PRIVILEGES, GRANT OPTION FROM <em class="replaceable"><code>user</code></em> [, <em class="replaceable"><code>user</code></em>] ...
</pre><p>
        この <code class="literal">REVOKE</code> 構文を使用するには、<code class="literal">mysql</code> データベースに対するグローバルな <code class="literal">CREATE USER</code> 権限または <code class="literal">UPDATE</code> 権限が必要です。
      </p><p>
        <code class="literal">REVOKE</code> は権限を削除しますが、<code class="literal">mysql.user</code> テーブルエントリは削除しません。ユーザーアカウントを完全に削除するには、<code class="literal">DROP USER</code> (<a class="xref" href="sql-syntax.html#drop-user" title="13.7.1.3 DROP USER 構文">セクション13.7.1.3「DROP USER 構文」</a>を参照してください) または <code class="literal">DELETE</code> を使用します。
      </p><p>
        付与テーブルに、大文字と小文字が混在したデータベースまたはテーブル名を含む権限行が保持されており、かつ <code class="literal">lower_case_table_names</code> システム変数が 0 以外の値に設定されている場合は、<code class="literal">REVOKE</code> を使用してこれらの権限を取り消すことはできません。付与テーブルを直接操作することが必要になります。(<code class="literal">lower_case_table_names</code> が設定されているとき、<code class="literal">GRANT</code> はこのような行を作成しませんが、その変数が設定される前にこのような行が作成されていた可能性があります。) 
      </p><p>
        <span class="command"><strong>mysql</strong></span> プログラムから正常に実行された場合、<code class="literal">REVOKE</code> は <code class="literal">Query OK, 0 rows affected</code> で応答します。この操作によってどのような権限が付与されたかを判定するには、<code class="literal">SHOW GRANTS</code> を使用します。<a class="xref" href="sql-syntax.html#show-grants" title="13.7.5.22 SHOW GRANTS 構文">セクション13.7.5.22「SHOW GRANTS 構文」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="set-password"></a>13.7.1.7 SET PASSWORD 構文</h4></div></div></div><a class="indexterm" name="idm139979079182560"></a><a class="indexterm" name="idm139979079181248"></a><a class="indexterm" name="idm139979079179104"></a><pre class="programlisting">
SET PASSWORD [FOR <em class="replaceable"><code>user</code></em>] =
    {
        PASSWORD('<em class="replaceable"><code>cleartext password</code></em>')
      | OLD_PASSWORD('<em class="replaceable"><code>cleartext password</code></em>')
      | '<em class="replaceable"><code>encrypted password</code></em>'
    }
</pre><p>
        <code class="literal">SET PASSWORD</code> ステートメントは、MySQL ユーザーアカウントにパスワードを割り当てます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">FOR <em class="replaceable"><code>user</code></em></code> 句を指定しない場合、このステートメントは、現在のユーザーのパスワードを設定します。
          </p><pre class="programlisting">
SET PASSWORD = PASSWORD('<em class="replaceable"><code>cleartext password</code></em>');
</pre><p>
            匿名以外のアカウントを使用してサーバーに接続したクライアントはすべて、そのアカウントのパスワードを変更できます。サーバーがどのアカウントを自動式に認証したかを表示するには、<code class="literal">CURRENT_USER()</code> 関数を呼び出します。
          </p><pre class="programlisting">
SELECT CURRENT_USER();
</pre></li><li class="listitem"><p>
            <code class="literal">FOR <em class="replaceable"><code>user</code></em></code> 句を指定した場合、このステートメントは、指定されたアカウントのパスワードを設定します。ただし、そのアカウントが存在する必要があります。
          </p><pre class="programlisting">
SET PASSWORD FOR 'jeffrey'@'localhost' = PASSWORD('<em class="replaceable"><code>cleartext password</code></em>');
</pre><p>
            この場合は、<code class="literal">mysql</code> データベースに対する <code class="literal">UPDATE</code> 権限が必要です。
          </p></li></ul></div><p>
        <code class="literal">read_only</code> システム変数が有効になっている場合、<code class="literal">SET PASSWORD</code> には、ほかのすべての必要な権限に加えて <code class="literal">SUPER</code> 権限が必要です。
      </p><p>
        <code class="literal">FOR <em class="replaceable"><code>user</code></em></code> 句が指定されている場合、このアカウント名には、<a class="xref" href="security.html#account-names" title="6.2.3 アカウント名の指定">セクション6.2.3「アカウント名の指定」</a>で説明されている形式が使用されます。<em class="replaceable"><code>user</code></em> 値は、<code class="literal">'<em class="replaceable"><code>user_name</code></em>'@'<em class="replaceable"><code>host_name</code></em>'</code> として指定するようにしてください。ここで、<code class="literal">'<em class="replaceable"><code>user_name</code></em>'</code> と <code class="literal">'<em class="replaceable"><code>host_name</code></em>'</code> は、そのアカウントの <code class="literal">mysql.user</code> テーブル行の <code class="literal">User</code> および <code class="literal">Host</code> カラムにリストされている内容とまったく同じです。(ユーザー名のみを指定した場合は、<code class="literal">'%'</code> のホスト名が使用されます。) たとえば、<code class="literal">'bob'</code> と <code class="literal">'%.example.org'</code> の <code class="literal">User</code> および <code class="literal">Host</code> カラム値を使用してアカウントのパスワードを設定するには、このステートメントを次のように記述します。
      </p><pre class="programlisting">
SET PASSWORD FOR 'bob'@'%.example.org' = PASSWORD('<em class="replaceable"><code>cleartext password</code></em>');
</pre><p>
        パスワードは、次の方法で指定できます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">PASSWORD()</code> 関数を使用して
          </p><p>
            この関数の引数は、平文 (暗号化されていない) パスワードです。<code class="literal">PASSWORD()</code> はパスワードをハッシュし、暗号化されたパスワード文字列を返します。
          </p><p>
            <code class="literal">old_passwords</code> システム変数値により、<code class="literal">PASSWORD()</code> によって使用されるハッシュ方式が決定されます。<code class="literal">SET PASSWORD</code> がパスワードを正しい形式でないとして拒否した場合は、ハッシュ方式を変更するために <code class="literal">old_passwords</code> を変更することが必要になる可能性があります。たとえば、そのアカウントが <code class="literal">mysql_native_password</code> プラグインを使用している場合、<code class="literal">old_passwords</code> 値は 0 である必要があります。
          </p><pre class="programlisting">
SET old_passwords = 0;
SET PASSWORD FOR 'jeffrey'@'localhost' = PASSWORD('mypass');
</pre><p>
            <code class="literal">old_passwords</code> 値が認証プラグインに必要な値と異なる場合は、<code class="literal">PASSWORD()</code> によって返されたハッシュされたパスワード値がそのプラグインに許容されず、パスワードを設定しようとするとエラーが生成されます。例:
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET old_passwords = 1;</code></strong>
mysql&gt; <strong class="userinput"><code>SET PASSWORD FOR 'jeffrey'@'localhost' = PASSWORD('mypass');</code></strong>
ERROR 1372 (HY000): Password hash should be a 41-digit hexadecimal number
</pre></li><li class="listitem"><p>
            <code class="literal">OLD_PASSWORD()</code> 関数を使用して:
          </p><p>
            この関数の引数は、平文 (暗号化されていない) パスワードです。<code class="literal">OLD_PASSWORD()</code> は 4.1 より前のハッシュを使用してパスワードをハッシュし、暗号化されたパスワード文字列を返します。このハッシュ方式は、<code class="literal">mysql_old_password</code> 認証プラグインを使用するアカウントにのみ適しています。
          </p></li><li class="listitem"><p>
            すでに暗号化されたパスワード文字列を使用して
          </p><p>
            このパスワードは、文字列リテラルとして指定されます。これは、このアカウントに使用されている認証方法に必要なハッシュ形式の、すでに暗号化されたパスワード値を表している必要があります。
          </p></li></ul></div><p>
        次の表は、<code class="literal">old_passwords</code> の許可される値、それぞれの値に対するパスワードハッシュ方式、およびそれぞれの方式でハッシュされたパスワードを使用する認証プラグインを示します。これらの値は MySQL 5.6.6 以降で許可されます。5.6.6 より前では、許可される値は 0 (または <code class="literal">OFF</code>) および 1 (または <code class="literal">ON</code>) です。
      </p><div class="informaltable"><table summary="次の表は、old_passwords の許可される値、それぞれの値に対するパスワードハッシュ方式、およびそれぞれの方式でハッシュされたパスワードを使用する認証プラグインを示します。" border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">値</th><th scope="col">パスワードハッシュ方式</th><th scope="col">関連付けられた認証プラグイン</th></tr></thead><tbody><tr><td scope="row">0</td><td>MySQL 4.1 ネイティブハッシュ</td><td><code class="literal">mysql_native_password</code></td></tr><tr><td scope="row">1</td><td>4.1 以前の (<span class="quote">「<span class="quote">古い</span>」</span>) ハッシュ</td><td><code class="literal">mysql_old_password</code></td></tr><tr><td scope="row">2</td><td>SHA-256 ハッシュ</td><td><code class="literal">sha256_password</code></td></tr></tbody></table></div><p>
        パスワードの設定の詳細は、<a class="xref" href="security.html#assigning-passwords" title="6.3.5 アカウントパスワードの割り当て">セクション6.3.5「アカウントパスワードの割り当て」</a>を参照してください。
      </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          状況によっては、<code class="literal">SET PASSWORD</code> がサーバーログ、またはクライアント側にある <code class="filename">~/.mysql_history</code> などの履歴ファイル内に記録されることがあります。つまり、平文のパスワードが、その情報に対する読み取りアクセス権を持つ任意のユーザーによって読み取られる可能性があります。これがサーバーログで発生する条件およびこれを制御する方法については、<a class="xref" href="security.html#password-logging" title="6.1.2.3 パスワードおよびロギング">セクション6.1.2.3「パスワードおよびロギング」</a>を参照してください。クライアント側のロギングに関する同様の情報については、<a class="xref" href="programs.html#mysql-logging" title="4.5.1.3 mysql のロギング">セクション4.5.1.3「mysql のロギング」</a>を参照してください。
        </p></div><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注意</div><p>
          4.1 より前のクライアントプログラムを使用して MySQL 4.1 以降のサーバーに接続している場合は、パスワードを変更する前に、必ず<a class="xref" href="security.html#password-hashing" title="6.1.2.4 MySQL でのパスワードハッシュ">セクション6.1.2.4「MySQL でのパスワードハッシュ」</a>を読んでください。デフォルトのパスワードハッシュ形式が MySQL 4.1 で変更されたため、パスワードを変更すると、そのパスワードが 4.1 より前のクライアントが生成できないハッシュ形式を使用して格納され、それにより、あとでサーバーに接続できなくなる可能性があります。
        </p></div><p>
        MySQL レプリケーションを使用している場合は、現在、<code class="literal">CHANGE MASTER TO</code> ステートメントの一部としてレプリケーションスレーブで使用されるパスワードは、実質的に長さが 32 文字に制限されます。パスワードがこれより長い場合、超過した文字はすべて切り捨てられます。これは、一般に MySQL Server によって適用される制限のためではなく、どちらかというと、MySQL レプリケーションに固有の問題です。(詳細は、Bug #43439 を参照してください。) 
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="table-maintenance-sql"></a>13.7.2 テーブル保守ステートメント</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-syntax.html#analyze-table">13.7.2.1 ANALYZE TABLE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#check-table">13.7.2.2 CHECK TABLE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#checksum-table">13.7.2.3 CHECKSUM TABLE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#optimize-table">13.7.2.4 OPTIMIZE TABLE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#repair-table">13.7.2.5 REPAIR TABLE 構文</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="analyze-table"></a>13.7.2.1 ANALYZE TABLE 構文</h4></div></div></div><a class="indexterm" name="idm139979079085232"></a><pre class="programlisting">
ANALYZE [NO_WRITE_TO_BINLOG | LOCAL] TABLE
    <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ...
</pre><p>
        <code class="literal">ANALYZE TABLE</code> は、テーブルのキー分布を分析して格納します。分析中、そのテーブルは <code class="literal">InnoDB</code> および <code class="literal">MyISAM</code> に対する読み取りロックでロックされます。このステートメントは、<code class="literal">InnoDB</code>、<code class="literal">NDB</code>、および <code class="literal">MyISAM</code> テーブルで機能します。<code class="literal">MyISAM</code> テーブルの場合、このステートメントは <span class="command"><strong>myisamchk --analyze</strong></span> を使用することと同等です。
      </p><p>
        <code class="literal">InnoDB</code> 内で分析がどのように機能するかの詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="14.13.16.1 永続的オプティマイザ統計のパラメータの構成">セクション14.13.16.1「永続的オプティマイザ統計のパラメータの構成」</a>および<a class="xref" href="innodb-storage-engine.html#innodb-analyze-table-complexity" title="14.13.17 InnoDB テーブルに対する ANALYZE TABLE の複雑さの推定">セクション14.13.17「InnoDB テーブルに対する ANALYZE TABLE の複雑さの推定」</a>を参照してください。<a class="xref" href="innodb-storage-engine.html#innodb-restrictions" title="14.6.7 InnoDB テーブル上の制限">セクション14.6.7「InnoDB テーブル上の制限」</a>も参照してください。特に、<code class="literal">innodb_stats_persistent</code> オプションを有効にした場合は、<code class="literal">InnoDB</code> テーブルに大量のデータをロードするか、またはそのテーブルの新しいインデックスを作成したあとに <code class="literal">ANALYZE TABLE</code> を実行する必要があります。
      </p><p>
        MySQL は、格納されたキー分布を使用して、定数以外の何かに対して結合が実行されたときにテーブルを結合する順序を決定します。さらに、クエリー内の特定のテーブルにどのインデックスを使用するかを決定する場合は、キー分布を使用できます。
      </p><p>
        このステートメントには、このテーブルに対する <code class="literal">SELECT</code> および <code class="literal">INSERT</code> 権限が必要です。
      </p><p>
        <code class="literal">ANALYZE TABLE</code> はパーティション化されたテーブルに対してサポートされているため、<code class="literal">ALTER TABLE ... ANALYZE PARTITION</code> を使用して 1 つ以上のパーティションを分析できます。詳細は、<a class="xref" href="sql-syntax.html#alter-table" title="13.1.7 ALTER TABLE 構文">セクション13.1.7「ALTER TABLE 構文」</a>および<a class="xref" href="partitioning.html#partitioning-maintenance" title="19.3.4 パーティションの保守">セクション19.3.4「パーティションの保守」</a>を参照してください。
      </p><p>
        MySQL 5.6.11 でのみ、このステートメントを発行する前に、<code class="literal">gtid_next</code> を <code class="literal">AUTOMATIC</code> に設定する必要があります。(Bug #16062608、Bug #16715809、Bug #69045)
      </p><p>
        <code class="literal">ANALYZE TABLE</code> は、次のカラムを含む結果セットを返します。
      </p><div class="informaltable"><table summary="この表は、ANALYZE TABLE の結果セットのカラムについて説明しています。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">カラム</th><th scope="col">値</th></tr></thead><tbody><tr><td scope="row"><code class="literal">Table</code></td><td>テーブル名</td></tr><tr><td scope="row"><code class="literal">Op</code></td><td>常に <code class="literal">analyze</code></td></tr><tr><td scope="row"><code class="literal">Msg_type</code></td><td><code class="literal">status</code>、<code class="literal">error</code>、<code class="literal">info</code>、<code class="literal">note</code>、または <code class="literal">warning</code></td></tr><tr><td scope="row"><code class="literal">Msg_text</code></td><td>情報メッセージ</td></tr></tbody></table></div><p>
        <code class="literal">SHOW INDEX</code> ステートメントを使用して、格納されたキー分布を確認できます。<a class="xref" href="sql-syntax.html#show-index" title="13.7.5.23 SHOW INDEX 構文">セクション13.7.5.23「SHOW INDEX 構文」</a>を参照してください。
      </p><p>
        テーブルが最後の <code class="literal">ANALYZE TABLE</code> ステートメントのあとに変更されていない場合、そのテーブルが再度分析されることはありません。
      </p><p>
        デフォルトでは、サーバーは <code class="literal">ANALYZE TABLE</code> ステートメントをバイナリログに書き込み、それらがレプリケーションスレーブにレプリケートされるようにします。ロギングを抑制するには、オプションの <code class="literal">NO_WRITE_TO_BINLOG</code> キーワード、またはそのエイリアス <code class="literal">LOCAL</code> を指定します。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="check-table"></a>13.7.2.2 CHECK TABLE 構文</h4></div></div></div><a class="indexterm" name="idm139979079030656"></a><pre class="programlisting">
CHECK TABLE <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ... [<em class="replaceable"><code>option</code></em>] ...

<em class="replaceable"><code>option</code></em> = {FOR UPGRADE | QUICK | FAST | MEDIUM | EXTENDED | CHANGED}
</pre><p>
        <code class="literal">CHECK TABLE</code> は、1 つまたは複数のテーブルをエラーがないかどうかチェックします。<code class="literal">CHECK TABLE</code> は、<code class="literal">InnoDB</code>、<code class="literal">MyISAM</code>、<code class="literal">ARCHIVE</code>、および <code class="literal">CSV</code> テーブルに対して機能します。<code class="literal">MyISAM</code> テーブルの場合は、キー統計の更新も実行されます。
      </p><p>
        テーブルをチェックするには、それに対する何らかの権限が必要です。
      </p><p>
        <code class="literal">CHECK TABLE</code> はまた、ビューをチェックして、そのビュー定義で参照されているテーブルが存在しなくなっているなどの問題がないかどうかを調べることもできます。
      </p><p>
        <code class="literal">CHECK TABLE</code> はパーティション化されたテーブルに対してサポートされているため、<code class="literal">ALTER TABLE ... CHECK PARTITION</code> を使用して 1 つ以上のパーティションをチェックできます。詳細は、<a class="xref" href="sql-syntax.html#alter-table" title="13.1.7 ALTER TABLE 構文">セクション13.1.7「ALTER TABLE 構文」</a>および<a class="xref" href="partitioning.html#partitioning-maintenance" title="19.3.4 パーティションの保守">セクション19.3.4「パーティションの保守」</a>を参照してください。
      </p><p>
        MySQL 5.6.11 でのみ、このステートメントを発行する前に、<code class="literal">gtid_next</code> を <code class="literal">AUTOMATIC</code> に設定する必要があります。(Bug #16062608、Bug #16715809、Bug #69045)
      </p><h5><a name="idm139979079008416"></a>出力</h5><p>
        <code class="literal">CHECK TABLE</code> は、次のカラムを含む結果セットを返します。
      </p><div class="informaltable"><table summary="この表は、CHECK TABLE の結果セットのカラムについて説明しています。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">カラム</th><th scope="col">値</th></tr></thead><tbody><tr><td scope="row"><code class="literal">Table</code></td><td>テーブル名</td></tr><tr><td scope="row"><code class="literal">Op</code></td><td>常に <code class="literal">check</code></td></tr><tr><td scope="row"><code class="literal">Msg_type</code></td><td><code class="literal">status</code>、<code class="literal">error</code>、<code class="literal">info</code>、<code class="literal">note</code>、または <code class="literal">warning</code></td></tr><tr><td scope="row"><code class="literal">Msg_text</code></td><td>情報メッセージ</td></tr></tbody></table></div><p>
        このステートメントによって、チェックされたテーブルごとに多数の情報行が生成される可能性があります。最後の行には <code class="literal">status</code> の <code class="literal">Msg_type</code> 値が含まれ、<code class="literal">Msg_text</code> は通常 <code class="literal">OK</code> になります。<code class="literal">OK</code> または <code class="literal">Table is already up to date</code> が得られない場合は通常、そのテーブルの修復を実行するべきです。<a class="xref" href="backup-and-recovery.html#myisam-table-maintenance" title="7.6 MyISAM テーブルの保守とクラッシュリカバリ">セクション7.6「MyISAM テーブルの保守とクラッシュリカバリ」</a>を参照してください。<code class="literal">Table is already up to date</code> は、そのテーブルのストレージエンジンがテーブルのチェックは必要ないと判断したことを示します。
      </p><h5><a name="idm139979078983376"></a>バージョン互換性のチェック</h5><p>
        <code class="literal">FOR UPGRADE</code> オプションは、指定されたテーブルが現在のバージョンの MySQL と互換性があるかどうかをチェックします。<code class="literal">FOR UPGRADE</code> を指定すると、サーバーは各テーブルをチェックして、テーブルの作成後にそのテーブルのいずれかのデータ型またはインデックスで互換性のない変更が発生しているかどうかを判定します。発生していない場合は、チェックが成功します。それ以外で、非互換性の可能性がある場合、サーバーはそのテーブルに対して完全なチェックを実行します (これには、ある程度時間がかかることがあります)。完全なチェックが成功した場合、サーバーは、そのテーブルの <code class="filename">.frm</code> ファイルを現在の MySQL バージョン番号でマークします。<code class="filename">.frm</code> ファイルをマークすると、このテーブルに対する同じバージョンのサーバーによるそれ以降のチェックが確実に速くなります。
      </p><p>
        データ型のストレージフォーマットが変更されたか、またはそのソート順序が変更されたために非互換性が発生する可能性があります。弊社の目的はそれらの変更を避けることですが、各リリースの間の非適合性よりもさらに深刻な問題を修正するために必要である場合もあります。
      </p><p>
        現在、<code class="literal">FOR UPGRADE</code> では、次の非互換性が検出されています。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">InnoDB</code> および <code class="literal">MyISAM</code> テーブルの <code class="literal">TEXT</code> カラム内の最後の領域のインデックス順序が MySQL 4.1 と 5.0 の間で変更されました。
          </p></li><li class="listitem"><p>
            新しい <code class="literal">DECIMAL</code> データ型のストレージ方法が MySQL 5.0.3 と 5.0.5 の間で変更されました。
          </p></li><li class="listitem"><p>
            テーブルが、現在実行しているものとは異なるバージョンの MySQL サーバーによって作成された場合、<code class="literal">FOR UPGRADE</code> は、そのテーブルに互換性のないバージョンの <code class="filename">.frm</code> ファイルが含まれていることを示します。この場合、<code class="literal">CHECK TABLE</code> によって返される結果セットには、<code class="literal">Msg_type</code> 値が <code class="literal">error</code> で、<code class="literal">Msg_text</code> 値が <code class="literal">Table upgrade required. Please do "REPAIR TABLE `<em class="replaceable"><code>tbl_name</code></em>`" to fix it!</code> である行が含まれています。
          </p></li><li class="listitem"><p>
            文字セットまたは照合順序に対して、テーブルインデックスの再構築が必要な変更が加えられる場合があります。これらの変更や、それが <code class="literal">FOR UPGRADE</code> によっていつ検出されるかの詳細は、<a class="xref" href="installing.html#checking-table-incompatibilities" title="2.11.3 テーブルまたはインデックスの再構築が必要かどうかのチェック">セクション2.11.3「テーブルまたはインデックスの再構築が必要かどうかのチェック」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">YEAR(2)</code> データ型は、MySQL 5.6.6 の時点では非推奨です。<code class="literal">YEAR(2)</code> カラムを含むテーブルの場合、<code class="literal">CHECK TABLE</code> では、<code class="literal">YEAR(2)</code> を <code class="literal">YEAR(4)</code> に変換する <code class="literal">REPAIR TABLE</code> が推奨されます。
          </p></li></ul></div><h5><a name="idm139979078952208"></a>データ一貫性のチェック</h5><p>
        指定できるその他のチェックオプションを次の表に示します。これらのオプションはストレージエンジンに渡されますが、そこで使用される場合とされない場合があります。
      </p><div class="informaltable"><table summary="この表は、その他の CHECK TABLE オプションについて説明しています。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">型</th><th scope="col">意味</th></tr></thead><tbody><tr><td scope="row"><code class="literal">QUICK</code></td><td>正しくないリンクをチェックするための行のスキャンを行いません。<code class="literal">InnoDB</code> および <code class="literal">MyISAM</code> テーブルとビューに適用されます。</td></tr><tr><td scope="row"><code class="literal">FAST</code></td><td>正しく閉じられていないテーブルのみを検査します。<code class="literal">MyISAM</code> テーブルとビューにのみ適用されます。<code class="literal">InnoDB</code> では無視されます。</td></tr><tr><td scope="row"><code class="literal">CHANGED</code></td><td>最後のチェック以降に変更されたか、または正しく閉じられていないテーブルのみをチェックします。<code class="literal">MyISAM</code> テーブルとビューにのみ適用されます。<code class="literal">InnoDB</code> では無視されます。</td></tr><tr><td scope="row"><code class="literal">MEDIUM</code></td><td>削除されたリンクが有効であることを検証するために行をスキャンします。また、行のキーチェックサムも計算し、キーの計算されたチェックサムを使用してこれを検証します。<code class="literal">MyISAM</code> テーブルとビューにのみ適用されます。<code class="literal">InnoDB</code> では無視されます。</td></tr><tr><td scope="row"><code class="literal">EXTENDED</code></td><td>行ごとにすべてのキーの完全なキールックアップを実行します。これにより、テーブルの 100% の整合性が保証されますが、長い時間がかかります。<code class="literal">MyISAM</code> テーブルとビューにのみ適用されます。<code class="literal">InnoDB</code> では無視されます。</td></tr></tbody></table></div><p>
        <code class="literal">QUICK</code>、<code class="literal">MEDIUM</code>、または <code class="literal">EXTENDED</code> オプションのいずれも指定されていない場合、動的フォーマットの <code class="literal">MyISAM</code> テーブルに対するデフォルトのチェックタイプは <code class="literal">MEDIUM</code> です。これにより、そのテーブルに対して <span class="command"><strong>myisamchk --medium-check <em class="replaceable"><code>tbl_name</code></em></strong></span> を実行したのと同じ結果が得られます。また、<code class="literal">CHANGED</code> または <code class="literal">FAST</code> が指定されていないかぎり、静的フォーマットの <code class="literal">MyISAM</code> テーブルに対するデフォルトのチェックタイプも <code class="literal">MEDIUM</code> です。指定されている場合、デフォルトは <code class="literal">QUICK</code> です。<code class="literal">CHANGED</code> および <code class="literal">FAST</code> の場合、行はめったに破損しないため、行スキャンはスキップされます。
      </p><p>
        チェックオプションは、次の例のように組み合わせることができます。この例では、テーブルが正しく閉じられたかどうかを判定するために、そのテーブルに対してすばやいチェックを実行します。
      </p><pre class="programlisting">
CHECK TABLE test_table FAST QUICK;
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          場合によっては、<code class="literal">CHECK TABLE</code> によってテーブルが変更されます。これは、テーブルが<span class="quote">「<span class="quote">破損している</span>」</span>または<span class="quote">「<span class="quote">正しく閉じられていない</span>」</span>としてマークされているが、<code class="literal">CHECK TABLE</code> でそのテーブル内に何も問題が見つからなかった場合に発生します。この場合、<code class="literal">CHECK TABLE</code> はそのテーブルを正常としてマークします。
        </p></div><p>
        テーブルが破損している場合、もっとも可能性が高いのはデータ部分ではなく、インデックス内の問題です。前のチェックタイプはすべて、インデックスを徹底的にチェックするため、ほとんどのエラーが見つかるはずです。
      </p><p>
        正常と見なしているテーブルをチェックするだけの場合は、チェックオプションを使用しないか、または <code class="literal">QUICK</code> オプションを使用するようにしてください。後者は、急いでおり、かつ <code class="literal">QUICK</code> でデータファイル内のエラーが見つからないという非常に小さなリスクを負える場合に使用するようにしてください。(ほとんどの場合、通常の使用状況では、MySQL でデータファイル内のどのようなエラーも見つかります。見つかった場合、そのテーブルは<span class="quote">「<span class="quote">破損している</span>」</span>としてマークされ、修復されるまで使用できなくなります。) 
      </p><p>
        <code class="literal">FAST</code> および <code class="literal">CHANGED</code> は主に、テーブルをときどきチェックする場合にスクリプトから使用される (たとえば、<span class="command"><strong>cron</strong></span> から実行される) ことを目的にしています。ほとんどの場合、<code class="literal">FAST</code> は <code class="literal">CHANGED</code> より優先されます。(優先されない唯一の場合は、<code class="literal">MyISAM</code> コード内にバグが見つかったのではないかと疑われるときです。) 
      </p><p>
        <code class="literal">EXTENDED</code> は、通常のチェックを実行したが、MySQL が行を更新するか、またはキーで行を検索しようとすると引き続きテーブルで奇妙なエラーが発生する場合にのみ使用されます。通常のチェックが成功した場合、これはめったに発生しません。
      </p><p>
        <code class="literal">CHECK TABLE ... EXTENDED</code> を使用すると、クエリーオプティマイザによって生成される実行計画に影響を与える可能性があります。
      </p><p>
        <code class="literal">CHECK TABLE</code> によってレポートされる次のいくつかの問題は、自動的には修正できません。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Found row where the auto_increment column has the value 0</code>。
          </p><p>
            これは、<code class="literal">AUTO_INCREMENT</code> インデックスカラムに値 0 が含まれている行がテーブル内に存在することを示します。(<code class="literal">AUTO_INCREMENT</code> カラムが 0 である行は、<code class="literal">UPDATE</code> ステートメントを使用してそのカラムを明示的に 0 に設定することによって作成できます。) 
          </p><p>
            これは、それ自体エラーではありませんが、そのテーブルをダンプしてリストアするか、またはそのテーブルに対して <code class="literal">ALTER TABLE</code> を実行しようとした場合に問題が発生する可能性があります。この場合、<code class="literal">AUTO_INCREMENT</code> カラムはその <code class="literal">AUTO_INCREMENT</code> カラムのルールに従って値を変更するため、重複キーエラーなどの問題が発生する可能性があります。
          </p><p>
            この警告を解消するには、単純に、そのカラムを 0 以外の何からの値に設定するために <code class="literal">UPDATE</code> ステートメントを実行します。
          </p></li></ul></div><h5><a name="idm139979078884288"></a>InnoDB テーブル</h5><p>
        次の注意事項は、<code class="literal">InnoDB</code> テーブルに適用されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CHECK TABLE</code> で <code class="literal">InnoDB</code> テーブルの問題が見つかった場合、サーバーはエラーの伝播を回避するためにシャットダウンする可能性があります。このエラーの詳細はエラーログに書き込まれます。
          </p></li><li class="listitem"><p>
            <code class="literal">CHECK TABLE</code> は、<code class="literal">InnoDB</code> テーブルまたはインデックスに破損またはエラーを検出すると、エラーをレポートします。サーバーをシャットダウンすることはしません。MySQL 5.5 からは、そのインデックスまたはテーブルのそれ以上の使用を防ぐために、<code class="literal">CHECK TABLE</code> は通常、そのインデックスを破損しているとしてマークし、またそのテーブルも同様にマークする場合があります。
          </p></li><li class="listitem"><p>
            <code class="literal">CHECK TABLE</code> は、セカンダリインデックス内のエントリ数の間違いを見つけた場合、エラーをレポートしますが、サーバーをシャットダウンしたり、ファイルへのアクセスを防いだりはしません。
          </p></li><li class="listitem"><p>
            <code class="literal">CHECK TABLE</code> はインデックスページの構造を調査してから、各キーエントリを調査します。キーポインタをクラスタ化されたレコードに対して検証したり、<code class="literal">BLOB</code> ポインタのパスに従ったりはしません。
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> テーブルが <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> モードで独自の <a class="link" href="glossary.html#glos_ibd_file" title=".ibd ファイル">.ibd ファイル </a> に格納されると、<code class="literal">.ibd</code> の最初の 3 つの<a class="link" href="glossary.html#glos_page" title="ページ">ページ</a>には、テーブルまたはインデックスデータではなくヘッダー情報が含まれます。<code class="literal">CHECK TABLE</code> ステートメントは、ヘッダーデータにのみ影響を与える不整合を検出しません。<code class="literal">InnoDB</code> <code class="literal">.ibd</code> ファイルの内容全体を検証するには、<span class="command"><strong>innochecksum</strong></span> コマンドを使用します。
          </p></li><li class="listitem"><p>
            大きな <code class="literal">InnoDB</code> テーブルに対して <code class="literal">CHECK TABLE</code> を実行すると、<code class="literal">CHECK TABLE</code> の実行中にほかのスレッドがブロックされる可能性があります。タイムアウトを回避するために、<code class="literal">CHECK TABLE</code> 操作の場合は、セマフォー待機のしきい値 (600 秒) が 2 時間 (7200 秒) 延長されます。<code class="literal">InnoDB</code> は、240 秒以上のセマフォー待機を検出すると、<code class="literal">InnoDB</code> モニターの出力をエラーログに出力し始めます。ロック要求がセマフォー待機のしきい値を超えて延長された場合、<code class="literal">InnoDB</code> はそのプロセスを中止します。セマフォー待機が完全にタイムアウトする可能性を回避するには、<code class="literal">CHECK TABLE</code> の代わりに <code class="literal">CHECK TABLE QUICK</code> を実行できます。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="checksum-table"></a>13.7.2.3 CHECKSUM TABLE 構文</h4></div></div></div><a class="indexterm" name="idm139979078850896"></a><pre class="programlisting">
CHECKSUM TABLE <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ... [ QUICK | EXTENDED ]
</pre><p>
        <code class="literal">CHECKSUM TABLE</code> は、テーブルの内容に対する<a class="link" href="glossary.html#glos_checksum" title="チェックサム">チェックサム</a>をレポートします。チェックサム操作中、そのテーブルは <code class="literal">InnoDB</code> および <code class="literal">MyISAM</code> に対する読み取りロックでロックされます。このステートメントを使用すると、その内容が、バックアップ、ロールバック、またはデータを元の既知の状態に戻すことを目的としたその他の操作の前後で同じであることを検証できます。このステートメントには、このテーブルに対する <code class="literal">SELECT</code> 権限が必要です。
      </p><h5><a name="idm139979078839728"></a>パフォーマンスに関する考慮事項</h5><p>
        デフォルトでは、テーブル全体が 1 行ごとに読み取られ、チェックサムが計算されます。大きなテーブルでは長い時間がかかる可能性があるため、この操作は、状況に応じてのみ実行されます。この 1 行ごとの計算は、<code class="literal">InnoDB</code> や <code class="literal">MyISAM</code> 以外のその他のすべてのストレージエンジン、および <code class="literal">CHECKSUM=1</code> 句で作成されていない <code class="literal">MyISAM</code> テーブルの場合に <code class="literal">EXTENDED</code> 句で得られるものと同じです。
      </p><p>
        <code class="literal">CHECKSUM=1</code> 句で作成された <code class="literal">MyISAM</code> テーブルの場合、<code class="literal">CHECKSUM TABLE</code> または <code class="literal">CHECKSUM TABLE ... QUICK</code> は、非常に速く返すことができる<span class="quote">「<span class="quote">ライブ</span>」</span>テーブルチェックサムを返します。テーブルがこれらのすべての条件を満たさない場合、<code class="literal">QUICK</code> による方法は <code class="literal">NULL</code> を返します。<code class="literal">CHECKSUM</code> 句の構文については、<a class="xref" href="sql-syntax.html#create-table" title="13.1.17 CREATE TABLE 構文">セクション13.1.17「CREATE TABLE 構文」</a>を参照してください。
      </p><p>
        存在しないテーブルに対しては、<code class="literal">CHECKSUM TABLE</code> は <code class="literal">NULL</code> を返し、警告を生成します。
      </p><p>
        MySQL 5.6.4 より前は、<code class="literal">EXTENDED</code> オプションが使用されていないかぎり、<code class="literal">CHECKSUM TABLE</code> はパーティション化されたテーブルに対して 0 を返しました。(Bug #11933226、Bug #60681)
      </p><p>
        チェックサム値は、テーブル行フォーマットによって異なります。行フォーマットが変更された場合は、チェックサムも変更されます。たとえば、<code class="literal">VARCHAR</code> のストレージフォーマットは MySQL 4.1 と 5.0 の間で変更されたため、4.1 テーブルが MySQL 5.0 にアップグレードされた場合、チェックサム値は変更される可能性があります。
      </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          2 つのテーブルのチェックサムが異なる場合は、それらのテーブルが何らかの点で異なることがほぼ確実です。ただし、<code class="literal">CHECKSUM TABLE</code> によって使用されるハッシュ関数は衝突がないことは保証されないため、同一でない 2 つのテーブルが同じチェックサムを生成する可能性が若干あります。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="optimize-table"></a>13.7.2.4 OPTIMIZE TABLE 構文</h4></div></div></div><a class="indexterm" name="idm139979078815856"></a><a class="indexterm" name="idm139979078814544"></a><a class="indexterm" name="idm139979078812400"></a><pre class="programlisting">
OPTIMIZE [NO_WRITE_TO_BINLOG | LOCAL] TABLE
    <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ...
</pre><p>
        ストレージ領域を削減し、テーブルアクセス時の I/O 効率を向上させるために、テーブルデータとそれに関連付けられたインデックスデータの物理ストレージを再編成します。各テーブルに加えられる正確な変更は、そのテーブルによって使用されている<a class="link" href="glossary.html#glos_storage_engine" title="ストレージエンジン">ストレージエンジン</a>によって異なります。
      </p><p>
        <code class="literal">OPTIMIZE TABLE</code> は、テーブルのタイプに応じて次の場合に使用します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">innodb_file_per_table</code> オプションが有効な状態で作成されたために独自の <a class="link" href="glossary.html#glos_ibd_file" title=".ibd ファイル">.ibd ファイル </a> を含む <code class="literal">InnoDB</code> テーブルに対して大量の挿入、更新、または削除操作を行なったあと。テーブルとインデックスが再編成されるため、ディスク領域をオペレーティングシステムによる使用のために再利用できます。
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> テーブル内の <code class="literal">FULLTEXT</code> インデックスの一部であるカラムに対して大量の挿入、更新、または削除操作を行なったあと。最初に、構成オプション <code class="literal">innodb_optimize_fulltext_only=1</code> を設定します。インデックスの保守期間を妥当な時間に維持するために、検索インデックスで更新するワード数を指定する <code class="literal">innodb_ft_num_word_optimize</code> オプションを設定し、検索インデックスが完全に更新されるまで <code class="literal">OPTIMIZE TABLE</code> ステートメントのシーケンスを実行します。
          </p></li><li class="listitem"><p>
            <code class="literal">MyISAM</code> または <code class="literal">ARCHIVE</code> テーブルの大きな部分を削除するか、あるいは可変長行を含む <code class="literal">MyISAM</code> または <code class="literal">ARCHIVE</code> テーブル (<code class="literal">VARCHAR</code>、<code class="literal">VARBINARY</code>、<code class="literal">BLOB</code>、または <code class="literal">TEXT</code> カラムを含むテーブル) に多くの変更を行なったあと。削除された行はリンクリスト内に保持され、以降の <code class="literal">INSERT</code> 操作は古い行の位置を再利用します。<code class="literal">OPTIMIZE TABLE</code> を使用すると、未使用領域を再利用したり、データファイルをデフラグしたりできます。テーブルを大幅に変更したあとは、このステートメントにより、そのテーブルを使用するステートメントのパフォーマンスを (場合によっては大幅に) 向上させることができます。
          </p></li></ul></div><p>
        このステートメントには、このテーブルに対する <code class="literal">SELECT</code> および <code class="literal">INSERT</code> 権限が必要です。
      </p><p>
        <code class="literal">OPTIMIZE TABLE</code> は、パーティション化されたテーブルでもサポートされます。このステートメントのパーティション化されたテーブルでの使用やテーブルパーティションについては、<a class="xref" href="partitioning.html#partitioning-maintenance" title="19.3.4 パーティションの保守">セクション19.3.4「パーティションの保守」</a>を参照してください。
      </p><p>
        MySQL 5.6.11 でのみ、このステートメントを発行する前に、<code class="literal">gtid_next</code> を <code class="literal">AUTOMATIC</code> に設定する必要があります。(Bug #16062608、Bug #16715809、Bug #69045)
      </p><p>
        <code class="literal">OPTIMIZE TABLE</code> は、<code class="literal">InnoDB</code>、<code class="literal">MyISAM</code>、および <code class="literal">ARCHIVE</code> テーブルに対して機能します。<code class="literal">OPTIMIZE TABLE</code> は、インメモリー <code class="literal">NDB</code> テーブルの動的なカラムに対してもサポートされます。ディスクデータテーブルに対しては機能しません。クラスタテーブルに対する <code class="literal">OPTIMIZE</code> のパフォーマンスは、<code class="literal">OPTIMIZE TABLE</code> による行のバッチの処理間で待機するミリ秒数を制御する <code class="literal">ndb_optimization_delay</code> システム変数の値を調整することによってチューニングできます。詳細は、<a class="xref" href="mysql-cluster.html#mysql-cluster-limitations-resolved" title="18.1.6.11 MySQL Cluster NDB 7.3 で解決された以前の MySQL Cluster の問題">セクション18.1.6.11「MySQL Cluster NDB 7.3 で解決された以前の MySQL Cluster の問題」</a>を参照してください。
      </p><p>
        MySQL Cluster テーブルの場合、<code class="literal">OPTIMIZE TABLE</code> は、<code class="literal">OPTIMIZE</code> 操作を実行している SQL スレッドを (たとえば) 強制終了することによって中断できます。
      </p><p>
        デフォルトでは、<code class="literal">OPTIMIZE TABLE</code> はその他のストレージエンジンを使用して作成されたテーブルに対しては機能<span class="emphasis"><em>せず</em></span>、このサポートがないことを示す結果を返します。<code class="option">--skip-new</code> オプションを使用して <span class="command"><strong>mysqld</strong></span> を起動することによって、その他のストレージエンジンに対して <code class="literal">OPTIMIZE TABLE</code> を機能させることができます。この場合、<code class="literal">OPTIMIZE TABLE</code> は単に <code class="literal">ALTER TABLE</code> にマップされます。
      </p><h5><a name="idm139979078754048"></a>InnoDB の詳細</h5><p>
        <code class="literal">InnoDB</code> テーブルの場合、<code class="literal">OPTIMIZE TABLE</code> は <code class="literal">ALTER TABLE ... FORCE</code> にマップされます。これは、インデックス統計を更新し、クラスタ化されたインデックス内の未使用領域を解放するためにテーブルを再構築します。これは、次に示すように、<code class="literal">InnoDB</code> テーブルに対して実行したときに <code class="literal">OPTIMIZE TABLE</code> の出力に表示されます。
      </p><pre class="programlisting">
mysql&gt; OPTIMIZE TABLE foo;
+----------+----------+----------+-------------------------------------------------------------------+
| Table    | Op       | Msg_type | Msg_text                                                          |
+----------+----------+----------+-------------------------------------------------------------------+
| test.foo | optimize | note     | Table does not support optimize, doing recreate + analyze instead |
| test.foo | optimize | status   | OK                                                                |
+----------+----------+----------+-------------------------------------------------------------------+
</pre><p>
        Mysql 5.6.17 より前は、<code class="literal">OPTIMIZE TABLE</code> は<a class="link" href="innodb-storage-engine.html#innodb-online-ddl" title="14.11 InnoDB とオンライン DDL">オンライン DDL</a> (<code class="literal">ALGORITHM=INPLACE</code>) を使用しません。その結果、<code class="literal">OPTIMIZE TABLE</code> が実行中のテーブルに対しては (つまり、そのテーブルのロック中は) 並列 DML (<code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、<code class="literal">DELETE</code>) が許可されません。また、主キーに現れる順序でキーが挿入されるため、セカンダリインデックスはそれほど効率的に作成されません。
      </p><p>
        5.6.17 の時点では、<code class="literal">OPTIMIZE TABLE</code> は、<code class="literal">InnoDB</code> の通常のテーブルとパーティション化されたテーブルの両方に対して<a class="link" href="innodb-storage-engine.html#innodb-online-ddl" title="14.11 InnoDB とオンライン DDL">オンライン DDL</a> (<code class="literal">ALGORITHM=INPLACE</code>) を使用します。<code class="literal">OPTIMIZE TABLE</code> によってトリガーされ、<code class="literal">ALTER TABLE ... FORCE</code> の下で実行されるテーブル再構築は現在、<a class="link" href="innodb-storage-engine.html#innodb-online-ddl" title="14.11 InnoDB とオンライン DDL">オンライン DDL</a> (<code class="literal">ALGORITHM=INPLACE</code>) を使用して実行され、短期間しかテーブルをロックしないため、並列 DML 操作のためのダウンタイムが短縮されます。
      </p><p>
        <code class="literal">OPTIMIZE TABLE</code> は引き続き、次の条件の下で <code class="literal">ALGORITHM=COPY</code> を使用します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">old_alter_table</code> システム変数が ON になっている場合。
          </p></li><li class="listitem"><p>
            <span class="command"><strong>mysqld</strong></span> <code class="literal">--skip-new</code> オプションが有効になっている場合。
          </p></li></ul></div><p>
        <a class="link" href="innodb-storage-engine.html#innodb-online-ddl" title="14.11 InnoDB とオンライン DDL">オンライン DDL</a> (<code class="literal">ALGORITHM=INPLACE</code>) を使用した <code class="literal">OPTIMIZE TABLE</code> は、<code class="literal">FULLTEXT</code> インデックスを含む <code class="literal">InnoDB</code> テーブルではサポートされません。代わりに <code class="literal">ALGORITHM=COPY</code> を使用する必要があります。
      </p><p>
        <code class="literal">InnoDB</code> はページ割り当ての方法を使用してデータを格納するため、従来のストレージエンジン (<code class="literal">MyISAM</code> など) の場合のような断片化は発生しません。最適化を実行するかどうかを検討する場合は、サーバーが処理するトランザクションのワークロードを考慮してください。

        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              ある程度の断片化は予測されます。<code class="literal">InnoDB</code> は、ページを分割しなくても更新できる余地を残すために、<a class="link" href="glossary.html#glos_page" title="ページ">ページ</a>を 93% までしかいっぱいにしません。
            </p></li><li class="listitem"><p>
              削除操作によってギャップが残され、ページの空きが目的より多くなることがあります。これにより、テーブルを最適化する価値が生まれる可能性があります。
            </p></li><li class="listitem"><p>
              行を更新すると通常、十分な領域が使用可能であれば、データ型と行フォーマットに応じて同じページ内のデータが書き換えられます。<a class="xref" href="innodb-storage-engine.html#innodb-compression-internals" title="14.7.5 InnoDB テーブルでの圧縮の動作">セクション14.7.5「InnoDB テーブルでの圧縮の動作」</a>および<a class="xref" href="innodb-storage-engine.html#innodb-row-format-overview" title="14.9.1 InnoDB 行ストレージの概要">セクション14.9.1「InnoDB 行ストレージの概要」</a>を参照してください。
            </p></li><li class="listitem"><p>
              <code class="literal">InnoDB</code> はその <a class="link" href="glossary.html#glos_mvcc" title="MVCC">MVCC</a> メカニズムのために同じデータの複数のバージョンを保持するため、並列性の高いワークロードでは、時間の経過とともにインデックス内にギャップが残される可能性があります。<a class="xref" href="innodb-storage-engine.html#innodb-multi-versioning" title="14.2.12 InnoDB マルチバージョン">セクション14.2.12「InnoDB マルチバージョン」</a>を参照してください。
            </p></li></ul></div><p>
      </p><h5><a name="idm139979078704224"></a>MyISAM の詳細</h5><p>
        <code class="literal">MyISAM</code> テーブルの場合、<code class="literal">OPTIMIZE TABLE</code> は次のように機能します。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            テーブルが行を削除または分割した場合は、そのテーブルを修復します。
          </p></li><li class="listitem"><p>
            インデックスページがソートされていない場合は、それをソートします。
          </p></li><li class="listitem"><p>
            テーブルの統計が最新でない (そのため、インデックスのソートによって修復を実行できない) 場合は、それを更新します。
          </p></li></ol></div><h5><a name="idm139979078697200"></a>その他の考慮事項</h5><p>
        <code class="literal">OPTIMIZE TABLE</code> は、次のカラムを含む結果セットを返します。
      </p><div class="informaltable"><table summary="この表は、OPTIMIZE TABLE の結果セットのカラムについて説明しています。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">カラム</th><th scope="col">値</th></tr></thead><tbody><tr><td scope="row"><code class="literal">Table</code></td><td>テーブル名</td></tr><tr><td scope="row"><code class="literal">Op</code></td><td>常に <code class="literal">optimize</code></td></tr><tr><td scope="row"><code class="literal">Msg_type</code></td><td><code class="literal">status</code>、<code class="literal">error</code>、<code class="literal">info</code>、<code class="literal">note</code>、または <code class="literal">warning</code></td></tr><tr><td scope="row"><code class="literal">Msg_text</code></td><td>情報メッセージ</td></tr></tbody></table></div><p>
        5.6.17 より前の <code class="literal">InnoDB</code> テーブルやその他のテーブルタイプの場合、MySQL は、<code class="literal">OPTIMIZE TABLE</code> の実行中は<a class="link" href="glossary.html#glos_table_lock" title="テーブルロック">そのテーブルをロックします</a>。MySQL 5.6.17 の時点では、<code class="literal">OPTIMIZE TABLE</code> は、<code class="literal">InnoDB</code> の通常のテーブルとパーティション化されたテーブルに対してオンラインで実行されます。
      </p><p>
        デフォルトでは、サーバーは <code class="literal">OPTIMIZE TABLE</code> ステートメントをバイナリログに書き込み、それらがレプリケーションスレーブにレプリケートされるようにします。ロギングを抑制するには、オプションの <code class="literal">NO_WRITE_TO_BINLOG</code> キーワード、またはそのエイリアス <code class="literal">LOCAL</code> を指定します。
      </p><p>
        <code class="literal">OPTIMIZE TABLE</code> は、<code class="literal">POINT</code> カラム上の空間インデックスなどの R ツリーインデックスをソートしません。(Bug #23578)
      </p><p>
        <code class="literal">OPTIMIZE TABLE</code> テーブルは、古いファイルから新しく作成されたファイルへのテーブル統計のコピー中に発生したすべてのエラーをキャッチしてスローします。たとえば、<code class="filename">.frm</code>、<code class="filename">.MYD</code>、または <code class="filename">.MYI</code> ファイルの所有者のユーザー ID が <span class="command"><strong>mysqld</strong></span> プロセスのユーザー ID と異なる場合は、<span class="command"><strong>mysqld</strong></span> が <code class="literal">root</code> ユーザーによって起動されていないかぎり、<code class="literal">OPTIMIZE TABLE</code> は "cannot change ownership of the file" エラーを生成します。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="repair-table"></a>13.7.2.5 REPAIR TABLE 構文</h4></div></div></div><a class="indexterm" name="idm139979078659248"></a><pre class="programlisting">
REPAIR [NO_WRITE_TO_BINLOG | LOCAL] TABLE
    <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ...
    [QUICK] [EXTENDED] [USE_FRM]
</pre><p>
        <code class="literal">REPAIR TABLE</code> は、特定のストレージエンジンに対してのみ、破損している可能性のあるテーブルを修復します。デフォルトでは、これには <span class="command"><strong>myisamchk --recover <em class="replaceable"><code>tbl_name</code></em></strong></span> と同じ効果があります。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">REPAIR TABLE</code> は <code class="literal">MyISAM</code>、<code class="literal">ARCHIVE</code>、および <code class="literal">CSV</code> の各テーブルのみに適用されます。<a class="xref" href="storage-engines.html#myisam-storage-engine" title="15.2 MyISAM ストレージエンジン">セクション15.2「MyISAM ストレージエンジン」</a>、<a class="xref" href="storage-engines.html#archive-storage-engine" title="15.5 ARCHIVE ストレージエンジン">セクション15.5「ARCHIVE ストレージエンジン」</a>、および<a class="xref" href="storage-engines.html#csv-storage-engine" title="15.4 CSV ストレージエンジン">セクション15.4「CSV ストレージエンジン」</a>を参照してください。
        </p></div><p>
        このステートメントには、このテーブルに対する <code class="literal">SELECT</code> および <code class="literal">INSERT</code> 権限が必要です。
      </p><p>
        <code class="literal">REPAIR TABLE</code> は、パーティション化されたテーブルに対してサポートされています。ただし、パーティション化されたテーブルに対して、このステートメントで <code class="literal">USE_FRM</code> オプションを使用することはできません。
      </p><p>
        MySQL 5.6.11 でのみ、このステートメントを発行する前に、<code class="literal">gtid_next</code> を <code class="literal">AUTOMATIC</code> に設定する必要があります。(Bug #16062608、Bug #16715809、Bug #69045)
      </p><p>
        <code class="literal">ALTER TABLE ... REPAIR PARTITION</code> を使用すると、1 つ以上のパーティションを修復できます。詳細は、<a class="xref" href="sql-syntax.html#alter-table" title="13.1.7 ALTER TABLE 構文">セクション13.1.7「ALTER TABLE 構文」</a>および<a class="xref" href="partitioning.html#partitioning-maintenance" title="19.3.4 パーティションの保守">セクション19.3.4「パーティションの保守」</a>を参照してください。
      </p><p>
        通常、<code class="literal">REPAIR TABLE</code> を実行する必要はありませんが、災害が発生した場合は、このステートメントを使用すると <code class="literal">MyISAM</code> テーブルからすべてのデータをリストアできる可能性があります。テーブルが頻繁に破損する場合は、その原因を見つけることにより、<code class="literal">REPAIR TABLE</code> を使用する必要がなくなるようにしてください。<a class="xref" href="error-handling.html#crashing" title="B.5.4.2 MySQL が繰り返しクラッシュする場合の対処方法">セクションB.5.4.2「MySQL が繰り返しクラッシュする場合の対処方法」</a>および<a class="xref" href="storage-engines.html#myisam-table-problems" title="15.2.4 MyISAM テーブルの問題点">セクション15.2.4「MyISAM テーブルの問題点」</a>を参照してください。
      </p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注意</div><p>
          テーブルの修復操作を実行する前に、そのテーブルのバックアップを作成してください。状況によっては、この操作のためにデータ損失が発生することがあります。考えられる原因としては、ファイルシステムのエラーなどがありますがこれに限りません。<a class="xref" href="backup-and-recovery.html" title="第 7 章 バックアップとリカバリ">第7章「<i>バックアップとリカバリ</i>」</a>を参照してください。
        </p></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
          <code class="literal">REPAIR TABLE</code> 操作中にサーバーがクラッシュした場合は、サーバーを再起動したあと、そのテーブルに対してほかの操作を実行する前に、再度 <code class="literal">REPAIR TABLE</code> ステートメントをただちに実行することが重要です。最悪の場合は、データファイルに関する情報のない新しいクリーンなインデックスファイルが生成されており、実行する次の操作によってデータファイルが上書きされる可能性があります。この状況はめったに発生しませんが、最初にバックアップを作成することの価値を強調している、可能性のあるシナリオです。
        </p></div><p>
        <code class="literal">REPAIR TABLE</code> は、次のカラムを含む結果セットを返します。
      </p><div class="informaltable"><table summary="この表は、REPAIR TABLE の結果セットのカラムについて説明しています。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">カラム</th><th scope="col">値</th></tr></thead><tbody><tr><td scope="row"><code class="literal">Table</code></td><td>テーブル名</td></tr><tr><td scope="row"><code class="literal">Op</code></td><td>常に <code class="literal">repair</code></td></tr><tr><td scope="row"><code class="literal">Msg_type</code></td><td><code class="literal">status</code>、<code class="literal">error</code>、<code class="literal">info</code>、<code class="literal">note</code>、または <code class="literal">warning</code></td></tr><tr><td scope="row"><code class="literal">Msg_text</code></td><td>情報メッセージ</td></tr></tbody></table></div><p>
        <code class="literal">REPAIR TABLE</code> ステートメントによって、修復されたテーブルごとに多数の情報行が生成される可能性があります。最後の行には <code class="literal">status</code> の <code class="literal">Msg_type</code> 値が含まれ、<code class="literal">Msg_test</code> は通常 <code class="literal">OK</code> になります。<code class="literal">MyISAM</code> テーブルに対して <code class="literal">OK</code> が表示されない場合は、<span class="command"><strong>myisamchk --safe-recover</strong></span> を使用して修復してみてください。(<code class="literal">REPAIR TABLE</code> によって、<span class="command"><strong>myisamchk</strong></span> のすべてのオプションが実装されるわけではありません。) <span class="command"><strong>myisamchk --safe-recover</strong></span> では、<code class="literal">REPAIR TABLE</code> がサポートしていないオプション (<code class="option">--max-record-length</code> など) も使用できます。
      </p><p>
        <code class="literal">QUICK</code> オプションを使用した場合、<code class="literal">REPAIR TABLE</code> はデータファイルではなく、インデックスファイルのみを修復しようとします。このタイプの修復は、<span class="command"><strong>myisamchk --recover --quick</strong></span> によって実行される修復と同様です。
      </p><p>
        <code class="literal">EXTENDED</code> オプションを使用した場合、MySQL はソートしながら 1 回につき 1 つのインデックスを作成する代わりに、1 行ごとにインデックスを作成します。このタイプの修復は、<span class="command"><strong>myisamchk --safe-recover</strong></span> によって実行される修復と同様です。
      </p><p>
        <code class="literal">USE_FRM</code> オプションは、<code class="filename">.MYI</code> インデックスファイルがない場合や、そのヘッダーが破損している場合に使用できます。このオプションは MySQL に、<code class="filename">.MYI</code> ファイルヘッダー内の情報を信頼せずに、<code class="filename">.frm</code> ファイルからの情報を使用してファイルヘッダーを再作成するよう指示します。この種類の修復は、<span class="command"><strong>myisamchk</strong></span> では実行できません。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          通常の <code class="literal">REPAIR</code> モードを使用できない場合は、<code class="literal">USE_FRM</code> オプション<span class="emphasis"><em>のみ</em></span>を使用します。サーバーに <code class="filename">.MYI</code> ファイルを無視するよう指示すると、<code class="filename">.MYI</code> に格納されている重要なテーブルメタデータが修復プロセスから使用できなくなるため、有害な結果を招く場合があります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              現在の <code class="literal">AUTO_INCREMENT</code> 値は失われます。
            </p></li><li class="listitem"><p>
              テーブル内の削除されたレコードへのリンクは失われます。つまり、削除されたレコードの空き領域は、それ以降も占有されずに残ります。
            </p></li><li class="listitem"><p>
              <code class="filename">.MYI</code> ヘッダーは、テーブルが圧縮されているかどうかを示します。サーバーがこの情報を無視すると、テーブルが圧縮されていることがわからないため、修復によってテーブルの内容の変更または損失が発生する場合があります。つまり、圧縮テーブルでは <code class="literal">USE_FRM</code> を使用しないようにしてください。いずれにしても、これは必須ではありません。圧縮テーブルは読み取り専用であるため、破損することはありません。
            </p></li></ul></div></div><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注意</div><p>
          現在実行しているものとは異なるバージョンの MySQL サーバーによって作成されたテーブルに対して <code class="literal">USE_FRM</code> を使用した場合、<code class="literal">REPAIR TABLE</code> はそのテーブルを修復しようとしません。この場合、<code class="literal">REPAIR TABLE</code> によって返される結果セットには、<code class="literal">Msg_type</code> 値が <code class="literal">error</code> で、<code class="literal">Msg_text</code> 値が <code class="literal">Failed repairing incompatible .FRM file</code> である行が含まれています。
        </p></div><p>
        <code class="literal">USE_FRM</code> が使用されて<span class="emphasis"><em>いない</em></span>場合、<code class="literal">REPAIR TABLE</code> はテーブルをチェックして、アップグレードが必要かどうかを確認します。アップグレードが必要な場合は、<code class="literal">CHECK TABLE ... FOR UPGRADE</code> と同じルールに従ってアップグレードを実行します。詳細は、<a class="xref" href="sql-syntax.html#check-table" title="13.7.2.2 CHECK TABLE 構文">セクション13.7.2.2「CHECK TABLE 構文」</a>を参照してください。<code class="literal">USE_FRM</code> のない <code class="literal">REPAIR TABLE</code> は、<code class="filename">.frm</code> ファイルを現在のバージョンにアップグレードします。
      </p><a class="indexterm" name="idm139979078558096"></a><a class="indexterm" name="idm139979078555856"></a><p>
        デフォルトでは、サーバーは <code class="literal">REPAIR TABLE</code> ステートメントをバイナリログに書き込み、それらがレプリケーションスレーブにレプリケートされるようにします。ロギングを抑制するには、オプションの <code class="literal">NO_WRITE_TO_BINLOG</code> キーワード、またはそのエイリアス <code class="literal">LOCAL</code> を指定します。
      </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
          マスター上のテーブルが破損し、そのテーブルに対して <code class="literal">REPAIR TABLE</code> を実行した場合、その結果としての元のテーブルへの変更はスレーブに伝播され<span class="emphasis"><em>ません</em></span>。
        </p></div><p>
        特定のシステム変数を設定することによって、<code class="literal">REPAIR TABLE</code> のパフォーマンスを向上させることができる可能性があります。<a class="xref" href="optimization.html#repair-table-speed" title="8.6.3 REPAIR TABLE ステートメントの速度">セクション8.6.3「REPAIR TABLE ステートメントの速度」</a>を参照してください。
      </p><p>
        <code class="literal">REPAIR TABLE</code> テーブルは、古い破損したファイルから新しく作成されたファイルへのテーブル統計のコピー中に発生したすべてのエラーをキャッチしてスローします。たとえば、<code class="filename">.frm</code>、<code class="filename">.MYD</code>、または <code class="filename">.MYI</code> ファイルの所有者のユーザー ID が <span class="command"><strong>mysqld</strong></span> プロセスのユーザー ID と異なる場合は、<span class="command"><strong>mysqld</strong></span> が <code class="literal">root</code> ユーザーによって起動されていないかぎり、<code class="literal">REPAIR TABLE</code> は "cannot change ownership of the file" エラーを生成します。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="plugin-sql"></a>13.7.3 プラグインおよびユーザー定義関数ステートメント</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-syntax.html#create-function-udf">13.7.3.1 ユーザー定義関数のための CREATE FUNCTION 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-function-udf">13.7.3.2 DROP FUNCTION 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#install-plugin">13.7.3.3 INSTALL PLUGIN 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#uninstall-plugin">13.7.3.4 UNINSTALL PLUGIN 構文</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="create-function-udf"></a>13.7.3.1 ユーザー定義関数のための CREATE FUNCTION 構文</h4></div></div></div><a class="indexterm" name="idm139979078534352"></a><a class="indexterm" name="idm139979078533008"></a><a class="indexterm" name="idm139979078530864"></a><a class="indexterm" name="idm139979078528832"></a><a class="indexterm" name="idm139979078527616"></a><a class="indexterm" name="idm139979078526128"></a><pre class="programlisting">
CREATE [AGGREGATE] FUNCTION <em class="replaceable"><code>function_name</code></em> RETURNS {STRING|INTEGER|REAL|DECIMAL}
    SONAME <em class="replaceable"><code>shared_library_name</code></em>
</pre><p>
        ユーザー定義関数 (UDF) は、<code class="literal">ABS()</code> や <code class="literal">CONCAT()</code> などのネイティブな (組み込みの) MySQL 関数のように機能する新しい関数によって MySQL を拡張するための方法です。
      </p><p>
        <em class="replaceable"><code>function_name</code></em> は、この関数を呼び出すために SQL ステートメントで使用される名前です。<code class="literal">RETURNS</code> 句は、この関数の戻り値の型を示します。<code class="literal">DECIMAL</code> は <code class="literal">RETURNS</code> のあとの正当な値ですが、現在 <code class="literal">DECIMAL</code> 関数は文字列値を返すため、<code class="literal">STRING</code> 関数のように記述してください。
      </p><p>
        <em class="replaceable"><code>shared_library_name</code></em> は、この関数を実装するコードを含む共有オブジェクトファイルのベース名です。このファイルは、プラグインディレクトリに存在する必要があります。このディレクトリは、<code class="literal">plugin_dir</code> システム変数の値から取得できます。詳細は、<a class="xref" href="extending-mysql.html#udf-compiling" title="24.3.2.5 ユーザー定義関数のコンパイルおよびインストール">セクション24.3.2.5「ユーザー定義関数のコンパイルおよびインストール」</a>を参照してください。
      </p><p>
        関数を作成するには、<code class="literal">mysql</code> データベースに対する <code class="literal">INSERT</code> 権限が必要です。これが必要なのは、<code class="literal">CREATE FUNCTION</code> によって、関数の名前、型、および共有ライブラリ名を記録する <code class="literal">mysql.func</code> システムテーブルに行が追加されるためです。このテーブルが存在しない場合は、<span class="command"><strong>mysql_upgrade</strong></span> コマンドを実行して作成するようにしてください。<a class="xref" href="programs.html#mysql-upgrade" title="4.4.7 mysql_upgrade — MySQL テーブルのチェックとアップグレード">セクション4.4.7「<span class="command"><strong>mysql_upgrade</strong></span> — MySQL テーブルのチェックとアップグレード」</a>を参照してください。
      </p><p>
        アクティブ関数とは、<code class="literal">CREATE FUNCTION</code> を使用してロードされていて、<code class="literal">DROP FUNCTION</code> を使用して削除されていない関数です。すべてのアクティブ関数は、サーバーが起動するたびにリロードされますが、<code class="option">--skip-grant-tables</code> オプションを指定して <span class="command"><strong>mysqld</strong></span> を起動した場合は異なります。この場合は、UDF の初期化がスキップされ、UDF は使用できません。
      </p><p>
        ユーザー定義関数を記述するための手順については、<a class="xref" href="extending-mysql.html#adding-udf" title="24.3.2 新しいユーザー定義関数の追加">セクション24.3.2「新しいユーザー定義関数の追加」</a>を参照してください。UDF のメカニズムが機能するには、関数を C か C++ (または、C の呼び出し規則を使用できる別の言語) で記述する必要があり、オペレーティングシステムが動的ロードをサポートしている必要があり、さらに <span class="command"><strong>mysqld</strong></span> を (静的にではなく) 動的にコンパイルしている必要があります。
      </p><p>
        <code class="literal">AGGREGATE</code> 関数は、<code class="literal">SUM</code> や <code class="literal">COUNT()</code> などのネイティブな MySQL 集約 (サマリー) 関数とまったく同じように機能します。<code class="literal">AGGREGATE</code> が機能するには、<code class="literal">mysql.func</code> テーブルに <code class="literal">type</code> カラムが含まれている必要があります。<code class="literal">mysql.func</code> テーブルにこのカラムが含まれていない場合は、<span class="command"><strong>mysql_upgrade</strong></span> プログラムを実行して作成するようにしてください (<a class="xref" href="programs.html#mysql-upgrade" title="4.4.7 mysql_upgrade — MySQL テーブルのチェックとアップグレード">セクション4.4.7「<span class="command"><strong>mysql_upgrade</strong></span> — MySQL テーブルのチェックとアップグレード」</a>を参照してください)。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          UDF に関連付けられた共有ライブラリをアップグレードするには、<code class="literal">DROP FUNCTION</code> ステートメントを発行し、共有ライブラリをアップグレードしたあと、<code class="literal">CREATE FUNCTION</code> ステートメントを発行します。最初に共有ライブラリをアップグレードしてから <code class="literal">DROP FUNCTION</code> を使用すると、サーバーがクラッシュする可能性があります。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="drop-function-udf"></a>13.7.3.2 DROP FUNCTION 構文</h4></div></div></div><a class="indexterm" name="idm139979078480624"></a><a class="indexterm" name="idm139979078479312"></a><a class="indexterm" name="idm139979078477168"></a><a class="indexterm" name="idm139979078475136"></a><a class="indexterm" name="idm139979078473968"></a><a class="indexterm" name="idm139979078472480"></a><pre class="programlisting">
DROP FUNCTION <em class="replaceable"><code>function_name</code></em>
</pre><p>
        このステートメントは、<em class="replaceable"><code>function_name</code></em> という名前のユーザー定義関数 (UDF) を削除します。
      </p><p>
        関数を削除するには、<code class="literal">mysql</code> データベースに対する <code class="literal">DELETE</code> 権限が必要です。これは、<code class="literal">DROP FUNCTION</code> によって、関数の名前、型、および共有ライブラリ名を記録する <code class="literal">mysql.func</code> システムテーブルから行が削除されるためです。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          UDF に関連付けられた共有ライブラリをアップグレードするには、<code class="literal">DROP FUNCTION</code> ステートメントを発行し、共有ライブラリをアップグレードしたあと、<code class="literal">CREATE FUNCTION</code> ステートメントを発行します。最初に共有ライブラリをアップグレードしてから <code class="literal">DROP FUNCTION</code> を使用すると、サーバーがクラッシュする可能性があります。
        </p></div><p>
        <code class="literal">DROP FUNCTION</code> はまた、ストアドファンクションを削除するためにも使用されます (<a class="xref" href="sql-syntax.html#drop-procedure" title="13.1.26 DROP PROCEDURE および DROP FUNCTION 構文">セクション13.1.26「DROP PROCEDURE および DROP FUNCTION 構文」</a>を参照してください)。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="install-plugin"></a>13.7.3.3 INSTALL PLUGIN 構文</h4></div></div></div><a class="indexterm" name="idm139979078451600"></a><a class="indexterm" name="idm139979078450256"></a><a class="indexterm" name="idm139979078448768"></a><pre class="programlisting">
INSTALL PLUGIN <em class="replaceable"><code>plugin_name</code></em> SONAME '<em class="replaceable"><code>shared_library_name</code></em>'
</pre><p>
        このステートメントは、サーバープラグインをインストールします。これには、<code class="literal">mysql.plugin</code> テーブルに対する <code class="literal">INSERT</code> 権限が必要です。
      </p><p>
        <em class="replaceable"><code>plugin_name</code></em> は、ライブラリファイルに含まれているプラグインディスクリプタ構造で定義されているプラグインの名前です (<a class="xref" href="extending-mysql.html#plugin-data-structures" title="24.2.4.2 プラグインのデータ構造体">セクション24.2.4.2「プラグインのデータ構造体」</a>を参照してください)。プラグイン名は大文字と小文字が区別されません。プラグイン名は C ソースファイル、シェルコマンド行、M4 および Bourne シェルスクリプト、SQL 環境などで使用されるため、最大化の互換性のために、プラグイン名は ASCII 文字、数字、およびアンダースコアに制限するようにしてください。
      </p><p>
        <em class="replaceable"><code>shared_library_name</code></em> は、プラグインコードを含む共有ライブラリの名前です。この名前には、ファイル名拡張子が含まれています (<code class="filename">libmyplugin.so</code>、<code class="filename">libmyplugin.dll</code>、<code class="filename">libmyplugin.dylib</code> など)。
      </p><p>
        共有ライブラリは、プラグインディレクトリ (<code class="literal">plugin_dir</code> システム変数で指定されているディレクトリ) 内に存在する必要があります。このライブラリは、サブディレクトリ内ではなく、プラグインディレクトリ自体に存在する必要があります。デフォルトでは、<code class="literal">plugin_dir</code> は <code class="literal">pkglibdir</code> 構成変数で指定されているディレクトリの下にある <code class="filename">plugin</code> ディレクトリですが、サーバーの起動時に <code class="literal">plugin_dir</code> の値を設定することによって変更できます。たとえば、<code class="filename">my.cnf</code> ファイル内でその値を設定します。
      </p><pre class="programlisting">
[mysqld]
plugin_dir=<em class="replaceable"><code>/path/to/plugin/directory</code></em>
</pre><p>
        <code class="literal">plugin_dir</code> の値が相対パス名である場合は、MySQL ベースディレクトリ (<code class="literal">basedir</code> システム変数の値) を基準にしていると見なされます。
      </p><p>
        <code class="literal">INSTALL PLUGIN</code> は、プラグインを使用可能にするために、そのプラグインコードをロードして初期化します。プラグインは、使用可能になる前にそのプラグインが実行する必要のあるすべての設定を処理するその初期化関数を実行することによって初期化されます。サーバーは、シャットダウン時に、ロードされている各プラグインの初期化解除関数を実行することにより、そのプラグインに最終クリーンアップを実行するための変更が発生するようにします。
      </p><p>
        <code class="literal">INSTALL PLUGIN</code> はまた、そのプラグイン名とライブラリファイル名を示す行を <code class="literal">mysql.plugin</code> テーブルに追加することによって、そのプラグインの登録も行います。サーバーの起動時に、サーバーは、<code class="literal">mysql.plugin</code> テーブルにリストされているすべてのプラグインをロードして初期化します。つまり、プラグインはサーバーが起動するたびにではなく、1 回だけ <code class="literal">INSTALL PLUGIN</code> によってインストールされます。起動時のプラグインのロードは、サーバーが <code class="option">--skip-grant-tables</code> オプションで起動された場合は実行されません。
      </p><p>
        プラグインライブラリには、複数のプラグインを含めることができます。各プラグインをインストールするには、個別の <code class="literal">INSTALL PLUGIN</code> ステートメントを使用します。各ステートメントは異なるプラグインを指定しますが、そのすべてが同じライブラリ名を指定します。
      </p><p>
        <code class="literal">INSTALL PLUGIN</code> を指定すると、サーバーは、サーバーの起動中と同様にオプション (<code class="filename">my.cnf</code>) ファイルを読み取ります。これにより、プラグインは、これらのファイルからすべての関連オプションを取得できるようになります。プラグインをロードする前でも、オプションファイルにプラグインオプションを追加できます (<code class="literal">loose</code> プリフィクスが使用されている場合)。また、プラグインをアンインストールしたり、<code class="filename">my.cnf</code> を編集したり、プラグインを再度インストールしたりすることもできます。プラグインをこの方法で再起動すると、サーバーを再起動することなく新しいオプション値を指定できます。
      </p><p>
        サーバーの起動時に個々のプラグインロードを制御するオプションについては、<a class="xref" href="server-administration.html#server-plugin-loading" title="5.1.8.1 プラグインのインストールおよびアンインストール">セクション5.1.8.1「プラグインのインストールおよびアンインストール」</a>を参照してください。サーバーにシステムテーブルを読み取らないよう指示する <code class="option">--skip-grant-tables</code> オプションが指定されたとき、1 回のサーバー起動時にプラグインをロードする必要がある場合は、<code class="option">--plugin-load</code> オプションを使用します。<a class="xref" href="server-administration.html#server-options" title="5.1.3 サーバーコマンドオプション">セクション5.1.3「サーバーコマンドオプション」</a>を参照してください。
      </p><p>
        プラグインを削除するには、<code class="literal">UNINSTALL PLUGIN</code> ステートメントを使用します。
      </p><p>
        プラグインのロードについての追加情報は、<a class="xref" href="server-administration.html#server-plugin-loading" title="5.1.8.1 プラグインのインストールおよびアンインストール">セクション5.1.8.1「プラグインのインストールおよびアンインストール」</a>を参照してください。
      </p><p>
        インストールされているプラグインを確認するには、<code class="literal">SHOW PLUGINS</code> ステートメントを使用するか、または <code class="literal">INFORMATION_SCHEMA.PLUGINS</code> テーブルにクエリーします。
      </p><p>
        プラグインライブラリを再コンパイルするとき、それを再インストールする必要がある場合は、次の方法のいずれかを使用できます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">UNINSTALL PLUGIN</code> を使用してライブラリ内のすべてのプラグインをアンインストールし、新しいプラグインライブラリファイルをプラグインディレクトリにインストールしてから、<code class="literal">INSTALL PLUGIN</code> を使用してすべてのプラグインをライブラリにインストールします。この手順には、サーバーを停止することなく使用できるという利点があります。ただし、プラグインライブラリに多数のプラグインが含まれている場合は、多数の <code class="literal">INSTALL PLUGIN</code> および <code class="literal">UNINSTALL PLUGIN</code> ステートメントを発行する必要があります。
          </p></li><li class="listitem"><p>
            サーバーを停止し、新しいプラグインライブラリファイルをプラグインディレクトリにインストールしてから、サーバーを再起動します。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="uninstall-plugin"></a>13.7.3.4 UNINSTALL PLUGIN 構文</h4></div></div></div><a class="indexterm" name="idm139979078388448"></a><a class="indexterm" name="idm139979078387136"></a><a class="indexterm" name="idm139979078385616"></a><pre class="programlisting">
UNINSTALL PLUGIN <em class="replaceable"><code>plugin_name</code></em>
</pre><p>
        このステートメントは、インストールされているサーバープラグインを削除します。これには、<code class="literal">mysql.plugin</code> テーブルに対する <code class="literal">DELETE</code> 権限が必要です。
      </p><p>
        <em class="replaceable"><code>plugin_name</code></em> は、<code class="literal">mysql.plugin</code> テーブルにリストされている何らかのプラグインの名前である必要があります。サーバーはプラグインの初期化解除関数を実行し、以降のサーバーの再起動でそのプラグインがロードおよび初期化されないように <code class="literal">mysql.plugin</code> テーブルからそのプラグインの行を削除します。<code class="literal">UNINSTALL PLUGIN</code> では、そのプラグインの共有ライブラリファイルは削除されません。
      </p><p>
        プラグインを使用しているテーブルが開いている場合は、そのプラグインをアンインストールできません。
      </p><p>
        プラグインの削除は、関連付けられたテーブルの使用に影響を与えます。たとえば、全文パーサープラグインがテーブル上の <code class="literal">FULLTEXT</code> インデックスに関連付けられている場合は、そのプラグインをアンインストールするとそのテーブルが使用できなくなります。そのテーブルにアクセスしようとすると、エラーが発生します。そのテーブルを開くこともできないため、そのプラグインが使用されているインデックスを削除できません。つまり、テーブルの内容が必要であるかぎり、プラグインのアンインストールは慎重に行う必要があります。あとで再インストールする予定のないプラグインをアンインストールしており、テーブルの内容が必要である場合は、あとでそのテーブルをリロードできるように、そのテーブルを <span class="command"><strong>mysqldump</strong></span> でダンプし、ダンプされた <code class="literal">CREATE TABLE</code> ステートメントから <code class="literal">WITH PARSER</code> 句を削除するようにしてください。テーブルの内容が必要でない場合は、そのテーブルに関連付けられたいずれかのプラグインがない場合でも <code class="literal">DROP TABLE</code> を使用できます。
      </p><p>
        プラグインのロードについての追加情報は、<a class="xref" href="server-administration.html#server-plugin-loading" title="5.1.8.1 プラグインのインストールおよびアンインストール">セクション5.1.8.1「プラグインのインストールおよびアンインストール」</a>を参照してください。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="set-statement"></a>13.7.4 SET 構文</h3></div></div></div><a class="indexterm" name="idm139979078362032"></a><pre class="programlisting">
SET <em class="replaceable"><code>variable_assignment</code></em> [, <em class="replaceable"><code>variable_assignment</code></em>] ...

<em class="replaceable"><code>variable_assignment</code></em>:
      <em class="replaceable"><code>user_var_name</code></em> = <em class="replaceable"><code>expr</code></em>
    | [GLOBAL | SESSION] <em class="replaceable"><code>system_var_name</code></em> = <em class="replaceable"><code>expr</code></em>
    | [@@global. | @@session. | @@]<em class="replaceable"><code>system_var_name</code></em> = <em class="replaceable"><code>expr</code></em>
</pre><p>
      <code class="literal">SET</code> ステートメントは、サーバーまたはクライアントの操作に影響を与える各種の変数に値を割り当てます。
    </p><p>
      このセクションでは、変数に値を割り当てるための <code class="literal">SET</code> の使用について説明します。<code class="literal">SET</code> ステートメントを使用すると、次の種類の変数に値を割り当てることができます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          システム変数。<a class="xref" href="server-administration.html#server-system-variables" title="5.1.4 サーバーシステム変数">セクション5.1.4「サーバーシステム変数」</a>を参照してください。システム変数はまた、<a class="xref" href="server-administration.html#using-system-variables" title="5.1.5 システム変数の使用">セクション5.1.5「システム変数の使用」</a>で説明されているように、サーバーの起動時にも設定できます。
        </p><p>
          ユーザー定義変数。<a class="xref" href="language-structure.html#user-variables" title="9.4 ユーザー定義変数">セクション9.4「ユーザー定義変数」</a>を参照してください。
        </p></li><li class="listitem"><p>
          ストアドプロシージャーやストアドファンクションのパラメータ、およびストアドプログラムのローカル変数。<a class="xref" href="sql-syntax.html#stored-program-variables" title="13.6.4 ストアドプログラム内の変数">セクション13.6.4「ストアドプログラム内の変数」</a>を参照してください。
        </p></li></ul></div><p>
      ほかのコンテキストでは、<code class="literal">SET</code> 構文のいくつかのバリアントが使用されます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">SET CHARACTER SET</code> と <code class="literal">SET NAMES</code> は、サーバーへの接続に関連付けられた文字セットおよび照合順序変数に値を割り当てます。<code class="literal">SET ONE_SHOT</code> は、レプリケーションに使用されます。これらのバリアントについては、このセクションのあとの方で説明されています。
        </p></li><li class="listitem"><p>
          <code class="literal">SET PASSWORD</code> は、アカウントのパスワードを割り当てます。<a class="xref" href="sql-syntax.html#set-password" title="13.7.1.7 SET PASSWORD 構文">セクション13.7.1.7「SET PASSWORD 構文」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">SET TRANSACTION ISOLATION LEVEL</code> は、トランザクション処理の分離レベルを設定します。<a class="xref" href="sql-syntax.html#set-transaction" title="13.3.6 SET TRANSACTION 構文">セクション13.3.6「SET TRANSACTION 構文」</a>を参照してください。
        </p></li></ul></div><p>
      次の説明は、変数を設定するために使用できる各種の <code class="literal">SET</code> 構文を示しています。これらの例では <code class="literal">=</code> 割り当て演算子を使用していますが、この目的には <code class="literal">:=</code> 割り当て演算子も使用できます。
    </p><p>
      ユーザー変数は <code class="literal">@<em class="replaceable"><code>var_name</code></em></code> として記述され、次のように設定できます。
    </p><pre class="programlisting">
SET @<em class="replaceable"><code>var_name</code></em> = <em class="replaceable"><code>expr</code></em>;
</pre><p>
      多くのシステム変数は動的であり、<code class="literal">SET</code> ステートメントを利用してサーバーが実行している間に変更できます。リストついては、<a class="xref" href="server-administration.html#dynamic-system-variables" title="5.1.5.2 動的システム変数">セクション5.1.5.2「動的システム変数」</a>を参照してください。<code class="literal">SET</code> を利用してシステム変数を変更するには、任意で修飾子が先行する <em class="replaceable"><code>var_name</code></em> としてシステム変数を参照してください。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          変数がグローバル変数であることを明示的に指示するためには、その名前の前に <code class="literal">GLOBAL</code> または <code class="literal">@@global.</code> を付けます。グローバル変数を設定するには <code class="literal">SUPER</code> 権限が必要です。
        </p></li><li class="listitem"><p>
          変数がセッション変数であることを明示的に指示するには、その名前の前に <code class="literal">SESSION</code>、<code class="literal">@@session.</code>、または <code class="literal">@@</code> を付けます。セッション変数を正常に設定するために特殊な権限は必要ありません。ただし、例外があります (<code class="literal">sql_log_bin</code> など)。クライアントは自分のセッション変数を変更できますが、ほかのどのクライアントのセッション変数も変更できません。
        </p></li><li class="listitem"><p>
          <code class="literal">LOCAL</code> と <code class="literal">@@local.</code> は <code class="literal">SESSION</code> と <code class="literal">@@session.</code> のシノニムです。
        </p></li><li class="listitem"><p>
          修飾子が何もなければ、<code class="literal">SET</code> はセッション変数を変更します。
        </p></li></ul></div><p>
      <code class="literal">SET</code> ステートメントは、カンマで区切られた複数の変数割り当てを含むことができます。たとえば、ステートメントは、ユーザー定義変数やシステム変数に値を割り当てることができます。複数のシステム変数を設定した場合、ステートメント内のいちばん最近の <code class="literal">GLOBAL</code> または <code class="literal">SESSION</code> 修飾子が、指定された修飾子を持たない後続の変数に利用されます。
    </p><p>
      例:
    </p><pre class="programlisting">
SET sort_buffer_size=10000;
SET @@local.sort_buffer_size=10000;
SET GLOBAL sort_buffer_size=1000000, SESSION sort_buffer_size=1000000;
SET @@sort_buffer_size=1000000;
SET @@global.sort_buffer_size=1000000, @@local.sort_buffer_size=1000000;
</pre><p>
      システム変数の <code class="literal">@@<em class="replaceable"><code>var_name</code></em></code> 構文では、ほかの一部のデータベースシステムとの互換性をサポートしています。
    </p><p>
      セッションシステム変数を変更すると、セッションが終了するまで、または変数を異なる値に変更するまではその値は有効になります。別のクライアントは変更を見ることができません。
    </p><p>
      グローバルシステム変数を変更すると、その値はサーバーが再起動するまでの間記憶され、新しい接続に利用されます。(グローバルシステム変数を永続的に設定するには、オプションファイルに設定する必要があります。)そのグローバル変数にアクセスするすべてのクライアントが変更を確認できます。ただし変更は、変更後に接続するクライアントの対応するセッション変数にのみ影響を与えます。グローバル変数の変更は、現在接続中のクライアントのセッション変数に影響を与えません (<code class="literal">SET GLOBAL</code> ステートメントを発行するクライアントのセッション変数にも影響を与えません)。
    </p><p>
      誤用を防ぐために、<code class="literal">SET SESSION</code> とのみ利用できる変数とともに <code class="literal">SET GLOBAL</code> を使用したり、グローバル変数の設定時に <code class="literal">GLOBAL</code> (または <code class="literal">@@global.</code>) を指定しなかったりした場合に、MySQL でエラーが生じます。
    </p><p>
      <code class="literal">SESSION</code> 変数を <code class="literal">GLOBAL</code> 値に設定したり、<code class="literal">GLOBAL</code> 値をコンパイル時の MySQL のデフォルト値に設定したりするには、<code class="literal">DEFAULT</code> キーワードを使用します。たとえば、次の 2 つのステートメントは、<code class="literal">max_join_size</code> のセッション値をグローバル値に設定する上で同一です。
    </p><pre class="programlisting">
SET max_join_size=DEFAULT;
SET @@session.max_join_size=@@global.max_join_size;
</pre><p>
      すべてのシステム変数を <code class="literal">DEFAULT</code> に設定できるわけではありません。そのような場合、<code class="literal">DEFAULT</code> を使用するとエラーが発生します。
    </p><p>
      ユーザー定義変数、ストアドプロシージャーやストアドファンクションのパラメータ、またはストアドプログラムのローカル変数に値 <code class="literal">DEFAULT</code> を割り当てることは許可されません。ユーザー定義変数の場合、これは構文エラーになります。また、MySQL 5.6.6 の時点では、パラメータまたはローカル変数の場合も同様です。
    </p><p>
      いずれかの <code class="literal">@@</code> 修飾子を使用することによって、特定のグローバルシステム変数またはセッションシステム変数の値を式で参照できます。たとえば、次のようにして <code class="literal">SELECT</code> ステートメントで値を取得できます。
    </p><pre class="programlisting">
SELECT @@global.sql_mode, @@session.sql_mode, @@sql_mode;
</pre><p>
      <code class="literal">@@<em class="replaceable"><code>var_name</code></em></code> のような式でシステム変数を参照するとき (つまり、<code class="literal">@@global.</code> または <code class="literal">@@session.</code> を指定しない場合)、MySQL はセッション値が存在すればそれを返し、それ以外の場合はグローバル値を返します。(これは、常にセッション値を参照する <code class="literal">SET @@<em class="replaceable"><code>var_name</code></em> = <em class="replaceable"><code>value</code></em></code> とは異なります。)
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">SHOW VARIABLES</code> によって表示される一部の変数は、<code class="literal">SELECT @@<em class="replaceable"><code>var_name</code></em></code> 構文で使用できない場合があり、<code class="literal">「不明なシステム変数です」</code>と表示されます。その場合の回避方法として、<code class="literal">SHOW VARIABLES LIKE '<em class="replaceable"><code>var_name</code></em>'</code> を使用できます。
      </p></div><p>
      値乗数を指定するサフィクスは、サーバーの起動時に変数を設定するときに使用できますが、実行時に <code class="literal">SET</code> で値を設定するためには使用できません。一方、<code class="literal">SET</code> を使用すると、式を使用して変数の値を割り当てることができますが、サーバーの起動時に変数を設定するときには使用できません。たとえば、サーバーの起動時に次の 1 行目は有効ですが 2 行目は無効です。
    </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>mysql --max_allowed_packet=16M</code></strong>
shell&gt; <strong class="userinput"><code>mysql --max_allowed_packet=16*1024*1024</code></strong>
</pre><p>
      逆に、実行時に次の 2 行目は有効ですが 1 行目は無効です。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET GLOBAL max_allowed_packet=16M;</code></strong>
mysql&gt; <strong class="userinput"><code>SET GLOBAL max_allowed_packet=16*1024*1024;</code></strong>
</pre><p>
      システム変数の名前と値を表示するには、<code class="literal">SHOW VARIABLES</code> ステートメントを使用します。(<a class="xref" href="sql-syntax.html#show-variables" title="13.7.5.40 SHOW VARIABLES 構文">セクション13.7.5.40「SHOW VARIABLES 構文」</a>を参照してください。) 
    </p><p>
      次のリストは、標準以外の構文を持つ <code class="literal">SET</code> オプション (つまり、<code class="literal"><em class="replaceable"><code>name</code></em> = <em class="replaceable"><code>value</code></em></code> 構文では設定されないオプション) を示しています。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="indexterm" name="idm139979078249152"></a> <code class="literal">CHARACTER SET {<em class="replaceable"><code>charset_name</code></em> | DEFAULT}</code>
        </p><p>
          これは、マッピングが指定されているすべての文字列をクライアントとの間でマップします。MySQL ソース配布内の <code class="filename">sql/convert.cc</code> を編集することによって、新しいマッピングを追加できます。<code class="literal">SET CHARACTER SET</code> は、3 つのセッションシステム変数を設定します。<code class="literal">character_set_client</code> と <code class="literal">character_set_results</code> は指定された文字セットに設定され、<code class="literal">character_set_connection</code> は <code class="literal">character_set_database</code> の値に設定されます。<a class="xref" href="globalization.html#charset-connection" title="10.1.4 接続文字セットおよび照合順序">セクション10.1.4「接続文字セットおよび照合順序」</a>を参照してください。
        </p><p>
          デフォルトのマッピングは、値 <code class="literal">DEFAULT</code> を使用してリストアできます。このデフォルトは、サーバー構成によって異なります。
        </p><p>
          <code class="literal">ucs2</code>、<code class="literal">utf16</code>、および <code class="literal">utf32</code> は、クライアント文字セットとして使用できません。つまり、これらは <code class="literal">SET CHARACTER SET</code> では機能しません。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979078233024"></a> <code class="literal">NAMES {'<em class="replaceable"><code>charset_name</code></em>' [COLLATE '<em class="replaceable"><code>collation_name</code></em>'] | DEFAULT}</code>
        </p><p>
          <code class="literal">SET NAMES</code> は、3 つのセッションシステム変数 <code class="literal">character_set_client</code>、<code class="literal">character_set_connection</code>、および <code class="literal">character_set_results</code> を指定された文字セットに設定します。<code class="literal">character_set_connection</code> を <code class="literal">charset_name</code> に設定すると、<code class="literal">collation_connection</code> も <code class="literal">charset_name</code> のデフォルトの照合順序に設定されます。オプションの <code class="literal">COLLATE</code> 句を使用すると、照合順序を明示的に指定できます。<a class="xref" href="globalization.html#charset-connection" title="10.1.4 接続文字セットおよび照合順序">セクション10.1.4「接続文字セットおよび照合順序」</a>を参照してください。
        </p><p>
          デフォルトのマッピングは、<code class="literal">DEFAULT</code> の値を使用してリストアできます。このデフォルトは、サーバー構成によって異なります。
        </p><p>
          <code class="literal">ucs2</code>、<code class="literal">utf16</code>、および <code class="literal">utf32</code> は、クライアント文字セットとして使用できません。つまり、これらは <code class="literal">SET NAMES</code> では機能しません。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979078214304"></a> <code class="literal">ONE_SHOT</code>
        </p><p>
          <code class="literal">ONE_SHOT</code> は、内部でのみ使用されます。これは、MySQL 5.0 から非推奨であり、MySQL 5.6.1 で削除されました。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="show"></a>13.7.5 SHOW 構文</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-syntax.html#show-authors">13.7.5.1 SHOW AUTHORS 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-binary-logs">13.7.5.2 SHOW BINARY LOGS 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-binlog-events">13.7.5.3 SHOW BINLOG EVENTS 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-character-set">13.7.5.4 SHOW CHARACTER SET 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-collation">13.7.5.5 SHOW COLLATION 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-columns">13.7.5.6 SHOW COLUMNS 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-contributors">13.7.5.7 SHOW CONTRIBUTORS 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-create-database">13.7.5.8 SHOW CREATE DATABASE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-create-event">13.7.5.9 SHOW CREATE EVENT 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-create-function">13.7.5.10 SHOW CREATE FUNCTION 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-create-procedure">13.7.5.11 SHOW CREATE PROCEDURE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-create-table">13.7.5.12 SHOW CREATE TABLE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-create-trigger">13.7.5.13 SHOW CREATE TRIGGER 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-create-view">13.7.5.14 SHOW CREATE VIEW 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-databases">13.7.5.15 SHOW DATABASES 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-engine">13.7.5.16 SHOW ENGINE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-engines">13.7.5.17 SHOW ENGINES 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-errors">13.7.5.18 SHOW ERRORS 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-events">13.7.5.19 SHOW EVENTS 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-function-code">13.7.5.20 SHOW FUNCTION CODE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-function-status">13.7.5.21 SHOW FUNCTION STATUS 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-grants">13.7.5.22 SHOW GRANTS 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-index">13.7.5.23 SHOW INDEX 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-master-status">13.7.5.24 SHOW MASTER STATUS 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-open-tables">13.7.5.25 SHOW OPEN TABLES 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-plugins">13.7.5.26 SHOW PLUGINS 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-privileges">13.7.5.27 SHOW PRIVILEGES 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-procedure-code">13.7.5.28 SHOW PROCEDURE CODE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-procedure-status">13.7.5.29 SHOW PROCEDURE STATUS 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-processlist">13.7.5.30 SHOW PROCESSLIST 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-profile">13.7.5.31 SHOW PROFILE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-profiles">13.7.5.32 SHOW PROFILES 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-relaylog-events">13.7.5.33 SHOW RELAYLOG EVENTS 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-slave-hosts">13.7.5.34 SHOW SLAVE HOSTS 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-slave-status">13.7.5.35 SHOW SLAVE STATUS 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-status">13.7.5.36 SHOW STATUS 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-table-status">13.7.5.37 SHOW TABLE STATUS 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-tables">13.7.5.38 SHOW TABLES 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-triggers">13.7.5.39 SHOW TRIGGERS 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-variables">13.7.5.40 SHOW VARIABLES 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show-warnings">13.7.5.41 SHOW WARNINGS 構文</a></span></dt></dl></div><a class="indexterm" name="idm139979078208224"></a><a class="indexterm" name="idm139979078204832"></a><a class="indexterm" name="idm139979078202656"></a><a class="indexterm" name="idm139979078201424"></a><a class="indexterm" name="idm139979078200080"></a><a class="indexterm" name="idm139979078198736"></a><a class="indexterm" name="idm139979078197392"></a><a class="indexterm" name="idm139979078196048"></a><a class="indexterm" name="idm139979078194704"></a><a class="indexterm" name="idm139979078193360"></a><a class="indexterm" name="idm139979078192016"></a><a class="indexterm" name="idm139979078190672"></a><a class="indexterm" name="idm139979078189328"></a><a class="indexterm" name="idm139979078187984"></a><a class="indexterm" name="idm139979078186640"></a><a class="indexterm" name="idm139979078185296"></a><a class="indexterm" name="idm139979078183952"></a><a class="indexterm" name="idm139979078182608"></a><a class="indexterm" name="idm139979078181264"></a><a class="indexterm" name="idm139979078179920"></a><a class="indexterm" name="idm139979078178576"></a><a class="indexterm" name="idm139979078177232"></a><a class="indexterm" name="idm139979078175888"></a><a class="indexterm" name="idm139979078174544"></a><a class="indexterm" name="idm139979078173200"></a><a class="indexterm" name="idm139979078171856"></a><a class="indexterm" name="idm139979078170512"></a><a class="indexterm" name="idm139979078169168"></a><a class="indexterm" name="idm139979078167824"></a><a class="indexterm" name="idm139979078166480"></a><a class="indexterm" name="idm139979078165136"></a><a class="indexterm" name="idm139979078163792"></a><a class="indexterm" name="idm139979078162448"></a><a class="indexterm" name="idm139979078161104"></a><a class="indexterm" name="idm139979078159760"></a><a class="indexterm" name="idm139979078158416"></a><a class="indexterm" name="idm139979078157072"></a><a class="indexterm" name="idm139979078155728"></a><a class="indexterm" name="idm139979078154384"></a><a class="indexterm" name="idm139979078153040"></a><a class="indexterm" name="idm139979078151696"></a><a class="indexterm" name="idm139979078150352"></a><a class="indexterm" name="idm139979078149008"></a><a class="indexterm" name="idm139979078147664"></a><a class="indexterm" name="idm139979078146320"></a><a class="indexterm" name="idm139979078144976"></a><p>
      <code class="literal">SHOW</code> には、データベース、テーブル、カラムに関する情報、またはサーバーに関するステータス情報を提供するための多くの形式があります。このセクションでは、次のものについて説明します。
    </p><pre class="programlisting">
SHOW AUTHORS
SHOW {BINARY | MASTER} LOGS
SHOW BINLOG EVENTS [IN '<em class="replaceable"><code>log_name</code></em>'] [FROM <em class="replaceable"><code>pos</code></em>] [LIMIT [<em class="replaceable"><code>offset</code></em>,] <em class="replaceable"><code>row_count</code></em>]
SHOW CHARACTER SET [<em class="replaceable"><code>like_or_where</code></em>]
SHOW COLLATION [<em class="replaceable"><code>like_or_where</code></em>]
SHOW [FULL] COLUMNS FROM <em class="replaceable"><code>tbl_name</code></em> [FROM <em class="replaceable"><code>db_name</code></em>] [<em class="replaceable"><code>like_or_where</code></em>]
SHOW CONTRIBUTORS
SHOW CREATE DATABASE <em class="replaceable"><code>db_name</code></em>
SHOW CREATE EVENT <em class="replaceable"><code>event_name</code></em>
SHOW CREATE FUNCTION <em class="replaceable"><code>func_name</code></em>
SHOW CREATE PROCEDURE <em class="replaceable"><code>proc_name</code></em>
SHOW CREATE TABLE <em class="replaceable"><code>tbl_name</code></em>
SHOW CREATE TRIGGER <em class="replaceable"><code>trigger_name</code></em>
SHOW CREATE VIEW <em class="replaceable"><code>view_name</code></em>
SHOW DATABASES [<em class="replaceable"><code>like_or_where</code></em>]
SHOW ENGINE <em class="replaceable"><code>engine_name</code></em> {STATUS | MUTEX}
SHOW [STORAGE] ENGINES
SHOW ERRORS [LIMIT [<em class="replaceable"><code>offset</code></em>,] <em class="replaceable"><code>row_count</code></em>]
SHOW EVENTS
SHOW FUNCTION CODE <em class="replaceable"><code>func_name</code></em>
SHOW FUNCTION STATUS [<em class="replaceable"><code>like_or_where</code></em>]
SHOW GRANTS FOR <em class="replaceable"><code>user</code></em>
SHOW INDEX FROM <em class="replaceable"><code>tbl_name</code></em> [FROM <em class="replaceable"><code>db_name</code></em>]
SHOW MASTER STATUS
SHOW OPEN TABLES [FROM <em class="replaceable"><code>db_name</code></em>] [<em class="replaceable"><code>like_or_where</code></em>]
SHOW PLUGINS
SHOW PROCEDURE CODE <em class="replaceable"><code>proc_name</code></em>
SHOW PROCEDURE STATUS [<em class="replaceable"><code>like_or_where</code></em>]
SHOW PRIVILEGES
SHOW [FULL] PROCESSLIST
SHOW PROFILE [<em class="replaceable"><code>types</code></em>] [FOR QUERY <em class="replaceable"><code>n</code></em>] [OFFSET <em class="replaceable"><code>n</code></em>] [LIMIT <em class="replaceable"><code>n</code></em>]
SHOW PROFILES
SHOW SLAVE HOSTS
SHOW SLAVE STATUS
SHOW [GLOBAL | SESSION] STATUS [<em class="replaceable"><code>like_or_where</code></em>]
SHOW TABLE STATUS [FROM <em class="replaceable"><code>db_name</code></em>] [<em class="replaceable"><code>like_or_where</code></em>]
SHOW [FULL] TABLES [FROM <em class="replaceable"><code>db_name</code></em>] [<em class="replaceable"><code>like_or_where</code></em>]
SHOW TRIGGERS [FROM <em class="replaceable"><code>db_name</code></em>] [<em class="replaceable"><code>like_or_where</code></em>]
SHOW [GLOBAL | SESSION] VARIABLES [<em class="replaceable"><code>like_or_where</code></em>]
SHOW WARNINGS [LIMIT [<em class="replaceable"><code>offset</code></em>,] <em class="replaceable"><code>row_count</code></em>]

<em class="replaceable"><code>like_or_where</code></em>:
    LIKE '<em class="replaceable"><code>pattern</code></em>'
  | WHERE <em class="replaceable"><code>expr</code></em>
</pre><p>
      特定の <code class="literal">SHOW</code> ステートメントの構文に <code class="literal">LIKE '<em class="replaceable"><code>pattern</code></em>'</code> 部分が含まれている場合、<code class="literal">'<em class="replaceable"><code>pattern</code></em>'</code> は SQL の<span class="quote">「<span class="quote"><code class="literal">%</code></span>」</span>と<span class="quote">「<span class="quote"><code class="literal">_</code></span>」</span>のワイルドカード文字を含むことのできる文字列です。このパターンは、ステートメント出力を一致する値に制限するために役立ちます。
    </p><p>
      いくつかの <code class="literal">SHOW</code> ステートメントは、どの行を表示するかをより柔軟に指定できる <code class="literal">WHERE</code> 句も受け入れます。<a class="xref" href="information-schema.html#extended-show" title="21.32 SHOW ステートメントの拡張">セクション21.32「SHOW ステートメントの拡張」</a>を参照してください。
    </p><p>
      多くの MySQL API (PHP など) では、<code class="literal">SHOW</code> ステートメントから返された結果を <code class="literal">SELECT</code> からの結果セットのように処理できます。詳細は、<a class="xref" href="connectors-apis.html" title="第 23 章 Connector および API">第23章「<i>Connector および API</i>」</a>または API のドキュメントを参照してください。さらに、SQL では、<code class="literal">INFORMATION_SCHEMA</code> データベース内のテーブルに対するクエリーからの結果を操作できます。これは、<code class="literal">SHOW</code> ステートメントからの結果では簡単にはできません。<a class="xref" href="information-schema.html" title="第 21 章 INFORMATION_SCHEMA テーブル">第21章「<i>INFORMATION_SCHEMA テーブル</i>」</a>を参照してください。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-authors"></a>13.7.5.1 SHOW AUTHORS 構文</h4></div></div></div><a class="indexterm" name="idm139979078100912"></a><pre class="programlisting">
SHOW AUTHORS
</pre><p>
        <code class="literal">SHOW AUTHORS</code> ステートメントは、MySQL に関して作業している人びとに関する情報を表示します。作成者ごとに、<code class="literal">Name</code>、<code class="literal">Location</code>、および <code class="literal">Comment</code> 値を表示します。
      </p><p>
        このステートメントは、MySQL 5.6.8 の時点で削除されています。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-binary-logs"></a>13.7.5.2 SHOW BINARY LOGS 構文</h4></div></div></div><a class="indexterm" name="idm139979078090080"></a><a class="indexterm" name="idm139979078088768"></a><pre class="programlisting">
SHOW BINARY LOGS
SHOW MASTER LOGS
</pre><p>
        サーバー上のバイナリログファイルを一覧表示します。このステートメントは、どのログをパージできるかを決定する方法を示す、<a class="xref" href="sql-syntax.html#purge-binary-logs" title="13.4.1.1 PURGE BINARY LOGS 構文">セクション13.4.1.1「PURGE BINARY LOGS 構文」</a>で説明されている手順の一部として使用されます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW BINARY LOGS;</code></strong>
+---------------+-----------+
| Log_name      | File_size |
+---------------+-----------+
| binlog.000015 |    724935 |
| binlog.000016 |    733481 |
+---------------+-----------+
</pre><p>
        <code class="literal">SHOW MASTER LOGS</code> は <code class="literal">SHOW BINARY LOGS</code> と同等です。
      </p><p>
        MySQL 5.6.5 以前では、このステートメントを使用するには <code class="literal">SUPER</code> 権限が必要でした。MySQL 5.6.6 からは、<code class="literal">REPLICATION CLIENT</code> 権限を持つユーザーもこのステートメントを実行できます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-binlog-events"></a>13.7.5.3 SHOW BINLOG EVENTS 構文</h4></div></div></div><a class="indexterm" name="idm139979078073728"></a><pre class="programlisting">
SHOW BINLOG EVENTS
   [IN '<em class="replaceable"><code>log_name</code></em>'] [FROM <em class="replaceable"><code>pos</code></em>] [LIMIT [<em class="replaceable"><code>offset</code></em>,] <em class="replaceable"><code>row_count</code></em>]
</pre><p>
        バイナリログ内のイベントを表示します。<code class="literal">'<em class="replaceable"><code>log_name</code></em>'</code> を指定しない場合は、最初のバイナリログが表示されます。
      </p><p>
        <code class="literal">LIMIT</code> 句の構文は、<code class="literal">SELECT</code> ステートメントの場合と同じです。<a class="xref" href="sql-syntax.html#select" title="13.2.9 SELECT 構文">セクション13.2.9「SELECT 構文」</a>を参照してください。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">SHOW BINLOG EVENTS</code> を <code class="literal">LIMIT</code> 句なしで発行すると、サーバーはクライアントに (サーバーによって実行された、データを変更するすべてのステートメントを含む) バイナリログの完全な内容を返すため、時間とリソースを大量に消費するプロセスが開始される可能性があります。あとの調査や分析のためにバイナリログをテキストファイルに保存するには、<code class="literal">SHOW BINLOG EVENTS</code> の代わりに <span class="command"><strong>mysqlbinlog</strong></span> ユーティリティーを使用してください。<a class="xref" href="programs.html#mysqlbinlog" title="4.6.8 mysqlbinlog — バイナリログファイルを処理するためのユーティリティー">セクション4.6.8「<span class="command"><strong>mysqlbinlog</strong></span> — バイナリログファイルを処理するためのユーティリティー」</a>を参照してください。
        </p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">SHOW BINLOG EVENTS</code> からの出力には、ユーザーおよびシステム変数の設定に関連した一部のイベントが含まれていません。バイナリログ内のイベントを完全に取得するには、<span class="command"><strong>mysqlbinlog</strong></span> を使用します。
        </p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">SHOW BINLOG EVENTS</code> は、リレーログファイルを操作<span class="emphasis"><em>しません</em></span>。この目的には、<code class="literal">SHOW RELAYLOG EVENTS</code> を使用できます。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-character-set"></a>13.7.5.4 SHOW CHARACTER SET 構文</h4></div></div></div><a class="indexterm" name="idm139979078049104"></a><pre class="programlisting">
SHOW CHARACTER SET
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
        <code class="literal">SHOW CHARACTER SET</code> ステートメントは使用可能な文字セットをすべて表示します。<code class="literal">LIKE</code> 句 (存在する場合) は、どの文字セット名と照合するかを示します。<a class="xref" href="information-schema.html#extended-show" title="21.32 SHOW ステートメントの拡張">セクション21.32「SHOW ステートメントの拡張」</a>で説明されているように、<code class="literal">WHERE</code> 句を指定すると、より一般的な条件を使用して行を選択できます。例:
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW CHARACTER SET LIKE 'latin%';</code></strong>
+---------+-----------------------------+-------------------+--------+
| Charset | Description                 | Default collation | Maxlen |
+---------+-----------------------------+-------------------+--------+
| latin1  | cp1252 West European        | latin1_swedish_ci |      1 |
| latin2  | ISO 8859-2 Central European | latin2_general_ci |      1 |
| latin5  | ISO 8859-9 Turkish          | latin5_turkish_ci |      1 |
| latin7  | ISO 8859-13 Baltic          | latin7_general_ci |      1 |
+---------+-----------------------------+-------------------+--------+
</pre><p>
        <code class="literal">Maxlen</code> カラムは、1 文字を格納するために必要な最大バイト数を表示します。
      </p><p>
        <code class="literal">filename</code> 文字セットは、内部でのみ使用されます。そのため、<code class="literal">SHOW CHARACTER SET</code> では表示されません。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-collation"></a>13.7.5.5 SHOW COLLATION 構文</h4></div></div></div><a class="indexterm" name="idm139979078032000"></a><pre class="programlisting">
SHOW COLLATION
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
        このステートメントは、サーバーによってサポートされる照合順序を一覧表示します。デフォルトでは、<code class="literal">SHOW COLLATION</code> からの出力には、使用可能なすべての照合順序が含まれます。<code class="literal">LIKE</code> 句 (存在する場合) は、どの照合順序名と照合するかを示します。<a class="xref" href="information-schema.html#extended-show" title="21.32 SHOW ステートメントの拡張">セクション21.32「SHOW ステートメントの拡張」</a>で説明されているように、<code class="literal">WHERE</code> 句を指定すると、より一般的な条件を使用して行を選択できます。例:
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW COLLATION LIKE 'latin1%';</code></strong>
+-------------------+---------+----+---------+----------+---------+
| Collation         | Charset | Id | Default | Compiled | Sortlen |
+-------------------+---------+----+---------+----------+---------+
| latin1_german1_ci | latin1  |  5 |         |          |       0 |
| latin1_swedish_ci | latin1  |  8 | Yes     | Yes      |       0 |
| latin1_danish_ci  | latin1  | 15 |         |          |       0 |
| latin1_german2_ci | latin1  | 31 |         | Yes      |       2 |
| latin1_bin        | latin1  | 47 |         | Yes      |       0 |
| latin1_general_ci | latin1  | 48 |         |          |       0 |
| latin1_general_cs | latin1  | 49 |         |          |       0 |
| latin1_spanish_ci | latin1  | 94 |         |          |       0 |
+-------------------+---------+----+---------+----------+---------+
</pre><p>
        <code class="literal">Collation</code> および <code class="literal">Charset</code> カラムは、照合順序の名前と、その照合順序が関連付けられている文字セットを示します。<code class="literal">Id</code> は照合順序 ID です。<code class="literal">Default</code> は、この照合順序がその文字セットのデフォルトであるかどうかを示します。<code class="literal">Compiled</code> は、この文字セットがサーバーにコンパイルされているかどうかを示します。<code class="literal">Sortlen</code> は、この文字セットで表される文字列をソートするために必要なメモリーの量に関連しています。
      </p><p>
        各文字セットのデフォルトの照合順序を表示するには、次のステートメントを使用します。<code class="literal">Default</code> は予約語であるため、それを識別子として使用するには、次のように引用符で囲む必要があります。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW COLLATION WHERE `Default` = 'Yes';</code></strong>
+---------------------+----------+----+---------+----------+---------+
| Collation           | Charset  | Id | Default | Compiled | Sortlen |
+---------------------+----------+----+---------+----------+---------+
| big5_chinese_ci     | big5     |  1 | Yes     | Yes      |       1 |
| dec8_swedish_ci     | dec8     |  3 | Yes     | Yes      |       1 |
| cp850_general_ci    | cp850    |  4 | Yes     | Yes      |       1 |
| hp8_english_ci      | hp8      |  6 | Yes     | Yes      |       1 |
| koi8r_general_ci    | koi8r    |  7 | Yes     | Yes      |       1 |
| latin1_swedish_ci   | latin1   |  8 | Yes     | Yes      |       1 |
...
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-columns"></a>13.7.5.6 SHOW COLUMNS 構文</h4></div></div></div><a class="indexterm" name="idm139979078008624"></a><a class="indexterm" name="idm139979078005264"></a><pre class="programlisting">
SHOW [FULL] COLUMNS {FROM | IN} <em class="replaceable"><code>tbl_name</code></em> [{FROM | IN} <em class="replaceable"><code>db_name</code></em>]
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
        <code class="literal">SHOW COLUMNS</code> は、特定のテーブル内のカラムに関する情報を表示します。これはビューに対しても機能します。<code class="literal">LIKE</code> 句 (存在する場合) は、どのカラム名と照合するかを示します。<a class="xref" href="information-schema.html#extended-show" title="21.32 SHOW ステートメントの拡張">セクション21.32「SHOW ステートメントの拡張」</a>で説明されているように、<code class="literal">WHERE</code> 句を指定すると、より一般的な条件を使用して行を選択できます。
      </p><p>
        <code class="literal">SHOW COLUMNS</code> は、ユーザーが何らかの権限を持っているカラムの情報のみを表示します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW COLUMNS FROM City;</code></strong>
+------------+----------+------+-----+---------+----------------+
| Field      | Type     | Null | Key | Default | Extra          |
+------------+----------+------+-----+---------+----------------+
| Id         | int(11)  | NO   | PRI | NULL    | auto_increment |
| Name       | char(35) | NO   |     |         |                |
| Country    | char(3)  | NO   | UNI |         |                |
| District   | char(20) | YES  | MUL |         |                |
| Population | int(11)  | NO   |     | 0       |                |
+------------+----------+------+-----+---------+----------------+
5 rows in set (0.00 sec)
</pre><p>
        データ型が、<code class="literal">CREATE TABLE</code> ステートメントに基づいて予測されるものと異なる場合は、テーブルの作成または変更時に MySQL によってデータ型が変更される場合があります。この状態が発生する条件は、<a class="xref" href="sql-syntax.html#silent-column-changes" title="13.1.17.3 暗黙のカラム指定の変更">セクション13.1.17.3「暗黙のカラム指定の変更」</a>で説明されています。
      </p><p>
        <code class="literal">FULL</code> キーワードを指定すると、カラムの照合順序とコメント、およびユーザーが各カラムに対して持っている権限が出力に含まれます。
      </p><p>
        <code class="literal"><em class="replaceable"><code>tbl_name</code></em> FROM <em class="replaceable"><code>db_name</code></em></code> 構文の代わりに <em class="replaceable"><code>db_name.tbl_name</code></em> を使用できます。つまり、次の 2 つのステートメントは同等です。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW COLUMNS FROM mytable FROM mydb;</code></strong>
mysql&gt; <strong class="userinput"><code>SHOW COLUMNS FROM mydb.mytable;</code></strong>
</pre><p>
        <code class="literal">SHOW COLUMNS</code> は、テーブルカラムごとに次の値を表示します。
      </p><p>
        <code class="literal">Field</code> は、カラム名を示します。
      </p><p>
        <code class="literal">Type</code> は、カラムデータ型を示します。
      </p><p>
        <code class="literal">Collation</code> は、バイナリ以外の文字列カラムの場合は照合順序、その他のカラムの場合は <code class="literal">NULL</code> を示します。この値は、<code class="literal">FULL</code> キーワードを使用した場合にのみ表示されます。
      </p><p>
        <code class="literal">Null</code> フィールドには、このカラムに <code class="literal">NULL</code> 値を格納できる場合は <code class="literal">YES</code>、できない場合は <code class="literal">NO</code> が含まれます。
      </p><p>
        <code class="literal">Key</code> フィールドは、このカラムがインデックス設定されているかどうかを示します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Key</code> が空の場合、このカラムはインデックス設定されていないか、またはマルチカラム内のセカンダリカラム (一意でないインデックス) としてのみインデックス設定されているかのどちらかです。
          </p></li><li class="listitem"><p>
            <code class="literal">Key</code> が <code class="literal">PRI</code> の場合、このカラムは <code class="literal">PRIMARY KEY</code> であるか、またはマルチカラム <code class="literal">PRIMARY KEY</code> 内のいずれかのカラムです。
          </p></li><li class="listitem"><p>
            <code class="literal">Key</code> が <code class="literal">UNI</code> の場合、このカラムは <code class="literal">UNIQUE</code> インデックスの最初のカラムです。(<code class="literal">UNIQUE</code> インデックスは複数の <code class="literal">NULL</code> 値を許可しますが、そのカラムが <code class="literal">NULL</code> を許可するかどうかは <code class="literal">Null</code> フィールドをチェックすることによってわかります。) 
          </p></li><li class="listitem"><p>
            <code class="literal">Key</code> が <code class="literal">MUL</code> の場合、このカラムは、特定の値がカラム内に複数回現れることが許可されている一意でないインデックスの最初のカラムです。
          </p></li></ul></div><p>
        テーブルの特定のカラムに複数の <code class="literal">Key</code> 値が適用される場合、<code class="literal">Key</code> には、もっとも優先度の高い値が <code class="literal">PRI</code>、<code class="literal">UNI</code>、<code class="literal">MUL</code> の順序で表示されます。
      </p><p>
        <code class="literal">UNIQUE</code> インデックスは、<code class="literal">NULL</code> 値を含むことができず、かつテーブル内に <code class="literal">PRIMARY KEY</code> が存在しない場合は <code class="literal">PRI</code> として表示される可能性があります。<code class="literal">UNIQUE</code> インデックスは、複数のカラムが複合 <code class="literal">UNIQUE</code> インデックスを形成している場合は <code class="literal">MUL</code> として表示される可能性があります。このカラムの組み合わせは一意であるにもかかわらず、各カラムには引き続き、特定の値が複数回現れることがあります。
      </p><p>
        <code class="literal">Default</code> フィールドは、このカラムに割り当てられているデフォルト値を示します。このカラムの明示的なデフォルト値が <code class="literal">NULL</code> である場合や、カラム定義に <code class="literal">DEFAULT</code> 句が含まれていない場合、これは <code class="literal">NULL</code> です。
      </p><p>
        <code class="literal">Extra</code> フィールドには、特定のカラムに関して使用可能な任意の追加情報が含まれます。この値が空以外になるのは、<code class="literal">AUTO_INCREMENT</code> 属性を持つカラムに対する <code class="literal">auto_increment</code> と、<code class="literal">ON UPDATE CURRENT_TIMESTAMP</code> 属性を持つ <code class="literal">TIMESTAMP</code> または <code class="literal">DATETIME</code> カラムに対する <code class="literal">on update CURRENT_TIMESTAMP</code> です。
      </p><p>
        <code class="literal">Privileges</code> は、ユーザーがこのカラムに対して持っている権限を示します。この値は、<code class="literal">FULL</code> キーワードを使用した場合にのみ表示されます。
      </p><p>
        <code class="literal">Comment</code> は、このカラムに含まれている任意のコメントを示します。この値は、<code class="literal">FULL</code> キーワードを使用した場合にのみ表示されます。
      </p><a class="indexterm" name="idm139979077931168"></a><p>
        <code class="literal">SHOW FIELDS</code> は <code class="literal">SHOW COLUMNS</code> のシノニムです。また、<span class="command"><strong>mysqlshow <em class="replaceable"><code>db_name</code></em> <em class="replaceable"><code>tbl_name</code></em></strong></span> コマンドを使用してテーブルのカラムを一覧表示することもできます。
      </p><p>
        <code class="literal">DESCRIBE</code> ステートメントは、<code class="literal">SHOW COLUMNS</code> と同様の情報を提供します。<a class="xref" href="sql-syntax.html#describe" title="13.8.1 DESCRIBE 構文">セクション13.8.1「DESCRIBE 構文」</a>を参照してください。
      </p><p>
        また、<code class="literal">SHOW CREATE TABLE</code>、<code class="literal">SHOW TABLE STATUS</code>、および <code class="literal">SHOW INDEX</code> ステートメントでは、テーブルに関する情報も提供されます。<a class="xref" href="sql-syntax.html#show" title="13.7.5 SHOW 構文">セクション13.7.5「SHOW 構文」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-contributors"></a>13.7.5.7 SHOW CONTRIBUTORS 構文</h4></div></div></div><a class="indexterm" name="idm139979077916768"></a><pre class="programlisting">
SHOW CONTRIBUTORS
</pre><p>
        <code class="literal">SHOW CONTRIBUTORS</code> ステートメントは、MySQL ソースまたはサポートされている原因に貢献している人びとに関する情報を表示します。貢献者ごとに、<code class="literal">Name</code>、<code class="literal">Location</code>、および <code class="literal">Comment</code> 値を表示します。
      </p><p>
        このステートメントは、MySQL 5.6.8 の時点で削除されています。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-create-database"></a>13.7.5.8 SHOW CREATE DATABASE 構文</h4></div></div></div><a class="indexterm" name="idm139979077905856"></a><a class="indexterm" name="idm139979077904544"></a><pre class="programlisting">
SHOW CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] <em class="replaceable"><code>db_name</code></em>
</pre><p>
        指定されたデータベースを作成する <code class="literal">CREATE DATABASE</code> ステートメントを表示します。<code class="literal">SHOW</code> ステートメントに <code class="literal">IF NOT EXISTS</code> 句が含まれている場合は、このような句が出力にも含まれます。<code class="literal">SHOW CREATE SCHEMA</code> は <code class="literal">SHOW CREATE DATABASE</code> のシノニムです。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW CREATE DATABASE test\G</code></strong>
*************************** 1. row ***************************
       Database: test
Create Database: CREATE DATABASE `test`
                 /*!40100 DEFAULT CHARACTER SET latin1 */

mysql&gt; <strong class="userinput"><code>SHOW CREATE SCHEMA test\G</code></strong>
*************************** 1. row ***************************
       Database: test
Create Database: CREATE DATABASE `test`
                 /*!40100 DEFAULT CHARACTER SET latin1 */
</pre><p>
        <code class="literal">SHOW CREATE DATABASE</code> は、<code class="literal">sql_quote_show_create</code> オプションの値に従って、テーブル名とカラム名を引用符で囲みます。<a class="xref" href="server-administration.html#server-system-variables" title="5.1.4 サーバーシステム変数">セクション5.1.4「サーバーシステム変数」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-create-event"></a>13.7.5.9 SHOW CREATE EVENT 構文</h4></div></div></div><pre class="programlisting">
SHOW CREATE EVENT <em class="replaceable"><code>event_name</code></em>
</pre><p>
        このステートメントは、特定のイベントを再作成するために必要な <code class="literal">CREATE EVENT</code> ステートメントを表示します。これには、このイベントが示される元のデータベースに対する <code class="literal">EVENT</code> 権限が必要です。例 (<a class="xref" href="sql-syntax.html#show-events" title="13.7.5.19 SHOW EVENTS 構文">セクション13.7.5.19「SHOW EVENTS 構文」</a>で定義され、あとで変更された同じイベント <code class="literal">e_daily</code> を使用しています):
      </p><pre class="programlisting">
mysql&gt; SHOW CREATE EVENT test.e_daily\G
*************************** 1. row ***************************
               Event: e_daily
            sql_mode:
           time_zone: SYSTEM
        Create Event: CREATE EVENT `e_daily`
                        ON SCHEDULE EVERY 1 DAY
                        STARTS CURRENT_TIMESTAMP + INTERVAL 6 HOUR
                        ON COMPLETION NOT PRESERVE
                        ENABLE
                        COMMENT 'Saves total number of sessions then
                                clears the table each day'
                        DO BEGIN
                          INSERT INTO site_activity.totals (time, total)
                            SELECT CURRENT_TIMESTAMP, COUNT(*)
                            FROM site_activity.sessions;
                          DELETE FROM site_activity.sessions;
                        END
character_set_client: latin1
collation_connection: latin1_swedish_ci
  Database Collation: latin1_swedish_ci
</pre><p>
        <code class="literal">character_set_client</code> は、このイベントが作成されたときの <code class="literal">character_set_client</code> システム変数のセッション値です。<code class="literal">collation_connection</code> は、このイベントが作成されたときの <code class="literal">collation_connection</code> システム変数のセッション値です。<code class="literal">Database Collation</code> は、このイベントが関連付けられているデータベースの照合順序です。
      </p><p>
        この出力には、このイベントが作成されたときのステータスではなく、その現在のステータス (<code class="literal">ENABLE</code>) が反映されます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-create-function"></a>13.7.5.10 SHOW CREATE FUNCTION 構文</h4></div></div></div><a class="indexterm" name="idm139979077865024"></a><pre class="programlisting">
SHOW CREATE FUNCTION <em class="replaceable"><code>func_name</code></em>
</pre><p>
        このステートメントは、ストアドファンクションである点を除き、<code class="literal">SHOW CREATE PROCEDURE</code> と同じです。<a class="xref" href="sql-syntax.html#show-create-procedure" title="13.7.5.11 SHOW CREATE PROCEDURE 構文">セクション13.7.5.11「SHOW CREATE PROCEDURE 構文」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-create-procedure"></a>13.7.5.11 SHOW CREATE PROCEDURE 構文</h4></div></div></div><a class="indexterm" name="idm139979077855808"></a><pre class="programlisting">
SHOW CREATE PROCEDURE <em class="replaceable"><code>proc_name</code></em>
</pre><p>
        このステートメントは、MySQL 拡張です。これは、指定されたストアドプロシージャーを再作成するために使用できる正確な文字列を返します。同様のステートメントである <code class="literal">SHOW CREATE FUNCTION</code> は、ストアドファンクションに関する情報を表示します (<a class="xref" href="sql-syntax.html#show-create-function" title="13.7.5.10 SHOW CREATE FUNCTION 構文">セクション13.7.5.10「SHOW CREATE FUNCTION 構文」</a>を参照してください)。
      </p><p>
        どちらのステートメントを使用するにも、このルーチンの <code class="literal">DEFINER</code> 句で指定されたユーザーであるか、または <code class="literal">mysql.proc</code> テーブルへの <code class="literal">SELECT</code> アクセス権を持っている必要があります。このルーチン自体に対する権限を持っていない場合、<code class="literal">Create Procedure</code> または <code class="literal">Create Function</code> フィールドに表示される値は <code class="literal">NULL</code> になります。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW CREATE PROCEDURE test.simpleproc\G</code></strong>
*************************** 1. row ***************************
           Procedure: simpleproc
            sql_mode:
    Create Procedure: CREATE PROCEDURE `simpleproc`(OUT param1 INT)
                      BEGIN
                      SELECT COUNT(*) INTO param1 FROM t;
                      END
character_set_client: latin1
collation_connection: latin1_swedish_ci
  Database Collation: latin1_swedish_ci

mysql&gt; <strong class="userinput"><code>SHOW CREATE FUNCTION test.hello\G</code></strong>
*************************** 1. row ***************************
            Function: hello
            sql_mode:
     Create Function: CREATE FUNCTION `hello`(s CHAR(20))
                      RETURNS CHAR(50)
                      RETURN CONCAT('Hello, ',s,'!')
character_set_client: latin1
collation_connection: latin1_swedish_ci
  Database Collation: latin1_swedish_ci
</pre><p>
        <code class="literal">character_set_client</code> は、このルーチンが作成されたときの <code class="literal">character_set_client</code> システム変数のセッション値です。<code class="literal">collation_connection</code> は、このルーチンが作成されたときの <code class="literal">collation_connection</code> システム変数のセッション値です。<code class="literal">Database Collation</code> は、このルーチンが関連付けられているデータベースの照合順序です。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-create-table"></a>13.7.5.12 SHOW CREATE TABLE 構文</h4></div></div></div><a class="indexterm" name="idm139979077831680"></a><pre class="programlisting">
SHOW CREATE TABLE <em class="replaceable"><code>tbl_name</code></em>
</pre><p>
        指定されたテーブルを作成する <code class="literal">CREATE TABLE</code> ステートメントを表示します。このステートメントを使用するには、そのテーブルに対する何らかの権限が必要です。また、このステートメントはビューでも機能します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE t\G</code></strong>
*************************** 1. row ***************************
       Table: t
Create Table: CREATE TABLE t (
  id INT(11) default NULL auto_increment,
  s char(60) default NULL,
  PRIMARY KEY (id)
) ENGINE=MyISAM

</pre><p>
        <code class="literal">SHOW CREATE TABLE</code> は、<code class="literal">sql_quote_show_create</code> オプションの値に従って、テーブル名とカラム名を引用符で囲みます。<a class="xref" href="server-administration.html#server-system-variables" title="5.1.4 サーバーシステム変数">セクション5.1.4「サーバーシステム変数」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-create-trigger"></a>13.7.5.13 SHOW CREATE TRIGGER 構文</h4></div></div></div><a class="indexterm" name="idm139979077815904"></a><pre class="programlisting">
SHOW CREATE TRIGGER <em class="replaceable"><code>trigger_name</code></em>
</pre><p>
        このステートメントは、指定されたトリガーを作成する <code class="literal">CREATE TRIGGER</code> ステートメントを表示します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW CREATE TRIGGER ins_sum\G</code></strong>
*************************** 1. row ***************************
               Trigger: ins_sum
              sql_mode: NO_ENGINE_SUBSTITUTION
SQL Original Statement: CREATE DEFINER=`me`@`localhost` TRIGGER ins_sum
                        BEFORE INSERT ON account
                        FOR EACH ROW SET @sum = @sum + NEW.amount
  character_set_client: utf8
  collation_connection: utf8_general_ci
    Database Collation: latin1_swedish_ci
</pre><p>
        <code class="literal">SHOW CREATE TRIGGER</code> の出力には、次のカラムがあります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Trigger</code>: トリガー名。
          </p></li><li class="listitem"><p>
            <code class="literal">sql_mode</code>: このトリガーが実行されるときに有効な SQL モード。
          </p></li><li class="listitem"><p>
            <code class="literal">SQL Original Statement</code>: このトリガーを定義する <code class="literal">CREATE TRIGGER</code> ステートメント。
          </p></li><li class="listitem"><p>
            <code class="literal">character_set_client</code>: このトリガーが作成されたときの <code class="literal">character_set_client</code> システム変数のセッション値。
          </p></li><li class="listitem"><p>
            <code class="literal">collation_connection</code>: このトリガーが作成されたときの <code class="literal">collation_connection</code> システム変数のセッション値。
          </p></li><li class="listitem"><p>
            <code class="literal">Database Collation</code>: このトリガーが関連付けられているデータベースの照合順序。
          </p></li></ul></div><p>
        また、<code class="literal">TRIGGERS</code> テーブルを含む <code class="literal">INFORMATION_SCHEMA</code> からトリガーオブジェクトに関する情報を取得することもできます。<a class="xref" href="information-schema.html#triggers-table" title="21.26 INFORMATION_SCHEMA TRIGGERS テーブル">セクション21.26「INFORMATION_SCHEMA TRIGGERS テーブル」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-create-view"></a>13.7.5.14 SHOW CREATE VIEW 構文</h4></div></div></div><a class="indexterm" name="idm139979077788080"></a><pre class="programlisting">
SHOW CREATE VIEW <em class="replaceable"><code>view_name</code></em>
</pre><p>
        このステートメントは、指定されたビューを作成する <code class="literal">CREATE VIEW</code> ステートメントを表示します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW CREATE VIEW v\G</code></strong>
*************************** 1. row ***************************
                View: v
         Create View: CREATE ALGORITHM=UNDEFINED
                      DEFINER=`bob`@`localhost`
                      SQL SECURITY DEFINER VIEW
                      `v` AS select 1 AS `a`,2 AS `b`
character_set_client: latin1
collation_connection: latin1_swedish_ci
</pre><p>
        <code class="literal">character_set_client</code> は、このビューが作成されたときの <code class="literal">character_set_client</code> システム変数のセッション値です。<code class="literal">collation_connection</code> は、このビューが作成されたときの <code class="literal">collation_connection</code> システム変数のセッション値です。
      </p><p>
        <code class="literal">SHOW CREATE VIEW</code> を使用するには、<code class="literal">SHOW VIEW</code> 権限、および対象のビューに対する <code class="literal">SELECT</code> 権限が必要です。
      </p><p>
        また、<code class="literal">VIEWS</code> テーブルを含む <code class="literal">INFORMATION_SCHEMA</code> からビューオブジェクトに関する情報を取得することもできます。<a class="xref" href="information-schema.html#views-table" title="21.28 INFORMATION_SCHEMA VIEWS テーブル">セクション21.28「INFORMATION_SCHEMA VIEWS テーブル」</a>を参照してください。
      </p><p>
        MySQL では、異なる <code class="literal">sql_mode</code> 設定を使用すると、サポートする SQL 構文のタイプをサーバーに指示できます。たとえば、<code class="literal">ANSI</code> SQL モードを使用すると、クエリーで、MySQL で標準 SQL 連結演算子の二重バー (<code class="literal">||</code>) が正しく解釈されます。その後、項目を連結するビューを作成した場合、<code class="literal">sql_mode</code> 設定を <code class="literal">ANSI</code> とは別の値に変更すると、そのビューが無効になるという懸念がある場合があります。ただし、そのようなことはありません。MySQL は、記述方法には関係なく、常にビュー定義を正規の形式で同じ方法で格納します。サーバーが二重バーの連結演算子を <code class="literal">CONCAT()</code> 関数にどのように変更するかを示す例を次に示します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET sql_mode = 'ANSI';</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>CREATE VIEW test.v AS SELECT 'a' || 'b' as col1;</code></strong>
Query OK, 0 rows affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>SHOW CREATE VIEW test.v\G</code></strong>
*************************** 1. row ***************************
                View: v
         Create View: CREATE VIEW "v" AS select concat('a','b') AS "col1"
...
1 row in set (0.00 sec)
</pre><p>
        ビュー定義を正規の形式で格納する利点は、あとで <code class="literal">sql_mode</code> の値を変更しても、ビューの結果に影響を与えないことにあります。ただし、<code class="literal">SELECT</code> の前にあるコメントが、サーバーによって定義から取り除かれるというその他の影響があります。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-databases"></a>13.7.5.15 SHOW DATABASES 構文</h4></div></div></div><a class="indexterm" name="idm139979077754080"></a><a class="indexterm" name="idm139979077752768"></a><pre class="programlisting">
SHOW {DATABASES | SCHEMAS}
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
        <code class="literal">SHOW DATABASES</code> は、MySQL サーバーホスト上のデータベースを一覧表示します。<code class="literal">SHOW SCHEMAS</code> は <code class="literal">SHOW DATABASES</code> のシノニムです。<code class="literal">LIKE</code> 句 (存在する場合) は、どのデータベース名と照合するかを示します。<a class="xref" href="information-schema.html#extended-show" title="21.32 SHOW ステートメントの拡張">セクション21.32「SHOW ステートメントの拡張」</a>で説明されているように、<code class="literal">WHERE</code> 句を指定すると、より一般的な条件を使用して行を選択できます。
      </p><p>
        グローバルな <code class="literal">SHOW DATABASES</code> 権限を持っていないかぎり、何らかの種類の権限を持っているデータベースしか表示できません。このリストはまた、<span class="command"><strong>mysqlshow</strong></span> コマンドを使用して取得することもできます。
      </p><p>
        サーバーが <code class="option">--skip-show-database</code> オプションで起動された場合は、<code class="literal">SHOW DATABASES</code> 権限を持っていないかぎり、このステートメントをまったく使用できません。
      </p><p>
        MySQL はデータベースをデータディレクトリ内のディレクトリとして実装するため、このステートメントは単純に、その場所にあるディレクトリを一覧表示します。ただし、実際のデータベースには対応しないディレクトリの名前が出力に含まれる可能性があります。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-engine"></a>13.7.5.16 SHOW ENGINE 構文</h4></div></div></div><a class="indexterm" name="idm139979077732864"></a><a class="indexterm" name="idm139979077731552"></a><a class="indexterm" name="idm139979077730176"></a><a class="indexterm" name="idm139979077728832"></a><pre class="programlisting">
SHOW ENGINE <em class="replaceable"><code>engine_name</code></em> {STATUS | MUTEX}
</pre><p>
        <code class="literal">SHOW ENGINE</code> は、ストレージエンジンに関する動作情報を表示します。これには <code class="literal">PROCESS</code> 権限が必要です。このステートメントは、次のバリアントがあります。
      </p><pre class="programlisting">
SHOW ENGINE INNODB STATUS
SHOW ENGINE INNODB MUTEX
SHOW ENGINE {NDB | NDBCLUSTER} STATUS
SHOW ENGINE PERFORMANCE_SCHEMA STATUS
</pre><p>
        <code class="literal">SHOW ENGINE INNODB STATUS</code> は、<code class="literal">InnoDB</code> ストレージエンジンの状態に関する <code class="literal">InnoDB</code> 標準モニターからの広範囲にわたる情報を表示します。<code class="literal">InnoDB</code> の処理に関する情報を提供する標準モニターやその他の <code class="literal">InnoDB</code> モニターについては、<a class="xref" href="innodb-storage-engine.html#innodb-monitors" title="14.15 InnoDB モニター">セクション14.15「InnoDB モニター」</a>を参照してください。
      </p><p>
        <code class="literal">SHOW ENGINE INNODB MUTEX</code> は、<code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_mutex" title="相互排他ロック">相互排他ロック</a>および<a class="link" href="glossary.html#glos_rw_lock" title="rw ロック (読み書きロック)">読み書きロック</a>の統計を表示します。ステートメント出力には、次のカラムがあります。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          ほとんどの <code class="literal">SHOW ENGINE INNODB MUTEX</code> 出力は 5.6.14 で削除されます。<code class="literal">SHOW ENGINE INNODB MUTEX</code> 出力は、MySQL 5.7.2 で完全に削除されます。<a class="link" href="performance-schema.html" title="第 22 章 MySQL パフォーマンススキーマ">パフォーマンススキーマ</a>テーブル上にビューを作成することによって、比較可能な情報を生成できます。
        </p></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Type</code>
          </p><p>
            常に <code class="literal">InnoDB</code> です。
          </p></li><li class="listitem"><p>
            <code class="literal">Name</code>
          </p><p>
            相互排他ロックが実装されているソースファイルと、そのファイル内の相互排他ロックが作成されている行番号。この行番号は、使用している MySQL のバージョンに固有です。
          </p></li><li class="listitem"><p>
            <code class="literal">Status</code>
          </p><p>
            相互排他ロックのステータス。MySQL のコンパイル時に <code class="option">WITH_DEBUG</code> が定義された場合、このフィールドにはいくつかの値が表示されます。<code class="option">WITH_DEBUG</code> が定義されなかった場合、このステートメントは <code class="literal">os_waits</code> 値のみを表示します。後者の (<code class="option">WITH_DEBUG</code> なしの) 場合は、この出力の基になっている情報が通常の相互排他ロックと、読み書きロックを保護する (複数読み取りまたは単一書き込みを許可する) 相互排他ロックを区別するには不足しています。その結果、出力が、同じ相互排他ロックに対して複数の行を含むように見える可能性があります。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">count</code> は、相互排他ロックが要求された回数を示します。
              </p></li><li class="listitem"><p>
                <code class="literal">spin_waits</code> は、スピンロックの実行が必要になった回数を示します。
              </p></li><li class="listitem"><p>
                <code class="literal">spin_rounds</code> は、スピンロックラウンドの数を示します。(<code class="literal">spin_rounds</code> を <code class="literal">spin_waits</code> で割ると、平均のラウンド数が得られます。) 
              </p></li><li class="listitem"><p>
                <code class="literal">os_waits</code> は、オペレーティングシステムの待機の数を示します。これは、スピンロックが機能しなかった (スピンロック中に相互排他ロックがロックされず、オペレーティングシステムに譲って待機する必要があった) 場合に発生します。
              </p></li><li class="listitem"><p>
                <code class="literal">os_yields</code> は、相互排他ロックをロックしようとしているスレッドがそのタイムスライスをあきらめ、オペレーティングシステムに譲った回数を示します (ほかのスレッドの実行を許可すると、相互排他ロックが解放され、ロックできるようになることを前提にしています)。
              </p></li><li class="listitem"><p>
                <code class="literal">os_wait_times</code> は、オペレーティングシステムの待機に費やされた時間 (ミリ秒単位) を示します。MySQL 5.6 ではタイミングが無効になるため、この値は常に 0 です。
              </p></li></ul></div></li></ul></div><p>
        大きなバッファープールでは出力の量がシステム上で膨大になる場合があるため、<code class="literal">SHOW ENGINE INNODB MUTEX</code> は、<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>ブロックの<a class="link" href="glossary.html#glos_mutex" title="相互排他ロック">相互排他ロック</a>と<a class="link" href="glossary.html#glos_rw_lock" title="rw ロック (読み書きロック)">読み書きロック</a>をスキップします。(各 16K バッファープールブロック内に 1 つの相互排他ロックと 1 つの読み書きロックが存在し、1G バイトあたり 65,536 個のブロックが存在します。) <code class="literal">SHOW ENGINE INNODB MUTEX</code> はまた、待機されなかった (<code class="literal">os_waits=0</code>) 相互排他ロックまたは読み書きロックも一覧表示しません。そのため、<code class="literal">SHOW ENGINE INNODB MUTEX</code> は、OS レベルの<a class="link" href="glossary.html#glos_wait" title="待機">待機</a>を少なくとも 1 回は発生させた、バッファープールの外部の相互排他ロックと読み書きロックに関する情報のみを表示します。
      </p><p>
        <code class="literal">SHOW ENGINE INNODB MUTEX</code> の情報を使用すると、システムの問題を診断できます。たとえば、<code class="literal">spin_waits</code> や <code class="literal">spin_rounds</code> の値が大きい場合は、スケーラビリティーの問題を示している可能性があります。
      </p><p>
        <code class="literal">SHOW ENGINE PERFORMANCE_SCHEMA STATUS</code> を使用して、パフォーマンススキーマコードの内部操作を検査します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW ENGINE PERFORMANCE_SCHEMA STATUS\G</code></strong>
...
*************************** 3. row ***************************
  Type: performance_schema
  Name: events_waits_history.row_size
Status: 76
*************************** 4. row ***************************
  Type: performance_schema
  Name: events_waits_history.row_count
Status: 10000
*************************** 5. row ***************************
  Type: performance_schema
  Name: events_waits_history.memory
Status: 760000
...
*************************** 57. row ***************************
  Type: performance_schema
  Name: performance_schema.memory
Status: 26459600
...
</pre><p>
        このステートメントは、さまざまなパフォーマンススキーマオプションがメモリー要件に与える効果について、DBA が理解できるようにすることを目的としています。
      </p><p>
        <code class="literal">Name</code> 値は、それぞれ、内部バッファーとバッファー属性を指定する 2 つの部分で構成されます。バッファー名は、次のように解釈します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            テーブルとして公開されていない内部バッファーは括弧内に指定されます。例: <code class="literal">(pfs_cond_class).row_size</code>、<code class="literal">(pfs_mutex_class).memory</code>。
          </p></li><li class="listitem"><p>
            <code class="literal">performance_schema</code> データベース内のテーブルとして公開されている内部バッファーは、そのテーブル名で (括弧なしで) 指定されます。例: <code class="literal">events_waits_history.row_size</code>、<code class="literal">mutex_instances.row_count</code>。
          </p></li><li class="listitem"><p>
            全体としてのパフォーマンススキーマに適用される値は、<code class="literal">performance_schema</code> で始まります。例: <code class="literal">performance_schema.memory</code>。
          </p></li></ul></div><p>
        バッファー属性には、次の意味があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">row_size</code> は、実装によって使用される内部レコードのサイズ (テーブル内の行のサイズなど) です。<code class="literal">row_size</code> 値は変更できません。
          </p></li><li class="listitem"><p>
            <code class="literal">row_count</code> は、内部レコードの数 (テーブル内の行数など) です。<code class="literal">row_count</code> 値は、パフォーマンススキーマの構成オプションを使用して変更できます。
          </p></li><li class="listitem"><p>
            テーブルの場合、<code class="literal"><em class="replaceable"><code>tbl_name</code></em>.memory</code> は <code class="literal">row_size</code> と <code class="literal">row_count</code> の積です。全体としてのパフォーマンススキーマの場合、<code class="literal">performance_schema.memory</code> は、使用されているすべてのメモリーの合計 (ほかのすべての <code class="literal">memory</code> 値の合計) です。
          </p></li></ul></div><p>
        場合によっては、パフォーマンススキーマの構成パラメータと <code class="literal">SHOW ENGINE</code> 値の間に直接の関係が存在します。たとえば、<code class="literal">events_waits_history_long.row_count</code> は <code class="literal">performance_schema_events_waits_history_long_size</code> に対応します。その他の場合、この関係はより複雑です。たとえば、<code class="literal">events_waits_history.row_count</code> は、<code class="literal">performance_schema_events_waits_history_size</code> (スレッドあたりの行数) に <code class="literal">performance_schema_max_thread_instances</code> (スレッドの数) を掛けた値に対応します。
      </p><p><a name="show-engine-ndb-status"></a><b>SHOW ENGINE NDB STATUS </b>
          サーバーで <code class="literal">NDB</code> ストレージエンジンが有効になっている場合、<code class="literal">SHOW ENGINE NDB STATUS</code> は、接続されているデータノードの数、クラスタの接続文字列、クラスタバイナリログのエポックや、クラスタに接続したときに MySQL Server によって作成されたさまざまなクラスタ API オブジェクトの数などのクラスタステータス情報を表示します。このステートメントからのサンプル出力を次に示します。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW ENGINE NDB STATUS;</code></strong>
+------------+-----------------------+--------------------------------------------------+
| Type       | Name                  | Status                                           |
+------------+-----------------------+--------------------------------------------------+
| ndbcluster | connection            | cluster_node_id=7,
  connected_host=192.168.0.103, connected_port=1186, number_of_data_nodes=4,
  number_of_ready_data_nodes=3, connect_count=0                                         |
| ndbcluster | NdbTransaction        | created=6, free=0, sizeof=212                    |
| ndbcluster | NdbOperation          | created=8, free=8, sizeof=660                    |
| ndbcluster | NdbIndexScanOperation | created=1, free=1, sizeof=744                    |
| ndbcluster | NdbIndexOperation     | created=0, free=0, sizeof=664                    |
| ndbcluster | NdbRecAttr            | created=1285, free=1285, sizeof=60               |
| ndbcluster | NdbApiSignal          | created=16, free=16, sizeof=136                  |
| ndbcluster | NdbLabel              | created=0, free=0, sizeof=196                    |
| ndbcluster | NdbBranch             | created=0, free=0, sizeof=24                     |
| ndbcluster | NdbSubroutine         | created=0, free=0, sizeof=68                     |
| ndbcluster | NdbCall               | created=0, free=0, sizeof=16                     |
| ndbcluster | NdbBlob               | created=1, free=1, sizeof=264                    |
| ndbcluster | NdbReceiver           | created=4, free=0, sizeof=68                     |
| ndbcluster | binlog                | latest_epoch=155467, latest_trans_epoch=148126,
  latest_received_binlog_epoch=0, latest_handled_binlog_epoch=0,
  latest_applied_binlog_epoch=0                                                         |
+------------+-----------------------+--------------------------------------------------+
</pre><p>
        <code class="literal">Name</code> カラム内に <code class="literal">connection</code> と <code class="literal">binlog</code> を含む行は、MySQL 5.1 でこのステートメントの出力に追加されました。これらの各行内の <code class="literal">Status</code> カラムは、それぞれ、MySQL サーバーのクラスタへの接続に関する情報と、クラスタバイナリログのステータスに関する情報を提供します。<code class="literal">Status</code> 情報は、カンマで区切られた一連の名前と値のペアの形式をしています。
      </p><p>
        <code class="literal">connection</code> 行の <code class="literal">Status</code> カラムには、次の表で説明されている名前と値のペアが含まれています。
      </p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">名前</th><th scope="col">値</th></tr></thead><tbody><tr><td scope="row"><code class="literal">cluster_node_id</code></td><td>クラスタ内の MySQL サーバーのノード ID</td></tr><tr><td scope="row"><code class="literal">connected_host</code></td><td>MySQL サーバーが接続されているクラスタ管理サーバーのホスト名または IP アドレス</td></tr><tr><td scope="row"><code class="literal">connected_port</code></td><td>MySQL サーバーが管理サーバー (<code class="literal">connected_host</code>) に接続するために使用するポート</td></tr><tr><td scope="row"><code class="literal">number_of_data_nodes</code></td><td>クラスタのために構成されているデータノードの数 (つまり、そのクラスタの <code class="filename">config.ini</code> ファイル内の <code class="literal">[ndbd]</code> セクションの数)</td></tr><tr><td scope="row"><code class="literal">number_of_ready_data_nodes</code></td><td>実際に実行されているクラスタ内のデータノードの数</td></tr><tr><td scope="row"><code class="literal">connect_count</code></td><td>この <span class="command"><strong>mysqld</strong></span> がクラスタデータノードに接続または再接続した回数</td></tr></tbody></table></div><p>
        <code class="literal">binlog</code> 行の <code class="literal">Status</code> カラムには、MySQL Cluster レプリケーションに関連した情報が含まれています。そこに含まれている名前と値のペアについて、次の表で説明します。
      </p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">名前</th><th scope="col">値</th></tr></thead><tbody><tr><td scope="row"><code class="literal">latest_epoch</code></td><td>この MySQL サーバー上で直近で実行された最新のエポック (つまり、このサーバー上で実行された最新のトランザクションのシーケンス番号)</td></tr><tr><td scope="row"><code class="literal">latest_trans_epoch</code></td><td>クラスタのデータノードによって処理された最新のエポック</td></tr><tr><td scope="row"><code class="literal">latest_received_binlog_epoch</code></td><td>バイナリログスレッドによって受信された最新のエポック</td></tr><tr><td scope="row"><code class="literal">latest_handled_binlog_epoch</code></td><td>(バイナリログへの書き込みのために) バイナリログスレッドによって処理された最新のエポック</td></tr><tr><td scope="row"><code class="literal">latest_applied_binlog_epoch</code></td><td>実際にバイナリログに書き込まれた最新のエポック</td></tr></tbody></table></div><p>
        詳細は、<a class="xref" href="mysql-cluster.html#mysql-cluster-replication" title="18.6 MySQL Cluster レプリケーション">セクション18.6「MySQL Cluster レプリケーション」</a>を参照してください。
      </p><p>
        クラスタのモニタリングにもっとも役立つ可能性のある <code class="literal">SHOW ENGINE NDB STATUS</code> の出力の残りの行を、次に <code class="literal">Name</code> で一覧表示します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">NdbTransaction</code>: 作成された <code class="literal">NdbTransaction</code> オブジェクトの数とサイズ。<code class="literal">NdbTransaction</code> は、<code class="literal">NDB</code> テーブル上で (<code class="literal">CREATE TABLE</code> や <code class="literal">ALTER TABLE</code> などの) テーブルスキーマ操作が実行されるたびに作成されます。
          </p></li><li class="listitem"><p>
            <code class="literal">NdbOperation</code>: 作成された <code class="literal">NdbOperation</code> オブジェクトの数とサイズ。
          </p></li><li class="listitem"><p>
            <code class="literal">NdbIndexScanOperation</code>: 作成された <code class="literal">NdbIndexScanOperation</code> オブジェクトの数とサイズ。
          </p></li><li class="listitem"><p>
            <code class="literal">NdbIndexOperation</code>: 作成された <code class="literal">NdbIndexOperation</code> オブジェクトの数とサイズ。
          </p></li><li class="listitem"><p>
            <code class="literal">NdbRecAttr</code>: 作成された <code class="literal">NdbRecAttr</code> オブジェクトの数とサイズ。一般に、これらのいずれかは、SQL ノードによってデータ操作ステートメントが実行されるたびに作成されます。
          </p></li><li class="listitem"><p>
            <code class="literal">NdbBlob</code>: 作成された <code class="literal">NdbBlob</code> オブジェクトの数とサイズ。<code class="literal">NdbBlob</code> は、<code class="literal">NDB</code> テーブル内の <code class="literal">BLOB</code> カラムに関連する新しい操作が実行されるたびに作成されます。
          </p></li><li class="listitem"><p>
            <code class="literal">NdbReceiver</code>: 作成されたすべての <code class="literal">NdbReceiver</code> オブジェクトの数とサイズ。<code class="literal">created</code> カラム内の数は、MySQL サーバーが接続されているクラスタ内のデータノードの数と同じです。
          </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          現在のセッション中に、このステートメントが実行されている SQL ノードにアクセスしている MySQL クライアントによって <code class="literal">NDB</code> テーブルに関連する操作が実行されていない場合、<code class="literal">SHOW ENGINE NDB STATUS</code> は空の結果を返します。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-engines"></a>13.7.5.17 SHOW ENGINES 構文</h4></div></div></div><a class="indexterm" name="idm139979077557760"></a><a class="indexterm" name="idm139979077556448"></a><pre class="programlisting">
SHOW [STORAGE] ENGINES
</pre><p>
        <code class="literal">SHOW ENGINES</code> は、サーバーのストレージエンジンに関するステータス情報を表示します。これは、ストレージエンジンがサポートされているかどうかをチェックしたり、デフォルトのエンジンが何であるかを確認したりするために特に役立ちます。この情報はまた、<code class="literal">INFORMATION_SCHEMA</code> <code class="literal">ENGINES</code> テーブルからも取得できます。<a class="xref" href="information-schema.html#engines-table" title="21.6 INFORMATION_SCHEMA ENGINES テーブル">セクション21.6「INFORMATION_SCHEMA ENGINES テーブル」</a>を参照してください。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW ENGINES\G</code></strong>
*************************** 1. row ***************************
      Engine: MEMORY
     Support: YES
     Comment: Hash based, stored in memory, useful for temporary tables
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 2. row ***************************
      Engine: MyISAM
     Support: YES
     Comment: MyISAM storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 3. row ***************************
      Engine: InnoDB
     Support: DEFAULT
     Comment: Supports transactions, row-level locking, and foreign keys
Transactions: YES
          XA: YES
  Savepoints: YES
*************************** 4. row ***************************
      Engine: EXAMPLE
     Support: YES
     Comment: Example storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 5. row ***************************
      Engine: ARCHIVE
     Support: YES
     Comment: Archive storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 6. row ***************************
      Engine: CSV
     Support: YES
     Comment: CSV storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 7. row ***************************
      Engine: BLACKHOLE
     Support: YES
     Comment: /dev/null storage engine (anything you write »
              to it disappears)
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 8. row ***************************
      Engine: FEDERATED
     Support: YES
     Comment: Federated MySQL storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 9. row ***************************
      Engine: MRG_MYISAM
     Support: YES
     Comment: Collection of identical MyISAM tables
Transactions: NO
          XA: NO
  Savepoints: NO
</pre><p>
        <code class="literal">SHOW ENGINES</code> からの出力は、使用されている MySQL バージョンやその他の要因によって異なる可能性があります。<code class="literal">Support</code> カラムに表示されている値は、次の表に示す、ストレージエンジンに対するサーバーのサポートのレベルを示します。
      </p><div class="informaltable"><table summary="この表は、SHOW ENGINES コマンドの出力内の Support カラムの値について説明しています。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">値</th><th scope="col">意味</th></tr></thead><tbody><tr><td scope="row"><code class="literal">YES</code></td><td>このエンジンはサポートされており、アクティブです</td></tr><tr><td scope="row"><code class="literal">DEFAULT</code></td><td><code class="literal">YES</code> と同様であることに加え、これがデフォルトのエンジンです</td></tr><tr><td scope="row"><code class="literal">NO</code></td><td>このエンジンはサポートされていません</td></tr><tr><td scope="row"><code class="literal">DISABLED</code></td><td>このエンジンはサポートされていますが、無効になっています</td></tr></tbody></table></div><p>
        <code class="literal">NO</code> の値は、サーバーがこのエンジンに対するサポートなしでコンパイルされたことを示すため、実行時にこのエンジンを有効にすることはできません。
      </p><p>
        <code class="literal">DISABLED</code> の値は、サーバーがこのエンジンを無効にするオプションを使用して起動されたか、またはこのエンジンを有効にするために必要な一部のオプションが指定されなかったために発生します。後者の場合は、このオプションがなぜ無効になっているかを示す理由がエラーログファイルに含まれているはずです。<a class="xref" href="server-administration.html#error-log" title="5.2.2 エラーログ">セクション5.2.2「エラーログ」</a> を参照してください。
      </p><p>
        ストレージエンジンに対する <code class="literal">DISABLED</code> はまた、サーバーがそれをサポートするようにコンパイルされたが、<code class="option">--skip-<em class="replaceable"><code>engine_name</code></em></code> オプションで起動された場合にも表示される可能性があります。<code class="literal">NDB</code> ストレージエンジンの場合、<code class="literal">DISABLED</code> は、サーバーが MySQL Cluster に対するサポート付きでコンパイルされたが、<code class="option">--ndbcluster</code> オプションで起動されなかったことを示します。
      </p><p>
        <code class="literal">MyISAM</code> はデフォルトのストレージエンジンであるため、すべての MySQL サーバーが <code class="literal">MyISAM</code> テーブルをサポートします。<code class="literal">MyISAM</code> を無効にすることはできません。
      </p><p>
        <code class="literal">Transactions</code>、<code class="literal">XA</code>、および <code class="literal">Savepoints</code> カラムは、それぞれ、このストレージエンジンがトランザクション、XA トランザクション、およびセーブポイントをサポートするかどうかを示します。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-errors"></a>13.7.5.18 SHOW ERRORS 構文</h4></div></div></div><a class="indexterm" name="idm139979077509568"></a><a class="indexterm" name="idm139979077508256"></a><pre class="programlisting">
SHOW ERRORS [LIMIT [<em class="replaceable"><code>offset</code></em>,] <em class="replaceable"><code>row_count</code></em>]
SHOW COUNT(*) ERRORS
</pre><p>
        <code class="literal">SHOW ERRORS</code> は <code class="literal">SHOW WARNINGS</code> に似た診断ステートメントですが、エラー、警告、および注意ではなく、エラーに関する情報のみを表示する点が異なります。
      </p><p>
        <code class="literal">LIMIT</code> 句の構文は、<code class="literal">SELECT</code> ステートメントの場合と同じです。<a class="xref" href="sql-syntax.html#select" title="13.2.9 SELECT 構文">セクション13.2.9「SELECT 構文」</a>を参照してください。
      </p><p>
        <code class="literal">SHOW COUNT(*) ERRORS</code> ステートメントは、エラーの数を表示します。この数はまた、<code class="literal">error_count</code> 変数からも取得できます。
      </p><pre class="programlisting">
SHOW COUNT(*) ERRORS;
SELECT @@error_count;
</pre><p>
        <code class="literal">SHOW ERRORS</code> および <code class="literal">error_count</code> は、警告や注意ではなく、エラーにのみ適用されます。その他の点では、<code class="literal">SHOW WARNINGS</code> および <code class="literal">warning_count</code> と同様です。特に、<code class="literal">SHOW ERRORS</code> が <code class="literal">max_error_count</code> 個を超えるメッセージに関する情報を表示できないのに対して、<code class="literal">error_count</code> は、エラーの数が <code class="literal">max_error_count</code> を超えた場合は <code class="literal">max_error_count</code> の値を超えることができます。
      </p><p>
        詳細は、<a class="xref" href="sql-syntax.html#show-warnings" title="13.7.5.41 SHOW WARNINGS 構文">セクション13.7.5.41「SHOW WARNINGS 構文」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-events"></a>13.7.5.19 SHOW EVENTS 構文</h4></div></div></div><a class="indexterm" name="idm139979077480816"></a><pre class="programlisting">
SHOW EVENTS [{FROM | IN} <em class="replaceable"><code>schema_name</code></em>]
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
        このステートメントは、イベントマネージャーのイベントに関する情報を表示します。これには、これらのイベントが示される元のデータベースに対する <code class="literal">EVENT</code> 権限が必要です。
      </p><p>
        <code class="literal">SHOW EVENTS</code> は、そのもっとも単純な形式では、現在のスキーマ内のすべてのイベントを一覧表示します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT CURRENT_USER(), SCHEMA();</code></strong>
+----------------+----------+
| CURRENT_USER() | SCHEMA() |
+----------------+----------+
| jon@ghidora    | myschema |
+----------------+----------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW EVENTS\G</code></strong>
*************************** 1. row ***************************
                  Db: myschema
                Name: e_daily
             Definer: jon@ghidora
           Time zone: SYSTEM
                Type: RECURRING
          Execute at: NULL
      Interval value: 10
      Interval field: SECOND
              Starts: 2006-02-09 10:41:23
                Ends: NULL
              Status: ENABLED
          Originator: 0
character_set_client: latin1
collation_connection: latin1_swedish_ci
  Database Collation: latin1_swedish_ci
</pre><p>
        特定のスキーマのイベントを表示するには、<code class="literal">FROM</code> 句を使用します。たとえば、<code class="literal">test</code> スキーマのイベントを表示するには、次のステートメントを使用します。
      </p><pre class="programlisting">
SHOW EVENTS FROM test;
</pre><p>
        <code class="literal">LIKE</code> 句 (存在する場合) は、どのイベント名と照合するかを示します。<a class="xref" href="information-schema.html#extended-show" title="21.32 SHOW ステートメントの拡張">セクション21.32「SHOW ステートメントの拡張」</a>で説明されているように、<code class="literal">WHERE</code> 句を指定すると、より一般的な条件を使用して行を選択できます。
      </p><p>
        <code class="literal">SHOW EVENTS</code> の出力には、次のカラムがあります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Db</code>: このイベントが定義されているスキーマ (データベース)。
          </p></li><li class="listitem"><p>
            <code class="literal">Name</code>: このイベントの名前。
          </p></li><li class="listitem"><p>
            <code class="literal">Time zone</code>: このイベントのタイムゾーン。これは、イベントのスケジューリングに使用され、イベントが実行されるとそのイベント内で有効になるタイムゾーンです。デフォルト値は <code class="literal">SYSTEM</code> です。
          </p></li><li class="listitem"><p>
            <code class="literal">Definer</code>: このイベントを作成したユーザーのアカウント。形式は <code class="literal">'<em class="replaceable"><code>user_name</code></em>'@'<em class="replaceable"><code>host_name</code></em>'</code> です。
          </p></li><li class="listitem"><p>
            <code class="literal">Type</code>: このイベントの繰り返しのタイプ。<code class="literal">ONE TIME</code> (一時的) または <code class="literal">RECURRING</code> (繰り返し) のどちらかです。
          </p></li><li class="listitem"><p>
            <code class="literal">Execute At</code>: 一時的なイベントの実行が設定されている日付と時間。<code class="literal">DATETIME</code> 値として示されます。
          </p><p>
            繰り返しのイベントの場合、このカラムの値は常に <code class="literal">NULL</code> です。
          </p></li><li class="listitem"><p>
            <code class="literal">Interval Value</code>: 繰り返しのイベントの場合は、イベント実行の間で待機する間隔の数。
          </p><p>
            一時的なイベントの場合、このカラムの値は常に <code class="literal">NULL</code> です。
          </p></li><li class="listitem"><p>
            <code class="literal">Interval Field</code>: 繰り返しのイベントが繰り返しの前に待機する間隔に使用される時間単位。
          </p><p>
            一時的なイベントの場合、このカラムの値は常に <code class="literal">NULL</code> です。
          </p></li><li class="listitem"><p>
            <code class="literal">Starts</code>: 繰り返しのイベントの開始日付と開始時間。これは <code class="literal">DATETIME</code> 値として表示され、このイベントの開始日付と開始時間が定義されていない場合は <code class="literal">NULL</code> です。
          </p><p>
            一時的なイベントの場合、このカラムは常に <code class="literal">NULL</code> です。
          </p></li><li class="listitem"><p>
            <code class="literal">Ends</code>: 繰り返しのイベントの終了日付と終了時間。これは <code class="literal">DATETIME</code> 値として表示され、このイベントの終了日付と終了時間が定義されていない場合は、デフォルトで <code class="literal">NULL</code> になります。
          </p><p>
            一時的なイベントの場合、このカラムは常に <code class="literal">NULL</code> です。
          </p></li><li class="listitem"><p>
            <code class="literal">Status</code>: このイベントのステータス。<code class="literal">ENABLED</code>、<code class="literal">DISABLED</code>、<code class="literal">SLAVESIDE_DISABLED</code> のいずれか。
          </p><p>
            <code class="literal">SLAVESIDE_DISABLED</code> は、イベントの作成が、レプリケーションマスターとして機能している別の MySQL サーバーで発生し、スレーブとして機能している現在の MySQL サーバーにレプリケートされたが、スレーブでは現在そのイベントが実行されていないことを示します。
          </p></li><li class="listitem"><p>
            <code class="literal">Originator</code>: このイベントが作成された MySQL サーバーのサーバー ID。デフォルトで 0 になります。
          </p></li><li class="listitem"><p>
            <code class="literal">character_set_client</code> は、このルーチンが作成されたときの <code class="literal">character_set_client</code> システム変数のセッション値です。<code class="literal">collation_connection</code> は、このルーチンが作成されたときの <code class="literal">collation_connection</code> システム変数のセッション値です。<code class="literal">Database Collation</code> は、このルーチンが関連付けられているデータベースの照合順序です。
          </p></li></ul></div><p>
        <code class="literal">SLAVE_DISABLED</code> および <code class="literal">Originator</code> カラムの詳細は、<a class="xref" href="replication.html#replication-features-invoked" title="17.4.1.11 呼び出される機能のレプリケーション">セクション17.4.1.11「呼び出される機能のレプリケーション」</a>を参照してください。
      </p><p>
        イベントのアクションステートメントは、<code class="literal">SHOW EVENTS</code> の出力には表示されません。<code class="literal">SHOW CREATE EVENT</code> または <code class="literal">INFORMATION_SCHEMA.EVENTS</code> テーブルを使用してください。
      </p><p>
        <code class="literal">SHOW EVENTS</code> によって表示される時間は、<a class="xref" href="stored-programs-views.html#events-metadata" title="20.4.4 イベントメタデータ">セクション20.4.4「イベントメタデータ」</a>で説明されているように、このイベントのタイムゾーンで示されます。
      </p><p>
        <code class="literal">SHOW EVENTS</code> の出力内のカラムは、<code class="literal">INFORMATION_SCHEMA.EVENTS</code> テーブル内のカラムに似ていますが、同じではありません。<a class="xref" href="information-schema.html#events-table" title="21.7 INFORMATION_SCHEMA EVENTS テーブル">セクション21.7「INFORMATION_SCHEMA EVENTS テーブル」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-function-code"></a>13.7.5.20 SHOW FUNCTION CODE 構文</h4></div></div></div><a class="indexterm" name="idm139979077402400"></a><pre class="programlisting">
SHOW FUNCTION CODE <em class="replaceable"><code>func_name</code></em>
</pre><p>
        このステートメントは、ストアドファンクションである点を除き、<code class="literal">SHOW PROCEDURE CODE</code> と同じです。<a class="xref" href="sql-syntax.html#show-procedure-code" title="13.7.5.28 SHOW PROCEDURE CODE 構文">セクション13.7.5.28「SHOW PROCEDURE CODE 構文」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-function-status"></a>13.7.5.21 SHOW FUNCTION STATUS 構文</h4></div></div></div><a class="indexterm" name="idm139979077393152"></a><pre class="programlisting">
SHOW FUNCTION STATUS
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
        このステートメントは、ストアドファンクションである点を除き、<code class="literal">SHOW PROCEDURE STATUS</code> と同じです。<a class="xref" href="sql-syntax.html#show-procedure-status" title="13.7.5.29 SHOW PROCEDURE STATUS 構文">セクション13.7.5.29「SHOW PROCEDURE STATUS 構文」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-grants"></a>13.7.5.22 SHOW GRANTS 構文</h4></div></div></div><a class="indexterm" name="idm139979077383488"></a><a class="indexterm" name="idm139979077381376"></a><a class="indexterm" name="idm139979077380144"></a><pre class="programlisting">
SHOW GRANTS [FOR <em class="replaceable"><code>user</code></em>]
</pre><p>
        このステートメントは、MySQL ユーザーアカウントに付与される権限を複製するために発行する必要のある 1 つまたは複数の <code class="literal">GRANT</code> ステートメントを一覧表示します。このアカウントは、<code class="literal">GRANT</code> ステートメントの場合と同じ形式 (<code class="literal">'jeffrey'@'localhost'</code> など) を使用して指定されます。アカウント名のユーザー名の部分のみを指定した場合は、<code class="literal">'%'</code> のホスト名の部分が使用されます。アカウント名の指定の詳細は、<a class="xref" href="sql-syntax.html#grant" title="13.7.1.4 GRANT 構文">セクション13.7.1.4「GRANT 構文」</a>を参照してください。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW GRANTS FOR 'root'@'localhost';</code></strong>
+---------------------------------------------------------------------+
| Grants for root@localhost                                           |
+---------------------------------------------------------------------+
| GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' WITH GRANT OPTION |
+---------------------------------------------------------------------+
</pre><p>
        サーバーに接続するために使用しているアカウントに付与される権限を一覧表示するには、次のいずれのステートメントでも使用できます。
      </p><pre class="programlisting">
SHOW GRANTS;
SHOW GRANTS FOR CURRENT_USER;
SHOW GRANTS FOR CURRENT_USER();
</pre><p>
        <code class="literal">SHOW GRANTS FOR CURRENT_USER</code> (または、いずれかの同等の構文) が <code class="literal">DEFINER</code> コンテキスト (<code class="literal">SQL SECURITY DEFINER</code> で定義されているストアドプロシージャー内など) で使用されている場合、表示される付与権限は呼び出し元ではなく、定義者のものです。
      </p><p>
        <code class="literal">SHOW GRANTS</code> は、指定されたアカウントに明示的に付与される権限のみを表示します。そのアカウントでほかの権限を使用できる可能性もありますが、それらは表示されません。たとえば、匿名アカウントが存在する場合、指定されたアカウントはその権限を使用できる可能性がありますが、<code class="literal">SHOW GRANTS</code> はそれらを表示しません。
      </p><p>
        <code class="literal">SHOW GRANTS</code> には、<code class="literal">mysql</code> データベースに対する <code class="literal">SELECT</code> 権限 (現在のユーザーの権限の表示を除く) が必要です。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-index"></a>13.7.5.23 SHOW INDEX 構文</h4></div></div></div><a class="indexterm" name="idm139979077355152"></a><a class="indexterm" name="idm139979077351792"></a><a class="indexterm" name="idm139979077350448"></a><pre class="programlisting">
SHOW {INDEX | INDEXES | KEYS}
    {FROM | IN} <em class="replaceable"><code>tbl_name</code></em>
    [{FROM | IN} <em class="replaceable"><code>db_name</code></em>]
    [WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
        <code class="literal">SHOW INDEX</code> は、テーブルインデックス情報を返します。この形式は、ODBC での <code class="literal">SQLStatistics</code> 呼び出しの形式に似ています。このステートメントには、このテーブル内のいずれかのカラムに対する何らかの権限が必要です。
      </p><p>
        <code class="literal">SHOW INDEX</code> は、次のフィールドを返します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Table</code>
          </p><p>
            テーブルの名前。
          </p></li><li class="listitem"><p>
            <code class="literal">Non_unique</code>
          </p><p>
            このインデックスが重複を含むことができない場合は 0、できる場合は 1。
          </p></li><li class="listitem"><p>
            <code class="literal">Key_name</code>
          </p><p>
            インデックスの名前。このインデックスが主キーである場合、その名前は常に <code class="literal">PRIMARY</code> です。
          </p></li><li class="listitem"><p>
            <code class="literal">Seq_in_index</code>
          </p><p>
            インデックス内のカラムシーケンス番号であり、1 から始まります。
          </p></li><li class="listitem"><p>
            <code class="literal">Column_name</code>
          </p><p>
            カラム名。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979077328192"></a> <code class="literal">Collation</code>
          </p><p>
            インデックス内でのカラムのソート方法。MySQL では、これは<span class="quote">「<span class="quote"><code class="literal">A</code></span>」</span>(昇順) または<code class="literal">NULL</code>(ソートされない) のどちらかの値です。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979077321744"></a> <a class="indexterm" name="idm139979077318880"></a> <code class="literal">Cardinality</code>
          </p><p>
            このインデックス内の一意の値の数の推定値。これは、<code class="literal">ANALYZE TABLE</code> または <span class="command"><strong>myisamchk -a</strong></span> を実行することによって更新されます。<code class="literal">Cardinality</code> は整数として格納された統計に基づいてカウントされるため、この値は、小さなテーブルの場合でも必ずしも正確であるとはかぎりません。カーディナリティーが高いほど、MySQL が結合を実行するときにこのインデックスを使用する可能性は高くなります。
          </p></li><li class="listitem"><p>
            <code class="literal">Sub_part</code>
          </p><p>
            カラムが部分的にしかインデックス設定されていない場合は、インデックス設定された文字の数。カラム全体がインデックス設定されている場合は <code class="literal">NULL</code>。
          </p></li><li class="listitem"><p>
            <code class="literal">Packed</code>
          </p><p>
            キーがパックされる方法を示します。パックされない場合は <code class="literal">NULL</code>。
          </p></li><li class="listitem"><p>
            <code class="literal">Null</code>
          </p><p>
            このカラムに <code class="literal">NULL</code> 値を含めることができる場合は <code class="literal">YES</code> が、できない場合は <code class="literal">''</code> が含まれます。
          </p></li><li class="listitem"><p>
            <code class="literal">Index_type</code>
          </p><p>
            使用されるインデックス方法 (<code class="literal">BTREE</code>、<code class="literal">FULLTEXT</code>、<code class="literal">HASH</code>、<code class="literal">RTREE</code>)。
          </p></li><li class="listitem"><p>
            <code class="literal">Comment</code>
          </p><p>
            各カラムで説明されていないこのインデックスに関する情報 (このインデックスが無効になっている場合の <code class="literal">disabled</code> など)。
          </p></li><li class="listitem"><p>
            <code class="literal">Index_comment</code>
          </p><p>
            このインデックスが作成されたときに <code class="literal">COMMENT</code> 属性でインデックスに対して提供された任意のコメント。
          </p></li></ul></div><p>
        <code class="literal"><em class="replaceable"><code>tbl_name</code></em> FROM <em class="replaceable"><code>db_name</code></em></code> 構文の代わりに <em class="replaceable"><code>db_name</code></em>.<em class="replaceable"><code>tbl_name</code></em> を使用できます。次の 2 つのステートメントは同等です。
      </p><pre class="programlisting">
SHOW INDEX FROM mytable FROM mydb;
SHOW INDEX FROM mydb.mytable;
</pre><p>
        <a class="xref" href="information-schema.html#extended-show" title="21.32 SHOW ステートメントの拡張">セクション21.32「SHOW ステートメントの拡張」</a>で説明されているように、<code class="literal">WHERE</code> 句を指定すると、より一般的な条件を使用して行を選択できます。
      </p><p>
        また、<span class="command"><strong>mysqlshow -k <em class="replaceable"><code>db_name</code></em> <em class="replaceable"><code>tbl_name</code></em></strong></span> コマンドを使用してテーブルのインデックスを一覧表示することもできます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-master-status"></a>13.7.5.24 SHOW MASTER STATUS 構文</h4></div></div></div><a class="indexterm" name="idm139979077281696"></a><pre class="programlisting">
SHOW MASTER STATUS
</pre><p>
        このステートメントは、マスターのバイナリログファイルに関するステータス情報を提供します。これには、<code class="literal">SUPER</code> または <code class="literal">REPLICATION CLIENT</code> 権限のどちらかが必要です。
      </p><p>
        例:
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW MASTER STATUS\G</code></strong>
*************************** 1. row ***************************
             File: master-bin.000002
         Position: 1307
     Binlog_Do_DB: test
 Binlog_Ignore_DB: manual, mysql
Executed_Gtid_Set: 3E11FA47-71CA-11E1-9E33-C80AA9429562:1-5
1 row in set (0.00 sec)
</pre><p>
        <code class="literal">Executed_Gtid_Set</code> カラムは、MySQL 5.6.5 で追加されました。グローバルトランザクション ID が使用されている場合、このカラムは、マスター上で実行されたトランザクションの GTID のセットを表示します。これは、このサーバー上の <code class="literal">gtid_executed</code> システム変数 (MySQL 5.6.9 より前の名前は <code class="literal">gtid_done</code>) の値や、このサーバー上での <code class="literal">SHOW SLAVE STATUS</code> の出力内の <code class="literal">Executed_Gtid_Set</code> の値と同じです。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-open-tables"></a>13.7.5.25 SHOW OPEN TABLES 構文</h4></div></div></div><a class="indexterm" name="idm139979077264848"></a><a class="indexterm" name="idm139979077261488"></a><pre class="programlisting">
SHOW OPEN TABLES [{FROM | IN} <em class="replaceable"><code>db_name</code></em>]
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
        <code class="literal">SHOW OPEN TABLES</code> は、現在テーブルキャッシュ内で開いている <code class="literal">TEMPORARY</code> 以外のテーブルを一覧表示します。<a class="xref" href="optimization.html#table-cache" title="8.4.3.1 MySQL でのテーブルのオープンとクローズの方法">セクション8.4.3.1「MySQL でのテーブルのオープンとクローズの方法」</a>を参照してください。<code class="literal">FROM</code> 句 (存在する場合) は、表示されるテーブルを <em class="replaceable"><code>db_name</code></em> データベース内に存在するテーブルに制限します。<code class="literal">LIKE</code> 句 (存在する場合) は、どのテーブル名と照合するかを示します。<a class="xref" href="information-schema.html#extended-show" title="21.32 SHOW ステートメントの拡張">セクション21.32「SHOW ステートメントの拡張」</a>で説明されているように、<code class="literal">WHERE</code> 句を指定すると、より一般的な条件を使用して行を選択できます。
      </p><p>
        <code class="literal">SHOW OPEN TABLES</code> の出力には、次のカラムがあります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Database</code>
          </p><p>
            このテーブルを含むデータベース。
          </p></li><li class="listitem"><p>
            <code class="literal">Table</code>
          </p><p>
            テーブル名。
          </p></li><li class="listitem"><p>
            <code class="literal">In_use</code>
          </p><p>
            このテーブルのために存在するテーブルロックまたはロック要求の数。たとえば、あるクライアントが <code class="literal">LOCK TABLE t1 WRITE</code> を使用してテーブルに対するロックを取得した場合、<code class="literal">In_use</code> は 1 になります。このテーブルがロックされたままになっている間に別のクライアントが <code class="literal">LOCK TABLE t1 WRITE</code> を発行した場合、このクライアントはロックを待機してブロックされますが、このロック要求が <code class="literal">In_use</code> を 2 にします。このカウントが 0 の場合、このテーブルは開いていますが、現在使用されていません。<code class="literal">In_use</code> はまた、<code class="literal">HANDLER ... OPEN</code> ステートメントによって増加し、<code class="literal">HANDLER ... CLOSE</code> ステートメントによって減少します。
          </p></li><li class="listitem"><p>
            <code class="literal">Name_locked</code>
          </p><p>
            テーブル名がロックされているかどうか。名前のロックは、テーブルの削除や名前の変更などの操作に使用されます。
          </p></li></ul></div><p>
        テーブルに対する権限を持っていない場合、そのテーブルは <code class="literal">SHOW OPEN TABLES</code> の出力に表示されません。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-plugins"></a>13.7.5.26 SHOW PLUGINS 構文</h4></div></div></div><a class="indexterm" name="idm139979077227664"></a><pre class="programlisting">
SHOW PLUGINS
</pre><p>
        <code class="literal">SHOW PLUGINS</code> は、サーバープラグインについての情報を表示します。プラグイン情報はまた、<code class="literal">INFORMATION_SCHEMA.PLUGINS</code> テーブルでも入手できます。<a class="xref" href="information-schema.html#plugins-table" title="21.14 INFORMATION_SCHEMA PLUGINS テーブル">セクション21.14「INFORMATION_SCHEMA PLUGINS テーブル」</a>を参照してください。
      </p><p>
        <code class="literal">SHOW PLUGINS</code> の出力の例:
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW PLUGINS\G</code></strong>
*************************** 1. row ***************************
   Name: binlog
 Status: ACTIVE
   Type: STORAGE ENGINE
Library: NULL
License: GPL
*************************** 2. row ***************************
   Name: CSV
 Status: ACTIVE
   Type: STORAGE ENGINE
Library: NULL
License: GPL
*************************** 3. row ***************************
   Name: MEMORY
 Status: ACTIVE
   Type: STORAGE ENGINE
Library: NULL
License: GPL
*************************** 4. row ***************************
   Name: MyISAM
 Status: ACTIVE
   Type: STORAGE ENGINE
Library: NULL
License: GPL
...
</pre><p>
        <code class="literal">SHOW PLUGINS</code> の出力には、次のカラムがあります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Name</code>: <code class="literal">INSTALL PLUGIN</code> や <code class="literal">UNINSTALL PLUGIN</code> などのステートメントでこのプラグインを参照するために使用される名前。
          </p></li><li class="listitem"><p>
            <code class="literal">Status</code>: このプラグインのステータスであり、<code class="literal">ACTIVE</code>、<code class="literal">INACTIVE</code>、<code class="literal">DISABLED</code>、<code class="literal">DELETED</code> のいずれかです。
          </p></li><li class="listitem"><p>
            <code class="literal">Type</code>: このプラグインのタイプであり、<code class="literal">STORAGE ENGINE</code>、<code class="literal">INFORMATION_SCHEMA</code>、<code class="literal">AUTHENTICATION</code> などがあります。
          </p></li><li class="listitem"><p>
            <code class="literal">Library</code>: このプラグインの共有オブジェクトファイルの名前。これは、<code class="literal">INSTALL PLUGIN</code> や <code class="literal">UNINSTALL PLUGIN</code> などのステートメントでプラグインファイルを参照するために使用される名前です。このファイルは、<code class="literal">plugin_dir</code> システム変数によって指名されたディレクトリに置かれます。ライブラリ名が <code class="literal">NULL</code> である場合、プラグインはコンパイルされますが、<code class="literal">UNINSTALL PLUGIN</code> でアンインストールできません。
          </p></li><li class="listitem"><p>
            <code class="literal">License</code>: このプラグインのライセンス方法 (<code class="literal">GPL</code> など)。
          </p></li></ul></div><p>
        <code class="literal">INSTALL PLUGIN</code> でインストールされたプラグインの場合、<code class="literal">Name</code> および <code class="literal">Library</code> 値は <code class="literal">mysql.plugin</code> テーブルにも登録されます。
      </p><p>
        <code class="literal">SHOW PLUGINS</code> によって表示される情報の基礎を形成するプラグインのデータ構造については、<a class="xref" href="extending-mysql.html#plugin-api" title="24.2 MySQL プラグイン API">セクション24.2「MySQL プラグイン API」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-privileges"></a>13.7.5.27 SHOW PRIVILEGES 構文</h4></div></div></div><a class="indexterm" name="idm139979077185552"></a><pre class="programlisting">
SHOW PRIVILEGES
</pre><p>
        <code class="literal">SHOW PRIVILEGES</code> は、MySQL サーバーがサポートするシステム権限のリストを表示します。権限の正確なリストは、使用しているサーバーのバージョンによって異なります。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW PRIVILEGES\G</code></strong>
*************************** 1. row ***************************
Privilege: Alter
  Context: Tables
  Comment: To alter the table
*************************** 2. row ***************************
Privilege: Alter routine
  Context: Functions,Procedures
  Comment: To alter or drop stored functions/procedures
*************************** 3. row ***************************
Privilege: Create
  Context: Databases,Tables,Indexes
  Comment: To create new databases and tables
*************************** 4. row ***************************
Privilege: Create routine
  Context: Databases
  Comment: To use CREATE FUNCTION/PROCEDURE
*************************** 5. row ***************************
Privilege: Create temporary tables
  Context: Databases
  Comment: To use CREATE TEMPORARY TABLE
...
</pre><p>
        特定のユーザーに属する権限は、<code class="literal">SHOW GRANTS</code> ステートメントによって表示されます。詳細は、<a class="xref" href="sql-syntax.html#show-grants" title="13.7.5.22 SHOW GRANTS 構文">セクション13.7.5.22「SHOW GRANTS 構文」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-procedure-code"></a>13.7.5.28 SHOW PROCEDURE CODE 構文</h4></div></div></div><a class="indexterm" name="idm139979077172432"></a><pre class="programlisting">
SHOW PROCEDURE CODE <em class="replaceable"><code>proc_name</code></em>
</pre><p>
        このステートメントは、デバッグサポート付きで構築されたサーバーでのみ使用可能な MySQL 拡張です。これは、指定されたストアドプロシージャーの内部実装の表現を表示します。同様のステートメントである <code class="literal">SHOW FUNCTION CODE</code> は、ストアドファンクションに関する情報を表示します (<a class="xref" href="sql-syntax.html#show-function-code" title="13.7.5.20 SHOW FUNCTION CODE 構文">セクション13.7.5.20「SHOW FUNCTION CODE 構文」</a>を参照してください)。
      </p><p>
        どちらのステートメントを使用するにも、このルーチンの所有者であるか、または <code class="literal">mysql.proc</code> テーブルへの <code class="literal">SELECT</code> アクセス権を持っている必要があります。
      </p><p>
        指定されたルーチンが使用可能な場合、各ステートメントは結果セットを生成します。結果セット内の各行は、このルーチン内の 1 つの<span class="quote">「<span class="quote">命令</span>」</span>に対応します。最初のカラムは、0 で始まる順序番号である <code class="literal">Pos</code> です。2 番目のカラムは <code class="literal">Instruction</code> であり、SQL ステートメント (通常は、元のソースから変更されています)、またはストアドルーチンのハンドラに対してのみ意味を持つディレクティブが含まれています。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>DELIMITER //</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE PROCEDURE p1 ()</code></strong>
    -&gt; <strong class="userinput"><code>BEGIN</code></strong>
    -&gt;   <strong class="userinput"><code>DECLARE fanta INT DEFAULT 55;</code></strong>
    -&gt;   <strong class="userinput"><code>DROP TABLE t2;</code></strong>
    -&gt;   <strong class="userinput"><code>LOOP</code></strong>
    -&gt;     <strong class="userinput"><code>INSERT INTO t3 VALUES (fanta);</code></strong>
    -&gt;     <strong class="userinput"><code>END LOOP;</code></strong>
    -&gt;   <strong class="userinput"><code>END//</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW PROCEDURE CODE p1//</code></strong>
+-----+----------------------------------------+
| Pos | Instruction                            |
+-----+----------------------------------------+
|   0 | set fanta@0 55                         |
|   1 | stmt 9 "DROP TABLE t2"                 |
|   2 | stmt 5 "INSERT INTO t3 VALUES (fanta)" |
|   3 | jump 2                                 |
+-----+----------------------------------------+
4 rows in set (0.00 sec)
</pre><p>
        この例では、実行不可能な <code class="literal">BEGIN</code> および <code class="literal">END</code> ステートメントが消えており、<code class="literal">DECLARE <em class="replaceable"><code>variable_name</code></em></code> ステートメントでは、実行可能ファイルの部分 (デフォルトが割り当てられている部分) のみが表示されています。ソースから取得されたステートメントごとに、コードワード <code class="literal">stmt</code> とそれに続くタイプ (<code class="literal">DROP</code> を示す 9、<code class="literal">INSERT</code> を示す 5 など) が存在します。最終行には、<code class="literal">GOTO instruction #2</code> を示す命令 <code class="literal">jump 2</code> が含まれています。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-procedure-status"></a>13.7.5.29 SHOW PROCEDURE STATUS 構文</h4></div></div></div><a class="indexterm" name="idm139979077140416"></a><pre class="programlisting">
SHOW PROCEDURE STATUS
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
        このステートメントは、MySQL 拡張です。これは、ストアドプロシージャーの特性 (データベース、名前、型、作成者、作成日と変更日、文字セット情報など) を返します。同様のステートメントである <code class="literal">SHOW FUNCTION STATUS</code> は、ストアドファンクションに関する情報を表示します (<a class="xref" href="sql-syntax.html#show-function-status" title="13.7.5.21 SHOW FUNCTION STATUS 構文">セクション13.7.5.21「SHOW FUNCTION STATUS 構文」</a>を参照してください)。
      </p><p>
        <code class="literal">LIKE</code> 句 (存在する場合) は、どのプロシージャーまたは関数名と照合するかを示します。<a class="xref" href="information-schema.html#extended-show" title="21.32 SHOW ステートメントの拡張">セクション21.32「SHOW ステートメントの拡張」</a>で説明されているように、<code class="literal">WHERE</code> 句を指定すると、より一般的な条件を使用して行を選択できます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW PROCEDURE STATUS LIKE 'sp1'\G</code></strong>
*************************** 1. row ***************************
                  Db: test
                Name: sp1
                Type: PROCEDURE
             Definer: testuser@localhost
            Modified: 2004-08-03 15:29:37
             Created: 2004-08-03 15:29:37
       Security_type: DEFINER
             Comment:
character_set_client: latin1
collation_connection: latin1_swedish_ci
  Database Collation: latin1_swedish_ci
</pre><p>
        <code class="literal">character_set_client</code> は、このルーチンが作成されたときの <code class="literal">character_set_client</code> システム変数のセッション値です。<code class="literal">collation_connection</code> は、このルーチンが作成されたときの <code class="literal">collation_connection</code> システム変数のセッション値です。<code class="literal">Database Collation</code> は、このルーチンが関連付けられているデータベースの照合順序です。
      </p><p>
        ストアドルーチンに関する情報はまた、<code class="literal">INFORMATION_SCHEMA</code> 内の <code class="literal">ROUTINES</code> テーブルからも取得できます。<a class="xref" href="information-schema.html#routines-table" title="21.18 INFORMATION_SCHEMA ROUTINES テーブル">セクション21.18「INFORMATION_SCHEMA ROUTINES テーブル」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-processlist"></a>13.7.5.30 SHOW PROCESSLIST 構文</h4></div></div></div><a class="indexterm" name="idm139979077116640"></a><a class="indexterm" name="idm139979077115216"></a><a class="indexterm" name="idm139979077113984"></a><a class="indexterm" name="idm139979077112640"></a><a class="indexterm" name="idm139979077110496"></a><a class="indexterm" name="idm139979077108464"></a><pre class="programlisting">
SHOW [FULL] PROCESSLIST
</pre><p>
        <code class="literal">SHOW PROCESSLIST</code> は、どのスレッドが実行されているかを表示します。この情報はまた、<code class="literal">INFORMATION_SCHEMA</code> <code class="literal">PROCESSLIST</code> テーブルまたは <span class="command"><strong>mysqladmin processlist</strong></span> コマンドからも取得できます。<code class="literal">PROCESS</code> 権限がある場合は、すべてのスレッドを表示できます。そうでない場合は、ユーザー独自のスレッド (つまり、使用している MySQL アカウントに関連付けられたスレッド) のみを表示できます。<code class="literal">FULL</code> キーワードを使用しない場合は、各ステートメントの最初の 100 文字のみが <code class="literal">Info</code> フィールドに表示されます。
      </p><p>
        処理情報は、<code class="literal">performance_schema.threads</code> テーブルから利用することもできます。ただし、<code class="literal">threads</code> へのアクセスには相互排他ロックは必要なく、サーバーパフォーマンスへの影響は最小です。<code class="literal">INFORMATION_SCHEMA.PROCESSLIST</code> および <code class="literal">SHOW PROCESSLIST</code> は、相互排他ロックを必要とするので、負のパフォーマンスの結果になります。<code class="literal">threads</code> はまた、バックグラウンドスレッドに関する情報も表示しますが、<code class="literal">INFORMATION_SCHEMA.PROCESSLIST</code> および <code class="literal">SHOW PROCESSLIST</code> は表示しません。これは、<code class="literal">threads</code> は、ほかのスレッド情報源では行えないアクティビティーのモニターに使用できることを意味します。
      </p><p>
        <code class="literal">SHOW PROCESSLIST</code> ステートメントは、<span class="quote">「<span class="quote">接続が多すぎます</span>」</span>というエラーメッセージが表示されるために、何が発生しているかを突き止めたい場合に非常に役立ちます。MySQL は、管理者がいつでもシステムに接続し、システムを確実にチェックできるようにするために、<code class="literal">SUPER</code> 権限を持つアカウントによって使用される追加の接続を 1 つ予約しています (この権限をすべてのユーザーには与えていないと仮定します)。 
      </p><p>
        スレッドは、<code class="literal">KILL</code> ステートメントを使用して強制終了できます。<a class="xref" href="sql-syntax.html#kill" title="13.7.6.4 KILL 構文">セクション13.7.6.4「KILL 構文」</a>を参照してください。
      </p><p>
        <code class="literal">SHOW PROCESSLIST</code> の出力の例を次に示します。
      </p><pre class="programlisting">
mysql&gt; SHOW FULL PROCESSLIST\G
*************************** 1. row ***************************
Id: 1
User: system user
Host:
db: NULL
Command: Connect
Time: 1030455
State: Waiting for master to send event
Info: NULL
*************************** 2. row ***************************
Id: 2
User: system user
Host:
db: NULL
Command: Connect
Time: 1004
State: Has read all relay log; waiting for the slave
       I/O thread to update it
Info: NULL
*************************** 3. row ***************************
Id: 3112
User: replikator
Host: artemis:2204
db: NULL
Command: Binlog Dump
Time: 2144
State: Has sent all binlog to slave; waiting for binlog to be updated
Info: NULL
*************************** 4. row ***************************
Id: 3113
User: replikator
Host: iconnect2:45781
db: NULL
Command: Binlog Dump
Time: 2086
State: Has sent all binlog to slave; waiting for binlog to be updated
Info: NULL
*************************** 5. row ***************************
Id: 3123
User: stefan
Host: localhost
db: apollon
Command: Query
Time: 0
State: NULL
Info: SHOW FULL PROCESSLIST
5 rows in set (0.00 sec)
</pre><p>
        <code class="literal">SHOW PROCESSLIST</code> によって生成されるカラムには、次の意味があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="processlist_id"></a>
            <code class="literal">Id</code>
          </p><p>
            接続識別子。これは、<code class="literal">INFORMATION_SCHEMA.PROCESSLIST</code> テーブルの <code class="literal">ID</code> カラム、パフォーマンススキーマの <code class="literal">threads</code> テーブルの <code class="literal">PROCESSLIST_ID</code> カラムに表示される値、および <code class="literal">CONNECTION_ID()</code> 関数によって返される値と同じ型の値です。
          </p></li><li class="listitem"><p><a name="processlist_user"></a>
            <code class="literal">User</code>
          </p><p>
            このステートメントを発行した MySQL ユーザー。これが <code class="literal">system user</code> である場合は、タスクを内部的に処理するためにサーバーによって生成された非クライアントスレッドを示します。これは、レプリケーションスレーブ上で使用されている I/O または SQL スレッドか、あるいは遅延行ハンドラである可能性があります。<code class="literal">unauthenticated user</code> は、クライアント接続に関連付けられたが、クライアントユーザーの認証がまだ実行されていないスレッドを示します。<code class="literal">event_scheduler</code> は、スケジュールされたイベントをモニターするスレッドを示します。<code class="literal">system user</code> の場合、<code class="literal">Host</code> カラムで指定されるホストは存在しません。
          </p></li><li class="listitem"><p><a name="processlist_host"></a>
            <code class="literal">Host</code>
          </p><p>
            このステートメントを発行しているクライアントのホスト名 (ホストが存在しない <code class="literal">system user</code> を除きます)。<code class="literal">SHOW PROCESSLIST</code> は、どのクライアントが何を実行しているかの判定を容易にするために、TCP/IP 接続のホスト名を <code class="literal"><em class="replaceable"><code>host_name</code></em>:<em class="replaceable"><code>client_port</code></em></code> の形式でレポートします。
          </p></li><li class="listitem"><p><a name="processlist_db"></a>
            <code class="literal">db</code>
          </p><p>
            デフォルトデータベース (選択されている場合)。そうでない場合は <code class="literal">NULL</code>。
          </p></li><li class="listitem"><p><a name="processlist_command"></a>
            <code class="literal">Command</code>
          </p><p>
            スレッドが実行しているコマンドの種類。スレッドのコマンドの説明については、<a class="xref" href="optimization.html#thread-information" title="8.12.5 スレッド情報の検査">セクション8.12.5「スレッド情報の検査」</a>を参照してください。このカラムの値は、クライアント/サーバープロトコルの <code class="literal">COM_<em class="replaceable"><code>xxx</code></em></code> コマンドと <code class="literal">Com_<em class="replaceable"><code>xxx</code></em></code> ステータス変数に対応します。<a class="xref" href="server-administration.html#server-status-variables" title="5.1.6 サーバーステータス変数">セクション5.1.6「サーバーステータス変数」</a>を参照してください
          </p></li><li class="listitem"><p><a name="processlist_time"></a>
            <code class="literal">Time</code>
          </p><p>
            スレッドが現在の状態になってからの秒数。スレーブ SQL スレッドの場合、この値は、最後にレプリケートされたイベントのタイムスタンプと、スレーブマシンの実際の時間の間の秒数です。<a class="xref" href="replication.html#replication-implementation-details" title="17.2.1 レプリケーション実装の詳細">セクション17.2.1「レプリケーション実装の詳細」</a>を参照してください。
          </p></li><li class="listitem"><p><a name="processlist_state"></a>
            <code class="literal">State</code>
          </p><p>
            スレッドが行なっていることを示すアクション、イベント、または状態。<code class="literal">State</code> 値の説明については、<a class="xref" href="optimization.html#thread-information" title="8.12.5 スレッド情報の検査">セクション8.12.5「スレッド情報の検査」</a>を参照してください。
          </p><p>
            ほとんどの状態がきわめてすばやい操作に対応します。スレッドの状態が何秒間も特定の状態にとどまっている場合は、調査が必要な問題が発生している可能性があります。
          </p><p>
            <code class="literal">SHOW PROCESSLIST</code> ステートメントの場合、<code class="literal">State</code> の値は <code class="literal">NULL</code> です。
          </p></li><li class="listitem"><p><a name="processlist_info"></a>
            <code class="literal">Info</code>
          </p><p>
            スレッドが実行しているステートメント、またはそれがどのステートメントも実行していない場合は <code class="literal">NULL</code>。このステートメントは、サーバーに送信されるステートメント、またはこのステートメントがほかのステートメントを実行する場合は、もっとも内側のステートメントである可能性があります。たとえば、<code class="literal">CALL</code> ステートメントが、<code class="literal">SELECT</code> ステートメントを実行しているストアドプロシージャーを実行する場合、<code class="literal">Info</code> 値はその <code class="literal">SELECT</code> ステートメントを示します。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-profile"></a>13.7.5.31 SHOW PROFILE 構文</h4></div></div></div><a class="indexterm" name="idm139979077024352"></a><a class="indexterm" name="idm139979077023040"></a><pre class="programlisting">
SHOW PROFILE [<em class="replaceable"><code>type</code></em> [, <em class="replaceable"><code>type</code></em>] ... ]
    [FOR QUERY <em class="replaceable"><code>n</code></em>]
    [LIMIT <em class="replaceable"><code>row_count</code></em> [OFFSET <em class="replaceable"><code>offset</code></em>]]

<em class="replaceable"><code>type</code></em>:
    ALL
  | BLOCK IO
  | CONTEXT SWITCHES
  | CPU
  | IPC
  | MEMORY
  | PAGE FAULTS
  | SOURCE
  | SWAPS
</pre><p>
        <code class="literal">SHOW PROFILE</code> および <code class="literal">SHOW PROFILES</code> ステートメントは、現在のセッションの過程で実行されたステートメントのリソース使用状況を示すプロファイリング情報を表示します。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          これらのステートメントは、MySQL 5.6.7 の時点では非推奨であり、将来の MySQL リリースで削除される予定です。代わりに、パフォーマンススキーマを使用してください。<a class="xref" href="performance-schema.html" title="第 22 章 MySQL パフォーマンススキーマ">第22章「<i>MySQL パフォーマンススキーマ</i>」</a>を参照してください。
        </p></div><p>
        プロファイリングは、<code class="literal">profiling</code> セッション変数によって制御されます。このデフォルト値は 0 (<code class="literal">OFF</code>) です。プロファイリングは、<code class="literal">profiling</code> を 1 または <code class="literal">ON</code> に設定することによって有効になります。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET profiling = 1;</code></strong>
</pre><p>
        <code class="literal">SHOW PROFILES</code> は、サーバーに送信された最新のステートメントのリストを表示します。このリストのサイズは、<code class="literal">profiling_history_size</code> セッション変数によって制御されます。このデフォルト値は 15 です。最大値は 100 です。この値を 0 に設定すると、実質的にプロファイリングが無効になります。
      </p><p>
        <code class="literal">SHOW PROFILE</code> と <code class="literal">SHOW PROFILES</code> を除くすべてのステートメントがプロファイルされるため、このどちらのステートメントもプロファイルリスト内に見つかりません。不正な形式のステートメントはプロファイルされます。たとえば、<code class="literal">SHOW PROFILING</code> は不正なステートメントであるため、それを実行しようとすると構文エラーが発生しますが、プロファイリングリストには表示されます。
      </p><p>
        <code class="literal">SHOW PROFILE</code> は、1 つのステートメントに関する詳細情報を表示します。<code class="literal">FOR QUERY <em class="replaceable"><code>n</code></em></code> 句を指定しない場合、出力は、直近で実行されたステートメントに関連したものになります。<code class="literal">FOR QUERY <em class="replaceable"><code>n</code></em></code> が含まれている場合、<code class="literal">SHOW PROFILE</code> は、ステートメント <em class="replaceable"><code>n</code></em> に関する情報を表示します。<em class="replaceable"><code>n</code></em> の値は、<code class="literal">SHOW PROFILES</code> によって表示される <code class="literal">Query_ID</code> 値に対応します。
      </p><p>
        <code class="literal">LIMIT <em class="replaceable"><code>row_count</code></em></code> 句を指定すると、出力を <em class="replaceable"><code>row_count</code></em> 行に制限できます。<code class="literal">LIMIT</code> が指定されている場合は、<code class="literal">OFFSET <em class="replaceable"><code>offset</code></em></code> を追加することで、行セット全体が <em class="replaceable"><code>offset</code></em> 行分オフセットされた状態で出力を開始できます。
      </p><p>
        デフォルトでは、<code class="literal">SHOW PROFILE</code> は <code class="literal">Status</code> および <code class="literal">Duration</code> カラムを表示します。この <code class="literal">Status</code> 値は <code class="literal">SHOW PROCESSLIST</code> によって表示される <code class="literal">State</code> 値に似ていますが、一部のステータス値では、この 2 つのステートメントの解釈にわずかな違いがいくつか存在する可能性があります (<a class="xref" href="optimization.html#thread-information" title="8.12.5 スレッド情報の検査">セクション8.12.5「スレッド情報の検査」</a>を参照してください)。
      </p><p>
        オプションの <em class="replaceable"><code>type</code></em> 値を指定すると、次のその他の特定のタイプの情報を表示できます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">ALL</code> は、すべての情報を表示します
          </p></li><li class="listitem"><p>
            <code class="literal">BLOCK IO</code> は、ブロック入力および出力操作の数を表示します
          </p></li><li class="listitem"><p>
            <code class="literal">CONTEXT SWITCHES</code> は、自発的および非自発的コンテキストスイッチの数を表示します
          </p></li><li class="listitem"><p>
            <code class="literal">CPU</code> は、ユーザーとシステムの CPU 使用時間を表示します
          </p></li><li class="listitem"><p>
            <code class="literal">IPC</code> は、送受信されたメッセージの数を表示します
          </p></li><li class="listitem"><p>
            <code class="literal">MEMORY</code> は現在、実装されていません
          </p></li><li class="listitem"><p>
            <code class="literal">PAGE FAULTS</code> は、メジャーおよびマイナーページフォルトの数を表示します
          </p></li><li class="listitem"><p>
            <code class="literal">SOURCE</code> は、ソースコードの関数の名前を、その関数が含まれているファイルの名前および行番号とともに表示します
          </p></li><li class="listitem"><p>
            <code class="literal">SWAPS</code> は、スワップ数を表示します
          </p></li></ul></div><p>
        プロファイリングは、セッション単位で有効になります。セッションが終了すると、そのプロファイリング情報は失われます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT @@profiling;</code></strong>
+-------------+
| @@profiling |
+-------------+
|           0 |
+-------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SET profiling = 1;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>DROP TABLE IF EXISTS t1;</code></strong>
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql&gt; <strong class="userinput"><code>CREATE TABLE T1 (id INT);</code></strong>
Query OK, 0 rows affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>SHOW PROFILES;</code></strong>
+----------+----------+--------------------------+
| Query_ID | Duration | Query                    |
+----------+----------+--------------------------+
|        0 | 0.000088 | SET PROFILING = 1        |
|        1 | 0.000136 | DROP TABLE IF EXISTS t1  |
|        2 | 0.011947 | CREATE TABLE t1 (id INT) |
+----------+----------+--------------------------+
3 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW PROFILE;</code></strong>
+----------------------+----------+
| Status               | Duration |
+----------------------+----------+
| checking permissions | 0.000040 |
| creating table       | 0.000056 |
| After create         | 0.011363 |
| query end            | 0.000375 |
| freeing items        | 0.000089 |
| logging slow query   | 0.000019 |
| cleaning up          | 0.000005 |
+----------------------+----------+
7 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW PROFILE FOR QUERY 1;</code></strong>
+--------------------+----------+
| Status             | Duration |
+--------------------+----------+
| query end          | 0.000107 |
| freeing items      | 0.000008 |
| logging slow query | 0.000015 |
| cleaning up        | 0.000006 |
+--------------------+----------+
4 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW PROFILE CPU FOR QUERY 2;</code></strong>
+----------------------+----------+----------+------------+
| Status               | Duration | CPU_user | CPU_system |
+----------------------+----------+----------+------------+
| checking permissions | 0.000040 | 0.000038 |   0.000002 |
| creating table       | 0.000056 | 0.000028 |   0.000028 |
| After create         | 0.011363 | 0.000217 |   0.001571 |
| query end            | 0.000375 | 0.000013 |   0.000028 |
| freeing items        | 0.000089 | 0.000010 |   0.000014 |
| logging slow query   | 0.000019 | 0.000009 |   0.000010 |
| cleaning up          | 0.000005 | 0.000003 |   0.000002 |
+----------------------+----------+----------+------------+
7 rows in set (0.00 sec)
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          一部のアーキテクチャーでは、プロファイリングが部分的にしか機能しません。<code class="literal">getrusage()</code> システムコールに依存する値の場合、このシステムコールをサポートしていない Windows などのシステムでは <code class="literal">NULL</code> が返されます。さらに、プロファイリングはスレッド単位ではなく、プロセス単位です。つまり、サーバー内の、ユーザー独自のスレッド以外のスレッド上のアクティビティーが、ユーザーに表示されるタイミング情報に影響を与える可能性があります。
        </p></div><p>
        プロファイリング情報はまた、<code class="literal">INFORMATION_SCHEMA</code> 内の <code class="literal">PROFILING</code> テーブルからも取得できます。<a class="xref" href="information-schema.html#profiling-table" title="21.16 INFORMATION_SCHEMA PROFILING テーブル">セクション21.16「INFORMATION_SCHEMA PROFILING テーブル」</a>を参照してください。たとえば、次のクエリーは同じ結果を生成します。
      </p><pre class="programlisting">
SHOW PROFILE FOR QUERY 2;

SELECT STATE, FORMAT(DURATION, 6) AS DURATION
FROM INFORMATION_SCHEMA.PROFILING
WHERE QUERY_ID = 2 ORDER BY SEQ;
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-profiles"></a>13.7.5.32 SHOW PROFILES 構文</h4></div></div></div><a class="indexterm" name="idm139979076943040"></a><pre class="programlisting">
SHOW PROFILES
</pre><p>
        <code class="literal">SHOW PROFILES</code> ステートメントは、<code class="literal">SHOW PROFILE</code> とともに、現在のセッションの過程で実行されたステートメントのリソース使用状況を示すプロファイリング情報を表示します。詳細は、<a class="xref" href="sql-syntax.html#show-profile" title="13.7.5.31 SHOW PROFILE 構文">セクション13.7.5.31「SHOW PROFILE 構文」</a>を参照してください。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          これらのステートメントは、MySQL 5.6.7 の時点では非推奨であり、将来の MySQL リリースで削除される予定です。代わりに、パフォーマンススキーマを使用してください。<a class="xref" href="performance-schema.html" title="第 22 章 MySQL パフォーマンススキーマ">第22章「<i>MySQL パフォーマンススキーマ</i>」</a>を参照してください。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-relaylog-events"></a>13.7.5.33 SHOW RELAYLOG EVENTS 構文</h4></div></div></div><a class="indexterm" name="idm139979076931120"></a><pre class="programlisting">
SHOW RELAYLOG EVENTS
   [IN '<em class="replaceable"><code>log_name</code></em>'] [FROM <em class="replaceable"><code>pos</code></em>] [LIMIT [<em class="replaceable"><code>offset</code></em>,] <em class="replaceable"><code>row_count</code></em>]
</pre><p>
        レプリケーションスレーブのリレーログ内のイベントを表示します。<code class="literal">'<em class="replaceable"><code>log_name</code></em>'</code> を指定しない場合は、最初のリレーログが表示されます。このステートメントは、マスターには影響を与えません。
      </p><p>
        <code class="literal">LIMIT</code> 句の構文は、<code class="literal">SELECT</code> ステートメントの場合と同じです。<a class="xref" href="sql-syntax.html#select" title="13.2.9 SELECT 構文">セクション13.2.9「SELECT 構文」</a>を参照してください。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">SHOW RELAYLOG EVENTS</code> を <code class="literal">LIMIT</code> 句なしで発行すると、サーバーはクライアントに (スレーブによって受信されたデータを変更するすべてのステートメントを含む) リレーログの完全な内容を返すため、時間とリソースを大量に消費するプロセスが開始される可能性があります。
        </p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">SHOW RELAYLOG EVENTS</code> からの出力には、ユーザーおよびシステム変数の設定に関連した一部のイベントが含まれていません。リレーログ内のイベントを完全に取得するには、<span class="command"><strong>mysqlbinlog</strong></span> を使用します。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-slave-hosts"></a>13.7.5.34 SHOW SLAVE HOSTS 構文</h4></div></div></div><a class="indexterm" name="idm139979076912112"></a><pre class="programlisting">
SHOW SLAVE HOSTS
</pre><p>
        現在マスターに登録されているレプリケーションスレーブのリストを表示します。
      </p><p>
        <code class="literal">SHOW SLAVE HOSTS</code> は、レプリケーションマスターとして機能するサーバー上で実行するようにしてください。このステートメントは、レプリケーションスレーブとして接続されているか、またはこれまでに接続されたサーバーに関する情報を、次に示すように結果の各行が 1 つのスレーブサーバーに対応するように表示します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW SLAVE HOSTS</code></strong>;
+-----------+-----------+-------+-----------+--------------------------------------+
| Server_id | Host      | Port  | Master_id | Slave_UUID                           |
+-----------+-----------+-------+-----------+--------------------------------------+
|  192168010 | iconnect2 | 3306 | 192168011 | 14cb6624-7f93-11e0-b2c0-c80aa9429562 |
| 1921680101 | athena    | 3306 | 192168011 | 07af4990-f41f-11df-a566-7ac56fdaf645 |
+------------+-----------+------+-----------+--------------------------------------+
</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Server_id</code>: このスレーブサーバーの一意のサーバー ID。これは、このスレーブサーバーのオプションファイルで、または <code class="option">--server-id=<em class="replaceable"><code>value</code></em></code> を使用してコマンド行で構成されます。
          </p></li><li class="listitem"><p>
            <code class="literal">Host</code>: このスレーブサーバーのホスト名。これは、このスレーブサーバーのオプションファイルで、または <code class="option">--report-host=<em class="replaceable"><code>host_name</code></em></code> を使用してコマンド行で構成されます。これは、オペレーティングシステムで構成されているマシン名とは異なる場合があります。
          </p></li><li class="listitem"><p>
            <code class="literal">Port</code>: このスレーブサーバーが待機しているマスター上のポート。
          </p><p>
            MySQL 5.6.5 以降では、このカラムが 0 である場合、スレーブポート (<code class="option">--report-port</code>) が設定されなかったことを示します。MySQL 5.6.5 より前は、このような場合は 3306 がデフォルトとして使用されました (Bug #13333431)。
          </p></li><li class="listitem"><p>
            <code class="literal">Master_id</code>: このスレーブサーバーのレプリケーション元であるマスターサーバーの一意のサーバー ID。これは、<code class="literal">SHOW SLAVE HOSTS</code> が実行されているサーバーのサーバー ID であるため、この同じ値が結果の各行にリストされます。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979076890416"></a> <code class="literal">Slave_UUID</code>: このスレーブのグローバルに一意の ID。これはスレーブ上で生成され、スレーブの <code class="filename">auto.cnf</code> ファイル内に格納されています。
          </p><p>
            このカラムは、MySQL 5.6.0 で追加されました。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-slave-status"></a>13.7.5.35 SHOW SLAVE STATUS 構文</h4></div></div></div><a class="indexterm" name="idm139979076883824"></a><pre class="programlisting">
SHOW SLAVE STATUS
</pre><p>
        このステートメントは、スレーブスレッドの基本的なパラメータに関するステータス情報を提供します。これには、<code class="literal">SUPER</code> または <code class="literal">REPLICATION CLIENT</code> 権限のどちらかが必要です。
      </p><p>
        <span class="command"><strong>mysql</strong></span> クライアントを使用してこのステートメントを発行する場合は、セミコロンの代わりに <code class="literal">\G</code> ステートメントターミネータを使用すると、より読みやすい縦のレイアウトが得られます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW SLAVE STATUS\G</code></strong>
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
                  Master_Host: localhost
                  Master_User: root
                  Master_Port: 13000
                Connect_Retry: 60
              Master_Log_File: master-bin.000002
          Read_Master_Log_Pos: 1307
               Relay_Log_File: slave-relay-bin.000003
                Relay_Log_Pos: 1508
        Relay_Master_Log_File: master-bin.000002
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
              Replicate_Do_DB:
          Replicate_Ignore_DB:
           Replicate_Do_Table:
       Replicate_Ignore_Table:
      Replicate_Wild_Do_Table:
  Replicate_Wild_Ignore_Table:
                   Last_Errno: 0
                   Last_Error:
                 Skip_Counter: 0
          Exec_Master_Log_Pos: 1307
              Relay_Log_Space: 1858
              Until_Condition: None
               Until_Log_File:
                Until_Log_Pos: 0
           Master_SSL_Allowed: No
           Master_SSL_CA_File:
           Master_SSL_CA_Path:
              Master_SSL_Cert:
            Master_SSL_Cipher:
               Master_SSL_Key:
        Seconds_Behind_Master: 0
Master_SSL_Verify_Server_Cert: No
                Last_IO_Errno: 0
                Last_IO_Error:
               Last_SQL_Errno: 0
               Last_SQL_Error:
  Replicate_Ignore_Server_Ids:
             Master_Server_Id: 1
                  Master_UUID: 3e11fa47-71ca-11e1-9e33-c80aa9429562
             Master_Info_File: /var/mysqld.2/data/master.info
                    SQL_Delay: 0
          SQL_Remaining_Delay: NULL
      Slave_SQL_Running_State: Slave has read all relay log; waiting for the slave I/O thread to update it
           Master_Retry_Count: 10
                  Master_Bind:
      Last_IO_Error_Timestamp:
     Last_SQL_Error_Timestamp:
               Master_SSL_Crl:
           Master_SSL_Crlpath:
           Retrieved_Gtid_Set: 3e11fa47-71ca-11e1-9e33-c80aa9429562:1-5
            Executed_Gtid_Set: 3e11fa47-71ca-11e1-9e33-c80aa9429562:1-5
                Auto_Position: 1
1 row in set (0.00 sec)
</pre><p>
        次のリストは、<code class="literal">SHOW SLAVE STATUS</code> によって返されるフィールドについて説明しています。これらの意味の解釈の詳細は、<a class="xref" href="optimization.html#slave-io-thread-states" title="8.12.5.6 レプリケーションスレーブの I/O スレッド状態">セクション8.12.5.6「レプリケーションスレーブの I/O スレッド状態」</a>を参照してください。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Slave_IO_State</code>
          </p><p>
            スレーブ I/O スレッドに対する <code class="literal">SHOW PROCESSLIST</code> の出力の <code class="literal">State</code> フィールドのコピー。これにより、このスレッドが何を実行しているか (マスターに接続しようとしている、マスターからのイベントを待機している、マスターに再接続しているなど) がわかります。可能性のある状態のリストについては、<a class="xref" href="optimization.html#slave-io-thread-states" title="8.12.5.6 レプリケーションスレーブの I/O スレッド状態">セクション8.12.5.6「レプリケーションスレーブの I/O スレッド状態」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">Master_Host</code>
          </p><p>
            このスレーブが接続されているマスターホスト。
          </p></li><li class="listitem"><p>
            <code class="literal">Master_User</code>
          </p><p>
            マスターに接続するために使用されるアカウントのユーザー名。
          </p></li><li class="listitem"><p>
            <code class="literal">Master_Port</code>
          </p><p>
            マスターに接続するために使用されるポート。
          </p></li><li class="listitem"><p>
            <code class="literal">Connect_Retry</code>
          </p><p>
            接続再試行の間の秒数 (デフォルトは 60)。これは、<code class="literal">CHANGE MASTER TO</code> ステートメントで設定できます。
          </p></li><li class="listitem"><p>
            <code class="literal">Master_Log_File</code>
          </p><p>
            I/O スレッドが現在読み取っている元のマスターバイナリログファイルの名前。
          </p></li><li class="listitem"><p>
            <code class="literal">Read_Master_Log_Pos</code>
          </p><p>
            現在のマスターバイナリログファイル内の I/O スレッドが最後に読み取った位置。
          </p></li><li class="listitem"><p>
            <code class="literal">Relay_Log_File</code>
          </p><p>
            SQL スレッドが現在読み取って実行している元のリレーログファイルの名前。
          </p></li><li class="listitem"><p>
            <code class="literal">Relay_Log_Pos</code>
          </p><p>
            現在のリレーログファイル内の SQL スレッドが最後に読み取って実行した位置。
          </p></li><li class="listitem"><p>
            <code class="literal">Relay_Master_Log_File</code>
          </p><p>
            SQL スレッドによって実行された最新のイベントを含むマスターバイナリログファイルの名前。
          </p></li><li class="listitem"><p>
            <code class="literal">Slave_IO_Running</code>
          </p><p>
            I/O スレッドが起動され、マスターに正常に接続したかどうか。内部的には、このスレッドの状態は次の 3 つの値のいずれかによって表されます。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><b>MYSQL_SLAVE_NOT_RUN </b>
                  スレーブ I/O スレッドは実行されていません。この状態の場合、<code class="literal">Slave_IO_Running</code> は <code class="literal">No</code> です。
                </p></li><li class="listitem"><p><b>MYSQL_SLAVE_RUN_NOT_CONNECT </b>
                  スレーブ I/O スレッドは実行されていますが、レプリケーションマスターに接続されていません。この状態の場合、<code class="literal">Slave_IO_Running</code> は、次の表に示すようにサーバーバージョンによって異なります。
                </p><div class="informaltable"><table summary="MYSQL_SLAVE_RUN_NOT_CONNECT 状態の場合、Slave_IO_Running は MySQL サーバーのバージョンによって異なります。この表は、Slave_IO_Running の MySQL バージョンの依存関係を示しています。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">MySQL バージョン</th><th scope="col"><code class="literal">Slave_IO_Running</code></th></tr></thead><tbody><tr><td scope="row">4.1 (4.1.13 以前)、5.0 (5.0.11 以前)</td><td><code class="literal">Yes</code></td></tr><tr><td scope="row">4.1 (4.1.14 以降)、5.0 (5.0.12 以降)</td><td><code class="literal">No</code></td></tr><tr><td scope="row">5.1 (5.1.45 以前)</td><td><code class="literal">No</code></td></tr><tr><td scope="row">5.1 (5.1.46 以降)、5.5、5.6</td><td><code class="literal">Connecting</code></td></tr></tbody></table></div></li><li class="listitem"><p><b>MYSQL_SLAVE_RUN_CONNECT </b>
                  スレーブ I/O スレッドは実行されており、レプリケーションマスターに接続されています。この状態の場合、<code class="literal">Slave_IO_Running</code> は <code class="literal">Yes</code> です。
                </p></li></ul></div><p>
            <code class="literal">Slave_running</code> システムステータス変数の値は、この値に対応します。
          </p></li><li class="listitem"><p>
            <code class="literal">Slave_SQL_Running</code>
          </p><p>
            SQL スレッドが起動されたかどうか。
          </p></li><li class="listitem"><p>
            <code class="literal">Replicate_Do_DB</code>、<code class="literal">Replicate_Ignore_DB</code>
          </p><p>
            <code class="option">--replicate-do-db</code> および <code class="option">--replicate-ignore-db</code> オプションで指定されたデータベースのリスト (存在する場合)。
          </p></li><li class="listitem"><p>
            <code class="literal">Replicate_Do_Table</code>、<code class="literal">Replicate_Ignore_Table</code>、<code class="literal">Replicate_Wild_Do_Table</code>、<code class="literal">Replicate_Wild_Ignore_Table</code>
          </p><p>
            <code class="option">--replicate-do-table</code>、<code class="option">--replicate-ignore-table</code>、<code class="option">--replicate-wild-do-table</code>、および <code class="option">--replicate-wild-ignore-table</code> オプションで指定されたテーブルのリスト (存在する場合)。
          </p></li><li class="listitem"><p>
            <code class="literal">Last_Errno</code>、<code class="literal">Last_Error</code>
          </p><p>
            これらのカラムは、<code class="literal">Last_SQL_Errno</code> および <code class="literal">Last_SQL_Error</code> のエイリアスです。
          </p><p>
            <code class="literal">RESET MASTER</code> または <code class="literal">RESET SLAVE</code> を発行すると、これらのカラムに表示されている値がリセットされます。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              スレーブ SQL スレッドは、エラーを受信すると、まずそのエラーをレポートしてから SQL スレッドを停止します。つまり、<code class="literal">Slave_SQL_Running</code> にまだ <code class="literal">Yes</code> が表示されているにもかかわらず、<code class="literal">SHOW SLAVE STATUS</code> が <code class="literal">Last_SQL_Errno</code> に対して 0 以外の値を示す短い時間帯が存在します。
            </p></div></li><li class="listitem"><p>
            <code class="literal">Skip_Counter</code>
          </p><p>
            <code class="literal">sql_slave_skip_counter</code> システム変数の現在の値。<a class="xref" href="sql-syntax.html#set-global-sql-slave-skip-counter" title="13.4.2.4 SET GLOBAL sql_slave_skip_counter 構文">セクション13.4.2.4「SET GLOBAL sql_slave_skip_counter 構文」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">Exec_Master_Log_Pos</code>
          </p><p>
            現在のマスターバイナリログファイル内の、SQL スレッドが処理対象の次のトランザクションまたはイベントの先頭をマークしながら読み取って実行した最後の位置。既存のスレーブから新しいスレーブを起動するときに、その新しいスレーブがこの位置から読み取りを開始するように、<code class="literal">CHANGE MASTER TO</code> ステートメントの <code class="literal">MASTER_LOG_POS</code> オプションでこの値を使用できます。マスターのバイナリログ内の (<code class="literal">Relay_Master_Log_File</code>、<code class="literal">Exec_Master_Log_Pos</code>) で指定される座標は、リレーログ内の (<code class="literal">Relay_Log_File</code>、<code class="literal">Relay_Log_Pos</code>) で指定される座標に対応します。
          </p><p>
            (MySQL 5.6.3 以降で <code class="literal">slave_parallel_workers</code> を 0 以外の値に設定することによって) マルチスレッドスレーブを使用している場合は、このカラム内の値が実際に、コミットされていないトランザクションがその前には残っていない<span class="quote">「<span class="quote">低位境界</span>」</span>値を表します。現在の実装では、別のデータベース上のトランザクションをスレーブ上でマスター上とは異なる順序で実行することが許可されるため、これは必ずしも、直近で実行されたトランザクションの位置ではありません。
          </p></li><li class="listitem"><p>
            <code class="literal">Relay_Log_Space</code>
          </p><p>
            既存のすべてのリレーログファイルの合計サイズ。
          </p></li><li class="listitem"><p>
            <code class="literal">Until_Condition</code>、<code class="literal">Until_Log_File</code>、<code class="literal">Until_Log_Pos</code>
          </p><p>
            <code class="literal">START SLAVE</code> ステートメントの <code class="literal">UNTIL</code> 句で指定された値。
          </p><p>
            <code class="literal">Until_Condition</code> の値は次のとおりです。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">UNTIL</code> 句が指定されなかった場合は <code class="literal">None</code>
              </p></li><li class="listitem"><p>
                このスレーブがマスターのバイナリログ内の特定の位置まで読み取っている場合は <code class="literal">Master</code>
              </p></li><li class="listitem"><p>
                このスレーブがそのリレーログ内の特定の位置まで読み取っている場合は <code class="literal">Relay</code>
              </p></li></ul></div><p>
            MySQL 5.6.6 からは、次の値を持つ、GTID に関連した <code class="literal">UNTIL</code> 句が追加されました。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                スレーブ SQL スレッドが、<code class="literal">gtid_set</code> に GTID がリストされている最初のトランザクションに達するまでトランザクションを処理している場合は、<code class="literal">SQL_BEFORE_GTIDS</code>。
              </p></li><li class="listitem"><p>
                スレーブスレッドが、<code class="literal">gtid_set</code> 内の最後のトランザクションが両方のスレッドによって処理されるまですべてのトランザクションを処理している場合は、<code class="literal">SQL_AFTER_GTIDS</code>。
              </p></li><li class="listitem"><p>
                マルチスレッドスレーブの SQL スレッドが、リレーログ内にそれ以上ギャップが見つからなくなるまで実行する場合は <code class="literal">SQL_AFTER_MTS_GAPS</code>。
              </p></li></ul></div><p>
            <code class="literal">Until_Log_File</code> と <code class="literal">Until_Log_Pos</code> は、ログファイルの名前と、SQL スレッドが実行を停止する座標を定義している位置を示します。
          </p><p>
            <code class="literal">UNTIL</code> 句の詳細は、<a class="xref" href="sql-syntax.html#start-slave" title="13.4.2.5 START SLAVE 構文">セクション13.4.2.5「START SLAVE 構文」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">Master_SSL_Allowed</code>、<code class="literal">Master_SSL_CA_File</code>、<code class="literal">Master_SSL_CA_Path</code>、<code class="literal">Master_SSL_Cert</code>、<code class="literal">Master_SSL_Cipher</code>、<code class="literal">Master_SSL_CRL_File</code>、<code class="literal">Master_SSL_CRL_Path</code>、<code class="literal">Master_SSL_Key</code>、<code class="literal">Master_SSL_Verify_Server_Cert</code>
          </p><p>
            これらのフィールドは、このスレーブがマスターに接続するために使用する SSL パラメータを表示します (存在する場合)。
          </p><p>
            <code class="literal">Master_SSL_Allowed</code> の値は次のとおりです。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                マスターへの SSL 接続が許可されている場合は <code class="literal">Yes</code>
              </p></li><li class="listitem"><p>
                マスターへの SSL 接続が許可されていない場合は <code class="literal">No</code>
              </p></li><li class="listitem"><p>
                SSL 接続は許可されているが、スレーブサーバーで SSL サポートが有効になっていない場合は <code class="literal">Ignored</code>
              </p></li></ul></div><p>
            その他の SSL 関連フィールドの値は、<code class="literal">CHANGE MASTER TO</code> ステートメントに対する <code class="literal">MASTER_SSL_CA</code>、<code class="literal">MASTER_SSL_CAPATH</code>、<code class="literal">MASTER_SSL_CERT</code>、<code class="literal">MASTER_SSL_CIPHER</code>、<code class="literal">MASTER_SSL_CRL</code>、<code class="literal">MASTER_SSL_CRLPATH</code>、<code class="literal">MASTER_SSL_KEY</code>、および <code class="literal">MASTER_SSL_VERIFY_SERVER_CERT</code> オプションの値に対応します。<a class="xref" href="sql-syntax.html#change-master-to" title="13.4.2.1 CHANGE MASTER TO 構文">セクション13.4.2.1「CHANGE MASTER TO 構文」</a>を参照してください。
          </p><p>
            <code class="literal">Master_SSL_CRL_File</code> と <code class="literal">Master_SSL_CRL_Path</code> は MySQL 5.6.3 で追加されました。
          </p></li><li class="listitem"><p>
            <code class="literal">Seconds_Behind_Master</code>
          </p><p>
            このフィールドは、このスレーブがどれだけ<span class="quote">「<span class="quote">遅延している</span>」</span>かを示します。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                このスレーブが更新をアクティブに処理している場合、このフィールドは、現在このスレーブ上で処理されている最新のイベントに対するスレーブ上の現在のタイムスタンプと、マスター上でログに記録されている元のタイムスタンプの違いを示します。
              </p></li><li class="listitem"><p>
                現在このスレーブ上でイベントが処理されていない場合、この値は 0 です。
              </p></li></ul></div><p>
            基本的に、このフィールドは、スレーブ SQL スレッドとスレーブ I/O スレッドの間の時間差 (秒単位) を測定します。マスターとスレーブの間のネットワーク接続が高速である場合は、スレーブ I/O スレッドがマスターに非常に近いため、このフィールドは、スレーブ SQL スレッドがマスターに比べてどれだけ遅延しているかを示す良い近似値になります。このネットワークが低速である場合、これは良い近似値では<span class="emphasis"><em>ありません</em></span>。スレーブ SQL スレッドが、読み取りの遅いスレーブ I/O スレッドに非常に頻繁に追い付かれる可能性があるため、I/O スレッドがマスターに比べて遅延している場合でも、<code class="literal">Seconds_Behind_Master</code> は多くの場合 0 の値を示します。つまり、<span class="emphasis"><em>このカラムは高速ネットワークの場合にのみ有効です</em></span>。
          </p><p>
            この時間差の計算は、スレーブ I/O スレッドの起動時に計算された時間差がそれ以降も一定のままであれば、マスターとスレーブのクロック時間が同じでない場合でも機能します。何らかの変更 (NTP の更新を含む) があると、<code class="literal">Seconds_Behind_Master</code> の計算の信頼性を低下させるクロックスキューが発生する場合があります。
          </p><p>
            MySQL 5.6.9 以降では、このフィールドは、スレーブ SQL スレッドが実行されていない場合、または SQL スレッドがすべてのリレーログを消費し、かつスレーブ I/O スレッドが実行されていない場合に <code class="literal">NULL</code> (未定義または不明) になります。以前は、このフィールドは、スレーブ SQL スレッドまたはスレーブ I/O スレッドが実行されていないか、あるいはマスターに接続されていない場合に <code class="literal">NULL</code> になりました。(Bug #12946333) たとえば、(MySQL 5.6.9 より前) スレーブ I/O スレッドが実行されているが、マスターに接続されておらず、再接続の前に <code class="literal">CHANGE MASTER TO</code> ステートメントまたは <code class="option">--master-connect-retry</code> オプションで指定された秒数 (デフォルトは 60) だけスリープしている場合、この値は <code class="literal">NULL</code> でした。現在、このようなケースでは、マスターへの接続はテストされません。代わりに、I/O スレッドが実行されているが、リレーログが使い果たされた場合は、<code class="literal">Seconds_Behind_Master</code> が 0 に設定されます。
          </p><p>
            <code class="literal">Seconds_Behind_Master</code> の値は、イベント内に格納されているタイムスタンプに基づいており、このタイムスタンプはレプリケーションを通して保持されます。つまり、マスター M1 がそれ自体 M0 のスレーブである場合、M0 のバイナリログに起因する M1 のバイナリログからのイベントはすべて、そのイベントに M0 のタイムスタンプを含んでいます。これにより、MySQL は <code class="literal">TIMESTAMP</code> を正常にレプリケートできます。ただし、<code class="literal">Seconds_Behind_Master</code> に関する問題は、M1 がクライアントからの直接の更新も受信した場合、M1 からの最後のイベントがときには M0 に起因し、またときには M1 上での直接の更新の結果であるため、<code class="literal">Seconds_Behind_Master</code> 値がランダムに変動することにあります。
          </p><p>
            マルチスレッドスレーブ (MySQL 5.6.3 以降) を使用している場合は、この値が <code class="literal">Exec_Master_Log_Pos</code> に基づいているため、直近でコミットされたトランザクションの位置を反映していない可能性があります。
          </p></li><li class="listitem"><p>
            <code class="literal">Last_IO_Errno</code>、<code class="literal">Last_IO_Error</code>
          </p><p>
            I/O スレッドを停止させた最新のエラーのエラー番号とエラーメッセージ。0 のエラー番号および空の文字列のメッセージは、<span class="quote">「<span class="quote">エラーなし</span>」</span>を示します。<code class="literal">Last_IO_Error</code> 値が空でない場合、このエラー値はスレーブのエラーログにも現れます。
          </p><p>
            MySQL 5.6.1 から、I/O エラーの情報には、最新の I/O スレッドエラーがいつ発生したかを示すタイムスタンプが含まれています。このタイムスタンプには、<code class="literal">YYMMDD HH:MM:SS</code> という形式が使用されます。
          </p><p>
            MySQL 5.6.3 より前は、このタイムスタンプは、<code class="literal">Last_IO_Error</code> カラムに表示されるエラーメッセージテキストの前に付加されました。MySQL 5.6.3 以降では、このタイムスタンプは、代わりに <code class="literal">Last_SQL_Error_Timestamp</code> カラムに表示されます。
          </p><p>
            <code class="literal">RESET MASTER</code> または <code class="literal">RESET SLAVE</code> を発行すると、これらのカラムに表示されている値がリセットされます。
          </p></li><li class="listitem"><p>
            <code class="literal">Last_SQL_Errno</code>、<code class="literal">Last_SQL_Error</code>
          </p><p>
            SQL スレッドを停止させた最新のエラーのエラー番号とエラーメッセージ。0 のエラー番号および空の文字列のメッセージは、<span class="quote">「<span class="quote">エラーなし</span>」</span>を示します。<code class="literal">Last_SQL_Error</code> 値が空でない場合、このエラー値はスレーブのエラーログにも現れます。
          </p><p>
            MySQL 5.6.1 から、SQL エラーの情報には、最新の SQL スレッドエラーがいつ発生したかを示すタイムスタンプが含まれています。このタイムスタンプには、<code class="literal">YYMMDD HH:MM:SS</code> という形式が使用されます。
          </p><p>
            MySQL 5.6.3 より前は、このタイムスタンプは、<code class="literal">Last_SQL_Error</code> カラムに表示されるエラーメッセージテキストの前に付加されました。MySQL 5.6.3 以降では、このタイムスタンプは、代わりに <code class="literal">Last_SQL_Error_Timestamp</code> カラムに表示されます。
          </p><p>
            <code class="literal">RESET MASTER</code> または <code class="literal">RESET SLAVE</code> を発行すると、これらのカラムに表示されている値がリセットされます。
          </p></li><li class="listitem"><p>
            <code class="literal">Replicate_Ignore_Server_Ids</code>
          </p><p>
            MySQL 5.6 では、<code class="literal">CHANGE MASTER TO</code> ステートメントの <code class="literal">IGNORE_SERVER_IDS</code> オプションを使用して、0 以上のマスターからのイベントを無視するようにスレーブを設定します。これはデフォルトではブランクであり、通常は、循環またはその他のマルチマスターレプリケーションセットアップを使用している場合にのみ変更されます。ブランクでないときに <code class="literal">Replicate_Ignore_Server_Ids</code> に表示されるメッセージは、無視されるサーバー ID を示す 1 つ以上の番号のカンマ区切りリストで構成されます。例:
          </p><pre class="programlisting">
	Replicate_Ignore_Server_Ids: 2, 6, 9
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              <code class="literal">Ignored_server_ids</code> も無視されるサーバー ID を示しますが、これは、無視されるサーバー ID の総数が前にあるスペースで区切られたリストです。たとえば、サーバー ID 2、6、または 9 を持つマスターを無視するようスレーブに指示するために <code class="literal">IGNORE_SERVER_IDS = (2,6,9)</code> オプションを含む <code class="literal">CHANGE MASTER TO</code> ステートメントが発行された場合、その情報は次のように表示されます。
            </p><pre class="programlisting">
	Ignored_server_ids: 3 2 6 9
</pre><p>
              ここで、<code class="literal">3</code> は、無視されるサーバー ID の総数です。
            </p></div><p>
            <code class="literal">Replicate_Ignore_Server_Ids</code> のフィルタリングは SQL スレッドではなく、I/O スレッドによって実行されます。つまり、フィルタで除外されるイベントはリレーログに書き込まれません。これは、SQL スレッドに適用される <code class="option">--replicate-do-table</code> などのサーバーオプションによって実行されるフィルタリングアクションとは異なります。
          </p></li><li class="listitem"><p>
            <code class="literal">Master_Server_Id</code>
          </p><p>
            マスターからの <code class="literal">server_id</code> 値。
          </p></li><li class="listitem"><p>
            <code class="literal">Master_UUID</code>
          </p><p>
            マスターからの <code class="literal">server_uuid</code> 値。このフィールドは、MySQL 5.6.0 で追加されました。
          </p></li><li class="listitem"><p>
            <code class="literal">Master_Info_File</code>
          </p><p>
            <code class="filename">master.info</code> ファイルの場所。このフィールドは、MySQL 5.6.0 で追加されました。
          </p></li><li class="listitem"><p>
            <code class="literal">SQL_Delay</code>
          </p><p>
            このスレーブがマスターから遅延する必要がある秒数。このフィールドは、MySQL 5.6.0 で追加されました。
          </p></li><li class="listitem"><p>
            <code class="literal">SQL_Remaining_Delay</code>
          </p><p>
            <code class="literal">Slave_SQL_Running_State</code> が <code class="literal">Waiting until MASTER_DELAY seconds after master executed event</code> である場合、このフィールドには残りの遅延秒数が含まれます。ほかのときは、このフィールドは <code class="literal">NULL</code> です。このフィールドは、MySQL 5.6.0 で追加されました。
          </p></li><li class="listitem"><p>
            <code class="literal">Slave_SQL_Running_State</code>
          </p><p>
            SQL スレッドの状態 (<code class="literal">Slave_IO_State</code> に類似しています)。この値は、<code class="literal">SHOW PROCESSLIST</code> によって表示される SQL スレッドの <code class="literal">State</code> 値と同じです。<a class="xref" href="optimization.html#slave-sql-thread-states" title="8.12.5.7 レプリケーションスレーブ SQL スレッドの状態">セクション8.12.5.7「レプリケーションスレーブ SQL スレッドの状態」</a>には、可能性のある状態のリストが示されています。このフィールドは、MySQL 5.6.0 で追加されました。
          </p></li><li class="listitem"><p>
            <code class="literal">Master_Retry_Count</code>
          </p><p>
            接続が失われた場合に、このスレーブがマスターへの再接続を試みることができる回数。この値は、<code class="literal">CHANGE MASTER TO</code> ステートメントの <code class="literal">MASTER_RETRY_COUNT</code> オプション (推奨)、または古い <code class="option">--master-retry-count</code> サーバーオプション (下位互換性のために引き続きサポートされています) を使用して設定できます。このフィールドは、MySQL 5.6.1 で追加されました。
          </p></li><li class="listitem"><p>
            <code class="literal">Master_Bind</code>
          </p><p>
            このスレーブのバインド先のネットワークインタフェース (存在する場合)。これは、<code class="literal">CHANGE MASTER TO</code> ステートメントの <code class="literal">MASTER_BIND</code> オプションを使用して設定されます。
          </p><p>
            このカラムは、MySQL 5.6.2 で追加されました。
          </p></li><li class="listitem"><p>
            <code class="literal">Last_IO_Error_Timestamp</code>
          </p><p>
            最新の I/O エラーがいつ発生したかを示す <code class="literal">YYMMDD HH:MM:SS</code> 形式のタイムスタンプ。
          </p><p>
            このカラムは、MySQL 5.6.3 で追加されました。以前 MySQL 5.6 では、このタイムスタンプは、<code class="literal">Last_IO_Error</code> に表示されるエラーテキストの前に付加されました。
          </p></li><li class="listitem"><p>
            <code class="literal">Last_SQL_Error_Timestamp</code>
          </p><p>
            最新の SQL エラーがいつ発生したかを示す <code class="literal">YYMMDD HH:MM:SS</code> 形式のタイムスタンプ。
          </p><p>
            このカラムは、MySQL 5.6.3 で追加されました。以前 MySQL 5.6 では、このタイムスタンプは、<code class="literal">Last_SQL_Error</code> に表示されるエラーテキストの前に付加されました。
          </p></li><li class="listitem"><p>
            <code class="literal">Retrieved_Gtid_Set</code>
          </p><p>
            このスレーブによって受信されたすべてのトランザクションに対応するグローバルトランザクション ID のセット。GTID が使用されていない場合は空です。
          </p><p>
            これは、リレーログ内に存在するか、またはこれまでに存在したすべての GTID のセットです。各 GTID は、<code class="literal">Gtid_log_event</code> が受信されるとすぐに追加されます。そのため、このセットには、部分的に転送されたトランザクションの GTID も含まれる場合があります。
          </p><p>
            <code class="literal">RESET SLAVE</code> または <code class="literal">CHANGE MASTER TO</code> を実行したため、あるいは <code class="option">--relay-log-recovery</code> オプションの効果のためにすべてのリレーログが失われた場合は、このセットがクリアされます。<code class="literal">relay_log_purge = 1</code> のときは、最新のリレーログが常に保持されるため、このセットはクリアされません。
          </p><p>
            このカラムは、MySQL 5.6.5 で追加されました。
          </p><p>
            MySQL 5.6.10 より前は、この値は大文字で出力されました。MySQL 5.6.10 以降では、常に小文字で出力されます。(Bug #15869441)
          </p></li><li class="listitem"><p>
            <code class="literal">Executed_Gtid_Set</code>
          </p><p>
            バイナリログに書き込まれたグローバルトランザクション ID のセット。これは、このサーバー上のグローバルな <code class="literal">gtid_executed</code> システム変数 (MySQL 5.6.9 より前の名前は <code class="literal">gtid_done</code>) の値や、このサーバー上での <code class="literal">SHOW MASTER STATUS</code> の出力内の <code class="literal">Executed_Gtid_Set</code> の値と同じです。GTID が使用されていない場合は空です。
          </p><p>
            このカラムは、MySQL 5.6.5 で追加されました。
          </p><p>
            MySQL 5.6.10 より前は、この値は大文字で出力されました。MySQL 5.6.10 以降では、常に小文字で出力されます。(Bug #15869441)
          </p></li><li class="listitem"><p>
            <code class="literal">Auto_Position</code>
          </p><p>
            自動ポジショニングが使用されている場合は 1、それ以外の場合は 0。
          </p><p>
            このカラムは、MySQL 5.6.10 で追加されました。(Bug #15992220)
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-status"></a>13.7.5.36 SHOW STATUS 構文</h4></div></div></div><a class="indexterm" name="idm139979076602736"></a><a class="indexterm" name="idm139979076601296"></a><pre class="programlisting">
SHOW [GLOBAL | SESSION] STATUS
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><a class="indexterm" name="idm139979076595744"></a><p>
        <code class="literal">SHOW STATUS</code> は、サーバーステータス情報を提供します。この情報はまた、<span class="command"><strong>mysqladmin extended-status</strong></span> コマンドを使用して取得することもできます。<code class="literal">LIKE</code> 句 (存在する場合) は、どの変数名と照合するかを示します。<a class="xref" href="information-schema.html#extended-show" title="21.32 SHOW ステートメントの拡張">セクション21.32「SHOW ステートメントの拡張」</a>で説明されているように、<code class="literal">WHERE</code> 句を指定すると、より一般的な条件を使用して行を選択できます。このステートメントにはどの権限も必要ありません。これには、サーバーに接続できることのみが必要です。
      </p><p>
        部分的な出力を次に示します。名前と値のリストが、実際のサーバーでは異なることがあります。各変数の意味は、<a class="xref" href="server-administration.html#server-status-variables" title="5.1.6 サーバーステータス変数">セクション5.1.6「サーバーステータス変数」</a>に示されています。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW STATUS;</code></strong>
+--------------------------+------------+
| Variable_name            | Value      |
+--------------------------+------------+
| Aborted_clients          | 0          |
| Aborted_connects         | 0          |
| Bytes_received           | 155372598  |
| Bytes_sent               | 1176560426 |
| Connections              | 30023      |
| Created_tmp_disk_tables  | 0          |
| Created_tmp_tables       | 8340       |
| Created_tmp_files        | 60         |
...
| Open_tables              | 1          |
| Open_files               | 2          |
| Open_streams             | 0          |
| Opened_tables            | 44600      |
| Questions                | 2026873    |
...
| Table_locks_immediate    | 1920382    |
| Table_locks_waited       | 0          |
| Threads_cached           | 0          |
| Threads_created          | 30022      |
| Threads_connected        | 1          |
| Threads_running          | 1          |
| Uptime                   | 80380      |
+--------------------------+------------+
</pre><p>
        <code class="literal">LIKE</code> 句を指定すると、このステートメントは、そのパターンに一致する名前を持つ変数の行のみを表示します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW STATUS LIKE 'Key%';</code></strong>
+--------------------+----------+
| Variable_name      | Value    |
+--------------------+----------+
| Key_blocks_used    | 14955    |
| Key_read_requests  | 96854827 |
| Key_reads          | 162040   |
| Key_write_requests | 7589728  |
| Key_writes         | 3813196  |
+--------------------+----------+
</pre><p>
        <code class="literal">GLOBAL</code> 修飾子を指定すると、<code class="literal">SHOW STATUS</code> は、MySQL へのすべての接続のステータス値を表示します。<code class="literal">SESSION</code> を指定すると、現在の接続のステータス値を表示します。修飾子が存在しない場合、デフォルトは <code class="literal">SESSION</code> です。<code class="literal">LOCAL</code> は <code class="literal">SESSION</code> のシノニムです。
      </p><p>
        一部のステータス変数にはグローバル値しかありません。これらの変数では、<code class="literal">GLOBAL</code> と <code class="literal">SESSION</code> の両方に同じ値が表示されます。各ステータス変数のスコープは、<a class="xref" href="server-administration.html#server-status-variables" title="5.1.6 サーバーステータス変数">セクション5.1.6「サーバーステータス変数」</a>に示されています。
      </p><p>
        <code class="literal">SHOW STATUS</code> ステートメントを呼び出すたびに内部一時テーブルが使用され、グローバルの <code class="literal">Created_tmp_tables</code> 値が増加します。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-table-status"></a>13.7.5.37 SHOW TABLE STATUS 構文</h4></div></div></div><a class="indexterm" name="idm139979076567456"></a><a class="indexterm" name="idm139979076565312"></a><a class="indexterm" name="idm139979076563248"></a><pre class="programlisting">
SHOW TABLE STATUS [{FROM | IN} <em class="replaceable"><code>db_name</code></em>]
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
        <code class="literal">SHOW TABLE STATUS</code> は <code class="literal">SHOW TABLES</code> のように機能しますが、<code class="literal">TEMPORARY</code> 以外の各テーブルに関する多くの情報を提供します。このリストはまた、<span class="command"><strong>mysqlshow --status <em class="replaceable"><code>db_name</code></em></strong></span> コマンドを使用して取得することもできます。<code class="literal">LIKE</code> 句 (存在する場合) は、どのテーブル名と照合するかを示します。<a class="xref" href="information-schema.html#extended-show" title="21.32 SHOW ステートメントの拡張">セクション21.32「SHOW ステートメントの拡張」</a>で説明されているように、<code class="literal">WHERE</code> 句を指定すると、より一般的な条件を使用して行を選択できます。
      </p><p>
        このステートメントはまた、ビューに関する情報も表示します。
      </p><p>
        <code class="literal">SHOW TABLE STATUS</code> の出力には、次のカラムがあります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Name</code>
          </p><p>
            テーブルの名前。
          </p></li><li class="listitem"><p>
            <code class="literal">Engine</code>
          </p><p>
            このテーブルのストレージエンジン。<a class="xref" href="storage-engines.html" title="第 15 章 代替ストレージエンジン">第15章「<i>代替ストレージエンジン</i>」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">Version</code>
          </p><p>
            このテーブルの <code class="filename">.frm</code> ファイルのバージョン番号。
          </p></li><li class="listitem"><p>
            <code class="literal">Row_format</code>
          </p><p>
            行ストレージフォーマット (<code class="literal">Fixed</code>、<code class="literal">Dynamic</code>、<code class="literal">Compressed</code>、<code class="literal">Redundant</code>、<code class="literal">Compact</code>)。<code class="literal">MyISAM</code> テーブルの場合、<code class="literal">Dynamic</code> は、<span class="command"><strong>myisamchk -dvv</strong></span> が <code class="literal">Packed</code> としてレポートするものに対応します。<code class="literal">InnoDB</code> テーブルのフォーマットは、<code class="literal">Redundant</code> または <code class="literal">Compact</code> としてレポートされます。<code class="literal">InnoDB Plugin</code> の <code class="literal">Barracuda</code> ファイル形式の場合、このフォーマットは <code class="literal">Compressed</code> または <code class="literal">Dynamic</code> である可能性があります。
          </p></li><li class="listitem"><p>
            <code class="literal">Rows</code>
          </p><p>
            行数。<code class="literal">MyISAM</code> などの一部のストレージエンジンは、正確な数を格納します。<code class="literal">InnoDB</code> などのその他のストレージエンジンの場合、この値は近似値であり、実際の値から 40 から 50% 変動する可能性があります。このような場合、正確な数を取得するには <code class="literal">SELECT COUNT(*)</code> を使用します。
          </p><p>
            <code class="literal">INFORMATION_SCHEMA</code> データベース内のテーブルの場合、<code class="literal">Rows</code> 値は <code class="literal">NULL</code> です。
          </p></li><li class="listitem"><p>
            <code class="literal">Avg_row_length</code>
          </p><p>
            平均行長。
          </p></li><li class="listitem"><p>
            <code class="literal">Data_length</code>
          </p><p>
            データファイルの長さ。
          </p></li><li class="listitem"><p>
            <code class="literal">Max_data_length</code>
          </p><p>
            データファイルの最大長。これは、このテーブル内に格納できるデータの合計バイト数です (使用されるデータポインタサイズが指定された場合)。
          </p></li><li class="listitem"><p>
            <code class="literal">Index_length</code>
          </p><p>
            インデックスファイルの長さ。
          </p></li><li class="listitem"><p>
            <code class="literal">Data_free</code>
          </p><p>
            割り当てられているが、使用されていないバイト数。
          </p><p>
            この情報はまた、<code class="literal">InnoDB</code> テーブルに対しても示されます (以前は、<code class="literal">Comment</code> 値に含まれていました)。<code class="literal">InnoDB</code> テーブルは、このテーブルが属するテーブルスペースの空き領域をレポートします。共有テーブルスペース内に存在するテーブルの場合、これはその共有テーブルスペースの空き領域です。複数のテーブルスペースを使用していて、このテーブルに独自のテーブルスペースがある場合は、そのテーブルのみの空き領域になります。空き領域とは、完全な空きエクステントから安全上のマージンを引いたバイト数を示します。空き領域が 0 として表示されている場合でも、新しいエクステントを割り当てる必要がないかぎり、行を挿入できる可能性があります。
          </p><p>
            パーティション化されたテーブルの場合、この値は推定値にすぎず、絶対的に正しいとはかぎりません。このような場合、この情報を取得するためのより正確な方法は、次の例に示すように <code class="literal">INFORMATION_SCHEMA.PARTITIONS</code> テーブルへのクエリーです。
          </p><pre class="programlisting">
SELECT    SUM(DATA_FREE)
    FROM  INFORMATION_SCHEMA.PARTITIONS
    WHERE TABLE_SCHEMA = 'mydb'
    AND   TABLE_NAME   = 'mytable';
</pre><p>
            詳細は、<a class="xref" href="information-schema.html#partitions-table" title="21.13 INFORMATION_SCHEMA PARTITIONS テーブル">セクション21.13「INFORMATION_SCHEMA PARTITIONS テーブル」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">Auto_increment</code>
          </p><p>
            次の <code class="literal">AUTO_INCREMENT</code> 値。
          </p></li><li class="listitem"><p>
            <code class="literal">Create_time</code>
          </p><p>
            いつテーブルが作成されたか。
          </p></li><li class="listitem"><p>
            <code class="literal">Update_time</code>
          </p><p>
            いつデータファイルが最後に更新されたか。一部のストレージエンジンでは、この値は <code class="literal">NULL</code> です。たとえば、<code class="literal">InnoDB</code> はその<a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">システムテーブルスペース</a>内に複数のテーブルを格納するため、データファイルのタイムスタンプは適用されません。各 <code class="literal">InnoDB</code> テーブルが個別の <code class="literal">.ibd</code> ファイル内に存在する <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> モードの場合でも、<a class="link" href="glossary.html#glos_change_buffering" title="変更バッファリング">変更バッファリング</a>によってデータファイルへの書き込みが遅延される可能性があるため、ファイルの変更時間は最後の挿入、更新、または削除の時間とは異なります。<code class="literal">MyISAM</code> の場合は、データファイルのタイムスタンプが使用されます。ただし、Windows ではタイムスタンプが更新によって更新されないため、この値は不正確です。
          </p></li><li class="listitem"><p>
            <code class="literal">Check_time</code>
          </p><p>
            いつテーブルが最後にチェックされたか。すべてのストレージエンジンがこの時間を更新するわけではありません。その場合、この値は常に <code class="literal">NULL</code> です。
          </p></li><li class="listitem"><p>
            <code class="literal">Collation</code>
          </p><p>
            このテーブルの文字セットと照合順序。
          </p></li><li class="listitem"><p>
            <code class="literal">Checksum</code>
          </p><p>
            ライブチェックサム値 (存在する場合)。
          </p></li><li class="listitem"><p>
            <code class="literal">Create_options</code>
          </p><p>
            <code class="literal">CREATE TABLE</code> で使用される追加のオプション。<code class="literal">CREATE TABLE</code> が呼び出されるときに指定される元のオプションは保持されており、ここでレポートされるオプションは、アクティブなテーブル設定やオプションとは異なる可能性があります。
          </p></li><li class="listitem"><p>
            <code class="literal">Comment</code>
          </p><p>
            このテーブルを作成するときに使用されたコメント (または、MySQL がテーブル情報にアクセスできなかった理由に関する情報)。
          </p></li></ul></div><p>
        <code class="literal">MEMORY</code> テーブルの場合、<code class="literal">Data_length</code>、<code class="literal">Max_data_length</code>、および <code class="literal">Index_length</code> 値はほぼ、割り当てられているメモリーの実際の量を表します。割り当てアルゴリズムは、割り当て操作の数を減らすために、大量のメモリーを確保します。
      </p><p>
        <code class="literal">NDB</code> テーブルの場合、このステートメントの出力は <code class="literal">Avg_row_length</code> および <code class="literal">Data_length</code> カラムの適切な値を示しますが、例外として <code class="literal">BLOB</code> カラムは考慮に入れられません。
      </p><p>
        ビューの場合は、<code class="literal">Name</code> がビュー名を示し、<code class="literal">Comment</code> が <code class="literal">view</code> になる点を除き、<code class="literal">SHOW TABLE STATUS</code> によって表示されるすべてのフィールドが <code class="literal">NULL</code> です。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-tables"></a>13.7.5.38 SHOW TABLES 構文</h4></div></div></div><a class="indexterm" name="idm139979076458400"></a><a class="indexterm" name="idm139979076455040"></a><pre class="programlisting">
SHOW [FULL] TABLES [{FROM | IN} <em class="replaceable"><code>db_name</code></em>]
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
        <code class="literal">SHOW TABLES</code> は、特定のデータベース内の <code class="literal">TEMPORARY</code> 以外のテーブルを一覧表示します。このリストはまた、<span class="command"><strong>mysqlshow <em class="replaceable"><code>db_name</code></em></strong></span> コマンドを使用して取得することもできます。<code class="literal">LIKE</code> 句 (存在する場合) は、どのテーブル名と照合するかを示します。<a class="xref" href="information-schema.html#extended-show" title="21.32 SHOW ステートメントの拡張">セクション21.32「SHOW ステートメントの拡張」</a>で説明されているように、<code class="literal">WHERE</code> 句を指定すると、より一般的な条件を使用して行を選択できます。
      </p><p>
        <code class="literal">LIKE</code> 句によって実行される照合は、<code class="literal">lower_case_table_names</code> システム変数の設定に依存します。
      </p><p>
        このステートメントはまた、このデータベース内のビューもすべて一覧表示します。<code class="literal">FULL</code> 修飾子は、<code class="literal">SHOW FULL TABLES</code> が 2 番目の出力カラムを表示するようにサポートされます。2 番目のカラムの値は、テーブルの場合は <code class="literal">BASE TABLE</code>、ビューの場合は <code class="literal">VIEW</code> です。
      </p><p>
        ベーステーブルまたはビューに対する権限を持っていない場合、そのテーブルまたはビューは <code class="literal">SHOW TABLES</code> または <span class="command"><strong>mysqlshow db_name</strong></span> の出力に表示されません。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-triggers"></a>13.7.5.39 SHOW TRIGGERS 構文</h4></div></div></div><a class="indexterm" name="idm139979076432032"></a><a class="indexterm" name="idm139979076430608"></a><a class="indexterm" name="idm139979076429248"></a><pre class="programlisting">
SHOW TRIGGERS [{FROM | IN} <em class="replaceable"><code>db_name</code></em>]
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><p>
        <code class="literal">SHOW TRIGGERS</code> は、データベース (<code class="literal">FROM</code> 句が指定されていないかぎり、デフォルトデータベース) 内のテーブルに対して現在定義されているトリガーを一覧表示します。このステートメントは、ユーザーが <code class="literal">TRIGGER</code> 権限を持っているデータベースとテーブルに対してのみ結果を返します。<code class="literal">LIKE</code> 句 (存在する場合) は、(トリガー名ではなく) どのテーブル名と照合するかを示し、このステートメントでそのテーブルのトリガーを表示するようにします。<a class="xref" href="information-schema.html#extended-show" title="21.32 SHOW ステートメントの拡張">セクション21.32「SHOW ステートメントの拡張」</a>で説明されているように、<code class="literal">WHERE</code> 句を指定すると、より一般的な条件を使用して行を選択できます。
      </p><p>
        <a class="xref" href="stored-programs-views.html#triggers" title="20.3 トリガーの使用">セクション20.3「トリガーの使用」</a>で定義されているトリガー <code class="literal">ins_sum</code> の場合、このステートメントの出力は次に示すようになります。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW TRIGGERS LIKE 'acc%'\G</code></strong>
*************************** 1. row ***************************
             Trigger: ins_sum
               Event: INSERT
               Table: account
           Statement: SET @sum = @sum + NEW.amount
              Timing: BEFORE
             Created: NULL
            sql_mode: NO_ENGINE_SUBSTITUTION
             Definer: me@localhost
character_set_client: utf8
collation_connection: utf8_general_ci
  Database Collation: latin1_swedish_ci
</pre><p>
        <code class="literal">SHOW TRIGGERS</code> の出力には、次のカラムがあります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Trigger</code>: トリガー名。
          </p></li><li class="listitem"><p>
            <code class="literal">Event</code>: このトリガーがアクティブ化される操作の種類。この値は、<code class="literal">'INSERT'</code>、<code class="literal">'UPDATE'</code>、または <code class="literal">'DELETE'</code> です。
          </p></li><li class="listitem"><p>
            <code class="literal">Table</code>: このトリガーが定義されているテーブル。
          </p></li><li class="listitem"><p>
            <code class="literal">Statement</code>: トリガー本体。つまり、このトリガーがアクティブ化されるときに実行されるステートメント。
          </p></li><li class="listitem"><p>
            <code class="literal">Timing</code>: このトリガーが、トリガーイベントの前またはあとのどちらにアクティブ化されるか。値は <code class="literal">'BEFORE'</code> または <code class="literal">'AFTER'</code> です。
          </p></li><li class="listitem"><p>
            <code class="literal">Created</code>: 現在、このカラムの値は常に <code class="literal">NULL</code> です。
          </p></li><li class="listitem"><p>
            <code class="literal">sql_mode</code>: このトリガーが実行されるときに有効な SQL モード。
          </p></li><li class="listitem"><p>
            <code class="literal">Definer</code>: このトリガーを作成したユーザーのアカウント。形式は <code class="literal">'<em class="replaceable"><code>user_name</code></em>'@'<em class="replaceable"><code>host_name</code></em>'</code> です。
          </p></li><li class="listitem"><p>
            <code class="literal">character_set_client</code>: このトリガーが作成されたときの <code class="literal">character_set_client</code> システム変数のセッション値。
          </p></li><li class="listitem"><p>
            <code class="literal">collation_connection</code>: このトリガーが作成されたときの <code class="literal">collation_connection</code> システム変数のセッション値。
          </p></li><li class="listitem"><p>
            <code class="literal">Database Collation</code>: このトリガーが関連付けられているデータベースの照合順序。
          </p></li></ul></div><p>
        また、<code class="literal">TRIGGERS</code> テーブルを含む <code class="literal">INFORMATION_SCHEMA</code> からトリガーオブジェクトに関する情報を取得することもできます。<a class="xref" href="information-schema.html#triggers-table" title="21.26 INFORMATION_SCHEMA TRIGGERS テーブル">セクション21.26「INFORMATION_SCHEMA TRIGGERS テーブル」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-variables"></a>13.7.5.40 SHOW VARIABLES 構文</h4></div></div></div><a class="indexterm" name="idm139979076380000"></a><a class="indexterm" name="idm139979076378560"></a><a class="indexterm" name="idm139979076377200"></a><a class="indexterm" name="idm139979076375168"></a><pre class="programlisting">
SHOW [GLOBAL | SESSION] VARIABLES
    [LIKE '<em class="replaceable"><code>pattern</code></em>' | WHERE <em class="replaceable"><code>expr</code></em>]
</pre><a class="indexterm" name="idm139979076369616"></a><p>
        <code class="literal">SHOW VARIABLES</code> は、MySQL システム変数の値を表示します。この情報はまた、<span class="command"><strong>mysqladmin variables</strong></span> コマンドを使用して取得することもできます。<code class="literal">LIKE</code> 句 (存在する場合) は、どの変数名と照合するかを示します。<a class="xref" href="information-schema.html#extended-show" title="21.32 SHOW ステートメントの拡張">セクション21.32「SHOW ステートメントの拡張」</a>で説明されているように、<code class="literal">WHERE</code> 句を指定すると、より一般的な条件を使用して行を選択できます。このステートメントにはどの権限も必要ありません。これには、サーバーに接続できることのみが必要です。
      </p><p>
        <code class="literal">GLOBAL</code> 修飾子を指定すると、<code class="literal">SHOW VARIABLES</code> は、MySQL への新しい接続に使用される値を表示します。MySQL 5.6 では、変数にグローバル値がない場合、値は表示されません。<code class="literal">SESSION</code> を指定すると、<code class="literal">SHOW VARIABLES</code> は、現在の接続に有効な値を表示します。修飾子が存在しない場合、デフォルトは <code class="literal">SESSION</code> です。<code class="literal">LOCAL</code> は <code class="literal">SESSION</code> のシノニムです。
      </p><p>
        <code class="literal">SHOW VARIABLES</code> は、バージョンに依存する表示幅の制限に従います。完全には表示されない非常に長い値を持つ変数の場合、回避策として <code class="literal">SELECT</code> を使用します。例:
      </p><pre class="programlisting">
SELECT @@GLOBAL.innodb_data_file_path;
</pre><p>
        デフォルトのシステム変数値が適切でない場合は、<span class="command"><strong>mysqld</strong></span> の起動時にコマンドオプションを使用して設定できるほか、そのほとんどは <code class="literal">SET</code> ステートメントで実行時に変更できます。<a class="xref" href="server-administration.html#using-system-variables" title="5.1.5 システム変数の使用">セクション5.1.5「システム変数の使用」</a>および<a class="xref" href="sql-syntax.html#set-statement" title="13.7.4 SET 構文">セクション13.7.4「SET 構文」</a>を参照してください。
      </p><p>
        部分的な出力を次に示します。名前と値のリストが、実際のサーバーでは異なることがあります。<a class="xref" href="server-administration.html#server-system-variables" title="5.1.4 サーバーシステム変数">セクション5.1.4「サーバーシステム変数」</a>では、各変数の意味について説明しています。また、<a class="xref" href="optimization.html#server-parameters" title="8.11.2 サーバーパラメータのチューニング">セクション8.11.2「サーバーパラメータのチューニング」</a>には、そのチューニングに関する情報が示されています。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW VARIABLES;</code></strong>
+-----------------------------------------+---------------------------+
| Variable_name                           | Value                     |
+-----------------------------------------+---------------------------+
| auto_increment_increment                | 1                         |
| auto_increment_offset                   | 1                         |
| autocommit                              | ON                        |
| automatic_sp_privileges                 | ON                        |
| back_log                                | 50                        |
| basedir                                 | /home/jon/bin/mysql-5.5   |
| big_tables                              | OFF                       |
| binlog_cache_size                       | 32768                     |
| binlog_direct_non_transactional_updates | OFF                       |
| binlog_format                           | STATEMENT                 |
| binlog_stmt_cache_size                  | 32768                     |
| bulk_insert_buffer_size                 | 8388608                   |
...
| max_allowed_packet                      | 1048576                   |
| max_binlog_cache_size                   | 18446744073709547520      |
| max_binlog_size                         | 1073741824                |
| max_binlog_stmt_cache_size              | 18446744073709547520      |
| max_connect_errors                      | 10                        |
| max_connections                         | 151                       |
| max_delayed_threads                     | 20                        |
| max_error_count                         | 64                        |
| max_heap_table_size                     | 16777216                  |
| max_insert_delayed_threads              | 20                        |
| max_join_size                           | 18446744073709551615      |
...

| thread_handling                         | one-thread-per-connection |
| thread_stack                            | 262144                    |
| time_format                             | %H:%i:%s                  |
| time_zone                               | SYSTEM                    |
| timed_mutexes                           | OFF                       |
| timestamp                               | 1316689732                |
| tmp_table_size                          | 16777216                  |
| tmpdir                                  | /tmp                      |
| transaction_alloc_block_size            | 8192                      |
| transaction_prealloc_size               | 4096                      |
| tx_isolation                            | REPEATABLE-READ           |
| unique_checks                           | ON                        |
| updatable_views_with_limit              | YES                       |
| version                                 | 5.5.17-log                |
| version_comment                         | Source distribution       |
| version_compile_machine                 | x86_64                    |
| version_compile_os                      | Linux                     |
| wait_timeout                            | 28800                     |
| warning_count                           | 0                         |
+-----------------------------------------+---------------------------+
</pre><p>
        <code class="literal">LIKE</code> 句を指定すると、このステートメントは、そのパターンに一致する名前を持つ変数の行のみを表示します。特定の変数の行を取得するには、<code class="literal">LIKE</code> 句を次に示すように使用します。
      </p><pre class="programlisting">
SHOW VARIABLES LIKE 'max_join_size';
SHOW SESSION VARIABLES LIKE 'max_join_size';
</pre><p>
        名前がパターンと一致する変数のリストを取得するには、<code class="literal">LIKE</code> 句の中で <span class="quote">「<span class="quote"><code class="literal">%</code></span>」</span> のワイルドカード文字を使用します。
      </p><pre class="programlisting">
SHOW VARIABLES LIKE '%size%';
SHOW GLOBAL VARIABLES LIKE '%size%';
</pre><p>
        ワイルドカード文字は、照合されるパターン内のどの場所でも利用できます。厳密には、<span class="quote">「<span class="quote"><code class="literal">_</code></span>」</span> は任意の 1 文字と一致するワイルドカードであるため、文字どおりに照合するには <span class="quote">「<span class="quote"><code class="literal">\_</code></span>」</span> としてエスケープしてください。実際には、これはほとんど必要ありません。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="show-warnings"></a>13.7.5.41 SHOW WARNINGS 構文</h4></div></div></div><a class="indexterm" name="idm139979076324384"></a><a class="indexterm" name="idm139979076323072"></a><pre class="programlisting">
SHOW WARNINGS [LIMIT [<em class="replaceable"><code>offset</code></em>,] <em class="replaceable"><code>row_count</code></em>]
SHOW COUNT(*) WARNINGS
</pre><p>
        <code class="literal">SHOW WARNINGS</code> は、現在のセッションでのステートメントの実行の結果として得られた条件 (エラー、警告、および注意) に関する情報を表示する診断ステートメントです。警告は、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、<code class="literal">LOAD DATA INFILE</code> などの DML ステートメントのほか、<code class="literal">CREATE TABLE</code> や <code class="literal">ALTER TABLE</code> などの DDL ステートメントに対して生成されます。
      </p><p>
        <code class="literal">LIMIT</code> 句の構文は、<code class="literal">SELECT</code> ステートメントの場合と同じです。<a class="xref" href="sql-syntax.html#select" title="13.2.9 SELECT 構文">セクション13.2.9「SELECT 構文」</a>を参照してください。
      </p><p>
        <code class="literal">SHOW WARNINGS</code> はまた、<code class="literal">EXTENDED</code> キーワードが使用されている <code class="literal">EXPLAIN</code> によって生成された追加の情報を表示するために、<code class="literal">EXPLAIN EXTENDED</code> のあとにも使用されます。<a class="xref" href="optimization.html#explain-extended" title="8.8.3 EXPLAIN EXTENDED 出力フォーマット">セクション8.8.3「EXPLAIN EXTENDED 出力フォーマット」</a>を参照してください。
      </p><p>
        <code class="literal">SHOW WARNINGS</code> は、メッセージを生成した、現在のセッションでの最新のステートメントの結果として得られた条件に関する情報を表示します。最新のステートメントがテーブルを使用し、メッセージを生成しなかった場合は、何も表示しません。(つまり、テーブルを使用するが、メッセージを生成しないステートメントはメッセージリストをクリアします。) テーブルを使用せず、メッセージを生成しないステートメントは、メッセージリストに影響を与えません。
      </p><p>
        <code class="literal">SHOW COUNT(*) WARNINGS</code> 診断ステートメントは、エラー、警告、および注意の総数を表示します。この数はまた、<code class="literal">warning_count</code> システム変数からも取得できます。
      </p><pre class="programlisting">
SHOW COUNT(*) WARNINGS;
SELECT @@warning_count;
</pre><p>
        関連する診断ステートメント <code class="literal">SHOW ERRORS</code> はエラー状態のみ (警告と注意は除外されます) を表示し、<code class="literal">SHOW COUNT(*) ERRORS</code> ステートメントはエラーの総数を表示します。<a class="xref" href="sql-syntax.html#show-errors" title="13.7.5.18 SHOW ERRORS 構文">セクション13.7.5.18「SHOW ERRORS 構文」</a>を参照してください。<code class="literal">GET DIAGNOSTICS</code> を使用すると、個々の条件に関する情報を検査できます。<a class="xref" href="sql-syntax.html#get-diagnostics" title="13.6.7.3 GET DIAGNOSTICS 構文">セクション13.6.7.3「GET DIAGNOSTICS 構文」</a>を参照してください。
      </p><p>
        <code class="literal">INSERT</code> でのデータ変換の警告を表示する単純な例を次に示します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (a TINYINT NOT NULL, b CHAR(4));</code></strong>
Query OK, 0 rows affected (0.05 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO t1 VALUES(10,'mysql'), (NULL,'test'), (300,'xyz');</code></strong>
Query OK, 3 rows affected, 3 warnings (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 3

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS\G</code></strong>
*************************** 1. row ***************************
  Level: Warning
   Code: 1265
Message: Data truncated for column 'b' at row 1
*************************** 2. row ***************************
  Level: Warning
   Code: 1048
Message: Column 'a' cannot be null
*************************** 3. row ***************************
  Level: Warning
   Code: 1264
Message: Out of range value for column 'a' at row 3
3 rows in set (0.00 sec)
</pre><p>
        <code class="literal">max_error_count</code> システム変数は、サーバーが情報を格納する対象となるエラー、警告、および注意メッセージの最大数、したがって <code class="literal">SHOW WARNINGS</code> が表示するメッセージの数を制御します。サーバーが格納できるメッセージの数を変更するには、<code class="literal">max_error_count</code> の値を変更します。デフォルトは 64 です。
      </p><p>
        <code class="literal">max_error_count</code> は、カウントされるメッセージの数ではなく、格納されるメッセージの数のみを制御します。生成されたメッセージの数が <code class="literal">max_error_count</code> を超えた場合でも、<code class="literal">warning_count</code> の値は <code class="literal">max_error_count</code> によって制限されません。この点について次の例で説明します。この <code class="literal">ALTER TABLE</code> ステートメントは、3 つの警告メッセージを生成します (この例では、変換の問題が 1 つ発生したあとにエラーが発生しないように、厳密な SQL モードが無効になっています)。<code class="literal">max_error_count</code> が 1 に設定されたため、格納されて表示されたメッセージは 1 つだけですが、<code class="literal">warning_count</code> の値で示されているように 3 つすべてがカウントされています。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'max_error_count';</code></strong>
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| max_error_count | 64    |
+-----------------+-------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SET max_error_count=1, sql_mode = '';</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE t1 MODIFY b CHAR;</code></strong>
Query OK, 3 rows affected, 3 warnings (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 3

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+---------+------+----------------------------------------+
| Level   | Code | Message                                |
+---------+------+----------------------------------------+
| Warning | 1263 | Data truncated for column 'b' at row 1 |
+---------+------+----------------------------------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT @@warning_count;</code></strong>
+-----------------+
| @@warning_count |
+-----------------+
|               3 |
+-----------------+
1 row in set (0.01 sec)
</pre><p>
        メッセージの格納を無効にするには、<code class="literal">max_error_count</code> を 0 に設定します。この場合、<code class="literal">warning_count</code> は引き続き、発生した警告の数を示しますが、メッセージは格納されないため表示できません。
      </p><p>
        <code class="literal">sql_notes</code> システム変数は、注意メッセージで <code class="literal">warning_count</code> が増分されるかどうか、またサーバーがそれらを格納するかどうかを制御します。デフォルトでは、<code class="literal">sql_notes</code> は 1 ですが、0 に設定されている場合は、注意で <code class="literal">warning_count</code> が増分されず、またサーバーはそれらを格納しません。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET sql_notes = 1;</code></strong>
mysql&gt; <strong class="userinput"><code>DROP TABLE IF EXISTS test.no_such_table;</code></strong>
Query OK, 0 rows affected, 1 warning (0.00 sec)
mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+-------+------+------------------------------------+
| Level | Code | Message                            |
+-------+------+------------------------------------+
| Note  | 1051 | Unknown table 'test.no_such_table' |
+-------+------+------------------------------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SET sql_notes = 0;</code></strong>
mysql&gt; <strong class="userinput"><code>DROP TABLE IF EXISTS test.no_such_table;</code></strong>
Query OK, 0 rows affected (0.00 sec)
mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
Empty set (0.00 sec)
</pre><p>
        MySQL サーバーは、各クライアントに、そのクライアントによって実行された最新のステートメントの結果として得られたエラー、警告、および注意の総数を示す数を送信します。C API からは、この値は <code class="literal">mysql_warning_count()</code> を呼び出すことによって取得できます。<a class="xref" href="connectors-apis.html#mysql-warning-count" title="23.8.7.73 mysql_warning_count()">セクション23.8.7.73「mysql_warning_count()」</a>を参照してください。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="other-administrative-sql"></a>13.7.6 その他の管理ステートメント</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-syntax.html#binlog">13.7.6.1 BINLOG 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#cache-index">13.7.6.2 CACHE INDEX 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#flush">13.7.6.3 FLUSH 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#kill">13.7.6.4 KILL 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#load-index">13.7.6.5 LOAD INDEX INTO CACHE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#reset">13.7.6.6 RESET 構文</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="binlog"></a>13.7.6.1 BINLOG 構文</h4></div></div></div><a class="indexterm" name="idm139979076246544"></a><pre class="programlisting">
BINLOG '<em class="replaceable"><code>str</code></em>'
</pre><p>
        <code class="literal">BINLOG</code> は、内部で使用されるステートメントです。これは、バイナリログファイル内の特定のイベントの印刷可能な表現として <span class="command"><strong>mysqlbinlog</strong></span> プログラムによって生成されます。(<a class="xref" href="programs.html#mysqlbinlog" title="4.6.8 mysqlbinlog — バイナリログファイルを処理するためのユーティリティー">セクション4.6.8「<span class="command"><strong>mysqlbinlog</strong></span> — バイナリログファイルを処理するためのユーティリティー」</a>を参照してください。)<code class="literal">'<em class="replaceable"><code>str</code></em>'</code> 値は、サーバーが、対応するイベントによって示されているデータ変更を判定するためにデコードする、base 64 でエンコードされた文字列です。このステートメントには、<code class="literal">SUPER</code> 権限が必要です。
      </p><p>
        MySQL 5.6 の時点では、このステートメントは形式記述イベントと行イベントのみを実行できます。以前は、すべてのタイプのイベントを実行できました。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="cache-index"></a>13.7.6.2 CACHE INDEX 構文</h4></div></div></div><a class="indexterm" name="idm139979076233280"></a><a class="indexterm" name="idm139979076231968"></a><a class="indexterm" name="idm139979076229792"></a><pre class="programlisting">
CACHE INDEX
  <em class="replaceable"><code>tbl_index_list</code></em> [, <em class="replaceable"><code>tbl_index_list</code></em>] ...
  [PARTITION (<em class="replaceable"><code>partition_list</code></em> | ALL)]
  IN <em class="replaceable"><code>key_cache_name</code></em>

<em class="replaceable"><code>tbl_index_list</code></em>:
  <em class="replaceable"><code>tbl_name</code></em> [[INDEX|KEY] (<em class="replaceable"><code>index_name</code></em>[, <em class="replaceable"><code>index_name</code></em>] ...)]

<em class="replaceable"><code>partition_list</code></em>:
  <em class="replaceable"><code>partition_name</code></em>[, <em class="replaceable"><code>partition_name</code></em>][, ...]
</pre><p>
        <code class="literal">CACHE INDEX</code> ステートメントは、テーブルインデックスを特定のキーキャッシュに割り当てます。これは、<code class="literal">MyISAM</code> テーブルにのみ使用されます。インデックスが割り当てられたら、これらのインデックスを、必要に応じて <code class="literal">LOAD INDEX INTO CACHE</code> でキャッシュにプリロードできます。
      </p><p>
        次のステートメントは、テーブル <code class="literal">t1</code>、<code class="literal">t2</code>、および <code class="literal">t3</code> のインデックスを <code class="literal">hot_cache</code> という名前のキーキャッシュに割り当てます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CACHE INDEX t1, t2, t3 IN hot_cache;</code></strong>
+---------+--------------------+----------+----------+
| Table   | Op                 | Msg_type | Msg_text |
+---------+--------------------+----------+----------+
| test.t1 | assign_to_keycache | status   | OK       |
| test.t2 | assign_to_keycache | status   | OK       |
| test.t3 | assign_to_keycache | status   | OK       |
+---------+--------------------+----------+----------+
</pre><p>
        <code class="literal">CACHE INDEX</code> の構文では、テーブルの特定のインデックスのみをキャッシュに割り当てるように指定できます。現在の実装では、テーブルのすべてのインデックスをキャッシュに割り当てるため、テーブル名以外のものを指定する理由は何もありません。
      </p><p>
        <code class="literal">CACHE INDEX</code> ステートメントで参照されるキーキャッシュは、パラメータ設定ステートメントを使用して、またはサーバーのパラメータ設定でそのサイズを設定することによって作成できます。例:
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET GLOBAL keycache1.key_buffer_size=128*1024;</code></strong>
</pre><p>
        キーキャッシュのパラメータには、構造化されたシステム変数のメンバーとしてアクセスできます。<a class="xref" href="server-administration.html#structured-system-variables" title="5.1.5.1 構造化システム変数">セクション5.1.5.1「構造化システム変数」</a>を参照してください。
      </p><p>
        インデックスをキーキャッシュに割り当てるには、そのキーキャッシュが存在している必要があります。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CACHE INDEX t1 IN non_existent_cache;</code></strong>
ERROR 1284 (HY000): Unknown key cache 'non_existent_cache'
</pre><p>
        デフォルトで、テーブルインデックスは、サーバー起動時に作成されるメイン (デフォルト) キーキャッシュに割り当てられます。キーキャッシュが破棄されると、それに割り当てられていたインデックスはすべて、デフォルトのキーキャッシュに再度割り当てられます。
      </p><p>
        インデックスの割り当ては、サーバーにグローバルに影響を与えます。あるクライアントがインデックスを特定のキャッシュに割り当てると、どのクライアントがクエリーを発行したかには関係なく、このキャッシュはそのインデックスに関連するすべてのクエリーに使用されます。
      </p><p>
        MySQL 5.6 では、このステートメントは、パーティション化された <code class="literal">MyISAM</code> テーブルに対してもサポートされます。1 つ、複数、またはすべてのパーティションの 1 つ以上のインデックスを特定のキーキャッシュに割り当てることができます。たとえば、次のステートメントを実行できます。
      </p><pre class="programlisting">
CREATE TABLE pt (c1 INT, c2 VARCHAR(50), INDEX i(c1))
    PARTITION BY HASH(c1)
    PARTITIONS 4;

SET GLOBAL kc_fast.key_buffer_size = 128 * 1024;
SET GLOBAL kc_slow.key_buffer_size = 128 * 1024;

CACHE INDEX pt PARTITION (p0) IN kc_fast;
CACHE INDEX pt PARTITION (p1, p3) IN kc_slow;
</pre><p>
        前の一連のステートメントは、次のアクションを実行します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            4 つのパーティションを含むパーティション化されたテーブルを作成します。これらのパーティションには、自動的に <code class="literal">p0</code>、...、<code class="literal">p3</code> という名前が付けられます。このテーブルには、カラム <code class="literal">c1</code> 上に <code class="literal">i</code> という名前のインデックスが含まれています。
          </p></li><li class="listitem"><p>
            <code class="literal">kc_fast</code> と <code class="literal">kc_slow</code> という名前の 2 つのキーキャッシュを作成します。
          </p></li><li class="listitem"><p>
            パーティション <code class="literal">p0</code> のインデックスを <code class="literal">kc_fast</code> キーキャッシュに、パーティション <code class="literal">p1</code> と <code class="literal">p3</code> のインデックスを <code class="literal">kc_slow</code> キーキャッシュに割り当てます。残りのパーティション (<code class="literal">p2</code>) のインデックスは、サーバーのデフォルトのキーキャッシュを使用します。
          </p></li></ul></div><p>
        代わりに、テーブル <code class="literal">pt</code> 内のすべてのパーティションのインデックスを <code class="literal">kc_all</code> という名前の 1 つのキーキャッシュに割り当てる場合は、次の 2 つのステートメントのどちらでも使用できます。
      </p><pre class="programlisting">
CACHE INDEX pt PARTITION (ALL) IN kc_all;

CACHE INDEX pt IN kc_all;
</pre><p>
        今示した 2 つのステートメントは同等であり、このうちのどちらを発行しても効果はまったく同じです。つまり、パーティション化されたテーブルのすべてのパーティションのインデックスを同じキーキャッシュに割り当てる場合、<code class="literal">PARTITION (ALL)</code> 句はオプションです。
      </p><p>
        複数のパーティションのインデックスをキーキャッシュに割り当てる場合、それらのパーティションが連続している必要はなく、それらの名前を特定の順序でリストする必要もありません。キーキャッシュに明示的に割り当てられていないパーティションのインデックスはすべて、自動的にサーバーのデフォルトのキーキャッシュを使用します。
      </p><p>
        MySQL 5.6 では、インデックスのプリロードも、パーティション化された <code class="literal">MyISAM</code> テーブルに対してサポートされます。詳細は、<a class="xref" href="sql-syntax.html#load-index" title="13.7.6.5 LOAD INDEX INTO CACHE 構文">セクション13.7.6.5「LOAD INDEX INTO CACHE 構文」</a>を参照してください。
      </p><p>
        MySQL 5.6.11 でのみ、このステートメントを発行する前に、<code class="literal">gtid_next</code> を <code class="literal">AUTOMATIC</code> に設定する必要があります。(Bug #16062608、Bug #16715809、Bug #69045)
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="flush"></a>13.7.6.3 FLUSH 構文</h4></div></div></div><a class="indexterm" name="idm139979076171280"></a><a class="indexterm" name="idm139979076169968"></a><a class="indexterm" name="idm139979076168624"></a><a class="indexterm" name="idm139979076166480"></a><pre class="programlisting">
FLUSH [NO_WRITE_TO_BINLOG | LOCAL]
    <em class="replaceable"><code>flush_option</code></em> [, <em class="replaceable"><code>flush_option</code></em>] ...
</pre><p>
        <code class="literal">FLUSH</code> ステートメントには、さまざまな内部キャッシュをクリアまたはリロードしたり、テーブルをフラッシュしたり、ロックを取得したりするいくつかのバリアント形式があります。<code class="literal">FLUSH</code> を実行するには、<code class="literal">RELOAD</code> 権限が必要です。あとで説明されているように、特定のフラッシュオプションには追加の権限が必要になることがあります。
      </p><p>
        デフォルトでは、サーバーは <code class="literal">FLUSH</code> ステートメントをバイナリログに書き込み、それらがレプリケーションスレーブにレプリケートされるようにします。ロギングを抑制するには、オプションの <code class="literal">NO_WRITE_TO_BINLOG</code> キーワード、またはそのエイリアス <code class="literal">LOCAL</code> を指定します。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">FLUSH LOGS</code>、<code class="literal">FLUSH TABLES WITH READ LOCK</code> (テーブルリスト付き、またはなし)、および <code class="literal">FLUSH TABLES <em class="replaceable"><code>tbl_name</code></em> ... FOR EXPORT</code> は、スレーブにレプリケートされると問題が発生するため、どのような場合でもバイナリログに書き込まれません。
        </p></div><p>
        <code class="literal">SIGHUP</code> シグナルをサーバーに送信すると、さまざまな形式の <code class="literal">FLUSH</code> ステートメントに似たいくつかのフラッシュ操作が発生します。<a class="xref" href="server-administration.html#server-signal-response" title="5.1.11 シグナルへのサーバー応答">セクション5.1.11「シグナルへのサーバー応答」</a>を参照してください。
      </p><p>
        <code class="literal">FLUSH</code> ステートメントは暗黙的なコミットを発生させます。<a class="xref" href="sql-syntax.html#implicit-commit" title="13.3.3 暗黙的なコミットを発生させるステートメント">セクション13.3.3「暗黙的なコミットを発生させるステートメント」</a>を参照してください。
      </p><p>
        <code class="literal">RESET</code> ステートメントは、<code class="literal">FLUSH</code> に似ています。レプリケーションでの <code class="literal">RESET</code> ステートメントの使用については、<a class="xref" href="sql-syntax.html#reset" title="13.7.6.6 RESET 構文">セクション13.7.6.6「RESET 構文」</a>を参照してください。
      </p><p>
        <em class="replaceable"><code>flush_option</code></em> には、次のいずれかの項目を指定できます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">DES_KEY_FILE</code>
          </p><p>
            サーバーの起動時に <code class="option">--des-key-file</code> オプションで指定されたファイルから DES キーをリロードします。
          </p></li><li class="listitem"><p>
            <code class="literal">HOSTS</code>
          </p><p>
            ホストキャッシュを空にします。ホストキャッシュは、一部のホストが IP アドレスを変更したか、または <code class="literal">Host '<em class="replaceable"><code>host_name</code></em>' is blocked</code> というエラーメッセージが表示された場合にフラッシュするようにしてください。(<a class="xref" href="error-handling.html#blocked-host" title="B.5.2.6 ホスト 'host_name' は拒否されました">セクションB.5.2.6「ホスト 'host_name' は拒否されました」</a>を参照してください。) MySQL サーバーへの接続中に、特定のホストに関して <code class="literal">max_connect_errors</code> 個を超えるエラーが連続して発生すると、MySQL は何か問題があると見なし、そのホストをそれ以上の接続要求からブロックします。ホストキャッシュをフラッシュすると、ホストからのそれ以上の接続試行が可能になります。<code class="literal">max_connect_errors</code> のデフォルト値は 10 です。このエラーメッセージを回避するには、<code class="literal">max_connect_errors</code> が大きな値に設定された状態でサーバーを起動します。
          </p></li><li class="listitem"><p>
            <code class="literal">[<em class="replaceable"><code>log_type</code></em>] LOGS</code>
          </p><p>
            <em class="replaceable"><code>log_type</code></em> オプションを指定しない場合、<code class="literal">FLUSH LOGS</code> はすべてのログファイルを閉じて、再度開きます。バイナリロギングが有効になっている場合は、バイナリログファイルのシーケンス番号が、前のファイルを基準にして 1 増分されます。
          </p><p>
            <em class="replaceable"><code>log_type</code></em> オプションを指定すると、指定されたログタイプのみがフラッシュされます。次の <em class="replaceable"><code>log_type</code></em> オプションが許可されます。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">BINARY</code> はバイナリログファイルを閉じて、再度開きます。
              </p></li><li class="listitem"><p>
                <code class="literal">ENGINE</code> は、インストールされているストレージエンジンのフラッシュ可能なログをすべて閉じて、再度開きます。現在、これにより <code class="literal">InnoDB</code> はそのログをディスクにフラッシュします。
              </p></li><li class="listitem"><p>
                <code class="literal">ERROR</code> はエラーログファイルを閉じて、再度開きます。
              </p></li><li class="listitem"><p>
                <code class="literal">GENERAL</code> は一般的なクエリーログファイルを閉じて、再度開きます。
              </p></li><li class="listitem"><p>
                <code class="literal">RELAY</code> はリレーログファイルを閉じて、再度開きます。
              </p></li><li class="listitem"><p>
                <code class="literal">SLOW</code> はスロークエリーログファイルを閉じて、再度開きます。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">PRIVILEGES</code>
          </p><p>
            <code class="literal">mysql</code> データベース内の付与テーブルから権限をリロードします。
          </p><p>
            <code class="literal">GRANT</code>、<code class="literal">CREATE USER</code>、<code class="literal">CREATE SERVER</code>、および <code class="literal">INSTALL PLUGIN</code> ステートメントの結果として、サーバーは情報をメモリーにキャッシュします。このメモリーは、対応する <code class="literal">REVOKE</code>、<code class="literal">DROP USER</code>、<code class="literal">DROP SERVER</code>、および <code class="literal">UNINSTALL PLUGIN</code> ステートメントによって解放されないため、キャッシュを発生させるステートメントの多数のインスタンスを実行するサーバーでは、メモリー使用量が増加します。このキャッシュされたメモリーは <code class="literal">FLUSH PRIVILEGES</code> で解放できます。
          </p></li><li class="listitem"><p>
            <code class="literal">QUERY CACHE</code>
          </p><p>
            クエリーキャッシュをデフラグして、そのメモリーをより有効に活用します。<code class="literal">FLUSH QUERY CACHE</code> は、<code class="literal">FLUSH TABLES</code> や <code class="literal">RESET QUERY CACHE</code> とは異なり、キャッシュからクエリーを削除しません。
          </p></li><li class="listitem"><p>
            <code class="literal">STATUS</code>
          </p><p>
            このオプションは、現在のスレッドのセッションステータス変数値をグローバル値に追加し、セッション値を 0 にリセットします。一部のグローバル変数も 0 にリセットされる可能性があります。また、(デフォルトおよび指定された) キーキャッシュのカウンタも 0 にリセットし、<code class="literal">Max_used_connections</code> を開いている接続の現在の数に設定します。これは、クエリーをデバッグしている場合にのみ使用するようにしてください。<a class="xref" href="introduction.html#bug-reports" title="1.7 質問またはバグをレポートする方法">セクション1.7「質問またはバグをレポートする方法」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">TABLES</code>
          </p><p>
            <code class="literal">FLUSH TABLES</code> はテーブルをフラッシュし、使用されているバリアントに応じてロックを取得します。許可される構文については、このセクションのあとの方で説明されています。
          </p></li><li class="listitem"><p>
            <code class="literal">USER_RESOURCES</code>
          </p><p>
            時間あたりのすべてのユーザーリソースを 0 にリセットします。これにより、時間あたりの接続、クエリー、または更新の制限に達したクライアントが、ただちにアクティビティーを再開できるようになります。<code class="literal">FLUSH USER_RESOURCES</code> は、最大同時接続に対する制限には適用されません。<a class="xref" href="security.html#user-resources" title="6.3.4 アカウントリソース制限の設定">セクション6.3.4「アカウントリソース制限の設定」</a>を参照してください。
          </p></li></ul></div><p>
        <span class="command"><strong>mysqladmin</strong></span> ユーティリティーは、<code class="literal">flush-hosts</code>、<code class="literal">flush-logs</code>、<code class="literal">flush-privileges</code>、<code class="literal">flush-status</code>、<code class="literal">flush-tables</code> などのコマンドを使用して、いくつかのフラッシュ操作へのコマンド行インタフェースを提供します。<a class="xref" href="programs.html#mysqladmin" title="4.5.2 mysqladmin — MySQL サーバーの管理を行うクライアント">セクション4.5.2「<span class="command"><strong>mysqladmin</strong></span> — MySQL サーバーの管理を行うクライアント」</a>を参照してください。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          ストアドファンクションまたはトリガー内で <code class="literal">FLUSH</code> ステートメントを発行することはできません。ただし、ストアドプロシージャーでは、それがストアドファンクションまたはトリガーから呼び出されないかぎり、<code class="literal">FLUSH</code> を使用できます。<a class="xref" href="restrictions.html#stored-program-restrictions" title="D.1 ストアドプログラムの制約">セクションD.1「ストアドプログラムの制約」</a>を参照してください。
        </p></div><p>
        MySQL 5.6.11 でのみ、このステートメントを発行する前に、<code class="literal">gtid_next</code> を <code class="literal">AUTOMATIC</code> に設定する必要があります。(Bug #16062608、Bug #16715809、Bug #69045)
      </p><h5><a name="idm139979076063328"></a>FLUSH TABLES 構文</h5><p>
        <code class="literal">FLUSH TABLES</code> には、次に説明されているいくつかの形式があります。<code class="literal">TABLES</code> オプションのいずれかのバリアントが <code class="literal">FLUSH</code> ステートメントで使用されている場合は、それが、使用されている唯一のオプションである必要があります。<code class="literal">FLUSH TABLES</code> は <code class="literal">FLUSH TABLES</code> のシノニムです。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">FLUSH TABLES</code>
          </p><p>
            開かれているすべてのテーブルを閉じ、使用されているすべてのテーブルを強制的に閉じて、クエリーキャッシュをフラッシュします。<code class="literal">FLUSH TABLES</code> はまた、<code class="literal">RESET QUERY CACHE</code> ステートメントと同様に、クエリーキャッシュからすべてのクエリー結果を削除します。
          </p><p>
            MySQL 5.6 では、アクティブな <code class="literal">LOCK TABLES ... READ</code> が存在する場合、<code class="literal">FLUSH TABLES</code> は許可されません。テーブルをフラッシュしてロックするには、代わりに <code class="literal">FLUSH TABLES <em class="replaceable"><code>tbl_name</code></em> ... WITH READ LOCK</code> を使用します。
          </p></li><li class="listitem"><p>
            <code class="literal">FLUSH TABLES <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ...</code>
          </p><p>
            カンマで区切られた 1 つ以上のテーブル名のリストを指定した場合、このステートメントは、サーバーが指定されたテーブルのみをフラッシュする点を除き、名前のない <code class="literal">FLUSH TABLES</code> と同様です。指定されたテーブルが存在しない場合、エラーは発生しません。
          </p></li><li class="listitem"><p>
            <code class="literal">FLUSH TABLES WITH READ LOCK</code>
          </p><p>
            開かれているすべてのテーブルを閉じ、グローバルな読み取りロックを保持しているすべてのデータベースのすべてのテーブルをロックします。これは、特定時点のスナップショットを取得できる、Veritas または ZFS などのファイルシステムがある場合にバックアップを取得するための非常に便利な方法です。このロックを解放するには、<code class="literal">UNLOCK TABLES</code> を使用します。
          </p><p>
            <code class="literal">FLUSH TABLES WITH READ LOCK</code> は、グローバルな読み取りロックを取得しますが、テーブルロックは取得しないため、テーブルロックと暗黙的なコミットに関して <code class="literal">LOCK TABLES</code> および <code class="literal">UNLOCK TABLES</code> と同じ動作には従いません。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">UNLOCK TABLES</code> は、現在 <code class="literal">LOCK TABLES</code> でロックされているテーブルがある場合にのみ、アクティブなトランザクションをすべて暗黙的にコミットします。<code class="literal">FLUSH TABLES WITH READ LOCK</code> はテーブルロックを取得しないため、このステートメントに続く <code class="literal">UNLOCK TABLES</code> に対してコミットは発生しません。
              </p></li><li class="listitem"><p>
                トランザクションを開始すると、ユーザーが <code class="literal">UNLOCK TABLES</code> を実行したかのように、<code class="literal">LOCK TABLES</code> によって取得されたテーブルロックが解放されます。トランザクションを開始しても、<code class="literal">FLUSH TABLES WITH READ LOCK</code> によって取得されたグローバルな読み取りロックは解放されません。
              </p></li></ul></div><p>
            <code class="literal">FLUSH TABLES WITH READ LOCK</code> では、サーバーがログテーブルに行を挿入することは妨げられません (<a class="xref" href="server-administration.html#log-destinations" title="5.2.1 一般クエリーログおよびスロークエリーログの出力先の選択">セクション5.2.1「一般クエリーログおよびスロークエリーログの出力先の選択」</a>を参照してください)。
          </p></li><li class="listitem"><p>
            <code class="literal">FLUSH TABLES <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ... WITH READ LOCK</code>
          </p><p>
            このステートメントは、指定されたテーブルをフラッシュし、それに対する読み取りロックを取得します。このステートメントは、まずテーブルに対する排他的なメタデータロックを取得するため、これらのテーブルを開いているトランザクションの完了を待機します。次に、このステートメントはテーブルキャッシュからテーブルをフラッシュし、テーブルを再度開き、(<code class="literal">LOCK TABLES ... READ</code> と同様に) テーブルロックを取得したあと、そのメタデータロックを排他的から共有にダウングレードします。このステートメントがロックを取得し、そのメタデータロックをダウングレードしたら、ほかのセッションはそれらのテーブルを読み取ることができますが、変更することはできません。
          </p><p>
            このステートメントはテーブルロックを取得するため、いずれかの <code class="literal">FLUSH</code> ステートメントを使用するために必要な <code class="literal">RELOAD</code> 権限に加えて、各テーブルに対する <code class="literal">LOCK TABLES</code> 権限が必要です。
          </p><p>
            このステートメントは、既存のベーステーブルにのみ適用されます。名前がベーステーブルを参照している場合は、そのテーブルが使用されます。<code class="literal">TEMPORARY</code> テーブルを参照している場合、その名前は無視されます。名前がビューに適用される場合は、<code class="literal">ER_WRONG_OBJECT</code> エラーが発生します。それ以外の場合は、<code class="literal">ER_NO_SUCH_TABLE</code> エラーが発生します。
          </p><p>
            ロックを解放するには <code class="literal">UNLOCK TABLES</code> を、ロックを解放し、ほかのロックを取得するには <code class="literal">LOCK TABLES</code> を、またはロックを解放し、新しいトランザクションを開始するには <code class="literal">START TRANSACTION</code> を使用します。
          </p><p>
            <code class="literal">FLUSH</code> のこのバリアントを使用すると、テーブルのフラッシュとロックを 1 つの操作で実行できます。これにより、アクティブな <code class="literal">LOCK TABLES ... READ</code> が存在する場合は <code class="literal">FLUSH TABLES</code> が許可されないという MySQL 5.6 での制限の回避方法が提供されます。
          </p><p>
            このステートメントは暗黙的な <code class="literal">UNLOCK TABLES</code> を実行しないため、このステートメントをアクティブな <code class="literal">LOCK TABLES</code> が存在する間に使用したり、取得されたロックをまず解放することなくふたたび使用したりすると、エラーが発生します。
          </p><p>
            フラッシュされたテーブルが <code class="literal">HANDLER</code> で開かれた場合、そのハンドラは暗黙的にフラッシュされ、その位置を失います。
          </p></li><li class="listitem"><p>
            <code class="literal">FLUSH TABLES <em class="replaceable"><code>tbl_name</code></em> [, <em class="replaceable"><code>tbl_name</code></em>] ... FOR EXPORT</code>
          </p><p>
            この <code class="literal">FLUSH TABLES</code> バリアントは、<code class="literal">InnoDB</code> テーブルに適用されます。これは、MySQL 5.6.6 の時点で使用できます。このステートメントは、サーバー稼働中にバイナリテーブルのコピーができるように、名前付きテーブルへの変更をディスクにフラッシュします。
          </p><p>
            このステートメントは、次のように機能します。
          </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                指定されたテーブルに対する共有メタデータロックを取得します。これらのテーブルを変更したか、またはそれに対するテーブルロックを保持するアクティブなトランザクションがほかのセッションに存在するかぎり、このステートメントはブロックされます。ロックが取得されると、このステートメントは、これらのテーブルを更新しようとするトランザクションをブロックしながら、読み取り専用操作は続行できるようにします。
              </p></li><li class="listitem"><p>
                これらのテーブルのすべてのストレージエンジンが <code class="literal">FOR EXPORT</code> をサポートしているかどうかをチェックします。サポートしていないものがある場合は、<code class="literal">ER_ILLEGAL_HA</code> エラーが発生し、このステートメントは失敗します。
              </p></li><li class="listitem"><p>
                このステートメントは、各テーブルのストレージエンジンに、そのテーブルをエクスポートのために準備するよう通知します。そのストレージエンジンは、保留中の変更がすべてディスクに書き込まれるようにする必要があります。
              </p></li><li class="listitem"><p>
                このステートメントは、<code class="literal">FOR EXPORT</code> ステートメントの完了時に以前に取得されたメタデータロックが解放されないように、そのセッションをテーブルロックモードにします。
              </p></li></ol></div><p>
            <code class="literal">FLUSH TABLES ... FOR EXPORT</code> ステートメントには、各テーブルに対する <code class="literal">SELECT</code> 権限が必要です。このステートメントはテーブルロックを取得するため、いずれかの <code class="literal">FLUSH</code> ステートメントを使用するために必要な <code class="literal">RELOAD</code> 権限に加えて、各テーブルに対する <code class="literal">LOCK TABLES</code> 権限も必要です。
          </p><p>
            このステートメントは、既存のベーステーブルにのみ適用されます。名前がベーステーブルを参照している場合は、そのテーブルが使用されます。<code class="literal">TEMPORARY</code> テーブルを参照している場合、その名前は無視されます。名前がビューに適用される場合は、<code class="literal">ER_WRONG_OBJECT</code> エラーが発生します。それ以外の場合は、<code class="literal">ER_NO_SUCH_TABLE</code> エラーが発生します。
          </p><p>
            <code class="literal">InnoDB</code> は、独自の <a class="link" href="glossary.html#glos_ibd_file" title=".ibd ファイル">.ibd ファイル</a>を持つテーブル (つまり、<code class="literal">innodb_file_per_table</code> 設定が有効になった状態で作成されたテーブル) に対する <code class="literal">FOR EXPORT</code> をサポートしています。<code class="literal">InnoDB</code> は、<code class="literal">FOR EXPORT</code> ステートメントから通知されると、すべての変更を確実にディスクにフラッシュします。<code class="filename">.ibd</code> ファイルはトランザクション一貫性があり、サーバーの実行中にコピーできるため、これにより、<code class="literal">FOR EXPORT</code> ステートメントが有効になっている間にテーブルの内容のバイナリコピーを作成できます。<code class="literal">FOR EXPORT</code> は、<code class="literal">InnoDB</code> システムテーブルスペースファイルや、いずれかの <code class="literal">FULLTEXT</code> インデックスを含む <code class="literal">InnoDB</code> テーブルには適用されません。
          </p><p>
            <code class="literal">FLUSH TABLES ...FOR EXPORT</code> は、MySQL 5.6.17 より前のパーティション化された <code class="literal">InnoDB</code> テーブルでは機能しませんが、MySQL 5.6.17 以降ではこのようなテーブルに対してもサポートされます。(Bug #16943907)。
          </p><p>
            <code class="literal">FOR EXPORT</code> から通知されると、<code class="literal">InnoDB</code> は、通常はメモリー内か、またはテーブルスペースファイルの外部にある個別のディスクバッファーに保持される特定の種類のデータをディスクに書き込みます。<code class="literal">InnoDB</code> はまた、テーブルごとに、そのテーブルと同じデータベースディレクトリ内に <code class="filename"><em class="replaceable"><code>table_name</code></em>.cfg</code> という名前のファイルも生成します。<code class="filename">.cfg</code> ファイルには、あとでテーブルスペースファイルを同じサーバーまたは別のサーバーに再インポートするために必要なメタデータが含まれています。
          </p><p>
            <code class="literal">FOR EXPORT</code> ステートメントが完了すると、<code class="literal">InnoDB</code> によって、すべての<a class="link" href="glossary.html#glos_dirty_page" title="ダーティーページ">ダーティーページ</a>がテーブルデータファイルにフラッシュされています。<a class="link" href="glossary.html#glos_change_buffer" title="変更バッファー">変更バッファー</a>のエントリはすべて、フラッシュの前にマージされます。この時点で、テーブルはロックされ、静止します。これらのテーブルはディスク上でトランザクション的に一貫性のある状態にあるため、<code class="filename">.ibd</code> テーブルスペースファイルを対応する <code class="filename">.cfg</code> ファイルとともにコピーすることによって、これらのテーブルの整合性のあるスナップショットを取得できます。
          </p><p>
            コピーされたテーブルデータを MySQL インスタンスに再インポートする手順については、<a class="xref" href="innodb-storage-engine.html#tablespace-copying" title="14.5.5 テーブルスペースの別のサーバーへのコピー (トランスポータブルテーブルスペース)">セクション14.5.5「テーブルスペースの別のサーバーへのコピー (トランスポータブルテーブルスペース)」</a>を参照してください。
          </p><p>
            テーブルの処理を完了したあと、ロックを解放するには <code class="literal">UNLOCK TABLES</code> を、ロックを解放し、ほかのロックを取得するには <code class="literal">LOCK TABLES</code> を、またはロックを解放し、新しいトランザクションを開始するには <code class="literal">START TRANSACTION</code> を使用します。
          </p><p>
            セッション内で次のいずれかのステートメントが有効になっている間は、<code class="literal">FLUSH TABLES ... FOR EXPORT</code> を使用しようとするとエラーが生成されます。
          </p><pre class="programlisting">
FLUSH TABLES ... WITH READ LOCK
FLUSH TABLES ... FOR EXPORT
LOCK TABLES ... READ
LOCK TABLES ... WRITE
</pre><p>
            セッション内で <code class="literal">FLUSH TABLES ... FOR EXPORT</code> が有効になっている間は、次のいずれかのステートメントを使用しようとするとエラーが生成されます。
          </p><pre class="programlisting">
FLUSH TABLES WITH READ LOCK
FLUSH TABLES ... WITH READ LOCK
FLUSH TABLES ... FOR EXPORT
</pre></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="kill"></a>13.7.6.4 KILL 構文</h4></div></div></div><a class="indexterm" name="idm139979075932208"></a><a class="indexterm" name="idm139979075930864"></a><pre class="programlisting">
KILL [CONNECTION | QUERY] <em class="replaceable"><code>processlist_id</code></em>
</pre><p>
        <span class="command"><strong>mysqld</strong></span> への各接続は、個別のスレッドで実行されます。スレッドは、<code class="literal">KILL <em class="replaceable"><code>processlist_id</code></em></code> ステートメントで強制終了できます。
      </p><p>
        スレッドのプロセスリスト識別子は、<code class="literal">INFORMATION_SCHEMA.PROCESSLIST</code> テーブルの <code class="literal">ID</code> カラム、<code class="literal">SHOW PROCESSLIST</code> の出力の <code class="literal">Id</code> カラム、およびパフォーマンススキーマの <code class="literal">threads</code> テーブルの <code class="literal">PROCESSLIST_ID</code> カラムから特定できます。現在のスレッドの値は、<code class="literal">CONNECTION_ID()</code> 関数によって返されます。
      </p><p>
        <code class="literal">KILL</code> では、オプションの <code class="literal">CONNECTION</code> または <code class="literal">QUERY</code> 修飾子が許可されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">KILL CONNECTION</code> は、修飾子のない <code class="literal">KILL</code> と同じです。これは、指定された <em class="replaceable"><code>processlist_id</code></em> に関連付けられた接続を終了します。
          </p></li><li class="listitem"><p>
            <code class="literal">KILL QUERY</code> は、接続が現在実行しているステートメントを終了しますが、その接続自体はそのままの状態で残します。
          </p></li></ul></div><p>
        <code class="literal">PROCESS</code> 権限がある場合は、すべてのスレッドを表示できます。<code class="literal">SUPER</code> 権限がある場合は、すべてのスレッドとステートメントを強制終了できます。そうでない場合は、ユーザー独自のスレッドとステートメントのみを表示および強制終了できます。
      </p><p>
        <span class="command"><strong>mysqladmin processlist</strong></span> および <span class="command"><strong>mysqladmin kill</strong></span> コマンドを使用して、スレッドを検査および強制終了することもできます。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          組み込みサーバーはホストアプリケーションのスレッドの内部でしか実行されないため、組み込み MySQL Server ライブラリでは <code class="literal">KILL</code> を使用できません。独自の接続スレッドは作成されません。
        </p></div><p>
        <code class="literal">KILL</code> を使用すると、そのスレッドのスレッド固有の強制終了フラグが設定されます。強制終了フラグは次の一定の間隔でしかチェックされないため、ほとんどの場合、スレッドが終了するまでにある程度時間がかかることがあります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">SELECT</code> 操作中、<code class="literal">ORDER BY</code> および <code class="literal">GROUP BY</code> ループでは、このフラグは行ブロックの読み取りのあとにチェックされます。強制終了フラグが設定されている場合、このステートメントは中止されます。
          </p></li><li class="listitem"><p>
            <code class="literal">ALTER TABLE</code> 操作中、強制終了フラグは、元のテーブルから各行ブロックが読み取られる前にチェックされます。強制終了フラグが設定されていた場合、このステートメントは中止され、一時テーブルが削除されます。
          </p></li><li class="listitem"><p>
            <code class="literal">UPDATE</code> または <code class="literal">DELETE</code> 操作中、強制終了フラグは、ブロックが読み取られるたび、および行が更新または削除されるたびにチェックされます。強制終了フラグが設定されている場合、このステートメントは中止されます。トランザクションを使用していない場合は、変更がロールバックされません。
          </p></li><li class="listitem"><p>
            <code class="literal">GET_LOCK()</code> は中止され、<code class="literal">NULL</code> を返します。
          </p></li><li class="listitem"><p>
            <code class="literal">INSERT DELAYED</code> スレッドは、メモリー内にあるすべての行をすばやくフラッシュ (挿入) してから終了します。
          </p></li><li class="listitem"><p>
            このスレッドがテーブルロックハンドラ内にある場合 (状態: <code class="literal">Locked</code>)、そのテーブルロックはすばやく中止されます。
          </p></li><li class="listitem"><p>
            このスレッドが書き込みコールでディスクの空き容量を待機している場合、その書き込みは<span class="quote">「<span class="quote">ディスク領域不足</span>」</span>というエラーメッセージで中止されます。
          </p></li></ul></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
          <code class="literal">MyISAM</code> テーブルに対する <code class="literal">REPAIR TABLE</code> または <code class="literal">OPTIMIZE TABLE</code> 操作を強制終了すると、テーブルが破損して使用できなくなります。このようなテーブルに対する読み取りまたは書き込みはすべて、そのテーブルをふたたび最適化または修復するまで失敗します (割り込みはなし)。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="load-index"></a>13.7.6.5 LOAD INDEX INTO CACHE 構文</h4></div></div></div><pre class="programlisting">
LOAD INDEX INTO CACHE
  <em class="replaceable"><code>tbl_index_list</code></em> [, <em class="replaceable"><code>tbl_index_list</code></em>] ...

<em class="replaceable"><code>tbl_index_list</code></em>:
  <em class="replaceable"><code>tbl_name</code></em>
    [PARTITION (<em class="replaceable"><code>partition_list</code></em> | ALL)]
    [[INDEX|KEY] (<em class="replaceable"><code>index_name</code></em>[, <em class="replaceable"><code>index_name</code></em>] ...)]
    [IGNORE LEAVES]

<em class="replaceable"><code>partition_list</code></em>:
    <em class="replaceable"><code>partition_name</code></em>[, <em class="replaceable"><code>partition_name</code></em>][, ...]
</pre><p>
        <code class="literal">LOAD INDEX INTO CACHE</code> ステートメントは、明示的な <code class="literal">CACHE INDEX</code> ステートメントによって割り当てられたキーキャッシュ、またはそれ以外の場合はデフォルトのキーキャッシュにテーブルインデックスをプリロードします。
      </p><p>
        <code class="literal">LOAD INDEX INTO CACHE</code> は、<code class="literal">MyISAM</code> テーブルにのみ使用されます。MySQL 5.6 では、パーティション化された <code class="literal">MyISAM</code> テーブルに対してもサポートされます。さらに、パーティション化されたテーブル上のインデックスを 1 つ、複数、またはすべてのパーティションに対してプリロードできます。
      </p><p>
        <code class="literal">IGNORE LEAVES</code> 修飾子によって、インデックスの非リーフノードのブロックのみがプリロードされます。
      </p><p>
        <code class="literal">IGNORE LEAVES</code> は、パーティション化された <code class="literal">MyISAM</code> テーブルに対してもサポートされます。
      </p><p>
        次のステートメントは、テーブル <code class="literal">t1</code> と <code class="literal">t2</code> のインデックスのノード (インデックスブロック) をプリロードします。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>LOAD INDEX INTO CACHE t1, t2 IGNORE LEAVES;</code></strong>
+---------+--------------+----------+----------+
| Table   | Op           | Msg_type | Msg_text |
+---------+--------------+----------+----------+
| test.t1 | preload_keys | status   | OK       |
| test.t2 | preload_keys | status   | OK       |
+---------+--------------+----------+----------+
</pre><p>
        このステートメントは、<code class="literal">t1</code> からすべてのインデックスブロックをプリロードします。<code class="literal">t2</code> からは、非リーフノードのブロックのみをプリロードします。
      </p><p>
        <code class="literal">LOAD INDEX INTO CACHE</code> の構文では、テーブルの特定のインデックスのみをプリロードするように指定できます。現在の実装では、テーブルのすべてのインデックスをキャッシュにプリロードするため、テーブル名以外のものを指定する理由は何もありません。
      </p><p>
        MySQL 5.6.11 でのみ、このステートメントを発行する前に、<code class="literal">gtid_next</code> を <code class="literal">AUTOMATIC</code> に設定する必要があります。(Bug #16062608、Bug #16715809、Bug #69045)
      </p><p>
        MySQL 5.6 では、パーティション化された <code class="literal">MyISAM</code> テーブルの特定のパーティション上のインデックスをプリロードできます。たとえば、次の 2 つのステートメントでは、最初が、パーティション化されたテーブル <code class="literal">pt</code> のパーティション <code class="literal">p0</code> のインデックスをプリロードするのに対して、2 番目は同じテーブルのパーティション <code class="literal">p1</code> と <code class="literal">p3</code> のインデックスをプリロードします。
      </p><pre class="programlisting">
LOAD INDEX INTO CACHE pt PARTITION (p0);
LOAD INDEX INTO CACHE pt PARTITION (p1, p3);
</pre><p>
        テーブル <code class="literal">pt</code> 内のすべてのパーティションのインデックスをプリロードするには、次の 2 つのステートメントのどちらでも使用できます。
      </p><pre class="programlisting">
LOAD INDEX INTO CACHE pt PARTITION (ALL);

LOAD INDEX INTO CACHE pt;
</pre><p>
        今示した 2 つのステートメントは同等であり、このうちのどちらを発行しても効果はまったく同じです。つまり、パーティション化されたテーブルのすべてのパーティションのインデックスをプリロードする場合、<code class="literal">PARTITION (ALL)</code> 句はオプションです。
      </p><p>
        複数のパーティションのインデックスをプリロードする場合、それらのパーティションが連続している必要はなく、それらの名前を特定の順序でリストする必要もありません。
      </p><p>
        <code class="literal">LOAD INDEX INTO CACHE ... IGNORE LEAVES</code> は、テーブル内のすべてのインデックスのブロックサイズが同じでないかぎり失敗します。テーブルのインデックスブロックサイズは、<span class="command"><strong>myisamchk -dv</strong></span> を使用し、<code class="literal">Blocksize</code> カラムをチェックすることによって特定できます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="reset"></a>13.7.6.6 RESET 構文</h4></div></div></div><pre class="programlisting">
RESET <em class="replaceable"><code>reset_option</code></em> [, <em class="replaceable"><code>reset_option</code></em>] ...
</pre><p>
        <code class="literal">RESET</code> ステートメントは、さまざまなサーバー操作の状態をクリアするために使用されます。<code class="literal">RESET</code> を実行するには、<code class="literal">RELOAD</code> 権限が必要です。
      </p><p>
        <code class="literal">RESET</code> は、<code class="literal">FLUSH</code> ステートメントのより強力なバージョンとして機能します。<a class="xref" href="sql-syntax.html#flush" title="13.7.6.3 FLUSH 構文">セクション13.7.6.3「FLUSH 構文」</a>を参照してください。
      </p><p>
        <code class="literal">RESET</code> ステートメントは暗黙的なコミットを発生させます。<a class="xref" href="sql-syntax.html#implicit-commit" title="13.3.3 暗黙的なコミットを発生させるステートメント">セクション13.3.3「暗黙的なコミットを発生させるステートメント」</a>を参照してください。
      </p><p>
        MySQL 5.6.11 でのみ、このステートメントを発行する前に、<code class="literal">gtid_next</code> を <code class="literal">AUTOMATIC</code> に設定する必要があります。(Bug #16062608、Bug #16715809、Bug #69045)
      </p><p>
        <em class="replaceable"><code>reset_option</code></em> には、次のいずれかを指定できます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">MASTER</code>
          </p><p>
            インデックスファイルにリストされているすべてのバイナリログを削除し、バイナリログインデックスファイルを空にリセットして、新しいバイナリログファイルを作成します。
          </p></li><li class="listitem"><p>
            <code class="literal">QUERY CACHE</code>
          </p><p>
            クエリーキャッシュからすべてのクエリー結果を削除します。
          </p></li><li class="listitem"><p>
            <code class="literal">SLAVE</code>
          </p><p>
            スレーブに、マスターバイナリログ内のそのレプリケーション位置を忘れさせます。また、既存のリレーログファイルをすべて削除し、新しいリレーログファイルを開始することによってリレーログもリセットします。
          </p></li></ul></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sql-syntax-utility"></a>13.8 MySQL ユーティリティーステートメント</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sql-syntax.html#describe">13.8.1 DESCRIBE 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#explain">13.8.2 EXPLAIN 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#help">13.8.3 HELP 構文</a></span></dt><dt><span class="section"><a href="sql-syntax.html#use">13.8.4 USE 構文</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="describe"></a>13.8.1 DESCRIBE 構文</h3></div></div></div><a class="indexterm" name="idm139979075802032"></a><a class="indexterm" name="idm139979075800720"></a><p>
      <code class="literal">DESCRIBE</code> ステートメントと <code class="literal">EXPLAIN</code> ステートメントはシノニムであり、テーブル構造またはクエリー実行計画に関する情報を取得するために使用されます。詳細は、<a class="xref" href="sql-syntax.html#show-columns" title="13.7.5.6 SHOW COLUMNS 構文">セクション13.7.5.6「SHOW COLUMNS 構文」</a>および<a class="xref" href="sql-syntax.html#explain" title="13.8.2 EXPLAIN 構文">セクション13.8.2「EXPLAIN 構文」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="explain"></a>13.8.2 EXPLAIN 構文</h3></div></div></div><a class="indexterm" name="idm139979075794000"></a><a class="indexterm" name="idm139979075792688"></a><pre class="programlisting">
{EXPLAIN | DESCRIBE | DESC}
    <em class="replaceable"><code>tbl_name</code></em> [<em class="replaceable"><code>col_name</code></em> | <em class="replaceable"><code>wild</code></em>]

{EXPLAIN | DESCRIBE | DESC}
    [<em class="replaceable"><code>explain_type</code></em>]
    <em class="replaceable"><code>explainable_stmt</code></em>

<em class="replaceable"><code>explain_type</code></em>: {
    EXTENDED
  | PARTITIONS
  | FORMAT = <em class="replaceable"><code>format_name</code></em>
}

<em class="replaceable"><code>format_name</code></em>: {
    TRADITIONAL
  | JSON
}

<em class="replaceable"><code>explainable_stmt</code></em>: {
    SELECT statement
  | DELETE statement
  | INSERT statement
  | REPLACE statement
  | UPDATE statement
}
</pre><p>
      <code class="literal">DESCRIBE</code> ステートメントと <code class="literal">EXPLAIN</code> ステートメントはシノニムです。実際には、<code class="literal">DESCRIBE</code> キーワードがテーブル構造に関する情報を取得するためにより頻繁に使用されるのに対して、<code class="literal">EXPLAIN</code> は、クエリー実行計画 (つまり、MySQL がクエリーをどのように実行するかの説明) を取得するために使用されます。次の説明では、<code class="literal">DESCRIBE</code> および <code class="literal">EXPLAIN</code> キーワードをそのような用途に従って使用しますが、MySQL パーサーはこれらを完全にシノニムとして処理します。
    </p><h4><a name="idm139979075775264"></a>テーブル構造に関する情報の取得</h4><p>
      <code class="literal">DESCRIBE</code> は、テーブル内のカラムに関する情報を提供します。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>DESCRIBE City;</code></strong>
+------------+----------+------+-----+---------+----------------+
| Field      | Type     | Null | Key | Default | Extra          |
+------------+----------+------+-----+---------+----------------+
| Id         | int(11)  | NO   | PRI | NULL    | auto_increment |
| Name       | char(35) | NO   |     |         |                |
| Country    | char(3)  | NO   | UNI |         |                |
| District   | char(20) | YES  | MUL |         |                |
| Population | int(11)  | NO   |     | 0       |                |
+------------+----------+------+-----+---------+----------------+
</pre><p>
      <code class="literal">DESCRIBE</code> は <code class="literal">SHOW COLUMNS</code> のショートカットです。これらのステートメントはまた、ビューに関する情報も表示します。<code class="literal">SHOW COLUMNS</code> の説明では、出力カラムに関してより多くの情報が提供されます。<a class="xref" href="sql-syntax.html#show-columns" title="13.7.5.6 SHOW COLUMNS 構文">セクション13.7.5.6「SHOW COLUMNS 構文」</a>を参照してください。
    </p><p>
      デフォルトでは、<code class="literal">DESCRIBE</code> は、そのテーブル内のすべてのカラムに関する情報を表示します。<em class="replaceable"><code>col_name</code></em> (指定されている場合) は、そのテーブル内のカラムの名前です。この場合、このステートメントは、指定されたカラムの情報のみを表示します。<em class="replaceable"><code>wild</code></em> (指定されている場合) は、パターン文字列です。これには、SQL の<span class="quote">「<span class="quote"><code class="literal">%</code></span>」</span>と<span class="quote">「<span class="quote"><code class="literal">_</code></span>」</span>のワイルドカード文字を含めることができます。この場合、このステートメントは、その文字列に一致する名前を持つカラムの出力のみを表示します。スペースやその他の特殊文字が含まれていないかぎり、この文字列を引用符で囲む必要はありません。
    </p><a class="indexterm" name="idm139979075761312"></a><a class="indexterm" name="idm139979075759824"></a><p>
      <code class="literal">DESCRIBE</code> ステートメントは、Oracle との互換性のために提供されています。
    </p><p>
      また、<code class="literal">SHOW CREATE TABLE</code>、<code class="literal">SHOW TABLE STATUS</code>、および <code class="literal">SHOW INDEX</code> ステートメントでは、テーブルに関する情報も提供されます。<a class="xref" href="sql-syntax.html#show" title="13.7.5 SHOW 構文">セクション13.7.5「SHOW 構文」</a>を参照してください。
    </p><h4><a name="idm139979075751936"></a>実行計画に関する情報の取得</h4><p>
      <code class="literal">EXPLAIN</code> ステートメントは、MySQL がステートメントをどのように実行するかに関する情報を提供します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          MySQL 5.6.3 現在、<code class="literal">EXPLAIN</code> に使用できる説明可能なステートメントは、<code class="literal">SELECT</code>、<code class="literal">DELETE</code>、<code class="literal">INSERT</code>、<code class="literal">REPLACE</code>、および <code class="literal">UPDATE</code> です。MySQL 5.6.3 より前では、<code class="literal">SELECT</code> が唯一の説明可能なステートメントです。
        </p></li><li class="listitem"><p>
          説明可能なステートメントで <code class="literal">EXPLAIN</code> を使用すると、MySQL は、オプティマイザからのステートメント実行プランに関する情報を表示します。つまり、MySQL はテーブルがどのように、どんな順番で結合されているかに関する情報を含む、ステートメントを処理する方法を説明します。<code class="literal">EXPLAIN</code> を使用して、実行プラン情報を取得することについては、<a class="xref" href="optimization.html#explain-output" title="8.8.2 EXPLAIN 出力フォーマット">セクション8.8.2「EXPLAIN 出力フォーマット」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">EXPLAIN EXTENDED</code> を使用して、追加の実行プラン情報を取得できます。<a class="xref" href="optimization.html#explain-extended" title="8.8.3 EXPLAIN EXTENDED 出力フォーマット">セクション8.8.3「EXPLAIN EXTENDED 出力フォーマット」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">EXPLAIN PARTITIONS</code> は、パーティション化されたテーブルを含むクエリーの調査に役立ちます。<a class="xref" href="partitioning.html#partitioning-info" title="19.3.5 パーティションに関する情報を取得する">セクション19.3.5「パーティションに関する情報を取得する」</a>を参照してください。
        </p></li><li class="listitem"><p>
          MySQL 5.6.5 の時点では、<code class="literal">FORMAT</code> オプションを使用して出力形式を選択できます。<code class="literal">TRADITIONAL</code> は表形式で出力を表示します。<code class="literal">FORMAT</code> オプションが存在しない場合、これはデフォルトです。<code class="literal">JSON</code> フォーマットは JSON フォーマットで情報を表示します。<code class="literal">FORMAT = JSON</code> を使用すると、出力には拡張されたパーティション情報が含まれます。
        </p></li></ul></div><p>
      <a class="indexterm" name="idm139979075725328"></a> <code class="literal">EXPLAIN</code> によって、インデックスを使用して行を見つけることで、ステートメントが高速に実行されるように、テーブルにインデックスを追加するべき場所がわかります。また、<code class="literal">EXPLAIN</code> を使用して、オプティマイザがテーブルを最適な順序で結合しているかどうかを確認することもできます。<code class="literal">SELECT</code> ステートメントでテーブルが指定されている順序に対応する結合順序を使用するように、オプティマイザにヒントを提供するには、ステートメントを <code class="literal">SELECT</code> だけでなく、<code class="literal">SELECT STRAIGHT_JOIN</code> で始めます。(<a class="xref" href="sql-syntax.html#select" title="13.2.9 SELECT 構文">セクション13.2.9「SELECT 構文」</a>を参照してください。)
    </p><p>
      インデックスが使われるはずであると思うタイミングでそれらが使われていない問題がある場合、<code class="literal">ANALYZE TABLE</code> を実行して、オプティマイザが行う選択に影響する可能性があるキーのカーディナリティーなどのテーブル統計を更新します。<a class="xref" href="sql-syntax.html#analyze-table" title="13.7.2.1 ANALYZE TABLE 構文">セクション13.7.2.1「ANALYZE TABLE 構文」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="help"></a>13.8.3 HELP 構文</h3></div></div></div><a class="indexterm" name="idm139979075712944"></a><pre class="programlisting">
HELP '<em class="replaceable"><code>search_string</code></em>'
</pre><p>
      <code class="literal">HELP</code> は、MySQL リファレンスマニュアルのオンライン情報を返します。これが正しく動作するには、<code class="literal">mysql</code> データベース内のヘルプテーブルがヘルプトピック情報で初期化されている必要があります (<a class="xref" href="server-administration.html#server-side-help-support" title="5.1.10 サーバー側のヘルプ">セクション5.1.10「サーバー側のヘルプ」</a>を参照してください)。
    </p><p>
      <code class="literal">HELP</code> ステートメントは、ヘルプテーブル内の指定された検索文字列を検索し、その検索の結果を表示します。検索文字列は大文字と小文字が区別されません。
    </p><p>
      検索文字列にはワイルドカード文字 <span class="quote">「<span class="quote"><code class="literal">%</code></span>」</span> および <span class="quote">「<span class="quote"><code class="literal">_</code></span>」</span> を含めることができます。これらは <code class="literal">LIKE</code> 演算子で実行されるパターンマッチング演算と同じ意味を持ちます。たとえば、<code class="literal">HELP 'rep%'</code> は <code class="literal">rep</code> で始まるトピックのリストを返します。
    </p><p>
      HELP ステートメントは、次のいくつかの種類の検索文字列を理解します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          もっとも一般的なレベルでは、トップレベルのヘルプカテゴリのリストを取得するには <code class="literal">contents</code> を使用します。
        </p><pre class="programlisting">
HELP 'contents'
</pre></li><li class="listitem"><p>
          <code class="literal">Data Types</code> などの、特定のヘルプカテゴリ内のトピックのリストを取得するには、そのカテゴリ名を使用します。
        </p><pre class="programlisting">
HELP 'data types'
</pre></li><li class="listitem"><p>
          <code class="literal">ASCII()</code> 関数や <code class="literal">CREATE TABLE</code> ステートメントなどの、特定のヘルプトピックに関するヘルプを表示するには、関連する 1 つまたは複数のキーワードを使用します。
        </p><pre class="programlisting">
HELP 'ascii'
HELP 'create table'
</pre></li></ul></div><p>
      つまり、検索文字列はカテゴリ、多数のトピック、または 1 つのトピックに一致します。特定の検索文字列が項目のリストか、または 1 つのヘルプトピックのヘルプ情報のどちらを返すかが前もってわかるとはかぎりません。ただし、結果セット内の行数やカラム数を検査することによって、<code class="literal">HELP</code> がどのような種類の応答を返したかがわかります。
    </p><p>
      次の説明は、結果セットの可能性のある形式を示しています。ステートメントの例の出力は、<span class="command"><strong>mysql</strong></span> クライアントの使用時に表示されるなじみのある<span class="quote">「<span class="quote">表</span>」</span>または<span class="quote">「<span class="quote">垂直</span>」</span>形式を使用して示されています。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <span class="command"><strong>mysql</strong></span> 自体は、<code class="literal">HELP</code> の結果セットを別の方法で再フォーマットします。
      </p></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          空の結果セット
        </p><p>
          検索文字列に一致するものが見つかりませんでした。
        </p></li><li class="listitem"><p>
          3 つのカラムを含む単一行が含まれた結果セット
        </p><p>
          これは、検索文字列が 1 つのヘルプトピックに一致したことを示します。この結果には 3 つのカラムが含まれています。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">name</code>: トピック名。
            </p></li><li class="listitem"><p>
              <code class="literal">description</code>: トピックの説明的なヘルプテキスト。
            </p></li><li class="listitem"><p>
              <code class="literal">example</code>: 使用例または例。このカラムはブランクである可能性があります。
            </p></li></ul></div><p>
          例: <code class="literal">HELP 'replace'</code>
        </p><p>
          生成される結果:
        </p><pre class="programlisting">
name: REPLACE
description: Syntax:
REPLACE(str,from_str,to_str)

Returns the string str with all occurrences of the string from_str
replaced by the string to_str. REPLACE() performs a case-sensitive
match when searching for from_str.
example: mysql&gt; SELECT REPLACE('www.mysql.com', 'w', 'Ww');
        -&gt; 'WwWwWw.mysql.com'
</pre></li><li class="listitem"><p>
          2 つのカラムを含む複数の行が含まれた結果セット
        </p><p>
          これは、検索文字列が多数のヘルプトピックに一致したことを示します。この結果セットは、ヘルプトピック名を示します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">name</code>: ヘルプトピック名。
            </p></li><li class="listitem"><p>
              <code class="literal">is_it_category</code>: この名前がヘルプカテゴリを表す場合は <code class="literal">Y</code>、それ以外の場合は <code class="literal">N</code>。それ以外の場合、<code class="literal">name</code> 値は、<code class="literal">HELP</code> ステートメントへの引数として指定されると、指定された項目の説明が含まれた単一行の結果セットを生成するはずです。
            </p></li></ul></div><p>
          例: <code class="literal">HELP 'status'</code>
        </p><p>
          生成される結果:
        </p><pre class="programlisting">
+-----------------------+----------------+
| name                  | is_it_category |
+-----------------------+----------------+
| SHOW                  | N              |
| SHOW ENGINE           | N              |
| SHOW MASTER STATUS    | N              |
| SHOW PROCEDURE STATUS | N              |
| SHOW SLAVE STATUS     | N              |
| SHOW STATUS           | N              |
| SHOW TABLE STATUS     | N              |
+-----------------------+----------------+
</pre></li><li class="listitem"><p>
          3 つのカラムを含む複数の行が含まれた結果セット
        </p><p>
          これは、検索文字列がカテゴリに一致したことを示します。この結果セットには、カテゴリエントリが含まれています。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">source_category_name</code>: ヘルプカテゴリ名。
            </p></li><li class="listitem"><p>
              <code class="literal">name</code>: カテゴリまたはトピック名
            </p></li><li class="listitem"><p>
              <code class="literal">is_it_category</code>: この名前がヘルプカテゴリを表す場合は <code class="literal">Y</code>、それ以外の場合は <code class="literal">N</code>。それ以外の場合、<code class="literal">name</code> 値は、<code class="literal">HELP</code> ステートメントへの引数として指定されると、指定された項目の説明が含まれた単一行の結果セットを生成するはずです。
            </p></li></ul></div><p>
          例: <code class="literal">HELP 'functions'</code>
        </p><p>
          生成される結果:
        </p><pre class="programlisting">
+----------------------+-------------------------+----------------+
| source_category_name | name                    | is_it_category |
+----------------------+-------------------------+----------------+
| Functions            | CREATE FUNCTION         | N              |
| Functions            | DROP FUNCTION           | N              |
| Functions            | Bit Functions           | Y              |
| Functions            | Comparison operators    | Y              |
| Functions            | Control flow functions  | Y              |
| Functions            | Date and Time Functions | Y              |
| Functions            | Encryption Functions    | Y              |
| Functions            | Information Functions   | Y              |
| Functions            | Logical operators       | Y              |
| Functions            | Miscellaneous Functions | Y              |
| Functions            | Numeric Functions       | Y              |
| Functions            | String Functions        | Y              |
+----------------------+-------------------------+----------------+
</pre></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="use"></a>13.8.4 USE 構文</h3></div></div></div><a class="indexterm" name="idm139979075642544"></a><a class="indexterm" name="idm139979075641264"></a><pre class="programlisting">
USE <em class="replaceable"><code>db_name</code></em>
</pre><p>
      <code class="literal">USE <em class="replaceable"><code>db_name</code></em></code> ステートメントは、以降のステートメントのデフォルトの (現在の) データベースとして <em class="replaceable"><code>db_name</code></em> データベースを使用するよう MySQL に指示します。このデータベースは、セッションが終了するか、または別の <code class="literal">USE</code> ステートメントが発行されるまでデフォルトのままになります。
    </p><pre class="programlisting">
USE db1;
SELECT COUNT(*) FROM mytable;   # selects from db1.mytable
USE db2;
SELECT COUNT(*) FROM mytable;   # selects from db2.mytable
</pre><p>
      <code class="literal">USE</code> ステートメントを使用して特定のデータベースをデフォルトにしても、ユーザーがほかのデータベース内のテーブルにアクセスすることは除外されません。次の例では、<code class="literal">db1</code> データベースの <code class="literal">author</code> テーブルと、<code class="literal">db2</code> データベースの <code class="literal">editor</code> テーブルにアクセスします。
    </p><pre class="programlisting">
USE db1;
SELECT author_name,editor_name FROM author,db2.editor
  WHERE author.editor_id = db2.editor.editor_id;
</pre></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="functions.html">前</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="innodb-storage-engine.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第 12 章 関数と演算子 </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 第 14 章 InnoDB ストレージエンジン</td></tr></table></div><div class="copyright-footer"></div></body></html>
