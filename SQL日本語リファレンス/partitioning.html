<html lang="ja"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>第 19 章 パーティション化</title><link rel="stylesheet" type="text/css" href="mvl.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="MySQL 5.6 リファレンスマニュアル"><link rel="up" href="index.html" title="MySQL 5.6 リファレンスマニュアル"><link rel="prev" href="mysql-cluster.html" title="第 18 章 MySQL Cluster NDB 7.3 および MySQL Cluster NDB 7.4"><link rel="next" href="stored-programs-views.html" title="第 20 章 ストアドプログラムおよびビュー">
<script language="javascript" type="text/javascript">
  function addOnload(theFunc)
  {
    var previous = window.onload;
    if (typeof window.onload != 'function')
    {
      window.onload = theFunc;
    }
    else
    {
      window.onload = function()
      {
        previous();
        theFunc();
      }
    }
  }

  addOnload(function()
  {
    var base = new Date(1442918127*1000);
    var now = new Date();
    var diff = ((now-base)/1000)/(24*3600);

    if (diff > 90) {
      var nodes = document.getElementsByClassName('titlepage');
      nodes[0].innerHTML = '<p style="border: 5px #ff0000 solid; padding: 5px; margin 5px">' +
        'This copy of the manual is more than 90 days old. We encourage you to download a ' +
        'new version from <a href="http://dev.mysql.com">dev.mysql.com/doc</a>.</p>' + nodes[0].innerHTML;
    }
  });
</script>
<noscript></noscript>
</head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第 19 章 パーティション化</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="mysql-cluster.html">前</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="stored-programs-views.html">次へ</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="partitioning"></a>第 19 章 パーティション化</h1></div></div></div><div class="toc"><p><b>目次</b></p><dl class="toc"><dt><span class="section"><a href="partitioning.html#partitioning-overview">19.1 MySQL のパーティショニングの概要</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-types">19.2 パーティショニングタイプ</a></span></dt><dd><dl><dt><span class="section"><a href="partitioning.html#partitioning-range">19.2.1 RANGE パーティショニング</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-list">19.2.2 LIST パーティショニング</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-columns">19.2.3 COLUMNS パーティショニング</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-hash">19.2.4 HASH パーティショニング</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-key">19.2.5 KEY パーティショニング</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-subpartitions">19.2.6 サブパーティショニング</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-handling-nulls">19.2.7 MySQL パーティショニングによる NULL の扱い</a></span></dt></dl></dd><dt><span class="section"><a href="partitioning.html#partitioning-management">19.3 パーティション管理</a></span></dt><dd><dl><dt><span class="section"><a href="partitioning.html#partitioning-management-range-list">19.3.1 RANGE および LIST パーティションの管理</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-management-hash-key">19.3.2 HASH および KEY パーティションの管理</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-management-exchange">19.3.3 パーティションとサブパーティションをテーブルと交換する</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-maintenance">19.3.4 パーティションの保守</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-info">19.3.5 パーティションに関する情報を取得する</a></span></dt></dl></dd><dt><span class="section"><a href="partitioning.html#partitioning-pruning">19.4 パーティションプルーニング</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-selection">19.5 パーティション選択</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-limitations">19.6 パーティショニングの制約と制限</a></span></dt><dd><dl><dt><span class="section"><a href="partitioning.html#partitioning-limitations-partitioning-keys-unique-keys">19.6.1 パーティショニングキー、主キー、および一意キー</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-limitations-storage-engines">19.6.2 ストレージエンジンに関連するパーティショニング制限</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-limitations-functions">19.6.3 関数に関連するパーティショニング制限</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-limitations-locking">19.6.4 パーティショニングとロック</a></span></dt></dl></dd></dl></div><a class="indexterm" name="idm139979016329664"></a><a class="indexterm" name="idm139979016328352"></a><a class="indexterm" name="idm139979016326864"></a><a class="indexterm" name="idm139979016324800"></a><p>
    この章では、MySQL での<em class="firstterm">ユーザー定義パーティショニング</em>の実装について説明します。使用している MySQL サーバーがパーティショニングをサポートしているかどうかを判別するには、次のように <code class="literal">SHOW PLUGINS</code> ステートメントの出力を確認します。
  </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
      MySQL の以前のバージョンには、<code class="literal">have_partitioning</code> 変数がありましたが、非推奨となり、MySQL 5.6.1 で削除されました。
    </p></div><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW PLUGINS;</code></strong>
+------------+----------+----------------+---------+---------+
| Name       | Status   | Type           | Library | License |
+------------+----------+----------------+---------+---------+
| binlog     | ACTIVE   | STORAGE ENGINE | NULL    | GPL     |
<span class="bold"><strong>| partition  | ACTIVE   | STORAGE ENGINE | NULL    | GPL     |</strong></span>
| ARCHIVE    | ACTIVE   | STORAGE ENGINE | NULL    | GPL     |
| BLACKHOLE  | ACTIVE   | STORAGE ENGINE | NULL    | GPL     |
| CSV        | ACTIVE   | STORAGE ENGINE | NULL    | GPL     |
| FEDERATED  | DISABLED | STORAGE ENGINE | NULL    | GPL     |
| MEMORY     | ACTIVE   | STORAGE ENGINE | NULL    | GPL     |
| InnoDB     | ACTIVE   | STORAGE ENGINE | NULL    | GPL     |
| MRG_MYISAM | ACTIVE   | STORAGE ENGINE | NULL    | GPL     |
| MyISAM     | ACTIVE   | STORAGE ENGINE | NULL    | GPL     |
| ndbcluster | DISABLED | STORAGE ENGINE | NULL    | GPL     |
+------------+----------+----------------+---------+---------+
11 rows in set (0.00 sec)
</pre><p>
    次のようなクエリーを使用して <code class="literal">INFORMATION_SCHEMA.PLUGINS</code> テーブルを確認することもできます。
  </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT</code></strong> 
    -&gt;     <strong class="userinput"><code>PLUGIN_NAME as Name,</code></strong> 
    -&gt;     <strong class="userinput"><code>PLUGIN_VERSION as Version,</code></strong> 
    -&gt;     <strong class="userinput"><code>PLUGIN_STATUS as Status</code></strong> 
    -&gt; <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PLUGINS</code></strong> 
    -&gt; <strong class="userinput"><code>WHERE PLUGIN_TYPE='STORAGE ENGINE';</code></strong>
+--------------------+---------+--------+
| Name               | Version | Status |
+--------------------+---------+--------+
| binlog             | 1.0     | ACTIVE |
| CSV                | 1.0     | ACTIVE |
| MEMORY             | 1.0     | ACTIVE |
| MRG_MYISAM         | 1.0     | ACTIVE |
| MyISAM             | 1.0     | ACTIVE |
| PERFORMANCE_SCHEMA | 0.1     | ACTIVE |
| BLACKHOLE          | 1.0     | ACTIVE |
| ARCHIVE            | 3.0     | ACTIVE |
| InnoDB             | 5.6     | ACTIVE |
<span class="bold"><strong>| partition          | 1.0     | ACTIVE |</strong></span>
+--------------------+---------+--------+
10 rows in set (0.00 sec)
</pre><p>
    どちらの場合も、出力で <code class="literal">partition</code> プラグインの <code class="literal">Status</code> カラムに値 <code class="literal">ACTIVE</code> が示されていない (それぞれの例で太字で示されています) 場合、使用しているバージョンの MySQL にはパーティショニングサポートが組み込まれていません。
  </p><p>
    オラクルによって提供されている MySQL 5.6 Community バイナリには、パーティショニングのサポートが含まれています。商用の MySQL サーバーバイナリで提供されているパーティショニングサポートについては、<a class="xref" href="mysql-enterprise.html" title="第 25 章 MySQL Enterprise Edition">第25章「<i>MySQL Enterprise Edition</i>」</a>を参照してください。
  </p><p>
    ソースから MySQL 5.6 をコンパイルする場合にパーティショニングを有効にするには、<code class="option">-DWITH_PARTITION_STORAGE_ENGINE</code> オプションを指定してビルドを構成する必要があります。詳細は、<a class="xref" href="installing.html#source-installation" title="2.9 ソースから MySQL をインストールする">セクション2.9「ソースから MySQL をインストールする」</a>を参照してください。
  </p><p>
    使用している MySQL バイナリにパーティショニングサポートが組み込まれている場合は、それを有効にするために何も行う必要はありません (たとえば、<code class="filename">my.cnf</code> ファイルに特別なエントリを指定する必要はありません)。
  </p><p>
    パーティショニングサポートを無効にするには、<code class="option">--skip-partition</code> オプションを指定して MySQL サーバーを起動します。その場合は、<code class="literal">have_partitioning</code> の値が <code class="literal">DISABLED</code> になります。パーティショニングサポートを無効にすると、既存のパーティション化されたテーブルの表示、およびそれらの削除は行うことができますが (ただし、これを行うことはお勧めしません)、それ以外にそれらを操作したり、データにアクセスしたりすることはできません。
  </p><p>
    パーティショニングの概要およびパーティショニングの概念については、<a class="xref" href="partitioning.html#partitioning-overview" title="19.1 MySQL のパーティショニングの概要">セクション19.1「MySQL のパーティショニングの概要」</a>を参照してください。
  </p><p>
    MySQL では、いくつかのタイプのパーティショニングおよびサブパーティショニングをサポートしています。<a class="xref" href="partitioning.html#partitioning-types" title="19.2 パーティショニングタイプ">セクション19.2「パーティショニングタイプ」</a>および<a class="xref" href="partitioning.html#partitioning-subpartitions" title="19.2.6 サブパーティショニング">セクション19.2.6「サブパーティショニング」</a>を参照してください。
  </p><p>
    <a class="xref" href="partitioning.html#partitioning-management" title="19.3 パーティション管理">セクション19.3「パーティション管理」</a>では、既存のパーティション化されたテーブルでパーティションを追加、削除および変更する方法について説明しています。
  </p><p>
    <a class="xref" href="partitioning.html#partitioning-maintenance" title="19.3.4 パーティションの保守">セクション19.3.4「パーティションの保守」</a>では、パーティション化されたテーブルで使用するテーブル保守コマンドについて説明しています。
  </p><p>
    <code class="literal">INFORMATION_SCHEMA</code> データベースの <code class="literal">PARTITIONS</code> テーブルには、パーティションおよびパーティション化されたテーブルに関する情報があります。詳細は、<a class="xref" href="information-schema.html#partitions-table" title="21.13 INFORMATION_SCHEMA PARTITIONS テーブル">セクション21.13「INFORMATION_SCHEMA PARTITIONS テーブル」</a>を参照してください。このテーブルに対するクエリーのいくつかの例については、<a class="xref" href="partitioning.html#partitioning-handling-nulls" title="19.2.7 MySQL パーティショニングによる NULL の扱い">セクション19.2.7「MySQL パーティショニングによる NULL の扱い」</a>を参照してください。
  </p><p>
    MySQL 5.6 のパーティショニングの既知の問題については、<a class="xref" href="partitioning.html#partitioning-limitations" title="19.6 パーティショニングの制約と制限">セクション19.6「パーティショニングの制約と制限」</a>を参照してください。
  </p><p>
    また、パーティション化されたテーブルを使用して作業を行うときに、次のリソースが役に立つことがあります。
  </p><a class="indexterm" name="idm139979016283152"></a><p><b>追加のリソース </b>
      MySQL のユーザー定義パーティショニングに関するその他の情報ソースには、次のものがあります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <a class="ulink" href="http://forums.mysql.com/list.php?106" target="_top">MySQL パーティショニングフォーラム</a>
      </p><p>
        これは、MySQL パーティショニングテクノロジに興味があり実験している人のための公式ディスカッションフォーラムです。MySQL 開発者などからの発表や更新が掲載されています。パーティショニングの開発チームおよびドキュメントチームのメンバーによってモニターされています。
      </p></li><li class="listitem"><p>
        <a class="ulink" href="http://mikaelronstrom.blogspot.com/" target="_top">Mikael Ronström のブログ</a>
      </p><p>
        MySQL パーティショニングの設計者、およびリード開発者である Mikael Ronström が、MySQL パーティショニングおよび MySQL Cluster に関する記事を頻繁に掲載しています。
      </p></li><li class="listitem"><p>
        <a class="ulink" href="http://www.planetmysql.org/" target="_top">PlanetMySQL</a>
      </p><p>
        MySQL を使用している人が関心を持つと思われる MySQL 関連ブログをまとめた MySQL ニュースサイト。MySQL パーティショニングを使用している人が更新しているブログへのリンクをここでチェックしたり、自分のブログを追加したりすることをお勧めします。
      </p></li></ul></div><p>
    MySQL 5.6 バイナリは、<a class="ulink" href="http://dev.mysql.com/downloads/mysql/5.6.html" target="_top">http://dev.mysql.com/downloads/mysql/5.6.html</a>から入手できます。ただし、最新のパーティショニングバグ修正および機能追加が必要な場合は、Bazaar リポジトリからソースを取得できます。パーティショニングを有効にするには、<code class="option">-DWITH_PARTITION_STORAGE_ENGINE</code> オプションを指定してビルドを構成する必要があります。MySQL のビルドについては、<a class="xref" href="installing.html#source-installation" title="2.9 ソースから MySQL をインストールする">セクション2.9「ソースから MySQL をインストールする」</a>を参照してください。パーティションを有効にした MySQL 5.6 ビルドのコンパイルで問題が発生した場合は、「<a class="ulink" href="http://forums.mysql.com/list.php?106" target="_top">MySQL Partitioning Forum</a>」をチェックして、問題の解決策がそこにない場合は支援を要請してください。
  </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="partitioning-overview"></a>19.1 MySQL のパーティショニングの概要</h2></div></div></div><a class="indexterm" name="idm139979016266384"></a><p>
      このセクションでは、MySQL 5.6 のパーティショニングの概念について説明します。
    </p><p>
      パーティショニングの制約および機能制限については、<a class="xref" href="partitioning.html#partitioning-limitations" title="19.6 パーティショニングの制約と制限">セクション19.6「パーティショニングの制約と制限」</a>を参照してください。
    </p><p>
      SQL 標準では、データ保存の物理的な仕様に関するガイダンスはあまり提供されていません。SQL 言語自体が、それが動作するスキーマ、テーブル、行、またはカラムの基盤となるデータ構造やメディアと独立して動作するように意図されています。それにもかかわらず、ほとんどの高度なデータベース管理システムでは、ファイルシステム、ハードウェア、またはその両方について、特定のデータを格納するために使用される物理的な場所を判別する方法が開発されてきました。MySQL では、<code class="literal">InnoDB</code> ストレージエンジンによってテーブルスペースの認識がサポートされてきており、MySQL サーバーは、パーティショニングが導入される前から、異なるデータベースの格納に異なる物理的なディレクトリを使用するように構成できました (これを行う方法については、<a class="xref" href="optimization.html#symbolic-links" title="8.11.3.1 シンボリックリンクの使用">セクション8.11.3.1「シンボリックリンクの使用」</a>を参照してください)。
    </p><p>
      <em class="firstterm">パーティショニング</em>はこの認識をさらに一歩進めて、必要に応じて多くの部分を設定できるルールに従って、個々のテーブルの部分をファイルシステムに配分できるようにしています。それにより、テーブルの異なる部分が別個のテーブルとして別個の場所に格納されます。データを分割するためにユーザーが選択するルールは<em class="firstterm">パーティショニング関数</em>と呼ばれ、MySQL では法、範囲セットまたは値リストに対する単純な照合、内部ハッシュ関数、または線形ハッシュ関数が使用されます。関数は、ユーザーが指定したパーティショニングタイプに従って選択され、ユーザーが指定した式の値をパラメータとして取ります。この式には、使用されるパーティショニングのタイプに応じて、カラム値、1 つ以上のカラム値を操作する関数、または 1 つ以上のカラム値のセットを指定できます。
    </p><p>
      <code class="literal">RANGE</code>、<code class="literal">LIST</code>、および [<code class="literal">LINEAR</code>] <code class="literal">HASH</code> パーティショニングの場合、パーティショニングカラムの値はパーティショニング関数に渡され、特定のレコードを格納すべきパーティションの番号を表す整数値が返されます。この関数は非定数および非ランダムである必要があります。クエリーを含めることはできませんが、式が <code class="literal">NULL</code> または次のような整数 <em class="replaceable"><code>intval</code></em> を返すかぎり、MySQL で有効な SQL 式を使用できます。
    </p><pre class="programlisting">
-MAXVALUE &lt;= <em class="replaceable"><code>intval</code></em> &lt;= MAXVALUE
</pre><p>
      (<code class="literal">MAXVALUE</code> は対象となる整数型の上限を表すために使用されます。<code class="literal">-MAXVALUE</code> は下限を表します。)
    </p><p>
      [<code class="literal">LINEAR</code>] <code class="literal">KEY</code>、<code class="literal">RANGE COLUMNS</code>、および <code class="literal">LIST COLUMNS</code> パーティショニングの場合、パーティショニング式は 1 つ以上のカラムのリストから構成されます。
    </p><p>
      [<code class="literal">LINEAR</code>] <code class="literal">KEY</code> パーティショニングの場合、パーティショニング関数は MySQL によって提供されます。
    </p><p>
      許可されるパーティショニングカラムタイプおよびパーティショニング関数については、<a class="xref" href="partitioning.html#partitioning-types" title="19.2 パーティショニングタイプ">セクション19.2「パーティショニングタイプ」</a>、およびパーティショニング構文の説明および追加例を示している<a class="xref" href="sql-syntax.html#create-table" title="13.1.17 CREATE TABLE 構文">セクション13.1.17「CREATE TABLE 構文」</a>を参照してください。パーティショニング関数の制約については、<a class="xref" href="partitioning.html#partitioning-limitations-functions" title="19.6.3 関数に関連するパーティショニング制限">セクション19.6.3「関数に関連するパーティショニング制限」</a>を参照してください。
    </p><p>
      これは<em class="firstterm">「水平パーティショニング」</em>と呼ばれます。つまり、テーブル内の異なる行を異なる物理パーティションに割り当てることができます。MySQL 5.6 は、テーブルの異なるカラムが異なる物理パーティションに割り当てられる、<em class="firstterm">「垂直パーティショニング」</em>はサポートしていません。現時点で、垂直パーティショニングを MySQL 5.6 に導入する計画はありません。
    </p><p>
      MySQL サーバーバイナリがユーザー定義パーティショニングをサポートしているかどうかの判断については、<a class="xref" href="partitioning.html" title="第 19 章 パーティション化">第19章「<i>パーティション化</i>」</a>を参照してください。
    </p><p>
      パーティション化されたテーブルを作成する場合、MySQL サーバーによってサポートされているほとんどのストレージエンジンを使用できます。MySQL パーティショニングエンジンは別のレイヤーで実行されており、それらのいずれともやり取りできます。MySQL 5.6 では、同じパーティション化されたテーブルのすべてのパーティションは同じストレージエンジンを使用する必要があります。たとえば、あるパーティションに <code class="literal">MyISAM</code>、別のものに <code class="literal">InnoDB</code> を使用することはできません。ただし、同じ MySQL サーバーまたは同じデータベース上の異なるパーティション化されたテーブルに、異なるストレージエンジンを使用することはできます。
    </p><p>
      MySQL パーティショニングは、<code class="literal">MERGE</code>、<code class="literal">CSV</code>、または <code class="literal">FEDERATED</code> ストレージエンジンで使用できません。
    </p><p>
      <code class="literal">KEY</code> または <code class="literal">LINEAR KEY</code> によるパーティショニングは <code class="literal">NDB</code> で使用できますが、ほかのタイプのユーザー定義パーティショニングはこのストレージエンジンを使用するテーブルでサポートされません。また、ユーザー定義パーティショニングを使用する <code class="literal">NDB</code> テーブルには明示的な主キーが必要であり、テーブルのパーティショニング式で参照されるカラムは主キーの一部である必要があります。ただし、ユーザーパーティション化された <code class="literal">NDB</code> テーブルを作成または変更するために使用される <code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> ステートメントの <code class="literal">PARTITION BY KEY</code> 句または <code class="literal">PARTITION BY LINEAR KEY</code> 句にカラムが 1 つもリストされていない場合は、テーブルに明示的な主キーは必要ありません。詳細は、<a class="xref" href="mysql-cluster.html#mysql-cluster-limitations-syntax" title="18.1.6.1 MySQL Cluster での SQL 構文の不適合">セクション18.1.6.1「MySQL Cluster での SQL 構文の不適合」</a>を参照してください。
    </p><p>
      パーティション化されたテーブルに特定のストレージエンジンを使用するために必要なのは、パーティション化されていないテーブルの場合と同様に、<code class="literal">[STORAGE] ENGINE</code> オプションを使用することだけです。ただし、<code class="literal">[STORAGE] ENGINE</code> (およびほかのテーブルオプション) は、<code class="literal">CREATE TABLE</code> ステートメントでパーティショニングオプションを使用する<span class="emphasis"><em>前に</em></span>指定する必要があります。次の例は、ハッシュによって 6 個のパーティションにパーティション化され、<code class="literal">InnoDB</code> ストレージエンジンを使用するテーブルの作成方法を示しています。
    </p><pre class="programlisting">
CREATE TABLE ti (id INT, amount DECIMAL(7,2), tr_date DATE)
    ENGINE=INNODB
    PARTITION BY HASH( MONTH(tr_date) )
    PARTITIONS 6;
</pre><p>
      各 <code class="literal">PARTITION</code> 句に <code class="literal">[STORAGE] ENGINE</code> オプションを含めることはできますが、MySQL 5.6 ではこれは効果がありません。
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        パーティショニングはテーブルのすべてのデータおよびインデックスに適用されます。データだけにパーティション化しインデックスは行わないことはできず (その逆も不可)、テーブルの一部のみをパーティション化することもできません。
      </p></div><p>
      各パーティションのデータおよびインデックスを特定のディレクトリに割り当てるには、パーティション化されたテーブルを作成するために使用する <code class="literal">CREATE TABLE</code> ステートメントの <code class="literal">PARTITION</code> 句に <code class="literal">DATA DIRECTORY</code> および <code class="literal">INDEX DIRECTORY</code> オプションを使用します。
    </p><p>
      Windows 上の <code class="literal">MyISAM</code> テーブルの個別のパーティションまたはサブパーティションでは、<code class="literal">DATA DIRECTORY</code> および <code class="literal">INDEX DIRECTORY</code> はサポートされません。これらは <code class="literal">InnoDB</code> テーブルの個別のパーティションおよびサブパーティションでサポートされます (すべてのプラットフォームと同様)。
    </p><a class="indexterm" name="idm139979016201776"></a><p>
      また、<code class="literal">MAX_ROWS</code> および <code class="literal">MIN_ROWS</code> は、各パーティションに格納できる行のそれぞれ最大数および最小数を決定するために使用できます。<code class="literal">MAX_ROWS</code> オプションは、MySQL Cluster テーブルを追加パーティションで作成し、ハッシュインデックスにより大きなストレージを確保するために役立つことがあります。詳細は、<code class="literal">DataMemory</code> データノード構成パラメータのドキュメント、および <a class="xref" href="mysql-cluster.html#mysql-cluster-nodes-groups" title="18.1.2 MySQL Cluster のノード、ノードグループ、レプリカ、およびパーティション">セクション18.1.2「MySQL Cluster のノード、ノードグループ、レプリカ、およびパーティション」</a>を参照してください。
    </p><a class="indexterm" name="idm139979016194624"></a><p>
      パーティショニングのいくつかの利点を次に示します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          パーティショニングを使用すると、単一ディスクまたはファイルシステムパーティションに保持できるデータより多くのデータを 1 つのテーブルに格納できます。
        </p></li><li class="listitem"><p>
          有効性を失っているデータは、多くの場合、そのデータのみが含まれているパーティションを削除することによって、パーティション化されたテーブルから簡単に削除できます。反対に、新しいデータを追加する処理は、そのデータだけを格納するための 1 つ以上の新しいパーティションを追加することによって、非常に便利になることがあります。
        </p></li><li class="listitem"><p>
          指定された <code class="literal">WHERE</code> 句を満たすデータを 1 つ以上のパーティションのみに格納できることによって、検索からほかのパーティションが自動的に除外され、一部のクエリーが大幅に最適化されることがあります。パーティションはパーティション化されたテーブルが作成されたあとに変更できるため、使用頻度の高いクエリー (パーティショニングスキームが最初に設定されたときはあまり使用されていなかった) を改善するためにデータを再編成できます。一致しないパーティション (およびそれらに含まれている行) を除外するこの機能は、よく<em class="firstterm">パーティションプルーニング</em>と呼ばれます。詳細は、<a class="xref" href="partitioning.html#partitioning-pruning" title="19.4 パーティションプルーニング">セクション19.4「パーティションプルーニング」</a>を参照してください。
        </p><p>
          また、MySQL 5.6 ではクエリーで明示的なパーティション選択がサポートされます。たとえば、<code class="literal">SELECT * FROM t PARTITION (p0,p1) WHERE c &lt; 5</code> は、パーティション <code class="literal">p0</code> および <code class="literal">p1</code> の <code class="literal">WHERE</code> 条件に一致する行のみを選択します。この場合、MySQL はテーブル <code class="literal">t</code> のほかのパーティションをチェックしません。これにより、検査するパーティションが事前にわかっているときにクエリー速度が大幅に向上することがあります。パーティション選択は、データ変更ステートメント (<code class="literal">DELETE</code>、<code class="literal">INSERT</code>、<code class="literal">REPLACE</code>、<code class="literal">UPDATE</code>、<code class="literal">LOAD DATA</code>、および <code class="literal">LOAD XML</code>) でもサポートされます。詳細および例については、これらのステートメントの説明を参照してください。
        </p></li></ul></div><p>
      通常はパーティショニングに関連付けられるその他の利点を次に示します。これらの機能は MySQL パーティショニングに現在実装されていませんが、オラクルの優先事項リストの上位にあります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">SUM()</code>、<code class="literal">COUNT()</code> などの集約関数を含むクエリーを簡単に並列化できます。そのようなクエリーの簡単な例として、<code class="literal">SELECT salesperson_id, COUNT(orders) as order_total FROM sales GROUP BY salesperson_id;</code> を挙げられます。<span class="quote">「<span class="quote">並列化</span>」</span>することで、クエリーを各パーティションで同時に実行してから、すべてのパーティションで取得される結果を単に集約するだけで最終的な結果が得られることを意味します。
        </p></li><li class="listitem"><p>
          複数のディスクにデータシークを分散することによって、クエリーのスループットが向上します。
        </p></li></ul></div><p>
      MySQL パーティショニング開発は継続されているため、このセクションおよび章が更新されているかどうかを頻繁にチェックしてください。
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="partitioning-types"></a>19.2 パーティショニングタイプ</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="partitioning.html#partitioning-range">19.2.1 RANGE パーティショニング</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-list">19.2.2 LIST パーティショニング</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-columns">19.2.3 COLUMNS パーティショニング</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-hash">19.2.4 HASH パーティショニング</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-key">19.2.5 KEY パーティショニング</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-subpartitions">19.2.6 サブパーティショニング</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-handling-nulls">19.2.7 MySQL パーティショニングによる NULL の扱い</a></span></dt></dl></div><a class="indexterm" name="idm139979016164016"></a><p>
      このセクションでは、MySQL 5.6 で使用できるパーティショニングのタイプについて説明します。これらには、次に一覧したタイプが含まれます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>RANGE パーティショニング </b>
            このタイプのパーティショニングは、指定された範囲に含まれるカラム値に基づいて、行をパーティションに割り当てます。<a class="xref" href="partitioning.html#partitioning-range" title="19.2.1 RANGE パーティショニング">セクション19.2.1「RANGE パーティショニング」</a>を参照してください。このタイプを拡張した <code class="literal">RANGE COLUMNS</code> については、<a class="xref" href="partitioning.html#partitioning-columns-range" title="19.2.3.1 RANGE COLUMNS パーティショニング">セクション19.2.3.1「RANGE COLUMNS パーティショニング」</a>を参照してください。
          </p></li><li class="listitem"><p><b>LIST パーティショニング </b>
            <code class="literal">RANGE</code> によるパーティショニングに似ていますが、別個の値のセットのいずれかに一致するカラムに基づいて、パーティションが選択されます。<a class="xref" href="partitioning.html#partitioning-list" title="19.2.2 LIST パーティショニング">セクション19.2.2「LIST パーティショニング」</a>を参照してください。このタイプを拡張した <code class="literal">LIST COLUMNS</code> については、<a class="xref" href="partitioning.html#partitioning-columns-list" title="19.2.3.2 LIST COLUMNS パーティショニング">セクション19.2.3.2「LIST COLUMNS パーティショニング」</a>を参照してください。
          </p></li><li class="listitem"><p><b>HASH パーティショニング </b>
            このタイプのパーティショニングでは、テーブルに挿入される行内のカラム値を操作するユーザー定義式によって返される値に基づいて、パーティションが選択されます。関数は、負ではない整数値を返す MySQL の有効な式で構成できます。このタイプを拡張した <code class="literal">LINEAR HASH</code> も使用できます。<a class="xref" href="partitioning.html#partitioning-hash" title="19.2.4 HASH パーティショニング">セクション19.2.4「HASH パーティショニング」</a>を参照してください。
          </p></li><li class="listitem"><p><b>KEY パーティショニング </b>
            このタイプのパーティショニングは、<code class="literal">HASH</code> によるパーティショニングに似ていますが、評価される 1 つ以上のカラムのみを指定し、MySQL サーバーが独自のハッシュ関数を提供します。MySQL によって提供されるハッシュ関数ではカラムデータ型に関係なく整数結果が保証されるため、これらのカラムに整数以外の値が含まれていてもかまいません。このタイプを拡張した <code class="literal">LINEAR KEY</code> も使用できます。<a class="xref" href="partitioning.html#partitioning-key" title="19.2.5 KEY パーティショニング">セクション19.2.5「KEY パーティショニング」</a>を参照してください。
          </p></li></ul></div><a class="indexterm" name="idm139979016143216"></a><a class="indexterm" name="idm139979016141072"></a><p>
      データベースパーティショニングの非常に一般的な使用方法は、日付によってデータを分けることです。一部のデータベースシステムは、MySQL 5.6 では実装されていない、明示的な日付パーティショニングをサポートしています。ただし、MySQL で、<code class="literal">DATE</code>、<code class="literal">TIME</code>、または <code class="literal">DATETIME</code> カラムに基づいて、またはそのようなカラムを使用する式に基づいて、パーティショニングスキームを作成することは難しくありません。
    </p><p>
      <code class="literal">KEY</code> または <code class="literal">LINEAR KEY</code> でパーティショニングする場合は、<code class="literal">DATE</code>、<code class="literal">TIME</code>、または <code class="literal">DATETIME</code> カラムを、カラム値の変更を実行しないパーティショニングカラムとして使用できます。たとえば、次のテーブル作成ステートメントは MySQL で完全に有効です。
    </p><pre class="programlisting">
CREATE TABLE members (
    firstname VARCHAR(25) NOT NULL,
    lastname VARCHAR(25) NOT NULL,
    username VARCHAR(16) NOT NULL,
    email VARCHAR(35),
    joined DATE NOT NULL
)
PARTITION BY KEY(joined)
PARTITIONS 6;
</pre><p>
      MySQL 5.6 では、<code class="literal">RANGE COLUMNS</code> および <code class="literal">LIST COLUMNS</code> パーティショニングを使用して、<code class="literal">DATE</code> または <code class="literal">DATETIME</code> カラムをパーティショニングカラムとして使用することもできます。
    </p><p>
      ただし、MySQL のほかのパーティショニングタイプでは、整数値または <code class="literal">NULL</code> を返すパーティショニング式が必要です。<code class="literal">RANGE</code>、<code class="literal">LIST</code>、<code class="literal">HASH</code>、または <code class="literal">LINEAR HASH</code> による日付ベースパーティショニングを使用する場合は、次のように単純に <code class="literal">DATE</code>、<code class="literal">TIME</code>、または <code class="literal">DATETIME</code> カラムを操作してそのような値を返す関数を使用できます。
    </p><pre class="programlisting">
CREATE TABLE members (
    firstname VARCHAR(25) NOT NULL,
    lastname VARCHAR(25) NOT NULL,
    username VARCHAR(16) NOT NULL,
    email VARCHAR(35),
    joined DATE NOT NULL
)
PARTITION BY RANGE( YEAR(joined) ) (
    PARTITION p0 VALUES LESS THAN (1960),
    PARTITION p1 VALUES LESS THAN (1970),
    PARTITION p2 VALUES LESS THAN (1980),
    PARTITION p3 VALUES LESS THAN (1990),
    PARTITION p4 VALUES LESS THAN MAXVALUE
);
</pre><p>
      日付を使用したパーティショニングの追加例は、この章の次のセクションにあります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="xref" href="partitioning.html#partitioning-range" title="19.2.1 RANGE パーティショニング">セクション19.2.1「RANGE パーティショニング」</a>
        </p></li><li class="listitem"><p>
          <a class="xref" href="partitioning.html#partitioning-hash" title="19.2.4 HASH パーティショニング">セクション19.2.4「HASH パーティショニング」</a>
        </p></li><li class="listitem"><p>
          <a class="xref" href="partitioning.html#partitioning-linear-hash" title="19.2.4.1 LINEAR HASH パーティショニング">セクション19.2.4.1「LINEAR HASH パーティショニング」</a>
        </p></li></ul></div><p>
      日付ベースパーティショニングのより複雑な例については、次のセクションを参照してください。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="xref" href="partitioning.html#partitioning-pruning" title="19.4 パーティションプルーニング">セクション19.4「パーティションプルーニング」</a>
        </p></li><li class="listitem"><p>
          <a class="xref" href="partitioning.html#partitioning-subpartitions" title="19.2.6 サブパーティショニング">セクション19.2.6「サブパーティショニング」</a>
        </p></li></ul></div><p>
      MySQL パーティショニングは、<code class="literal">TO_DAYS()</code>、<code class="literal">YEAR()</code>、および <code class="literal">TO_SECONDS()</code> 関数で使用するために最適化されています。ただし、整数または <code class="literal">NULL</code> を返すほかの日時関数 (<code class="literal">WEEKDAY()</code>、<code class="literal">DAYOFYEAR()</code>、<code class="literal">MONTH()</code> など) を使用できます。そのような関数の詳細については、<a class="xref" href="functions.html#date-and-time-functions" title="12.7 日付および時間関数">セクション12.7「日付および時間関数」</a>を参照してください。
    </p><p>
      使用するパーティショニングのタイプにかかわらず、パーティションには作成時に常に <code class="literal">0</code> から始まる番号が順番に自動的に付けられることを覚えておくことが重要です。新しい行がパーティション化されたテーブルに挿入されるときは、これらのパーティション番号が正しいパーティションを識別するために使用されます。たとえば、テーブルで 4 つのパーティションが使用される場合、これらのパーティションには <code class="literal">0</code>、<code class="literal">1</code>、<code class="literal">2</code>、および <code class="literal">3</code> という番号が付けられます。<code class="literal">RANGE</code> および <code class="literal">LIST</code> パーティショニングタイプの場合は、各パーティション番号のパーティションが定義されている必要があります。<code class="literal">HASH</code> パーティショニングの場合は、使用されるユーザー関数が <code class="literal">0</code> より大きい整数値を返す必要があります。<code class="literal">KEY</code> パーティショニングの場合は、MySQL サーバーが内部で使用しているハッシュ関数によって、この問題が自動的に対処されます。
    </p><p>
      パーティションの名前は通常、ほかの MySQL 識別子 (テーブル名、データベース名など) を制御するルールに従っています。ただし、パーティション名では大文字/小文字が区別されません。たとえば、次の <code class="literal">CREATE TABLE</code> ステートメントは、示されているように失敗します。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE t2 (val INT)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY LIST(val)(</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION mypart VALUES IN (1,3,5),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION MyPart VALUES IN (2,4,6)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
ERROR 1488 (HY000): Duplicate partition name mypart
</pre><p>
      失敗は、MySQL がパーティション名 <code class="literal">mypart</code> と <code class="literal">MyPart</code> の違いを認識できないために発生します。
    </p><p>
      テーブルのパーティション番号を指定するときは、先行ゼロなしのゼロ以外の正の整数リテラルとして表現する必要があり、<code class="literal">0.8E+01</code> や <code class="literal">6-2</code> などの式であってはいけません (これが整数値に評価されるとしても)。小数は許可されません。
    </p><p>
      以降のセクションでは、各パーティションタイプの作成に使用できるすべての形式の構文を提供しているわけではありません。この情報については、<a class="xref" href="sql-syntax.html#create-table" title="13.1.17 CREATE TABLE 構文">セクション13.1.17「CREATE TABLE 構文」</a>も参照してみてください。
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="partitioning-range"></a>19.2.1 RANGE パーティショニング</h3></div></div></div><a class="indexterm" name="idm139979016075440"></a><a class="indexterm" name="idm139979016073296"></a><p>
        範囲によってパーティション化されるテーブルは、各パーティションに含まれる行のパーティショニング式値が指定された範囲に収まるようにパーティション化されます。範囲は、連続しているけれども重複しないものであるべきで、<code class="literal">VALUES LESS THAN</code> 演算子を使用して定義されます。次のいくつかの例では、20 のビデオ店で構成されるチェーン (1 から 20 までの番号が付けられている) の従業員レコードを保持する、次のようなテーブルを作成していると想定してください。
      </p><pre class="programlisting">
CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT NOT NULL,
    store_id INT NOT NULL
);
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          ここで使用する <code class="literal">employees</code> テーブルには主キーまたは一意キーがありません。これらの例はここでの説明のためのもので、実際のテーブルは主キー、一意キー、またはその両方を備えている可能性がきわめて高く、パーティショニングカラムに利用できる選択肢はこれらのキー (ある場合) に使用されるカラムに依存します。これらの事項については、<a class="xref" href="partitioning.html#partitioning-limitations-partitioning-keys-unique-keys" title="19.6.1 パーティショニングキー、主キー、および一意キー">セクション19.6.1「パーティショニングキー、主キー、および一意キー」</a>を参照してください。
        </p></div><p>
        このテーブルは、必要に応じていくつかの方法で、範囲によるパーティション化を実行できます。1 つの方法は、<code class="literal">store_id</code> カラムを使用することです。たとえば、次のように <code class="literal">PARTITION BY RANGE</code> 句を追加することで、テーブルを 4 つのパーティションに分割することを決定できます。
      </p><pre class="programlisting">
CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT NOT NULL,
    store_id INT NOT NULL
)
PARTITION BY RANGE (store_id) (
    PARTITION p0 VALUES LESS THAN (6),
    PARTITION p1 VALUES LESS THAN (11),
    PARTITION p2 VALUES LESS THAN (16),
    PARTITION p3 VALUES LESS THAN (21)
);
</pre><p>
        このパーティショニングスキームでは、店舗 1 から店舗 5 で働いている従業員に対応するすべての行がパーティション <code class="literal">p0</code> に格納され、店舗 6 から店舗 10 の従業員がパーティション <code class="literal">p1</code> に格納されます (以下同様)。各パーティションは、もっとも小さい値からもっとも大きい値の順で定義されます。これは <code class="literal">PARTITION BY RANGE</code> 構文の要件です。これは、C または Java の一連の <code class="literal">if ... elseif ...</code> ステートメントに似ていると考えることができます。
      </p><p>
        データ <code class="literal">(72, 'Michael', 'Widenius', '1998-06-25', NULL, 13)</code> が含まれている新しい行がパーティション <code class="literal">p2</code> に挿入されることは簡単に判断できますが、このチェーンに 21 番目の店舗が追加されたらどうなるでしょうか。<sup></sup>このスキームでは、<code class="literal">store_id</code> が 20 よりも大きい行に対応するルールがなく、サーバーはどこに置くべきかがわからないため、エラーになります。これが発生しないようにするには、<span class="quote">「<span class="quote">すべての状況に対応する</span>」</span> <code class="literal">VALUES LESS THAN</code> 句を <code class="literal">CREATE TABLE</code> ステートメントで使用して、明示的に指定されている最大値を超えるすべての値に備えます。
      </p><pre class="programlisting">
CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT NOT NULL,
    store_id INT NOT NULL
)
PARTITION BY RANGE (store_id) (
    PARTITION p0 VALUES LESS THAN (6),
    PARTITION p1 VALUES LESS THAN (11),
    PARTITION p2 VALUES LESS THAN (16),
    <span class="emphasis"><em>PARTITION p3 VALUES LESS THAN MAXVALUE</em></span>
);
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          一致する値が見つからないときにエラーを回避するための別の方法は、<code class="literal">INSERT</code> ステートメントの一部として <code class="literal">IGNORE</code> キーワードを使用することです。例については、<a class="xref" href="partitioning.html#partitioning-list" title="19.2.2 LIST パーティショニング">セクション19.2.2「LIST パーティショニング」</a>を参照してください。また、<code class="literal">IGNORE</code> の一般的な情報については、<a class="xref" href="sql-syntax.html#insert" title="13.2.5 INSERT 構文">セクション13.2.5「INSERT 構文」</a>を参照してください。
        </p></div><p>
        <code class="literal">MAXVALUE</code> は、可能な最大整数値よりも確実に大きな整数値を表します (数学用語では、<em class="firstterm">上限</em>です)。これによって、<code class="literal">store_id</code> カラム値が 16 (定義されている最大値) 以上である行は、パーティション <code class="literal">p3</code> に格納されます。将来のある時点で、店舗の数が 25、30、またはそれ以上に増加したときは、<code class="literal">ALTER TABLE</code> ステートメントを使用して、店舗 21-25、26-30 などのための新しいパーティションを追加できます (これを行う方法の詳細については、<a class="xref" href="partitioning.html#partitioning-management" title="19.3 パーティション管理">セクション19.3「パーティション管理」</a>を参照してください)。
      </p><p>
        同様に、従業員ジョブコードに基づいて (つまり、<code class="literal">job_code</code> カラム値の範囲に基づいて) テーブルをパーティション化できます。たとえば、正規 (インストア) 従業員に 2 桁のジョブコード、オフィスおよびサポート従業員に 3 桁のコード、および管理職に 4 桁のコードが使用されると想定すると、次のステートメントを使用してパーティション化されたテーブルを作成できます。
      </p><pre class="programlisting">
CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT NOT NULL,
    store_id INT NOT NULL
)
PARTITION BY RANGE (job_code) (
    PARTITION p0 VALUES LESS THAN (100),
    PARTITION p1 VALUES LESS THAN (1000),
    PARTITION p2 VALUES LESS THAN (10000)
);
</pre><p>
        この例では、インストア従業員に関連するすべての行はパーティション <code class="literal">p0</code>、オフィスおよびサポートスタッフに関連するものは <code class="literal">p1</code>、および管理職に関連するものはパーティション <code class="literal">p2</code> に格納されます。
      </p><p>
        <code class="literal">VALUES LESS THAN</code> 句に式を使用することもできます。ただし、MySQL が式の戻り値を <code class="literal">LESS THAN</code> (<code class="literal">&lt;</code>) 比較の一部として評価できる必要があります。
      </p><a class="indexterm" name="idm139979016030800"></a><p>
        店舗番号に従ってテーブルデータを分割するのではなく、代わりに 2 つの <code class="literal">DATE</code> カラムのうちの 1 つに基づく式を使用できます。たとえば、各従業員が会社を退職した年 (つまり、<code class="literal">YEAR(separated)</code> の値) に基づいてパーティション化するとします。そのようなパーティショニングスキームを実装する <code class="literal">CREATE TABLE</code> ステートメントの例を次に示します。
      </p><pre class="programlisting">
CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT,
    store_id INT
)
PARTITION BY RANGE ( YEAR(separated) ) (
    PARTITION p0 VALUES LESS THAN (1991),
    PARTITION p1 VALUES LESS THAN (1996),
    PARTITION p2 VALUES LESS THAN (2001),
    PARTITION p3 VALUES LESS THAN MAXVALUE
);
</pre><p>
        このスキームでは、1991 年より前に退職したすべての従業員の場合、行はパーティション <code class="literal">p0</code> に格納されます。1991 年から 1995 年までに退職した人は <code class="literal">p1</code>、1996 年から 2000 年までに退職した人は <code class="literal">p2</code>、および 2000 年よりあとに退職した従業員は <code class="literal">p3</code> に格納されます。
      </p><p>
        次の例に示すように、<code class="literal">UNIX_TIMESTAMP()</code> 関数を使用して、<code class="literal">TIMESTAMP</code> カラムの値に基づいて、<code class="literal">RANGE</code> によってテーブルをパーティション化することもできます。
      </p><pre class="programlisting">
CREATE TABLE quarterly_report_status (
    report_id INT NOT NULL,
    report_status VARCHAR(20) NOT NULL,
    report_updated TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
)
PARTITION BY RANGE ( UNIX_TIMESTAMP(report_updated) ) (
    PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-01-01 00:00:00') ),
    PARTITION p1 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-04-01 00:00:00') ),
    PARTITION p2 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-07-01 00:00:00') ),
    PARTITION p3 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-10-01 00:00:00') ),
    PARTITION p4 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-01-01 00:00:00') ),
    PARTITION p5 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-04-01 00:00:00') ),
    PARTITION p6 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-07-01 00:00:00') ),
    PARTITION p7 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-10-01 00:00:00') ),
    PARTITION p8 VALUES LESS THAN ( UNIX_TIMESTAMP('2010-01-01 00:00:00') ),
    PARTITION p9 VALUES LESS THAN (MAXVALUE)
);
</pre><p>
        <code class="literal">TIMESTAMP</code> 値を含むほかの式は許可されません(Bug #42849 を参照してください)。
      </p><p>
        次の条件の 1 つ以上が true のときは、RANGE パーティショニングが特に役立ちます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <span class="quote">「<span class="quote">古い</span>」</span>データを削除したい、またはする必要がある。直前のパーティショニングスキームを使用している場合は、単純に <code class="literal">ALTER TABLE employees DROP PARTITION p0;</code> を使用して 1991 年より前に会社を退職した従業員に関連するすべての行を削除できます。(詳細は、<a class="xref" href="sql-syntax.html#alter-table" title="13.1.7 ALTER TABLE 構文">セクション13.1.7「ALTER TABLE 構文」</a>および<a class="xref" href="partitioning.html#partitioning-management" title="19.3 パーティション管理">セクション19.3「パーティション管理」</a>を参照してください)。テーブルに多数の行がある場合、これは <code class="literal">DELETE FROM employees WHERE YEAR(separated) &lt;= 1990;</code> などの <code class="literal">DELETE</code> クエリーを実行するよりもはるかに効率的な場合があります。
          </p></li><li class="listitem"><p>
            日付または時間値、または何らかのほかの一連値から生じる値が含まれるカラムを使用したい。
          </p></li><li class="listitem"><p>
            テーブルのパーティショニングに使用されるカラムに直接依存するクエリーを頻繁に実行する。たとえば、<code class="literal">EXPLAIN PARTITIONS SELECT COUNT(*) FROM employees WHERE separated BETWEEN '2000-01-01' AND '2000-12-31' GROUP BY store_id;</code> などのクエリーを実行する場合、MySQL はパーティション <code class="literal">p2</code> のみをスキャンする必要であることをすばやく判断できます (残りのパーティションに <code class="literal">WHERE</code> 句を満たすレコードが含まれるはずがないため)。これがどのように実現されるかについての詳細は、<a class="xref" href="partitioning.html#partitioning-pruning" title="19.4 パーティションプルーニング">セクション19.4「パーティションプルーニング」</a>を参照してください。
          </p></li></ul></div><p>
        このタイプのパーティショニングのバリアントが <code class="literal">RANGE COLUMNS</code> パーティショニングです。<code class="literal">RANGE COLUMNS</code> によるパーティショニングでは、複数のカラムを使用してパーティショニング範囲を定義できます (パーティション内での行の配置、およびパーティションプルーニングを実行するときに特定のパーティションの包含または除外を判断する際に適用されます)。詳細は、<a class="xref" href="partitioning.html#partitioning-columns-range" title="19.2.3.1 RANGE COLUMNS パーティショニング">セクション19.2.3.1「RANGE COLUMNS パーティショニング」</a>を参照してください。
      </p><p><a name="partitioning-time-intervals"></a><b>時間間隔に基づくパーティショニングスキーム </b>
          MySQL 5.6 で時間の範囲または間隔に基づいてパーティショニングスキームを実装する場合は、2 つの方法があります。
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            次のように、<code class="literal">RANGE</code> によってテーブルをパーティション化し、パーティショニング式に <code class="literal">DATE</code>、<code class="literal">TIME</code>、または <code class="literal">DATETIME</code> カラムを操作して整数値を返す関数を使用します。
          </p><pre class="programlisting">
CREATE TABLE members (
    firstname VARCHAR(25) NOT NULL,
    lastname VARCHAR(25) NOT NULL,
    username VARCHAR(16) NOT NULL,
    email VARCHAR(35),
    joined DATE NOT NULL
)
PARTITION BY RANGE( YEAR(joined) ) (
    PARTITION p0 VALUES LESS THAN (1960),
    PARTITION p1 VALUES LESS THAN (1970),
    PARTITION p2 VALUES LESS THAN (1980),
    PARTITION p3 VALUES LESS THAN (1990),
    PARTITION p4 VALUES LESS THAN MAXVALUE
);
</pre><p>
            MySQL 5.6 では、次の例に示すように <code class="literal">UNIX_TIMESTAMP()</code> 関数を使用して、<code class="literal">TIMESTAMP</code> カラムの値に基づいて <code class="literal">RANGE</code> によってテーブルをパーティション化することもできます。
          </p><pre class="programlisting">
CREATE TABLE quarterly_report_status (
    report_id INT NOT NULL,
    report_status VARCHAR(20) NOT NULL,
    report_updated TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
)
PARTITION BY RANGE ( UNIX_TIMESTAMP(report_updated) ) (
    PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-01-01 00:00:00') ),
    PARTITION p1 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-04-01 00:00:00') ),
    PARTITION p2 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-07-01 00:00:00') ),
    PARTITION p3 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-10-01 00:00:00') ),
    PARTITION p4 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-01-01 00:00:00') ),
    PARTITION p5 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-04-01 00:00:00') ),
    PARTITION p6 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-07-01 00:00:00') ),
    PARTITION p7 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-10-01 00:00:00') ),
    PARTITION p8 VALUES LESS THAN ( UNIX_TIMESTAMP('2010-01-01 00:00:00') ),
    PARTITION p9 VALUES LESS THAN (MAXVALUE)
);
</pre><p>
            MySQL 5.6 では、<code class="literal">TIMESTAMP</code> 値を含むほかの式は許可されません。(Bug #42849 を参照してください)。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              MySQL 5.6 では、<code class="literal">LIST</code> によってパーティション化されるテーブルのパーティショニング式として <code class="literal">UNIX_TIMESTAMP(timestamp_column)</code> を使用することもできます。ただし、このようにするのは通常は実用的ではありません。
            </p></div></li><li class="listitem"><p>
            <code class="literal">DATE</code> または <code class="literal">DATETIME</code> カラムをパーティショニングカラムとして使用して、<code class="literal">RANGE COLUMNS</code> によってテーブルをパーティション化します。たとえば、次のように <code class="literal">joined</code> カラムを直接使用して <code class="literal">members</code> テーブルを定義できます。
          </p><pre class="programlisting">
CREATE TABLE members (
    firstname VARCHAR(25) NOT NULL,
    lastname VARCHAR(25) NOT NULL,
    username VARCHAR(16) NOT NULL,
    email VARCHAR(35),
    joined DATE NOT NULL
)
PARTITION BY RANGE COLUMNS(joined) (
    PARTITION p0 VALUES LESS THAN ('1960-01-01'),
    PARTITION p1 VALUES LESS THAN ('1970-01-01'),
    PARTITION p2 VALUES LESS THAN ('1980-01-01'),
    PARTITION p3 VALUES LESS THAN ('1990-01-01'),
    PARTITION p4 VALUES LESS THAN MAXVALUE
);
</pre></li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">DATE</code> または <code class="literal">DATETIME</code> 以外の日付または時間型を使用してパーティショニングカラムを使用することは、<code class="literal">RANGE COLUMNS</code> ではサポートされません。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="partitioning-list"></a>19.2.2 LIST パーティショニング</h3></div></div></div><a class="indexterm" name="idm139979015966208"></a><a class="indexterm" name="idm139979015964064"></a><p>
        MySQL の LIST パーティショニングは、多くの点で RANGE パーティショニングに似ています。<code class="literal">RANGE</code> によるパーティショニングと同様に、各パーティションを明示的に定義する必要があります。2 つのタイプのパーティショニングの主な違いは、LIST パーティショニングでは、各パーティションが、連続する値の範囲のセットのいずれかではなく、値リストのセットのいずれかに含まれるカラム値のメンバーシップに基づいて定義および選択されることです。これを行うには、<code class="literal">PARTITION BY LIST (<em class="replaceable"><code>expr</code></em>)</code> を使用します。ここで、<em class="replaceable"><code>expr</code></em> はカラム値またはカラム値に基づく式で、整数値を返し、<code class="literal">VALUES IN (<em class="replaceable"><code>value_list</code></em>)</code> で各パーティションを定義します。ここで、<em class="replaceable"><code>value_list</code></em> はカンマで区切られた整数のリストです。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          MySQL 5.6 では、<code class="literal">LIST</code> によってパーティション化するときに、整数 (および <code class="literal">NULL</code> も可。<a class="xref" href="partitioning.html#partitioning-handling-nulls" title="19.2.7 MySQL パーティショニングによる NULL の扱い">セクション19.2.7「MySQL パーティショニングによる NULL の扱い」</a>を参照してください) のリストに対してのみ照合できます。
        </p><p>
          ただし、<code class="literal">LIST COLUMN</code> パーティショニングを使用するときは、ほかのカラムタイプを値リストで使用できます (これについては、このセクションで後述します)。
        </p></div><p>
        範囲で定義されるパーティションの場合と異なり、リストパーティションは特定の順序で宣言する必要はありません。構文についての詳細は、<a class="xref" href="sql-syntax.html#create-table" title="13.1.17 CREATE TABLE 構文">セクション13.1.17「CREATE TABLE 構文」</a>を参照してください。
      </p><p>
        以降の例では、パーティション化するテーブルの基本定義が、次に示す <code class="literal">CREATE TABLE</code> ステートメントによって提供されることを想定します。
      </p><pre class="programlisting">
CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT,
    store_id INT
);
</pre><p>
        (これは、<a class="xref" href="partitioning.html#partitioning-range" title="19.2.1 RANGE パーティショニング">セクション19.2.1「RANGE パーティショニング」</a>の例の出発点として使用したものと同じテーブルです。)
      </p><p>
        次の表に示すように、20 のビデオ店があり、それらが 4 つのフランチャイズに分類されていると想定します。
      </p><div class="informaltable"><table summary="この表は、前のテキストで説明したように、20 のビデオ店が 4 つの地域フランチャイズに分類されている例を示しています。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">地域</th><th scope="col">店舗 ID 番号</th></tr></thead><tbody><tr><td scope="row">北</td><td>3、5、6、9、17</td></tr><tr><td scope="row">東</td><td>1、2、10、11、19、20</td></tr><tr><td scope="row">西</td><td>4、12、13、14、18</td></tr><tr><td scope="row">中央</td><td>7、8、15、16</td></tr></tbody></table></div><p>
        同じ地域に属する店舗の行が同じパーティションに格納されるようにこのテーブルをパーティション化するには、次のような <code class="literal">CREATE TABLE</code> ステートメントを使用できます。
      </p><pre class="programlisting">
CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT,
    store_id INT
)
PARTITION BY LIST(store_id) (
    PARTITION pNorth VALUES IN (3,5,6,9,17),
    PARTITION pEast VALUES IN (1,2,10,11,19,20),
    PARTITION pWest VALUES IN (4,12,13,14,18),
    PARTITION pCentral VALUES IN (7,8,15,16)
);
</pre><p>
        これにより、特定の地域に関連する従業員レコードをテーブルで簡単に追加または削除できるようになります。たとえば、西地域の全店舗が別の会社に売却されたとします。MySQL 5.6 では、その地域の店舗で働いていた従業員に関連するすべての行をクエリー <code class="literal">ALTER TABLE employees TRUNCATE PARTITION pWest</code> を使用して削除できます。これは、同等の <code class="literal">DELETE</code> ステートメント <code class="literal">DELETE FROM employees WHERE store_id IN (4,12,13,14,18);</code> よりもはるかに効率的に実行できます(<code class="literal">ALTER TABLE employees DROP PARTITION pWest</code> を使用してもこれらのすべての行が削除されますが、テーブルの定義からパーティション <code class="literal">pWest</code> も削除されるため、<code class="literal">ALTER TABLE ... ADD PARTITION</code> ステートメントを使用してテーブルの元のパーティショニングスキームをリストアする必要があります)。
      </p><p>
        <code class="literal">RANGE</code> パーティショニングと同様に、<code class="literal">LIST</code> パーティショニングとハッシュまたはキーによるパーティショニングを組み合わせることによって、複合パーティショニング (サブパーティショニング) を生成できます。<a class="xref" href="partitioning.html#partitioning-subpartitions" title="19.2.6 サブパーティショニング">セクション19.2.6「サブパーティショニング」</a>を参照してください。
      </p><p>
        <code class="literal">RANGE</code> パーティショニングの場合と異なり、<code class="literal">MAXVALUE</code> などの<span class="quote">「<span class="quote">すべての状況に対応する</span>」</span>ものはありません。パーティショニング式で予期されるすべての値を <code class="literal">PARTITION ... VALUES IN (...)</code> 句で指定してください。一致しないパーティショニングカラム値が含まれている <code class="literal">INSERT</code> ステートメントは、次の例に示すように、エラーで失敗します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE h2 (</code></strong>
    -&gt;   <strong class="userinput"><code>c1 INT,</code></strong>
    -&gt;   <strong class="userinput"><code>c2 INT</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY LIST(c1) (</code></strong>
    -&gt;   <strong class="userinput"><code>PARTITION p0 VALUES IN (1, 4, 7),</code></strong>
    -&gt;   <strong class="userinput"><code>PARTITION p1 VALUES IN (2, 5, 8)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.11 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO h2 VALUES (3, 5);</code></strong>
<span class="errortext">ERROR 1525 (HY000): Table has no partition for value 3</span>
</pre><p>
        単一 <code class="literal">INSERT</code> ステートメントを使用して複数の行を挿入するときの動作は、テーブルがトランザクションストレージエンジンを使用するかどうかによって変わります。<code class="literal">InnoDB</code> テーブルの場合、ステートメントは単一トランザクションと見なされ、一致しない値があるときはステートメントが完全に失敗し、行は挿入されません。<code class="literal">MyISAM</code> などの非トランザクションストレージエンジンを使用するテーブルの場合、一致しない値が含まれている行の前にある行は挿入されますが、あとにある行はされません。
      </p><p>
        このタイプのエラーは、<code class="literal">IGNORE</code> キーワードを使用することで無視させることができます。そうした場合、一致しないパーティショニングカラム値が含まれる行は挿入されませんが、一致する値を持つ行は挿入<span class="emphasis"><em>され</em></span>てエラーが報告されません。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>TRUNCATE h2;</code></strong>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM h2;</code></strong>
Empty set (0.00 sec)

mysql&gt; <strong class="userinput"><code>INSERT IGNORE INTO h2 VALUES (2, 5), (6, 10), (7, 5), (3, 1), (1, 9);</code></strong>
Query OK, 3 rows affected (0.00 sec)
Records: 5  Duplicates: 2  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT * FROM h2;</code></strong>
+------+------+
| c1   | c2   |
+------+------+
|    7 |    5 |
|    1 |    9 |
|    2 |    5 |
+------+------+
3 rows in set (0.00 sec)
</pre><p>
        MySQL 5.6 は <code class="literal">LIST COLUMNS</code> パーティショニングのサポートを提供します。これは、<code class="literal">LIST</code> パーティショニングのバリアントで、パーティショニングカラムに整数型以外の型のカラムを使用したり、複数のカラムをパーティショニングキーとして使用したりできます。詳細は、<a class="xref" href="partitioning.html#partitioning-columns-list" title="19.2.3.2 LIST COLUMNS パーティショニング">セクション19.2.3.2「LIST COLUMNS パーティショニング」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="partitioning-columns"></a>19.2.3 COLUMNS パーティショニング</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="partitioning.html#partitioning-columns-range">19.2.3.1 RANGE COLUMNS パーティショニング</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-columns-list">19.2.3.2 LIST COLUMNS パーティショニング</a></span></dt></dl></div><a class="indexterm" name="idm139979015896384"></a><a class="indexterm" name="idm139979015894352"></a><a class="indexterm" name="idm139979015892832"></a><a class="indexterm" name="idm139979015891568"></a><a class="indexterm" name="idm139979015890192"></a><a class="indexterm" name="idm139979015888672"></a><p>
        次の 2 つのセクションでは、<code class="literal">RANGE</code> および <code class="literal">LIST</code> パーティショニングのバリアントである <em class="firstterm"><code class="literal">COLUMNS</code> パーティショニング</em>について説明します。<code class="literal">COLUMNS</code> パーティショニングでは、パーティショニングキーに複数のカラムを使用できます。これらのすべてのカラムが、パーティションに行を配置するため、およびパーティションプルーニングでどのパーティションで一致する行をチェックするかを判断するという両方の目的のために考慮されます。
      </p><p>
        また、<code class="literal">RANGE COLUMNS</code> パーティショニングおよび <code class="literal">LIST COLUMNS</code> パーティショニングの両方が、値範囲またはリストメンバーの定義のために整数以外のカラムの使用をサポートします。許可されるデータ型を次のリストに示します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            すべての整数型: <code class="literal">TINYINT</code>、<code class="literal">SMALLINT</code>、<code class="literal">MEDIUMINT</code>、<code class="literal">INT</code> (<code class="literal">INTEGER</code>)、および <code class="literal">BIGINT</code>(これは、<code class="literal">RANGE</code> および <code class="literal">LIST</code> によるパーティショニングと同じです)。
          </p><p>
            ほかの数値データ型 (<code class="literal">DECIMAL</code>、<code class="literal">FLOAT</code> など) はパーティショニングカラムとしてサポートされません。
          </p></li><li class="listitem"><p>
            <code class="literal">DATE</code> および <code class="literal">DATETIME</code>。
          </p><p>
            日付または時間に関連するほかのデータ型を使用するカラムは、パーティショニングカラムとしてサポートされません。
          </p></li><li class="listitem"><p>
            次の文字列型: <code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、<code class="literal">BINARY</code>、および <code class="literal">VARBINARY</code>。
          </p><p>
            <code class="literal">TEXT</code> カラムおよび <code class="literal">BLOB</code> カラムはパーティショニングカラムとしてサポートされません。
          </p></li></ul></div><p>
        次の 2 つのセクションでの <code class="literal">RANGE COLUMNS</code> および <code class="literal">LIST COLUMNS</code> パーティショニングの説明では、MySQL 5.1 以降でサポートされる範囲およびリストに基づくパーティショニングをすでに理解していることを想定しています。これらについての詳細は、<a class="xref" href="partitioning.html#partitioning-range" title="19.2.1 RANGE パーティショニング">セクション19.2.1「RANGE パーティショニング」</a>および<a class="xref" href="partitioning.html#partitioning-list" title="19.2.2 LIST パーティショニング">セクション19.2.2「LIST パーティショニング」</a>をそれぞれ参照してください。
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="partitioning-columns-range"></a>19.2.3.1 RANGE COLUMNS パーティショニング</h4></div></div></div><p>
          RANGE COLUMNS パーティショニングは RANGE パーティショニングに似ていますが、複数のカラム値に基づく範囲を使用してパーティションを定義できます。また、整数型以外の型のカラムを使用して範囲を定義できます。
        </p><p>
          <code class="literal">RANGE COLUMNS</code> パーティショニングは、次の点で <code class="literal">RANGE</code> パーティショニングと大きく異なります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">RANGE COLUMNS</code> は式を受け入れません (カラムの名前のみ)。
            </p></li><li class="listitem"><p>
              <code class="literal">RANGE COLUMNS</code> は 1 つ以上のカラムのリストを受け入れます。
            </p><p>
              <code class="literal">RANGE COLUMNS</code> パーティションは、スカラー値の比較ではなく、<em class="firstterm">タプル</em> (カラム値のリスト) の比較に基づきます。<code class="literal">RANGE COLUMNS</code> パーティションでの行の配置も、タプルの比較に基づきます。これについては、このセクションで後述します。
            </p></li><li class="listitem"><p>
              <code class="literal">RANGE COLUMNS</code> パーティショニングカラムは整数カラムに制限されません。文字列、<code class="literal">DATE</code>、および <code class="literal">DATETIME</code> カラムもパーティショニングカラムとして使用できます。(詳細は、<a class="xref" href="partitioning.html#partitioning-columns" title="19.2.3 COLUMNS パーティショニング">セクション19.2.3「COLUMNS パーティショニング」</a>を参照してください)。
            </p></li></ul></div><p>
          <code class="literal">RANGE COLUMNS</code> によってパーティション化されたテーブルを作成するための基本構文を次に示します。
        </p><pre class="programlisting">
CREATE TABLE <em class="replaceable"><code>table_name</code></em>
PARTITIONED BY RANGE COLUMNS(<em class="replaceable"><code>column_list</code></em>) (
    PARTITION <em class="replaceable"><code>partition_name</code></em> VALUES LESS THAN (<em class="replaceable"><code>value_list</code></em>)[,
    PARTITION <em class="replaceable"><code>partition_name</code></em> VALUES LESS THAN (<em class="replaceable"><code>value_list</code></em>)][,
    ...]
) 

<em class="replaceable"><code>column_list</code></em>:
    <em class="replaceable"><code>column_name</code></em>[, <em class="replaceable"><code>column_name</code></em>][, ...]

<em class="replaceable"><code>value_list</code></em>:
    <em class="replaceable"><code>value</code></em>[, <em class="replaceable"><code>value</code></em>][, ...]
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            パーティション化されたテーブルを作成するときに使用できる <code class="literal">CREATE TABLE</code> オプションをすべて示しているわけではありません。詳細は、<a class="xref" href="sql-syntax.html#create-table" title="13.1.17 CREATE TABLE 構文">セクション13.1.17「CREATE TABLE 構文」</a>を参照してください。
          </p></div><p>
          前述の構文で、<em class="replaceable"><code>column_list</code></em> は 1 つ以上のカラムのリスト (<em class="firstterm">パーティショニングカラムリスト</em>と呼ばれることもあります)、<em class="replaceable"><code>value_list</code></em> は値のリスト (つまり、<em class="firstterm">パーティション定義値リスト</em>です) です。<em class="replaceable"><code>value_list</code></em> は各パーティション定義に指定する必要があり、各 <em class="replaceable"><code>value_list</code></em> には <em class="replaceable"><code>column_list</code></em> のカラムと同じ数の値が必要です。一般的に、<code class="literal">COLUMNS</code> 句に <em class="replaceable"><code>N</code></em> 個のカラムを使用する場合は、各 <code class="literal">VALUES LESS THAN</code> 句にも <em class="replaceable"><code>N</code></em> 個の値のリストを指定する必要があります。
        </p><p>
          パーティショニングカラムリストおよび各パーティションを定義する値リスト内の要素は、同じ順序で指定する必要があります。また、値リスト内の各要素は、カラムリスト内の対応する要素と同じデータ型である必要があります。ただし、パーティショニングカラムリストおよび値リスト内のカラム名の順序は、<code class="literal">CREATE TABLE</code> ステートメントの主要部内のテーブルカラム定義の順序と同じである必要はありません。<code class="literal">RANGE</code> によってパーティション化されるテーブルと同様に、<code class="literal">MAXVALUE</code> を使用して、指定されたカラムに挿入される正当な値より確実に大きな値を表すことができます。これらの点をすべて説明するために役立つ <code class="literal">CREATE TABLE</code> ステートメントの例を次に示します。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE rcx (</code></strong>
    -&gt;     <strong class="userinput"><code>a INT,</code></strong>
    -&gt;     <strong class="userinput"><code>b INT,</code></strong>
    -&gt;     <strong class="userinput"><code>c CHAR(3),</code></strong>
    -&gt;     <strong class="userinput"><code>d INT</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY RANGE COLUMNS(a,d,c) (</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (5,10,'ggg'),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (10,20,'mmmm'),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p2 VALUES LESS THAN (15,30,'sss'),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE,MAXVALUE)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.15 sec)
</pre><p>
          テーブル <code class="literal">rcx</code> にはカラム <code class="literal">a</code>、<code class="literal">b</code>、<code class="literal">c</code>、および <code class="literal">d</code> が含まれています。<code class="literal">COLUMNS</code> 句に指定されたパーティショニングカラムリストには、これらのカラムのうちの 3 つが <code class="literal">a</code>、<code class="literal">d</code>、および <code class="literal">c</code> の順に使用されています。パーティションを定義するために使用される各値リストには、同じ順序で 3 つの値が含まれます。つまり、各値リストタプルの形式は、カラム <code class="literal">a</code>、<code class="literal">d</code>、および <code class="literal">c</code> が (この順序で) 使用するデータ型に対応する、(<code class="literal">INT</code>, <code class="literal">INT</code>, <code class="literal">CHAR(3)</code>) です。
        </p><p>
          パーティションに行がどのように配置されるかは、挿入される行のタプル (<code class="literal">COLUMNS</code> 句内のカラムリストに一致) と<code class="literal">VALUES LESS THAN</code> 句に使用されるタプル (テーブルのパーティションを定義) を比較することによって判断されます。スカラー値ではなくタプル (つまり、値のリストまたはセット) を比較するため、<code class="literal">RANGE COLUMNS</code> パーティションで使用される <code class="literal">VALUES LESS THAN</code> のセマンティクスは、単純な <code class="literal">RANGE</code> パーティションの場合とは若干異なります。<code class="literal">RANGE</code> パーティショニングでは、<code class="literal">VALUES LESS THAN</code> 内の制限値と等しい式値を生成する行は、対応するパーティションに配置されません。ただし、<code class="literal">RANGE COLUMNS</code> パーティショニングを使用するときは、パーティショニングカラムリストの最初の要素が <code class="literal">VALUES LESS THAN</code> 値リスト内の最初の要素と値が等しい行が、対応するパーティションに配置されることがあります。
        </p><p>
          次のステートメントによって作成されるパーティション化された <code class="literal">RANGE</code> テーブルを検討します。
        </p><pre class="programlisting">
CREATE TABLE r1 (
    a INT,
    b INT
)
PARTITION BY RANGE (a)  (
    PARTITION p0 VALUES LESS THAN (5),
    PARTITION p1 VALUES LESS THAN (MAXVALUE)
);
</pre><p>
          各行の <code class="literal">a</code> のカラム値が <code class="literal">5</code> である 3 つの行をこのテーブルに挿入する場合、各行の <code class="literal">a</code> カラム値が 5 以上であるため、3 行がすべてパーティション <code class="literal">p1</code> に格納されます。これは、<code class="literal">INFORMATION_SCHEMA.PARTITIONS</code> テーブルに対して適切なクエリーを実行することによって確認できます。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>INSERT INTO r1 VALUES (5,10), (5,11), (5,12);</code></strong>
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT PARTITION_NAME,TABLE_ROWS</code></strong>
    -&gt;     <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE TABLE_NAME = 'r1';</code></strong>
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          0 |
| p1             |          3 |
+----------------+------------+
2 rows in set (0.00 sec)
</pre><p>
          ここで、次のように作成される、カラム <code class="literal">a</code> および <code class="literal">b</code> の両方が <code class="literal">COLUMNS</code> 句で参照される、<code class="literal">RANGE COLUMNS</code> パーティショニングを使用する同様のテーブル <code class="literal">rc1</code> を検討します。
        </p><pre class="programlisting">
CREATE TABLE rc1 (
    a INT, 
    b INT
) 
PARTITION BY RANGE COLUMNS(a, b) (
    PARTITION p0 VALUES LESS THAN (5, 12),
    PARTITION p3 VALUES LESS THAN (MAXVALUE, MAXVALUE)
);
</pre><p>
          <code class="literal">r1</code> に挿入したのとまったく同じ行を <code class="literal">rc1</code> に挿入した場合、行の配分はかなり異なります。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>INSERT INTO rc1 VALUES (5,10), (5,11), (5,12);</code></strong>
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT PARTITION_NAME,TABLE_ROWS</code></strong>
    -&gt;     <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE TABLE_NAME = 'rc1';</code></strong>
+--------------+----------------+------------+
| TABLE_SCHEMA | PARTITION_NAME | TABLE_ROWS |
+--------------+----------------+------------+
| p            | p0             |          2 |
| p            | p1             |          1 |
+--------------+----------------+------------+
2 rows in set (0.00 sec)
</pre><p>
          これは、スカラー値ではなく行を比較しているためです。挿入された行値と、テーブル <code class="literal">rc1</code> のパーティション <code class="literal">p0</code> を定義するために使用された <code class="literal">VALUES THAN LESS THAN</code> 句の行制限値とを次のように比較できます。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT (5,10) &lt; (5,12), (5,11) &lt; (5,12), (5,12) &lt; (5,12);</code></strong>
+-----------------+-----------------+-----------------+
| (5,10) &lt; (5,12) | (5,11) &lt; (5,12) | (5,12) &lt; (5,12) |
+-----------------+-----------------+-----------------+
|               1 |               1 |               0 |
+-----------------+-----------------+-----------------+
1 row in set (0.00 sec)
</pre><p>
          2 つのタプル <code class="literal">(5,10)</code> および <code class="literal">(5,11)</code> は <code class="literal">(5,12)</code> より小さいと評価されるため、パーティション <code class="literal">p0</code> に格納されています。5 は 5 以上、12 は 12 以上であるため、<code class="literal">(5,12)</code> は <code class="literal">(5,12)</code> 以上と見なされ、パーティション <code class="literal">p1</code> に格納されています。
        </p><p>
          前の例の <code class="literal">SELECT</code> ステートメントは、次のように明示的な行コンストラクタを使用して記述することもできました。
        </p><pre class="programlisting">
SELECT ROW(5,10) &lt; ROW(5,12), ROW(5,11) &lt; ROW(5,12), ROW(5,12) &lt; ROW(5,12);
</pre><p>
          MySQL で行コンストラクタを使用する方法についての詳細は、<a class="xref" href="sql-syntax.html#row-subqueries" title="13.2.10.5 行サブクエリー">セクション13.2.10.5「行サブクエリー」</a>を参照してください。
        </p><p>
          単一パーティショニングカラムのみを使用して <code class="literal">RANGE COLUMNS</code> によってパーティション化されたテーブルの場合、パーティションへの行の格納は <code class="literal">RANGE</code> によってパーティション化された同等のテーブルの場合と同じです。次の <code class="literal">CREATE TABLE</code> ステートメントでは、1 つのパーティショニングカラムを使用して <code class="literal">RANGE COLUMNS</code> によってパーティション化されるテーブルが作成されます。
        </p><pre class="programlisting">
CREATE TABLE rx (
    a INT,
    b INT
)
PARTITION BY RANGE COLUMNS (a)  (
    PARTITION p0 VALUES LESS THAN (5),
    PARTITION p1 VALUES LESS THAN (MAXVALUE)
); 
</pre><p>
          このテーブルに行 <code class="literal">(5,10)</code>、<code class="literal">(5,11)</code>、および <code class="literal">(5,12)</code> を挿入する場合、それらの配置は、前に作成して移入したテーブル <code class="literal">r</code> の場合と同じです。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>INSERT INTO rx VALUES (5,10), (5,11), (5,12);</code></strong>
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT PARTITION_NAME,TABLE_ROWS</code></strong>
    -&gt;     <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE TABLE_NAME = 'rx';</code></strong>
+--------------+----------------+------------+
| TABLE_SCHEMA | PARTITION_NAME | TABLE_ROWS |
+--------------+----------------+------------+
| p            | p0             |          0 |
| p            | p1             |          3 |
+--------------+----------------+------------+
2 rows in set (0.00 sec)
</pre><p>
          1 つ以上のカラムの制限値が連続するパーティション定義で繰り返される、<code class="literal">RANGE COLUMNS</code> によってパーティション化されるテーブルを作成することもできます。これを行うには、パーティションを定義するために使用されるカラム値のタプルが厳密にしだいに増加する必要があります。たとえば、次の各 <code class="literal">CREATE TABLE</code> ステートメントは有効です。
        </p><pre class="programlisting">
CREATE TABLE rc2 (
    a INT,
    b INT
)
PARTITION BY RANGE COLUMNS(a,b) (
    PARTITION p0 VALUES LESS THAN (0,10),
    PARTITION p1 VALUES LESS THAN (10,20),
    PARTITION p2 VALUES LESS THAN (10,30),
    PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE)
 );
 
CREATE TABLE rc3 (
    a INT,
    b INT
)
PARTITION BY RANGE COLUMNS(a,b) (
    PARTITION p0 VALUES LESS THAN (0,10),
    PARTITION p1 VALUES LESS THAN (10,20),
    PARTITION p2 VALUES LESS THAN (10,30),
    PARTITION p3 VALUES LESS THAN (10,35),
    PARTITION p4 VALUES LESS THAN (20,40),
    PARTITION p5 VALUES LESS THAN (MAXVALUE,MAXVALUE)
 );
</pre><p>
          次のステートメントも成功しますが、カラム <code class="literal">b</code> の制限値がパーティション <code class="literal">p0</code> で 25 およびパーティション <code class="literal">p1</code> で 20、カラム <code class="literal">c</code> の制限値がパーティション <code class="literal">p1</code> で 100 およびパーティション <code class="literal">p2</code> で 50 であるため、一見したところではそうでないように見えるかもしれません。
        </p><pre class="programlisting">
CREATE TABLE rc4 (
    a INT,
    b INT,
    c INT
)
PARTITION BY RANGE COLUMNS(a,b,c) (
    PARTITION p0 VALUES LESS THAN (0,25,50),
    PARTITION p1 VALUES LESS THAN (10,20,100),
    PARTITION p2 VALUES LESS THAN (10,30,50)
    PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE,MAXVALUE) 
 );
</pre><p>
          <code class="literal">RANGE COLUMNS</code> によってパーティション化されるテーブルを設計するときは、次のように <span class="command"><strong>mysql</strong></span> クライアントを使用して目的のタプルを比較することで、いつでも連続するパーティション定義をテストできます。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT (0,25,50) &lt; (10,20,100), (10,20,100) &lt; (10,30,50);</code></strong>
+-------------------------+--------------------------+
| (0,25,50) &lt; (10,20,100) | (10,20,100) &lt; (10,30,50) |
+-------------------------+--------------------------+
|                       1 |                        1 |
+-------------------------+--------------------------+
1 row in set (0.00 sec)
</pre><p>
          <code class="literal">CREATE TABLE</code> ステートメントに含まれるパーティション定義が、厳密にしだいに増加しない順序である場合は、次の例に示すようにエラーで失敗します。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE rcf (</code></strong>
    -&gt;     <strong class="userinput"><code>a INT,</code></strong>
    -&gt;     <strong class="userinput"><code>b INT,</code></strong>
    -&gt;     <strong class="userinput"><code>c INT</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY RANGE COLUMNS(a,b,c) (</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (0,25,50),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (20,20,100),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p2 VALUES LESS THAN (10,30,50),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE,MAXVALUE)</code></strong>
    -&gt;  <strong class="userinput"><code>);</code></strong>
<span class="errortext">ERROR 1493 (HY000): VALUES LESS THAN value must be strictly increasing for each partition</span>
</pre><p>
          そのようなエラーが発生するときは、それらのカラムリストの<span class="quote">「<span class="quote">小なり</span>」</span>比較を作成することで、無効なパーティション定義を推定できます。この場合、問題はパーティション <code class="literal">p2</code> の定義にあります。次に示すように、それを定義するために使用されるタプルが、パーティション <code class="literal">p3</code> を定義するために使用されるタプル以上であるためです。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT (0,25,50) &lt; (20,20,100), (20,20,100) &lt; (10,30,50);</code></strong>
+-------------------------+--------------------------+
| (0,25,50) &lt; (20,20,100) | (20,20,100) &lt; (10,30,50) |
+-------------------------+--------------------------+
|                       1 |                        0 |
+-------------------------+--------------------------+
1 row in set (0.00 sec)
</pre><p>
          <code class="literal">RANGE COLUMNS</code> を使用するときは、複数の <code class="literal">VALUES LESS THAN</code> 句内の同じカラムに <code class="literal">MAXVALUE</code> を指定することもできます。ただし、それ以外の場合は、連続するパーティション定義内の個々のカラムの制限値はしだいに増加するべきであり、<code class="literal">MAXVALUE</code> をすべてのカラム値の上限として使用するパーティションは 1 つだけ定義するべきであり、このパーティション定義は <code class="literal">PARTITION ... VALUES LESS THAN</code> 句のリストの最後に指定するべきです。また、複数のパーティション定義の最初のカラムの制限値として <code class="literal">MAXVALUE</code> を使用することはできません。
        </p><p>
          前述したように、<code class="literal">RANGE COLUMNS</code> パーティショニングでは、整数以外のカラムをパーティショニングカラムとして使用することもできます(これらの完全な一覧については、<a class="xref" href="partitioning.html#partitioning-columns" title="19.2.3 COLUMNS パーティショニング">セクション19.2.3「COLUMNS パーティショニング」</a>を参照してください)。次のステートメントを使用して作成された <code class="literal">employees</code> という名前のテーブル (パーティション化されていません) を検討します。
        </p><pre class="programlisting">
CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT NOT NULL,
    store_id INT NOT NULL
);
</pre><p>
          <code class="literal">RANGE COLUMNS</code> パーティショニングを使用して、次のように従業員の姓に基づいて各行を 4 つのパーティションのいずれかに格納する、このテーブルのバージョンを作成できます。
        </p><pre class="programlisting">
CREATE TABLE employees_by_lname (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT NOT NULL,
    store_id INT NOT NULL
)
PARTITION BY RANGE COLUMNS (lname)  (
    PARTITION p0 VALUES LESS THAN ('g'),
    PARTITION p1 VALUES LESS THAN ('m'),
    PARTITION p2 VALUES LESS THAN ('t'),
    PARTITION p3 VALUES LESS THAN (MAXVALUE)
);
</pre><p>
          または、次の <code class="literal">ALTER TABLE</code> ステートメントを実行することで、前に作成した <code class="literal">employees</code> テーブルをこのスキームを使用してパーティション化できます。
        </p><pre class="programlisting">
ALTER TABLE employees PARTITION BY RANGE COLUMNS (lname)  (
    PARTITION p0 VALUES LESS THAN ('g'),
    PARTITION p1 VALUES LESS THAN ('m'),
    PARTITION p2 VALUES LESS THAN ('t'),
    PARTITION p3 VALUES LESS THAN (MAXVALUE)
);
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            文字セットおよび照合順序が異なるとソート順序が異なるため、文字列カラムをパーティショニングカラムとして使用するときに、使用している文字セットおよび照合順序が、指定された行が <code class="literal">RANGE COLUMNS</code> によってパーティション化されるテーブルのどのパーティションに格納されるかに影響することがあります。また、そのようなテーブルが作成されたあとに指定されたデータベース、テーブル、またはカラムの文字セットまたは照合順序を変更すると、行がどのように配分されるかが変わることがあります。たとえば、大文字/小文字が区別される照合順序を使用するときは、<code class="literal">'and'</code> は <code class="literal">'Andersen'</code> の前に置かれますが、大文字/小文字が区別されない照合順序を使用するときは、その逆が true になります。
          </p><p>
            MySQL が文字セットおよび照合順序をどのように扱うかについては、<a class="xref" href="globalization.html#charset" title="10.1 文字セットのサポート">セクション10.1「文字セットのサポート」</a>を参照してください。
          </p></div><p>
          同様に、<code class="literal">employees</code> テーブルを、各行がいくつかの 10 年間 (その間に対応する従業員が雇用された) ベースのパーティションのいずれかに格納されるように、次のような <code class="literal">ALTER TABLE</code> ステートメントを使用してパーティション化できます。
        </p><pre class="programlisting">
ALTER TABLE employees PARTITION BY RANGE COLUMNS (hired)  (
    PARTITION p0 VALUES LESS THAN ('1970-01-01'),
    PARTITION p1 VALUES LESS THAN ('1980-01-01'),
    PARTITION p2 VALUES LESS THAN ('1990-01-01'),
    PARTITION p3 VALUES LESS THAN ('2000-01-01'),
    PARTITION p4 VALUES LESS THAN ('2010-01-01'),
    PARTITION p5 VALUES LESS THAN (MAXVALUE)
);
</pre><p>
          <code class="literal">PARTITION BY RANGE COLUMNS</code> 構文の詳細については、<a class="xref" href="sql-syntax.html#create-table" title="13.1.17 CREATE TABLE 構文">セクション13.1.17「CREATE TABLE 構文」</a>を参照してください。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="partitioning-columns-list"></a>19.2.3.2 LIST COLUMNS パーティショニング</h4></div></div></div><p>
          MySQL 5.6 は <code class="literal">LIST COLUMNS</code> パーティショニングのサポートを提供します。これは <code class="literal">LIST</code> パーティショニングのバリアントで、複数のカラムをパーティションキーとして使用でき、整数型以外のデータ型のカラムをパーティショニングカラムとして使用できます。文字列型、<code class="literal">DATE</code>、および <code class="literal">DATETIME</code> カラムを使用できます(<code class="literal">COLUMNS</code> パーティショニングカラムに許可されるデータ型の詳細については、<a class="xref" href="partitioning.html#partitioning-columns" title="19.2.3 COLUMNS パーティショニング">セクション19.2.3「COLUMNS パーティショニング」</a>を参照してください)。
        </p><p>
          ある会社の顧客が 12 の都市に存在し、販売およびマーケティングのために、それらを次の表に示すように 3 つの都市で構成される 4 つの地域に分類すると想定します。
        </p><div class="informaltable"><table summary="この表は、前のテキストで説明されている、4 つの販売/マーケティング地域と、それぞれの地域が 3 つの都市で構成されている会社の例を示しています。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">地域</th><th scope="col">都市</th></tr></thead><tbody><tr><td scope="row">1</td><td>Oskarshamn、Högsby、Mönsterås</td></tr><tr><td scope="row">2</td><td>Vimmerby、Hultsfred、Västervik</td></tr><tr><td scope="row">3</td><td>Nässjö、Eksjö、Vetlanda</td></tr><tr><td scope="row">4</td><td>Uppvidinge、Alvesta、Växjo</td></tr></tbody></table></div><p>
          <code class="literal">LIST COLUMNS</code> パーティショニングでは、ここで示すように、顧客が所在する都市の名前に基づいてこれらの地域に対応する 4 つのパーティションのいずれかに行を割り当てる、顧客データのテーブルを作成できます。
        </p><pre class="programlisting">
CREATE TABLE customers_1 (
    first_name VARCHAR(25),
    last_name VARCHAR(25),
    street_1 VARCHAR(30),
    street_2 VARCHAR(30),
    city VARCHAR(15),
    renewal DATE
)
PARTITION BY LIST COLUMNS(city) (
    PARTITION pRegion_1 VALUES IN('Oskarshamn', 'Högsby', 'Mönsterås'),
    PARTITION pRegion_2 VALUES IN('Vimmerby', 'Hultsfred', 'Västervik'),
    PARTITION pRegion_3 VALUES IN('Nässjö', 'Eksjö', 'Vetlanda'),
    PARTITION pRegion_4 VALUES IN('Uppvidinge', 'Alvesta', 'Växjo')
);
</pre><p>
          <code class="literal">RANGE COLUMNS</code> によるパーティショニングのように、<code class="literal">COLUMNS()</code> 句で式を使用してカラム値を整数に変換する必要はありません(実際、カラム名ではなく式を使用することは <code class="literal">COLUMNS()</code> では許可されません)。
        </p><p>
          <code class="literal">DATE</code> および <code class="literal">DATETIME</code> カラムを使用することもでき、次の例では、前に示した <code class="literal">customers_1</code> テーブルと同じ名前およびカラムを使用していますが、<code class="literal">renewal</code> カラムに基づく <code class="literal">LIST COLUMNS</code> パーティショニングを使用して、顧客のアカウントの更新がスケジュールされている 2010 年 2 月の週に応じて、4 つのパーティションのいずれかに行が格納されることを示しています。
        </p><pre class="programlisting">
CREATE TABLE customers_2 (
    first_name VARCHAR(25),
    last_name VARCHAR(25),
    street_1 VARCHAR(30),
    street_2 VARCHAR(30),
    city VARCHAR(15),
    renewal DATE
)
PARTITION BY LIST COLUMNS(renewal) (
    PARTITION pWeek_1 VALUES IN('2010-02-01', '2010-02-02', '2010-02-03',
        '2010-02-04', '2010-02-05', '2010-02-06', '2010-02-07'),
    PARTITION pWeek_2 VALUES IN('2010-02-08', '2010-02-09', '2010-02-10',
        '2010-02-11', '2010-02-12', '2010-02-13', '2010-02-14'),
    PARTITION pWeek_3 VALUES IN('2010-02-15', '2010-02-16', '2010-02-17',
        '2010-02-18', '2010-02-19', '2010-02-20', '2010-02-21'),
    PARTITION pWeek_4 VALUES IN('2010-02-22', '2010-02-23', '2010-02-24',
        '2010-02-25', '2010-02-26', '2010-02-27', '2010-02-28')
);
</pre><p>
          これは機能しますが、関係する日付の数が非常に多くなってきた場合に、定義および保守が面倒になります。そのような場合は通常、<code class="literal">RANGE</code> または <code class="literal">RANGE COLUMNS</code> パーティショニングを代わりに使用するほうが現実的です。この場合、パーティショニングキーとして使用するカラムは <code class="literal">DATE</code> カラムであるため、次に示すように <code class="literal">RANGE COLUMNS</code> パーティショニングを使用します。
        </p><pre class="programlisting">
CREATE TABLE customers_3 (
    first_name VARCHAR(25),
    last_name VARCHAR(25),
    street_1 VARCHAR(30),
    street_2 VARCHAR(30),
    city VARCHAR(15),
    renewal DATE
)
PARTITION BY RANGE COLUMNS(renewal) (
    PARTITION pWeek_1 VALUES LESS THAN('2010-02-09'),
    PARTITION pWeek_2 VALUES LESS THAN('2010-02-15'),
    PARTITION pWeek_3 VALUES LESS THAN('2010-02-22'),
    PARTITION pWeek_4 VALUES LESS THAN('2010-03-01')
);
</pre><p>
          詳細は、<a class="xref" href="partitioning.html#partitioning-columns-range" title="19.2.3.1 RANGE COLUMNS パーティショニング">セクション19.2.3.1「RANGE COLUMNS パーティショニング」</a>を参照してください。
        </p><p>
          また (<code class="literal">RANGE COLUMNS</code> パーティショニングと同様に)、<code class="literal">COLUMNS()</code> 句で複数のカラムを使用できます。
        </p><p>
          <code class="literal">PARTITION BY LIST COLUMNS()</code> 構文についての詳細は、<a class="xref" href="sql-syntax.html#create-table" title="13.1.17 CREATE TABLE 構文">セクション13.1.17「CREATE TABLE 構文」</a>を参照してください。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="partitioning-hash"></a>19.2.4 HASH パーティショニング</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="partitioning.html#partitioning-linear-hash">19.2.4.1 LINEAR HASH パーティショニング</a></span></dt></dl></div><a class="indexterm" name="idm139979015635456"></a><a class="indexterm" name="idm139979015633312"></a><p>
        <code class="literal">HASH</code> によるパーティショニングは、事前に決められた数のパーティションにデータを均等に配分するために主に使用されます。RANGE または LIST パーティショニングでは、指定されたカラム値またはカラム値セットがどのパーティションに格納されるかを明示的に指定する必要があります。HASH パーティショニングでは MySQL がこれを自動的に行うため、必要なことは、ハッシュされるカラム値またはカラム値に基づく式、およびパーティション化されたテーブルがいくつのパーティションに分割されるかを指定することだけです。
      </p><p>
        <code class="literal">HASH</code> パーティショニングを使用してテーブルをパーティション化する場合は、<code class="literal">CREATE TABLE</code> ステートメントに <code class="literal">PARTITION BY HASH (<em class="replaceable"><code>expr</code></em>)</code> 句を付加する必要があります。ここで、<em class="replaceable"><code>expr</code></em> は整数を返す式です。これには、型が MySQL の整数型のいずれかであるカラムの名前を単純に指定できます。また、これのあとにはほとんどの場合 <code class="literal">PARTITIONS <em class="replaceable"><code>num</code></em></code> 句を続けます。ここで、<em class="replaceable"><code>num</code></em> はテーブルがいくつのパーティションに分割されるかを表す正の整数です。
      </p><p>
        たとえば、次のステートメントは <code class="literal">store_id</code> カラムにハッシュを使用し、4 つのパーティションに分割されたテーブルを作成します。
      </p><pre class="programlisting">
CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT,
    store_id INT
)
PARTITION BY HASH(store_id)
PARTITIONS 4;
</pre><p>
        <code class="literal">PARTITIONS</code> 句を含めない場合、パーティションの数はデフォルトで <code class="literal">1</code> となります。
      </p><p>
        <code class="literal">PARTITIONS</code> キーワードを使用する場合、そのあとに数を指定しないと構文エラーになります。
      </p><a class="indexterm" name="idm139979015617760"></a><p>
        整数を返す SQL 式を <em class="replaceable"><code>expr</code></em> に使用することもできます。たとえば、従業員が雇用された年度に基づいてパーティション化するとします。これは、次のように行うことができます。
      </p><pre class="programlisting">
CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT,
    store_id INT
)
PARTITION BY HASH( YEAR(hired) )
PARTITIONS 4;
</pre><p>
        <em class="replaceable"><code>expr</code></em> は、定数以外のランダムではない整数値 (つまり、変化するけれども決定論的であるべき) を返す必要があり、<a class="xref" href="partitioning.html#partitioning-limitations" title="19.6 パーティショニングの制約と制限">セクション19.6「パーティショニングの制約と制限」</a>で説明されている禁止された構造体を含んでいてはいけません。また、この式は行が挿入または更新 (または場合によっては削除) されるたびに評価されるべきです。これは、非常に複雑な式がパフォーマンスの問題を起こすことがあることを意味します (特に、一度に多くの行に影響する操作 (バッチ挿入など) を実行するとき)。
      </p><p>
        もっとも効率的なハッシュ関数は、単一テーブルカラムに実行され、その値がカラム値に対して比例的に増加または減少するもので、これによってパーティションの範囲を<span class="quote">「<span class="quote">プルーニング</span>」</span>できます。つまり、式がそのベースのカラムの値に対してより密接に変化するほど、MySQL は式を HASH パーティショニングにより効率的に使用できます。
      </p><p>
        たとえば、<code class="literal">date_col</code> が <code class="literal">DATE</code> 型のカラムである場合、式 <code class="literal">TO_DAYS(date_col)</code> は <code class="literal">date_col</code> の値に正比例すると表現されます。<code class="literal">date_col</code> の値が変わるたびに、式の値が一定の方法で変化するためです。<code class="literal">date_col</code> に対する式 <code class="literal">YEAR(date_col)</code> の変化は、<code class="literal">TO_DAYS(date_col)</code> ほど比例的ではありません。<code class="literal">date_col</code> のあらゆる変化に対して <code class="literal">YEAR(date_col)</code> が同等に変化するとはかぎらないためです。それでも、<code class="literal">YEAR(date_col)</code> はハッシュ関数の良い候補の 1 つです。<code class="literal">date_col</code> の一部と正比例し、<code class="literal">date_col</code> の変化によって <code class="literal">YEAR(date_col)</code> で比例的でない変化が発生することがないためです。
      </p><p>
        比較のために、型が <code class="literal">INT</code> である <code class="literal">int_col</code> という名前のカラムがあるとします。式 <code class="literal">POW(5-int_col,3) + 6</code> を検討してみてください。これは、<code class="literal">int_col</code> の値が変化したときに、式の値に比例的に変化することが保証されないため、ハッシュ関数の良い候選択肢ではありません。<code class="literal">int_col</code> の値が一定量で変化したときに、式の値の変化量が大きくなる可能性があります。たとえば、<code class="literal">int_col</code> が <code class="literal">5</code> から <code class="literal">6</code> に変化すると、式の値が <code class="literal">-1</code> に変化しますが、<code class="literal">int_col</code> の値が <code class="literal">6</code> から <code class="literal">7</code> に変化すると、式の値が <code class="literal">-7</code> に変化します。
      </p><p>
        つまり、カラム値と式の値のグラフが、等式 <code class="literal">y=<em class="replaceable"><code>c</code></em>x</code> (ここで、<em class="replaceable"><code>c</code></em> はゼロでない何らかの定数) によって描かれるような直線に近くなるほど、その式はハッシュにより適切になります。これは、式が非直線的であるほど、パーティションに対するデータの配分が不均衡になる傾向があることに関係しています。
      </p><p>
        理論上は、複数のカラム値を使用する式をプルーニングすることもできますが、そのような式のどれが適しているかを判断するのがかなり難しく、時間がかかることがあります。このため、複数のカラムを含むハッシュ式を使用することはあまり推奨されていません。
      </p><p>
        <code class="literal">PARTITION BY HASH</code> が使用された場合、MySQL はユーザー関数の結果の法に基づいて、<em class="replaceable"><code>num</code></em> パーティションのうちのどのパーティションを使用するかを判断します。つまり、式 <em class="replaceable"><code>expr</code></em> の場合、レコードが格納されるパーティションは、パーティション番号 <em class="replaceable"><code>N</code></em> です (ここで、<code class="literal"><em class="replaceable"><code>N</code></em> = MOD(<em class="replaceable"><code>expr</code></em>, <em class="replaceable"><code>num</code></em>)</code>)。テーブル <code class="literal">t1</code> が次のように 4 つのパーティションを持つように定義されているとします。
      </p><pre class="programlisting">
CREATE TABLE t1 (col1 INT, col2 CHAR(5), col3 DATE)
    PARTITION BY HASH( YEAR(col3) )
    PARTITIONS 4;
</pre><p>
        <code class="literal">t1</code> に <code class="literal">col3</code> 値が <code class="literal">'2005-09-15'</code> であるレコードを挿入した場合、それが格納されるパーティションは次のように判断されます。
      </p><pre class="programlisting">
MOD(YEAR('2005-09-01'),4)
=  MOD(2005,4)
=  1
</pre><p>
        MySQL 5.6 は、パーティション化されたテーブルに挿入される新しい行の配置を判断するために、より複雑なアルゴリズムを使用する<em class="firstterm">線形ハッシュ</em>と呼ばれる、<code class="literal">HASH</code> パーティショニングのバリアントもサポートします。このアルゴリズムについては、<a class="xref" href="partitioning.html#partitioning-linear-hash" title="19.2.4.1 LINEAR HASH パーティショニング">セクション19.2.4.1「LINEAR HASH パーティショニング」</a>を参照してください。
      </p><p>
        ユーザー関数は、レコードが挿入または更新されるたびに評価されます。状況によっては、レコードが削除されるときにも評価されることがあります。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          パーティション化されるテーブルに <code class="literal">UNIQUE</code> キーがある場合、<code class="literal">HASH</code> ユーザー関数または <code class="literal">KEY</code> の <em class="replaceable"><code>column_list</code></em> に引数として指定するカラムは、そのキーの一部である必要があります。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="partitioning-linear-hash"></a>19.2.4.1 LINEAR HASH パーティショニング</h4></div></div></div><a class="indexterm" name="idm139979015562288"></a><a class="indexterm" name="idm139979015560128"></a><p>
          MySQL は線形ハッシュもサポートしています。通常のハッシュと異なるところは、線形ハッシュは線形二乗アルゴリズムを使用し、通常のハッシュはハッシュ関数の値の法を使用することです。
        </p><p>
          構文的には、リニアハッシュパーティショニングと通常のハッシュの唯一の違いは、次に示すように、<code class="literal">PARTITION BY</code> 句に <code class="literal">LINEAR</code> キーワードが追加されていることです。
        </p><pre class="programlisting">
CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT,
    store_id INT
)
PARTITION BY LINEAR HASH( YEAR(hired) )
PARTITIONS 4;
</pre><p>
          式 <em class="replaceable"><code>expr</code></em> の場合、線形ハッシュが使用されるときにレコードが格納されるパーティションは、<em class="replaceable"><code>num</code></em> パーティションのうちのバーティション番号 <em class="replaceable"><code>N</code></em> です。ここで、<em class="replaceable"><code>N</code></em> は次のアルゴリズムに従って導出されます。
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              <em class="replaceable"><code>num</code></em> よりも大きい次の 2 の累乗を見つけます。この値を <em class="replaceable"><code>V</code></em> と呼ぶことにします。これは次のように計算できます。
            </p><pre class="programlisting">
<em class="replaceable"><code>V</code></em> = POWER(2, CEILING(LOG(2, <em class="replaceable"><code>num</code></em>)))
</pre><p>
              (<em class="replaceable"><code>num</code></em> が 13 であるとします。その場合、<code class="literal">LOG(2,13)</code> は 3.7004397181411 です。<code class="literal">CEILING(3.7004397181411)</code> は 4、<em class="replaceable"><code>V</code></em> = <code class="literal">POWER(2,4)</code> は 16 です。)
            </p></li><li class="listitem"><p>
              <em class="replaceable"><code>N</code></em> = <em class="replaceable"><code>F</code></em>(<em class="replaceable"><code>column_list</code></em>) &amp; (<em class="replaceable"><code>V</code></em> - 1) を設定します。
            </p></li><li class="listitem"><p>
              <em class="replaceable"><code>N</code></em> &gt;= <em class="replaceable"><code>num</code></em> の間:
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                  <em class="replaceable"><code>V</code></em> = CEIL(<em class="replaceable"><code>V</code></em> / 2) を設定します
                </p></li><li class="listitem"><p>
                  <em class="replaceable"><code>N</code></em> = <em class="replaceable"><code>N</code></em> &amp; (<em class="replaceable"><code>V</code></em> - 1) を設定します
                </p></li></ul></div></li></ol></div><p>
          線形ハッシュパーティショニングを使用し、6 個のパーティションを持つテーブル <code class="literal">t1</code> を次のステートメントを使用して作成するとします。
        </p><pre class="programlisting">
CREATE TABLE t1 (col1 INT, col2 CHAR(5), col3 DATE)
    PARTITION BY LINEAR HASH( YEAR(col3) )
    PARTITIONS 6;
</pre><p>
          <code class="literal">col3</code> カラムの値が <code class="literal">'2003-04-14'</code> および <code class="literal">'1998-10-19'</code> である 2 つのレコードを <code class="literal">t1</code> に挿入するとします。これらの 1 番目のパーティション番号は次のように決定されます。
        </p><pre class="programlisting">
<em class="replaceable"><code>V</code></em> = POWER(2, CEILING( LOG(2,6) )) = 8
<em class="replaceable"><code>N</code></em> = YEAR('2003-04-14') &amp; (8 - 1)
   = 2003 &amp; 7
   = 3

(<span class="emphasis"><em>3 &gt;= 6 is FALSE: record stored in partition #3</em></span>)
</pre><p>
          2 番目のレコードが格納されるパーティションの番号は、次のように計算されます。
        </p><pre class="programlisting">
<em class="replaceable"><code>V</code></em> = 8
<em class="replaceable"><code>N</code></em> = YEAR('1998-10-19') &amp; (8-1)
  = 1998 &amp; 7
  = 6

(<span class="emphasis"><em>6 &gt;= 6 is TRUE: additional step required</em></span>)

<em class="replaceable"><code>N</code></em> = 6 &amp; CEILING(8 / 2)
  = 6 &amp; 3
  = 2

(<span class="emphasis"><em>2 &gt;= 6 is FALSE: record stored in partition #2</em></span>)
</pre><p>
          線形ハッシュによるパーティショニングの利点は、パーティションの追加、削除、マージ、および分割の速度が向上することです。これは、非常に大量 (テラバイト) のデータが含まれるテーブルを扱うときに利点になることがあります。欠点は、通常のハッシュパーティショニングを使用して獲得される配分と比べて、データがパーティションに均等に配分される可能性が低いことです。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="partitioning-key"></a>19.2.5 KEY パーティショニング</h3></div></div></div><a class="indexterm" name="idm139979015521056"></a><a class="indexterm" name="idm139979015518912"></a><p>
        キーによるパーティショニングはハッシュによるパーティショニングと似ていますが、ハッシュパーティショニングはユーザー定義の式を使用し、キーパーティショニング用のハッシュ関数は MySQL サーバーによって提供されます。MySQL Cluster はこのために <code class="literal">MD5()</code> を使用します。ほかのストレージエンジンを使用するテーブルの場合、サーバーは <code class="literal">PASSWORD()</code> と同じアルゴリズムに基づく独自の内部ハッシュ関数を使用します。
      </p><p>
        <code class="literal">CREATE TABLE ... PARTITION BY KEY</code> の構文規則は、ハッシュによってパーティション化されたテーブルを作成する場合のものと似ています。主な違いを次に示します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">HASH</code> ではなく <code class="literal">KEY</code> が使用されます。
          </p></li><li class="listitem"><p>
            <code class="literal">KEY</code> は、0 個以上のカラム名のリストのみを取ります。パーティショニングキーとして使用されるカラムは、テーブルの主キーの一部またはすべてを構成している必要があります (テーブルにそれがある場合)。パーティショニングキーとしてカラム名を指定しない場合は、テーブルの主キーが使用されます (ある場合)。たとえば、次の <code class="literal">CREATE TABLE</code> ステートメントは MySQL 5.6 で有効です。
          </p><pre class="programlisting">
CREATE TABLE k1 (
    id INT NOT NULL PRIMARY KEY,
    name VARCHAR(20)
)
PARTITION BY KEY()
PARTITIONS 2;
</pre><p>
            主キーはないけれども一意キーはある場合は、パーティショニングキーに一意キーが使用されます。
          </p><pre class="programlisting">
CREATE TABLE k1 (
    id INT NOT NULL,
    name VARCHAR(20),
    UNIQUE KEY (id)
)
PARTITION BY KEY()
PARTITIONS 2;
</pre><p>
            ただし、一意キーカラムが <code class="literal">NOT NULL</code> として定義されていない場合、前のステートメントは失敗します。
          </p><p>
            どちらの場合も、パーティショニングキーは <code class="literal">id</code> カラムです。ただし、<code class="literal">SHOW CREATE TABLE</code> の出力や <code class="literal">INFORMATION_SCHEMA.PARTITIONS</code> テーブルの <code class="literal">PARTITION_EXPRESSION</code> カラムには表示されません。
          </p><p>
            ほかのパーティショニングタイプの場合と異なり、<code class="literal">KEY</code> によるパーティショニングに使用されるカラムは、整数または <code class="literal">NULL</code> 値に制限されません。たとえば、次の <code class="literal">CREATE TABLE</code> ステートメントは有効です。
          </p><pre class="programlisting">
CREATE TABLE tm1 (
    s1 CHAR(32) PRIMARY KEY
)
PARTITION BY KEY(s1)
PARTITIONS 10;
</pre><p>
            ほかのパーティショニングタイプが指定された場合、前のステートメントは有効で<span class="emphasis"><em>なくなります</em></span>(この場合、<code class="literal">s1</code> はテーブルの主キーであるため、単純に <code class="literal">PARTITION BY KEY()</code> を使用することも有効であり、<code class="literal">PARTITION BY KEY(s1)</code> と同じ効果があります)。
          </p><p>
            この問題の詳細については、<a class="xref" href="partitioning.html#partitioning-limitations" title="19.6 パーティショニングの制約と制限">セクション19.6「パーティショニングの制約と制限」</a>を参照してください。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              <code class="literal">NDB</code> ストレージエンジンを使用するテーブルは、テーブルの主キーをパーティショニングキーとして使用して、<code class="literal">KEY</code> によって暗黙的にパーティション化されます。MySQL Cluster テーブルに明示的な主キーがない場合は、<code class="literal">NDB</code> ストレージエンジンによって各 MySQL Cluster テーブルに生成される<span class="quote">「<span class="quote">隠し</span>」</span>主キーが、パーティショニングキーとして使用されます。
            </p><p>
              <code class="literal">NDB</code> テーブルに明示的なパーティショニングスキームを定義する場合は、テーブルに明示的な主キーが必要であり、パーティショニング式に使用されるカラムがこのキーの一部である必要があります。ただし、テーブルが<span class="quote">「<span class="quote">空</span>」</span>のパーティショニング式を使用する (つまり、カラム参照なしの <code class="literal">PARTITION BY KEY()</code>) 場合、明示的な主キーは必要ありません。
            </p><p>
              このパーティショニングは、<span class="command"><strong>ndb_desc</strong></span> ユーティリティー (<code class="option">-p</code> オプション付き) を使用して確認できます。
            </p></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
              キーによってパーティション化されたテーブルの場合は、<code class="literal">ALTER TABLE DROP PRIMARY KEY</code> を実行できません。それを実行すると次のエラーが生成されます: <span class="errortext">ERROR 1466 (HY000): Field in list of fields for partition function not found in table</span>。これは、<code class="literal">KEY</code> によってパーティション化された MySQL Cluster テーブルの場合は問題ではありません。そのような場合は、<span class="quote">「<span class="quote">隠し</span>」</span>主キーをテーブルの新しいパーティショニングキーとして使用してテーブルが再編成されます。<a class="xref" href="mysql-cluster.html" title="第 18 章 MySQL Cluster NDB 7.3 および MySQL Cluster NDB 7.4">第18章「<i>MySQL Cluster NDB 7.3 および MySQL Cluster NDB 7.4</i>」</a>を参照してください。
            </p></div></li></ul></div><a class="indexterm" name="idm139979015476160"></a><a class="indexterm" name="idm139979015473984"></a><p>
        リニアキーによってテーブルをパーティション化することもできます。次に、単純な例を示します。
      </p><pre class="programlisting">
CREATE TABLE tk (
    col1 INT NOT NULL,
    col2 CHAR(5),
    col3 DATE
)
PARTITION BY LINEAR KEY (col1)
PARTITIONS 3;
</pre><p>
        <code class="literal">LINEAR</code> を使用することは、<code class="literal">HASH</code> パーティショニングの場合と同じ効果が <code class="literal">KEY</code> パーティショニングにあり、パーティショニング番号は法演算ではなく二乗アルゴリズムを使用して導出されます。このアルゴリズムの説明およびその影響については、<a class="xref" href="partitioning.html#partitioning-linear-hash" title="19.2.4.1 LINEAR HASH パーティショニング">セクション19.2.4.1「LINEAR HASH パーティショニング」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="partitioning-subpartitions"></a>19.2.6 サブパーティショニング</h3></div></div></div><a class="indexterm" name="idm139979015466064"></a><a class="indexterm" name="idm139979015464576"></a><p>
        サブパーティショニング (<em class="firstterm">複合パーティショニング</em>とも呼ばれます) は、パーティション化されたテーブルの各パーティションをさらに分割することです。次の <code class="literal">CREATE TABLE</code> ステートメントを検討します。
      </p><pre class="programlisting">
CREATE TABLE ts (id INT, purchased DATE)
    PARTITION BY RANGE( YEAR(purchased) )
    SUBPARTITION BY HASH( TO_DAYS(purchased) )
    SUBPARTITIONS 2 (
        PARTITION p0 VALUES LESS THAN (1990),
        PARTITION p1 VALUES LESS THAN (2000),
        PARTITION p2 VALUES LESS THAN MAXVALUE
    );
</pre><p>
        テーブル <code class="literal">ts</code> には 3 つの <code class="literal">RANGE</code> パーティションがあります。これらの各パーティション (<code class="literal">p0</code>、<code class="literal">p1</code>、および <code class="literal">p2</code>) は、さらに 2 つのサブパーティションに分割されます。実際には、テーブル全体が <code class="literal">3 * 2 = 6</code> パーティションに分割されます。ただし、<code class="literal">PARTITION BY RANGE</code> 句のアクションによって、これらの最初の 2 つには <code class="literal">purchased</code> カラムで値が 1990 より小さいレコードのみが格納されます。
      </p><a class="indexterm" name="idm139979015453344"></a><p>
        MySQL 5.6 では、<code class="literal">RANGE</code> または <code class="literal">LIST</code> によってパーティション化されたテーブルをサブパーティション化できます。サブパーティショニングには、<code class="literal">HASH</code> または <code class="literal">KEY</code> パーティショニングを使用できます。これは、<em class="firstterm">複合パーティショニング</em>とも呼ばれます。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">SUBPARTITION BY HASH</code> および <code class="literal">SUBPARTITION BY KEY</code> は通常それぞれ、<code class="literal">PARTITION BY HASH</code> および <code class="literal">PARTITION BY KEY</code> と同じ構文規則に従います。これの例外は、<code class="literal">SUBPARTITION BY KEY</code> は現在 (<code class="literal">PARTITION BY KEY</code> と異なり) デフォルトカラムをサポートしないことで、この目的に使用されるカラムを指定する必要があります (テーブルに明示的な主キーがある場合でも)。これは既知の問題であり、対処中です。詳細および例については <a class="xref" href="partitioning.html#partitioning-limitations-subpartitions" title="サブパーティションに関する問題">サブパーティションに関する問題</a>を参照してください。
        </p></div><a class="indexterm" name="idm139979015441104"></a><p>
        <code class="literal">SUBPARTITION</code> 句を使用して個々のサブパーティションのオプションを指定することによって、サブパーティションを明示的に定義することもできます。たとえば、前の例と同じテーブル <code class="literal">ts</code> をより冗長な形式で作成するには、次のようにします。
      </p><pre class="programlisting">
CREATE TABLE ts (id INT, purchased DATE)
    PARTITION BY RANGE( YEAR(purchased) )
    SUBPARTITION BY HASH( TO_DAYS(purchased) ) (
        PARTITION p0 VALUES LESS THAN (1990) (
            SUBPARTITION s0,
            SUBPARTITION s1
        ),
        PARTITION p1 VALUES LESS THAN (2000) (
            SUBPARTITION s2,
            SUBPARTITION s3
        ),
        PARTITION p2 VALUES LESS THAN MAXVALUE (
            SUBPARTITION s4,
            SUBPARTITION s5
        )
    );
</pre><p>
        構文に関するいくつかの注意事項を次に示します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            各パーティションには、同じ数のサブパーティションが必要です。
          </p></li><li class="listitem"><p>
            パーティション化されたテーブルのパーティションに <code class="literal">SUBPARTITION</code> を使用してサブパーティションを明示的に定義する場合は、それらのすべてを定義する必要があります。言い換えると、次のステートメントは失敗します。
          </p><pre class="programlisting">
CREATE TABLE ts (id INT, purchased DATE)
    PARTITION BY RANGE( YEAR(purchased) )
    SUBPARTITION BY HASH( TO_DAYS(purchased) ) (
        PARTITION p0 VALUES LESS THAN (1990) (
            SUBPARTITION s0,
            SUBPARTITION s1
        ),
        PARTITION p1 VALUES LESS THAN (2000),
        PARTITION p2 VALUES LESS THAN MAXVALUE (
            SUBPARTITION s2,
            SUBPARTITION s3
        )
    );
</pre><p>
            このステートメントは、<code class="literal">SUBPARTITIONS 2</code> 句を含んでいた場合でも失敗します。
          </p></li><li class="listitem"><p>
            各 <code class="literal">SUBPARTITION</code> 句には、(少なくとも) サブパーティションの名前が含まれている必要があります。それ以外は、サブパーティションに適切なオプションを設定するか、またはそのオプションのデフォルト設定を想定します。
          </p></li><li class="listitem"><p>
            サブパーティション名はテーブル全体で一意である必要があります。たとえば、次の <code class="literal">CREATE TABLE</code> ステートメントは MySQL 5.6 で有効です。
          </p><pre class="programlisting">
CREATE TABLE ts (id INT, purchased DATE)
    PARTITION BY RANGE( YEAR(purchased) )
    SUBPARTITION BY HASH( TO_DAYS(purchased) ) (
        PARTITION p0 VALUES LESS THAN (1990) (
            SUBPARTITION s0,
            SUBPARTITION s1
        ),
        PARTITION p1 VALUES LESS THAN (2000) (
            SUBPARTITION s2,
            SUBPARTITION s3
        ),
        PARTITION p2 VALUES LESS THAN MAXVALUE (
            SUBPARTITION s4,
            SUBPARTITION s5
        )
    );
</pre></li></ul></div><p>
        サブパーティションは、非常に大きいテーブルで、データおよびインデックスを多数のディスクに分散するために使用できます。<code class="filename">/disk0</code>、<code class="filename">/disk1</code>、<code class="filename">/disk2</code> などとしてマウントされた 6 個のディスクがあるとします。ここで次の例を検討します。
      </p><pre class="programlisting">
CREATE TABLE ts (id INT, purchased DATE)
    PARTITION BY RANGE( YEAR(purchased) )
    SUBPARTITION BY HASH( TO_DAYS(purchased) ) (
        PARTITION p0 VALUES LESS THAN (1990) (
            SUBPARTITION s0
                DATA DIRECTORY = '/disk0/data'
                INDEX DIRECTORY = '/disk0/idx',
            SUBPARTITION s1
                DATA DIRECTORY = '/disk1/data'
                INDEX DIRECTORY = '/disk1/idx'
        ),
        PARTITION p1 VALUES LESS THAN (2000) (
            SUBPARTITION s2
                DATA DIRECTORY = '/disk2/data'
                INDEX DIRECTORY = '/disk2/idx',
            SUBPARTITION s3
                DATA DIRECTORY = '/disk3/data'
                INDEX DIRECTORY = '/disk3/idx'
        ),
        PARTITION p2 VALUES LESS THAN MAXVALUE (
            SUBPARTITION s4
                DATA DIRECTORY = '/disk4/data'
                INDEX DIRECTORY = '/disk4/idx',
            SUBPARTITION s5
                DATA DIRECTORY = '/disk5/data'
                INDEX DIRECTORY = '/disk5/idx'
        )
    );
</pre><p>
        この場合、各 <code class="literal">RANGE</code> のデータおよびインデックスに個別のディスクが使用されます。ほかにも多数のバリエーションが考えられます。別の例を次に示します。
      </p><pre class="programlisting">
CREATE TABLE ts (id INT, purchased DATE)
    PARTITION BY RANGE(YEAR(purchased))
    SUBPARTITION BY HASH( TO_DAYS(purchased) ) (
        PARTITION p0 VALUES LESS THAN (1990) (
            SUBPARTITION s0a
                DATA DIRECTORY = '/disk0'
                INDEX DIRECTORY = '/disk1',
            SUBPARTITION s0b
                DATA DIRECTORY = '/disk2'
                INDEX DIRECTORY = '/disk3'
        ),
        PARTITION p1 VALUES LESS THAN (2000) (
            SUBPARTITION s1a
                DATA DIRECTORY = '/disk4/data'
                INDEX DIRECTORY = '/disk4/idx',
            SUBPARTITION s1b
                DATA DIRECTORY = '/disk5/data'
                INDEX DIRECTORY = '/disk5/idx'
        ),
        PARTITION p2 VALUES LESS THAN MAXVALUE (
            SUBPARTITION s2a,
            SUBPARTITION s2b
        )
    );
</pre><p>
        この場合は、次のように格納されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">purchased</code> 日付が 1990 年より前の行には大きな領域が使用されるため、4 つに分割され、パーティション <code class="literal">p0</code> を構成する 2 つの各サブパーティション (<code class="literal">s0a</code> および <code class="literal">s0b</code>) のデータおよびインデックスに個別のディスクが専用に割り当てられます。言い換えると、次のようになります。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                サブパーティション <code class="literal">s0a</code> のデータは <code class="filename">/disk0</code> に格納されます。
              </p></li><li class="listitem"><p>
                サブパーティション <code class="literal">s0a</code> のインデックスは、<code class="filename">/disk1</code> に格納されます。
              </p></li><li class="listitem"><p>
                サブパーティション <code class="literal">s0b</code> のデータは、<code class="filename">/disk2</code> に格納されます。
              </p></li><li class="listitem"><p>
                サブパーティション <code class="literal">s0b</code> のインデックスは、<code class="filename">/disk3</code> に格納されます。
              </p></li></ul></div></li><li class="listitem"><p>
            1990 年から 1999 年までの日付 (パーティション <code class="literal">p1</code>) が含まれている行は、1990 年より前の行ほどの領域を必要としません。これらは、<code class="literal">p0</code> に格納されるレガシーレコードの場合の 4 つのディスクではなく、2 つのディスク (<code class="filename">/disk4</code> および <code class="filename">/disk5</code>) に分割されます。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">p1</code> の最初のサブパーティション (<code class="literal">s1a</code>) に属するデータおよびインデックスは、<code class="filename">/disk4</code> (データは <code class="filename">/disk4/data</code>、およびインデックスは <code class="filename">/disk4/idx</code>) に格納されます。
              </p></li><li class="listitem"><p>
                <code class="literal">p1</code> の 2 番目のサブパーティション (<code class="literal">s1b</code>) に属するデータおよびインデックスは、<code class="filename">/disk5</code> (データは <code class="filename">/disk5/data</code>、およびインデックスは <code class="filename">/disk5/idx</code>) に格納されます。
              </p></li></ul></div></li><li class="listitem"><p>
            2000 年から現在までの日付 (パーティション <code class="literal">p2</code>) を反映する行には、前の 2 つの範囲で必要とされたほどの領域は使用されません。現在のところ、これらのすべてをデフォルトの場所に格納しても問題ありません。
          </p><p>
            将来、2000 年から始まる 10 年間の購入数が、デフォルトの場所では十分な領域を提供できないほど増えたときには、<code class="literal">ALTER TABLE ... REORGANIZE PARTITION</code> ステートメントを使用して対応する行を移動できます。これを行う方法については、<a class="xref" href="partitioning.html#partitioning-management" title="19.3 パーティション管理">セクション19.3「パーティション管理」</a>を参照してください。
          </p></li></ul></div><p>
        <code class="literal">NO_DIR_IN_CREATE</code> サーバー SQL モードが有効である場合、<code class="literal">DATA DIRECTORY</code> および <code class="literal">INDEX DIRECTORY</code> オプションはパーティション定義で許可されません。MySQL 5.6 では、これらのオプションはサブパーティションを定義するときにも許可されません (Bug #42954)。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="partitioning-handling-nulls"></a>19.2.7 MySQL パーティショニングによる NULL の扱い</h3></div></div></div><p>
        MySQL のパーティショニングには、パーティショニング式の値 (カラム値またはユーザー定義式の値にかかわらず) として <code class="literal">NULL</code> を拒否する手段はありません。式の値として <code class="literal">NULL</code> を使用することは許可されていますが (そうでない場合は整数を返す必要がある)、<code class="literal">NULL</code> は数値でないことを認識することは重要です。MySQL のパーティショニング実装は、<code class="literal">ORDER BY</code> のように、<code class="literal">NULL</code> でない値より小さい値として <code class="literal">NULL</code> を扱います。
      </p><p>
        これは、<code class="literal">NULL</code> の扱いは各タイプのパーティショニングで異なり、これに準備していない場合は予期しない動作になる可能性があることを意味します。このような状況があるので、このセクションでは、各 MySQL パーティショニングタイプが、行をどのパーティションに格納するべきかを判断するときに <code class="literal">NULL</code> 値をどのように扱うかを説明し、それぞれの例を示します。
      </p><p><b>RANGE パーティショニングでの NULL の扱い </b>
          パーティションを判断するために使用されるカラム値が <code class="literal">NULL</code> である行を、<code class="literal">RANGE</code> によってパーティション化されたテーブルに挿入した場合、行はもっとも低いパーティションに挿入されます。<code class="literal">p</code> という名前のデータベースに、次のように作成された 2 つのテーブルがあるとします。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (</code></strong>
    -&gt;     <strong class="userinput"><code>c1 INT,</code></strong>
    -&gt;     <strong class="userinput"><code>c2 VARCHAR(20)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY RANGE(c1) (</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (0),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (10),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p2 VALUES LESS THAN MAXVALUE</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.09 sec)

mysql&gt; <strong class="userinput"><code>CREATE TABLE t2 (</code></strong>
    -&gt;     <strong class="userinput"><code>c1 INT,</code></strong>
    -&gt;     <strong class="userinput"><code>c2 VARCHAR(20)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY RANGE(c1) (</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (-5),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (0),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p2 VALUES LESS THAN (10),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p3 VALUES LESS THAN MAXVALUE</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.09 sec)
</pre><p>
        これらの 2 つの <code class="literal">CREATE TABLE</code> ステートメントによって作成されたパーティションについては、次のクエリーを <code class="literal">INFORMATION_SCHEMA</code> データベース内の <code class="literal">PARTITIONS</code> テーブルに対して使用することで確認できます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT TABLE_NAME, PARTITION_NAME, TABLE_ROWS, AVG_ROW_LENGTH, DATA_LENGTH</code></strong>
     &gt;   <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
     &gt;   <strong class="userinput"><code>WHERE TABLE_SCHEMA = 'p' AND TABLE_NAME LIKE 't_';</code></strong>
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
| t1         | p0             |          0 |              0 |           0 |
| t1         | p1             |          0 |              0 |           0 |
| t1         | p2             |          0 |              0 |           0 |
| t2         | p0             |          0 |              0 |           0 |
| t2         | p1             |          0 |              0 |           0 |
| t2         | p2             |          0 |              0 |           0 |
| t2         | p3             |          0 |              0 |           0 |
+------------+----------------+------------+----------------+-------------+
7 rows in set (0.00 sec)
</pre><p>
        (このテーブルについての詳細は、<a class="xref" href="information-schema.html#partitions-table" title="21.13 INFORMATION_SCHEMA PARTITIONS テーブル">セクション21.13「INFORMATION_SCHEMA PARTITIONS テーブル」</a>を参照してください。)ここで、これらの各テーブルのパーティショニングキーとして使用されるカラムに <code class="literal">NULL</code> が含まれる単一行を移入し、2 つの <code class="literal">SELECT</code> ステートメントを使用してこれらの行が挿入されたことを確認します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>INSERT INTO t1 VALUES (NULL, 'mothra');</code></strong>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO t2 VALUES (NULL, 'mothra');</code></strong>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM t1;</code></strong>
+------+--------+
| id   | name   |
+------+--------+
| NULL | mothra |
+------+--------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM t2;</code></strong>
+------+--------+
| id   | name   |
+------+--------+
| NULL | mothra |
+------+--------+
1 row in set (0.00 sec)
</pre><p>
        挿入された行を格納するためにどのパーティションが使用されたかについては、前のクエリーを <code class="literal">INFORMATION_SCHEMA.PARTITIONS</code> に対して再実行して出力を検査することで確認できます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT TABLE_NAME, PARTITION_NAME, TABLE_ROWS, AVG_ROW_LENGTH, DATA_LENGTH</code></strong>
     &gt;   <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
     &gt;   <strong class="userinput"><code>WHERE TABLE_SCHEMA = 'p' AND TABLE_NAME LIKE 't_';</code></strong>
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
<span class="emphasis"><em>| t1         | p0             |          1 |             20 |          20 |</em></span>
| t1         | p1             |          0 |              0 |           0 |
| t1         | p2             |          0 |              0 |           0 |
<span class="emphasis"><em>| t2         | p0             |          1 |             20 |          20 |</em></span>
| t2         | p1             |          0 |              0 |           0 |
| t2         | p2             |          0 |              0 |           0 |
| t2         | p3             |          0 |              0 |           0 |
+------------+----------------+------------+----------------+-------------+
7 rows in set (0.01 sec)
</pre><p>
        これらの行が各テーブルのもっとも低いパーティションに格納されたことについては、これらのパーティションを削除してから <code class="literal">SELECT</code> ステートメントを再実行することで確認できます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>ALTER TABLE t1 DROP PARTITION p0;</code></strong>
Query OK, 0 rows affected (0.16 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE t2 DROP PARTITION p0;</code></strong>
Query OK, 0 rows affected (0.16 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM t1;</code></strong>
Empty set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM t2;</code></strong>
Empty set (0.00 sec)
</pre><p>
        (<code class="literal">ALTER TABLE ... DROP PARTITION</code> の詳細については、<a class="xref" href="sql-syntax.html#alter-table" title="13.1.7 ALTER TABLE 構文">セクション13.1.7「ALTER TABLE 構文」</a>を参照してください。)
      </p><p>
        SQL 関数を使用するパーティショニング式の場合も、<code class="literal">NULL</code> はこのように扱われます。次のような <code class="literal">CREATE TABLE</code> ステートメントを使用してテーブルを定義するとします。
      </p><pre class="programlisting">
CREATE TABLE tndate (
    id INT,
    dt DATE
)
PARTITION BY RANGE( YEAR(dt) ) (
    PARTITION p0 VALUES LESS THAN (1990),
    PARTITION p1 VALUES LESS THAN (2000),
    PARTITION p2 VALUES LESS THAN MAXVALUE
);
</pre><p>
        ほかの MySQL 関数と同様に、<code class="literal">YEAR(NULL)</code> は <code class="literal">NULL</code> を返します。<code class="literal">dt</code> カラム値が <code class="literal">NULL</code> である行は、パーティショニング式がほかの値より小さい値に評価されたかのように扱われ、パーティション <code class="literal">p0</code> に挿入されます。
      </p><p><b>LIST パーティショニングでの NULL の扱い </b>
          <code class="literal">LIST</code> によってパーティション化されたテーブルで <code class="literal">NULL</code> 値が許可されるのは、<code class="literal">NULL</code> が含まれている値リストを使用していずれかのパーティションが定義されている場合のみです。これとは逆に、<code class="literal">LIST</code> によってパーティション化されたテーブルが、値リストで <code class="literal">NULL</code> を明示的に使用していない場合は、次の例のようにパーティショニング式で <code class="literal">NULL</code> 値に評価される行を拒否します。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE ts1 (</code></strong>
    -&gt;     <strong class="userinput"><code>c1 INT,</code></strong>
    -&gt;     <strong class="userinput"><code>c2 VARCHAR(20)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY LIST(c1) (</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES IN (0, 3, 6),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES IN (1, 4, 7),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p2 VALUES IN (2, 5, 8)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO ts1 VALUES (9, 'mothra');</code></strong>
<span class="errortext">ERROR 1504 (HY000): Table has no partition for value 9</span>

mysql&gt; <strong class="userinput"><code>INSERT INTO ts1 VALUES (NULL, 'mothra');</code></strong>
<span class="errortext">ERROR 1504 (HY000): Table has no partition for value NULL</span>
</pre><p>
        <code class="literal">ts1</code> に挿入できるのは、<code class="literal">c1</code> 値が <code class="literal">0</code> 以上 <code class="literal">8</code> 以下の行のみです。<code class="literal">NULL</code> は、数値 <code class="literal">9</code> と同様にこの範囲を外れます。<code class="literal">NULL</code> が含まれる値リストを持つテーブル <code class="literal">ts2</code> および<code class="literal">ts3</code> は次のように作成できます。
      </p><pre class="programlisting">
mysql&gt; CREATE TABLE ts2 (
    -&gt;     c1 INT,
    -&gt;     c2 VARCHAR(20)
    -&gt; )
    -&gt; PARTITION BY LIST(c1) (
    -&gt;     PARTITION p0 VALUES IN (0, 3, 6),
    -&gt;     PARTITION p1 VALUES IN (1, 4, 7),
    -&gt;     PARTITION p2 VALUES IN (2, 5, 8),
    -&gt;     PARTITION p3 VALUES IN (NULL)
    -&gt; );
Query OK, 0 rows affected (0.01 sec)

mysql&gt; CREATE TABLE ts3 (
    -&gt;     c1 INT,
    -&gt;     c2 VARCHAR(20)
    -&gt; )
    -&gt; PARTITION BY LIST(c1) (
    -&gt;     PARTITION p0 VALUES IN (0, 3, 6),
    -&gt;     PARTITION p1 VALUES IN (1, 4, 7, NULL),
    -&gt;     PARTITION p2 VALUES IN (2, 5, 8)
    -&gt; );
Query OK, 0 rows affected (0.01 sec)
</pre><p>
        パーティショニングの値リストを定義するときに、<code class="literal">NULL</code> をほかの値と同様に扱うことができます (そうすべきです)。たとえば、<code class="literal">VALUES IN (NULL)</code> および <code class="literal">VALUES IN (1, 4, 7, NULL)</code> は両方とも有効であり、<code class="literal">VALUES IN (1, NULL, 4, 7)</code>、<code class="literal">VALUES IN (NULL, 1, 4, 7)</code> なども同様です。カラム <code class="literal">c1</code> が <code class="literal">NULL</code> である行をテーブル <code class="literal">ts2</code> および <code class="literal">ts3</code> にそれぞれ挿入できます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>INSERT INTO ts2 VALUES (NULL, 'mothra');</code></strong>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO ts3 VALUES (NULL, 'mothra');</code></strong>
Query OK, 1 row affected (0.00 sec)
</pre><p>
        <code class="literal">INFORMATION_SCHEMA.PARTITIONS</code> に対して適切なクエリーを発行することによって、先ほど挿入した行を格納するためにどのパーティションが使用されたかを確認できます (前の例と同様に、パーティション化されたテーブルが <code class="literal">p</code> データベースに作成されたことを想定しています)。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT TABLE_NAME, PARTITION_NAME, TABLE_ROWS, AVG_ROW_LENGTH, DATA_LENGTH</code></strong>
     &gt;   <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
     &gt;   <strong class="userinput"><code>WHERE TABLE_SCHEMA = 'p' AND TABLE_NAME LIKE 'ts_';</code></strong>
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
| ts2        | p0             |          0 |              0 |           0 |
| ts2        | p1             |          0 |              0 |           0 |
| ts2        | p2             |          0 |              0 |           0 |
<span class="emphasis"><em>| ts2        | p3             |          1 |             20 |          20 |</em></span>
| ts3        | p0             |          0 |              0 |           0 |
<span class="emphasis"><em>| ts3        | p1             |          1 |             20 |          20 |</em></span>
| ts3        | p2             |          0 |              0 |           0 |
+------------+----------------+------------+----------------+-------------+
7 rows in set (0.01 sec)
</pre><p>
        このセクションですでに示したように、行を格納するためにどのパーティションが使用されたかについては、それらのパーティションを削除してから <code class="literal">SELECT</code> を実行することで確認できます。
      </p><p><b>HASH および KEY パーティショニングでの NULL の扱い </b>
          <code class="literal">HASH</code> または <code class="literal">KEY</code> によってパーティション化されたテーブルの場合、<code class="literal">NULL</code> の扱いは少し異なります。これらの場合、<code class="literal">NULL</code> 値を返すパーティショニング式は、戻り値がゼロであったかのように扱われます。この動作については、<code class="literal">HASH</code> によってパーティション化されたテーブルを作成して該当する値が含まれるレコードを挿入することで、ファイルシステムにどのような影響があるかを検査することで確認できます。次のステートメントを使用して作成されたテーブル <code class="literal">th</code> (これも <code class="literal">p</code> データベース内) があるとします。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE th (</code></strong>
    -&gt;     <strong class="userinput"><code>c1 INT,</code></strong>
    -&gt;     <strong class="userinput"><code>c2 VARCHAR(20)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY HASH(c1)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITIONS 2;</code></strong>
Query OK, 0 rows affected (0.00 sec)
</pre><p>
        このテーブルに属するパーティションは、次のクエリーを使用して表示できます。
      </p><pre class="programlisting">
mysql&gt; SELECT TABLE_NAME,PARTITION_NAME,TABLE_ROWS,AVG_ROW_LENGTH,DATA_LENGTH
     &gt;   FROM INFORMATION_SCHEMA.PARTITIONS
     &gt;   WHERE TABLE_SCHEMA = 'p' AND TABLE_NAME ='th';
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
| th         | p0             |          0 |              0 |           0 |
| th         | p1             |          0 |              0 |           0 |
+------------+----------------+------------+----------------+-------------+
2 rows in set (0.00 sec)
</pre><p>
        各パーティションの <code class="literal">TABLE_ROWS</code> は 0 です。ここで次に示すように、<code class="literal">c1</code> カラム値が <code class="literal">NULL</code> および 0 である 2 つの行を <code class="literal">th</code> に挿入し、それらの行が挿入されたことを確認します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>INSERT INTO th VALUES (NULL, 'mothra'), (0, 'gigan');</code></strong>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM th;</code></strong>
+------+---------+
| c1   | c2      |
+------+---------+
| NULL | mothra  |
+------+---------+
|    0 | gigan   |
+------+---------+
2 rows in set (0.01 sec)
</pre><p>
        任意の整数 <em class="replaceable"><code>N</code></em> について、<code class="literal">NULL MOD <em class="replaceable"><code>N</code></em></code> の値は常に <code class="literal">NULL</code> であることを思い出してください。<code class="literal">HASH</code> または <code class="literal">KEY</code> によってパーティション化されたテーブルの場合、この結果は正しいパーティションを判別するために <code class="literal">0</code> として扱われます。<code class="literal">INFORMATION_SCHEMA.PARTITIONS</code> テーブルを再度確認すると、両方の行がパーティション <code class="literal">p0</code> に挿入されたことがわかります。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT TABLE_NAME, PARTITION_NAME, TABLE_ROWS, AVG_ROW_LENGTH, DATA_LENGTH</code></strong>
     &gt;   <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
     &gt;   <strong class="userinput"><code>WHERE TABLE_SCHEMA = 'p' AND TABLE_NAME ='th';</code></strong>
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
<span class="emphasis"><em>| th         | p0             |          2 |             20 |          20 |</em></span>
| th         | p1             |          0 |              0 |           0 |
+------------+----------------+------------+----------------+-------------+
2 rows in set (0.00 sec)
</pre><p>
        テーブルの定義で <code class="literal">PARTITION BY HASH</code> の代わりに <code class="literal">PARTITION BY KEY</code> を使用してこの例を繰り返すと、このタイプのパーティショニングでも <code class="literal">NULL</code> が 0 のように扱われることを簡単に確認できます。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="partitioning-management"></a>19.3 パーティション管理</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="partitioning.html#partitioning-management-range-list">19.3.1 RANGE および LIST パーティションの管理</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-management-hash-key">19.3.2 HASH および KEY パーティションの管理</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-management-exchange">19.3.3 パーティションとサブパーティションをテーブルと交換する</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-maintenance">19.3.4 パーティションの保守</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-info">19.3.5 パーティションに関する情報を取得する</a></span></dt></dl></div><a class="indexterm" name="idm139979015233568"></a><a class="indexterm" name="idm139979015232112"></a><a class="indexterm" name="idm139979015230080"></a><a class="indexterm" name="idm139979015228048"></a><a class="indexterm" name="idm139979015226000"></a><a class="indexterm" name="idm139979015223936"></a><p>
      MySQL 5.6 は、パーティション化されたテーブルを変更するためにいくつかの方法を提供しています。既存のパーティションを追加、削除、再定義、マージ、または分割できます。これらのすべてのアクションは、<code class="literal">ALTER TABLE</code> ステートメントのパーティショニング拡張を使用して実行できます。パーティション化されたテーブルおよびパーティションに関する情報を取得する方法もあります。以降のセクションでは次のトピックについて説明します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">RANGE</code> または <code class="literal">LIST</code> によってパーティション化されたテーブルのパーティション管理については、<a class="xref" href="partitioning.html#partitioning-management-range-list" title="19.3.1 RANGE および LIST パーティションの管理">セクション19.3.1「RANGE および LIST パーティションの管理」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">HASH</code> および <code class="literal">KEY</code> パーティションの管理については、<a class="xref" href="partitioning.html#partitioning-management-hash-key" title="19.3.2 HASH および KEY パーティションの管理">セクション19.3.2「HASH および KEY パーティションの管理」</a>を参照してください。
        </p></li><li class="listitem"><p>
          パーティション化されたテーブルおよびパーティションに関する情報を取得するために MySQL 5.6 で提供されるメカニズムについては、<a class="xref" href="partitioning.html#partitioning-info" title="19.3.5 パーティションに関する情報を取得する">セクション19.3.5「パーティションに関する情報を取得する」</a>を参照してください。
        </p></li><li class="listitem"><p>
          パーティションの保守操作の実行については、<a class="xref" href="partitioning.html#partitioning-maintenance" title="19.3.4 パーティションの保守">セクション19.3.4「パーティションの保守」</a>を参照してください。
        </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        MySQL 5.6 では、パーティション化されたテーブルのすべてのパーティションに同じ数のサブパーティションが必要であり、テーブルが作成されたあとにサブパーティショニングを変更することはできません。
      </p></div><p>
      テーブルのパーティショニングスキームを変更するために必要なことは、<em class="replaceable"><code>partition_options</code></em> 句付きで <code class="literal">ALTER TABLE</code> ステートメントを使用することだけです。この句の構文は、パーティション化されたテーブルを作成する <code class="literal">CREATE TABLE</code> で使用されるものと同じで、必ずキーワード <code class="literal">PARTITION BY</code> で始まります。次の <code class="literal">CREATE TABLE</code> ステートメントを使用して範囲によってパーティション化されたテーブルがあるとします。
    </p><pre class="programlisting">
CREATE TABLE trb3 (id INT, name VARCHAR(50), purchased DATE)
    PARTITION BY RANGE( YEAR(purchased) ) (
        PARTITION p0 VALUES LESS THAN (1990),
        PARTITION p1 VALUES LESS THAN (1995),
        PARTITION p2 VALUES LESS THAN (2000),
        PARTITION p3 VALUES LESS THAN (2005)
    );
</pre><p>
      このテーブルをキーによるパーティション化でパーティション化し直して、キーをベースとする <code class="literal">id</code> カラム値を使用する 2 つのパーティションに分割するために、次のステートメントを使用できます。
    </p><pre class="programlisting">
ALTER TABLE trb3 PARTITION BY KEY(id) PARTITIONS 2;
</pre><p>
      これは、テーブルを削除してから <code class="literal">CREATE TABLE trb3 PARTITION BY KEY(id) PARTITIONS 2;</code> を使用して再作成する場合と同じ効果を、テーブルの構造に対して持ちます。
    </p><p>
      <code class="literal">ALTER TABLE ... ENGINE = ...</code> は、テーブルによって使用されるストレージエンジンのみを変更し、テーブルのパーティショニングスキームはそのままにします。テーブルのパーティショニングを削除するには、<code class="literal">ALTER TABLE ... REMOVE PARTITIONING</code> を使用します。<a class="xref" href="sql-syntax.html#alter-table" title="13.1.7 ALTER TABLE 構文">セクション13.1.7「ALTER TABLE 構文」</a>を参照してください。
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        <code class="literal">ALTER TABLE</code> ステートメントに使用できるのは、単一の <code class="literal">PARTITION BY</code>、<code class="literal">ADD PARTITION</code>、<code class="literal">DROP PARTITION</code>、<code class="literal">REORGANIZE PARTITION</code>、または <code class="literal">COALESCE PARTITION</code> 句のみです。たとえば、あるパーティションを削除して、テーブルの残りのパーティションを再編成する場合は、2 つの別々の <code class="literal">ALTER TABLE</code> ステートメントでそうする必要があります (<code class="literal">DROP PARTITION</code> を使用するものと <code class="literal">REORGANIZE PARTITIONS</code> を使用するもの)。
      </p></div><p>
      MySQL 5.6 では、<code class="literal">ALTER TABLE ... TRUNCATE PARTITION</code> を使用して、選択した 1 つ以上のパーティションからすべての行を削除できます。
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="partitioning-management-range-list"></a>19.3.1 RANGE および LIST パーティションの管理</h3></div></div></div><a class="indexterm" name="idm139979015181904"></a><a class="indexterm" name="idm139979015179760"></a><a class="indexterm" name="idm139979015177680"></a><a class="indexterm" name="idm139979015175584"></a><p>
        RANGE および LIST パーティションは、パーティションの追加と削除がどのように処理されるかに関してはよく似ています。このため、このセクションでは両方のタイプのパーティショニングの管理について説明します。ハッシュまたはキーによってパーティション化されたテーブルの管理については、<a class="xref" href="partitioning.html#partitioning-management-hash-key" title="19.3.2 HASH および KEY パーティションの管理">セクション19.3.2「HASH および KEY パーティションの管理」</a>を参照してください。<code class="literal">RANGE</code> または <code class="literal">LIST</code> パーティションの削除は追加よりも単純なので、これを最初に説明します。
      </p><p>
        <code class="literal">RANGE</code> または <code class="literal">LIST</code> によってパーティション化されたテーブルからパーティションを削除する操作は、<code class="literal">DROP PARTITION</code> 句付きで <code class="literal">ALTER TABLE</code> ステートメントを使用することで実行できます。非常に基本的な例ですが、次の <code class="literal">CREATE TABLE</code> および <code class="literal">INSERT</code> ステートメントを使用して、範囲によってパーティション化されるテーブルをすでに作成済みで、10 件のレコードを移入しているとします。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE tr (id INT, name VARCHAR(50), purchased DATE)</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION BY RANGE( YEAR(purchased) ) (</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (1990),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (1995),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p2 VALUES LESS THAN (2000),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p3 VALUES LESS THAN (2005)</code></strong>
    -&gt;     <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO tr VALUES</code></strong>
    -&gt;     <strong class="userinput"><code>(1, 'desk organiser', '2003-10-15'),</code></strong>
    -&gt;     <strong class="userinput"><code>(2, 'CD player', '1993-11-05'),</code></strong>
    -&gt;     <strong class="userinput"><code>(3, 'TV set', '1996-03-10'),</code></strong>
    -&gt;     <strong class="userinput"><code>(4, 'bookcase', '1982-01-10'),</code></strong>
    -&gt;     <strong class="userinput"><code>(5, 'exercise bike', '2004-05-09'),</code></strong>
    -&gt;     <strong class="userinput"><code>(6, 'sofa', '1987-06-05'),</code></strong>
    -&gt;     <strong class="userinput"><code>(7, 'popcorn maker', '2001-11-22'),</code></strong>
    -&gt;     <strong class="userinput"><code>(8, 'aquarium', '1992-08-04'),</code></strong>
    -&gt;     <strong class="userinput"><code>(9, 'study desk', '1984-09-16'),</code></strong>
    -&gt;     <strong class="userinput"><code>(10, 'lava lamp', '1998-12-25');</code></strong>
Query OK, 10 rows affected (0.01 sec)
</pre><p>
        パーティション <code class="literal">p2</code> に挿入されているはずの項目を以下のように確認できます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT * FROM tr</code></strong>
    -&gt; <strong class="userinput"><code>WHERE purchased BETWEEN '1995-01-01' AND '1999-12-31';</code></strong>
+------+-----------+------------+
| id   | name      | purchased  |
+------+-----------+------------+
|    3 | TV set    | 1996-03-10 |
|   10 | lava lamp | 1998-12-25 |
+------+-----------+------------+
2 rows in set (0.00 sec)
</pre><p>
        <code class="literal">p2</code> という名前のパーティションを削除するには、次のコマンドを実行します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>ALTER TABLE tr DROP PARTITION p2;</code></strong>
Query OK, 0 rows affected (0.03 sec)
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">NDB</code> ストレージエンジンは <code class="literal">ALTER TABLE ... DROP PARTITION</code> をサポートしません。ただし、この章で説明されている <code class="literal">ALTER TABLE</code> へのほかのパーティショニング関連拡張はサポートしています。
        </p></div><p>
        <span class="emphasis"><em>パーティションを削除すると、そのパーティションに格納されていたすべてのデータも削除される</em></span>ことを覚えておくことは非常に重要です。前の <code class="literal">SELECT</code> クエリーを再実行することで、これが本当であることを確認できます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT * FROM tr WHERE purchased</code></strong>
    -&gt; <strong class="userinput"><code>BETWEEN '1995-01-01' AND '1999-12-31';</code></strong>
Empty set (0.00 sec)
</pre><p>
        このため、テーブルに対して <code class="literal">ALTER TABLE ... DROP PARTITION</code> を実行するには、そのテーブルの <code class="literal">DROP</code> 権限が必要です。
      </p><p>
        テーブル定義およびそのパーティショニングスキームを保持したまま、すべてのパーティションからすべてのデータを削除する場合は、<code class="literal">TRUNCATE TABLE</code> ステートメントを使用してください。(<a class="xref" href="sql-syntax.html#truncate-table" title="13.1.33 TRUNCATE TABLE 構文">セクション13.1.33「TRUNCATE TABLE 構文」</a>を参照してください)。
      </p><p>
        データを失うこと<span class="emphasis"><em>なく</em></span>テーブルのパーティショニングを変更する場合は、代わりに <code class="literal">ALTER TABLE ... REORGANIZE PARTITION</code> を使用してください。<code class="literal">REORGANIZE PARTITION</code> については、後続の説明または<a class="xref" href="sql-syntax.html#alter-table" title="13.1.7 ALTER TABLE 構文">セクション13.1.7「ALTER TABLE 構文」</a>を参照してください。
      </p><p>
        ここで <code class="literal">SHOW CREATE TABLE</code> ステートメントを実行すると、テーブルのパーティショニング構成がどのように変更されたかを確認できます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE tr\G</code></strong>
*************************** 1. row ***************************
       Table: tr
Create Table: CREATE TABLE `tr` (
  `id` int(11) default NULL,
  `name` varchar(50) default NULL,
  `purchased` date default NULL
) ENGINE=MyISAM DEFAULT CHARSET=latin1
PARTITION BY RANGE ( YEAR(purchased) ) (
  PARTITION p0 VALUES LESS THAN (1990) ENGINE = MyISAM,
  PARTITION p1 VALUES LESS THAN (1995) ENGINE = MyISAM,
  PARTITION p3 VALUES LESS THAN (2005) ENGINE = MyISAM
)
1 row in set (0.01 sec)
</pre><p>
        <code class="literal">purchased</code> カラム値が <code class="literal">'1995-01-01'</code> から <code class="literal">'2004-12-31'</code> まで (両端を含む) の新しい行を変更済みテーブルに挿入すると、それらの行はパーティション <code class="literal">p3</code> に格納されます。このことを次のようにして確認できます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>INSERT INTO tr VALUES (11, 'pencil holder', '1995-07-12');</code></strong>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM tr WHERE purchased</code></strong>
    -&gt; <strong class="userinput"><code>BETWEEN '1995-01-01' AND '2004-12-31';</code></strong>
+------+----------------+------------+
| id   | name           | purchased  |
+------+----------------+------------+
|   11 | pencil holder  | 1995-07-12 |
|    1 | desk organiser | 2003-10-15 |
|    5 | exercise bike  | 2004-05-09 |
|    7 | popcorn maker  | 2001-11-22 |
+------+----------------+------------+
4 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE tr DROP PARTITION p3;</code></strong>
Query OK, 0 rows affected (0.03 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM tr WHERE purchased</code></strong>
    -&gt; <strong class="userinput"><code>BETWEEN '1995-01-01' AND '2004-12-31';</code></strong>
Empty set (0.00 sec)
</pre><p>
        <code class="literal">ALTER TABLE ... DROP PARTITION</code> の結果としてテーブルから削除された行数は、同等の <code class="literal">DELETE</code> クエリーとは異なり、サーバーから報告されません。
      </p><p>
        <code class="literal">LIST</code> パーティションを削除する場合は、<code class="literal">RANGE</code> パーティションの削除に使用するものとまったく同じ <code class="literal">ALTER TABLE ... DROP PARTITION</code> 構文を使用します。ただし、この操作が持つ影響について、このテーブルをあとで使用する際に重要な違いが 1 つあります。このテーブルには、削除したパーティションを定義する値リストに含まれていた値を持つ行を挿入できなくなります。(例については、<a class="xref" href="partitioning.html#partitioning-list" title="19.2.2 LIST パーティショニング">セクション19.2.2「LIST パーティショニング」</a>を参照してください)。
      </p><p>
        すでにパーティション化されたテーブルに新しい範囲またはリストパーティションを追加するには、<code class="literal">ALTER TABLE ... ADD PARTITION</code> ステートメントを使用します。<code class="literal">RANGE</code> によってパーティション化されたテーブルの場合は、これを使用して、既存のパーティションのリストの最後に新しい範囲を追加できます。次のように定義された、組織のメンバーシップデータが含まれるパーティション化されたテーブルがあるとします。
      </p><pre class="programlisting">
CREATE TABLE members (
    id INT,
    fname VARCHAR(25),
    lname VARCHAR(25),
    dob DATE
)
PARTITION BY RANGE( YEAR(dob) ) (
    PARTITION p0 VALUES LESS THAN (1970),
    PARTITION p1 VALUES LESS THAN (1980),
    PARTITION p2 VALUES LESS THAN (1990)
);
</pre><p>
        さらに、メンバーの最少年齢は 16 歳であるとします。カレンダーが 2005 年の終わりに近づいて、1990 年に生まれたメンバー (さらに、来年以降はそれよりあとのメンバー) をまもなく受け入れることに気付きます。次のように <code class="literal">members</code> テーブルを変更することで、1990 年から 1999 年までに生まれた新しいメンバーを受け入れることができます。
      </p><pre class="programlisting">
ALTER TABLE members ADD PARTITION (PARTITION p3 VALUES LESS THAN (2000));
</pre><p>
        範囲によってパーティション化されたテーブルで <code class="literal">ADD PARTITION</code> を使用するときは、パーティションリストの上端にのみ新しいパーティションを追加できます。この方法で新しいパーティションを既存のパーティションの間または前に追加しようとすると、次のようにエラーになります。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>ALTER TABLE members</code></strong>
     &gt;     <strong class="userinput"><code>ADD PARTITION (</code></strong>
     &gt;     <strong class="userinput"><code>PARTITION n VALUES LESS THAN (1960));</code></strong>
ERROR 1463 (HY000): VALUES LESS THAN value must be strictly »
   increasing for each partition
</pre><p>
        この問題は、次のように最初のパーティションを 2 つに再編成し、それらの間の範囲を分割することで回避できます。
      </p><pre class="programlisting">
ALTER TABLE members
    REORGANIZE PARTITION p0 INTO (
        PARTITION n0 VALUES LESS THAN (1960),
        PARTITION n1 VALUES LESS THAN (1970)
);
</pre><p>
        <code class="literal">SHOW CREATE TABLE</code> を使用することで、<code class="literal">ALTER TABLE</code> ステートメントによって意図した効果が得られたことを確認できます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE members\G</code></strong>
*************************** 1. row ***************************
       Table: members
Create Table: CREATE TABLE `members` (
  `id` int(11) DEFAULT NULL,
  `fname` varchar(25) DEFAULT NULL,
  `lname` varchar(25) DEFAULT NULL,
  `dob` date DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1
/*!50100 PARTITION BY RANGE ( YEAR(dob))
(PARTITION n0 VALUES LESS THAN (1960) ENGINE = InnoDB,
 PARTITION n1 VALUES LESS THAN (1970) ENGINE = InnoDB,
 PARTITION p1 VALUES LESS THAN (1980) ENGINE = InnoDB,
 PARTITION p2 VALUES LESS THAN (1990) ENGINE = InnoDB,
 PARTITION p3 VALUES LESS THAN (2000) ENGINE = InnoDB) */
1 row in set (0.00 sec)
</pre><p>
        <a class="xref" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1 ALTER TABLE パーティション操作">セクション13.1.7.1「ALTER TABLE パーティション操作」</a>も参照してください。
      </p><p>
        <code class="literal">ALTER TABLE ... ADD PARTITION</code> を使用して、<code class="literal">LIST</code> によってパーティション化されたテーブルに新しいパーティションを追加することもできます。次の <code class="literal">CREATE TABLE</code> ステートメントを使用してテーブル <code class="literal">tt</code> が定義されているとします。
      </p><pre class="programlisting">
CREATE TABLE tt (
    id INT,
    data INT
)
PARTITION BY LIST(data) (
    PARTITION p0 VALUES IN (5, 10, 15),
    PARTITION p1 VALUES IN (6, 12, 18)
);
</pre><p>
        <code class="literal">data</code> カラム値が <code class="literal">7</code>、<code class="literal">14</code>、および <code class="literal">21</code> である行を格納する新しいパーティションを次のように追加できます。
      </p><pre class="programlisting">
ALTER TABLE tt ADD PARTITION (PARTITION p2 VALUES IN (7, 14, 21));
</pre><p>
        既存のパーティションの値リストにすでに含まれている値を含む新しい <code class="literal">LIST</code> パーティションは、追加<span class="emphasis"><em>できません</em></span>。これを試みるとエラーになります。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>ALTER TABLE tt ADD PARTITION </code></strong>
     &gt;     <strong class="userinput"><code>(PARTITION np VALUES IN (4, 8, 12));</code></strong>
ERROR 1465 (HY000): Multiple definition of same constant »
                    in list partitioning
</pre><p>
        <code class="literal">data</code> カラム値が <code class="literal">12</code> である行がパーティション <code class="literal">p1</code> にすでに割り当てられているため、値リストに <code class="literal">12</code> が含まれる新しいパーティションをテーブル <code class="literal">tt</code> に作成することはできません。これを実現するために、<code class="literal">p1</code> を削除し、<code class="literal">np</code> を追加してから、定義を変更した新しい <code class="literal">p1</code> を追加できます。ただし、すでに説明したように、これによって <code class="literal">p1</code> に格納されていたすべてのデータが失われるので、これが実際にやりたいことでないことが多いです。別の解決策になる可能性があるのが、<code class="literal">CREATE TABLE ... SELECT ...</code> を使用して、新しいパーティショニング付きでテーブルのコピーを作成し、データをそこにコピーしてから、古いテーブルを削除して新しいテーブルを名前変更することですが、これは大量のデータを扱うときに非常に時間がかかる可能性があります。高可用性が要求される状況では実行できない可能性もあります。
      </p><p>
        次のように単一 <code class="literal">ALTER TABLE ... ADD PARTITION</code> ステートメントで複数のパーティションを追加できます。
      </p><pre class="programlisting">
CREATE TABLE employees (
  id INT NOT NULL,
  fname VARCHAR(50) NOT NULL,
  lname VARCHAR(50) NOT NULL,
  hired DATE NOT NULL
)
PARTITION BY RANGE( YEAR(hired) ) (
  PARTITION p1 VALUES LESS THAN (1991),
  PARTITION p2 VALUES LESS THAN (1996),
  PARTITION p3 VALUES LESS THAN (2001),
  PARTITION p4 VALUES LESS THAN (2005)
);

ALTER TABLE employees ADD PARTITION (
    PARTITION p5 VALUES LESS THAN (2010),
    PARTITION p6 VALUES LESS THAN MAXVALUE
);
</pre><p>
        ありがたいことに、MySQL のパーティショニング実装は、データを失うことなくパーティショニングを再定義する方法を提供しています。まず、<code class="literal">RANGE</code> パーティショニングを使用するいくつかの簡単な例を見てみましょう。次のように定義された <code class="literal">members</code> テーブルを思い出してください。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE members\G</code></strong>
*************************** 1. row ***************************
       Table: members
Create Table: CREATE TABLE `members` (
  `id` int(11) default NULL,
  `fname` varchar(25) default NULL,
  `lname` varchar(25) default NULL,
  `dob` date default NULL
) ENGINE=MyISAM DEFAULT CHARSET=latin1
PARTITION BY RANGE ( YEAR(dob) ) (
  PARTITION p0 VALUES LESS THAN (1970) ENGINE = MyISAM,
  PARTITION p1 VALUES LESS THAN (1980) ENGINE = MyISAM,
  PARTITION p2 VALUES LESS THAN (1990) ENGINE = MyISAM.
  PARTITION p3 VALUES LESS THAN (2000) ENGINE = MyISAM
)
</pre><p>
        1960 年より前に生まれたメンバーを表すすべての行を別のパーティションに移動するとします。すでに説明したように、これは <code class="literal">ALTER TABLE ... ADD PARTITION</code> を使用して行うことはできません。ただし、<code class="literal">ALTER TABLE</code> への別のパーティション関連拡張を使用して、これを行うことができます。
      </p><pre class="programlisting">
ALTER TABLE members REORGANIZE PARTITION p0 INTO (
    PARTITION s0 VALUES LESS THAN (1960),
    PARTITION s1 VALUES LESS THAN (1970)
);
</pre><p>
        実際には、このコマンドはパーティション <code class="literal">p0</code> を 2 つの新しいパーティション <code class="literal">s0</code> および <code class="literal">s1</code> に分割します。さらに、<code class="literal">p0</code> に格納されていたデータを 2つの <code class="literal">PARTITION ... VALUES ...</code> 句に示されているルールに従って新しいパーティションに移動する結果、<code class="literal">s0</code> には <code class="literal">YEAR(dob)</code> が 1960 より小さいレコードのみが含まれ、<code class="literal">s1</code> には <code class="literal">YEAR(dob)</code> が 1960 以上で 1970 より小さい行が含まれます。
      </p><p>
        <code class="literal">REORGANIZE PARTITION</code> 句を使用して、隣接するパーティションをマージすることもできます。次のように <code class="literal">members</code> テーブルを以前のパーティショニングに戻すことができます。
      </p><pre class="programlisting">
ALTER TABLE members REORGANIZE PARTITION s0,s1 INTO (
    PARTITION p0 VALUES LESS THAN (1970)
);
</pre><p>
        <code class="literal">REORGANIZE PARTITION</code> を使用してパーティションを分割またはマージしてもデータは失われません。上記のステートメントを実行すると、MySQL はパーティション <code class="literal">s0</code> および <code class="literal">s1</code> に格納されていたすべてのレコードをパーティション <code class="literal">p0</code> に移動します。
      </p><p>
        <code class="literal">REORGANIZE PARTITION</code> の一般的な構文を次に示します。
      </p><pre class="programlisting">
ALTER TABLE <em class="replaceable"><code>tbl_name</code></em>
    REORGANIZE PARTITION <em class="replaceable"><code>partition_list</code></em>
    INTO (<em class="replaceable"><code>partition_definitions</code></em>);
</pre><p>
        ここで、<em class="replaceable"><code>tbl_name</code></em> はパーティション化されたテーブルの名前、<em class="replaceable"><code>partition_list</code></em> は変更する 1 つ以上の既存のパーティションの名前のカンマ区切りのリストです。<em class="replaceable"><code>partition_definitions</code></em> は、<code class="literal">CREATE TABLE</code> で使用される <em class="replaceable"><code>partition_definitions</code></em> リスト (<a class="xref" href="sql-syntax.html#create-table" title="13.1.17 CREATE TABLE 構文">セクション13.1.17「CREATE TABLE 構文」</a>を参照してください) と同じ規則に従う、新しいパーティション定義のカンマ区切りのリストです。<code class="literal">REORGANIZE PARTITION</code> を使用するときは、複数のパーティションを 1 つにマージする、または 1 つのパーティションを多数に分割する以外のこともできます。たとえば、次のように <code class="literal">members</code> テーブルの 4 つのパーティションすべてを 2 つに再編成できます。
      </p><pre class="programlisting">
ALTER TABLE members REORGANIZE PARTITION p0,p1,p2,p3 INTO (
    PARTITION m0 VALUES LESS THAN (1980),
    PARTITION m1 VALUES LESS THAN (2000)
);
</pre><p>
        <code class="literal">LIST</code> によってパーティション化されたテーブルで <code class="literal">REORGANIZE PARTITION</code> を使用することもできます。リストによってパーティション化された <code class="literal">tt</code> テーブルに新しいパーティションを追加する操作が、既存のパーティションのいずれかの値リストにすでに存在する値が新しいパーティションに含まれていることが原因で失敗する問題に戻ります。これは、競合しない値のみが含まれるパーティションを追加してから、新しいパーティションと既存のものを再編成して既存のものに格納されていた値が新しいものに移動するようにすることで、対処できます。
      </p><pre class="programlisting">
ALTER TABLE tt ADD PARTITION (PARTITION np VALUES IN (4, 8));
ALTER TABLE tt REORGANIZE PARTITION p1,np INTO (
    PARTITION p1 VALUES IN (6, 18),
    PARTITION np VALUES in (4, 8, 12)
);
</pre><p>
        <code class="literal">RANGE</code> または <code class="literal">LIST</code> によってパーティション化されたテーブルをパーティション化し直すために <code class="literal">ALTER TABLE ... REORGANIZE PARTITION</code> を使用するときに注意すべき、いくつかの重要点を次に示します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            新しいパーティショニングスキームを決定するために使用される <code class="literal">PARTITION</code> 句には、<code class="literal">CREATE TABLE</code> ステートメントで使用されるものと同じ規則が適用されます。
          </p><p>
            もっとも重要なことは、新しいパーティショニングスキームには、重複する範囲 (<code class="literal">RANGE</code> によってパーティション化されたテーブルに適用される) または値のセット (<code class="literal">LIST</code> によってパーティション化されたテーブルを再編成するとき) を指定できないことを覚えておくべきです。
          </p></li><li class="listitem"><p>
            <em class="replaceable"><code>partition_definitions</code></em> リストのパーティションの組み合わせは、<em class="replaceable"><code>partition_list</code></em> に指定されたパーティションの組み合わせの範囲または値セット全体と同じであるべきです。
          </p><p>
            たとえば、このセクションの例として使用されている <code class="literal">members</code> テーブルでは、パーティション <code class="literal">p1</code> および <code class="literal">p2</code> が 1980 年から 1999 年までを範囲としています。このため、これら 2 つのパーティションを再編成する場合は、全体として同じ年範囲を含むべきです。
          </p></li><li class="listitem"><p>
            <code class="literal">RANGE</code> によってパーティション化されたテーブルの場合は、隣接するパーティションのみを再編成できます。範囲パーティションを飛ばすことはできません。
          </p><p>
            たとえば、このセクションの例として使用されている <code class="literal">members</code> テーブルを、<code class="literal">ALTER TABLE members REORGANIZE PARTITION p0,p2 INTO ...</code> で始まるステートメントを使用して再編成することはできません。<code class="literal">p0</code> は 1970 年より前の年を範囲とし、<code class="literal">p2</code> は 1990 年から 1999 年まで (両端を含む) を範囲としていて、この 2 つは隣接するパーティションではないためです。
          </p></li><li class="listitem"><p>
            <code class="literal">REORGANIZE PARTITION</code> を使用して、テーブルのパーティショニングタイプを変更することはできません。つまり、たとえば、<code class="literal">RANGE</code> パーティションを <code class="literal">HASH</code> パーティションに変更することはできません (逆も不可)。このコマンドを使用してパーティショニング式またはカラムを変更することもできません。これらの作業をテーブルを削除および再作成することなく実現するために、<code class="literal">ALTER TABLE ... PARTITION BY ...</code> を使用できます。例:
          </p><pre class="programlisting">
ALTER TABLE members
    PARTITION BY HASH( YEAR(dob) )
    PARTITIONS 8;
</pre></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="partitioning-management-hash-key"></a>19.3.2 HASH および KEY パーティションの管理</h3></div></div></div><a class="indexterm" name="idm139979014998144"></a><a class="indexterm" name="idm139979014996000"></a><a class="indexterm" name="idm139979014993920"></a><a class="indexterm" name="idm139979014991808"></a><p>
        ハッシュまたはキーによってパーティション化されたテーブルは、パーティショニングセットアップで変更に関して互いによく似ていますが、範囲またはリストによってパーティション化されたテーブルとはいくつかの点で異なります。このため、このセクションではハッシュまたはキーによってパーティション化されたテーブルの変更についてのみ取り上げます。範囲またはリストによってパーティション化されたテーブルのパーティションを追加および削除することについては、<a class="xref" href="partitioning.html#partitioning-management-range-list" title="19.3.1 RANGE および LIST パーティションの管理">セクション19.3.1「RANGE および LIST パーティションの管理」</a>を参照してください。
      </p><p>
        <code class="literal">HASH</code> または <code class="literal">KEY</code> によってパーティション化されたテーブルから、<code class="literal">RANGE</code> または <code class="literal">LIST</code> によってパーティション化されたテーブルと同じ方法でパーティションを削除することはできません。ただし、<code class="literal">ALTER TABLE ... COALESCE PARTITION</code> ステートメントを使用して <code class="literal">HASH</code> または <code class="literal">KEY</code> のパーティションをマージすることはできます。クライアントに関するデータが含まれている、12 個のパーティションに分割されたテーブルがあるとします。<code class="literal">clients</code> テーブルは次のように定義されています。
      </p><pre class="programlisting">
CREATE TABLE clients (
    id INT,
    fname VARCHAR(30),
    lname VARCHAR(30),
    signed DATE
)
PARTITION BY HASH( MONTH(signed) )
PARTITIONS 12;
</pre><p>
        パーティションの数を 12 個から 8 個に減らす場合は、次の <code class="literal">ALTER TABLE</code> コマンドを実行します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>ALTER TABLE clients COALESCE PARTITION 4;</code></strong>
Query OK, 0 rows affected (0.02 sec)
</pre><p>
        <code class="literal">COALESCE</code> は、<code class="literal">HASH</code>、<code class="literal">KEY</code>、<code class="literal">LINEAR HASH</code>、または <code class="literal">LINEAR KEY</code> によってパーティション化されたテーブルで同等に適切に動作します。次の例は前の例と似ていますが、テーブルが <code class="literal">LINEAR KEY</code> によってパーティション化されている点のみが異なります。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE clients_lk (</code></strong>
    -&gt;     <strong class="userinput"><code>id INT,</code></strong>
    -&gt;     <strong class="userinput"><code>fname VARCHAR(30),</code></strong>
    -&gt;     <strong class="userinput"><code>lname VARCHAR(30),</code></strong>
    -&gt;     <strong class="userinput"><code>signed DATE</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY LINEAR KEY(signed)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITIONS 12;</code></strong>
Query OK, 0 rows affected (0.03 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE clients_lk COALESCE PARTITION 4;</code></strong>
Query OK, 0 rows affected (0.06 sec)
Records: 0  Duplicates: 0  Warnings: 0
</pre><p>
        <code class="literal">COALESCE PARTITION</code> のあとの数値は、残りにマージするパーティションの数です。つまり、テーブルから削除するパーティションの数です。
      </p><p>
        テーブルに含まれているものより多くのパーティションを削除しようとすると、次のようなエラーになります。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>ALTER TABLE clients COALESCE PARTITION 18;</code></strong>
ERROR 1478 (HY000): Cannot remove all partitions, use DROP TABLE instead
</pre><p>
        <code class="literal">clients</code> テーブルのパーティションの数を 12 個から 18 個に増やす場合は、次のように <code class="literal">ALTER TABLE ... ADD PARTITION</code> を使用します。
      </p><pre class="programlisting">
ALTER TABLE clients ADD PARTITION PARTITIONS 6;
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="partitioning-management-exchange"></a>19.3.3 パーティションとサブパーティションをテーブルと交換する</h3></div></div></div><p>
        MySQL 5.6 では、<code class="literal">ALTER TABLE <em class="replaceable"><code>pt</code></em> EXCHANGE PARTITION <em class="replaceable"><code>p</code></em> WITH TABLE <em class="replaceable"><code>nt</code></em></code> を使用して、テーブルパーティションまたはサブパーティションをテーブルと交換できます。ここで、<em class="replaceable"><code>pt</code></em> はパーティション化されたテーブル、<em class="replaceable"><code>p</code></em> はパーティション化されていないテーブル <em class="replaceable"><code>nt</code></em> と交換する <em class="replaceable"><code>pt</code></em> のパーティションまたはサブパーティションです (次の記述が true である場合)。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            テーブル <em class="replaceable"><code>nt</code></em> 自体はパーティション化されていない。
          </p></li><li class="listitem"><p>
            テーブル <em class="replaceable"><code>nt</code></em> は一時テーブルではない。
          </p></li><li class="listitem"><p>
            テーブル <em class="replaceable"><code>pt</code></em> および <em class="replaceable"><code>nt</code></em> の構造はそれ以外の点で同じである。
          </p></li><li class="listitem"><p>
            テーブル <code class="literal">nt</code> は外部キー参照を含まず、ほかのどのテーブルも <code class="literal">nt</code> を参照する外部キーを持たない。
          </p></li><li class="listitem"><p>
            <em class="replaceable"><code>nt</code></em> 内に <em class="replaceable"><code>p</code></em> のパーティション定義の境界の外に存在する行がない。
          </p></li></ol></div><p>
        <code class="literal">ALTER TABLE</code> ステートメントに通常必要な <code class="literal">ALTER</code>、<code class="literal">INSERT</code>、および <code class="literal">CREATE</code> 権限に加えて、<code class="literal">ALTER TABLE ... EXCHANGE PARTITION</code> を実行するための <code class="literal">DROP</code> 権限が必要です。
      </p><p>
        <code class="literal">ALTER TABLE ... EXCHANGE PARTITION</code> の次の影響も考慮してください。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">ALTER TABLE ... EXCHANGE PARTITION</code> を実行しても、パーティション化されたテーブルまたは交換されるテーブルに対するトリガーは呼び出されません。
          </p></li><li class="listitem"><p>
            交換されるテーブル内の <code class="literal">AUTO_INCREMENT</code> カラムがリセットされます。
          </p></li><li class="listitem"><p>
            <code class="literal">IGNORE</code> キーワードは、<code class="literal">ALTER TABLE ... EXCHANGE PARTITION</code> と一緒に使用された場合、効果を持つません。
          </p></li></ul></div><p>
        <code class="literal">ALTER TABLE ... EXCHANGE PARTITION</code> ステートメントの完全な構文を次に示します。ここで、<em class="replaceable"><code>pt</code></em> はパーティション化されたテーブル、<em class="replaceable"><code>p</code></em> は交換されるパーティションまたはサブパーティション、<em class="replaceable"><code>nt</code></em> は <em class="replaceable"><code>p</code></em> と交換されるパーティション化されていないテーブルです。
      </p><pre class="programlisting">
ALTER TABLE <em class="replaceable"><code>pt</code></em> 
    EXCHANGE PARTITION <em class="replaceable"><code>p</code></em> 
    WITH TABLE <em class="replaceable"><code>nt</code></em>;
</pre><p>
        単一 <code class="literal">ALTER TABLE EXCHANGE PARTITION</code> ステートメントでは、1 つのパーティションまたはサブパーティションのみを 1 つのパーティション化されていないテーブルのみと交換できます。複数のパーティションまたはサブパーティションを交換するには、複数の <code class="literal">ALTER TABLE EXCHANGE PARTITION</code> ステートメントを使用してください。<code class="literal">EXCHANGE PARTITION</code> は、ほかの <code class="literal">ALTER TABLE</code> オプションと組み合わせることはできません。パーティション化されたテーブルによって使用されるパーティショニングおよび (該当する場合) サブパーティショニングには、MySQL 5.6 でサポートされる任意のタイプを選択できます。
      </p><h4><a name="idm139979014914208"></a>パーティションをパーティション化されていないテーブルと交換する</h4><p>
        次の SQL ステートメントを使用して、パーティション化されたテーブル <code class="literal">e</code> が作成および移入されているとします。
      </p><pre class="programlisting">
CREATE TABLE e (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30)
)
    PARTITION BY RANGE (id) (
        PARTITION p0 VALUES LESS THAN (50),
        PARTITION p1 VALUES LESS THAN (100),
        PARTITION p2 VALUES LESS THAN (150),
        PARTITION p3 VALUES LESS THAN (MAXVALUE)
);

INSERT INTO e VALUES 
    (1669, "Jim", "Smith"),
    (337, "Mary", "Jones"),
    (16, "Frank", "White"),
    (2005, "Linda", "Black");
</pre><p>
        ここで、<code class="literal">e2</code> という名前の、<code class="literal">e</code> のパーティション化されていないコピーを作成します。これは、<span class="command"><strong>mysql</strong></span> クライアントを使用して次のように行うことができます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE e2 LIKE e;</code></strong>
Query OK, 0 rows affected (1.34 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE e2 REMOVE PARTITIONING;</code></strong>
Query OK, 0 rows affected (0.90 sec)
Records: 0  Duplicates: 0  Warnings: 0
</pre><p>
        テーブル <code class="literal">e</code> のどのパーティションに行が含まれるかは、次のように <code class="literal">INFORMATION_SCHEMA.PARTITIONS</code> テーブルを照会することで確認できます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT PARTITION_NAME, TABLE_ROWS</code></strong>
    -&gt;     <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE TABLE_NAME = 'e';</code></strong>
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          1 |
| p1             |          0 |
| p2             |          0 |
| p3             |          3 |
+----------------+------------+
4 rows in set (0.00 sec)
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          パーティション化された <code class="literal">InnoDB</code> テーブルの場合、<code class="literal">INFORMATION_SCHEMA.PARTITIONS</code> テーブルの <code class="literal">TABLE_ROWS</code> カラムに示される行数は、SQL 最適化で使用される見積もり値であり、常に正確とはかぎりません。
        </p></div><p>
        テーブル <code class="literal">e</code> 内のパーティション <code class="literal">p0</code> をテーブル<code class="literal">e2</code> と交換するには、次のような <code class="literal">ALTER TABLE</code> ステートメントを使用できます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>ALTER TABLE e EXCHANGE PARTITION p0 WITH TABLE e2;</code></strong>
Query OK, 0 rows affected (0.28 sec)
</pre><p>
        より正確に言うと、ここで発行したステートメントによって、パーティションで見つかる行がテーブルで見つかるものと交換されます。これがどのように行われたかは、前のように <code class="literal">INFORMATION_SCHEMA.PARTITIONS</code> テーブルを照会することで観察できます。パーティション <code class="literal">p0</code> で以前は見つかったテーブル行が存在しなくなっています。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT PARTITION_NAME, TABLE_ROWS</code></strong>
    -&gt;     <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE TABLE_NAME = 'e';</code></strong>
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          0 |
| p1             |          0 |
| p2             |          0 |
| p3             |          3 |
+----------------+------------+
4 rows in set (0.00 sec)
</pre><p>
        テーブル <code class="literal">e2</code> を照会すると、<span class="quote">「<span class="quote">見つからない</span>」</span>行がそこで見つかります。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT * FROM e2;</code></strong>
+----+-------+-------+
| id | fname | lname |
+----+-------+-------+
| 16 | Frank | White |
+----+-------+-------+
1 row in set (0.00 sec)
</pre><p>
        パーティションと交換されるテーブルは、必ずしも空である必要はありません。これを実証するために、まず新しい行をテーブル <code class="literal">e</code> に挿入してから、この行がパーティション <code class="literal">p0</code> に格納されていることを確認します (50 より小さい <code class="literal">id</code> カラム値を選択し、これをあとで <code class="literal">PARTITIONS</code> テーブルを照会することで確認します)。
      </p><pre class="programlisting">                                                            
mysql&gt; <strong class="userinput"><code>INSERT INTO e VALUES (41, "Michael", "Green");</code></strong>              
Query OK, 1 row affected (0.05 sec)                                

mysql&gt; <strong class="userinput"><code>SELECT PARTITION_NAME, TABLE_ROWS</code></strong> 
    -&gt;     <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong> 
    -&gt;     <strong class="userinput"><code>WHERE TABLE_NAME = 'e';</code></strong>              
+----------------+------------+               
| PARTITION_NAME | TABLE_ROWS |               
+----------------+------------+               
| p0             |          1 |               
| p1             |          0 |               
| p2             |          0 |               
| p3             |          3 |               
+----------------+------------+               
4 rows in set (0.00 sec)          
</pre><p>
        ここで、前と同じ <code class="literal">ALTER TABLE</code> ステートメントを使用して、ふたたびパーティション <code class="literal">p0</code> をテーブル <code class="literal">e2</code> と交換します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>ALTER TABLE e EXCHANGE PARTITION p0 WITH TABLE e2;</code></strong>
Query OK, 0 rows affected (0.28 sec)
</pre><p>
        次のクエリーの出力は、<code class="literal">ALTER TABLE</code> ステートメントを発行する前に、パーティション <code class="literal">p0</code> に格納されていたテーブル行およびテーブル <code class="literal">e2</code> に格納されていたテーブル行の配置が切り替わったことを示しています。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT * FROM e;</code></strong>
+------+-------+-------+
| id   | fname | lname |
+------+-------+-------+
|   16 | Frank | White |
| 1669 | Jim   | Smith |
|  337 | Mary  | Jones |
| 2005 | Linda | Black |
+------+-------+-------+
4 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT PARTITION_NAME, TABLE_ROWS</code></strong>
    -&gt;     <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE TABLE_NAME = 'e';</code></strong>
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          1 |
| p1             |          0 |
| p2             |          0 |
| p3             |          3 |
+----------------+------------+
4 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM e2;</code></strong>
+----+---------+-------+
| id | fname   | lname |
+----+---------+-------+
| 41 | Michael | Green |
+----+---------+-------+
1 row in set (0.00 sec)
</pre><h4><a name="idm139979014859584"></a>一致しない行</h4><p>
        <code class="literal">ALTER TABLE ... EXCHANGE PARTITION</code> ステートメントを発行する前にパーティション化されていないテーブルで見つかる行は、それらがターゲットパーティションに格納されるために必要な条件を満たしている必要があり、そうでない場合はステートメントが失敗することを覚えておいてください。これがどのように発生するかを確認するために、まずテーブル<code class="literal">e</code> のパーティション <code class="literal">p0</code> のパーティション定義の境界外の行を、<code class="literal">e2</code> に挿入します。たとえば、<code class="literal">id</code> カラム値が大きすぎる行を挿入してから、テーブルをパーティションとふたたび交換してみてください。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>INSERT INTO e2 VALUES (51, "Ellen", "McDonald");</code></strong>
Query OK, 1 row affected (0.08 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE e EXCHANGE PARTITION p0 WITH TABLE e2;</code></strong>
<span class="errortext">ERROR 1707 (HY000): Found row that does not match the partition</span>
</pre><p>
        <code class="literal">IGNORE</code> キーワードは受け入れられますが、次に示すように <code class="literal">EXCHANGE PARTITION</code> で使用されるときは効果がありません。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>ALTER IGNORE TABLE e EXCHANGE PARTITION p0 WITH TABLE e2;</code></strong>
<span class="errortext">ERROR 1707 (HY000): Found row that does not match the partition</span>
</pre><h4><a name="idm139979014846640"></a>サブパーティションをパーティション化されていないテーブルと交換する</h4><p>
        <code class="literal">ALTER TABLE ... EXCHANGE PARTITION</code> ステートメントを使用して、サブパーティション化されたテーブルのサブパーティション (<a class="xref" href="partitioning.html#partitioning-subpartitions" title="19.2.6 サブパーティショニング">セクション19.2.6「サブパーティショニング」</a>を参照してください) をパーティション化されていないテーブルと交換することもできます。次の例では、まず <code class="literal">RANGE</code> によってパーティション化され、<code class="literal">KEY</code> によってサブパーティション化されたテーブル <code class="literal">es</code> を作成し、テーブル <code class="literal">e</code> と同様にこのテーブルに移入してから、このテーブルの空のパーティション化されていないコピー <code class="literal">es2</code> を作成します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE es (</code></strong>
    -&gt;     <strong class="userinput"><code>id INT NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>fname VARCHAR(30),</code></strong>
    -&gt;     <strong class="userinput"><code>lname VARCHAR(30)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION BY RANGE (id)</code></strong>
    -&gt;     <strong class="userinput"><code>SUBPARTITION BY KEY (lname)</code></strong>
    -&gt;     <strong class="userinput"><code>SUBPARTITIONS 2 (</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (50),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (100),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p2 VALUES LESS THAN (150),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p3 VALUES LESS THAN (MAXVALUE)</code></strong>
    -&gt;     <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (2.76 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO es VALUES</code></strong>
    -&gt;     <strong class="userinput"><code>(1669, "Jim", "Smith"),</code></strong>
    -&gt;     <strong class="userinput"><code>(337, "Mary", "Jones"),</code></strong>
    -&gt;     <strong class="userinput"><code>(16, "Frank", "White"),</code></strong>
    -&gt;     <strong class="userinput"><code>(2005, "Linda", "Black");</code></strong>
Query OK, 4 rows affected (0.04 sec)
Records: 4  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>CREATE TABLE es2 LIKE es;</code></strong>
Query OK, 0 rows affected (1.27 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE es2 REMOVE PARTITIONING;</code></strong>
Query OK, 0 rows affected (0.70 sec)
Records: 0  Duplicates: 0  Warnings: 0
</pre><p>
        テーブル <code class="literal">es</code> を作成するときにサブパーティションの名前を明示的に指定しなかったけれども、<code class="literal">PARTITIONS</code> テーブルから選択するときに、次のように <code class="literal">INFORMATION_SCHEMA</code> からそのテーブルの <code class="literal">SUBPARTITION_NAME</code> を取り込むことで、それらに生成された名前を取得できます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT PARTITION_NAME, SUBPARTITION_NAME, TABLE_ROWS</code></strong>
    -&gt;     <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE TABLE_NAME = 'es';</code></strong>
+----------------+-------------------+------------+
| PARTITION_NAME | SUBPARTITION_NAME | TABLE_ROWS |
+----------------+-------------------+------------+
| p0             | p0sp0             |          1 |
| p0             | p0sp1             |          0 |
| p1             | p1sp0             |          0 |
| p1             | p1sp1             |          0 |
| p2             | p2sp0             |          0 |
| p2             | p2sp1             |          0 |
| p3             | p3sp0             |          3 |
| p3             | p3sp1             |          0 |
+----------------+-------------------+------------+
8 rows in set (0.00 sec)
</pre><p>
        次の <code class="literal">ALTER TABLE</code> ステートメントは、テーブル <code class="literal">es</code> のサブパーティション <code class="literal">p3sp0</code> をパーティション化されていないテーブル <code class="literal">es2</code> と交換します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>ALTER TABLE es EXCHANGE PARTITION p3sp0 WITH TABLE es2;</code></strong>
Query OK, 0 rows affected (0.29 sec)
</pre><p>
        次のクエリーを発行することで、それらの行が交換されたことを確認できます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT PARTITION_NAME, SUBPARTITION_NAME, TABLE_ROWS</code></strong>
    -&gt;     <strong class="userinput"><code>FROM INFORMATION_SCHEMA.PARTITIONS</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE TABLE_NAME = 'es';</code></strong>
+----------------+-------------------+------------+
| PARTITION_NAME | SUBPARTITION_NAME | TABLE_ROWS |
+----------------+-------------------+------------+
| p0             | p0sp0             |          1 |
| p0             | p0sp1             |          0 |
| p1             | p1sp0             |          0 |
| p1             | p1sp1             |          0 |
| p2             | p2sp0             |          0 |
| p2             | p2sp1             |          0 |
| p3             | p3sp0             |          0 |
| p3             | p3sp1             |          0 |
+----------------+-------------------+------------+
8 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM es2;</code></strong>
+------+-------+-------+
| id   | fname | lname |
+------+-------+-------+
| 1669 | Jim   | Smith |
|  337 | Mary  | Jones |
| 2005 | Linda | Black |
+------+-------+-------+
3 rows in set (0.00 sec)
</pre><p>
        テーブルがサブパーティション化されている場合、次に示すように、パーティション化されていないテーブルと交換できるのは、テーブルのパーティション全体ではなくサブパーティションのみです。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>ALTER TABLE es EXCHANGE PARTITION p3 WITH TABLE es2;</code></strong>
<span class="errortext">ERROR 1704 (HY000): Subpartitioned table, use subpartition instead of partition</span>
</pre><p>
        MySQL によって使用されるテーブル構造の比較は非常に厳密です。カラムの数、順序、名前、および型、さらにパーティション化されたテーブルとパーティション化されていないテーブルのインデックスが、正確に一致する必要があります。また、両方のテーブルが同じストレージエンジンを使用している必要があります。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE es3 LIKE e;</code></strong>
Query OK, 0 rows affected (1.31 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE es3 REMOVE PARTITIONING;</code></strong>
Query OK, 0 rows affected (0.53 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE es3\G</code></strong>
*************************** 1. row ***************************
       Table: es3
Create Table: CREATE TABLE `es3` (
  `id` int(11) NOT NULL,
  `fname` varchar(30) DEFAULT NULL,
  `lname` varchar(30) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>ALTER TABLE es3 ENGINE = MyISAM;</code></strong>
Query OK, 0 rows affected (0.15 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>ALTER TABLE es EXCHANGE PARTITION p3sp0 WITH TABLE es3;</code></strong>
<span class="errortext">ERROR 1497 (HY000): The mix of handlers in the partitions is not allowed in this version of MySQL</span>
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="partitioning-maintenance"></a>19.3.4 パーティションの保守</h3></div></div></div><a class="indexterm" name="idm139979014793648"></a><a class="indexterm" name="idm139979014791504"></a><a class="indexterm" name="idm139979014789472"></a><a class="indexterm" name="idm139979014787440"></a><a class="indexterm" name="idm139979014785408"></a><a class="indexterm" name="idm139979014783344"></a><a class="indexterm" name="idm139979014781280"></a><a class="indexterm" name="idm139979014779216"></a><p>
        いくつかのテーブルおよびパーティション保守タスクは、MySQL 5.6 のパーティション化されたテーブルでそのような目的を実現するための SQL ステートメントを使用して実行できます。
      </p><p>
        パーティション化されたテーブルのテーブル保守は、パーティション化されたテーブルでサポートされる <code class="literal">CHECK TABLE</code>、<code class="literal">OPTIMIZE TABLE</code>、<code class="literal">ANALYZE TABLE</code>、および <code class="literal">REPAIR TABLE</code> ステートメントを使用して実現できます。
      </p><p>
        次のリストで説明しているように、<code class="literal">ALTER TABLE</code> へのいくつかの拡張を使用して、1 つ以上のパーティションに対してこのタイプの操作を直接実行できます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>パーティションの再構築 </b>
              パーティションを再構築します。これは、パーティションに格納されているすべてのレコードを削除してからそれらを再度挿入することと同じ効果があります。これはデフラグに役立つことがあります。
            </p><p>
            例:
          </p><pre class="programlisting">
ALTER TABLE t1 REBUILD PARTITION p0, p1;
</pre></li><li class="listitem"><p><b>パーティションの最適化 </b>
              パーティションから多数の行を削除した場合、または可変長行を持つ (つまり、<code class="literal">VARCHAR</code>、<code class="literal">BLOB</code>、または <code class="literal">TEXT</code> カラムを持つ) パーティション化されたテーブルに多くの変更を行なった場合は、<code class="literal">ALTER TABLE ... OPTIMIZE PARTITION</code> を使用して、未使用領域を解放したりパーティションデータファイルをデフラグしたりできます。
            </p><p>
            例:
          </p><pre class="programlisting">
ALTER TABLE t1 OPTIMIZE PARTITION p0, p1;
</pre><p>
            指定されたパーティションに <code class="literal">OPTIMIZE PARTITION</code> を使用することは、そのパーティションに <code class="literal">CHECK PARTITION</code>、<code class="literal">ANALYZE PARTITION</code>、および <code class="literal">REPAIR PARTITION</code> を実行することと同等です。
          </p><p>
            一部の MySQL ストレージエンジン (<code class="literal">InnoDB</code> を含む) は、パーティションごとの最適化をサポートしません。これらの場合は、<code class="literal">ALTER TABLE ... OPTIMIZE PARTITION</code> がテーブル全体を再構築されます。MySQL 5.6.9 以降では、そのようなテーブルでこのステートメントを実行すると、テーブル全体が再構築および分析され、該当する警告が発行されます (Bug #11751825、Bug #42822)。この問題を回避するには、代わりに <code class="literal">ALTER TABLE ... REBUILD PARTITION</code> および <code class="literal">ALTER TABLE ... ANALYZE PARTITION</code> を使用してください。
          </p></li><li class="listitem"><p><b>パーティションの分析 </b>
              これは、パーティションのキー分布を読み取って格納します。
            </p><p>
            例:
          </p><pre class="programlisting">
ALTER TABLE t1 ANALYZE PARTITION p3;
</pre></li><li class="listitem"><p><b>パーティションの修復 </b>
              これは、破損したパーティションを修復します。
            </p><p>
            例:
          </p><pre class="programlisting">
ALTER TABLE t1 REPAIR PARTITION p0,p1;
</pre></li><li class="listitem"><p><b>パーティションのチェック </b>
              パーティション化されていないテーブルで <code class="literal">CHECK TABLE</code> を使用できるのとほぼ同様に、パーティションのエラーをチェックできます。
            </p><p>
            例:
          </p><pre class="programlisting">
ALTER TABLE trb3 CHECK PARTITION p1;
</pre><p>
            このコマンドは、テーブル <code class="literal">t1</code> のパーティション <code class="literal">p1</code> のデータまたはインデックスが破損しているかどうかを通知します。その場合は、<code class="literal">ALTER TABLE ... REPAIR PARTITION</code> を使用してパーティションを修復してください。
          </p></li></ul></div><p>
        上記のリストの各ステートメントでは、パーティション名のリストの代わりにキーワード <code class="literal">ALL</code> もサポートされます。<code class="literal">ALL</code> を使用すると、テーブル内のすべてのパーティションにステートメントが作用します。
      </p><p>
        パーティション化されたテーブルでは <span class="command"><strong>mysqlcheck</strong></span> および <span class="command"><strong>myisamchk</strong></span> の使用はサポートされません。
      </p><p>
        MySQL 5.6 では、<code class="literal">ALTER TABLE ... TRUNCATE PARTITION</code> を使用してパーティションを切り捨てることもできます。このステートメントは、<code class="literal">TRUNCATE TABLE</code> がテーブルからすべての行を削除するのとほぼ同様に、1 つ以上のパーティションからすべての行を削除するために使用できます。
      </p><p>
        <code class="literal">ALTER TABLE ... TRUNCATE PARTITION ALL</code> はテーブル内のすべてのパーティションを切り捨てます。
      </p><p>
        <code class="literal">ANALYZE</code>、<code class="literal">CHECK</code>、<code class="literal">OPTIMIZE</code>、<code class="literal">REBUILD</code>、<code class="literal">REPAIR</code>、および <code class="literal">TRUNCATE</code> 操作は、サブパーティションではサポートされません。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="partitioning-info"></a>19.3.5 パーティションに関する情報を取得する</h3></div></div></div><a class="indexterm" name="idm139979014720768"></a><a class="indexterm" name="idm139979014719264"></a><a class="indexterm" name="idm139979014717824"></a><a class="indexterm" name="idm139979014716368"></a><p>
        このセクションでは、既存のパーティションに関する情報を取得する方法 (いくつかの方法が可能) について説明します。そのような情報を取得する方法には次のものが含まれます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">SHOW CREATE TABLE</code> ステートメントを使用して、パーティション化されたテーブルの作成に使用されたパーティショニング句を表示する。
          </p></li><li class="listitem"><p>
            <code class="literal">SHOW TABLE STATUS</code> ステートメントを使用して、テーブルがパーティション化されているかどうかを判別する。
          </p></li><li class="listitem"><p>
            <code class="literal">INFORMATION_SCHEMA.PARTITIONS</code> テーブルを照会する。
          </p></li><li class="listitem"><p>
            <code class="literal">EXPLAIN PARTITIONS SELECT</code> ステートメントを使用して、指定された <code class="literal">SELECT</code> によってどのパーティションが使用されているかを確認する。
          </p></li></ul></div><p>
        この章のほかの場所でも説明しているように、<code class="literal">SHOW CREATE TABLE</code> の出力にはパーティション化されたテーブルの作成に使用された <code class="literal">PARTITION BY</code> 句が含まれます。例:
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE trb3\G</code></strong>
*************************** 1. row ***************************
       Table: trb3
Create Table: CREATE TABLE `trb3` (
  `id` int(11) default NULL,
  `name` varchar(50) default NULL,
  `purchased` date default NULL
) ENGINE=MyISAM DEFAULT CHARSET=latin1
PARTITION BY RANGE (YEAR(purchased)) (
  PARTITION p0 VALUES LESS THAN (1990) ENGINE = MyISAM,
  PARTITION p1 VALUES LESS THAN (1995) ENGINE = MyISAM,
  PARTITION p2 VALUES LESS THAN (2000) ENGINE = MyISAM,
  PARTITION p3 VALUES LESS THAN (2005) ENGINE = MyISAM
)
1 row in set (0.00 sec)
</pre><p>
        パーティション化されたテーブルに対する <code class="literal">SHOW TABLE STATUS</code> の出力は、<code class="literal">Create_options</code> カラムに文字列 <code class="literal">partitioned</code> が含まれることを除いて、パーティション化されていないテーブルの場合と同じです。<code class="literal">Engine</code> カラムには、テーブルのすべてのパーティションによって使用されるストレージエンジンの名前が含まれます。(このステートメントについての詳細は、<a class="xref" href="sql-syntax.html#show-table-status" title="13.7.5.37 SHOW TABLE STATUS 構文">セクション13.7.5.37「SHOW TABLE STATUS 構文」</a>を参照してください)。
      </p><p>
        パーティションに関する情報は、<code class="literal">PARTITIONS</code> テーブルを含む <code class="literal">INFORMATION_SCHEMA</code> からも取得できます。<a class="xref" href="information-schema.html#partitions-table" title="21.13 INFORMATION_SCHEMA PARTITIONS テーブル">セクション21.13「INFORMATION_SCHEMA PARTITIONS テーブル」</a>を参照してください。
      </p><a class="indexterm" name="idm139979014692144"></a><a class="indexterm" name="idm139979014690000"></a><p>
        指定された <code class="literal">SELECT</code> クエリーでパーティション化されたテーブルのどのパーティションが使用されるかは、<code class="literal">EXPLAIN PARTITIONS</code> を使用して判別できます。<code class="literal">PARTITIONS</code> キーワードは、<code class="literal">partitions</code> カラム (どのパーティションからのレコードがクエリーで照合されるかをリストする) を <code class="literal">EXPLAIN</code> の出力に追加します。
      </p><p>
        テーブル <code class="literal">trb1</code> が次のように作成されて移入されているとします。
      </p><pre class="programlisting">
CREATE TABLE trb1 (id INT, name VARCHAR(50), purchased DATE)
    PARTITION BY RANGE(id)
    (
        PARTITION p0 VALUES LESS THAN (3),
        PARTITION p1 VALUES LESS THAN (7),
        PARTITION p2 VALUES LESS THAN (9),
        PARTITION p3 VALUES LESS THAN (11)
    );

INSERT INTO trb1 VALUES
    (1, 'desk organiser', '2003-10-15'),
    (2, 'CD player', '1993-11-05'),
    (3, 'TV set', '1996-03-10'),
    (4, 'bookcase', '1982-01-10'),
    (5, 'exercise bike', '2004-05-09'),
    (6, 'sofa', '1987-06-05'),
    (7, 'popcorn maker', '2001-11-22'),
    (8, 'aquarium', '1992-08-04'),
    (9, 'study desk', '1984-09-16'),
    (10, 'lava lamp', '1998-12-25');
</pre><p>
        <code class="literal">SELECT * FROM trb1;</code> などのクエリーでどのパーティションが使用されるかを次のように確認できます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>EXPLAIN PARTITIONS SELECT * FROM trb1\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: trb1
   partitions: p0,p1,p2,p3
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 10
        Extra: Using filesort
</pre><p>
        この場合、4 つのパーティションがすべて検索されます。ただし、次のようにパーティショニングキーを使用する制限条件をクエリーに追加すると、一致する値が含まれているパーティションのみがスキャンされることがわかります。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>EXPLAIN PARTITIONS SELECT * FROM trb1 WHERE id &lt; 5\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: trb1
   partitions: p0,p1
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 10
        Extra: Using where
</pre><p>
        <code class="literal">EXPLAIN PARTITIONS</code> では、普通の <code class="literal">EXPLAIN SELECT</code> ステートメントと同様に、使用されているキーおよび使用可能なキーに関する情報が表示されます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>ALTER TABLE trb1 ADD PRIMARY KEY (id);</code></strong>
Query OK, 10 rows affected (0.03 sec)
Records: 10  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>EXPLAIN PARTITIONS SELECT * FROM trb1 WHERE id &lt; 5\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: trb1
   partitions: p0,p1
         type: range
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 4
          ref: NULL
         rows: 7
        Extra: Using where
</pre><p>
        <code class="literal">EXPLAIN PARTITIONS</code> に関する次の制約および制限に注目してください。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">EXTENDED</code> および <code class="literal">PARTITIONS</code> キーワードは、同一 <code class="literal">EXPLAIN ... SELECT</code> ステートメント内で一緒に使用できません。そうしようとすると構文エラーになります。
          </p></li><li class="listitem"><p>
            クエリーを検査するためにパーティション化されていないテーブルで <code class="literal">EXPLAIN PARTITIONS</code> を使用すると、エラーは発生しませんが、<code class="literal">partitions</code> カラムの値は常に <code class="literal">NULL</code> となります。
          </p></li></ul></div><p>
        <code class="literal">EXPLAIN PARTITIONS</code> 出力の <code class="literal">rows</code> カラムには、テーブルの合計行数が表示されます。
      </p><p>
        <a class="xref" href="sql-syntax.html#explain" title="13.8.2 EXPLAIN 構文">セクション13.8.2「EXPLAIN 構文」</a>も参照してください。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="partitioning-pruning"></a>19.4 パーティションプルーニング</h2></div></div></div><a class="indexterm" name="idm139979014653856"></a><a class="indexterm" name="idm139979014652400"></a><p>
      このセクションでは、<em class="firstterm">パーティションプルーニング</em>と呼ばれる最適化について説明します。パーティションプルーニングの背後の中心概念は比較的単純で、<span class="quote">「<span class="quote">一致する値がないパーティションはスキャンしない</span>」</span>と表現できます。次のステートメントによって定義されたパーティション化されたテーブル <code class="literal">t1</code> があるとします。
    </p><pre class="programlisting">
CREATE TABLE t1 (
    fname VARCHAR(50) NOT NULL,
    lname VARCHAR(50) NOT NULL,
    region_code TINYINT UNSIGNED NOT NULL,
    dob DATE NOT NULL
)
PARTITION BY RANGE( region_code ) (
    PARTITION p0 VALUES LESS THAN (64),
    PARTITION p1 VALUES LESS THAN (128),
    PARTITION p2 VALUES LESS THAN (192),
    PARTITION p3 VALUES LESS THAN MAXVALUE
);
</pre><p>
      次のような <code class="literal">SELECT</code> ステートメントから結果を取得するとします。
    </p><pre class="programlisting">
SELECT fname, lname, region_code, dob
    FROM t1
    WHERE region_code &gt; 125 AND region_code &lt; 130;
</pre><p>
      返すべき行がパーティション <code class="literal">p0</code> にも <code class="literal">p3</code> にもないことは簡単にわかります。つまり、パーティション <code class="literal">p1</code> および <code class="literal">p2</code> のみを検索して一致する行を見つける必要があります。そうすることにより、一致する行を検索するために消費する時間と労力が、テーブル内のすべてのパーティションのスキャンに必要なものより少なくて済みます。必要のないパーティションをこのように<span class="quote">「<span class="quote">省く</span>」</span>ことを<em class="firstterm">プルーニング</em>といいます。オプティマイザがこのクエリーの実行でパーティションプルーニングを使用できるときは、同じカラム定義およびデータが含まれているパーティション化されていないテーブルで同じクエリーを実行するよりも、速度が大幅に向上することがあります。
    </p><p>
      <code class="literal">WHERE</code> 条件を次の 2 つのケースのいずれかにまとめられるとき、オプティマイザはプルーニングを実行できます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal"><em class="replaceable"><code>partition_column</code></em> = <em class="replaceable"><code>constant</code></em></code>
        </p></li><li class="listitem"><p>
          <code class="literal"><em class="replaceable"><code>partition_column</code></em> IN (<em class="replaceable"><code>constant1</code></em>, <em class="replaceable"><code>constant2</code></em>, ..., <em class="replaceable"><code>constantN</code></em>)</code>
        </p></li></ul></div><p>
      最初のケースで、オプティマイザは指定された値についてパーティショニング式を単純に評価し、どのパーティションに値が含まれるかを判別して、このパーティションのみをスキャンします。多くの場合、この等号を別の算術比較 (<code class="literal">&lt;</code>、<code class="literal">&gt;</code>、<code class="literal">&lt;=</code>、<code class="literal">&gt;=</code>、および <code class="literal">&lt;&gt;</code> を含む) に置き換えることができます。<code class="literal">WHERE</code> 句で <code class="literal">BETWEEN</code> を使用するクエリーも、パーティションプルーニングの利点を活用できます。このセクションの後続の例を参照してください。
    </p><p>
      2 番目のケースで、オプティマイザはリスト内の各値についてパーティショニング式を評価して、一致するパーティションのリストを作成してから、このパーティションリストのパーティションのみをスキャンします。
    </p><p>
      MySQL は、パーティションプルーニングを <code class="literal">SELECT</code>、<code class="literal">DELETE</code>、および <code class="literal">UPDATE</code> ステートメントに適用できます。<code class="literal">INSERT</code> ステートメントは現在のところ、プルーニングできません。
    </p><p>
      短い範囲にもプルーニングを適用できます (オプティマイザが同等の値リストに変換できるもの)。たとえば、前の例では、<code class="literal">WHERE</code> 句を <code class="literal">WHERE region_code IN (126, 127, 128, 129)</code> に変換できます。これにより、オプティマイザは、リスト内の最初の 3 つの値はパーティション <code class="literal">p1</code> に見つかり、残りの 3 つの値はパーティション <code class="literal">p2</code> に見つかり、ほかのパーティションには関連する値は含まれないため一致する行を検索する必要がないと判断できます。
    </p><p>
      MySQL 5.6 のオプティマイザは、<code class="literal">RANGE COLUMNS</code> または <code class="literal">LIST COLUMNS</code> パーティショニングを使用するテーブルの複数のカラムで、前述のタイプの比較を使用する <code class="literal">WHERE</code> 条件のプルーニングを実行することもできます。
    </p><a class="indexterm" name="idm139979014612720"></a><p>
      このタイプの最適化は、パーティショニング式が同一性や範囲で構成されていてそれを同一性のセットにまとめられるとき、またはパーティショニング式が増減する関係を表すときに適用できます。パーティショニング式が <code class="literal">YEAR()</code> または <code class="literal">TO_DAYS()</code> 関数を使用するとき、<code class="literal">DATE</code> カラムまたは <code class="literal">DATETIME</code> カラムでパーティション化されるテーブルにプルーニングを適用することもできます。また、MySQL 5.6 では、パーティショニング式が <code class="literal">TO_SECONDS()</code> 関数を使用するとき、そのようなテーブルにプルーニングを適用できます。
    </p><p>
      テーブル <code class="literal">t2</code> が次のように定義されて、<code class="literal">DATE</code> カラムでパーティション化されるとします。
    </p><pre class="programlisting">
CREATE TABLE t2 (
    fname VARCHAR(50) NOT NULL,
    lname VARCHAR(50) NOT NULL,
    region_code TINYINT UNSIGNED NOT NULL,
    dob DATE NOT NULL
)
PARTITION BY RANGE( YEAR(dob) ) (
    PARTITION d0 VALUES LESS THAN (1970),
    PARTITION d1 VALUES LESS THAN (1975),
    PARTITION d2 VALUES LESS THAN (1980),
    PARTITION d3 VALUES LESS THAN (1985),
    PARTITION d4 VALUES LESS THAN (1990),
    PARTITION d5 VALUES LESS THAN (2000),
    PARTITION d6 VALUES LESS THAN (2005),
    PARTITION d7 VALUES LESS THAN MAXVALUE
);
</pre><p>
      <code class="literal">t2</code> を使用する次のステートメントでは、パーティションプルーニングを使用できます。
    </p><pre class="programlisting">
SELECT * FROM t2 WHERE dob = '1982-06-23';

UPDATE t2 SET region_code = 8 WHERE dob BETWEEN '1991-02-15' AND '1997-04-25';

DELETE FROM t2 WHERE dob &gt;= '1984-06-21' AND dob &lt;= '1999-06-21'
</pre><p>
      最後のステートメントの場合、オプティマイザは次のようにも動作できます。
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          <span class="emphasis"><em>範囲の下限が含まれるパーティションを見つけます</em></span>。
        </p><p>
          <code class="literal">YEAR('1984-06-21')</code> は値 <code class="literal">1984</code> を返し、それはパーティション <code class="literal">d3</code> に見つかります。
        </p></li><li class="listitem"><p>
          <span class="emphasis"><em>範囲の上限が含まれるパーティションを見つけます</em></span>。
        </p><p>
          <code class="literal">YEAR('1999-06-21')</code> は <code class="literal">1999</code> と評価され、それはパーティション <code class="literal">d5</code> に見つかります。
        </p></li><li class="listitem"><p>
          <span class="emphasis"><em>これらの 2 つのパーティションおよびそれらの間にある可能性のあるパーティションのみをスキャンします</em></span>。
        </p><p>
          この場合、これはパーティション <code class="literal">d3</code>、<code class="literal">d4</code>、および <code class="literal">d5</code> のみがスキャンされることを意味します。残りのパーティションは安全に無視できます (そして無視されます)。
        </p></li></ol></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        パーティション化されたテーブルに対するステートメントの <code class="literal">WHERE</code> 条件で参照される無効な <code class="literal">DATE</code> および <code class="literal">DATETIME</code> 値は、<code class="literal">NULL</code> として扱われます。これは、<code class="literal">SELECT * FROM <em class="replaceable"><code>partitioned_table</code></em> WHERE <em class="replaceable"><code>date_column</code></em> &lt; '2008-12-00'</code> などのクエリーは値を返さないことを意味します (Bug #40972 を参照してください)。
      </p></div><p>
      ここまで、<code class="literal">RANGE</code> パーティショニングを使用する例のみを見てきましたが、プルーニングはほかのパーティショニングタイプにも適用できます。
    </p><p>
      次に示すテーブル <code class="literal">t3</code> のように、パーティショニング式が増加または減少している <code class="literal">LIST</code> によってパーティション化されたテーブルがあるとします。(この例では、簡単にするために <code class="literal">region_code</code> カラムが値 1 から 10 まで (両端を含む) に制限されると想定します)。
    </p><pre class="programlisting">
CREATE TABLE t3 (
    fname VARCHAR(50) NOT NULL,
    lname VARCHAR(50) NOT NULL,
    region_code TINYINT UNSIGNED NOT NULL,
    dob DATE NOT NULL
)
PARTITION BY LIST(region_code) (
    PARTITION r0 VALUES IN (1, 3),
    PARTITION r1 VALUES IN (2, 5, 8),
    PARTITION r2 VALUES IN (4, 9),
    PARTITION r3 VALUES IN (6, 7, 10)
);
</pre><p>
      <code class="literal">SELECT * FROM t3 WHERE region_code BETWEEN 1 AND 3</code> などのステートメントの場合、オプティマイザはどのパーティションで値 1、2、および 3 が見つかるかを判別して (<code class="literal">r0</code> および <code class="literal">r1</code>)、残りのもの (<code class="literal">r2</code> および <code class="literal">r3</code>) をスキップします。
    </p><p>
      <code class="literal">HASH</code> または <code class="literal">[LINEAR] KEY</code> によってパーティション化されたテーブルの場合も、パーティショニング式で使用されるカラムに対して <code class="literal">WHERE</code> 句が単純な <code class="literal">=</code> 関係を使用しているときは、パーティションプルーニングを適用できます。次のように作成されたテーブルがあるとします。
    </p><pre class="programlisting">
CREATE TABLE t4 (
    fname VARCHAR(50) NOT NULL,
    lname VARCHAR(50) NOT NULL,
    region_code TINYINT UNSIGNED NOT NULL,
    dob DATE NOT NULL
)
PARTITION BY KEY(region_code)
PARTITIONS 8;
</pre><p>
      カラム値を定数と比較するステートメントはプルーニングできます。
    </p><pre class="programlisting">
UPDATE t4 WHERE region_code = 7;
</pre><p>
      プルーニングは短い範囲にも適用できます。オプティマイザがそのような条件を <code class="literal">IN</code> 関係に変換できるためです。たとえば、前に定義したものと同じテーブル <code class="literal">t4</code> を使用して、次のようなクエリーをプルーニングできます。
    </p><pre class="programlisting">
SELECT * FROM t4 WHERE region_code &gt; 2 AND region_code &lt; 6;

SELECT * FROM t4 WHERE region_code BETWEEN 3 AND 5;
</pre><p>
      どちらの場合も、<code class="literal">WHERE</code> 句はオプティマイザによって <code class="literal">WHERE region_code IN (3, 4, 5)</code> に変換されます。
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        この最適化は、範囲サイズがパーティションの数より小さい場合にのみ使用されます。次のステートメントがあるとします。
      </p><pre class="programlisting">
DELETE FROM t4 WHERE region_code BETWEEN 4 AND 12;
</pre><p>
        <code class="literal">WHERE</code> 句の範囲は 9 個の値 (4、5、6、7、8、9、10、11、12) ですが、<code class="literal">t4</code> のパーティションは 8 個だけです。これはこの <code class="literal">DELETE</code> をプルーニングできないことを意味します。
      </p></div><p>
      <code class="literal">HASH</code> または <code class="literal">[LINEAR] KEY</code> によってパーティション化されたテーブルの場合、プルーニングを使用できるのは整数カラムに対してのみです。たとえば、<code class="literal">dob</code> は <code class="literal">DATE</code> カラムであるため、次のステートメントにはプルーニングを使用できません。
    </p><pre class="programlisting">
SELECT * FROM t4 WHERE dob &gt;= '2001-04-14' AND dob &lt;= '2005-10-15';
</pre><p>
      ただし、このテーブルが年値を <code class="literal">INT</code> カラムに格納する場合は、<code class="literal">WHERE year_col &gt;= 2001 AND year_col &lt;= 2005</code> を持つクエリーをプルーニングできます。
    </p><p>
      MySQL 5.6.8 以降では、自動パーティショニングを提供するストレージエンジン (MySQL Cluster によって使用される <code class="literal">NDB</code> ストレージエンジン (現在のところ、MySQL 5.6 ではサポートされません) など) を使用するすべてのテーブルで、パーティションプルーニングは無効です(Bug #14672885)。MySQL 5.6.10 以降では、明示的にパーティション化されている場合は、そのようなテーブルをプルーニングできます(Bug #14827952)。
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="partitioning-selection"></a>19.5 パーティション選択</h2></div></div></div><p>
      MySQL 5.6 は、ステートメントを実行するときに、指定された <code class="literal">WHERE</code> 条件と一致する行をチェックすべきパーティションおよびサブパーティションの明示的選択をサポートします。パーティション選択は、特定のパーティションのみで一致がチェックされる点でパーティションプルーニングと似ていますが、2 つの重要な点で異なります。
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          チェックされるパーティションは、パーティションプルーニングと異なり (自動)、ステートメントの発行者が指定します。
        </p></li><li class="listitem"><p>
          パーティションプルーニングはクエリーのみに適用されますが、明示的なパーティション選択はクエリーおよびいくつかの DML ステートメントの両方でサポートされます。
        </p></li></ol></div><p>
      明示的なパーティション選択をサポートする SQL ステートメントを次に一覧します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">SELECT</code>
        </p></li><li class="listitem"><p>
          <code class="literal">DELETE</code>
        </p></li><li class="listitem"><p>
          <code class="literal">INSERT</code>
        </p></li><li class="listitem"><p>
          <code class="literal">REPLACE</code>
        </p></li><li class="listitem"><p>
          <code class="literal">UPDATE</code>
        </p></li><li class="listitem"><p>
          <code class="literal">LOAD DATA</code>。
        </p></li><li class="listitem"><p>
          <code class="literal">LOAD XML</code>。
        </p></li></ul></div><p>
      このセクションの残りの部分では、上記に一覧したステートメントに一般的に適用される明示的パーティション選択について説明し、いくつかの例を示します。
    </p><p>
      明示的パーティション選択は、<code class="literal">PARTITION</code> オプションを使用して実装されます。サポートされるすべてのステートメントについて、このオプションは次のような構文を使用します。
    </p><pre class="programlisting">
      PARTITION (<em class="replaceable"><code>partition_names</code></em>)

      <em class="replaceable"><code>partition_names</code></em>:
          <em class="replaceable"><code>partition_name</code></em>, ...
</pre><p>
      このオプションは常に、パーティションが属するテーブルの名前の後ろに続けます。<em class="replaceable"><code>partition_names</code></em> は、使用されるパーティションまたはサブパーティションのカンマ区切りのリストです。このリスト内の各名前は、指定されたテーブルの既存のパーティションまたはサブパーティションの名前である必要があります。パーティションまたはサブパーティションが見つからない場合、ステートメントはエラー (<span class="errortext">partition '<em class="replaceable"><code>partition_name</code></em>' doesn't exist</span>) で失敗します。<em class="replaceable"><code>partition_names</code></em> に指定するパーティションまたはサブパーティションは、任意の順序でリストでき、重複していてもかまいません。
    </p><p>
      <code class="literal">PARTITION</code> オプションを使用すると、リストされたパーティションおよびサブパーティションのみで一致する行がチェックされます。このオプションを <code class="literal">SELECT</code> ステートメントで使用すると、指定したパーティションに属する行を判別できます。次のようなステートメントを使用して作成および移入された、<code class="literal">employees</code> という名前のパーティション化されたテーブルがあるとします。
    </p><pre class="programlisting">
SET @@SQL_MODE = '';

CREATE TABLE employees  (
    id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    fname VARCHAR(25) NOT NULL,
    lname VARCHAR(25) NOT NULL,
    store_id INT NOT NULL,
    department_id INT NOT NULL
)   
    PARTITION BY RANGE(id)  (
        PARTITION p0 VALUES LESS THAN (5),
        PARTITION p1 VALUES LESS THAN (10),
        PARTITION p2 VALUES LESS THAN (15),
        PARTITION p3 VALUES LESS THAN MAXVALUE
);

INSERT INTO employees VALUES
    ('', 'Bob', 'Taylor', 3, 2), ('', 'Frank', 'Williams', 1, 2), 
    ('', 'Ellen', 'Johnson', 3, 4), ('', 'Jim', 'Smith', 2, 4),  
    ('', 'Mary', 'Jones', 1, 1), ('', 'Linda', 'Black', 2, 3),
    ('', 'Ed', 'Jones', 2, 1), ('', 'June', 'Wilson', 3, 1), 
    ('', 'Andy', 'Smith', 1, 3), ('', 'Lou', 'Waters', 2, 4),  
    ('', 'Jill', 'Stone', 1, 4), ('', 'Roger', 'White', 3, 2),
    ('', 'Howard', 'Andrews', 1, 2), ('', 'Fred', 'Goldberg', 3, 3), 
    ('', 'Barbara', 'Brown', 2, 3), ('', 'Alice', 'Rogers', 2, 2),  
    ('', 'Mark', 'Morgan', 3, 3), ('', 'Karen', 'Cole', 3, 2);
</pre><p>
      どの行がパーティション <code class="literal">p1</code> に格納されているかは次のように確認できます。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT * FROM employees PARTITION (p1);</code></strong>
+----+-------+--------+----------+---------------+
| id | fname | lname  | store_id | department_id |
+----+-------+--------+----------+---------------+
|  5 | Mary  | Jones  |        1 |             1 |
|  6 | Linda | Black  |        2 |             3 |
|  7 | Ed    | Jones  |        2 |             1 |
|  8 | June  | Wilson |        3 |             1 |
|  9 | Andy  | Smith  |        1 |             3 |
+----+-------+--------+----------+---------------+
5 rows in set (0.00 sec)
</pre><p>
      この結果は、クエリー <code class="literal">SELECT * FROM employees WHERE id BETWEEN 5 AND 9</code> によって取得されるものと同じです。
    </p><p>
      複数のパーティションからの行を取得するには、それらの名前をカンマ区切りのリストとして指定します。たとえば、<code class="literal">SELECT * FROM employees PARTITION (p1, p2)</code> はパーティション <code class="literal">p1</code> および <code class="literal">p2</code> からのすべての行を返し、残りのパーティションからの行を除外します。
    </p><p>
      パーティション化されたテーブルに対する有効なクエリーは、<code class="literal">PARTITION</code> オプションを使用して、結果を 1 つ以上の目的のパーティションに制限するように書き直すことができます。<code class="literal">WHERE</code> 条件、<code class="literal">ORDER BY</code> オプション、<code class="literal">LIMIT</code> オプションなどを使用できます。集約関数を <code class="literal">HAVING</code> および <code class="literal">GROUP BY</code> オプション付きで使用することもできます。次の各クエリーは、前に定義した <code class="literal">employees</code> テーブルで実行するときに、有効な結果を生成します。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT * FROM employees PARTITION (p0, p2)</code></strong>
    -&gt;     <strong class="userinput"><code>WHERE lname LIKE 'S%';</code></strong>
+----+-------+-------+----------+---------------+
| id | fname | lname | store_id | department_id |
+----+-------+-------+----------+---------------+
|  4 | Jim   | Smith |        2 |             4 |
| 11 | Jill  | Stone |        1 |             4 |
+----+-------+-------+----------+---------------+
2 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT id, CONCAT(fname, ' ', lname) AS name</code></strong> 
    -&gt;     <strong class="userinput"><code>FROM employees PARTITION (p0) ORDER BY lname;</code></strong>
+----+----------------+
| id | name           |
+----+----------------+
|  3 | Ellen Johnson  |
|  4 | Jim Smith      |
|  1 | Bob Taylor     |
|  2 | Frank Williams |
+----+----------------+
4 rows in set (0.06 sec)

mysql&gt; <strong class="userinput"><code>SELECT store_id, COUNT(department_id) AS c</code></strong> 
    -&gt;     <strong class="userinput"><code>FROM employees PARTITION (p1,p2,p3)</code></strong> 
    -&gt;     <strong class="userinput"><code>GROUP BY store_id HAVING c &gt; 4;</code></strong>
+---+----------+
| c | store_id |
+---+----------+
| 5 |        2 |
| 5 |        3 |
+---+----------+
2 rows in set (0.00 sec)
</pre><p>
      パーティション選択を使用するステートメントは、MySQL 5.6 でサポートされるパーティショニングタイプを使用するテーブルで使用できます。テーブルが <code class="literal">[LINEAR] HASH</code> または <code class="literal">[LINEAR] KEY</code> パーティショニングを使用して作成されているけれども、パーティションの名前が指定されていない場合は、MySQL はパーティションに <code class="literal">p0</code>、<code class="literal">p1</code>、<code class="literal">p2</code>、...、<code class="literal">p<em class="replaceable"><code>N-1</code></em></code> という名前を自動的に付けます。ここで、<em class="replaceable"><code>N</code></em> はパーティションの数です。明示的に名前が付けられていないサブパーティションの場合、MySQL は各パーティション <code class="literal">p<em class="replaceable"><code>X</code></em></code> 内のサブパーティションに <code class="literal">p<em class="replaceable"><code>X</code></em>sp0</code>、<code class="literal">p<em class="replaceable"><code>X</code></em>sp1</code>、<code class="literal">p<em class="replaceable"><code>X</code></em>sp2</code>、...、<code class="literal">p<em class="replaceable"><code>X</code></em>sp<em class="replaceable"><code>M-1</code></em></code> という名前を自動的に割り当てます。ここで、<em class="replaceable"><code>M</code></em> はサブパーティションの数です。このテーブルで <code class="literal">SELECT</code> (または明示的パーティション選択が許可されるほかの SQL ステートメント) を実行するときは、次のようにこれらの生成された名前を <code class="literal">PARTITION</code> オプションで使用できます。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE employees_sub  (</code></strong>
    -&gt;     <strong class="userinput"><code>id INT NOT NULL AUTO_INCREMENT,</code></strong>
    -&gt;     <strong class="userinput"><code>fname VARCHAR(25) NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>lname VARCHAR(25) NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>store_id INT NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>department_id INT NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>PRIMARY KEY pk (id, lname)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>   
    -&gt;     <strong class="userinput"><code>PARTITION BY RANGE(id)</code></strong>
    -&gt;     <strong class="userinput"><code>SUBPARTITION BY KEY (lname)</code></strong>
    -&gt;     <strong class="userinput"><code>SUBPARTITIONS 2 (</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (5),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (10),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p2 VALUES LESS THAN (15),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p3 VALUES LESS THAN MAXVALUE</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (1.14 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO employees_sub</code></strong>   # re-use data in employees table
    -&gt;     <strong class="userinput"><code>SELECT * FROM employees;</code></strong>
Query OK, 18 rows affected (0.09 sec)
Records: 18  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT id, CONCAT(fname, ' ', lname) AS name</code></strong>
    -&gt;     <strong class="userinput"><code>FROM employees_sub PARTITION (p2sp1);</code></strong>
+----+---------------+
| id | name          |
+----+---------------+
| 10 | Lou Waters    |
| 14 | Fred Goldberg |
+----+---------------+
2 rows in set (0.00 sec)
</pre><p>
      次のように <code class="literal">PARTITION</code> オプションを <code class="literal">INSERT ... SELECT</code> ステートメントの <code class="literal">SELECT</code> 部分に使用することもできます。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE employees_copy LIKE employees;</code></strong>
Query OK, 0 rows affected (0.28 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO employees_copy</code></strong> 
    -&gt;     <strong class="userinput"><code>SELECT * FROM employees PARTITION (p2);</code></strong>
Query OK, 5 rows affected (0.04 sec)
Records: 5  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT * FROM employees_copy;</code></strong>
+----+--------+----------+----------+---------------+
| id | fname  | lname    | store_id | department_id |
+----+--------+----------+----------+---------------+
| 10 | Lou    | Waters   |        2 |             4 |
| 11 | Jill   | Stone    |        1 |             4 |
| 12 | Roger  | White    |        3 |             2 |
| 13 | Howard | Andrews  |        1 |             2 |
| 14 | Fred   | Goldberg |        3 |             3 |
+----+--------+----------+----------+---------------+
5 rows in set (0.00 sec)
</pre><p>
      パーティション選択は結合と一緒に使用することもできます。次のステートメントを使用して 2 つのテーブルを作成して移入するとします。
    </p><pre class="programlisting">
CREATE TABLE stores (
    id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    city VARCHAR(30) NOT NULL
)
    PARTITION BY HASH(id)
    PARTITIONS 2;
    
INSERT INTO stores VALUES
    ('', 'Nambucca'), ('', 'Uranga'), 
    ('', 'Bellingen'), ('', 'Grafton');
    
CREATE TABLE departments  (
    id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(30) NOT NULL
)
    PARTITION BY KEY(id)
    PARTITIONS 2;
    
INSERT INTO departments VALUES
    ('', 'Sales'), ('', 'Customer Service'), 
    ('', 'Delivery'), ('', 'Accounting');
</pre><p>
      任意またはすべてのテーブルからのパーティション (またはサブパーティション、あるいはその両方) を結合で明示的に選択できます(指定されたテーブルからのパーティションを選択するために使用する <code class="literal">PARTITION</code> オプションは、テーブル名の直後、かつほかのすべてのオプション (テーブルエイリアスを含む) の前に指定します)。たとえば、次のクエリーは都市 Nambucca および Bellingen (<code class="literal">stores</code> テーブルのパーティション <code class="literal">p0</code>) のいずれかの店舗の販売部門または配送部門 (<code class="literal">departments</code> テーブルのパーティション <code class="literal">p1</code>) で働いているすべての従業員の、名前、従業員 ID、部門、および都市を取得します。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT</code></strong>
    -&gt;     <strong class="userinput"><code>e.id AS 'Employee ID', CONCAT(e.fname, ' ', e.lname) AS Name,</code></strong>
    -&gt;     <strong class="userinput"><code>s.city AS City, d.name AS department</code></strong>
    -&gt; <strong class="userinput"><code>FROM employees AS e</code></strong>
    -&gt;     <strong class="userinput"><code>JOIN stores PARTITION (p1) AS s ON e.store_id=s.id</code></strong>
    -&gt;     <strong class="userinput"><code>JOIN departments PARTITION (p0) AS d ON e.department_id=d.id</code></strong>
    -&gt; <strong class="userinput"><code>ORDER BY e.lname;</code></strong>
+-------------+---------------+-----------+------------+
| Employee ID | Name          | City      | department |
+-------------+---------------+-----------+------------+
|          14 | Fred Goldberg | Bellingen | Delivery   |
|           5 | Mary Jones    | Nambucca  | Sales      |
|          17 | Mark Morgan   | Bellingen | Delivery   |
|           9 | Andy Smith    | Nambucca  | Delivery   |
|           8 | June Wilson   | Bellingen | Sales      |
+-------------+---------------+-----------+------------+
5 rows in set (0.00 sec)
</pre><p>
      MySQL での結合の一般情報については、<a class="xref" href="sql-syntax.html#join" title="13.2.9.2 JOIN 構文">セクション13.2.9.2「JOIN 構文」</a>を参照してください。
    </p><p>
      <code class="literal">DELETE</code> ステートメントで <code class="literal">PARTITION</code> オプションを使用すると、オプションにリストされているパーティション (およびサブパーティション (ある場合)) でのみ削除される行がチェックされます。次のようにほかのパーティションは無視されます。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT * FROM employees WHERE fname LIKE 'j%';</code></strong>
+----+-------+--------+----------+---------------+
| id | fname | lname  | store_id | department_id |
+----+-------+--------+----------+---------------+
|  4 | Jim   | Smith  |        2 |             4 |
|  8 | June  | Wilson |        3 |             1 |
| 11 | Jill  | Stone  |        1 |             4 |
+----+-------+--------+----------+---------------+
3 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>DELETE FROM employees PARTITION (p0, p1)</code></strong> 
    -&gt;     <strong class="userinput"><code>WHERE fname LIKE 'j%';</code></strong>
Query OK, 2 rows affected (0.09 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM employees WHERE fname LIKE 'j%';</code></strong>
+----+-------+-------+----------+---------------+
| id | fname | lname | store_id | department_id |
+----+-------+-------+----------+---------------+
| 11 | Jill  | Stone |        1 |             4 |
+----+-------+-------+----------+---------------+
1 row in set (0.00 sec)
</pre><p>
      <code class="literal">WHERE</code> 条件と一致するパーティション <code class="literal">p0</code> および <code class="literal">p1</code> 内の 2 つの行のみが削除されました。<code class="literal">SELECT</code> を 2 回目に実行したときの結果から確認できるように、<code class="literal">WHERE</code> 条件に一致する 1 行がテーブルに残っていますが、別のパーティション (<code class="literal">p2</code>) にあります。
    </p><p>
      明示的パーティション選択を使用する <code class="literal">UPDATE</code> ステートメントも同様に動作します。次のステートメントを実行することによって確認できるように、<code class="literal">PARTITION</code> オプションによって参照されるパーティション内の行のみが、更新される行を判別するときに考慮されます。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>UPDATE employees PARTITION (p0) </code></strong>
    -&gt;     <strong class="userinput"><code>SET store_id = 2 WHERE fname = 'Jill';</code></strong>
Query OK, 0 rows affected (0.00 sec)
Rows matched: 0  Changed: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT * FROM employees WHERE fname = 'Jill';</code></strong>
+----+-------+-------+----------+---------------+
| id | fname | lname | store_id | department_id |
+----+-------+-------+----------+---------------+
| 11 | Jill  | Stone |        1 |             4 |
+----+-------+-------+----------+---------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>UPDATE employees PARTITION (p2)</code></strong>
    -&gt;     <strong class="userinput"><code>SET store_id = 2 WHERE fname = 'Jill';</code></strong>
Query OK, 1 row affected (0.09 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT * FROM employees WHERE fname = 'Jill';</code></strong>
+----+-------+-------+----------+---------------+
| id | fname | lname | store_id | department_id |
+----+-------+-------+----------+---------------+
| 11 | Jill  | Stone |        2 |             4 |
+----+-------+-------+----------+---------------+
1 row in set (0.00 sec)
</pre><p>
      同様に、<code class="literal">DELETE</code> 付きで <code class="literal">PARTITION</code> を使用すると、パーティションリストに指定されたパーティション内の行のみが削除をチェックされます。
    </p><p>
      行を挿入するステートメントの動作は、適切なパーティションが見つからないとステートメントが失敗する点が異なります。これは、次のように <code class="literal">INSERT</code> および <code class="literal">REPLACE</code> ステートメントの両方に当てはまります。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>INSERT INTO employees PARTITION (p2) VALUES (20, 'Jan', 'Jones', 1, 3);</code></strong>
<span class="errortext">ERROR 1729 (HY000): Found a row not matching the given partition set</span>
mysql&gt; <strong class="userinput"><code>INSERT INTO employees PARTITION (p3) VALUES (20, 'Jan', 'Jones', 1, 3);</code></strong>
Query OK, 1 row affected (0.07 sec)

mysql&gt; REPLACE INTO employees PARTITION (p0) VALUES (20, 'Jan', 'Jones', 3, 2);
<span class="errortext">ERROR 1729 (HY000): Found a row not matching the given partition set</span>

mysql&gt; REPLACE INTO employees PARTITION (p3) VALUES (20, 'Jan', 'Jones', 3, 2);
Query OK, 2 rows affected (0.09 sec)
</pre><p>
      <code class="literal">InnoDB</code> ストレージエンジンを使用するパーティション化されたテーブルに複数の行を書き込むステートメントの場合、<code class="literal">VALUES</code> に続くリスト内の行を <em class="replaceable"><code>partition_names</code></em> リストに指定されたパーティションのいずれかに書き込むことができないときは、ステートメント全体が失敗し、一行も書き込まれません。これについては、次の例 (<code class="literal">employees</code> テーブルを再使用) の <code class="literal">INSERT</code> ステートメントで示されています。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>ALTER TABLE employees</code></strong>
    -&gt;     <strong class="userinput"><code>REORGANIZE PARTITION p3 INTO (</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p3 VALUES LESS THAN (20),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p4 VALUES LESS THAN (25),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p5 VALUES LESS THAN MAXVALUE</code></strong>
    -&gt;     <strong class="userinput"><code>);</code></strong>
Query OK, 6 rows affected (2.09 sec)
Records: 6  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE employees\G</code></strong>
*************************** 1. row ***************************
       Table: employees
Create Table: CREATE TABLE `employees` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `fname` varchar(25) NOT NULL,
  `lname` varchar(25) NOT NULL,
  `store_id` int(11) NOT NULL,
  `department_id` int(11) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=27 DEFAULT CHARSET=latin1
/*!50100 PARTITION BY RANGE (id)
(PARTITION p0 VALUES LESS THAN (5) ENGINE = InnoDB,
 PARTITION p1 VALUES LESS THAN (10) ENGINE = InnoDB,
 PARTITION p2 VALUES LESS THAN (15) ENGINE = InnoDB,
 PARTITION p3 VALUES LESS THAN (20) ENGINE = InnoDB,
 PARTITION p4 VALUES LESS THAN (25) ENGINE = InnoDB,
 PARTITION p5 VALUES LESS THAN MAXVALUE ENGINE = InnoDB) */
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO employees PARTITION (p3, p4) VALUES</code></strong> 
    -&gt;     <strong class="userinput"><code>(24, 'Tim', 'Greene', 3, 1),  (26, 'Linda', 'Mills', 2, 1);</code></strong>
ERROR 1729 (HY000): Found a row not matching the given partition set

mysql&gt; <strong class="userinput"><code>INSERT INTO employees PARTITION (p3, p4. p5) VALUES</code></strong> 
    -&gt;     <strong class="userinput"><code>(24, 'Tim', 'Greene', 3, 1),  (26, 'Linda', 'Mills', 2, 1);</code></strong>
Query OK, 2 rows affected (0.06 sec)
Records: 2  Duplicates: 0  Warnings: 0
</pre><p>
      前述のことは、複数の行を書き込む <code class="literal">INSERT</code> および <code class="literal">REPLACE</code> ステートメントの両方に当てはまります。
    </p><p>
      MySQL 5.6.10 以降では、自動パーティショニングを提供するストレージエンジン (<code class="literal">NDB</code> など) を使用するテーブルの場合、パーティション選択は無効になります。(Bug #14827952)。
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="partitioning-limitations"></a>19.6 パーティショニングの制約と制限</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="partitioning.html#partitioning-limitations-partitioning-keys-unique-keys">19.6.1 パーティショニングキー、主キー、および一意キー</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-limitations-storage-engines">19.6.2 ストレージエンジンに関連するパーティショニング制限</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-limitations-functions">19.6.3 関数に関連するパーティショニング制限</a></span></dt><dt><span class="section"><a href="partitioning.html#partitioning-limitations-locking">19.6.4 パーティショニングとロック</a></span></dt></dl></div><a class="indexterm" name="idm139979014382336"></a><p>
      このセクションでは、MySQL パーティショニングサポートでの現在の制約と制限について説明します。
    </p><p><b>禁止されている構造体 </b>
        次の構造体はパーティショニング式で許可されません。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ストアドプロシージャー、ストアドファンクション、UDF、またはプラグイン。
        </p></li><li class="listitem"><p>
          宣言された変数またはユーザー変数。
        </p></li></ul></div><p>
      パーティショニング式で許可される SQL 関数のリストについては、<a class="xref" href="partitioning.html#partitioning-limitations-functions" title="19.6.3 関数に関連するパーティショニング制限">セクション19.6.3「関数に関連するパーティショニング制限」</a>を参照してください。
    </p><p><b>算術および論理演算子 </b>
        <a class="indexterm" name="idm139979014373632"></a> <a class="indexterm" name="idm139979014371344"></a> 算術演算子 <code class="literal">+</code>、<code class="literal">-</code>、および <code class="literal">*</code> の使用は、パーティショニング式で許可されます。ただし、結果は整数値または <code class="literal">NULL</code> である必要があります (この章のほかの場所で説明しているように、<code class="literal">[LINEAR] KEY</code> パーティショニングの場合を除きます。詳細は、<a class="xref" href="partitioning.html#partitioning-types" title="19.2 パーティショニングタイプ">セクション19.2「パーティショニングタイプ」</a>を参照してください)。
      </p><p>
      <code class="literal">DIV</code> 演算子もサポートされますが、<code class="literal">/</code> 演算子は許可されません。(Bug #30188、Bug #33182)。
    </p><p>
      ビット演算子 <code class="literal">|</code>、<code class="literal">&amp;</code>、<code class="literal">^</code>、<code class="literal">&lt;&lt;</code>、<code class="literal">&gt;&gt;</code>、および <code class="literal">~</code> はパーティショニング式では許可されません。
    </p><p><b>HANDLER ステートメント </b>
        MySQL 5.6 では、<code class="literal">HANDLER</code> ステートメントはパーティション化されたテーブルでサポートされません。
      </p><p><b>サーバー SQL モード </b>
        <a class="indexterm" name="idm139979014348720"></a> <a class="indexterm" name="idm139979014346544"></a> ユーザー定義パーティショニングを使用するテーブルは、それらが作成された時点で有効だった SQL モードを保持しません。<a class="xref" href="server-administration.html#sql-mode" title="5.1.7 サーバー SQL モード">セクション5.1.7「サーバー SQL モード」</a>で説明したように、多くの MySQL 関数および演算子の結果はサーバー SQL モードに従って変更されることがあります。このため、パーティション化されたテーブルの作成後の任意の時点に SQL モードを変更すると、そのようなテーブルの動作が大きく変わることがあり、データの破損または損失が発生しやすくなることがあります。これらの理由により、<span class="emphasis"><em>パーティション化されたテーブルを作成したあとにサーバー SQL モードを決して変更しないことが強く推奨されています</em></span>。
      </p><p><b>例 </b>
        次の例は、サーバー SQL モードを変更したことによる、パーティション化されたテーブルの動作の変化をいくつか示しています。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><b>エラー処理 </b>
            次のように、パーティショニング式が <code class="literal"><em class="replaceable"><code>column</code></em> DIV 0</code>、<code class="literal"><em class="replaceable"><code>column</code></em> MOD 0</code> などのいずれかであるパーティション化されたテーブルを作成するとします。
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE tn (c1 INT)</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION BY LIST(1 DIV c1) (</code></strong>
    -&gt;       <strong class="userinput"><code>PARTITION p0 VALUES IN (NULL),</code></strong>
    -&gt;       <strong class="userinput"><code>PARTITION p1 VALUES IN (1)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.05 sec)
</pre><p>
          ゼロで除算した結果に対する MySQL のデフォルト動作は、エラーを発生させずに <code class="literal">NULL</code> を返すことです。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT @@sql_mode;</code></strong>
+------------+
| @@sql_mode |
+------------+
|            |
+------------+
1 row in set (0.00 sec)


mysql&gt; <strong class="userinput"><code>INSERT INTO tn VALUES (NULL), (0), (1);</code></strong>
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0
</pre><p>
          ただし、ゼロによる除算をエラーとして扱い、厳密なエラー処理を適用するようにサーバー SQL モードを変更すると、次のように同じ <code class="literal">INSERT</code> ステートメントが失敗します。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET sql_mode='STRICT_ALL_TABLES,ERROR_FOR_DIVISION_BY_ZERO';</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO tn VALUES (NULL), (0), (1);</code></strong>
<span class="errortext">ERROR 1365 (22012): Division by 0</span>
</pre></li><li class="listitem"><p><b>テーブルアクセス可能性 </b>
            サーバー SQL モードを変更することによって、パーティション化されたテーブルが使用できなくなることがあります。次の <code class="literal">CREATE TABLE</code> ステートメントは、<code class="literal">NO_UNSIGNED_SUBTRACTION</code> モードが有効である場合にのみ、正常に実行できます。
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT @@sql_mode;</code></strong>
+------------+
| @@sql_mode |
+------------+
|            |
+------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>CREATE TABLE tu (c1 BIGINT UNSIGNED)</code></strong>
    -&gt;   <strong class="userinput"><code>PARTITION BY RANGE(c1 - 10) (</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (-5),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (0),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p2 VALUES LESS THAN (5),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p3 VALUES LESS THAN (10),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p4 VALUES LESS THAN (MAXVALUE)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
<span class="errortext">ERROR 1563 (HY000): Partition constant is out of partition function domain</span>

mysql&gt; <strong class="userinput"><code>SET sql_mode='NO_UNSIGNED_SUBTRACTION';</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT @@sql_mode;</code></strong>
+-------------------------+
| @@sql_mode              |
+-------------------------+
| NO_UNSIGNED_SUBTRACTION |
+-------------------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>CREATE TABLE tu (c1 BIGINT UNSIGNED)</code></strong>
    -&gt;   <strong class="userinput"><code>PARTITION BY RANGE(c1 - 10) (</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (-5),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (0),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p2 VALUES LESS THAN (5),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p3 VALUES LESS THAN (10),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p4 VALUES LESS THAN (MAXVALUE)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.05 sec)
</pre><p>
          <code class="literal">tu</code> を作成したあとに <code class="literal">NO_UNSIGNED_SUBTRACTION</code> サーバー SQL モードを削除すると、このテーブルにアクセスできなくなる可能性があります。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET sql_mode='';</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM tu;</code></strong>
<span class="errortext">ERROR 1563 (HY000): Partition constant is out of partition function domain</span>
mysql&gt; <strong class="userinput"><code>INSERT INTO tu VALUES (20);</code></strong>
<span class="errortext">ERROR 1563 (HY000): Partition constant is out of partition function domain</span>
</pre></li></ol></div><p>
      サーバー SQL モードは、パーティション化されたテーブルのレプリケーションにも影響します。マスターとスレーブで SQL モードが異なると、パーティショニング式が違って評価されることがあります。これにより、指定されたテーブルのマスターのコピーとスレーブのコピーでパーティション間のデータ配分が違ってくることがあり、マスターで成功するパーティション化されたテーブルへの挿入がスレーブで失敗することさえあります。最適な結果を得るために、マスターとスレーブとで常に同じサーバー SQL モードを使用してください。
    </p><p><b>パフォーマンス考慮事項 </b>
        パーティショニング操作のパフォーマンスへの影響の一部を次のリストに示します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="partitioning-limitations-file-system-ops"></a><b>ファイルシステム操作 </b>
            パーティショニングおよび再パーティショニング操作 (<code class="literal">PARTITION BY ...</code>、<code class="literal">REORGANIZE PARTITIONS</code>、または <code class="literal">REMOVE PARTITIONING</code> を指定した <code class="literal">ALTER TABLE</code> など) は、それらの実装のファイルシステム操作に依存します。これは、これらの操作の速度が、ファイルシステムのタイプと特性、ディスク速度、スワップ領域、オペレーティングシステムによるファイル処理効率、ファイル処理に関連する MySQL サーバーのオプションと変数などの要因に影響されることを意味します。特に、<code class="literal">large_files_support</code> が有効になっていて、<code class="literal">open_files_limit</code> が適切に設定されていることを確認してください。<code class="literal">MyISAM</code> ストレージエンジンを使用するパーティション化されたテーブルの場合、<code class="literal">myisam_max_sort_file_size</code> を増やすとパフォーマンスが向上することがあります。<code class="literal">innodb_file_per_table</code> を有効にすることで、<code class="literal">InnoDB</code> テーブルを使用するパーティショニングおよび再パーティショニング操作の効率が向上することがあります。
          </p><p>
          <a class="xref" href="partitioning.html#partitioning-limitations-max-partitions" title="パーティションの最大数">パーティションの最大数</a>も参照してください。
        </p></li><li class="listitem"><p><b>テーブルロック </b>
            テーブルに対してパーティショニング操作を実行する処理は、テーブルに対して書き込みロックを設定します。そのようなテーブルからの読み取りは比較的影響を受けません。保留中の <code class="literal">INSERT</code> および <code class="literal">UPDATE</code> 操作は、パーティショニング操作が完了するとすぐに実行されます。
          </p></li><li class="listitem"><p><b>ストレージエンジン </b>
            パーティショニング操作、クエリー、および更新操作は通常、<code class="literal">InnoDB</code> または <code class="literal">NDB</code> テーブルより <code class="literal">MyISAM</code> テーブルで高速である傾向があります。
          </p></li><li class="listitem"><p><b>インデックス、パーティションプルーニング </b>
            パーティション化されていないテーブルと同様に、インデックスを適切に使用することで、パーティション化されたテーブルに対する照会速度が大幅に向上することがあります。また、パーティション化されたテーブルおよびこれらのテーブルに対するクエリーを<em class="firstterm">パーティションプルーニング</em>の利点を活用するように設計することで、パフォーマンスが劇的に向上することがあります。詳細は、<a class="xref" href="partitioning.html#partitioning-pruning" title="19.4 パーティションプルーニング">セクション19.4「パーティションプルーニング」</a>を参照してください。
          </p><p>
          インデックスコンディションプッシュダウンは、パーティション化されたテーブルではサポートされません。<a class="xref" href="optimization.html#index-condition-pushdown-optimization" title="8.2.1.6 インデックスコンディションプッシュダウンの最適化">セクション8.2.1.6「インデックスコンディションプッシュダウンの最適化」</a>を参照してください。
        </p></li><li class="listitem"><p><b>LOAD DATA のパフォーマンス </b>
            MySQL 5.6 では、<code class="literal">LOAD DATA</code> はパフォーマンスを向上させるためにバッファリングを使用します。これを実現するために、バッファーがパーティションごとに 130K バイトメモリーを使用することを認識してください。
          </p></li></ul></div><p><a name="partitioning-limitations-max-partitions"></a><b>パーティションの最大数 </b><a class="indexterm" name="idm139979014260944"></a><a class="indexterm" name="idm139979014258720"></a>
        MySQL 5.6.7 より前は、<code class="literal">NDB</code> ストレージエンジンを使用しないテーブルで可能な最大パーティション数は 1024 でした。MySQL 5.6.7 以降は、この制限は 8192 パーティションに増えています。MySQL Server バージョンにかかわらず、この最大数にはサブパーティションが含まれます。
      </p><p>
      <code class="literal">NDB</code> ストレージエンジンを使用するテーブルのユーザー定義パーティションの最大数は、使用されている MySQL Cluster ソフトウェアのバージョン、データノードの数、およびその他の要因に応じて決まります。詳細は、<a class="xref" href="mysql-cluster.html#mysql-cluster-nodes-groups-user-partitioning" title="NDB とユーザー定義のパーティション化">NDB とユーザー定義のパーティション化</a>を参照してください。
    </p><p>
      多数のパーティション (ただし、最大数より少ない) を持つテーブルを作成するときに、<span class="errortext">Got error ... from storage engine: Out of resources when opening file</span>などのエラーメッセージが表示される場合は、<code class="literal">open_files_limit</code> システム変数の値を増やすことによってこの問題に対処できることがあります。ただし、これはオペレーティングシステムによって異なるため、すべてのプラットフォームで可能または推奨されるとはかぎりません。詳細は、<a class="xref" href="error-handling.html#not-enough-file-handles" title="B.5.2.18 'File' が見つかりません、および同様のエラー">セクションB.5.2.18「'File' が見つかりません、および同様のエラー」</a>を参照してください。場合によっては、多数の (数百の) パーティションを使用することがほかの問題のために推奨されないこともあり、より多くのパーティションを使用することが自動的に良い結果となるとはかぎりません。
    </p><p>
      <a class="xref" href="partitioning.html#partitioning-limitations-file-system-ops" title="ファイルシステム操作">ファイルシステム操作</a>も参照してください。
    </p><p><b>クエリーキャッシュがサポートされない </b><a class="indexterm" name="idm139979014245792"></a><a class="indexterm" name="idm139979014243584"></a>
        クエリーキャッシュはパーティション化されたテーブルではサポートされません。MySQL 5.6.5 以降は、クエリーキャッシュはパーティション化されたテーブルを使用するクエリーで自動的に無効になり、そのようなクエリーで有効にすることはできません。(Bug #53775)
      </p><p><b>パーティションごとのキーキャッシュ </b><a class="indexterm" name="idm139979014239600"></a><a class="indexterm" name="idm139979014237504"></a><a class="indexterm" name="idm139979014235440"></a>
        MySQL 5.6 では、<code class="literal">CACHE INDEX</code> および <code class="literal">LOAD INDEX INTO CACHE</code> ステートメントを使用することで、キーキャッシュがパーティション化された <code class="literal">MyISAM</code> テーブルでサポートされます。キーキャッシュは 1 つ、複数、またはすべてのパーティションに定義でき、1 つ、複数、またはすべてのパーティションのインデックスをキーキャッシュにプリロードできます。
      </p><p><b>パーティション化された InnoDB テーブルで外部キーがサポートされない </b><a class="indexterm" name="idm139979014228176"></a>
        <code class="literal">InnoDB</code> ストレージエンジンを使用するパーティション化されたテーブルでは、外部キーはサポートされません。これは具体的には、次の 2 つの記述が true であることを意味します。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          ユーザー定義パーティショニングを使用する <code class="literal">InnoDB</code> テーブルの定義には、外部キー参照を含めることはできません。定義に外部キー参照が含まれる <code class="literal">InnoDB</code> テーブルはパーティション化できません。
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> テーブル定義に、ユーザーパーティション化されたテーブルへの外部キー参照を含めることはできません。ユーザー定義パーティショニングを持つ <code class="literal">InnoDB</code> テーブルに、外部キーによって参照されるカラムを含めることはできません。
        </p></li></ol></div><p>
      上記の制約のスコープには、<code class="literal">InnoDB</code> ストレージエンジンを使用するすべてのテーブルが含まれます。結果のテーブルがこれらの制約に違反する <code class="literal">CREATE TABLE</code> および <code class="literal">ALTER TABLE</code> ステートメントは許可されません。
    </p><p><b>ALTER TABLE ... ORDER BY </b>
        パーティション化されたテーブルに <code class="literal">ALTER TABLE ... ORDER BY <em class="replaceable"><code>column</code></em></code> ステートメントを実行すると、各パーティション内でのみ行が並べ替えられます。
      </p><p><b>主キーを変更することによる REPLACE ステートメントへの影響 </b>
        テーブルの主キーを変更することが望ましい場合があります (<a class="xref" href="partitioning.html#partitioning-limitations-partitioning-keys-unique-keys" title="19.6.1 パーティショニングキー、主キー、および一意キー">セクション19.6.1「パーティショニングキー、主キー、および一意キー」</a>を参照してください)。<code class="literal">REPLACE</code> ステートメントを使用するアプリケーションでこれを行うと、これらのステートメントの結果が大きく変わることがあることを認識してください。詳細および例については、<a class="xref" href="sql-syntax.html#replace" title="13.2.8 REPLACE 構文">セクション13.2.8「REPLACE 構文」</a>を参照してください。
      </p><p><b>FULLTEXT インデックス </b><a class="indexterm" name="idm139979014206208"></a>
        パーティション化されたテーブルは、<code class="literal">InnoDB</code> または <code class="literal">MyISAM</code> ストレージエンジンを使用するパーティション化されたテーブルでも、<code class="literal">FULLTEXT</code> インデックスまたは検索をサポートしません。
      </p><p><b>空間カラム </b>
        <code class="literal">POINT</code>、<code class="literal">GEOMETRY</code> などの空間データ型を持つカラムは、パーティション化されたテーブルで使用できません。
      </p><p><b>一時テーブル </b><a class="indexterm" name="idm139979014197008"></a>
        一時テーブルはパーティション化できません (Bug #17497)。
      </p><p><b>ログテーブル </b>
        ログテーブルをパーティション化することはできません。そのようなテーブルに <code class="literal">ALTER TABLE ... PARTITION BY ...</code> ステートメントを実行すると、エラーで失敗します。
      </p><p><b>パーティショニングキーのデータ型 </b><a class="indexterm" name="idm139979014190608"></a>
        パーティショニングキーは、整数カラム、または整数に解決される式である必要があります。<code class="literal">ENUM</code> カラムを使用する式は使用できません。カラムまたは式値は <code class="literal">NULL</code> でもかまいません(<a class="xref" href="partitioning.html#partitioning-handling-nulls" title="19.2.7 MySQL パーティショニングによる NULL の扱い">セクション19.2.7「MySQL パーティショニングによる NULL の扱い」</a>を参照してください)。
      </p><p>
      この制約には 2 つの例外があります。
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          <code class="literal">[LINEAR] KEY</code> によってパーティショニングするときは、<code class="literal">TEXT</code> または <code class="literal">BLOB</code> 以外の有効な MySQL データ型のカラムをパーティショニングキーとして使用できます。MySQL の内部キーハッシュ関数によって、これらの型から正しいデータ型が生成されるためです。たとえば、次の 2 つの <code class="literal">CREATE TABLE</code> ステートメントは有効です。
        </p><pre class="programlisting">
CREATE TABLE tkc (c1 CHAR)
PARTITION BY KEY(c1)
PARTITIONS 4;

CREATE TABLE tke 
    ( c1 ENUM('red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet') ) 
PARTITION BY LINEAR KEY(c1) 
PARTITIONS 6;
</pre></li><li class="listitem"><p>
          <code class="literal">RANGE COLUMNS</code> または <code class="literal">LIST COLUMNS</code> によってパーティショニングするときは、文字列、<code class="literal">DATE</code>、および <code class="literal">DATETIME</code> カラムを使用できます。たとえば、次の各 <code class="literal">CREATE TABLE</code> ステートメントは有効です。
        </p><pre class="programlisting">
CREATE TABLE rc (c1 INT, c2 DATE)
PARTITION BY RANGE COLUMNS(c2) (
    PARTITION p0 VALUES LESS THAN('1990-01-01'),
    PARTITION p1 VALUES LESS THAN('1995-01-01'),
    PARTITION p2 VALUES LESS THAN('2000-01-01'),
    PARTITION p3 VALUES LESS THAN('2005-01-01'),
    PARTITION p4 VALUES LESS THAN(MAXVALUE)
);

CREATE TABLE lc (c1 INT, c2 CHAR(1))
PARTITION BY LIST COLUMNS(c2) (
    PARTITION p0 VALUES IN('a', 'd', 'g', 'j', 'm', 'p', 's', 'v', 'y'),
    PARTITION p1 VALUES IN('b', 'e', 'h', 'k', 'n', 'q', 't', 'w', 'z'),
    PARTITION p2 VALUES IN('c', 'f', 'i', 'l', 'o', 'r', 'u', 'x', NULL)
);
</pre></li></ol></div><p>
      上記の例外は、<code class="literal">BLOB</code> または <code class="literal">TEXT</code> カラム型には該当しません。
    </p><p><b>サブクエリー </b><a class="indexterm" name="idm139979014166992"></a>
        パーティショニングキーはサブクエリーにできません (そのサブクエリーが整数値または <code class="literal">NULL</code> に解決される場合でも)。
      </p><p><a name="partitioning-limitations-subpartitions"></a><b>サブパーティションに関する問題 </b><a class="indexterm" name="idm139979014162112"></a><a class="indexterm" name="idm139979014159952"></a>
        サブパーティションは <code class="literal">HASH</code> または <code class="literal">KEY</code> パーティショニングを使用する必要があります。サブパーティション化できるのは <code class="literal">RANGE</code> および <code class="literal">LIST</code> パーティションのみです。<code class="literal">HASH</code> および <code class="literal">KEY</code> パーティションはサブパーティション化できません。
      </p><p>
      <a class="indexterm" name="idm139979014152464"></a> 現在のところ、<code class="literal">SUBPARTITION BY KEY</code> にはサブパーティショニングカラムを明示的に指定する必要がありますが、<code class="literal">PARTITION BY KEY</code> の場合は省略できます (その場合、テーブルの主キーカラムがデフォルトで使用されます)、次のステートメントによって作成されたテーブルがあるとします。
    </p><pre class="programlisting">
CREATE TABLE ts (
    id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(30)
);
</pre><p>
      次のようなステートメントを使用することで、<code class="literal">KEY</code> によってパーティション化された、同じカラムを持つテーブルを作成できます。
    </p><pre class="programlisting">
CREATE TABLE ts (
    id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(30)
)
PARTITION BY KEY() 
PARTITIONS 4;
        </pre><p>
      前のステートメントは、次のように記述されているかのように扱われます (テーブルの主キーカラムがパーティショニングカラムとして使用されます)。
    </p><pre class="programlisting">
CREATE TABLE ts (
    id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(30)
)
PARTITION BY KEY(id) 
PARTITIONS 4;
        </pre><p>
      ただし、次のステートメントは、デフォルトカラムをサブパーティショニングカラムとして使用するサブパーティション化されたテーブルを作成しようとするため失敗します。このステートメントが成功するには次のようにカラムを指定する必要があります。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE ts (</code></strong>
    -&gt;     <strong class="userinput"><code>id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,</code></strong>
    -&gt;     <strong class="userinput"><code>name VARCHAR(30)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY RANGE(id)</code></strong>
    -&gt; <strong class="userinput"><code>SUBPARTITION BY KEY()</code></strong>
    -&gt; <strong class="userinput"><code>SUBPARTITIONS 4</code></strong>
    -&gt; <strong class="userinput"><code>(</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (100),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (MAXVALUE)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
<span class="errortext">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that 
corresponds to your MySQL server version for the right syntax to use near ')</span>

mysql&gt; <strong class="userinput"><code>CREATE TABLE ts (</code></strong>
    -&gt;     <strong class="userinput"><code>id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,</code></strong>
    -&gt;     <strong class="userinput"><code>name VARCHAR(30)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY RANGE(id)</code></strong>
    -&gt; <strong class="userinput"><code>SUBPARTITION BY KEY(id)</code></strong>
    -&gt; <strong class="userinput"><code>SUBPARTITIONS 4</code></strong>
    -&gt; <strong class="userinput"><code>(</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (100),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (MAXVALUE)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.07 sec)
</pre><p>
      これは既知の問題です (Bug #51470 を参照してください)。
    </p><p><b>DELAYED オプションがサポートされない </b>
        <code class="literal">INSERT DELAYED</code> を使用してパーティション化されたテーブルに行を挿入することはサポートされません。これを試みるとエラーで失敗します。
      </p><p><b>DATA DIRECTORY および INDEX DIRECTORY オプション </b>
        <code class="literal">DATA DIRECTORY</code> および <code class="literal">INDEX DIRECTORY</code> は、パーティション化されたテーブルで使用するときに次の制限が適用されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          テーブルレベル <code class="literal">DATA DIRECTORY</code> および <code class="literal">INDEX DIRECTORY</code> オプションは無視されます (Bug #32091 を参照してください)。
        </p></li><li class="listitem"><p>
          Windows では、<code class="literal">DATA DIRECTORY</code> および <code class="literal">INDEX DIRECTORY</code> オプションは、<code class="literal">MyISAM</code> テーブルの個々のパーティションまたはサブパーティションでサポートされません (Bug #30459)。ただし、<code class="literal">InnoDB</code> テーブルの個々のパーティションまたはサブパーティションには <code class="literal">DATA DIRECTORY</code> を使用できます。
        </p></li></ul></div><p><b>パーティション化されたテーブルを修復および再構築する </b>
        ステートメント <code class="literal">CHECK TABLE</code>、<code class="literal">OPTIMIZE TABLE</code>、<code class="literal">ANALYZE TABLE</code>、および <code class="literal">REPAIR TABLE</code> がパーティション化されたテーブルでサポートされます。
      </p><p>
      また、<code class="literal">ALTER TABLE ... REBUILD PARTITION</code> を使用することで、パーティション化されたテーブルの 1 つ以上のパーティションを再構築できます。<code class="literal">ALTER TABLE ... REORGANIZE PARTITION</code> でもパーティションが再構築されます。これら 2 つのステートメントの詳細については、<a class="xref" href="sql-syntax.html#alter-table" title="13.1.7 ALTER TABLE 構文">セクション13.1.7「ALTER TABLE 構文」</a>を参照してください。
    </p><p>
      <span class="command"><strong>mysqlcheck</strong></span>、<span class="command"><strong>myisamchk</strong></span>、および <span class="command"><strong>myisampack</strong></span> はパーティション化されたテーブルでサポートされません。
    </p><p><b>FOR EXPORT オプション (FLUSH TABLES) </b>
        <code class="literal">FLUSH TABLES</code> ステートメントの <code class="literal">FOR EXPORT</code> オプションは、MySQL 5.6.16 以前のパーティション化された <code class="literal">InnoDB</code> テーブルでサポートされません (Bug #16943907)。
      </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="partitioning-limitations-partitioning-keys-unique-keys"></a>19.6.1 パーティショニングキー、主キー、および一意キー</h3></div></div></div><a class="indexterm" name="idm139979014094320"></a><a class="indexterm" name="idm139979014092864"></a><a class="indexterm" name="idm139979014090768"></a><a class="indexterm" name="idm139979014089344"></a><a class="indexterm" name="idm139979014087248"></a><p>
        このセクションでは、パーティショニングキーと主キーおよび一意キーとの関係について説明します。この関係を制御するルールは次のように表現できます。パーティション化されたテーブルのパーティショニング式で使用されるすべてのカラムは、テーブルが持つことができるすべての一意キーの一部である必要があります。
      </p><p>
        つまり、<span class="emphasis"><em>テーブルのすべての一意キーは、テーブルのパーティショニング式内のすべてのカラムを使用する必要があります</em></span>(これには、テーブルの主キーも含まれます (自明で一意キーであるため)。この点については、このセクションで後述します)。たとえば、次の各テーブル作成ステートメントは無効です。
      </p><pre class="programlisting">
CREATE TABLE t1 (
    col1 INT NOT NULL,
    col2 DATE NOT NULL,
    col3 INT NOT NULL,
    col4 INT NOT NULL,
    UNIQUE KEY (col1, col2)
)
PARTITION BY HASH(col3)
PARTITIONS 4;

CREATE TABLE t2 (
    col1 INT NOT NULL,
    col2 DATE NOT NULL,
    col3 INT NOT NULL,
    col4 INT NOT NULL,
    UNIQUE KEY (col1),
    UNIQUE KEY (col3)
)
PARTITION BY HASH(col1 + col3)
PARTITIONS 4;
</pre><p>
        どちらの場合も、記述されたテーブルには、パーティショニング式に使用されているすべてのカラムを含んでいない一意キーが少なくとも 1 つあります。
      </p><p>
        次の各ステートメントは有効で、対応する無効なテーブル作成ステートメントを機能させる 1 つの方法を示しています。
      </p><pre class="programlisting">
CREATE TABLE t1 (
    col1 INT NOT NULL,
    col2 DATE NOT NULL,
    col3 INT NOT NULL,
    col4 INT NOT NULL,
    UNIQUE KEY (col1, col2, col3)
)
PARTITION BY HASH(col3)
PARTITIONS 4;

CREATE TABLE t2 (
    col1 INT NOT NULL,
    col2 DATE NOT NULL,
    col3 INT NOT NULL,
    col4 INT NOT NULL,
    UNIQUE KEY (col1, col3)
)
PARTITION BY HASH(col1 + col3)
PARTITIONS 4;
</pre><p>
        次の例は、そのような場合に生成されるエラーを示しています。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE t3 (</code></strong>
    -&gt;     <strong class="userinput"><code>col1 INT NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>col2 DATE NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>col3 INT NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>col4 INT NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>UNIQUE KEY (col1, col2),</code></strong>
    -&gt;     <strong class="userinput"><code>UNIQUE KEY (col3)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY HASH(col1 + col3)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITIONS 4;</code></strong>
<span class="errortext">ERROR 1491 (HY000): A PRIMARY KEY must include all columns in the table's partitioning function</span>
</pre><p>
        この <code class="literal">CREATE TABLE</code> ステートメントは、指定されたパーティショニングキーに <code class="literal">col1</code> および <code class="literal">col3</code> が含まれているけれども、これらのカラムのいずれもテーブルの両方の一意キーの一部でないために、失敗します。無効なテーブル定義の考えられる解決策の 1 つを次に示します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE t3 (</code></strong>
    -&gt;     <strong class="userinput"><code>col1 INT NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>col2 DATE NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>col3 INT NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>col4 INT NOT NULL,</code></strong>
    -&gt;     <strong class="userinput"><code>UNIQUE KEY (col1, col2, col3),</code></strong>
    -&gt;     <strong class="userinput"><code>UNIQUE KEY (col3)</code></strong>
    -&gt; <strong class="userinput"><code>)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITION BY HASH(col3)</code></strong>
    -&gt; <strong class="userinput"><code>PARTITIONS 4;</code></strong>
Query OK, 0 rows affected (0.05 sec)
</pre><p>
        この場合、指定されたパーティショニングキー <code class="literal">col3</code> は両方の一意キーの一部であるため、このテーブル作成ステートメントは成功します。
      </p><p>
        次のテーブルは、両方の一意キーに属するカラムをパーティショニングキーに含めることができないため、パーティション化できません。
      </p><pre class="programlisting">
CREATE TABLE t4 (
    col1 INT NOT NULL,
    col2 INT NOT NULL,
    col3 INT NOT NULL,
    col4 INT NOT NULL,
    UNIQUE KEY (col1, col3),
    UNIQUE KEY (col2, col4)
);
</pre><p>
        すべての主キーは自明で一意キーであるため、この制約にはテーブルの主キーも含まれます (ある場合)。たとえば、次の 2 つのステートメントは無効です。
      </p><pre class="programlisting">
CREATE TABLE t5 (
    col1 INT NOT NULL,
    col2 DATE NOT NULL,
    col3 INT NOT NULL,
    col4 INT NOT NULL,
    PRIMARY KEY(col1, col2)
)
PARTITION BY HASH(col3)
PARTITIONS 4;

CREATE TABLE t6 (
    col1 INT NOT NULL,
    col2 DATE NOT NULL,
    col3 INT NOT NULL,
    col4 INT NOT NULL,
    PRIMARY KEY(col1, col3),
    UNIQUE KEY(col2)
)
PARTITION BY HASH( YEAR(col2) )
PARTITIONS 4;
</pre><p>
        どちらの場合も、パーティショニング式で参照されるすべてのカラムが主キーに含まれていません。ただし、次の 2 つのステートメントは両方とも有効です。
      </p><pre class="programlisting">
CREATE TABLE t7 (
    col1 INT NOT NULL,
    col2 DATE NOT NULL,
    col3 INT NOT NULL,
    col4 INT NOT NULL,
    PRIMARY KEY(col1, col2)
)
PARTITION BY HASH(col1 + YEAR(col2))
PARTITIONS 4;

CREATE TABLE t8 (
    col1 INT NOT NULL,
    col2 DATE NOT NULL,
    col3 INT NOT NULL,
    col4 INT NOT NULL,
    PRIMARY KEY(col1, col2, col4),
    UNIQUE KEY(col2, col1)
)
PARTITION BY HASH(col1 + YEAR(col2))
PARTITIONS 4;
</pre><p>
        テーブルに一意キーがない場合 (主キーがない場合を含む) はこの制約は適用されず、カラム型がパーティショニングタイプと互換性があるかぎり、パーティショニング式に任意のカラムを使用できます。
      </p><p>
        同じ理由で、テーブルのパーティショニング式で使用されるすべてのカラムが一意キーに含まれている場合を除き、パーティション化されたテーブルにあとから一意キーを追加することはできません。次のように作成されたパーティション化されたテーブルがあるとします。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE t_no_pk (c1 INT, c2 INT)</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION BY RANGE(c1) (</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p0 VALUES LESS THAN (10),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p1 VALUES LESS THAN (20),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p2 VALUES LESS THAN (30),</code></strong>
    -&gt;         <strong class="userinput"><code>PARTITION p3 VALUES LESS THAN (40)</code></strong>
    -&gt;     <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.12 sec)
</pre><p>
        次のいずれかの <code class="literal">ALTER TABLE</code> ステートメントを使用することで、<code class="literal">t_no_pk</code> に主キーを追加できます。
      </p><pre class="programlisting">
#  possible PK
mysql&gt; <strong class="userinput"><code>ALTER TABLE t_no_pk ADD PRIMARY KEY(c1);</code></strong>
Query OK, 0 rows affected (0.13 sec)
Records: 0  Duplicates: 0  Warnings: 0

# drop this PK
mysql&gt; <strong class="userinput"><code>ALTER TABLE t_no_pk DROP PRIMARY KEY;</code></strong>
Query OK, 0 rows affected (0.10 sec)
Records: 0  Duplicates: 0  Warnings: 0

#  use another possible PK
mysql&gt; <strong class="userinput"><code>ALTER TABLE t_no_pk ADD PRIMARY KEY(c1, c2);</code></strong>
Query OK, 0 rows affected (0.12 sec)
Records: 0  Duplicates: 0  Warnings: 0

# drop this PK
mysql&gt; <strong class="userinput"><code>ALTER TABLE t_no_pk DROP PRIMARY KEY;</code></strong>
Query OK, 0 rows affected (0.09 sec)
Records: 0  Duplicates: 0  Warnings: 0
</pre><p>
        ただし、次のステートメントは失敗します。<code class="literal">c1</code> は、パーティショニングキーの一部ですが、指定された主キーの一部ではないためです。
      </p><pre class="programlisting">
#  fails with error 1503
mysql&gt; <strong class="userinput"><code>ALTER TABLE t_no_pk ADD PRIMARY KEY(c2);</code></strong>
<span class="errortext">ERROR 1503 (HY000): A PRIMARY KEY must include all columns in the table's partitioning function</span>
</pre><p>
        <code class="literal">t_no_pk</code> のパーティショニング式は <code class="literal">c1</code> のみであるため、<code class="literal">c2</code> のみに一意キーを追加しようとすると失敗します。ただし、<code class="literal">c1</code> および <code class="literal">c2</code> の両方を使用する一意キーは追加できます。
      </p><p>
        これらのルールは、既存のパーティション化されていないテーブルを <code class="literal">ALTER TABLE ... PARTITION BY</code> を使用してパーティション化するときにも適用されます。次のように作成されたテーブル <code class="literal">np_pk</code> があるとします。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE np_pk (</code></strong>
    -&gt;     <strong class="userinput"><code>id INT NOT NULL AUTO_INCREMENT,</code></strong>
    -&gt;     <strong class="userinput"><code>name VARCHAR(50),</code></strong>
    -&gt;     <strong class="userinput"><code>added DATE,</code></strong>
    -&gt;     <strong class="userinput"><code>PRIMARY KEY (id)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
Query OK, 0 rows affected (0.08 sec)
</pre><p>
        次の <code class="literal">ALTER TABLE</code> ステートメントは、<code class="literal">added</code> カラムがテーブルの一意キーの一部でないため、エラーで失敗します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>ALTER TABLE np_pk</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION BY HASH( TO_DAYS(added) )</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITIONS 4;</code></strong>
<span class="errortext">ERROR 1503 (HY000): A PRIMARY KEY must include all columns in the table's partitioning function</span>
</pre><p>
        ただし、次に示すように、パーティショニングカラムに <code class="literal">id</code> カラムを使用する次のステートメントは有効です。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>ALTER TABLE np_pk</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION BY HASH(id)</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITIONS 4;</code></strong>
Query OK, 0 rows affected (0.11 sec)
Records: 0  Duplicates: 0  Warnings: 0
</pre><p>
        <code class="literal">np_pk</code> の場合、パーティショニング式の一部として使用できる唯一のカラムは <code class="literal">id</code> です。このテーブルをパーティショニング式でほかのカラムを使用してパーティション化する場合は、目的のカラムを主キーに追加するか、主キーをすべて削除することによって、まずテーブルを変更する必要があります。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="partitioning-limitations-storage-engines"></a>19.6.2 ストレージエンジンに関連するパーティショニング制限</h3></div></div></div><a class="indexterm" name="idm139979014006544"></a><p>
        次の制限は、テーブルのユーザー定義パーティショニングでストレージエンジンを使用する際に適用されます。
      </p><p><b>MERGE ストレージエンジン </b>
          ユーザー定義パーティショニングと <code class="literal">MERGE</code> ストレージエンジンは互換性を持ちません。<code class="literal">MERGE</code> ストレージエンジンを使用するテーブルはパーティション化できません。パーティション化されたテーブルはマージできません。
        </p><p><b>FEDERATED ストレージエンジン </b>
          <code class="literal">FEDERATED</code> テーブルのパーティショニングはサポートされません。パーティション化された <code class="literal">FEDERATED</code> テーブルを作成することはできません。
        </p><p><b>CSV ストレージエンジン </b>
          <code class="literal">CSV</code> ストレージエンジンを使用するパーティション化されたテーブルはサポートされません。パーティション化された <code class="literal">CSV</code> テーブルを作成することはできません。
        </p><p><b>InnoDB ストレージエンジン </b>
          <code class="literal">InnoDB</code> 外部キーと MySQL パーティショニングは互換性を持ちません。パーティション化された <code class="literal">InnoDB</code> テーブルは、外部キー参照を持つことができず、外部キーによって参照されるカラムを持つこともできません。外部キーを持っていたり、外部キーによって参照されたりする <code class="literal">InnoDB</code> テーブルはパーティション化できません。
        </p><p>
        また、<code class="literal">ALTER TABLE ... OPTIMIZE PARTITION</code> は、<code class="literal">InnoDB</code> ストレージエンジンを使用するパーティション化されたテーブルで正しく動作しません。そのようなテーブルの場合は、代わりに <code class="literal">ALTER TABLE ... REBUILD PARTITION</code> および <code class="literal">ALTER TABLE ... ANALYZE PARTITION</code> を使用してください。詳細は、<a class="xref" href="sql-syntax.html#alter-table-partition-operations" title="13.1.7.1 ALTER TABLE パーティション操作">セクション13.1.7.1「ALTER TABLE パーティション操作」</a>を参照してください。
      </p><p><b>NDB ストレージエンジン (MySQL Cluster) </b>
          <code class="literal">KEY</code> (<code class="literal">LINEAR KEY</code> を含む) によるパーティショニングは、<code class="literal">NDB</code> ストレージエンジンでサポートされる唯一のパーティショニングタイプです。MySQL Cluster NDB 7.3 では、[<code class="literal">LINEAR</code>] <code class="literal">KEY</code> 以外のパーティショニングタイプを使用して MySQL Cluster テーブルを作成することはできず、それを試みるとエラーで失敗します。
        </p><p>
        また、<code class="literal">NDB</code> テーブルに定義できる最大パーティション数は、クラスター内のデータノードとノードグループの数、使用している MySQL Cluster ソフトウェアのバージョン、およびその他の要因に依存します。詳細は、<a class="xref" href="mysql-cluster.html#mysql-cluster-nodes-groups-user-partitioning" title="NDB とユーザー定義のパーティション化">NDB とユーザー定義のパーティション化</a>を参照してください。
      </p><p>
        ユーザーパーティション化された <code class="literal">NDB</code> テーブルが次の 2 つの要件のいずれかまたは両方を満たさなくなる <code class="literal">CREATE TABLE</code> ステートメントおよび <code class="literal">ALTER TABLE</code> ステートメントは許可されず、エラーで失敗します。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            テーブルに明示的な主キーが存在する必要があります。
          </p></li><li class="listitem"><p>
            テーブルのパーティショニング式に指定されたすべてのカラムが主キーの一部である必要があります。
          </p></li></ol></div><p><b>例外 </b>
          ユーザーパーティション化された <code class="literal">NDB</code> テーブルが空のカラムリストを使用して (つまり、<code class="literal">PARTITION BY KEY()</code> または <code class="literal">PARTITION BY LINEAR KEY()</code> を使用して) 作成された場合、明示的な主キーは必要ありません。
        </p><p><b>パーティション化されたテーブルをアップグレードする </b>
          アップグレードを実行するときに、<code class="literal">KEY</code> によってパーティション化され、<code class="literal">NDB</code> 以外のストレージエンジンを使用するテーブルは、ダンプしてリロードする必要があります。
        </p><p><b>すべてのパーティションに同じストレージエンジン </b>
          パーティション化されたテーブルのすべてのパーティションは、同じストレージエンジンを使用する必要があり、それがテーブルが全体として使用する同じストレージエンジンである必要があります。また、テーブルレベルでエンジンを指定しない場合は、パーティション化されたテーブルを作成または変更するときに次のいずれかを行う必要があります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <span class="emphasis"><em>任意</em></span>のパーティションまたはサブパーティションにエンジンを指定<span class="emphasis"><em>しない</em></span>
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>すべて</em></span>のパーティションまたはサブパーティションにエンジンを指定する
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="partitioning-limitations-functions"></a>19.6.3 関数に関連するパーティショニング制限</h3></div></div></div><p>
        このセクションでは特に、パーティショニング式で使用される関数に関連する、MySQL パーティショニングの制限について説明します。
      </p><a class="indexterm" name="idm139979013954912"></a><p>
        次の表に示されている MySQL 関数のみがパーティショニング式で許可されます。
      </p><div class="informaltable"><table summary="この表は、MySQL 5.6 のパーティショニング式で許可される関数を一覧します。関数は、3 カラムテーブル形式、アルファベット順で左から右に提示されます。" border="1"><colgroup><col><col><col></colgroup><tbody><tr><td scope="row"><code class="literal">ABS()</code></td><td><code class="literal">CEILING()</code> (<a class="xref" href="partitioning.html#partitioning-limitations-ceiling-floor" title="CEILING() および FLOOR()">CEILING() および FLOOR()</a>を参照してください)</td><td><code class="literal">DAY()</code></td></tr><tr><td scope="row"><code class="literal">DAYOFMONTH()</code></td><td><code class="literal">DAYOFWEEK()</code></td><td><code class="literal">DAYOFYEAR()</code></td></tr><tr><td scope="row"><code class="literal">DATEDIFF()</code></td><td><code class="literal">EXTRACT()</code> (<a class="xref" href="partitioning.html#partitioning-limitations-extract" title="WEEK 指定子付きの EXTRACT() 関数">WEEK 指定子付きの EXTRACT() 関数</a>を参照してください)</td><td><code class="literal">FLOOR()</code> (<a class="xref" href="partitioning.html#partitioning-limitations-ceiling-floor" title="CEILING() および FLOOR()">CEILING() および FLOOR()</a>を参照してください)</td></tr><tr><td scope="row"><code class="literal">HOUR()</code></td><td><code class="literal">MICROSECOND()</code></td><td><code class="literal">MINUTE()</code></td></tr><tr><td scope="row"><code class="literal">MOD()</code></td><td><code class="literal">MONTH()</code></td><td><code class="literal">QUARTER()</code></td></tr><tr><td scope="row"><code class="literal">SECOND()</code></td><td><code class="literal">TIME_TO_SEC()</code></td><td><code class="literal">TO_DAYS()</code></td></tr><tr><td scope="row"><code class="literal">TO_SECONDS()</code></td><td><code class="literal">UNIX_TIMESTAMP()</code> (<code class="literal">TIMESTAMP</code> カラムで、MySQL 5.6.1 から許可され、MySQL 5.6.3 から完全にサポートされています)</td><td><code class="literal">WEEKDAY()</code></td></tr><tr><td scope="row"><code class="literal">YEAR()</code></td><td> </td><td><code class="literal">YEARWEEK()</code></td></tr></tbody></table></div><p>
        MySQL 5.6 では、<code class="literal">TO_DAYS()</code>、<code class="literal">TO_SECONDS()</code>、および <code class="literal">YEAR()</code> 関数で範囲最適化を使用できます。また、MySQL 5.6.3 以降では、<code class="literal">UNIX_TIMESTAMP()</code> はパーティショニング式で単調として扱われます。詳細は、<a class="xref" href="partitioning.html#partitioning-pruning" title="19.4 パーティションプルーニング">セクション19.4「パーティションプルーニング」</a>を参照してください。
      </p><p><a name="partitioning-limitations-ceiling-floor"></a><b>CEILING() および FLOOR() </b>
          これらの各関数は、正確な数値型 (<code class="literal">INT</code> 型または <code class="literal">DECIMAL</code> 型のいずれかなど) の引数を渡された場合にのみ整数を返します。これはたとえば、次の <code class="literal">CREATE TABLE</code> ステートメントがここで示すようにエラーで失敗することを意味します。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE t (c FLOAT) PARTITION BY LIST( FLOOR(c) )(</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p0 VALUES IN (1,3,5),</code></strong>
    -&gt;     <strong class="userinput"><code>PARTITION p1 VALUES IN (2,4,6)</code></strong>
    -&gt; <strong class="userinput"><code>);</code></strong>
<span class="errortext">ERROR 1490 (HY000): The PARTITION function returns the wrong type</span>
</pre><p><a name="partitioning-limitations-extract"></a><b>WEEK 指定子付きの EXTRACT() 関数 </b>
          <code class="literal">EXTRACT()</code> 関数によって返される値は、<code class="literal">EXTRACT(WEEK FROM <em class="replaceable"><code>col</code></em>)</code> として使用されるときに、<code class="literal">default_week_format</code> システム変数の値に依存します。このため、MySQL 5.6.2 以降では、<code class="literal">EXTRACT()</code> は、単位を <code class="literal">WEEK</code> として指定するときに、パーティショニング関数として許可されなくなりました (Bug #54483)。
        </p><p>
        これらの関数の戻り型についての詳細は、<a class="xref" href="functions.html#mathematical-functions" title="12.6.2 数学関数">セクション12.6.2「数学関数」</a>および<a class="xref" href="data-types.html#numeric-types" title="11.2 数値型">セクション11.2「数値型」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="partitioning-limitations-locking"></a>19.6.4 パーティショニングとロック</h3></div></div></div><p>
        MySQL 5.6.5 以前では、DML または DDL ステートメントを実行するときにテーブルレベルロックを実際に実行する <code class="literal">MyISAM</code> などのストレージエンジンの場合、パーティション化されたテーブルに影響するそのようなステートメントがテーブルに全体としてロックを適用していました。つまり、ステートメントが完了するまですべてのパーティションがロックされました。MySQL 5.6.6 は<em class="firstterm">パーティションロックプルーニング</em>を実装し、これによって多くの場合に不必要なロックが排除されます。MySQL 5.6.6 以降では、パーティション化された <code class="literal">MyISAM</code> テーブルに対して読み取りまたは更新を行うほとんどのステートメントで、影響を受けるパーティションのみがロックされます。たとえば、MySQL 5.6.6 より前は、パーティション化 <code class="literal">MyISAM</code> テーブルからの <code class="literal">SELECT</code> でテーブル全体がロックされました。MySQL 5.6.6 以降は、<code class="literal">SELECT</code> ステートメントの <code class="literal">WHERE</code> 条件を満たす行を実際に含むパーティションのみがロックされます。これには、パーティション化された <code class="literal">MyISAM</code> テーブルに対する同時操作の速度および効率を向上させる効果があります。この改善は、多く (32 以上) のパーティションを持つ <code class="literal">MyISAM</code> テーブルを操作するときに特に顕著になります。
      </p><p>
        この動作の変更は、行レベルロックを使用し、パーティションプルーニングの前にロックを実際に実行しない (または実行する必要がない)、<code class="literal">InnoDB</code> などのストレージエンジンを使用するパーティション化されたテーブルに影響するステートメントには影響しません。
      </p><p>
        次のいくつかの段落では、テーブルレベルロックを使用するストレージエンジンを使用するテーブルに対する、さまざまな MySQL ステートメントへのパーティションロックプルーニングの影響について説明します。
      </p><h4><a name="idm139979013877888"></a>DML ステートメントへの影響</h4><p>
        <code class="literal">SELECT</code> ステートメント (union または join を含むものを含む) が、実際に読み取る必要があるパーティションのみをロックするようになります。これは <code class="literal">SELECT ... PARTITION</code> にも適用されます。
      </p><p>
        <code class="literal">UPDATE</code> は、パーティショニングカラムが更新されないテーブルにのみロックをプルーニングします。
      </p><p>
        <code class="literal">REPLACE</code> および <code class="literal">INSERT</code> は、挿入または交換される行を持つパーティションのみをロックするようになります。ただし、<code class="literal">AUTO_INCREMENT</code> 値がパーティショニングカラム用に生成される場合は、すべてのパーティションがロックされます。
      </p><p>
        <code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> は、パーティショニングカラムが更新されないかぎりプルーニングされます。
      </p><p>
        <code class="literal">INSERT ... SELECT</code> は、読み取る必要があるソーステーブル内のパーティションのみをロックするようになります (ターゲットテーブル内のすべてのパーティションはロックされます)。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">INSERT DELAYED</code> はパーティション化されたテーブルではサポートされません。
        </p></div><p>
        <code class="literal">LOAD DATA</code> ステートメントによってパーティション化されたテーブルに適用されるロックはプルーニングできません。
      </p><p>
        パーティション化されたテーブルのパーティショニングカラムを使用する <code class="literal">BEFORE INSERT</code> または <code class="literal">BEFORE UPDATE</code> トリガーが存在する場合は、このテーブルを更新する <code class="literal">INSERT</code> および <code class="literal">UPDATE</code> ステートメントでのロックをプルーニングできないことを意味します (トリガーがその値を変更する可能性があるため)。テーブルのパーティショニングカラムに対する <code class="literal">BEFORE INSERT</code> トリガーが存在する場合は、<code class="literal">INSERT</code> または <code class="literal">REPLACE</code> によって設定されるロックをプルーニングできないことを意味します (<code class="literal">BEFORE INSERT</code> トリガーが、行が挿入される前に行のパーティショニングカラムを変更し、それによって行が本来のものとは異なるパーティションに強制的に挿入される可能性があるため)。パーティショニングカラムでの <code class="literal">BEFORE UPDATE</code> トリガーは、<code class="literal">UPDATE</code> または <code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> によって適用されるロックをプルーニングできないことを意味します。
      </p><h4><a name="idm139979013851152"></a>影響を受ける DDL ステートメント</h4><p>
        <code class="literal">CREATE VIEW</code> でロックが行われなくなります。
      </p><p>
        <code class="literal">ALTER TABLE ... EXCHANGE PARTITION</code> がロックをプルーニングするようになります。交換されるテーブルおよび交換されるパーティションのみがロックされます。
      </p><p>
        <code class="literal">ALTER TABLE ... TRUNCATE PARTITION</code> がロックがプルーニングするようになります。空にされるパーティションのみがロックされます。
      </p><p>
        <code class="literal">ALTER TABLE</code> ステートメントは引き続きテーブルレベルでメタデータロックを行います。
      </p><h4><a name="idm139979013843376"></a>その他のステートメント</h4><p>
        <code class="literal">LOCK TABLES</code> はパーティションロックをプルーニングできません。
      </p><p>
        <code class="literal">CALL stored_procedure(<em class="replaceable"><code>expr</code></em>)</code> はロックプルーニングをサポートしますが、<em class="replaceable"><code>expr</code></em> を評価する際はしません。
      </p><p>
        <code class="literal">DO</code> および <code class="literal">SET</code> ステートメントはパーティショニングロックプルーニングをサポートしません。
      </p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="mysql-cluster.html">前</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="stored-programs-views.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第 18 章 MySQL Cluster NDB 7.3 および MySQL Cluster NDB 7.4 </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 第 20 章 ストアドプログラムおよびビュー</td></tr></table></div><div class="copyright-footer"></div></body></html>
