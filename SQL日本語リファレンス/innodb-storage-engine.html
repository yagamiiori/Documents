<html lang="ja"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>第 14 章 InnoDB ストレージエンジン</title><link rel="stylesheet" type="text/css" href="mvl.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="MySQL 5.6 リファレンスマニュアル"><link rel="up" href="index.html" title="MySQL 5.6 リファレンスマニュアル"><link rel="prev" href="sql-syntax.html" title="第 13 章 SQL ステートメントの構文"><link rel="next" href="storage-engines.html" title="第 15 章 代替ストレージエンジン">
<script language="javascript" type="text/javascript">
  function addOnload(theFunc)
  {
    var previous = window.onload;
    if (typeof window.onload != 'function')
    {
      window.onload = theFunc;
    }
    else
    {
      window.onload = function()
      {
        previous();
        theFunc();
      }
    }
  }

  addOnload(function()
  {
    var base = new Date(1442918127*1000);
    var now = new Date();
    var diff = ((now-base)/1000)/(24*3600);

    if (diff > 90) {
      var nodes = document.getElementsByClassName('titlepage');
      nodes[0].innerHTML = '<p style="border: 5px #ff0000 solid; padding: 5px; margin 5px">' +
        'This copy of the manual is more than 90 days old. We encourage you to download a ' +
        'new version from <a href="http://dev.mysql.com">dev.mysql.com/doc</a>.</p>' + nodes[0].innerHTML;
    }
  });
</script>
<noscript></noscript>
</head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第 14 章 InnoDB ストレージエンジン</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="sql-syntax.html">前</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="storage-engines.html">次へ</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="innodb-storage-engine"></a>第 14 章 InnoDB ストレージエンジン</h1></div></div></div><div class="toc"><p><b>目次</b></p><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-introduction">14.1 InnoDB 入門</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-default-se">14.1.1 デフォルトの MySQL ストレージエンジンとしての InnoDB</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-check-availability">14.1.2 InnoDB の可用性チェック</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-turning-off">14.1.3 InnoDB の無効化</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-concepts">14.2 InnoDB の概念とアーキテクチャー</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#mysql-acid">14.2.1 MySQL および ACID モデル</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-transaction-model">14.2.2 InnoDB のトランザクションモデルおよびロック</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-lock-modes">14.2.3 InnoDB のロックモード</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-consistent-read">14.2.4 一貫性非ロック読み取り</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-locking-reads">14.2.5 ロック読み取り (SELECT ... FOR UPDATE および SELECT ... LOCK IN SHARE MODE)</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-record-level-locks">14.2.6 InnoDB のレコード、ギャップ、およびネクストキーロック</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-next-key-locking">14.2.7 ネクストキーロックによるファントム問題の回避</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-locks-set">14.2.8 InnoDB のさまざまな SQL ステートメントで設定されたロック</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-implicit-commit">14.2.9 暗黙的なトランザクションコミットとロールバック</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-deadlock-detection">14.2.10 デッドロックの検出とロールバック</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-deadlocks">14.2.11 デッドロックの対処方法</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-multi-versioning">14.2.12 InnoDB マルチバージョン</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-table-and-index">14.2.13 InnoDB テーブルおよびインデックスの構造</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-configuration">14.3 InnoDB の構成</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-read-only-instance">14.3.1 読み取り専用操作用の InnoDB の構成</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-administration">14.4 InnoDB の管理</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-tablespace">14.5 InnoDB テーブルスペース管理</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-init">14.5.1 InnoDB テーブルスペースの作成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-multiple-tablespaces">14.5.2 InnoDB File-Per-Table モード</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#tablespace-enabling">14.5.3 File-Per-Table モードの有効化および無効化</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#tablespace-placing">14.5.4 テーブルスペースの位置の指定</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#tablespace-copying">14.5.5 テーブルスペースの別のサーバーへのコピー (トランスポータブルテーブルスペース)</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-undo-tablespace">14.5.6 個別のテーブルスペースへの InnoDB Undo ログの格納</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-data-log-reconfiguration">14.5.7 InnoDB ログファイルの数またはサイズの変更、および InnoDB テーブルスペースのサイズの変更</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-raw-devices">14.5.8 共有テーブルスペースでの RAW ディスクパーティションの使用</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-tables">14.6 InnoDB テーブルの管理</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#using-innodb-tables">14.6.1 InnoDB テーブルの作成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-migration">14.6.2 別のマシンへの InnoDB テーブルの移動またはコピー</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-transactions-with-different-apis">14.6.3 トランザクションを使用した DML 操作のグループ化</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#converting-tables-to-innodb">14.6.4 MyISAM から InnoDB へのテーブルの変換</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-auto-increment-handling">14.6.5 InnoDB での AUTO_INCREMENT 処理</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-foreign-key-constraints">14.6.6 InnoDB と FOREIGN KEY 制約</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-restrictions">14.6.7 InnoDB テーブル上の制限</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-compression">14.7 InnoDB 圧縮テーブル</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-compression-background">14.7.1 テーブル圧縮の概要</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-compression-usage">14.7.2 テーブル圧縮の有効化</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-compression-tuning">14.7.3 InnoDB テーブルの圧縮の調整</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-compression-tuning-monitoring">14.7.4 実行時の圧縮のモニタリング</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-compression-internals">14.7.5 InnoDB テーブルでの圧縮の動作</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-compression-oltp">14.7.6 OLTP ワークロードの圧縮</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-compression-syntax-warnings">14.7.7 SQL 圧縮構文の警告とエラー</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-format">14.8 InnoDB のファイル形式管理</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-format-enabling">14.8.1 ファイル形式の有効化</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-format-compatibility">14.8.2 ファイル形式の互換性の確認</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-format-identifying">14.8.3 使用されているファイル形式の識別</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-format-downgrading">14.8.4 ファイル形式のダウングレード</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-format-future">14.8.5 将来の InnoDB ファイル形式</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-row-format">14.9 InnoDB の行ストレージと行フォーマット</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-row-format-overview">14.9.1 InnoDB 行ストレージの概要</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-row-format-specification">14.9.2 テーブルの行フォーマットの指定</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-row-format-dynamic">14.9.3 DYNAMIC および COMPRESSED 行フォーマット</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-row-format-antelope">14.9.4 COMPACT および REDUNDANT 行フォーマット</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-disk-management">14.10 InnoDB のディスク I/O とファイル領域管理</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-disk-io">14.10.1 InnoDB ディスク I/O</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-space">14.10.2 ファイル領域管理</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-checkpoints">14.10.3 InnoDB チェックポイント</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-defragmenting">14.10.4 テーブルのデフラグ</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-truncate-table-reclaim-space">14.10.5 TRUNCATE TABLE によるディスク領域の再利用</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-online-ddl">14.11 InnoDB とオンライン DDL</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-create-index-overview">14.11.1 オンライン DDL の概要</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-create-index-concurrency">14.11.2 オンライン DDL でのパフォーマンスと並列性に関する考慮事項</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-online-ddl-syntax">14.11.3 オンライン DDL の SQL 構文</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-online-ddl-single-multi">14.11.4 DDL ステートメントの結合または分離</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-create-index-examples">14.11.5 オンライン DDL の例</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-create-index-implementation">14.11.6 オンライン DDL の実装の詳細</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-create-index-recovery">14.11.7 オンライン DDL でのクラッシュリカバリの動作のしくみ</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#online-ddl-partitioning">14.11.8 パーティション化された InnoDB テーブルに対するオンライン DDL</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-create-index-limitations">14.11.9 オンライン DDL の制限</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-parameters">14.12 InnoDB の起動オプションおよびシステム変数</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance">14.13 InnoDB のパフォーマンス</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-buffer-pool">14.13.1 InnoDB バッファープールの構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-latching">14.13.2 InnoDB 相互排他ロックおよび読み取り/書き込みロックの実装</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-use_sys_malloc">14.13.3 InnoDB のためのメモリーアロケータの構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-change_buffering">14.13.4 InnoDB 変更バッファリングの構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-thread_concurrency">14.13.5 InnoDB のスレッド並列性の構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-multiple_io_threads">14.13.6 InnoDB バックグラウンド I/O スレッドの数の構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-group_commit">14.13.7 グループコミット</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-thread_io_rate">14.13.8 InnoDB マスタースレッドの I/O レートの構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-pause_instruction">14.13.9 InnoDB スピンループでの PAUSE 命令の使用</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-spin_lock_polling">14.13.10 スピンロックのポーリングの構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-schema">14.13.11 InnoDB の MySQL パフォーマンススキーマとの統合</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-multiple-rollback-segments">14.13.12 複数のロールバックセグメントによるスケーラビリティーの向上</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-improved-purge-scheduling">14.13.13 InnoDB のパージスケジューリングの構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-ro-txn">14.13.14 InnoDB の読み取り専用トランザクションの最適化</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-crc32-checksum">14.13.15 チェックサムの高速化のための CRC32 チェックサムアルゴリズムの使用</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-optimizer-statistics">14.13.16 オプティマイザ統計</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-analyze-table-complexity">14.13.17 InnoDB テーブルに対する ANALYZE TABLE の複雑さの推定</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema">14.14 InnoDB INFORMATION_SCHEMA テーブル</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-compression-tables">14.14.1 圧縮に関する InnoDB INFORMATION_SCHEMA テーブル</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-transactions">14.14.2 InnoDB INFORMATION_SCHEMA トランザクションおよびロックテーブル</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-system-tables">14.14.3 InnoDB INFORMATION_SCHEMA システムテーブル</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-fulltext_index-tables">14.14.4 InnoDB INFORMATION_SCHEMA FULLTEXT インデックステーブル</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-buffer-pool-tables">14.14.5 InnoDB INFORMATION_SCHEMA バッファープールテーブル</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-metrics-table">14.14.6 InnoDB INFORMATION_SCHEMA メトリックテーブル</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-monitors">14.15 InnoDB モニター</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-monitor-types">14.15.1 InnoDB モニターのタイプ</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-enabling-monitors">14.15.2 InnoDB モニターの有効化</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-standard-monitor">14.15.3 InnoDB 標準モニターおよびロックモニターの出力</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-tablespace-monitor">14.15.4 InnoDB テーブルスペースモニターの出力</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-table-monitor">14.15.5 InnoDB テーブルモニターの出力</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-backup">14.16 InnoDB のバックアップとリカバリ</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-recovery">14.16.1 InnoDB のリカバリプロセス</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-and-mysql-replication">14.17 InnoDB と MySQL レプリケーション</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached">14.18 InnoDB と memcached の統合</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-benefits">14.18.1 InnoDB と memcached の組み合わせの利点</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-intro">14.18.2 InnoDB および memcached の統合のアーキテクチャー</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-setup">14.18.3 InnoDB Memcached プラグインの概要</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-security">14.18.4 InnoDB memcached プラグインのセキュリティーに関する考慮事項</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-developing">14.18.5 InnoDB memcached インタフェース用のアプリケーションの作成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-replication">14.18.6 レプリケーションでの InnoDB memcached プラグインの使用</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-internals">14.18.7 InnoDB memcached プラグインの内部構造</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-troubleshoot">14.18.8 InnoDB memcached プラグインのトラブルシューティング</a></span></dt></dl></dd><dt><span class="section"><a href="innodb-storage-engine.html#innodb-troubleshooting">14.19 InnoDB のトラブルシューティング</a></span></dt><dd><dl><dt><span class="section"><a href="innodb-storage-engine.html#error-creating-innodb">14.19.1 InnoDB の I/O に関する問題のトラブルシューティング</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#forcing-innodb-recovery">14.19.2 InnoDB のリカバリの強制的な実行</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-troubleshooting-datadict">14.19.3 InnoDB データディクショナリの操作のトラブルシューティング</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-error-handling">14.19.4 InnoDB のエラー処理</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-error-codes">14.19.5 InnoDB のエラーコード</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#operating-system-error-codes">14.19.6 オペレーティングシステムのエラーコード</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-introduction"></a>14.1 InnoDB 入門</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-default-se">14.1.1 デフォルトの MySQL ストレージエンジンとしての InnoDB</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-check-availability">14.1.2 InnoDB の可用性チェック</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-turning-off">14.1.3 InnoDB の無効化</a></span></dt></dl></div><a class="indexterm" name="idm139979075622560"></a><a class="indexterm" name="idm139979075620528"></a><a class="indexterm" name="idm139979075619008"></a><a class="indexterm" name="idm139979075617088"></a><a class="indexterm" name="idm139979075615744"></a><a class="indexterm" name="idm139979075613568"></a><a class="indexterm" name="idm139979075612160"></a><a class="indexterm" name="idm139979075610928"></a><a class="indexterm" name="idm139979075609456"></a><p>
    <code class="literal">InnoDB</code> は、高い信頼性と高いパフォーマンスとのバランスをとる汎用のストレージエンジンです。MySQL 5.5 の時点では、これがデフォルトの MySQL ストレージエンジンです。MySQL 5.6 では、<code class="literal">ENGINE=</code> 句を指定せずに <code class="literal">CREATE TABLE</code> ステートメントを発行すると、<code class="literal">InnoDB</code> テーブルが作成されます。
  </p><h3><a name="idm139979075603952"></a>InnoDB の主要な利点</h3><p>
    <code class="literal">InnoDB</code> テーブルの主要な利点は、次のとおりです。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        その <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> 操作は、<a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a>にユーザーデータを保護するための<a class="link" href="glossary.html#glos_commit" title="コミット">コミット</a>、<a class="link" href="glossary.html#glos_rollback" title="ロールバック">ロールバック</a>、および<a class="link" href="glossary.html#glos_crash_recovery" title="クラッシュリカバリ">クラッシュリカバリ</a>機能が備わっている <a class="link" href="glossary.html#glos_acid" title="ACID">ACID</a> モデルに従っています。
      </p></li><li class="listitem"><p>
        行レベルの<a class="link" href="glossary.html#glos_locking" title="ロック">ロック</a>と Oracle スタイルの<a class="link" href="glossary.html#glos_consistent_read" title="一貫性読み取り">一貫性読み取り</a>を使用すると、複数ユーザーの並列性およびパフォーマンスが向上します。
      </p></li><li class="listitem"><p>
        <code class="literal">InnoDB</code> テーブルでは、<a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a>に基づいてクエリーが最適化されるように、ディスク上のデータが整列されます。
      </p></li><li class="listitem"><p>
        データの<a class="link" href="glossary.html#glos_referential_integrity" title="参照整合性">整合性</a>を保つために、<code class="literal">InnoDB</code> では <a class="link" href="glossary.html#glos_foreign_key" title="外部キー"><code class="literal">FOREIGN KEY</code></a> 制約もサポートされています。挿入、更新、および削除によってさまざまなテーブル間で不整合が発生しないかを確認するために、これらの操作がすべてチェックされます。
      </p></li><li class="listitem"><p>
        同じステートメント内でも、<code class="literal">InnoDB</code> のテーブルと別の MySQL ストレージエンジンのテーブルを混在させることができます。たとえば、<a class="link" href="glossary.html#glos_join" title="結合">結合</a>操作を使用すると、単一のクエリーで <code class="literal">InnoDB</code> テーブルと <code class="literal">MEMORY</code> テーブルのデータを結合できます。
      </p></li><li class="listitem"><p>
        <code class="literal">InnoDB</code> は、大きなデータボリュームを処理する際に、高い CPU の効率性と最大のパフォーマンスが実現されるように設計されています。
      </p></li></ul></div><div class="table"><a name="idm139979075579936"></a><p class="title"><b>表 14.1 InnoDB ストレージエンジンの機能</b></p><div class="table-contents"><table summary="InnoDB ストレージエンジンの機能" border="1"><colgroup><col class="featurev0"><col class="featurevalue0"><col class="featurev1"><col class="featurevalue1"><col class="featurev2"><col class="featurevalue2"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>ストレージの制限</strong></span></td><td>64T バイト</td><td><span class="bold"><strong>トランザクション</strong></span></td><td>はい</td><td><span class="bold"><strong>ロック粒度</strong></span></td><td>行</td></tr><tr><td scope="row"><span class="bold"><strong>MVCC</strong></span></td><td>はい</td><td><span class="bold"><strong>地理空間データ型のサポート</strong></span></td><td>はい</td><td><span class="bold"><strong>地理空間インデックスのサポート</strong></span></td><td>はい<a href="#ftn.idm139979075567328" class="footnote" name="idm139979075567328"><sup class="footnote">[a]</sup></a></td></tr><tr><td scope="row"><span class="bold"><strong>B ツリーインデックス</strong></span></td><td>はい</td><td><span class="bold"><strong>T ツリーインデックス</strong></span></td><td>いいえ</td><td><span class="bold"><strong>ハッシュインデックス</strong></span></td><td>いいえ<a href="#ftn.idm139979075562800" class="footnote" name="idm139979075562800"><sup class="footnote">[b]</sup></a></td></tr><tr><td scope="row"><span class="bold"><strong>全文検索インデックス</strong></span></td><td>はい<a href="#ftn.idm139979075560736" class="footnote" name="idm139979075560736"><sup class="footnote">[c]</sup></a></td><td><span class="bold"><strong>クラスタ化されたインデックス</strong></span></td><td>はい</td><td><span class="bold"><strong>データキャッシュ</strong></span></td><td>はい</td></tr><tr><td scope="row"><span class="bold"><strong>インデックスキャッシュ</strong></span></td><td>はい</td><td><span class="bold"><strong>圧縮データ</strong></span></td><td>はい<a href="#ftn.idm139979075555024" class="footnote" name="idm139979075555024"><sup class="footnote">[d]</sup></a></td><td><span class="bold"><strong>暗号化データ<a href="#ftn.idm139979075553696" class="footnote" name="idm139979075553696"><sup class="footnote">[e]</sup></a></strong></span></td><td>はい</td></tr><tr><td scope="row"><span class="bold"><strong>クラスタデータベースのサポート</strong></span></td><td>いいえ</td><td><span class="bold"><strong>レプリケーションのサポート<a href="#ftn.idm139979075550544" class="footnote" name="idm139979075550544"><sup class="footnote">[f]</sup></a></strong></span></td><td>はい</td><td><span class="bold"><strong>外部キーのサポート</strong></span></td><td>はい</td></tr><tr><td scope="row"><span class="bold"><strong>バックアップ/ポイントインタイムリカバリ<a href="#ftn.idm139979075547408" class="footnote" name="idm139979075547408"><sup class="footnote">[g]</sup></a></strong></span></td><td>はい</td><td><span class="bold"><strong>クエリーキャッシュのサポート</strong></span></td><td>はい</td><td><span class="bold"><strong>データディクショナリ向け更新統計</strong></span></td><td>はい</td></tr></tbody><tbody class="footnotes"><tr><td colspan="6"><div id="ftn.idm139979075567328" class="footnote"><p><a href="#idm139979075567328" class="para"><sup class="para">[a] </sup></a>InnoDB の地理空間インデックスサポートは MySQL 5.7.5 以降で使用できます。</p></div><div id="ftn.idm139979075562800" class="footnote"><p><a href="#idm139979075562800" class="para"><sup class="para">[b] </sup></a>InnoDB は、アダプティブハッシュインデックス機能に対して、内部的にハッシュインデックスを利用します。</p></div><div id="ftn.idm139979075560736" class="footnote"><p><a href="#idm139979075560736" class="para"><sup class="para">[c] </sup></a>InnoDB の FULLTEXT インデックスサポートは MySQL 5.6.4 以降で使用できます。</p></div><div id="ftn.idm139979075555024" class="footnote"><p><a href="#idm139979075555024" class="para"><sup class="para">[d] </sup></a>圧縮された InnoDB テーブルは InnoDB Barracuda ファイルフォーマットを必要とします。</p></div><div id="ftn.idm139979075553696" class="footnote"><p><a href="#idm139979075553696" class="para"><sup class="para">[e] </sup></a>ストレージエンジン内ではなくサーバー内で (暗号化関数を使って) 実装されています。</p></div><div id="ftn.idm139979075550544" class="footnote"><p><a href="#idm139979075550544" class="para"><sup class="para">[f] </sup></a>ストレージエンジン内ではなくサーバー内で実装されています。</p></div><div id="ftn.idm139979075547408" class="footnote"><p><a href="#idm139979075547408" class="para"><sup class="para">[g] </sup></a>ストレージエンジン内ではなくサーバー内で実装されています。</p></div></td></tr></tbody></table></div></div><br class="table-break"><p>
    <code class="literal">InnoDB</code> ストレージエンジンには、データとインデックスをメインメモリーにキャッシュするための独自の<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>が保持されています。デフォルトでは、<code class="literal">innodb_file_per_table</code> 設定が有効になっているため、新しい各 <code class="literal">InnoDB</code> テーブルとそれに関連付けられたインデックスが個別のファイルに格納されます。<code class="literal">innodb_file_per_table</code> オプションを無効にすると、<code class="literal">InnoDB</code> ではそのテーブルとインデックスがすべて単一の<a class="link" href="glossary.html#glos_tablespace" title="テーブルスペース">システムテーブルスペース</a>に格納されます。システムテーブルスペースは、複数のファイル (または生のディスクパーティション) で構成されている場合があります。<code class="literal">InnoDB</code> テーブルは、ファイルサイズが 2G バイトに制限されているオペレーティングシステム上でも、大量のデータを処理できます。
  </p><p>
    <code class="literal">InnoDB</code> の機能と MySQL で提供されているその他のストレージエンジンを比較する方法については、<a class="xref" href="storage-engines.html" title="第 15 章 代替ストレージエンジン">第15章「<i>代替ストレージエンジン</i>」</a>の<span class="emphasis"><em>「ストレージエンジンの機能」</em></span>表を参照してください。
  </p><h3><a name="idm139979075532896"></a>InnoDB の拡張機能と新機能</h3><p>
    MySQL 5.6 での <code class="literal">InnoDB</code> の拡張機能と新機能については、次を参照してください。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="literal">InnoDB</code> の拡張機能については、<a class="xref" href="introduction.html#mysql-nutshell" title="1.4 MySQL 5.6 の新機能">セクション1.4「MySQL 5.6 の新機能」</a>に一覧表示されています。ここでは、MySQL 5.6 で追加された機能の概要が示されています。
      </p></li><li class="listitem"><p>
        <a class="ulink" href="http://dev.mysql.com/doc/relnotes/mysql/5.6/en/" target="_top">リリースノート</a>。ここでは、各バージョンでの変更に関する情報が提供されています。
      </p></li></ul></div><h3><a name="idm139979075526528"></a>追加のリソース</h3><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="literal">InnoDB</code> 関連の用語および定義については、<a class="xref" href="glossary.html" title="MySQL 用語集">MySQL 用語集</a>を参照してください。
      </p></li><li class="listitem"><p>
        <code class="literal">InnoDB</code> ストレージエンジン専用のフォーラムには、<a class="ulink" href="http://forums.mysql.com/list.php?22" target="_top">MySQL Forums::InnoDB</a> からアクセスできます。
      </p></li><li class="listitem"><p>
        <code class="literal">InnoDB</code> は、MySQL と同じ GNU GPL ライセンスバージョン 2 (1991 年 6 月) によって発行されています。MySQL ライセンスの詳細は、<a class="ulink" href="http://www.mysql.com/company/legal/licensing/" target="_top">http://www.mysql.com/company/legal/licensing/</a>を参照してください。
      </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-default-se"></a>14.1.1 デフォルトの MySQL ストレージエンジンとしての InnoDB</h3></div></div></div><a class="indexterm" name="idm139979075517264"></a><a class="indexterm" name="idm139979075515088"></a><a class="indexterm" name="idm139979075512944"></a><p>
    MySQL は、使いやすく、高いパフォーマンスと拡張性を実現するという評価を勝ち得ています。MySQL 5.5 よりも前では、<code class="literal">MyISAM</code> がデフォルトのストレージエンジンでした。我々の経験上、ほとんどのユーザーはデフォルト設定を変更しませんでした。MySQL 5.5 以上では、<code class="literal">InnoDB</code> がデフォルトのストレージエンジンです。やはりほとんどのユーザーがデフォルト設定を変更しないと予想されます。ただし、<code class="literal">InnoDB</code> を使用すれば、デフォルト設定でもユーザーが RDBMS から期待する利点 (<a class="link" href="glossary.html#glos_acid" title="ACID">ACID</a> トランザクション、<a class="link" href="glossary.html#glos_referential_integrity" title="参照整合性">参照整合性</a>、および<a class="link" href="glossary.html#glos_crash_recovery" title="クラッシュリカバリ">クラッシュリカバリ</a>) が得られます。<code class="literal">InnoDB</code> テーブルを使用して MySQL ユーザー、DBA、または開発者としての生活を改善する方法を探ってみましょう。
  </p><h4><a name="idm139979075503728"></a>ストレージエンジンの使用傾向</h4><p>
    MySQL の成長期の 1 年目には、初期の Web ベースのアプリケーションによって並列性と可用性の限界が押し広げられることはありませんでした。近年では、ハードドライブやメモリーの容量および価格性能比がすべて向上しています。MySQL のパフォーマンスの限界を押し広げているユーザーは、信頼性やクラッシュリカバリに多くの関心を持っています。MySQL データベースは、大規模で、高負荷で、強固で、分散型で、重要です。
  </p><p>
    <code class="literal">InnoDB</code> は、このようなユーザーの最優先事項に対処します。ストレージエンジンの使用傾向は、より拡張可能な <code class="literal">InnoDB</code> の方へシフトしています。したがって、MySQL 5.5 は、<code class="literal">InnoDB</code> をデフォルトのストレージエンジンにするための論理遷移リリースでした。
  </p><p>
    MySQL は、以前は <code class="literal">MyISAM</code> テーブルが必要だったユースケースへの対処に取り組み続けています。MySQL 5.6 以上には、次のような特性があります。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="literal">InnoDB</code> は、<code class="literal">FULLTEXT</code> インデックスタイプを使用した全文検索を実行できます。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-fulltext-index" title="14.2.13.3 FULLTEXT インデックス">セクション14.2.13.3「FULLTEXT インデックス」</a>を参照してください。
      </p></li><li class="listitem"><p>
        <code class="literal">InnoDB</code> は、読み取り専用または読み取りが大半のワークロードで、より適切に機能するようになりました。<a class="link" href="glossary.html#glos_autocommit" title="自動コミット">自動コミット</a>モードでは、<code class="literal">InnoDB</code> クエリーに自動的な最適化が適用され、<code class="literal">START TRANSACTION READ ONLY</code> という構文を使用すると、読み取り専用としてトランザクションに明示的にマークできます。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-ro-txn" title="14.13.14 InnoDB の読み取り専用トランザクションの最適化">セクション14.13.14「InnoDB の読み取り専用トランザクションの最適化」</a>を参照してください。
      </p></li><li class="listitem"><p>
        読み取り専用メディア上に配布されたアプリケーションでは、<code class="literal">InnoDB</code> テーブルが使用されるようになりました。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-read-only-instance" title="14.3.1 読み取り専用操作用の InnoDB の構成">セクション14.3.1「読み取り専用操作用の InnoDB の構成」</a>を参照してください。
      </p></li></ul></div><h4><a name="idm139979075486240"></a>デフォルトの MySQL ストレージエンジンとしての InnoDB の重要性</h4><p>
    MySQL 5.5.5 以降、新しいテーブル用のデフォルトのストレージエンジンは <code class="literal">InnoDB</code> です。この変更は、新たに作成されたテーブルの中で、<code class="literal">ENGINE=MyISAM</code> などの句を使用してストレージエンジンが指定されていないものに適用されます。このようにデフォルトの動作を変更すると、MySQL 5.5 は、<code class="literal">MyISAM</code> が使用されているテーブルが <code class="literal">InnoDB</code> に切り替えることによる利点を得られるかどうかを評価するための論理ポイントになる可能性があります。
  </p><p>
    MySQL 内部仕様の一部が実装されている <code class="literal">mysql</code> および <code class="literal">information_schema</code> データベースでは、引き続き <code class="literal">MyISAM</code> が使用されます。特に、付与テーブルを切り替えても、<code class="literal">InnoDB</code> を使用できません。
  </p><h4><a name="idm139979075477424"></a>InnoDB テーブルの利点</h4><p>
    <code class="literal">MyISAM</code> テーブルを使用しているが、技術的な理由でそれらに関与していない場合は、<code class="literal">InnoDB</code> テーブルを使用すると、さらに便利な点が数多く見つかるでしょう。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        ハードウェアまたはソフトウェアの問題が原因でサーバーがクラッシュした場合でも、その時点でデータベースに何が発生していたのかには関係なく、データベースの再起動後に特別なことは何もする必要がありません。<code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_crash_recovery" title="クラッシュリカバリ">クラッシュリカバリ</a>を使用すると自動的に、クラッシュ時の前にコミットされた変更はすべて完了し、処理中だったがコミットされなかった変更はすべて取り消されます。単に再起動し、終了した場所から続行するだけです。このプロセスは、MySQL 5.1 以前よりも大幅に高速になりました。
      </p></li><li class="listitem"><p>
        テーブルおよびインデックスのデータにアクセスすると、そのデータは <code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>にキャッシュされます。頻繁に使用されるデータは、直接メモリーから処理されます。このキャッシュは非常に数多くのタイプの情報に適用され、これにより処理速度が大幅に上がります。その結果、専用のデータベースサーバーでは、最大で物理メモリーの 80% が <code class="literal">InnoDB</code> のバッファープールに割り当てられます。
      </p></li><li class="listitem"><p>
        関連データをさまざまなテーブルに分割すると、強制的に<a class="link" href="glossary.html#glos_referential_integrity" title="参照整合性">参照整合性</a>が適用される<a class="link" href="glossary.html#glos_foreign_key" title="外部キー">外部キー</a>を設定できます。データを更新または削除すると、ほかのテーブル内の関連データも自動的に更新または削除されます。プライマリテーブル内に対応するデータが存在しないセカンダリテーブルにデータを挿入しようとすると、自動的に不正なデータが除外されます。
      </p></li><li class="listitem"><p>
        ディスク上またはメモリー内のデータが破損した場合は、偽のデータを使用する前に、<a class="link" href="glossary.html#glos_checksum" title="チェックサム">チェックサム</a>メカニズムによって警告が発行されます。
      </p></li><li class="listitem"><p>
        テーブルごとに適切な<a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a>カラムを持つデータベースを設計すると、これらのカラムが関与する操作が自動的に最適化されます。<code class="literal">WHERE</code> 句、<code class="literal">ORDER BY</code> 句、<code class="literal">GROUP BY</code> 句、および<a class="link" href="glossary.html#glos_join" title="結合">結合</a>操作では、主キーカラムへの参照が非常に高速です。
      </p></li><li class="listitem"><p>
        挿入、更新、および削除は、<a class="link" href="glossary.html#glos_change_buffering" title="変更バッファリング">変更バッファリング</a>と呼ばれる自動化メカニズムによって最適化されます。<code class="literal">InnoDB</code> では、同じテーブルへの並列読み取りおよび書き込みアクセスが許可されているだけでなく、ディスク I/O が効率化されるように変更されたデータがキャッシュに入れられます。
      </p></li><li class="listitem"><p>
        パフォーマンスの利点は、長時間実行されるクエリーを含む巨大なテーブルだけに限定されません。同じ行が 1 つのテーブルから何度もアクセスされると、<a class="link" href="glossary.html#glos_adaptive_hash_index" title="適応型ハッシュインデックス">適応型ハッシュインデックス</a>と呼ばれる機能に引き継がれ、ハッシュテーブルから読み取られたかのように、これらの検索がさらに高速になります。
      </p></li></ul></div><h4><a name="idm139979075450880"></a>InnoDB テーブルのベストプラクティス</h4><p>
    長期間 <code class="literal">InnoDB</code> を使用していれば、すでにトランザクションや外部キーなどの機能について理解できています。そうでない場合は、この章全体でこれらについて参照してください。手短に言えば、次のとおりです。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        もっとも頻繁にクエリーが実行されるカラム (複数の場合あり) を使用しているすべてのテーブルに、<a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a>を指定します。明示的な主キーが存在しない場合は、<a class="link" href="glossary.html#glos_auto_increment" title="自動インクリメント">自動インクリメント</a>値を指定します。
      </p></li><li class="listitem"><p>
        複数のテーブルにある同じ ID 値に基づいて、それらのテーブルからデータを抽出する場合は、<a class="link" href="glossary.html#glos_join" title="結合">結合</a>の概念を取り入れます。結合のパフォーマンスを高速にするには、結合カラム上に<a class="link" href="glossary.html#glos_foreign_key" title="外部キー">外部キー</a>を定義し、各テーブル内でそれらのカラムを同じデータ型で宣言します。また、外部キーを使用すると、影響を受けるすべてのテーブルに削除または更新が反映され、親テーブルに対応する ID が存在しない場合は、子テーブル内のデータの挿入が回避されます。
      </p></li><li class="listitem"><p>
        <a class="link" href="glossary.html#glos_autocommit" title="自動コミット">自動コミット</a>をオフにします。1 秒間に何百回もコミットすると、パフォーマンスに上限が設定されます (これは、ストレージデバイスの書き込み速度で制限されます)。
      </p></li><li class="listitem"><p>
        関連する <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> 操作のセットを <code class="literal">START TRANSACTION</code> と <code class="literal">COMMIT</code> ステートメントで囲むことで、<a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a>にグループ化します。頻繁にはコミットしたくない一方で、コミットなしで何時間も実行される <code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、または <code class="literal">DELETE</code> ステートメントの巨大なバッチも発生させたくありません。
      </p></li><li class="listitem"><p>
        <code class="literal">LOCK TABLE</code> ステートメントの使用を停止します。<code class="literal">InnoDB</code> は、一度に同じテーブルへのすべての読み取りおよび書き込みを行うことで、信頼性や高パフォーマンスを犠牲にせずに、複数のセッションを処理できます。行のセットへの排他的な書き込みアクセス権を取得するには、<code class="literal">SELECT ... FOR UPDATE</code> という構文を使用して、更新対象の行のみをロックします。
      </p></li><li class="listitem"><p>
        <code class="literal">innodb_file_per_table</code> オプションを有効にして、単一の巨大な<a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">システムテーブルスペース</a>内の代わりに、個別のファイルに各テーブル用のデータおよびインデックスを配置します。この設定は、テーブルの<a class="link" href="glossary.html#glos_compression" title="圧縮">圧縮</a>および高速の<a class="link" href="glossary.html#glos_truncate" title="切り捨て">切り捨て</a>などのその他の機能の一部を使用する際に必要となります。
      </p></li><li class="listitem"><p>
        使用中のデータおよびアクセスパターンによって、<code class="literal">CREATE TABLE</code> ステートメントで新しい <code class="literal">InnoDB</code> テーブルの<a class="link" href="glossary.html#glos_compression" title="圧縮">圧縮</a>機能 (<code class="literal">ROW_FORMAT=COMPRESSED</code>) からの利点が得られるかどうかを評価します。読み取りおよび書き込みの機能を犠牲にせずに、<code class="literal">InnoDB</code> テーブルを圧縮できます。
      </p></li><li class="listitem"><p>
        オプション <code class="literal">--sql_mode=NO_ENGINE_SUBSTITUTION</code> を付けてサーバーを実行して、<code class="literal">CREATE TABLE</code> の <code class="literal">ENGINE=</code> 句で指定されたストレージエンジンで問題が発生した場合に、別のストレージエンジンを使用してテーブルが作成されないようにします。
      </p></li></ul></div><h4><a name="idm139979075416560"></a>InnoDB テーブルに対する最近の改善点</h4><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        テーブルおよび関連付けられたインデックスを圧縮できます。
      </p></li><li class="listitem"><p>
        以前よりも大幅に小さいパフォーマンスや可用性への影響度で、インデックスを作成および削除できます。
      </p></li><li class="listitem"><p>
        テーブルの切り捨てが大幅に高速になり、<code class="literal">InnoDB</code> でのみ再使用される可能性のあるシステムテーブルスペース内の領域を解放するのではなく、オペレーティングシステムで再使用されるディスク領域を解放できます。
      </p></li><li class="listitem"><p>
        <code class="literal">DYNAMIC</code> 行フォーマットを使用することで、テーブルデータのストレージレイアウトが BLOB および長いテキストフィールドでより効率的になりました。
      </p></li><li class="listitem"><p>
        <code class="literal">INFORMATION_SCHEMA</code> テーブルでクエリーを実行することで、ストレージエンジンの内部動作をモニターできます。
      </p></li><li class="listitem"><p>
        <code class="literal">performance_schema</code> テーブルでクエリーを実行することで、ストレージエンジンのパフォーマンスを詳細にモニターできます。
      </p></li><li class="listitem"><p>
        パフォーマンスに関して多くの改善点があります。特に、クラッシュリカバリ、つまりデータベースが再起動するときにすべてのデータを自動的に整合させる処理の速度および信頼性が向上しました (<code class="literal">InnoDB</code> ユーザーが従来経験してきた速度よりずっと高速です)。データベースが大きいほど、大幅に速度が向上します。
      </p><p>
        ほとんどの新しいパフォーマンス機能は自動的です。そうでない場合でも、必要なことは、多くても構成オプションの値を設定するだけです。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-performance" title="14.13 InnoDB のパフォーマンス">セクション14.13「InnoDB のパフォーマンス」</a>を参照してください。アプリケーションコードで適用できる <code class="literal">InnoDB</code> 固有のチューニング技術については、<a class="xref" href="optimization.html#optimizing-innodb" title="8.5 InnoDB テーブルの最適化">セクション8.5「InnoDB テーブルの最適化」</a>を参照してください。上級ユーザーは、<a class="xref" href="innodb-storage-engine.html#innodb-parameters" title="14.12 InnoDB の起動オプションおよびシステム変数">セクション14.12「InnoDB の起動オプションおよびシステム変数」</a>を再確認してください。
      </p></li></ul></div><h4><a name="idm139979075399504"></a>デフォルトのストレージエンジンとして InnoDB を使用したテストおよびベンチマーク</h4><p>
    MySQL 5.1 以前から MySQL 5.5 以降へのアップグレードが完了する前でも、データベースサーバーまたはアプリケーションでデフォルトのストレージエンジンとして、<code class="literal">InnoDB</code> が正常に動作するかどうかをプレビューできます。以前の MySQL リリースでデフォルトのストレージエンジンとして <code class="literal">InnoDB</code> を設定するには、コマンド行で <code class="literal">--default-storage-engine=InnoDB</code> を指定するか、または <code class="literal">my.cnf</code> ファイルの <code class="literal">[mysqld]</code> セクションに <code class="literal">default-storage-engine=innodb</code> を追加してから、サーバーを再起動します。
  </p><p>
    デフォルトのストレージエンジンを変更しても、新たに作成されたテーブルしか影響を受けないため、アプリケーションのインストールおよび設定ステップをすべて実行して、すべてが正しくインストールされたことを確認します。次に、すべてのアプリケーション機能を実行して、データのロード、編集、およびクエリー機能がすべて動作することを確認します。テーブルが一部の <code class="literal">MyISAM</code> 固有の機能に依存している場合は、エラーが受信されます。エラーを回避するには、<code class="literal">ENGINE=MyISAM</code> 句を <code class="literal">CREATE TABLE</code> ステートメントに追加します (たとえば、全文検索に依存するテーブルは <code class="literal">InnoDB</code> テーブルではなく、<code class="literal">MyISAM</code> テーブルにする必要があります)。
  </p><p>
    ストレージエンジンについて慎重な決定を行わなかった場合に、特定のテーブルが <code class="literal">InnoDB</code> で作成されたときにどのように動作するのかをプレビューするには、テーブルごとに <code class="literal">ALTER TABLE table_name ENGINE=InnoDB;</code> コマンドを発行します。また、元のテーブルを配布せずに、テストクエリーおよびその他のステートメントを実行するには、次のようなコピーを作成します。
  </p><pre class="programlisting">
CREATE TABLE InnoDB_Table (...) ENGINE=InnoDB AS SELECT * FROM MyISAM_Table;
        </pre><p>
    MySQL 5.5 以上には、非常に多くの <code class="literal">InnoDB</code> のパフォーマンス拡張機能があるため、現実的なワークロードで完全なアプリケーションを使用したときのパフォーマンスについて正確な考察を得るには、最新の MySQL サーバーをインストールして、ベンチマークを実行してください。
  </p><p>
    完全なアプリケーションのライフサイクル (インストールから頻繁な使用まで)、およびサーバーの再起動をテストします。電源障害のシミュレーションを行うために、データベースの負荷が高いときにサーバープロセスを強制終了し、サーバーの再起動時にデータが正常にリカバリされるかどうかを確認します。
  </p><p>
    特に、マスターおよびスレーブ上でさまざまな MySQL バージョンやオプションを使用している場合は、レプリケーション構成をテストします。
  </p><h4><a name="idm139979075380736"></a>InnoDB がデフォルトのストレージエンジンであるかどうかの確認</h4><p>
    古い MySQL を使用して what-if テストを行うのか、最新の MySQL を使用して包括的なテストを行うのかに関係なく、<code class="literal">InnoDB</code> のステータスを確認する方法は、次のとおりです。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="literal">SHOW ENGINES;</code> コマンドを発行して、さまざまな MySQL ストレージエンジンをすべて表示します。<code class="literal">InnoDB</code> 行で <code class="literal">DEFAULT</code> を探します。
      </p></li><li class="listitem"><p>
        <code class="literal">InnoDB</code> がまったく存在しない場合は、<code class="literal">InnoDB</code> のサポートなしでコンパイルされた <code class="literal">mysqld</code> バイナリがあるため、別のバイナリを入手する必要があります。
      </p></li><li class="listitem"><p>
        <code class="literal">InnoDB</code> は存在するが、無効になっている場合は、起動オプションおよび構成ファイルまで戻って、すべての <code class="literal">skip-innodb</code> オプションを削除します。
      </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-check-availability"></a>14.1.2 InnoDB の可用性チェック</h3></div></div></div><p>
      使用中のサーバーで <code class="literal">InnoDB</code> がサポートされているかどうかを確認するには、<code class="literal">SHOW ENGINES</code> ステートメントを使用します。(<code class="literal">InnoDB</code> はデフォルトの MySQL ストレージエンジンになったため、サポートされない可能性があるのは、非常に特殊な環境の場合だけです。)
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-turning-off"></a>14.1.3 InnoDB の無効化</h3></div></div></div><p>
      オラクルでは、ローカルシステム上で運用されている単一ユーザーの Wiki やブログから、パフォーマンスの限界を押し広げているハイエンドのアプリケーションまでの一般的なデータベースアプリケーションで優先されるストレージエンジンとして、<code class="literal">InnoDB</code> が推奨されています。MySQL 5.6 では、<code class="literal">InnoDB</code> が新しいテーブル用のデフォルトストレージエンジンです。
    </p><p>
      <code class="literal">InnoDB</code> テーブルを使用しない場合:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">InnoDB</code> ストレージエンジンを無効にするには、<code class="option">--innodb=OFF</code> または <code class="option">--skip-innodb</code> オプションを付けてサーバーを起動します。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            MySQL 5.6.21 の時点では、<code class="option">--skip-innodb</code> オプションは引き続き機能しますが、非推奨となったため、使用されると警告が返されます。これは今後の MySQL リリースで削除されます。これは、そのシノニム (<code class="option">--innodb=OFF</code> や <code class="option">--disable-innodb</code> など) にも適用されます。
          </p></div></li><li class="listitem"><p>
          デフォルトのストレージエンジンは <code class="literal">InnoDB</code> であるため、<code class="option">--default-storage-engine</code> および <code class="option">--default-tmp-storage-engine</code> を使用して、永続的なテーブルと <code class="literal">TEMPORARY</code> テーブルの両方についてデフォルトを別のエンジンに設定しないかぎり、サーバーは起動しません。
        </p></li><li class="listitem"><p>
          <a class="link" href="information-schema.html#innodb-i_s-tables" title="21.29 InnoDB の INFORMATION_SCHEMA テーブル"><code class="literal">InnoDB</code> 関連の <code class="literal">information_schema</code> テーブル</a>でクエリーが実行されるときに、サーバーがクラッシュすることを回避するには、それらのテーブルに関連付けられたプラグインも無効にします。MySQL 構成ファイルの <code class="literal">[mysqld]</code> セクションで、次のように指定します。
        </p><pre class="programlisting">
loose-innodb-trx=0 
loose-innodb-locks=0 
loose-innodb-lock-waits=0 
loose-innodb-cmp=0 
loose-innodb-cmp-per-index=0
loose-innodb-cmp-per-index-reset=0
loose-innodb-cmp-reset=0 
loose-innodb-cmpmem=0 
loose-innodb-cmpmem-reset=0 
loose-innodb-buffer-page=0 
loose-innodb-buffer-page-lru=0 
loose-innodb-buffer-pool-stats=0 
loose-innodb-metrics=0 
loose-innodb-ft-default-stopword=0 
loose-innodb-ft-inserted=0 
loose-innodb-ft-deleted=0 
loose-innodb-ft-being-deleted=0 
loose-innodb-ft-config=0 
loose-innodb-ft-index-cache=0 
loose-innodb-ft-index-table=0 
loose-innodb-sys-tables=0 
loose-innodb-sys-tablestats=0 
loose-innodb-sys-indexes=0 
loose-innodb-sys-columns=0 
loose-innodb-sys-fields=0 
loose-innodb-sys-foreign=0 
loose-innodb-sys-foreign-cols=0 
</pre></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-concepts"></a>14.2 InnoDB の概念とアーキテクチャー</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#mysql-acid">14.2.1 MySQL および ACID モデル</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-transaction-model">14.2.2 InnoDB のトランザクションモデルおよびロック</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-lock-modes">14.2.3 InnoDB のロックモード</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-consistent-read">14.2.4 一貫性非ロック読み取り</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-locking-reads">14.2.5 ロック読み取り (SELECT ... FOR UPDATE および SELECT ... LOCK IN SHARE MODE)</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-record-level-locks">14.2.6 InnoDB のレコード、ギャップ、およびネクストキーロック</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-next-key-locking">14.2.7 ネクストキーロックによるファントム問題の回避</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-locks-set">14.2.8 InnoDB のさまざまな SQL ステートメントで設定されたロック</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-implicit-commit">14.2.9 暗黙的なトランザクションコミットとロールバック</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-deadlock-detection">14.2.10 デッドロックの検出とロールバック</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-deadlocks">14.2.11 デッドロックの対処方法</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-multi-versioning">14.2.12 InnoDB マルチバージョン</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-table-and-index">14.2.13 InnoDB テーブルおよびインデックスの構造</a></span></dt></dl></div><p>
    このセクションの情報では、<code class="literal">InnoDB</code> テーブルを使用することで大部分のパフォーマンスおよび機能を取得する際に役立つバックグラウンドが提供されます。対象者は次のとおりです。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        使い慣れていると思われる機能と、まったく新しい機能を説明するために、別のデータベースシステムから MySQL に切り替えている任意のユーザー。
      </p></li><li class="listitem"><p>
        <code class="literal">InnoDB</code> がデフォルトの MySQL ストレージエンジンになったために、<code class="literal">MyISAM</code> テーブルから <code class="literal">InnoDB</code> に移行している任意のユーザー。
      </p></li><li class="listitem"><p>
        <code class="literal">InnoDB</code> テーブルの設計上の考慮事項、パフォーマンスの特性、および拡張性を詳細なレベルで理解するために、アプリケーションアーキテクチャーまたはソフトウェアスタックを検討している任意のユーザー。
      </p></li></ul></div><p>
    このセクションでは、次のことを学習します。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        どのくらい厳密に <code class="literal">InnoDB</code> が <a class="link" href="glossary.html#glos_acid" title="ACID">ACID</a> の原則に準拠しているのか。
      </p></li><li class="listitem"><p>
        どのように <code class="literal">InnoDB</code> が<a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a>を実装するのか、およびどのようにトランザクションの内部動作と、使い慣れているその他のデータベースシステムを比較するのか。
      </p></li><li class="listitem"><p>
        どのように <code class="literal">InnoDB</code> が、クエリーおよび DML ステートメントが同じテーブルの読み取りと書き込みを同時に実行できる<a class="link" href="glossary.html#glos_row_level_locking" title="行レベルロック">行レベルロック</a>を実装するのか。
      </p></li><li class="listitem"><p>
        マルチバージョン並列処理制御 (<a class="link" href="glossary.html#glos_mvcc" title="MVCC">MVCC</a>) によって、適切な時間になる前にトランザクションがその他の各データを表示または変更することがどのように回避されるのか。
      </p></li><li class="listitem"><p>
        ディスク上の <code class="literal">InnoDB</code> 関連のオブジェクト (<a class="link" href="glossary.html#glos_table" title="テーブル">テーブル</a>、<a class="link" href="glossary.html#glos_index" title="インデックス">インデックス</a>、<a class="link" href="glossary.html#glos_tablespace" title="テーブルスペース">テーブルスペース</a>、<a class="link" href="glossary.html#glos_undo_log" title="Undo ログ">Undo ログ</a>、および <a class="link" href="glossary.html#glos_redo_log" title="Redo ログ">Redo ログ</a>) の物理レイアウト。
      </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="mysql-acid"></a>14.2.1 MySQL および ACID モデル</h3></div></div></div><a class="indexterm" name="idm139979075314208"></a><p>
      <a class="link" href="glossary.html#glos_acid" title="ACID">ACID</a> モデルは、ビジネスデータおよびミッションクリティカルなアプリケーションで重要となる信頼性の側面が強調されたデータベース設計原則のセットです。ソフトウェアのクラッシュやハードウェアの誤動作などの例外的な状況でも、データが破損せず、結果が歪曲されないように、MySQL には、ACID モデルに厳密に準拠した <code class="literal">InnoDB</code> ストレージエンジンなどのコンポーネントが含まれています。ACID に準拠した機能に依存していれば、一貫性チェックおよびクラッシュリカバリのメカニズムを再開発する必要がありません。追加のソフトウェアの保護手段、信頼性が最高のハードウェア、または少量のデータ損失や不整合に耐えることができるアプリケーションが備わっている場合は、ACID の信頼性の一部と引き換えに、パフォーマンスやスループットが向上するように MySQL の設定を調整できます。
    </p><p>
      次のセクションでは、どのように MySQL の機能 (特に <code class="literal">InnoDB</code> ストレージエンジン) が ACID モデルのカテゴリとやりとりするのかについて説明します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <span class="bold"><strong>A</strong></span>: 原子性。
        </p></li><li class="listitem"><p>
          <span class="bold"><strong>C</strong></span>: 一貫性。
        </p></li><li class="listitem"><p>
          <span class="bold"><strong>I:</strong></span>: 分離性。
        </p></li><li class="listitem"><p>
          <span class="bold"><strong>D</strong></span>: 持続性。
        </p></li></ul></div><h4><a name="idm139979075301088"></a>原子性</h4><p>
      ACID モデルの<span class="bold"><strong>原子性</strong></span>の側面には、主に <code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a>が関与しています。関連する MySQL の機能は次のとおりです。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          自動コミット設定。
        </p></li><li class="listitem"><p>
          <code class="literal">COMMIT</code> ステートメント。
        </p></li><li class="listitem"><p>
          <code class="literal">ROLLBACK</code> ステートメント。
        </p></li><li class="listitem"><p>
          <code class="literal">INFORMATION_SCHEMA</code> テーブルの運用データ。
        </p></li></ul></div><h4><a name="idm139979075290880"></a>一貫性</h4><p>
      ACID モデルの<span class="bold"><strong>一貫性</strong></span>の側面には、主にクラッシュからデータを保護するための内部的な <code class="literal">InnoDB</code> 処理が関与しています。関連する MySQL の機能は次のとおりです。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_doublewrite_buffer" title="二重書き込みバッファー">二重書き込みバッファー</a>。
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_crash_recovery" title="クラッシュリカバリ">クラッシュリカバリ</a>。
        </p></li></ul></div><h4><a name="idm139979075283056"></a>分離性</h4><p>
      ACID モデルの<span class="bold"><strong>分離性</strong></span>の側面には、主に <code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a> (特に、各トランザクションに適用される<a class="link" href="glossary.html#glos_isolation_level" title="分離レベル">分離レベル</a>) が関与しています。関連する MySQL の機能は次のとおりです。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="link" href="glossary.html#glos_autocommit" title="自動コミット">自動コミット</a>設定。
        </p></li><li class="listitem"><p>
          <code class="literal">SET ISOLATION LEVEL</code> ステートメント。
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_locking" title="ロック">ロック</a>の低レベルの詳細。これらの詳細は、パフォーマンスチューニング時に <code class="literal">INFORMATION_SCHEMA</code> テーブルから参照します。
        </p></li></ul></div><h4><a name="idm139979075271840"></a>持続性</h4><p>
      ACID モデルの<span class="bold"><strong>持続性</strong></span>の側面には、特定のハードウェア構成とやりとりする MySQL ソフトウェアの機能が関与しています。CPU、ネットワーク、およびストレージデバイスの性能に応じて多くの可能性が考えられるため、具体的なガイドラインを示す際は、この側面がもっとも複雑になります。(これらのガイドラインに従うことは、<span class="quote">「<span class="quote">新しいハードウェア</span>」</span>を購入するという形になる場合があります。)関連する MySQL の機能は次のとおりです。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">innodb_doublewrite</code> 構成オプションでオンとオフが切り替えられる <code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_doublewrite_buffer" title="二重書き込みバッファー">二重書き込みバッファー</a>。
        </p></li><li class="listitem"><p>
          <code class="literal">innodb_flush_log_at_trx_commit</code> 構成オプション。
        </p></li><li class="listitem"><p>
          <code class="literal">sync_binlog</code> 構成オプション。
        </p></li><li class="listitem"><p>
          <code class="literal">innodb_file_per_table</code> 構成オプション。
        </p></li><li class="listitem"><p>
          ストレージデバイス内の書き込みバッファー (ディスクドライブ、SSD、RAID アレイなど)。
        </p></li><li class="listitem"><p>
          ストレージデバイス内のバッテリーでバックアップされるキャッシュ。
        </p></li><li class="listitem"><p>
          MySQL を実行する際に使用されるオペレーティングシステム (特に、<code class="literal">fsync()</code> システムコールでのサポート)。
        </p></li><li class="listitem"><p>
          MySQL サーバーを実行し、MySQL データを格納するすべてのコンピュータサーバーおよびストレージデバイスへの電力を保護する無停電電源装置 (UPS)。
        </p></li><li class="listitem"><p>
          バックアップ方針 (頻度、バックアップのタイプ、バックアップの保存期間など)。
        </p></li><li class="listitem"><p>
          分散型またはホスト型のデータアプリケーションの場合、MySQL サーバー用のハードウェアが配置されているデータセンター、およびデータセンター間のネットワーク接続の特定の特性。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-transaction-model"></a>14.2.2 InnoDB のトランザクションモデルおよびロック</h3></div></div></div><a class="indexterm" name="idm139979075249632"></a><a class="indexterm" name="idm139979075247504"></a><a class="indexterm" name="idm139979075245472"></a><a class="indexterm" name="idm139979075243408"></a><a class="indexterm" name="idm139979075242064"></a><p>
      <a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a>および<a class="link" href="glossary.html#glos_locking" title="ロック">ロック</a>は InnoDB ストレージエンジンに関連するため、大規模、高負荷、または高信頼性のデータベースアプリケーションを実装したり、別のデータベースシステムから大量のコードを移植したり、MySQL のパフォーマンスを調整したりするには、これらの概念を理解する必要があります。
    </p><p>
      <code class="literal">InnoDB</code> トランザクションモデルの目標は、マルチバージョンデータベースの最高の特性を従来の二相ロックと組み合わせることです。<code class="literal">InnoDB</code> は、行レベルでロックを行い、デフォルトではクエリーを Oracle 式の非ロックの一貫性読み取りとして実行します。<code class="literal">InnoDB</code> のロック情報は非常に高い空間効率で格納されるため、ロックのエスカレーションは必要ありません。一般に、何人かのユーザーは、<code class="literal">InnoDB</code> テーブル内のすべての行、または行のランダムなサブセットをロックすることが許可されています。これにより、<code class="literal">InnoDB</code> のメモリーが使い果たされることはありません。
    </p><p>
      <code class="literal">InnoDB</code> では、すべてのユーザーアクティビティーがトランザクション内部で発生します。自動コミットモードが有効になっている場合は、各 SQL ステートメント自体に単一のトランザクションが生成されます。MySQL は、デフォルトで新しい接続のセッション開始時に自動コミットを有効にするため、各 SQL ステートメントからエラーが返されなかった場合に、そのステートメントのあとでコミットを実行します。ステートメントからエラーが返された場合、コミットまたはロールバックの動作はそのエラーによって異なります。<a class="xref" href="innodb-storage-engine.html#innodb-error-handling" title="14.19.4 InnoDB のエラー処理">セクション14.19.4「InnoDB のエラー処理」</a>を参照してください。
    </p><p>
      自動コミットが有効になっているセッションでは、明示的な <code class="literal">START TRANSACTION</code> または <code class="literal">BEGIN</code> ステートメントで起動し、<code class="literal">COMMIT</code> または <code class="literal">ROLLBACK</code> ステートメントで終了することで、複数ステートメントのトランザクションを実行できます。<a class="xref" href="sql-syntax.html#commit" title="13.3.1 START TRANSACTION、COMMIT、および ROLLBACK 構文">セクション13.3.1「START TRANSACTION、COMMIT、および ROLLBACK 構文」</a>を参照してください。
    </p><p>
      <code class="literal">SET autocommit = 0</code> でセッション内の自動コミットモードを無効にすると、そのセッションでは常にトランザクションが開かれた状態になります。<code class="literal">COMMIT</code> または <code class="literal">ROLLBACK</code> ステートメントは現在のトランザクションを終了し、新しいセッションを開始します。
    </p><p>
      <code class="literal">COMMIT</code> は、現在のトランザクション内で行われた変更は永続的であり、その他のセッションから表示できることを意味します。反対に、<code class="literal">ROLLBACK</code> ステートメントは、現在のトランザクションによって行われたすべての変更を取り消します。<code class="literal">COMMIT</code> と <code class="literal">ROLLBACK</code> は両方とも、現在のトランザクション中に設定されたすべての <code class="literal">InnoDB</code> ロックを解除します。
    </p><p>
      SQL:1992 のトランザクション<a class="link" href="glossary.html#glos_isolation_level" title="分離レベル">分離レベル</a>に関しては、デフォルトの <code class="literal">InnoDB</code> レベルは <code class="literal">REPEATABLE READ</code> です。<code class="literal">InnoDB</code> では、SQL 標準に記載された 4 つのトランザクション分離レベル (<code class="literal">READ UNCOMMITTED</code>、<code class="literal">READ COMMITTED</code>、<code class="literal">REPEATABLE READ</code>、<code class="literal">SERIALIZABLE</code>) がすべて提供されます。
    </p><p>
      ユーザーは <code class="literal">SET TRANSACTION</code> ステートメントを使用して単一のセッションまたは後続のすべての接続の分離レベルを変更できます。すべての接続に対するサーバーのデフォルトの分離レベルを設定するには、コマンド行上、またはオプションファイル内で <code class="option">--transaction-isolation</code> オプションを使用します。分離レベルおよびレベル設定構文についての詳細は、<a class="xref" href="sql-syntax.html#set-transaction" title="13.3.6 SET TRANSACTION 構文">セクション13.3.6「SET TRANSACTION 構文」</a>を参照してください。
    </p><a class="indexterm" name="idm139979075199440"></a><a class="indexterm" name="idm139979075197296"></a><a class="indexterm" name="idm139979075195232"></a><a class="indexterm" name="idm139979075193168"></a><a class="indexterm" name="idm139979075191136"></a><a class="indexterm" name="idm139979075189184"></a><a class="indexterm" name="idm139979075187120"></a><a class="indexterm" name="idm139979075185056"></a><p>
      <code class="literal">InnoDB</code> では、通常、<a class="link" href="glossary.html#glos_row_level_locking" title="行レベルロック">行レベルロック</a>でネクストキーロックが使用されます。つまり、<code class="literal">InnoDB</code> はインデックスレコードのほかに、インデックスレコードの前の<a class="link" href="glossary.html#glos_gap" title="ギャップ">ギャップ</a>もロックすることで、インデックス付きの値がツリーデータ構造内のそのギャップに挿入されるその他のセッションによって挿入されることをブロックできます。ネクストキーロックは、インデックスレコードとその前のギャップをロックするロックを参照します。ギャップロックは、いくつかのインデックスレコードの前のギャップのみをロックするロックを参照します。
    </p><p>
      行レベルロック、およびギャップロックが無効になる状況についての詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-record-level-locks" title="14.2.6 InnoDB のレコード、ギャップ、およびネクストキーロック">セクション14.2.6「InnoDB のレコード、ギャップ、およびネクストキーロック」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-lock-modes"></a>14.2.3 InnoDB のロックモード</h3></div></div></div><a class="indexterm" name="idm139979075175664"></a><a class="indexterm" name="idm139979075173552"></a><p>
      <code class="literal">InnoDB</code> では、2 つのロックタイプ (<a class="link" href="glossary.html#glos_shared_lock" title="共有ロック">共有 (<em class="replaceable"><code>S</code></em>) ロック</a>と<a class="link" href="glossary.html#glos_exclusive_lock" title="排他ロック">排他 (<em class="replaceable"><code>X</code></em>) ロック</a>) がある標準の行レベルロックが実装されます。レコード、ギャップ、およびネクストキーの各ロックタイプについては、<a class="xref" href="innodb-storage-engine.html#innodb-record-level-locks" title="14.2.6 InnoDB のレコード、ギャップ、およびネクストキーロック">セクション14.2.6「InnoDB のレコード、ギャップ、およびネクストキーロック」</a>を参照してください。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="link" href="glossary.html#glos_shared_lock" title="共有ロック">共有 (<em class="replaceable"><code>S</code></em>) ロック</a>では、ロックを保持するトランザクションによる行の読み取りが許可されます。
        </p></li><li class="listitem"><p>
          <a class="link" href="glossary.html#glos_exclusive_lock" title="排他ロック">排他 (<em class="replaceable"><code>X</code></em>) ロック</a>では、ロックを保持するトランザクションによる行の更新または削除が許可されます。
        </p></li></ul></div><p>
      トランザクション <code class="literal">T1</code> が行 <code class="literal">r</code> に対する共有 (<em class="replaceable"><code>S</code></em>) ロックを保持している場合、別のトランザクション <code class="literal">T2</code> からの行 <code class="literal">r</code> に対するロック要求は次のように処理されます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">T2</code> による <em class="replaceable"><code>S</code></em> ロックに対するリクエストは、すぐに付与できます。結果として、<code class="literal">T1</code> と <code class="literal">T2</code> の両方が <code class="literal">r</code> 上で <em class="replaceable"><code>S</code></em> ロックを保持します。
        </p></li><li class="listitem"><p>
          <code class="literal">T2</code> による <em class="replaceable"><code>X</code></em> ロックに対するリクエストは、すぐに付与できません。
        </p></li></ul></div><p>
      トランザクション <code class="literal">T1</code> が行 <code class="literal">r</code> 上で排他 (<em class="replaceable"><code>X</code></em>) ロックを保持している場合は、<code class="literal">r</code> 上のいずれかのタイプのロックに対する一部の個別のトランザクション <code class="literal">T2</code> からのリクエストは、すぐに付与できません。代わりに、トランザクション <code class="literal">T2</code> は、行 <code class="literal">r</code> 上でトランザクション <code class="literal">T1</code> のロックが解放されるまで待機する必要があります。
    </p><h4><a name="idm139979075145296"></a>インテンションロック</h4><p>
      さらに、<code class="literal">InnoDB</code> では、レコードロックとテーブル全体のロックが共存することを許可する<span class="emphasis"><em>複数粒度ロック</em></span>もサポートされています。複数粒度レベルでのロックを実用的にするために、<a class="link" href="glossary.html#glos_intention_lock" title="インテンションロック">インテンションロック</a>と呼ばれる追加のロックタイプが使用されます。インテンションロックとは、あとでトランザクションがそのテーブル内の行で必要となるロックのタイプ (共有または排他) を示す <code class="literal">InnoDB</code> のテーブルロックです。トランザクション <code class="literal">T</code> がテーブル <code class="literal">t</code> 上に指定されたタイプのロックをリクエストしたと仮定すると、<code class="literal">InnoDB</code> で使用されるインテンションロックには、次の 2 つタイプがあります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="link" href="glossary.html#glos_intention_shared_lock" title="インテンション共有ロック">インテンション共有</a> (<em class="replaceable"><code>IS</code></em>): トランザクション <code class="literal">T</code> は意図的に、テーブル <code class="literal">t</code> 内の各行に <em class="replaceable"><code>S</code></em> ロックを設定します。
        </p></li><li class="listitem"><p>
          <a class="link" href="glossary.html#glos_intention_exclusive_lock" title="インテンション排他ロック">インテンション排他</a> (<em class="replaceable"><code>IX</code></em>): トランザクション <code class="literal">T</code> は意図的に、これらの行に <em class="replaceable"><code>X</code></em> ロックを設定します。
        </p></li></ul></div><p>
      たとえば、<code class="literal">SELECT ... LOCK IN SHARE MODE</code> は <em class="replaceable"><code>IS</code></em> ロックを設定し、<code class="literal">SELECT ... FOR UPDATE</code> は <em class="replaceable"><code>IX</code></em> ロックを設定します。
    </p><p>
      インテンションロックの手順は次のとおりです。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          トランザクションがテーブル <code class="literal">t</code> のある行の <em class="replaceable"><code>S</code></em> ロックを取得するには、まず <code class="literal">t</code> の <em class="replaceable"><code>IS</code></em> またはそれより強いロックを取得する必要があります。
        </p></li><li class="listitem"><p>
          トランザクションがある行の <em class="replaceable"><code>X</code></em> ロックを取得するには、まず <code class="literal">t</code> の <em class="replaceable"><code>IX</code></em> ロックを取得する必要があります。
        </p></li></ul></div><p>
      これらのルールをまとめる際は、次に示す<span class="emphasis"><em>ロックタイプ互換性マトリクス</em></span>を使用すると便利です。
    </p><div class="informaltable"><table summary="許可されているロックタイプ X、IX、S、および IS の組み合わせを示す互換性マトリクス。マトリクス内の各セルには、「互換」と「競合」のいずれかのマークが付いています。" border="1"><colgroup><col><col><col><col><col></colgroup><thead><tr><th scope="col"> </th><th scope="col"><em class="replaceable"><code>X</code></em></th><th scope="col"><em class="replaceable"><code>IX</code></em></th><th scope="col"><em class="replaceable"><code>S</code></em></th><th scope="col"><em class="replaceable"><code>IS</code></em></th></tr></thead><tbody><tr><td scope="row"><em class="replaceable"><code>X</code></em></td><td>競合</td><td>競合</td><td>競合</td><td>競合</td></tr><tr><td scope="row"><em class="replaceable"><code>IX</code></em></td><td>競合</td><td>互換</td><td>競合</td><td>互換</td></tr><tr><td scope="row"><em class="replaceable"><code>S</code></em></td><td>競合</td><td>競合</td><td>互換</td><td>互換</td></tr><tr><td scope="row"><em class="replaceable"><code>IS</code></em></td><td>競合</td><td>互換</td><td>互換</td><td>互換</td></tr></tbody></table></div><p>
      ロックに既存のロックとの互換性がある場合は、リクエスト元のトランザクションにロックが付与されますが、既存のロックと競合している場合は、ロックが付与されません。トランザクションは、競合している既存のロックが解放されるまで待機します。ロックリクエストが既存のロックと競合し、<a class="link" href="glossary.html#glos_deadlock" title="デッドロック">デッドロック</a>が発生するために付与できない場合は、エラーが発生します。
    </p><p>
      したがって、インテンションロックでは、完全なテーブルリクエスト (<code class="literal">LOCK TABLES ... WRITE</code> など) 以外は何もブロックされません。<em class="replaceable"><code>IX</code></em> および <em class="replaceable"><code>IS</code></em> ロックの主な目的は、だれかが行をロックしていることや、テーブル内の行をロックしようとしていることを示すことです。
    </p><h4><a name="idm139979075095616"></a>デッドロックの例</h4><p>
      次の例は、ロックリクエストによってデッドロックが発生したときに、どのようにエラーが発生するのかを示しています。この例には、A と B の 2 つのクライアントが登場します。
    </p><p>
      最初に、クライアント A が行を 1 つ含むテーブルを作成し、トランザクションを開始します。トランザクション内で、A は共有モードで選択した行で <em class="replaceable"><code>S</code></em> ロックを取得します。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE t (i INT) ENGINE = InnoDB;</code></strong>
Query OK, 0 rows affected (1.07 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO t (i) VALUES(1);</code></strong>
Query OK, 1 row affected (0.09 sec)

mysql&gt; <strong class="userinput"><code>START TRANSACTION;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM t WHERE i = 1 LOCK IN SHARE MODE;</code></strong>
+------+
| i    |
+------+
|    1 |
+------+
1 row in set (0.10 sec)
</pre><p>
      次に、クライアント B がトランザクションを開始し、テーブルから行を削除しようとします。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>START TRANSACTION;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>DELETE FROM t WHERE i = 1;</code></strong>
</pre><p>
      削除操作を行うには、<em class="replaceable"><code>X</code></em> ロックが必要です。クライアント A が保持している <em class="replaceable"><code>S</code></em> ロックとの互換性がないために、ロックを付与できません。そのため、リクエストはその行のロックリクエストのキューに入れられ、クライアント B はブロックされます。
    </p><p>
      最後に、クライアント A もテーブルから行を削除しようとします。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>DELETE FROM t WHERE i = 1;</code></strong>
ERROR 1213 (40001): Deadlock found when trying to get lock;
try restarting transaction
</pre><p>
      クライアント A は行を削除するために <em class="replaceable"><code>X</code></em> ロックが必要であるため、ここでデッドロックが発生します。ただし、クライアント B はすでに <em class="replaceable"><code>X</code></em> ロックに対するリクエストを持っていて、クライアント A がその <em class="replaceable"><code>S</code></em> ロックを解放するまで待機しているため、そのロックリクエストを付与することはできません。B による <em class="replaceable"><code>X</code></em> ロックに対する以前のリクエストが原因で、A が保持している <em class="replaceable"><code>S</code></em> ロックを <em class="replaceable"><code>X</code></em> ロックにアップグレードすることもできません。その結果、<code class="literal">InnoDB</code> はクライアントのいずれかに対してエラーを生成し、そのロックを解放します。クライアントは、次のエラーを返します。
    </p><pre class="programlisting">
ERROR 1213 (40001): Deadlock found when trying to get lock;
try restarting transaction
</pre><p>
      この時点で、ほかのクライアントに対するロックリクエストを付与できるようになり、テーブルから行が削除されます。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        InnoDB Monitor の出力の <code class="literal">LATEST DETECTED DEADLOCK</code> セクションには、<span class="quote">「<span class="quote"><span class="errortext">TOO DEEP OR LONG SEARCH IN THE LOCK TABLE WAITS-FOR GRAPH, WE WILL ROLL BACK FOLLOWING TRANSACTION</span></span>」</span> というメッセージが含まれます。これは、待機リスト上のトランザクション数が 200 の制限に達したことを示します。この制限は、<code class="literal">LOCK_MAX_DEPTH_IN_DEADLOCK_CHECK</code> で定義されます。200 個のトランザクションを超える待機リストはデッドロックとして処理され、待機リストをチェックしようとするトランザクションはロールバックされます。
      </p><p>
        ロックスレッドが待機リスト上のトランザクションが所有する 1,000,000 個を超えるロックを参照する必要がある場合も、同じエラーが発生する可能性があります。1,000,000 個のロック制限は、<code class="literal">LOCK_MAX_N_STEPS_IN_DEADLOCK_CHECK</code> で定義されます。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-consistent-read"></a>14.2.4 一貫性非ロック読み取り</h3></div></div></div><a class="indexterm" name="idm139979075068672"></a><a class="indexterm" name="idm139979075066544"></a><p>
      <a class="link" href="glossary.html#glos_consistent_read" title="一貫性読み取り">一貫性読み取り</a>とは、<code class="literal">InnoDB</code> がマルチバージョンを使用して、ある時点でのデータベースのスナップショットをクエリーに提供することを意味します。クエリーには、その時点よりも前にコミットされたトランザクションによる変更のみが表示され、その時点よりもあとのトランザクションまたはコミットされていないトランザクションによる変更は表示されません。このルールの例外として、同じトランザクション内の以前のステートメントによる変更はクエリーに表示されます。この例外によって、次のような異常が発生します。テーブル内の一部の行を更新すると、更新された行の最新バージョンが <code class="literal">SELECT</code> に表示されますが、いずれかの行の旧バージョンも表示される可能性があります。その他のセッションで同じテーブルが同時に更新される場合、その異常は、データベースに存在しない状態でテーブルが表示される可能性があることを意味します。
    </p><p>
      トランザクション<a class="link" href="glossary.html#glos_isolation_level" title="分離レベル">分離レベル</a>が <code class="literal">REPEATABLE READ</code> (デフォルトのレベル) である場合は、同じトランザクション内のすべての一貫性読み取りで、そのトランザクション内の最初のこのような読み取りで確立されたスナップショットが読み取られます。現在のトランザクションをコミットしたあとに、新しいクエリーを発行すると、クエリーの新しいスナップショットを取得できます。
    </p><p>
      分離レベルが <code class="literal">READ COMMITTED</code> の場合は、トランザクション内の各一貫性読み取りで、独自の新しいスナップショットが設定され、読み取られます。
    </p><p>
      一貫性読み取りは、<code class="literal">InnoDB</code> が <code class="literal">READ COMMITTED</code> および <code class="literal">REPEATABLE READ</code> 分離レベルで <code class="literal">SELECT</code> ステートメントを処理する際のデフォルトモードです。一貫性読み取りではアクセスされるテーブル上にロックが設定されないため、その他のセッションも、そのテーブル上で一貫性読み取りが実行されるときと同時に、それらのテーブルを自由に変更できます。
    </p><p>
      デフォルトの <code class="literal">REPEATABLE READ</code> 分離レベルで実行していると仮定します。一貫性読み取り (つまり、通常の <code class="literal">SELECT</code> ステートメント) を発行すると、<code class="literal">InnoDB</code> は、クエリーがデータベースを参照するときの基準となるタイムポイントをトランザクションに付与します。タイムポイントが割り当てられたあとに、別のトランザクションが行を削除してコミットした場合は、その行が削除済みとして表示されません。挿入および更新も同様に処理されます。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        データベースの状態のスナップショットは、トランザクション内の <code class="literal">SELECT</code> ステートメントに適用されますが、<a class="link" href="glossary.html#glos_dml" title="DML">DML</a> ステートメントには必ずしも適用されるとは限りません。一部の行を挿入または変更してから、そのトランザクションをコミットする場合は、そのセッションでクエリーが実行される可能性がない場合でも、別の並列実行 <code class="literal">REPEATABLE READ</code> トランザクションから発行された <code class="literal">DELETE</code> または <code class="literal">UPDATE</code> ステートメントによって、コミットされたばかりの行が影響を受ける可能性があります。トランザクションによって別のトランザクションでコミットされた行が更新または削除されると、これらの変更を現在のトランザクションに表示できるようになります。たとえば、次のような状況が発生する可能性があります。
      </p><pre class="programlisting">
SELECT COUNT(c1) FROM t1 WHERE c1 = 'xyz'; -- Returns 0: no rows match.
DELETE FROM t1 WHERE c1 = 'xyz'; -- Deletes several rows recently committed by other transaction.

SELECT COUNT(c2) FROM t1 WHERE c2 = 'abc'; -- Returns 0: no rows match.
UPDATE t1 SET c2 = 'cba' WHERE c2 = 'abc'; -- Affects 10 rows: another txn just committed 10 rows with 'abc' values.
SELECT COUNT(c2) FROM t1 WHERE c2 = 'cba'; -- Returns 10: this txn can now see the rows it just updated.
</pre></div><p>
      トランザクションをコミットしてから、別の <code class="literal">SELECT</code> または <code class="literal">START TRANSACTION WITH CONSISTENT SNAPSHOT</code> を実行すると、タイムポイントを進めることができます。
    </p><p>
      これは、<em class="firstterm">マルチバージョン並列処理制御</em>と呼ばれます。
    </p><p>
      次の例では、セッション B が挿入をコミットし、セッション A も同様にコミットした場合にのみ、B によって挿入された行が A に表示されます。これにより、タイムポイントが B のコミットよりも先に進みます。
    </p><pre class="programlisting">
             Session A              Session B

           SET autocommit=0;      SET autocommit=0;
time
|          SELECT * FROM t;
|          empty set
|                                 INSERT INTO t VALUES (1, 2);
|
v          SELECT * FROM t;
           empty set
                                  COMMIT;

           SELECT * FROM t;
           empty set

           COMMIT;

           SELECT * FROM t;
           ---------------------
           |    1    |    2    |
           ---------------------
           1 row in set
</pre><p>
      データベースの<span class="quote">「<span class="quote">最新</span>」</span>状態を確認する場合は、<code class="literal">READ COMMITTED</code> 分離レベルと<a class="link" href="glossary.html#glos_locking_read" title="ロック読み取り">ロック読み取り</a>のいずれかを使用します。
    </p><pre class="programlisting">
SELECT * FROM t LOCK IN SHARE MODE;
</pre><p>
      分離レベルが <code class="literal">READ COMMITTED</code> の場合は、トランザクション内の各一貫性読み取りで、独自の新しいスナップショットが設定され、読み取られます。<code class="literal">LOCK IN SHARE MODE</code> の場合は、代わりにロック読み取りが発生します。<code class="literal">SELECT</code> は、最新の行を含むトランザクションが終了するまでブロックされます (<a class="xref" href="innodb-storage-engine.html#innodb-locking-reads" title="14.2.5 ロック読み取り (SELECT ... FOR UPDATE および SELECT ... LOCK IN SHARE MODE)">セクション14.2.5「ロック読み取り (SELECT ... FOR UPDATE および SELECT ... LOCK IN SHARE MODE)」</a>を参照)。
    </p><p>
      特定の DDL ステートメントでは、一貫性読み取りが機能しません。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">DROP TABLE</code> では、MySQL が削除されたテーブルを使用できず、そのテーブルは <code class="literal">InnoDB</code> によって破棄されるため、一貫性読み取りが機能しません。
        </p></li><li class="listitem"><p>
          <code class="literal">ALTER TABLE</code> では、そのステートメントで元のテーブルの一時コピーが作成され、元のテーブルは一時コピーが構築されるときに削除されるため、一貫性読み取りが機能しません。トランザクション内で一貫性読み取りを再発行しても、新しいテーブル内の行はトランザクションのスナップショット取得されたときには存在していなかったため、表示できません。MySQL 5.6.6 の時点では、この場合に、トランザクションから<span class="quote">「<span class="quote">Table definition has changed, please retry transaction</span>」</span>という <code class="literal">ER_TABLE_DEF_CHANGED</code> エラーが返されます。
        </p></li></ul></div><p>
      <code class="literal">FOR UPDATE</code> または <code class="literal">LOCK IN SHARE MODE</code> を指定しない <code class="literal">INSERT INTO ... SELECT</code>、<code class="literal">UPDATE ... (SELECT)</code>、<code class="literal">CREATE TABLE ... SELECT</code> などの句での選択では、読み取りのタイプが異なります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          デフォルトでは、<code class="literal">InnoDB</code> はより強固なロックを使用し、<code class="literal">SELECT</code> 部分は <code class="literal">READ COMMITTED</code> と同様に機能します。この場合、同じトランザクション内でも、各一貫性読み取りで独自の新しいスナップショットが設定され、読み取られます。

          
        </p></li><li class="listitem"><p>
          このような場合に一貫性読み取りを使用するには、<code class="literal">innodb_locks_unsafe_for_binlog</code> オプションを有効にし、トランザクションの分離レベルを <code class="literal">READ UNCOMMITTED</code>、<code class="literal">READ COMMITTED</code>、または <code class="literal">REPEATABLE READ</code> (つまり、<code class="literal">SERIALIZABLE</code> 以外のすべて) に設定します。この場合、選択したテーブルから読み取られた行には、ロックが設定されません。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-locking-reads"></a>14.2.5 ロック読み取り (SELECT ... FOR UPDATE および SELECT ... LOCK IN SHARE MODE)</h3></div></div></div><a class="indexterm" name="idm139979074998704"></a><p>
      データのクエリーを実行してから、同じトランザクション内で関連データを挿入または更新する場合は、通常の <code class="literal">SELECT</code> ステートメントで十分な保護が提供されません。ほかのトランザクションは、クエリーが実行されたばかりの同じ行を更新または削除できます。<code class="literal">InnoDB</code> では、追加の安全性が提供される 2 つのタイプの<a class="link" href="glossary.html#glos_locking_read" title="ロック読み取り">ロック読み取り</a>がサポートされています。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">SELECT ... LOCK IN SHARE MODE</code> は、読み取られるすべての行に共有モードのロックを設定します。ほかのセッションもその行を読み取ることができますが、トランザクションがコミットするまで変更することはできません。これらの行のいずれかがコミットされていない別のトランザクションによって変更された場合、クエリーはそのトランザクションが終了するまで待機してから、最新の値を使用します。
        </p></li><li class="listitem"><p>
          検索でインデックスレコードが見つかった場合、<code class="literal">SELECT ... FOR UPDATE</code> は、行および関連付けられたすべてのエントリをロックします。この動作は、これらの行に <code class="literal">UPDATE</code> ステートメントを発行した場合と同じです。ほかのトランザクションは、これらの行の更新、<code class="literal">SELECT ... LOCK IN SHARE MODE</code> の実行、または特定のトランザクション分離レベルでのデータの読み取りからブロックされます。一貫性読み取りでは、読み取られたビュー内に存在するレコードに設定されたロックはすべて無視されます。(古いバージョンのレコードはロックできません。レコードのインメモリーコピー上の <a class="link" href="glossary.html#glos_undo_log" title="Undo ログ">Undo ログ</a>に適用することで、再構築されます。)
        </p></li></ul></div><p>
      これらの句は、主に、単一のテーブル内または複数のテーブルに分割された状態で、ツリー構造またはグラフ構造のデータを処理する際に役立ちます。エッジまたはツリー分岐をある場所から別の場所にトラバースしても、これらの<span class="quote">「<span class="quote">ポインタ</span>」</span>に戻ってその値を変更する権利を保有しています。
    </p><p>
      トランザクションがコミットまたはロールバックされると、<code class="literal">LOCK IN SHARE MODE</code> および <code class="literal">FOR UPDATE</code> クエリーで設定されたすべてのロックが解放されます。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">SELECT FOR UPDATE</code> を使用した更新対象の行のロックは、<code class="literal">START TRANSACTION</code> でトランザクションを開始するか、<code class="literal">autocommit</code> を 0 に設定することで、自動コミットが無効になっている場合にのみ適用されます。自動コミットが有効になっている場合は、指定に一致する行がロックされません。
      </p></div><h4><a name="idm139979074975840"></a>使用例</h4><p>
      <code class="literal">child</code> テーブルに新しい行を挿入し、子の行が <code class="literal">parent</code> テーブル内に親の行を持っていることを確認すると仮定します。アプリケーションコードを使用して、この操作シーケンス全体の参照整合性を確保できます。
    </p><p>
      まず、一貫性読み取りを使用して、<code class="literal">PARENT</code> テーブルでクエリーを実行し、親の行が存在することを確認します。<code class="literal">CHILD</code> テーブルに子の行を安全に挿入できますか。気付かないうちに、その他の一部のセッションで、<code class="literal">SELECT</code> と <code class="literal">INSERT</code> との間に親の行が削除された可能性もあるため、できません。
    </p><p>
      このような問題の可能性を回避するには、<code class="literal">LOCK IN SHARE MODE</code> を使用して <code class="literal">SELECT</code> を実行します。
    </p><pre class="programlisting">
SELECT * FROM parent WHERE NAME = 'Jones' LOCK IN SHARE MODE;
</pre><p>
      <code class="literal">LOCK IN SHARE MODE</code> クエリーから<code class="literal">「Jones」</code>という親が返されたら、<code class="literal">CHILD</code> テーブルに子のレコードを安全に追加し、トランザクションをコミットできます。<code class="literal">PARENT</code> テーブル内のアプリケーション行で読み取りまたは書き込みを行おうとするトランザクションは、ユーザーが完了するまで (つまり、すべてのテーブル内のデータが一貫性のある状態になるまで) 待機します。
    </p><p>
      もう 1 つの例では、<code class="literal">CHILD</code> テーブルに追加された各子に一意の識別子を割り当てる際に使用される <code class="literal">CHILD_CODES</code> テーブル内の整数カウンタフィールドを検討します。一貫性読み取りまたは共有モード読み取りを使用すると、データベースの 2 人のユーザーが同じカウンタ値を参照する可能性があり、2 つのトランザクションが同じ識別子を持つ行を <code class="literal">CHILD</code> テーブルに追加しようとすると、重複キーのエラーが発生するため、カウンタの現在の値を読み取る際には使用しないでください。
    </p><p>
      ここで、2 人のユーザーがカウンタを同時に読み取る場合、少なくとも 1 人のユーザーがカウンタを更新しようとするとデッドロックが発生するため、<code class="literal">LOCK IN SHARE MODE</code> は適切な解決策ではありません。
    </p><p>
      カウンタの読み取りおよび増分を実装するには、まず <code class="literal">FOR UPDATE</code> を使用してカウンタのロック読み取りを実行してから、カウンタを増分します。例:
    </p><pre class="programlisting">
SELECT counter_field FROM child_codes FOR UPDATE;
UPDATE child_codes SET counter_field = counter_field + 1;
</pre><p>
      <code class="literal">SELECT ... FOR UPDATE</code> は使用可能な最新データを読み取り、読み取られる各行上に排他ロックを設定します。したがって、検索された SQL <code class="literal">UPDATE</code> によって行上に設定される場合と同じロックが設定されます。
    </p><p>
      前述の説明は、単に <code class="literal">SELECT ... FOR UPDATE</code> がどのように機能するのかを示した例です。MySQL では、テーブルへの単一アクセスを使用するだけで、一意の識別子を生成する特定のタスクを実現できます。
    </p><pre class="programlisting">
UPDATE child_codes SET counter_field = LAST_INSERT_ID(counter_field + 1);
SELECT LAST_INSERT_ID();
</pre><p>
      この <code class="literal">SELECT</code> ステートメントは、単に (現在の接続に固有の) 識別子情報を取得するだけです。どのテーブルにもアクセスしません。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-record-level-locks"></a>14.2.6 InnoDB のレコード、ギャップ、およびネクストキーロック</h3></div></div></div><a class="indexterm" name="idm139979074945008"></a><a class="indexterm" name="idm139979074942880"></a><a class="indexterm" name="idm139979074940864"></a><a class="indexterm" name="idm139979074938752"></a><a class="indexterm" name="idm139979074936720"></a><a class="indexterm" name="idm139979074934768"></a><a class="indexterm" name="idm139979074932704"></a><a class="indexterm" name="idm139979074930640"></a><p>
      <code class="literal">InnoDB</code> のレコードレベルのロックには、レコードロック、ギャップロック、ネクストキーロックなどの複数のタイプがあります。共有ロック、排他ロック、およびインテンションロックについては、<a class="xref" href="innodb-storage-engine.html#innodb-lock-modes" title="14.2.3 InnoDB のロックモード">セクション14.2.3「InnoDB のロックモード」</a>を参照してください。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          レコードロック: これはインデックスレコードのロックです。
        </p></li><li class="listitem"><p>
          ギャップロック: これはインデックスレコード間にあるギャップのロック、または先頭のインデックスレコードの前や末尾のインデックスレコードのあとにあるギャップのロックです。
        </p></li><li class="listitem"><p>
          ネクストキーロック: これはインデックスレコードに対するレコードロックと、そのインデックスレコードの前にあるギャップに対するギャップロックとを組み合わせたものです。
        </p></li></ul></div><h4><a name="idm139979074922032"></a>レコードロック</h4><p>
      レコードロックでは、テーブルにインデックスが定義されていなくても必ず、インデックスレコードがロックされます。このような場合は、<code class="literal">InnoDB</code> によって非表示のクラスタ化されたインデックスが作成され、このインデックスを使用してレコードロックが行われます。<a class="xref" href="innodb-storage-engine.html#innodb-index-types" title="14.2.13.2 クラスタインデックスとセカンダリインデックス">セクション14.2.13.2「クラスタインデックスとセカンダリインデックス」</a>を参照してください。
    </p><h4><a name="idm139979074918704"></a>ネクストキーロック</h4><p>
      デフォルトでは、<code class="literal">InnoDB</code> は <code class="literal">REPEATABLE READ</code> トランザクション分離レベルで動作し、<code class="literal">innodb_locks_unsafe_for_binlog</code> システム変数は無効になっています。この場合、<code class="literal">InnoDB</code> はネクストキーロックを使用して検索およびインデックススキャンを行うため、ファントム行の発生を回避できます (<a class="xref" href="innodb-storage-engine.html#innodb-next-key-locking" title="14.2.7 ネクストキーロックによるファントム問題の回避">セクション14.2.7「ネクストキーロックによるファントム問題の回避」</a>を参照)。
    </p><p>
      ネクストキーロックは、インデックス行ロックとギャップロックを組み合わせたものです。<code class="literal">InnoDB</code> は、テーブルインデックスを検索またはスキャンするときに、生成されたインデックスレコード上に共有ロックまたは排他ロックを設定するという方法で、行レベルロックを実行します。したがって、行レベルロックは、実際にはインデックスレコードロックです。さらに、あるインデックスレコードに対するネクストキーロックによって、そのインデックスレコードの前の<span class="quote">「<span class="quote">ギャップ</span>」</span>も影響を受けます。つまり、ネクストキーロックは、インデックスレコードロックと、そのインデックスレコードの前のギャップに対するギャップロックとを組み合わせたものです。あるセッションがインデックス内のレコード <code class="literal">R</code> 上に共有ロックまたは排他ロックを持っている場合は、別のセッションがインデックスの順番で <code class="literal">R</code> の直前にあるギャップに新しいインデックスレコードを挿入できません。
    </p><p>
      あるインデックスに値 10、11、13、20 が含まれているとします。このインデックスでは、次の間隔をカバーするネクストキーロックが使用される可能性があります。ここで、<code class="literal">(</code> や <code class="literal">)</code> は間隔の端点が含まれないことを表し、<code class="literal">[</code> や <code class="literal">]</code> は間隔の端点が含まれることを表します。
    </p><pre class="programlisting">
(negative infinity, 10]
(10, 11]
(11, 13]
(13, 20]
(20, positive infinity)
</pre><p>
      最後の間隔ではネクストキーロックによって、インデックス内の最大値を上回るギャップ、およびインデックス内の実際のどの値よりも大きい値を持つ<span class="quote">「<span class="quote">最小上限</span>」</span>の擬似レコードがロックされます。最小上限は実際のインデックスレコードではないため、事実上、このネクストキーロックによってロックされるのは、最大インデックス値のあとにあるギャップのみです。
    </p><h4><a name="idm139979074901808"></a>ギャップロック</h4><p>
      前のセクションで示したネクストキーロックの例は、ギャップの範囲が単一のインデックス値、複数のインデックス値、または空になる場合もあることを示しています。
    </p><p>
      一意のインデックスを使用して一意の行を検索することで行をロックするステートメントでは、ギャップロックは必要ありません。(これには、検索条件に複数カラムの一意のインデックスの一部のカラムのみが含まれるケースは含まれません。この場合は、ギャップロックが発生します。)たとえば、<code class="literal">id</code> カラムに一意のインデックスが設定されている場合、次のステートメントで使用されるのは <code class="literal">id</code> の値が 100 の行に対するインデックスレコードロックだけとなり、ほかのセッションがそのレコードの前にあるギャップに行を挿入するかどうかは問題ではなくなります。
    </p><pre class="programlisting">
SELECT * FROM child WHERE id = 100;
</pre><p>
      <code class="literal">id</code> にインデックスが設定されていなかったり、一意でないインデックスが設定されていたりすると、このステートメントで先行するギャップがロックされます。
    </p><p>
      <code class="literal">INSERT</code> 操作では行の挿入前に、挿入インテンションギャップロックと呼ばれる一種のギャップロックが設定されます。このロックは、同じインデックスギャップに挿入する複数のトランザクションは、そのギャップ内の同じ場所に挿入しなければ相互に待機する必要がないように、意図的に挿入することを示しています。値が 4 と 7 のインデックスレコードが存在すると仮定します。それぞれ値 5 と 6 の挿入を試みる別々のトランザクションは、挿入される行の排他ロックを取得する前に挿入インテンションロックを使用して、4 と 7 の間にあるギャップをロックしますが、行の競合が発生しないため相互にブロックされません。インテンションロックについての詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-lock-modes" title="14.2.3 InnoDB のロックモード">セクション14.2.3「InnoDB のロックモード」</a>を参照してください。
    </p><p>
      さまざまなトランザクションによってギャップ上に競合するロックを保持できることも、ここで注目するべき点です。たとえば、トランザクション A はギャップ上に共有ギャップロック (ギャップ S ロック) を保持できる一方で、トランザクション B は同じギャップ上に排他ギャップロック (ギャップ X ロック) を保持します。競合するギャップロックが許可される理由は、レコードがインデックスからパージされる場合に、さまざまなトランザクションによってレコード上に保持されたギャップロックをマージする必要があるためです。
    </p><p>
      <code class="literal">InnoDB</code> のギャップロックは、<span class="quote">「<span class="quote">単に抑制的</span>」</span>です。つまり、ほかのトランザクションによるギャップへの挿入が停止されるだけです。したがって、ギャップ X ロックの効果はギャップ S ロックと同じです。
    </p><h4><a name="idm139979074887408"></a>ギャップロックの無効化</h4><p>
      ギャップロックは明示的に無効化できます。これは、トランザクション分離レベルを <code class="literal">READ COMMITTED</code> に変更するか、または <code class="literal">innodb_locks_unsafe_for_binlog</code> システム変数 (現在は非推奨です) を有効にすると発生します。このような状況では、ギャップロックは検索およびインデックススキャン時に無効化され、外部キー制約チェックおよび重複キーチェック時にのみ使用されます。
    </p><p>
      <code class="literal">READ COMMITTED</code> 分離レベルを使用するか、<code class="literal">innodb_locks_unsafe_for_binlog</code> を有効にした場合の効果はほかにもあります。一致しない行のレコードロックは、MySQL による <code class="literal">WHERE</code> 条件の評価が完了すると解放されます。<code class="literal">UPDATE</code> ステートメントの場合、<code class="literal">InnoDB</code> は最後にコミットされたバージョンが MySQL に返されるように、<span class="quote">「<span class="quote">半一貫性</span>」</span>読み取りを実行します。これにより、MySQL はその行が <code class="literal">UPDATE</code> の <code class="literal">WHERE</code> 条件に一致するかどうかを判断できます。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-next-key-locking"></a>14.2.7 ネクストキーロックによるファントム問題の回避</h3></div></div></div><a class="indexterm" name="idm139979074874720"></a><a class="indexterm" name="idm139979074873280"></a><a class="indexterm" name="idm139979074871216"></a><a class="indexterm" name="idm139979074869152"></a><a class="indexterm" name="idm139979074867088"></a><a class="indexterm" name="idm139979074865056"></a><a class="indexterm" name="idm139979074863104"></a><a class="indexterm" name="idm139979074861040"></a><a class="indexterm" name="idm139979074858976"></a><p>
      同じクエリーでさまざまな時間にさまざまな行のセットが生成されると、いわゆる<em class="firstterm">ファントム</em>の問題がトランザクション内で発生します。たとえば、<code class="literal">SELECT</code> が 2 回実行されたが、1 回目には返されなかった行が 2 回目には返された場合、その行が<span class="quote">「<span class="quote">ファントム</span>」</span>行です。
    </p><p>
      <code class="literal">child</code> テーブルの <code class="literal">id</code> カラム上にインデックスがあり、識別子の値が 100 よりも大きいすべての行をテーブルから読み取り、選択された行の一部のカラムをあとで更新するという意図でロックすると仮定します。
    </p><pre class="programlisting">
SELECT * FROM child WHERE id &gt; 100 FOR UPDATE;
</pre><p>
      クエリーでは、<code class="literal">id</code> が 100 よりも大きい最初のレコードからインデックスがスキャンされます。このテーブルには <code class="literal">id</code> の値が 90 と 102 の行が格納されているものとします。スキャン範囲内のインデックスレコード上に設定されたロックによって、ギャップ (この場合のギャップは 90 から 102 まで) への挿入がロックアウトされていない場合は、別のセッションが <code class="literal">id</code> が 101 の新しい行をそのテーブルに挿入できます。同じトランザクション内で同じ <code class="literal">SELECT</code> を実行すると、クエリーから返された結果セット内に、<code class="literal">id</code> が 101 の新しい行 (<span class="quote">「<span class="quote">ファントム</span>」</span>) が含まれています。一連の行をデータ項目とみなせば、この新しいファントムの子は、「トランザクション中は読み取られるデータが変更されないようにトランザクションを実行できるべきである」というトランザクションの分離原則に違反しています。
    </p><p>
      ファントムの発生を回避できるように、<code class="literal">InnoDB</code> では通常、インデックス行ロックとギャップロックを組み合わせた<em class="firstterm">ネクストキーロック</em>と呼ばれるアルゴリズムが使用されます。<code class="literal">InnoDB</code> は、テーブルインデックスを検索またはスキャンするときに、生成されたインデックスレコード上に共有ロックまたは排他ロックを設定するという方法で、行レベルロックを実行します。したがって、行レベルロックは、実際にはインデックスレコードロックです。さらに、あるインデックスレコードに対するネクストキーロックによって、そのインデックスレコードの前の<span class="quote">「<span class="quote">ギャップ</span>」</span>も影響を受けます。つまり、ネクストキーロックは、インデックスレコードロックと、そのインデックスレコードの前のギャップに対するギャップロックとを組み合わせたものです。あるセッションがインデックス内のレコード <code class="literal">R</code> 上に共有ロックまたは排他ロックを持っている場合は、別のセッションがインデックスの順番で <code class="literal">R</code> の直前にあるギャップに新しいインデックスレコードを挿入できません。
    </p><p>
      <code class="literal">InnoDB</code> はインデックスをスキャンするときに、インデックス内の最後のレコードのあとのギャップをロックすることもできます。前述の例では、まさにそれが行われています。<code class="literal">id</code> が 100 よりも大きいテーブルへの挿入が回避されるように、<code class="literal">InnoDB</code> で設定されたロックには、<code class="literal">id</code> 値 102 のあとのギャップに対するロックが含まれています。
    </p><p>
      ネクストキーロックを使用すると、アプリケーションに一意性チェックを実装できます。共有モードでデータを読み取るときに、挿入される行の重複が見られなければ、行を安全に挿入でき、読み取り中に後続の行に設定されたネクストキーロックによって、任意のユーザーによる重複行の挿入が回避されることを確認できます。したがって、ネクストキーロックを使用すれば、テーブル内に存在しないものも<span class="quote">「<span class="quote">ロック</span>」</span>できます。
    </p><p>
      ギャップロックは、<a class="xref" href="innodb-storage-engine.html#innodb-record-level-locks" title="14.2.6 InnoDB のレコード、ギャップ、およびネクストキーロック">セクション14.2.6「InnoDB のレコード、ギャップ、およびネクストキーロック」</a>で説明した方法で無効にすることができます。ギャップロックが無効になっていると、ほかのセッションが新しい行をギャップに挿入できるため、ファントムの問題が発生する可能性があります。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-locks-set"></a>14.2.8 InnoDB のさまざまな SQL ステートメントで設定されたロック</h3></div></div></div><a class="indexterm" name="idm139979074830176"></a><p>
      一般に、<a class="link" href="glossary.html#glos_locking_read" title="ロック読み取り">ロック読み取り</a>、<code class="literal">UPDATE</code>、または <code class="literal">DELETE</code> では、SQL ステートメントの処理時にスキャンされるすべてのインデックスレコード上に、レコードロックが設定されます。

      

      行を除外する <code class="literal">WHERE</code> 条件がステートメント内に存在するかどうかは、関係ありません。<code class="literal">InnoDB</code> には正確な <code class="literal">WHERE</code> 条件が記憶されませんが、スキャンされたインデックスの範囲は認識されます。通常、ロックはレコードの直前にある<span class="quote">「<span class="quote">ギャップ</span>」</span>への挿入もブロックする<a class="link" href="glossary.html#glos_next_key_lock" title="ネクストキーロック">ネクストキーロック</a>です。ただし、<a class="link" href="glossary.html#glos_gap_lock" title="ギャップロック">ギャップロック</a>は明示的に無効にすることができます。これにより、ネクストキーロックが使用されなくなります。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-record-level-locks" title="14.2.6 InnoDB のレコード、ギャップ、およびネクストキーロック">セクション14.2.6「InnoDB のレコード、ギャップ、およびネクストキーロック」</a>を参照してください。トランザクション分離レベルによって、どのロックが設定されるのかも影響を受けます。<a class="xref" href="sql-syntax.html#set-transaction" title="13.3.6 SET TRANSACTION 構文">セクション13.3.6「SET TRANSACTION 構文」</a>を参照してください。
    </p><p>
      検索でセカンダリインデックスが使用され、設定されるインデックスレコードのロックが排他的である場合、<code class="literal">InnoDB</code> は対応するクラスタ化されたインデックスレコードを取得し、それらにロックを設定することも行います。
    </p><p>
      共有ロックと排他ロックの違いについては、<a class="xref" href="innodb-storage-engine.html#innodb-lock-modes" title="14.2.3 InnoDB のロックモード">セクション14.2.3「InnoDB のロックモード」</a>を参照してください。
    </p><p>
      ステートメントに適したインデックスがなく、MySQL がステートメントを処理するためにテーブル全体をスキャンする必要がある場合は、テーブルのすべての行がロックされます。その結果、そのテーブルへのほかのユーザーによるすべての挿入がブロックされます。クエリーで不必要に複数の行がスキャンされないように、適切なインデックスを作成することが重要です。
    </p><p>
      <code class="literal">SELECT ... FOR UPDATE</code> または <code class="literal">SELECT ... LOCK IN SHARE MODE</code> では、スキャンされた行についてはロックが取得され、<code class="literal">WHERE</code> 句に指定された条件を満たさないなどの理由で結果セットに含める対象から除外された行については、ロックが解放されることが予想されます。ただし場合によっては、クエリーの実行中に結果行とその元のソースとの関係が失われたために、行のロックがすぐに解除されない可能性もあります。たとえば <code class="literal">UNION</code> では、スキャン (およびロック) されたテーブル内の行が、結果セットに含める対象となるかどうかの評価前に、一時テーブルに挿入される可能性があります。この状況では、一時テーブル内の行と元のテーブル内の行との関係は失われているため、クエリー実行が終了するまで後者の行のロックは解除されません。
    </p><p>
      <code class="literal">InnoDB</code> は、次のように特定のロックタイプを設定します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">SELECT ... FROM</code> は一貫性読み取りであり、データベースのスナップショットを読み取り、トランザクションの分離レベルが <code class="literal">SERIALIZABLE</code> に設定されなければロックを設定しません。<code class="literal">SERIALIZABLE</code> レベルの場合、検索で見つかったインデックスレコード上に共有ネクストキーロックが設定されます。
        </p></li><li class="listitem"><p>
          <code class="literal">SELECT ... FROM ... LOCK IN SHARE MODE</code> では、検索で見つかったすべてのインデックスレコード上に共有ネクストキーロックが設定されます。
        </p></li><li class="listitem"><p>
          <code class="literal">SELECT ... FROM ... FOR UPDATE</code> は、検索で見つかったインデックスレコードに対して、ほかのセッションが <code class="literal">SELECT ... FROM ... LOCK IN SHARE MODE</code> を実行したり、特定のトランザクション分離レベルで読み取ったりすることをブロックします。一貫性読み取りでは、読み取られたビュー内に存在するレコードに設定されたロックはすべて無視されます。
        </p></li><li class="listitem"><p>
          <code class="literal">UPDATE ... WHERE ...</code> は、検索で見つかったすべてのレコード上に排他ネクストキーロックを設定します。
        </p></li><li class="listitem"><p>
          <code class="literal">DELETE FROM ... WHERE ...</code> は、検索で見つかったすべてのレコード上に排他ネクストキーロックを設定します。
        </p></li><li class="listitem"><p>
          <code class="literal">INSERT</code> は、挿入される行に排他ロックを設定します。このロックは、ネクストキーロックではなくインデックスレコードロックである (つまり、ギャップロックが存在しない) ため、ほかのセッションが挿入された行の前にあるギャップに挿入することは回避されません。
        </p><p>
          行の挿入前に、挿入インテンションギャップロックと呼ばれる一種のギャップロックが設定されます。このロックは、同じインデックスギャップに挿入する複数のトランザクションは、そのギャップ内の同じ場所に挿入しなければ相互に待機する必要がないように、意図的に挿入することを示しています。値が 4 と 7 のインデックスレコードが存在すると仮定します。それぞれ値 5 と 6 の挿入を試みる別々のトランザクションは、挿入される行の排他ロックを取得する前に挿入インテンションロックを使用して、4 と 7 の間にあるギャップをロックしますが、行の競合が発生しないため相互にブロックされません。
        </p><p>
          重複キーエラーが発生すると、重複インデックスレコード上の共有ロックが設定されます。複数のセッションが同じ行を挿入しようとしているときに、別のセッションがすでに排他ロックを取得していた場合は、このように共有ロックを使用することでデッドロックが発生する可能性があります。これは、別のセッションがその行を削除した場合に発生する可能性があります。<code class="literal">InnoDB</code> テーブル <code class="literal">t1</code> の構造が次のようになっているとします。
        </p><pre class="programlisting">
CREATE TABLE t1 (i INT, PRIMARY KEY (i)) ENGINE = InnoDB;
</pre><p>
          次に、3 つのセッションが次の処理を順番に実行するものとします。
        </p><p>
          セッション 1:
        </p><pre class="programlisting">
START TRANSACTION;
INSERT INTO t1 VALUES(1);
</pre><p>
          セッション 2:
        </p><pre class="programlisting">
START TRANSACTION;
INSERT INTO t1 VALUES(1);
</pre><p>
          セッション 3:
        </p><pre class="programlisting">
START TRANSACTION;
INSERT INTO t1 VALUES(1);
</pre><p>
          セッション 1:
        </p><pre class="programlisting">
ROLLBACK;
</pre><p>
          セッション 1 による最初の処理では、行の排他ロックが取得されます。セッション 2 と 3 の処理ではどちらも重複キーエラーが発生し、どちらのセッションも行の共有ロックをリクエストします。セッション 1 はロールバック時に行の排他ロックを解放し、キュー内のセッション 2 と 3 の共有ロックリクエストが付与されます。この時点でセッション 2 と 3 でデッドロックが発生します。どちらも他方が保持している共有ロックのために、行の排他ロックを取得できません。
        </p><p>
          キー値が 1 の行がテーブルに含まれている場合も似たような状況が発生し、3 つのセッションが次の処理を順番に実行します。
        </p><p>
          セッション 1:
        </p><pre class="programlisting">
START TRANSACTION;
DELETE FROM t1 WHERE i = 1;
</pre><p>
          セッション 2:
        </p><pre class="programlisting">
START TRANSACTION;
INSERT INTO t1 VALUES(1);
</pre><p>
          セッション 3:
        </p><pre class="programlisting">
START TRANSACTION;
INSERT INTO t1 VALUES(1);
</pre><p>
          セッション 1:
        </p><pre class="programlisting">
COMMIT;
</pre><p>
          セッション 1 による最初の処理では、行の排他ロックが取得されます。セッション 2 と 3 の処理ではどちらも重複キーエラーが発生し、どちらのセッションも行の共有ロックをリクエストします。セッション 1 はコミット時に行の排他ロックを解放し、キュー内のセッション 2 と 3 の共有ロックリクエストが付与されます。この時点でセッション 2 と 3 でデッドロックが発生します。どちらも他方が保持している共有ロックのために、行の排他ロックを取得できません。
        </p></li><li class="listitem"><p>
          <code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> は、重複キーエラーが発生したときに、更新される行に共有ロックではなく、排他ネクストキーロックが配置されるという点で、単純な <code class="literal">INSERT</code> と異なります。
        </p></li><li class="listitem"><p>
          <code class="literal">REPLACE</code> は、一意のキーが競合していなければ、<code class="literal">INSERT</code> と同様に動作します。それ以外の場合は、置換される行に排他ネクストキーロックが配置されます。
        </p></li><li class="listitem"><p>
          <code class="literal">INSERT INTO T SELECT ... FROM S WHERE ...</code> は、<code class="literal">T</code> に挿入された各行に、ギャップロックなしの排他インデックスレコードロックを設定します。トランザクション分離レベルが <code class="literal">READ COMMITTED</code> である場合、または <code class="literal">innodb_locks_unsafe_for_binlog</code> が有効になっていて、トランザクション分離レベルが <code class="literal">SERIALIZABLE</code> でない場合、<code class="literal">InnoDB</code> は一貫性読み取り (ロックなし) として <code class="literal">S</code> 上で検索を実行します。それ以外の場合、<code class="literal">InnoDB</code> は <code class="literal">S</code> から取得した行に共有ネクストキーロックを設定します。<code class="literal">InnoDB</code> は、後者の場合にロックを設定する必要があります。バックアップからのロールフォワードリカバリ時には、すべての SQL ステートメントを元とまったく同じ方法で実行する必要があります。
        </p><p>
          <code class="literal">CREATE TABLE ... SELECT ...</code> は、<code class="literal">INSERT ... SELECT</code> の場合と同様に、<code class="literal">SELECT</code> を共有ネクストキーロックを使用して実行するか、一貫性読み取りとして実行します。
        </p><p>
          構造文 <code class="literal">REPLACE INTO t SELECT ... FROM s WHERE ...</code> または <code class="literal">UPDATE t ... WHERE col IN (SELECT ... FROM s ...)</code> で <code class="literal">SELECT</code> が使用されると、<code class="literal">InnoDB</code> はテーブル <code class="literal">s</code> の行に共有ネクストキーロックを設定します。
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> は、テーブル上に事前に指定された <code class="literal">AUTO_INCREMENT</code> カラムの初期化中に、<code class="literal">AUTO_INCREMENT</code> カラムに関連付けられたインデックスの最後に排他ロックを設定します。<code class="literal">InnoDB</code> では、自動インクリメントカウンタにアクセスするときに、ロックがトランザクション全体の最後までではなく、現在の SQL ステートメントの最後まで続く、特別な <code class="literal">AUTO-INC</code> テーブルロックモードが使用されます。<code class="literal">AUTO-INC</code> テーブルロックが保持されている間は、ほかのセッションはそのテーブルに挿入できません。<a class="xref" href="innodb-storage-engine.html#innodb-transaction-model" title="14.2.2 InnoDB のトランザクションモデルおよびロック">セクション14.2.2「InnoDB のトランザクションモデルおよびロック」</a>を参照してください。
        </p><p>
          <code class="literal">InnoDB</code> は、ロックを設定せずに、事前に初期化された <code class="literal">AUTO_INCREMENT</code> カラムの値をフェッチします。
        </p></li><li class="listitem"><p>
          <code class="literal">FOREIGN KEY</code> 制約がテーブル上で定義されている場合は、制約条件をチェックする必要がある挿入、更新、または削除が行われると、制約をチェックするために、参照されるレコード上に共有レコードレベルロックが設定されます。<code class="literal">InnoDB</code> は、制約が失敗する場合に備えて、これらのロックの設定も行います。
        </p></li><li class="listitem"><p>
          <code class="literal">LOCK TABLES</code> はテーブルロックを設定しますが、これらのロックを設定する <code class="literal">InnoDB</code> レイヤーよりも上位の MySQL レイヤーです。<code class="literal">InnoDB</code> は、<code class="literal">innodb_table_locks = 1</code> (デフォルト) かつ <code class="literal">autocommit = 0</code> の場合にテーブルロックを認識し、<code class="literal">InnoDB</code> よりも上位の MySQL レイヤーは、行レベルロックを識別します。
        </p><p>
          それ以外の場合は、<code class="literal">InnoDB</code> の自動デッドロック検出では、このようなテーブルロックが関与するデッドロックを検出できません。また、この場合には上位の MySQL レイヤーは行レベルロックを識別しないため、現在別のセッションが行レベルロックを保持しているテーブル上でテーブルロックを取得できます。ただし、<a class="xref" href="innodb-storage-engine.html#innodb-deadlock-detection" title="14.2.10 デッドロックの検出とロールバック">セクション14.2.10「デッドロックの検出とロールバック」</a>で説明したように、これによりトランザクションの完全性が危険にさらされることはありません。<a class="xref" href="innodb-storage-engine.html#innodb-restrictions" title="14.6.7 InnoDB テーブル上の制限">セクション14.6.7「InnoDB テーブル上の制限」</a>も参照してください。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-implicit-commit"></a>14.2.9 暗黙的なトランザクションコミットとロールバック</h3></div></div></div><a class="indexterm" name="idm139979074720736"></a><p>
      MySQL は、デフォルトで新しい接続のセッション開始時に自動コミットモードが有効になります。そのため、各 SQL ステートメントからエラーが返されなかった場合に、MySQL はそのステートメントのあとでコミットを実行します。ステートメントからエラーが返された場合、コミットまたはロールバックの動作はそのエラーによって異なります。<a class="xref" href="innodb-storage-engine.html#innodb-error-handling" title="14.19.4 InnoDB のエラー処理">セクション14.19.4「InnoDB のエラー処理」</a>を参照してください。
    </p><p>
      自動コミットが無効になっているセッションが、最後のトランザクションを明示的にコミットせずに終了した場合、MySQL はそのトランザクションをロールバックします。
    </p><p>
      一部のステートメントは、ユーザーがそのステートメントの実行前に <code class="literal">COMMIT</code> を実行した場合と同様に、暗黙的にトランザクションを終了します。詳細は、<a class="xref" href="sql-syntax.html#implicit-commit" title="13.3.3 暗黙的なコミットを発生させるステートメント">セクション13.3.3「暗黙的なコミットを発生させるステートメント」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-deadlock-detection"></a>14.2.10 デッドロックの検出とロールバック</h3></div></div></div><a class="indexterm" name="idm139979074712256"></a><a class="indexterm" name="idm139979074710160"></a><a class="indexterm" name="idm139979074707408"></a><a class="indexterm" name="idm139979074705296"></a><p>
      <code class="literal">InnoDB</code> では、自動的にトランザクションの<a class="link" href="glossary.html#glos_deadlock" title="デッドロック">デッドロック</a>が検出され、デッドロックを解除するためにトランザクション (複数の場合あり) がロールバックされます。<code class="literal">InnoDB</code> は、小さいトランザクションを選択してロールバックしようと試みます。トランザクションのサイズは、挿入、更新、または削除された行数によって決定されます。
    </p><p>
      <code class="literal">InnoDB</code> は、<code class="literal">innodb_table_locks = 1</code> (デフォルト) かつ <code class="literal">autocommit = 0</code> の場合にテーブルロックを認識し、それよりも上位の MySQL レイヤーは、行レベルロックを識別します。それ以外の場合、<code class="literal">InnoDB</code> は、MySQL <code class="literal">LOCK TABLES</code> ステートメントで設定されたテーブルロックまたは <code class="literal">InnoDB</code> 以外のストレージエンジンで設定されたロックが関連しているデッドロックを検出できません。このような状況を解決するには、<code class="literal">innodb_lock_wait_timeout</code> システム変数の値を設定します。
    </p><p>
      <code class="literal">InnoDB</code> でトランザクションの完全なロールバックが実行されると、トランザクションで設定されたすべてのロックが解放されます。ただし、エラーの結果として単一の SQL ステートメントのみがロールバックされると、ステートメントで設定された一部のロックが保持される可能性があります。これが発生する原因は、<code class="literal">InnoDB</code> では、どの行がどのステートメントで設定されたのかをあとで確認できないような形式で、行ロックが格納されるためです。
    </p><p>
      トランザクションで <code class="literal">SELECT</code> がストアドファンクションを呼び出し、そのファンクション内のステートメントに失敗した場合は、そのステートメントがロールバックされます。さらに、そのあとで <code class="literal">ROLLBACK</code> が実行された場合、トランザクション全体がロールバックされます。
    </p><p>
      デッドロックを回避するためにデータベース操作を編成する方法については、<a class="xref" href="innodb-storage-engine.html#innodb-deadlocks" title="14.2.11 デッドロックの対処方法">セクション14.2.11「デッドロックの対処方法」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-deadlocks"></a>14.2.11 デッドロックの対処方法</h3></div></div></div><p>
      このセクションは、<a class="xref" href="innodb-storage-engine.html#innodb-deadlock-detection" title="14.2.10 デッドロックの検出とロールバック">セクション14.2.10「デッドロックの検出とロールバック」</a>に示したデッドロックに関する概念情報に基づいています。ここでは、デッドロックが最小限になるようにデータベース操作を編成する方法、およびアプリケーションで必要となる後続のエラー処理について説明します。
    </p><p>
      <a class="link" href="glossary.html#glos_deadlock" title="デッドロック">デッドロック</a>は、トランザクションデータベースの古典的な問題ですが、特定のトランザクションをまったく実行できないほど発生頻度が高くなければ、危険ではありません。通常は、デッドロックが発生したためにトランザクションがロールバックされた場合に、それを再発行できる準備が常にできているようにアプリケーションを作成する必要があります。
    </p><p>
      <code class="literal">InnoDB</code> では自動行レベルロックが使用されます。単一の行を挿入または削除するだけのトランザクションの場合でも、デッドロックが発生する可能性があります。その原因は、これらの操作が実際には<span class="quote">「<span class="quote">原子的</span>」</span>でないためです。これらの操作では自動的に、挿入または削除される行のインデックスレコード (複数の可能性あり) にロックが設定されます。
    </p><p>
      次の方法を使用すれば、デッドロックに対処し、発生の可能性を減らすことができます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          いつでも、<code class="literal">SHOW ENGINE INNODB STATUS</code> コマンドを発行して、最近のデッドロックの原因を特定してください。これは、デッドロックが回避されるようにアプリケーションを調整する際に役立ちます。
        </p></li><li class="listitem"><p>
          頻繁にデッドロックの警告が発生することに懸念がある場合は、<code class="literal">innodb_print_all_deadlocks</code> 構成オプションを有効にして、より広範囲にわたるデバッグ情報を収集してください。MySQL の<a class="link" href="glossary.html#glos_error_log" title="エラーログ">エラーログ</a>には、最近のデッドロックだけでなく、各デッドロックに関する情報が記録されます。デバッグが完了したら、このオプションを無効にします。
        </p></li><li class="listitem"><p>
          デッドロックが原因でトランザクションに失敗した場合に、そのトランザクションを再発行できるように常に準備しておきます。デッドロックは危険ではありません。再度試してください。
        </p></li><li class="listitem"><p>
          トランザクションが競合する可能性を低くするために、トランザクションのサイズを小さく、期間を短く保ってください。
        </p></li><li class="listitem"><p>
          トランザクションが競合する可能性を低くするために、関連する一連の変更を行なった直後にトランザクションをコミットしてください。特に、コミットされていないトランザクションを含むインタラクティブな <span class="command"><strong>mysql</strong></span> セッションは、長時間開いたままにしないでください。
        </p></li><li class="listitem"><p>
          <a class="link" href="glossary.html#glos_locking_read" title="ロック読み取り">ロック読み取り</a> (<code class="literal">SELECT ... FOR UPDATE</code> または <code class="literal">SELECT ... LOCK IN SHARE MODE</code>) を使用する場合は、<code class="literal">READ COMMITTED</code> などの低い分離レベルを使用してみてください。
        </p></li><li class="listitem"><p>
          トランザクション内の複数のテーブルを変更する場合や、同じテーブル内のさまざまな行のセットを変更する場合は、毎回、これらの操作を一貫性のある順序で実行してください。その結果、トランザクションで明示的に定義されたキューが生成され、デッドロックは発生しません。たとえば、さまざまな場所で同様の <code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、および <code class="literal">DELETE</code> ステートメントのシーケンスを複数回コーディングするのではなく、データベース操作をアプリケーション内の関数に編成したり、ストアドルーチンを呼び出したりします。
        </p></li><li class="listitem"><p>
          テーブルに適切なインデックスを追加してください。これにより、クエリーでスキャンする必要のあるインデックスレコード数が減少するため、ロックの設定も減少します。MySQL サーバーがクエリーに最適であるとみなすインデックスを特定するために、<code class="literal">EXPLAIN SELECT</code> を使用してください。
        </p></li><li class="listitem"><p>
          ロックの使用を減らしてください。古いスナップショットからのデータを返すために、<code class="literal">SELECT</code> を許可する余裕がある場合は、<code class="literal">FOR UPDATE</code> または <code class="literal">LOCK IN SHARE MODE</code> 句を追加しないでください。同じトランザクション内の各一貫性読み取りでは、独自の新しいスナップショットから読み取られるため、<code class="literal">READ COMMITTED</code> 分離レベルを使用することが適切な方法です。
        </p></li><li class="listitem"><p>
          

          ほかに方法がなければ、テーブルレベルロックを使用してトランザクションを直列化してください。<code class="literal">InnoDB</code> テーブルなどのトランザクションテーブルで <code class="literal">LOCK TABLES</code> を使用する正しい方法は、(<code class="literal">START TRANSACTION</code> ではなく) <code class="literal">SET autocommit = 0</code> でトランザクションを開始し、そのあと <code class="literal">LOCK TABLES</code> を実行し、<code class="literal">UNLOCK TABLES</code> を呼び出す前にそのトランザクションを明示的にコミットすることです。たとえば、テーブル <code class="literal">t1</code> に書き込み、テーブル <code class="literal">t2</code> から読み取る必要がある場合は、次のように実行できます。
        </p><pre class="programlisting">
SET autocommit=0;
LOCK TABLES t1 WRITE, t2 READ, ...;
<em class="replaceable"><code>... do something with tables t1 and t2 here ...</code></em>
COMMIT;
UNLOCK TABLES;
</pre><p>
          テーブルレベルロックを使用すると、テーブルへの並列更新が抑制されるため、デッドロックが回避されますが、負荷の高いシステムで応答性が低くなるという犠牲が伴います。
        </p></li><li class="listitem"><p>
          トランザクションを直列化する別の方法は、単一行だけを含む補助<span class="quote">「<span class="quote">セマフォー</span>」</span>テーブルを作成することです。ほかのテーブルにアクセスする前に、各トランザクションでその行を更新してください。これにより、すべてのトランザクションが直列方式で発生します。直列化ロックは行レベルロックであるため、この場合、<code class="literal">InnoDB</code> のインスタントデッドロック検出アルゴリズムも機能することに注意してください。MySQL のテーブルレベルロックを使用してデッドロックを解決するには、タイムアウト方式を使用する必要があります。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-multi-versioning"></a>14.2.12 InnoDB マルチバージョン</h3></div></div></div><a class="indexterm" name="idm139979074632736"></a><a class="indexterm" name="idm139979074630592"></a><p>
      <code class="literal">InnoDB</code> は<a class="link" href="glossary.html#glos_mvcc" title="MVCC">マルチバージョンストレージエンジン</a>です。並列実行や<a class="link" href="glossary.html#glos_rollback" title="ロールバック">ロールバック</a>などのトランザクション機能をサポートするために、変更された行の古いバージョンに関する情報が保持されます。この情報は、テーブルスペース内に<a class="link" href="glossary.html#glos_rollback_segment" title="ロールバックセグメント">ロールバックセグメント</a>と呼ばれるデータ構造で (Oracle では類似したデータ構造のあとに) 格納されます。<code class="literal">InnoDB</code> では、トランザクションのロールバックで必要となる取り消し操作を実行するために、ロールバックセグメント内の情報が使用されます。また、この情報は、<a class="link" href="glossary.html#glos_consistent_read" title="一貫性読み取り">一貫性読み取り</a>のために行の初期バージョンを構築する際にも使用されます。
    </p><h4><a name="idm139979074622240"></a>マルチバージョン内部の詳細</h4><p>
      <code class="literal">InnoDB</code> は内部的に、データベース内に格納された各行に 3 つのフィールドを追加します。6 バイトの <code class="literal">DB_TRX_ID</code> フィールドは、行を挿入または更新した最後のトランザクションに対して、トランザクション識別子を指示します。また、行内の特別ビットが削除されたとマークするように設定されている場合、削除は内部的に更新として処理されます。各行には、ロールポインタと呼ばれる 7 バイトの <code class="literal">DB_ROLL_PTR</code> フィールドも含まれています。ロールポインタは、ロールバックセグメントに書き込まれた Undo ログレコードを示しています。行が更新された場合は、Undo ログレコードに、更新される前の行の内容を再構築するために必要な情報が含まれます。6 バイトの <code class="literal">DB_ROW_ID</code> フィールドには、新しい行が挿入されると単調に増加する行 ID が含まれています。<code class="literal">InnoDB</code> によって自動生成されたクラスタ化されたインデックスには、行 ID 値が含まれます。それ以外の場合、インデックスに <code class="literal">DB_ROW_ID</code> カラムが含まれることはありません。
    </p><p>
      ロールバックセグメント内の Undo ログは、挿入および更新 Undo ログに分割されます。挿入 Undo ログはトランザクションロールバックでのみ必要であるため、トランザクションのコミット直後に破棄できます。更新 Undo ログも一貫性読み取りで使用されますが、<code class="literal">InnoDB</code> によってスナップショットが割り当てられたトランザクションが存在しなくなったあとでのみ破棄できます。更新 Undo ログ内のスナップショット情報は、データベース行の以前のバージョンを構築する際に一貫性読み取りで必要となる可能性があります。
    </p><h4><a name="idm139979074612464"></a>ロールバックセグメントを管理するためのガイドライン</h4><p>
      トランザクション (一貫性読み取りのみを発行するトランザクションを含む) を定期的にコミットしてください。それ以外の場合は、<code class="literal">InnoDB</code> は更新 Undo ログからデータを破棄できないため、ロールバックセグメントが大きくなり過ぎてテーブルスペースがいっぱいになる可能性があります。
    </p><p>
      一般に、ロールバックセグメント内の Undo ログレコードの物理的サイズは、それに対応する挿入された行や更新された行よりも小さいです。この情報を使用すると、ロールバックセグメントで必要となる領域を計算できます。
    </p><p>
      <code class="literal">InnoDB</code> マルチバージョンスキームでは、SQL ステートメントで行を削除しても、その行はすぐにデータベースから物理的に削除されません。<code class="literal">InnoDB</code> は、削除用に書き込まれた更新 Undo ログレコードが破棄されたときにのみ、対応する行およびそのインデックスレコードを物理的に削除します。このような削除操作は<a class="link" href="glossary.html#glos_purge" title="パージ">パージ</a>と呼ばれ、非常に高速です。通常は、削除が行われなかった SQL ステートメントと同じ時系列順で実行されます。
    </p><p>
      テーブル内で小さめのバッチの行をほぼ同じ速度で挿入および削除すると、すべての<span class="quote">「<span class="quote">デッド</span>」</span>行が原因で、パージスレッドが遅延し始め、増加し続ける可能性があります。これにより、すべてにおいてディスクが抑制され、非常に低速になります。このような場合は、新たな行操作を抑制し、<code class="literal">innodb_max_purge_lag</code> システム変数を調整することで、より多くのリソースをパージスレッドに割り当てます。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-parameters" title="14.12 InnoDB の起動オプションおよびシステム変数">セクション14.12「InnoDB の起動オプションおよびシステム変数」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-table-and-index"></a>14.2.13 InnoDB テーブルおよびインデックスの構造</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-frm-file">14.2.13.1 InnoDB テーブル用の .frm ファイルの役割</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-index-types">14.2.13.2 クラスタインデックスとセカンダリインデックス</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-fulltext-index">14.2.13.3 FULLTEXT インデックス</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-physical-structure">14.2.13.4 InnoDB インデックスの物理構造</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-insert-buffering">14.2.13.5 挿入バッファー</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-adaptive-hash">14.2.13.6 適応型ハッシュインデックス</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-physical-record">14.2.13.7 物理的な行構造</a></span></dt></dl></div><a class="indexterm" name="idm139979074599840"></a><a class="indexterm" name="idm139979074597728"></a><p>
      このセクションでは、<code class="literal">InnoDB</code> のテーブル、インデックス、およびこれらに関連付けられたメタデータを物理レベルで表示する方法について説明します。この情報は、主にパフォーマンスチューニングおよびトラブルシューティングに役立ちます。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-frm-file"></a>14.2.13.1 InnoDB テーブル用の .frm ファイルの役割</h4></div></div></div><p>
        MySQL では、データベースディレクトリ内の <a class="link" href="glossary.html#glos_frm_file" title=".frm ファイル">.frm ファイル</a>に、テーブルに関するそのデータディクショナリ情報が格納されます。その他の MySQL ストレージエンジンとは異なり、<code class="literal">InnoDB</code> では、テーブルスペース内にある独自の内部データディクショナリのテーブルに関する情報のエンコードも行われます。MySQL でテーブルまたはデータベースが削除されると、1 つ以上の <code class="filename">.frm</code> ファイルおよび <code class="literal">InnoDB</code> データディクショナリ内の対応するエントリも削除されます。単に <code class="filename">.frm</code> ファイルを移動するだけでは、データベース間で <code class="literal">InnoDB</code> テーブルを移動できません。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-index-types"></a>14.2.13.2 クラスタインデックスとセカンダリインデックス</h4></div></div></div><a class="indexterm" name="idm139979074582160"></a><a class="indexterm" name="idm139979074580064"></a><a class="indexterm" name="idm139979074577856"></a><a class="indexterm" name="idm139979074575904"></a><p>
        すべての <code class="literal">InnoDB</code> テーブルは、行のデータが格納されている<a class="link" href="glossary.html#glos_clustered_index" title="クラスタ化されたインデックス">クラスタ化されたインデックス</a>と呼ばれる特別なインデックスを持っています。一般に、クラスタ化されたインデックスは<a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a>のシノニムです。クエリー、挿入、およびその他のデータベース操作で最適なパフォーマンスを実現するには、InnoDB がクラスタ化されたインデックスを使用して、テーブルごとにもっとも一般的な検索と DML 操作を最適化する方法について理解する必要があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            テーブル上で <code class="literal">PRIMARY KEY</code> を定義すると、<code class="literal">InnoDB</code> ではそれがクラスタ化されたインデックスとして使用されます。作成するテーブルごとに主キーを定義します。論理的に一意で、Null 以外のカラムまたはカラムのセットが存在しない場合は、自動的に値が入力される新しい<a class="link" href="glossary.html#glos_auto_increment" title="自動インクリメント">自動インクリメント</a>カラムを追加します。
          </p></li><li class="listitem"><p>
            テーブルに <code class="literal">PRIMARY KEY</code> が定義されていない場合、MySQL はすべてのキーカラムが <code class="literal">NOT NULL</code> の <code class="literal">UNIQUE</code> インデックスを最初に検索し、<code class="literal">InnoDB</code> はそれをクラスタ化されたインデックスとして使用します。
          </p></li><li class="listitem"><p>
            テーブルに <code class="literal">PRIMARY KEY</code> も適切な <code class="literal">UNIQUE</code> インデックスも存在しない場合には、<code class="literal">InnoDB</code> の内部で、行 ID 値を含む合成カラム上に非表示のクラスタ化されたインデックスが生成されます。そのようなテーブルでは、<code class="literal">InnoDB</code> が行に割り当てる ID に基づいて行の順序付けが行われます。行 ID は、新しい行が挿入されると単調に増加する 6 バイトのフィールドです。したがって、行 ID で順序付けられた行が物理的な挿入順になります。
          </p></li></ul></div><h5><a name="idm139979074556912"></a>クラスタ化されたインデックスでクエリーを高速にする方法</h5><p>
        クラスタ化されたインデックスから行にアクセスすると、インデックス検索がすべての行データを持つページで直接実行されるため、高速になります。多くの場合、テーブルのサイズが大きい場合にクラスタ化されたインデックスアーキテクチャーを使用すれば、インデックスレコードとは別のページに行データを格納するストレージ編成と比べて、ディスク I/O 操作を節約できます。(たとえば <code class="literal">MyISAM</code> では、データ行に使用されるファイルとインデックスレコードに使用されるファイルは異なります。)
      </p><h5><a name="idm139979074554080"></a>セカンダリインデックスとクラスタ化されたインデックスとの関係</h5><p>
        クラスタ化されたインデックス以外のインデックスは、すべて<a class="link" href="glossary.html#glos_secondary_index" title="セカンダリインデックス">セカンダリインデックス</a>と呼ばれます。<code class="literal">InnoDB</code> では、セカンダリインデックス内の各レコードに、行の主キーカラム、およびセカンダリインデックスに指定されたカラムが含まれます。<code class="literal">InnoDB</code> では、クラスタ化されたインデックス内で行を検索する際に、この主キー値が使用されます。
      </p><p>
        主キーが長くなると、セカンダリインデックスで使用される領域も多くなるため、主キーは短い方が利点があります。
      </p><p>
        <code class="literal">InnoDB</code> のクラスタインデックスおよびセカンダリインデックスの利点を得るためのコーディングのガイドラインについては、<a class="xref" href="optimization.html#optimizing-primary-keys" title="8.3.2 主キーの使用">セクション8.3.2「主キーの使用」</a>、<a class="xref" href="optimization.html#optimization-indexes" title="8.3 最適化とインデックス">セクション8.3「最適化とインデックス」</a>、<a class="xref" href="optimization.html#optimizing-innodb" title="8.5 InnoDB テーブルの最適化">セクション8.5「InnoDB テーブルの最適化」</a>、<a class="xref" href="optimization.html#optimizing-primary-keys" title="8.3.2 主キーの使用">セクション8.3.2「主キーの使用」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-fulltext-index"></a>14.2.13.3 FULLTEXT インデックス</h4></div></div></div><a class="indexterm" name="idm139979074543696"></a><a class="indexterm" name="idm139979074541648"></a><p>
        テキストベースのカラム (<code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、または <code class="literal">TEXT</code> カラム) 上に作成されたインデックスのタイプです。これを使用すると、ストップワードとして定義されている任意の単語が省略されることで、これらのカラム内に含まれるデータ上での <code class="literal">InnoDB</code> のクエリーおよび DML 操作の速度を上げる際に役立ちます。
      </p><p>
        <code class="literal">FULLTEXT</code> インデックスは、<code class="literal">CREATE TABLE</code> ステートメントの一部として定義することも、あとで <code class="literal">ALTER TABLE</code> または <code class="literal">CREATE INDEX</code> を使用して追加することもできます。
      </p><p>
        全文検索は、<code class="literal">MATCH() ... AGAINST</code> 構文を使用して実行されます。使用法については、<a class="xref" href="functions.html#fulltext-search" title="12.9 全文検索関数">セクション12.9「全文検索関数」</a>を参照してください。
      </p><h5><a name="idm139979074527984"></a>全文インデックスの設計</h5><p>
        <code class="literal">InnoDB</code> の <code class="literal">FULLTEXT</code> インデックスでは、<span class="quote">「<span class="quote">転置インデックス</span>」</span>の設計が使用されています。転置インデックスには、単語のリスト、および単語ごとに、その単語が出現するドキュメントのリストが格納されます。近接検索をサポートするために、単語ごとの位置情報もバイトオフセットとして格納されます。
      </p><h5><a name="idm139979074524304"></a>全文インデックステーブル</h5><p>
        次の例に示すように、<code class="literal">InnoDB</code> の <code class="literal">FULLTEXT</code> インデックスごとに、インデックステーブルのセットが作成されます。
      </p><pre class="programlisting">CREATE TABLE opening_lines (
id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,
opening_line TEXT(500),
author VARCHAR(200),
title VARCHAR(200),
FULLTEXT idx (opening_line)
) ENGINE=InnoDB;

mysql&gt; SELECT table_id, name, space from INFORMATION_SCHEMA.INNODB_SYS_TABLES WHERE name LIKE 'test/%';
+----------+----------------------------------------------------+-------+
| table_id | name                                               | space |
+----------+----------------------------------------------------+-------+
|      333 | test/FTS_0000000000000147_00000000000001c9_INDEX_1 |   289 |
|      334 | test/FTS_0000000000000147_00000000000001c9_INDEX_2 |   290 |
|      335 | test/FTS_0000000000000147_00000000000001c9_INDEX_3 |   291 |
|      336 | test/FTS_0000000000000147_00000000000001c9_INDEX_4 |   292 |
|      337 | test/FTS_0000000000000147_00000000000001c9_INDEX_5 |   293 |
|      338 | test/FTS_0000000000000147_00000000000001c9_INDEX_6 |   294 |
|      330 | test/FTS_0000000000000147_BEING_DELETED            |   286 |
|      331 | test/FTS_0000000000000147_BEING_DELETED_CACHE      |   287 |
|      332 | test/FTS_0000000000000147_CONFIG                   |   288 |
|      328 | test/FTS_0000000000000147_DELETED                  |   284 |
|      329 | test/FTS_0000000000000147_DELETED_CACHE            |   285 |
|      327 | test/opening_lines                                 |   283 |
+----------+----------------------------------------------------+-------+
12 rows in set (0.02 sec)    </pre><p>
        最初の 6 つのテーブルは転置インデックスを表し、<span class="quote">「<span class="quote">近接検索インデックステーブル</span>」</span>と呼ばれます。受信ドキュメントがトークン化されると、各単語が位置情報およびドキュメント ID (<code class="literal">DOC_ID</code>) とともに、インデックステーブルに挿入されます。単語は完全にソートされてから、単語の最初の文字の文字セット重みに基づいて、6 つのインデックステーブル間でパーティション化されます。
      </p><p>
        転置インデックスは、インデックスの並列作成をサポートするために、6 つの補助インデックステーブルに<span class="quote">「<span class="quote">パーティション化</span>」</span>されます。デフォルトでは、2 つのスレッドを使用して、単語および関連するデータのトークン化、ソート、およびインデックステーブルへの挿入が実行されます。スレッドの数は、<code class="literal">innodb_ft_sort_pll_degree</code> オプションを使用することで構成可能です。大きなテーブル上に <code class="literal">FULLTEXT</code> インデックスを作成する際には、スレッドの数を多くすることを検討してください。
      </p><p>
        補助インデックステーブル名の前には <code class="literal">FTS_</code>、後ろには <code class="literal">INDEX_*</code> が付けられます。各インデックステーブルは、インデックス付きのテーブルの <code class="literal">table_id</code> と一致するインデックステーブル名に含まれる 16 進値によって、インデックス付きのテーブルに関連付けられます。たとえば、<code class="literal">test/opening_lines</code> テーブルの <code class="literal">table_id</code> は <code class="literal">327</code> (16 進値は 0x147) です。前述の例で示したように、16 進値の <span class="quote">「<span class="quote">147</span>」</span> は、<code class="literal">test/opening_lines</code> テーブルに関連付けられたインデックステーブルの名前に表示されます。
      </p><p>
        補助インデックス名に表示されるもう 1 つの 16 進値は、<code class="literal">FULLTEXT</code> インデックスの <code class="literal">index_id</code> です。たとえば、補助テーブル名 <code class="literal">test/FTS_0000000000000147_00000000000001c9_INDEX_1</code> では、16 進値 <code class="literal">1c9</code> の 10 進値は 457 です。<code class="literal">opening_lines</code> テーブルで定義されたインデックス (<code class="literal">idx</code>) は、<code class="literal">INFORMATION_SCHEMA.INNODB_SYS_INDEXES</code> テーブルでこの値 (457) に対してクエリーを実行することで識別できます。
      </p><pre class="programlisting">mysql&gt; SELECT index_id, name, table_id, space from INFORMATION_SCHEMA.INNODB_SYS_INDEXES WHERE index_id=457;
+----------+------+----------+-------+
| index_id | name | table_id | space |
+----------+------+----------+-------+
|      457 | idx  |      327 |   283 |
+----------+------+----------+-------+
1 row in set (0.00 sec)     </pre><p>
        <code class="literal">innodb_file_per_table</code> を有効にすると、インデックステーブルが独自のテーブルスペースに格納されます。<code class="literal">innodb_file_per_table</code> を無効にすると、インデックステーブルが <code class="literal">InnoDB</code> のシステムテーブルスペース (スペース 0) に格納されます。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          MySQL 5.6.5 で導入されたバグが原因で、<code class="literal">innodb_file_per_table</code> を有効にしても、インデックステーブルは <code class="literal">InnoDB</code> のシステムテーブルスペース (スペース 0) に作成されます。このバグは、MySQL 5.6.20 および MySQL 5.7.5 で修正されました (Bug#18635485)。
        </p></div><p>
        前述の例で示したその他のインデックステーブルは、<code class="literal">FULLTEXT</code> インデックスの削除処理および内部状態の格納で使用されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">FTS_*_DELETED</code> および <code class="literal">FTS_*_DELETED_CACHE</code>: 削除されるが、データはまだ全文インデックスから削除されないドキュメントのドキュメント ID (DOC_ID) が含まれます。<code class="literal">FTS_*_DELETED_CACHE</code> は、<code class="literal">FTS_*_DELETED</code> テーブルのインメモリーバージョンです。
          </p></li><li class="listitem"><p>
            <code class="literal">FTS_*_BEING_DELETED</code> および <code class="literal">FTS_*_BEING_DELETED_CACHE</code>: 削除され、現在データが全文インデックスから削除中であるドキュメントのドキュメント ID (DOC_ID) が含まれます。<code class="literal">FTS_*_BEING_DELETED_CACHE</code> テーブルは、<code class="literal">FTS_*_BEING_DELETED</code> テーブルのインメモリーバージョンです。
          </p></li><li class="listitem"><p>
            <code class="literal">FTS_*_CONFIG</code>: <code class="literal">FULLTEXT</code> インデックスの内部状態に関する情報が格納されます。もっとも重要な点は、解析され、ディスクにフラッシュされたドキュメントを識別する <code class="literal">FTS_SYNCED_DOC_ID</code> が格納されることです。クラッシュリカバリの場合、ドキュメントを再解析し、<code class="literal">FULLTEXT</code> インデックスキャッシュに追加し直すことができるように、ディスクにフラッシュされていないドキュメントを識別する際に、<code class="literal">FTS_SYNCED_DOC_ID</code> 値が使用されます。このテーブル内のデータを表示するには、<code class="literal">INFORMATION_SCHEMA.INNODB_FT_CONFIG</code> テーブルでクエリーを実行します。
          </p></li></ul></div><h5><a name="idm139979074475584"></a>全文インデックスキャッシュ</h5><p>
        ドキュメントが挿入されると、トークン化され、各単語および関連付けられたデータが <code class="literal">FULLTEXT</code> インデックスに挿入されます。このプロセスが実行されると、小さなドキュメントの場合でも、補助インデックステーブルへの多数の小規模な挿入が発生します。これにより、競合の発生時に、これらのテーブルへの並列アクセスが発生する可能性があります。この問題を回避するために、<code class="literal">InnoDB</code> では、最近挿入された行に対するインデックステーブルの挿入を一時的にキャッシュに入れるために、<code class="literal">FULLTEXT</code> インデックスキャッシュが使用されます。この<span class="quote">「<span class="quote">インメモリー</span>」</span>キャッシュの構造では、キャッシュがいっぱいになるまで挿入が保持され、そのあと、ディスク (補助インデックステーブル) にバッチフラッシュされます。<code class="literal">INFORMATION_SCHEMA.INNODB_FT_INDEX_CACHE</code> テーブルでクエリーを実行すると、最近挿入された行のトークン化されたデータを表示できます。
      </p><p>
        キャッシュおよびバッチフラッシュの動作によって、補助インデックステーブルへの頻繁な更新が回避されますが、負荷の高い挿入時および更新時に並列アクセスの問題が発生する可能性があります。また、バッチ技術を使用すると、同じ単語への挿入が複数回発生することも回避され、重複エントリも最小限になります。各単語を個別にフラッシュする代わりに、同じ単語の挿入がマージされ、単一のエントリとしてディスクにフラッシュされるため、補助インデックステーブルのサイズをできるかぎり小さく保ちながら、挿入の効率性が改善されます。
      </p><p>
        全文インデックスキャッシュのサイズを (テーブルごとに) 構成するには、<code class="literal">innodb_ft_cache_size</code> 変数が使用されます。これにより、全文インデックスキャッシュがフラッシュされる頻度が影響を受けます。特定のインスタンスで <code class="literal">innodb_ft_total_cache_size</code> オプションを使用すれば、すべてのテーブルに対応したグローバルな全文インデックスキャッシュのサイズ制限を定義することもできます。
      </p><p>
        全文インデックスキャッシュには、補助インデックステーブルと同じ情報が格納されます。ただし、全文インデックスキャッシュでは、最近挿入された行のトークン化されたデータのみがキャッシュに入れられます。すでにディスク (全文補助テーブル) にフラッシュされているデータは、クエリー時に全文インデックスキャッシュに戻りません。補助インデックステーブル内のデータは、直接クエリーが実行されます。補助インデックステーブルからの結果は、全文インデックスキャッシュからの結果とマージされてから返されます。
      </p><h5><a name="idm139979074462000"></a>InnoDB の全文ドキュメント ID および FTS_DOC_ID カラム</h5><p>
        <code class="literal">InnoDB</code> では、全文インデックス内の単語をその単語が出現するドキュメントレコードとマップする際に、ドキュメント ID (<code class="literal">DOC_ID</code>) と呼ばれる一意のドキュメント識別子が使用されます。このマッピングには、インデックス付きテーブル上の <code class="literal">FTS_DOC_ID</code> カラムが必要です。<code class="literal">FTS_DOC_ID</code> カラムが定義されていない場合は、全文インデックスの作成時に、<code class="literal">InnoDB</code> によって自動的に非表示の <code class="literal">FTS_DOC_ID</code> カラムが追加されます。次の例で、この動作を実演します。
      </p><p>
        次のテーブル定義には、<code class="literal">FTS_DOC_ID</code> カラムが含まれていません。
      </p><pre class="programlisting">CREATE TABLE opening_lines (
id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,
opening_line TEXT(500),
author VARCHAR(200),
title VARCHAR(200)
) ENGINE=InnoDB;    </pre><p>
        <code class="literal">CREATE FULLTEXT INDEX</code> 構文を使用して、テーブル上に全文インデックスを作成すると、<code class="literal">FTS_DOC_ID</code> カラムが追加されるように <code class="literal">InnoDB</code> がテーブルを再構築してしていることをレポートする警告が返されます。
      </p><pre class="programlisting">mysql&gt; CREATE FULLTEXT INDEX idx ON opening_lines(opening_line);
Query OK, 0 rows affected, 1 warning (0.19 sec)
Records: 0  Duplicates: 0  Warnings: 1

mysql&gt; SHOW WARNINGS;
+---------+------+--------------------------------------------------+
| Level   | Code | Message                                          |
+---------+------+--------------------------------------------------+
| Warning |  124 | InnoDB rebuilding table to add column FTS_DOC_ID |
+---------+------+--------------------------------------------------+
1 row in set (0.00 sec)    </pre><p>
        <code class="literal">ALTER TABLE</code> を使用して、<code class="literal">FTS_DOC_ID</code> カラムが存在しないテーブルに全文インデックスを追加するときにも、同じ警告が返されます。<code class="literal">CREATE TABLE</code> の実行時に全文インデックスを作成する場合に、<code class="literal">FTS_DOC_ID</code> カラムを定義しないと、<code class="literal">InnoDB</code> によって警告なしで、非表示の <code class="literal">FTS_DOC_ID</code> カラムが追加されます。
      </p><p>
        <code class="literal">CREATE TABLE</code> の実行時に <code class="literal">FTS_DOC_ID</code> カラムを定義するには、すでにデータがロードされているテーブル上に全文インデックスを作成する必要があります。データをロードする前に、テーブル上に <code class="literal">FTS_DOC_ID</code> カラムが定義されている場合は、新しいカラムが追加されるようにテーブルおよびそのインデックスを再構築する必要がありません。<code class="literal">CREATE FULLTEXT INDEX</code> のパフォーマンスに関心がない場合は、<code class="literal">InnoDB</code> で自動的に作成されるように、<code class="literal">FTS_DOC_ID</code> カラムを除外します。<code class="literal">InnoDB</code> によって、<code class="literal">FTS_DOC_ID_INDEX</code> という名前の <code class="literal">FTS_DOC_ID</code> カラム上に、一意のインデックスとともに非表示の <code class="literal">FTS_DOC_ID</code> が作成されます。独自の <code class="literal">FTS_DOC_ID</code> カラムを作成する場合は、次の例で示すように、カラムを <code class="literal">BIGINT UNSIGNED NOT NULL</code> として定義し、<code class="literal">FTS_DOC_ID</code> (すべて大文字) という名前を付けます。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">AUTO_INCREMENT</code> として <code class="literal">FTS_DOC_ID</code> カラムを定義する必要がありませんが、<code class="literal">AUTO_INCREMENT</code> を使用した方が簡単にデータをロードできます。
        </p></div><pre class="programlisting">CREATE TABLE opening_lines (
FTS_DOC_ID BIGINT UNSIGNED AUTO_INCREMENT NOT NULL,
opening_line TEXT(500),
author VARCHAR(200),
title VARCHAR(200)
) ENGINE=InnoDB;    </pre><p>
        <code class="literal">FTS_DOC_ID</code> カラムをユーザー自身で定義するように決定した場合は、空の値や重複する値が回避されるようにカラムを管理することがユーザーの責任となります。<code class="literal">FTS_DOC_ID</code> 値は再使用できません。つまり、<code class="literal">FTS_DOC_ID</code> 値は増加し続けます。
      </p><p>
        オプションで、<code class="literal">FTS_DOC_ID</code> カラム上に必要な一意の <code class="literal">FTS_DOC_ID_INDEX</code> (すべて大文字) を作成することもできます。
      </p><pre class="programlisting">CREATE UNIQUE INDEX FTS_DOC_ID_INDEX on opening_lines(FTS_DOC_ID);</pre><p>
        <code class="literal">FTS_DOC_ID_INDEX</code> を作成しない場合は、<code class="literal">InnoDB</code> によって自動的に作成されます。
      </p><h5><a name="idm139979074418992"></a>InnoDB による全文インデックスの削除処理</h5><p>
        全文インデックスカラムが含まれるレコードを削除すると、補助インデックステーブルへの多数の小規模な削除が発生します。これにより、競合の発生時に、これらのテーブルへの並列アクセスが発生する可能性があります。この問題を回避するために、インデックス付きのテーブルからレコードが削除されるたびに、削除されたドキュメントのドキュメント ID (<code class="literal">DOC_ID</code>) が特別な <span class="quote">「<span class="quote">DELETED</span>」</span> テーブルに記録され、インデックス付きのレコードが全文インデックスに残ります。クエリーの結果が返される前に、<span class="quote">「<span class="quote">DELETED</span>」</span> テーブル内の情報を使用して、削除されたドキュメント ID が取り除かれます。この設計の利点は、削除が高速で、低負荷であることです。欠点は、レコードの削除後に、すぐにインデックスのサイズが削減されないことです。削除したエントリの全文インデックスエントリを削除するには、<code class="literal">innodb_optimize_fulltext_only=ON</code> を使用してインデックス付きのテーブル上で <code class="literal">OPTIMIZE TABLE</code> を実行して、全文インデックスを再構築します。詳細は、<a class="xref" href="functions.html#fulltext-optimize" title="InnoDB 全文インデックスの最適化">InnoDB 全文インデックスの最適化</a>を参照してください。
      </p><h5><a name="idm139979074411792"></a>InnoDB による全文インデックスのトランザクション処理</h5><p>
        <code class="literal">InnoDB</code> の <code class="literal">FULLTEXT</code> インデックスには、そのキャッシュおよびバッチ処理の動作のために、特別なトランザクション処理の特性が備わっています。特に、<code class="literal">FULLTEXT</code> インデックス上の更新および挿入は、トランザクションのコミット時に処理されます。つまり、<code class="literal">FULLTEXT</code> 検索では、コミットされたデータのみを表示できます。次の例で、この動作を実演します。<code class="literal">FULLTEXT</code> 検索では、挿入された行がコミットされたあとにはじめて、結果が返されます。
      </p><pre class="programlisting">mysql&gt; CREATE TABLE opening_lines (
id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,
opening_line TEXT(500),
author VARCHAR(200),
title VARCHAR(200),
FULLTEXT idx (opening_line)
) ENGINE=InnoDB;

mysql&gt; BEGIN;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; INSERT INTO opening_lines(opening_line,author,title) VALUES
('Call me Ishmael.','Herman Melville','Moby-Dick'),
('A screaming comes across the sky.','Thomas Pynchon','Gravity\'s Rainbow'),
('I am an invisible man.','Ralph Ellison','Invisible Man'),
('Where now? Who now? When now?','Samuel Beckett','The Unnamable'),
('It was love at first sight.','Joseph Heller','Catch-22'),
('All this happened, more or less.','Kurt Vonnegut','Slaughterhouse-Five'),
('Mrs. Dalloway said she would buy the flowers herself.','Virginia Woolf','Mrs. Dalloway'),
('It was a pleasure to burn.','Ray Bradbury','Fahrenheit 451');
Query OK, 8 rows affected (0.00 sec)
Records: 8  Duplicates: 0  Warnings: 0

mysql&gt; SELECT COUNT(*) FROM opening_lines WHERE MATCH(opening_line) AGAINST('Ishmael');
+----------+
| COUNT(*) |
+----------+
|        0 |
+----------+
1 row in set (0.00 sec)

mysql&gt; COMMIT;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; SELECT COUNT(*) FROM opening_lines WHERE MATCH(opening_line) AGAINST('Ishmael');
+----------+
| COUNT(*) |
+----------+
|        1 |
+----------+
1 row in set (0.00 sec)    </pre><h5><a name="idm139979074402992"></a>InnoDB による全文インデックスのモニター</h5><p>
        次の <code class="literal">INFORMATION_SCHEMA</code> テーブルでクエリーを実行すると、<code class="literal">InnoDB</code> の <code class="literal">FULLTEXT</code> インデックスの特別なテキスト処理の側面をモニターおよび調査できます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">INNODB_FT_CONFIG</code>
          </p></li><li class="listitem"><p>
            <code class="literal">INNODB_FT_INDEX_TABLE</code>
          </p></li><li class="listitem"><p>
            <code class="literal">INNODB_FT_INDEX_CACHE</code>
          </p></li><li class="listitem"><p>
            <code class="literal">INNODB_FT_DEFAULT_STOPWORD</code>
          </p></li><li class="listitem"><p>
            <code class="literal">INNODB_FT_DELETED</code>
          </p></li><li class="listitem"><p>
            <code class="literal">INNODB_FT_BEING_DELETED</code>
          </p></li></ul></div><p>
        <code class="literal">INNODB_SYS_INDEXES</code> および <code class="literal">INNODB_SYS_TABLES</code> でクエリーを実行すると、<code class="literal">FULLTEXT</code> インデックスおよびテーブルに関する基本情報を表示することもできます。
      </p><p>
        これらのテーブルについての詳細は、<a class="link" href="information-schema.html" title="第 21 章 INFORMATION_SCHEMA テーブル">INFORMATION_SCHEMA</a> のドキュメントを参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-physical-structure"></a>14.2.13.4 InnoDB インデックスの物理構造</h4></div></div></div><a class="indexterm" name="idm139979074381136"></a><a class="indexterm" name="idm139979074379104"></a><a class="indexterm" name="idm139979074376960"></a><a class="indexterm" name="idm139979074375600"></a><p>
        すべての <code class="literal">InnoDB</code> インデックスは、インデックスレコードがツリーのリーフページ内に格納される <a class="link" href="glossary.html#glos_b_tree" title="B ツリー">B ツリー</a>です。インデックスページのデフォルトサイズは 16K バイトです。新しいレコードが挿入されると、<code class="literal">InnoDB</code> はページの 1/16 を、将来のインデックスレコードの挿入や更新に備えて空けようとします。
      </p><p>
        インデックスレコードが順次 (昇順または降順) に挿入されると、インデックスページの約 15/16 までがいっぱいになります。レコードがランダムに挿入された場合は、ページの 1/2 から 15/16 までがいっぱいになります。インデックスページの<a class="link" href="glossary.html#glos_fill_factor" title="フィルファクタ">フィルファクタ</a>が 1/2 を下回ると、<code class="literal">InnoDB</code> はページを解放するために、インデックスツリーを縮小しようとします。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          インスタンスを作成する前に、<code class="literal">innodb_page_size</code> 構成オプションを設定すると、MySQL インスタンス内のすべての <code class="literal">InnoDB</code> テーブルスペースの<a class="link" href="glossary.html#glos_page_size" title="page size">ページサイズ</a>を指定できます。一度 MySQL インスタンスのページサイズが設定されたら、変更できません。サポートされるサイズは、オプションの値 <code class="literal">16k</code>、<code class="literal">8k</code>、および <code class="literal">4k</code> に対応する 16K バイト、8K バイト、および 4K バイトです。
        </p><p>
          特定の <code class="literal">InnoDB</code> ページサイズを使用している MySQL インスタンスは、別のページサイズを使用するインスタンスのデータファイルやログファイルを使用できません。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-insert-buffering"></a>14.2.13.5 挿入バッファー</h4></div></div></div><a class="indexterm" name="idm139979074358384"></a><a class="indexterm" name="idm139979074356224"></a><p>
        多くの場合、データベースアプリケーションでは、新しい行が主キーの昇順で挿入されます。この場合、クラスタ化されたインデックスの順序が主キーと同じであるというレイアウトのために、InnoDB テーブルへの挿入時に、ディスクからのランダムな読み取りが必要ありません。
      </p><p>
        その一方で、通常、セカンダリインデックスは一意ではなく、セカンダリインデックスへの挿入は比較的ランダムな順序で発生します。同様に、削除および更新によって、セカンダリインデックス内の隣接しないデータページが影響を受ける可能性があります。このため、<code class="literal">InnoDB</code> で特別なメカニズムが使用されることなく、多数のランダムなディスク I/O が発生します。
      </p><p>
        インデックスレコードを挿入したり、削除対象のマークを付けたり、一意でないセカンダリインデックスから削除したりすると、<code class="literal">InnoDB</code> によって、セカンダリインデックスが<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>内に存在するかどうかがチェックされます。これに該当する場合は、<code class="literal">InnoDB</code> によって変更が直接インデックスページに適用されます。バッファープール内にインデックスページが見つからない場合は、<code class="literal">InnoDB</code> によって、<a class="link" href="glossary.html#glos_insert_buffer" title="挿入バッファー">挿入バッファー</a>と呼ばれる特別な構造に変更が記録されます。挿入バッファーは、バッファープール内に完全に収容されるようにサイズが小さく保たれるため、変更を非常にすばやく適用できます。このプロセスは、<a class="link" href="glossary.html#glos_change_buffering" title="変更バッファリング">変更バッファー</a>と呼ばれます。(以前は、挿入にのみ適用されていたため、挿入バッファーと呼ばれていました。データ構造は、引き続き挿入バッファーと呼ばれています。)
      </p><h5><a name="idm139979074345328"></a>挿入バッファーをフラッシュするためのディスク I/O</h5><p>
        挿入バッファーは、データベース内のセカンダリインデックスツリーに定期的にマージされます。多くの場合は、複数の変更をインデックスツリーの同じページにマージできるため、ディスク I/O 操作を節約できます。挿入バッファーによって、テーブルへの挿入速度が最大 15 倍に上昇すると測定されています。
      </p><p>
        挿入バッファーのマージは、トランザクションがコミットされた<span class="emphasis"><em>あとに</em></span>、発生し続ける可能性があります。実際、これはサーバーがシャットダウンし、再起動したあとまで発生し続ける可能性があります (<a class="xref" href="innodb-storage-engine.html#forcing-innodb-recovery" title="14.19.2 InnoDB のリカバリの強制的な実行">セクション14.19.2「InnoDB のリカバリの強制的な実行」</a>を参照してください)。
      </p><p>
        多くのセカンダリインデックスが更新される必要があり、多くの行が挿入されたときは、挿入バッファーのマージに何時間もかかる可能性があります。この期間は、ディスク I/O が増加します。これにより、ディスクに負荷がかかるクエリーは大幅に低速になります。もう 1 つの重要なバックグラウンド I/O 操作は、<a class="link" href="glossary.html#glos_purge_thread" title="パージスレッド">パージスレッド</a>です (<a class="xref" href="innodb-storage-engine.html#innodb-multi-versioning" title="14.2.12 InnoDB マルチバージョン">セクション14.2.12「InnoDB マルチバージョン」</a>を参照してください)。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-adaptive-hash"></a>14.2.13.6 適応型ハッシュインデックス</h4></div></div></div><a class="indexterm" name="idm139979074337792"></a><a class="indexterm" name="idm139979074335632"></a><p>
        <a class="link" href="glossary.html#glos_adaptive_hash_index" title="適応型ハッシュインデックス">適応型ハッシュインデックス</a> (AHI) と呼ばれる機能を使用すると、トランザクションの機能や信頼性を犠牲にせずに、<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>のワークロードと十分なメモリーが適切に組み合わされたシステム上でインメモリーデータベースと同様に <code class="literal">InnoDB</code> を実行できます。この機能はサーバーの起動時に、<code class="literal">innodb_adaptive_hash_index</code> オプションを使用すると有効になり、<code class="literal">--skip-innodb_adaptive_hash_index</code> を使用すると無効になります。
      </p><p>
        監視対象の検索パターンに基づいて、MySQL はインデックスキーのプリフィクスを使用して、ハッシュインデックスを構築します。キーのプリフィクスは任意の長さにすることができますが、ハッシュインデックスには B ツリー内の値の一部しか表示されない可能性があります。ハッシュインデックスは、頻繁にアクセスされるインデックスのページに対する要求に応じて構築されます。
      </p><p>
        テーブルがメインメモリー内にほぼ完全に収容されている場合は、任意の要素の直接検索を有効にし、インデックス値をポインタの一種に変換すると、ハッシュインデックスを使用してクエリーを高速にすることができます。<code class="literal">InnoDB</code> には、インデックスの検索をモニターするメカニズムが備わっています。ハッシュインデックスの構築がクエリーにとって有益であると <code class="literal">InnoDB</code> が判断した場合は、自動的にそのインデックスが構築されます。
      </p><p>
        一部の<a class="link" href="glossary.html#glos_workload" title="ワークロード">ワークロード</a>では、ハッシュインデックスの検索による高速化の方が、インデックスの検索をモニターしたり、ハッシュインデックスの構造を保持したりする追加の作業よりも重要です。複数の並列結合などの負荷の高いワークロードでは、適応型ハッシュインデックスへのアクセスを保護する読み取り/書き込みロックが競合の原因となる可能性があります。<code class="literal">LIKE</code> 演算子と <code class="literal">%</code> ワイルドカードを使用したクエリーも、AHI を使用する利点が得られない傾向があります。適応型ハッシュインデックスが必要のないワークロードでは、これをオフにすれば、不要なパフォーマンスのオーバーヘッドが削減されます。この機能が特定のシステムに適しているかどうかを事前に予測することは困難であるため、現実的なワークロードを使用して、有効にした場合と無効にした場合の両方でベンチマークを実行することを検討してください。MySQL 5.6 以上ではアーキテクチャーが変更され、以前のリリースよりも、適応型ハッシュインデックスを無効にすることに適したワークロードが多くなりました。ただし、デフォルトでは引き続き有効になっています。
      </p><p>
        常に、ハッシュインデックスはテーブル上の既存の <a class="link" href="glossary.html#glos_b_tree" title="B ツリー">B ツリー</a>インデックスに基づいて構築されます。<code class="literal">InnoDB</code> は、B ツリーインデックスに対して <code class="literal">InnoDB</code> が検出した検索パターンに応じて、任意の長さの B ツリーに定義されたキーのプリフィクスに、ハッシュインデックスを構築できます。ハッシュインデックスは、頻繁にアクセスされるインデックスのページのみが対象となるように、部分的に構築できます。
      </p><p>
        適応型ハッシュインデックスの使用、およびこれを <code class="literal">SHOW ENGINE INNODB STATUS</code> コマンドの出力の <code class="literal">SEMAPHORES</code> セクションで使用した場合の競合をモニターできます。<code class="filename">btr0sea.c</code> で作成された RW ラッチ上で待機しているスレッドが多く見られる場合は、適応型ハッシュインデックスを無効にすると役立つ可能性があります。
      </p><p>
        ハッシュインデックスのパフォーマンス特性についての詳細は、<a class="xref" href="optimization.html#index-btree-hash" title="8.3.8 B ツリーインデックスとハッシュインデックスの比較">セクション8.3.8「B ツリーインデックスとハッシュインデックスの比較」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-physical-record"></a>14.2.13.7 物理的な行構造</h4></div></div></div><a class="indexterm" name="idm139979074308192"></a><p>
        <code class="literal">InnoDB</code> テーブルの物理的な行構造は、テーブル作成時に指定された行フォーマットによって異なります。<code class="literal">InnoDB</code> のデフォルトでは、<a class="link" href="glossary.html#glos_antelope" title="Antelope">Antelope</a> ファイル形式とその <code class="literal">COMPACT</code> 行フォーマットが使用されます。<code class="literal">REDUNDANT</code> 形式は、古い MySQL バージョンとの互換性を保つために使用可能です。<a class="xref" href="innodb-storage-engine.html#innodb-row-format" title="14.9 InnoDB の行ストレージと行フォーマット">セクション14.9「InnoDB の行ストレージと行フォーマット」</a>および<a class="xref" href="innodb-storage-engine.html#innodb-compression" title="14.7 InnoDB 圧縮テーブル">セクション14.7「InnoDB 圧縮テーブル」</a>で説明するように、<code class="literal">innodb_file_per_table</code> 設定を有効にすると、新しい Barracuda ファイル形式を <code class="literal">DYNAMIC</code> および <code class="literal">COMPRESSED</code> 行フォーマットとともに使用することもできます。
      </p><p>
        <code class="literal">InnoDB</code> テーブルの行フォーマットをチェックするには、<code class="literal">SHOW TABLE STATUS</code> を使用します。例:
      </p><pre class="programlisting">mysql&gt; SHOW TABLE STATUS IN test1\G
*************************** 1. row ***************************
           Name: t1
         Engine: InnoDB
        Version: 10
     Row_format: Compact
           Rows: 0
 Avg_row_length: 0
    Data_length: 16384
Max_data_length: 0
   Index_length: 16384
      Data_free: 0
 Auto_increment: 1
    Create_time: 2014-10-31 16:02:01
    Update_time: NULL
     Check_time: NULL
      Collation: latin1_swedish_ci
       Checksum: NULL
 Create_options: 
        Comment: 
1 row in set (0.00 sec)</pre><p>
        <code class="literal">INFORMATION_SCHEMA.INNODB_SYS_TABLES</code> でクエリーを実行することで、<code class="literal">InnoDB</code> テーブルの行フォーマットをチェックすることもできます。
      </p><pre class="programlisting">mysql&gt; SELECT NAME, ROW_FORMAT FROM INFORMATION_SCHEMA.INNODB_SYS_TABLES WHERE NAME='test1/t1';
+----------+------------+
| NAME     | ROW_FORMAT |
+----------+------------+
| test1/t1 | Compact    |
+----------+------------+</pre><p>
        <code class="literal">COMPACT</code> 行フォーマットを使用すると、行のストレージ領域が約 20% 減少しますが、一部の操作では CPU 使用率が高くなります。ワークロードが、キャッシュヒット率とディスク速度によって制限される通常のワークロードであれば、<code class="literal">COMPACT</code> 形式が高速になる可能性があります。ワークロードが CPU 速度によって制限されるまれなケースでは、<code class="literal">COMPACT</code> 形式が低速になる可能性があります。
      </p><p>
        <code class="literal">REDUNDANT</code> 行フォーマットを使用する <code class="literal">InnoDB</code> テーブル内の行には、次のような特性があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            各インデックスレコードには、6 バイトのヘッダーが含まれています。このヘッダーは、連続するレコードをリンクするために使用されます。また、行レベルロックでも使用されます。
          </p></li><li class="listitem"><p>
            クラスタ化されたインデックス内のレコードには、すべてのユーザー定義カラムのフィールドが含まれます。さらに、6 バイトのトランザクション ID フィールドと 7 バイトのロールポインタフィールドも含まれています。
          </p></li><li class="listitem"><p>
            テーブルに主キーが定義されなかった場合は、各クラスタ化されたインデックスレコードに 6 バイトの行 ID フィールドも含まれています。
          </p></li><li class="listitem"><p>
            各セカンダリインデックスレコードには、セカンダリインデックス内に存在しないクラスタ化されたインデックスキーに定義されたすべての主キーフィールドも含まれています。
          </p></li><li class="listitem"><p>
            レコードには、そのレコードの各フィールドへのポインタが含まれます。レコード内のフィールド長の合計が 128 バイト未満の場合はポインタが 1 バイト、128 バイト以上の場合はポインタが 2 バイトになります。これらのポインタの配列はレコードディレクトリと呼ばれます。これらのポインタが示す領域は、レコードのデータ部分と呼ばれます。
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> には内部的に、固定長形式の <code class="literal">CHAR(10)</code> などの固定長文字カラムが格納されます。<code class="literal">InnoDB</code> は、<code class="literal">VARCHAR</code> カラム内の末尾の空白を切り捨てません。
          </p></li><li class="listitem"><p>
            SQL の <code class="literal">NULL</code> 値では、レコードディレクトリに 1 バイトまたは 2 バイトが予約されます。それ以外に、SQL の <code class="literal">NULL</code> 値では、可変長カラム内に格納されるとレコードのデータ部分にゼロバイトが予約されます。固定長カラムでは、レコードのデータ部分内にカラムの固定長が予約されます。<code class="literal">NULL</code> 値用に固定領域を予約すると、インデックスページの断片化が発生せずに、カラムを <code class="literal">NULL</code> から非 <code class="literal">NULL</code> 値に更新できます。
          </p></li></ul></div><p>
        <code class="literal">COMPACT</code> 行フォーマットを使用する <code class="literal">InnoDB</code> テーブル内の行には、次のような特性があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            各インデックスレコードには、前に可変長ヘッダーが付く可能性のある 5 バイトのヘッダーが含まれています。このヘッダーは、連続するレコードをリンクするために使用されます。また、行レベルロックでも使用されます。
          </p></li><li class="listitem"><p>
            レコードヘッダーの可変長部分には、<code class="literal">NULL</code> カラムを示すビットベクトルが含まれています。<code class="literal">NULL</code> にすることができるインデックス内のカラム数が <em class="replaceable"><code>N</code></em> である場合は、ビットベクトルで <code class="literal">CEILING(<em class="replaceable"><code>N</code></em>/8)</code> バイトが占有されます。(たとえば、<code class="literal">NULL</code> にすることができるカラムが 9 から 15 までの任意の数だけ存在する場合は、ビットベクトルで 2 バイトが使用されます。)このベクトル内のビット以外の領域は、<code class="literal">NULL</code> のカラムで占有されません。ヘッダーの可変長部分には、可変長カラムの長さも含まれています。各長さは、カラムの最大長に応じて、1 バイトと 2 バイトのいずれかになります。インデックス内のすべてのカラムが <code class="literal">NOT NULL</code> でかつ固定長である場合、レコードヘッダーには可変長部分が含まれません。
          </p></li><li class="listitem"><p>
            非 <code class="literal">NULL</code> 可変長フィールドごとに、レコードヘッダーに 1 バイトまたは 2 バイトのカラム長が含まれます。カラムの一部が外部のオーバーフローページに格納される場合や、最大長が 255 バイトを超え、実際の長さが 127 バイトを超える場合にのみ、2 バイトが必要になります。カラムが外部に格納された場合、2 バイトの長さは、内部に格納された部分の長さに、外部に格納された部分への 20 バイトのポインタを加えた長さを示します。内部の部分は 768 バイトであるため、長さは 768+20 になります。20 バイトのポインタには、そのカラムの実際の長さが格納されます。
          </p></li><li class="listitem"><p>
            レコードヘッダーのあとに、非 <code class="literal">NULL</code> カラムのデータ内容が続きます。
          </p></li><li class="listitem"><p>
            クラスタ化されたインデックス内のレコードには、すべてのユーザー定義カラムのフィールドが含まれます。さらに、6 バイトのトランザクション ID フィールドと 7 バイトのロールポインタフィールドも含まれています。
          </p></li><li class="listitem"><p>
            テーブルに主キーが定義されなかった場合は、各クラスタ化されたインデックスレコードに 6 バイトの行 ID フィールドも含まれています。
          </p></li><li class="listitem"><p>
            各セカンダリインデックスレコードには、セカンダリインデックス内に存在しないクラスタ化されたインデックスキーに定義されたすべての主キーフィールドも含まれています。これらの主キーフィールドのいずれかが可変長である場合、各セカンダリインデックスのレコードヘッダーには、そのセカンダリインデックスが固定長カラムで定義されている場合でも、それらのフィールドの長さを記録するための可変長部分が含まれます。
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> には内部的に、固定長形式の <code class="literal">CHAR(10)</code> などの固定長で固定幅の文字カラムが格納されます。<code class="literal">InnoDB</code> は、<code class="literal">VARCHAR</code> カラム内の末尾の空白を切り捨てません。
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> は、後続領域を切り取ることで内部的に UTF-8 <code class="literal">CHAR(<em class="replaceable"><code>N</code></em>)</code> カラムを <em class="replaceable"><code>N</code></em> バイトで格納しようとします。(<code class="literal">REDUNDANT</code> 行フォーマットでは、このようなカラムで 3 × <em class="replaceable"><code>N</code></em> バイトが占有されます。)多くの場合は、最小領域 <em class="replaceable"><code>N</code></em> を予約すると、インデックスページの断片化が発生せずに、カラムの更新を正常に実行できます。
          </p></li></ul></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-configuration"></a>14.3 InnoDB の構成</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-read-only-instance">14.3.1 読み取り専用操作用の InnoDB の構成</a></span></dt></dl></div><a class="indexterm" name="idm139979074235488"></a><p>
    InnoDB 構成について最初に決定することは、InnoDB データファイルのレイアウト方法、および InnoDB ストレージエンジン用に割り当てるメモリーの量です。これらの選択を記録するには、起動時に MySQL で読み取られる構成ファイル内に記録するか、または起動スクリプトのコマンド行オプションとして指定します。オプション、説明、および許可されるパラメータ値の完全なリストについては、<a class="xref" href="innodb-storage-engine.html#innodb-parameters" title="14.12 InnoDB の起動オプションおよびシステム変数">セクション14.12「InnoDB の起動オプションおよびシステム変数」</a>を参照してください。
  </p><h3><a name="idm139979074231552"></a>InnoDB テーブルスペースおよびログファイルの概要</h3><p>
    <code class="literal">InnoDB</code> ストレージエンジンで管理されている 2 つの重要なディスクベースのリソースは、そのテーブルスペースデータファイルとログファイルです。<code class="literal">InnoDB</code> 構成オプションを指定しない場合は、MySQL によって MySQL データディレクトリ内に、わずかに 12M バイトよりも大きい <code class="filename">ibdata1</code> という名前の自動拡張データファイルと、<code class="filename">ib_logfile0</code> および <code class="filename">ib_logfile1</code> という名前の 2 つのログファイルが作成されます。これらのサイズは、<code class="literal">innodb_log_file_size</code> システム変数のサイズで指定されます。適切なパフォーマンスを実現するには、次の例で説明するように、<code class="literal">InnoDB</code> パラメータを明示的に指定します。当然、ハードウェアおよび要件に合うように設定を編集します。
  </p><p>
    ここで示す例は代表的なものです。<code class="literal">InnoDB</code> に関連する構成パラメータに関する追加情報については、<a class="xref" href="innodb-storage-engine.html#innodb-parameters" title="14.12 InnoDB の起動オプションおよびシステム変数">セクション14.12「InnoDB の起動オプションおよびシステム変数」</a>を参照してください。
  </p><h3><a name="idm139979074221472"></a>ストレージデバイスに関する考慮事項</h3><p>
    場合によっては、一部のデータが同じ物理ディスク上に配置されてない場合に、データベースのパフォーマンスが改善されることがあります。非常に多くの場合、ログファイルをデータとは別のディスク上に配置すると、パフォーマンスの改善に役立ちます。次の例で、この方法を示します。2 つのデータファイルが別々のディスク上に配置され、ログファイルが 3 台目のディスク上に配置されています。<code class="literal">InnoDB</code> では、1 番目のデータファイルから順番にテーブルスペースに収容されます。<code class="literal">InnoDB</code> データファイルとして、RAW ディスクパーティション (RAW デバイス) を使用することもできます。これにより、I/O の速度が上がる可能性があります。<a class="xref" href="innodb-storage-engine.html#innodb-raw-devices" title="14.5.8 共有テーブルスペースでの RAW ディスクパーティションの使用">セクション14.5.8「共有テーブルスペースでの RAW ディスクパーティションの使用」</a>を参照してください。
  </p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注意</div><p>
      <code class="literal">InnoDB</code> はトランザクションセーフな (ACID に準拠した) MySQL 用のストレージエンジンであり、ユーザーデータを保護するためのコミット、ロールバック、およびクラッシュリカバリ機能を備えています。ただし、ベースとなるオペレーティングシステムやハードウェアが公表どおりに機能しない場合は、<span class="bold"><strong>実行できません</strong></span>。多くのオペレーティングシステムやディスクサブシステムでは、パフォーマンスを改善するために書き込み操作が遅延したり、再指示されたりする可能性があります。一部のオペレーティングシステムでは、まさに <code class="literal">fsync()</code> システムコールは、ファイルのすべての未書き込みデータがフラッシュされるまで待機するべきですが、実際には、データが安定したストレージにフラッシュされる前に返される可能性があります。このため、オペレーティングシステムのクラッシュや停電によって最近コミットされたデータが破損したり、さらに最悪の場合、書き込み操作が再指示されたためにデータベースが破損したりすることもあります。データの完全性が重要である場合は、本番環境で何かを使用する前に、何らかの形で<span class="quote">「<span class="quote">電源プラグを抜く</span>」</span>テストを実行してください。OS X 10.3 以降の <code class="literal">InnoDB</code> では、特別な <code class="literal">fcntl()</code> ファイルフラッシュ方式が使用されます。Linux では、<span class="bold"><strong>ライトバックキャッシュを無効にする</strong></span>ことが推奨されています。
    </p><p>
      ATA/SATA ディスクドライブ上で <code class="literal">hdparm -W0 /dev/hda</code> のようなコマンドを使用すると、ライトバックキャッシュを無効にできる場合があります。<span class="bold"><strong>一部のドライブやディスクコントローラでは、ライトバックキャッシュを無効にできない可能性があることに注意してください。</strong></span>
    </p><p>
      ユーザーを保護する <code class="literal">InnoDB</code> のリカバリ機能に関しては、<code class="literal">InnoDB</code> では<a class="link" href="glossary.html#glos_doublewrite_buffer" title="二重書き込みバッファー">二重書き込みバッファー</a>と呼ばれる構造に関連したファイルフラッシュ技術が使用されています。これは、デフォルトで有効になっています (<code class="literal">innodb_doublewrite=ON</code>)。二重書き込みバッファーを使用すると、クラッシュや停電のあとのリカバリの安全性が高まるだけでなく、<code class="literal">fsync()</code> 操作の必要性が減るため、ほとんどの種類の Unix でパフォーマンスが向上します。データの完全性またはエラーの可能性に関心がある場合は、<code class="literal">innodb_doublewrite</code> オプションを有効のままにすることが推奨されています。二重書き込みバッファーの追加情報については、<a class="xref" href="innodb-storage-engine.html#innodb-disk-management" title="14.10 InnoDB のディスク I/O とファイル領域管理">セクション14.10「InnoDB のディスク I/O とファイル領域管理」</a>を参照してください。
    </p></div><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注意</div><a class="indexterm" name="idm139979074198912"></a><a class="indexterm" name="idm139979074196976"></a><p>
      データの信頼性が考慮事項となっている場合は、NFS ボリューム上でデータファイルやログファイルが使用されるように <code class="literal">InnoDB</code> を構成しないでください。発生する可能性のある問題は、OS および NFS のバージョンによって異なります。これらの問題には、競合する書き込みからの保護が不足しているなどの問題や、最大ファイルサイズ上の制限などが含まれます。
    </p></div><h3><a name="idm139979074192720"></a>InnoDB テーブルスペースファイルの場所とサイズの指定</h3><p>
    <code class="literal">InnoDB</code> テーブルスペースファイルを設定するには、<code class="filename">my.cnf</code> オプションファイルの <code class="literal">[mysqld]</code> セクションで <code class="literal">innodb_data_file_path</code> オプションを使用します。Windows では、代わりに <code class="filename">my.ini</code> を使用できます。<code class="literal">innodb_data_file_path</code> の値は、1 つ以上のデータファイルのリストで指定するようにしてください。複数のデータファイル名を指定する場合は、セミコロン文字 (<span class="quote">「<span class="quote"><code class="literal">;</code></span>」</span>) で区切ってください。
  </p><pre class="programlisting">
innodb_data_file_path=<em class="replaceable"><code>datafile_spec1</code></em>[;<em class="replaceable"><code>datafile_spec2</code></em>]...
</pre><p>
    たとえば、次の設定では、最小サイズのシステムテーブルスペースが明示的に作成されます。
  </p><pre class="programlisting">
[mysqld]
innodb_data_file_path=ibdata1:12M:autoextend
</pre><p>
    この設定では、<code class="filename">ibdata1</code> という名前の 12M バイトの自動拡張データファイルが 1 つ構成されます。ファイルの場所が指定されていないため、<code class="literal">InnoDB</code> によって、デフォルトで MySQL データディレクトリ内に作成されます。
  </p><p>
    K バイト、M バイト、または G バイトの単位を指定するために、サイズは <code class="literal">K</code>、<code class="literal">M</code>、または <code class="literal">G</code> のサフィクス文字を使用して指定されます。
  </p><p>
    データディレクトリ内にある <code class="filename">ibdata1</code> という名前の 50M バイトの固定サイズデータファイルと、<code class="filename">ibdata2</code> という名前の 50M バイトの自動拡張ファイルを含むテーブルスペースは、次のように構成できます。
  </p><pre class="programlisting">
[mysqld]
innodb_data_file_path=ibdata1:50M;ibdata2:50M:autoextend
</pre><p>
    データファイルを指定するための完全な構文には、ファイル名、そのサイズ、および複数のオプション属性が含まれています。
  </p><pre class="programlisting">
<em class="replaceable"><code>file_name</code></em>:<em class="replaceable"><code>file_size</code></em>[:autoextend[:max:<em class="replaceable"><code>max_file_size</code></em>]]
</pre><p>
    <code class="literal">autoextend</code> および <code class="literal">max</code> 属性は、<code class="literal">innodb_data_file_path</code> 行内の最後のデータファイルでのみ使用できます。
  </p><p>
    最後のデータファイルに <code class="literal">autoextend</code> オプションを指定すると、テーブルスペースに空き領域がなくなった場合に、<code class="literal">InnoDB</code> はデータファイルを拡張します。デフォルトでは、一度に 8M バイトずつ増分されます。増分を変更するには、<code class="literal">innodb_autoextend_increment</code> システム変数を変更します。
  </p><p>
    ディスクがいっぱいになったら、別のディスク上に別のデータファイルを追加するといいでしょう。テーブルスペースを再構成する手順については、<a class="xref" href="innodb-storage-engine.html#innodb-data-log-reconfiguration" title="14.5.7 InnoDB ログファイルの数またはサイズの変更、および InnoDB テーブルスペースのサイズの変更">セクション14.5.7「InnoDB ログファイルの数またはサイズの変更、および InnoDB テーブルスペースのサイズの変更」</a>を参照してください。
  </p><p>
    <code class="literal">InnoDB</code> ではファイルシステムの最大ファイルサイズが認識されないため、最大ファイルサイズが 2G バイトのような小さい値になっているファイルシステムでは注意してください。自動拡張データファイルの最大サイズを指定するには、<code class="literal">autoextend</code> 属性のあとに <code class="literal">max</code> 属性を使用してください。最大サイズを超えると致命的なエラーが発生し、クラッシュする可能性もあるため、ディスクの使用率を制約することが非常に重要である場合に限り、<code class="literal">max</code> 属性を使用してください。次の構成では、<code class="filename">ibdata1</code> が最大で 500M バイトの制限まで増大することが許可されます。
  </p><pre class="programlisting">
[mysqld]
innodb_data_file_path=ibdata1:12M:autoextend:max:500M
</pre><p>
    <code class="literal">InnoDB</code> は、デフォルトで MySQL データディレクトリ内にテーブルスペースファイルを作成します。場所を明示的に指定するには、<code class="literal">innodb_data_home_dir</code> オプションを使用します。たとえば、<code class="filename">ibdata1</code> および <code class="filename">ibdata2</code> という名前の 2 つのファイルを使用するが、<code class="filename">/ibdata</code> ディレクトリ内に作成するには、次のように <code class="literal">InnoDB</code> を構成します。
  </p><pre class="programlisting">
[mysqld]
innodb_data_home_dir = /ibdata
innodb_data_file_path=ibdata1:50M;ibdata2:50M:autoextend
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
      <code class="literal">InnoDB</code> ではディレクトリが作成されないため、サーバーを起動する前に、<code class="filename">/ibdata</code> ディレクトリが存在することを確認してください。このことは、ユーザーが構成するログファイルディレクトリにも当てはまります。必要なディレクトリを作成するには、Unix または DOS の <code class="literal">mkdir</code> コマンドを使用します。
    </p><p>
      MySQL サーバーがデータディレクトリ内にファイルを作成するための適切なアクセス権を持っていることを確認してください。さらに一般的に言えば、サーバーはデータファイルやログファイルを作成する必要のあるディレクトリ内に、アクセス権を持っている必要があります。
    </p></div><p>
    <code class="literal">InnoDB</code> は <code class="literal">innodb_data_home_dir</code> の値をテキストとしてデータファイル名に連結させ、必要に応じてパス名の区切り文字 (スラッシュまたはバックスラッシュ) を値の間に追加することで、各データファイルのディレクトリパスを形成します。<code class="filename">my.cnf</code> に <code class="literal">innodb_data_home_dir</code> オプションがまったく指定されていない場合は、デフォルト値が<span class="quote">「<span class="quote">ドット</span>」</span>ディレクトリ <code class="filename">./</code> (つまり、MySQL データディレクトリ) になります。(MySQL サーバーは実行の開始時に、現在の作業ディレクトリをそのデータディレクトリに変更します。)
  </p><p>
    <code class="literal">innodb_data_home_dir</code> を空の文字列として指定すると、<code class="literal">innodb_data_file_path</code> 値で一覧表示されたデータファイルに絶対パスを指定できます。次の例は、前述の例と同等です。
  </p><pre class="programlisting">
[mysqld]
innodb_data_home_dir =
innodb_data_file_path=/ibdata/ibdata1:50M;/ibdata/ibdata2:50M:autoextend
</pre><h3><a name="idm139979074135600"></a>InnoDB 構成オプションの指定</h3><p>
    <span class="bold"><strong>小規模なシステム向けのサンプル <code class="filename">my.cnf</code> ファイル。</strong></span>512M バイトの RAM と 1 台のハードディスクが搭載されたコンピュータを使用すると仮定します。次の例では、<code class="literal">autoextend</code> 属性を含む、<code class="literal">InnoDB</code> の <code class="filename">my.cnf</code> または <code class="filename">my.ini</code> で指定可能な構成パラメータを示します。この例は、<code class="literal">InnoDB</code> データファイルとログファイルをいくつかのディスクに分散することを希望しない、Unix と Windows 両方のほとんどのユーザーに適しています。ここでは、MySQL データディレクトリ内に自動拡張データファイル <code class="filename">ibdata1</code> と、2 つの <code class="literal">InnoDB</code> ログファイル <code class="filename">ib_logfile0</code> および <code class="filename">ib_logfile1</code> を作成します。
  </p><pre class="programlisting">
[mysqld]
# You can write your other MySQL server options here
# ...
# Data files must be able to hold your data and indexes.
# Make sure that you have enough free disk space.
innodb_data_file_path = ibdata1:12M:autoextend
#
# Set buffer pool size to 50-80% of your computer's memory
innodb_buffer_pool_size=256M
innodb_additional_mem_pool_size=20M
#
# Set the log file size to about 25% of the buffer pool size
innodb_log_file_size=64M
innodb_log_buffer_size=8M
#
innodb_flush_log_at_trx_commit=1
</pre><p>
    一部のファイルシステムでは、データファイルを 2G バイト未満にする必要があることに注意してください。ログファイルを結合したサイズは、最大で 512G バイトまでにすることができます。データファイルを結合したサイズは、10M バイトをわずかに超える大きさにする必要があります。
  </p><h3><a name="idm139979074121968"></a>InnoDB システムテーブルスペースの設定</h3><p>
    はじめて <code class="literal">InnoDB</code> システムテーブルスペースを作成する際は、コマンドプロンプトから MySQL サーバーを起動する方法が最適です。そのあと、データベースの作成に関する情報が <code class="literal">InnoDB</code> の画面に出力されるため、何が発生しているのかを確認できます。たとえば、Windows の場合、<span class="command"><strong>mysqld</strong></span> が <code class="filename">C:\Program Files\MySQL\MySQL Server 5.6\bin</code> に配置されていれば、次のように起動できます。
  </p><pre class="programlisting">
C:\&gt; <strong class="userinput"><code>"C:\Program Files\MySQL\MySQL Server 5.6\bin\mysqld" --console</code></strong>
</pre><p>
    サーバーの出力が画面に送信されない場合は、サーバーのエラーログをチェックして、起動プロセス中に <code class="literal">InnoDB</code> から出力された内容を確認してください。
  </p><p>
    <code class="literal">InnoDB</code> で表示される情報の出力例については、<a class="xref" href="innodb-storage-engine.html#innodb-init" title="14.5.1 InnoDB テーブルスペースの作成">セクション14.5.1「InnoDB テーブルスペースの作成」</a>を参照してください。
  </p><h3><a name="idm139979074111984"></a>MySQL 構成ファイルの編集</h3><p>
    サーバーの起動時に読み取られる任意のオプションファイルの <code class="literal">[mysqld]</code> グループ内に、<code class="literal">InnoDB</code> オプションを配置できます。オプションファイルの場所については、<a class="xref" href="programs.html#option-files" title="4.2.6 オプションファイルの使用">セクション4.2.6「オプションファイルの使用」</a>で説明されています。
  </p><p>
    インストールおよび構成ウィザードを使用して、MySQL を Windows 上にインストールした場合は、オプションファイルが MySQL インストールディレクトリ内に配置された <code class="filename">my.ini</code> ファイルになります。<a class="xref" href="installing.html#mysql-installer" title="2.3.3 MySQL Installer を使用した MySQL の Microsoft Windows へのインストール">セクション2.3.3「MySQL Installer を使用した MySQL の Microsoft Windows へのインストール」</a>を参照してください。
  </p><p>
    <code class="filename">C:</code> ドライブがブートドライブではないブートローダーが PC で使用されている場合は、Windows ディレクトリ (通常は <code class="filename">C:\WINDOWS</code>) 内の <code class="filename">my.ini</code> ファイルを使用することが唯一のオプションとなります。コンソールウィンドウ内のコマンドプロンプトで <code class="literal">SET</code> コマンドを使用すると、<code class="literal">WINDIR</code> の値を出力できます。
  </p><pre class="programlisting">
C:\&gt; <strong class="userinput"><code>SET WINDIR</code></strong>
windir=C:\WINDOWS
</pre><p>
    <span class="command"><strong>mysqld</strong></span> で特定のファイルからのオプションのみが読み取られることを確認するには、サーバーの起動時に <code class="option">--defaults-file</code> オプションをコマンド行の最初のオプションとして使用します。
  </p><pre class="programlisting">
mysqld --defaults-file=<em class="replaceable"><code>your_path_to_my_cnf</code></em>
</pre><p>
    <span class="bold"><strong>大規模なシステム向けのサンプル <code class="filename">my.cnf</code> ファイル。</strong></span>ディレクトリパス <code class="filename">/</code>、<code class="filename">/dr2</code>、および <code class="filename">/dr3</code> に 2G バイトの RAM と 3 台の 60G バイトハードディスクが搭載された Linux コンピュータを使用すると仮定します。次の例では、<code class="literal">InnoDB</code> の <code class="filename">my.cnf</code> で指定可能な構成パラメータを示します。
  </p><pre class="programlisting">
[mysqld]
# You can write your other MySQL server options here
# ...
innodb_data_home_dir =
#
# Data files must be able to hold your data and indexes
innodb_data_file_path = /db/ibdata1:2000M;/dr2/db/ibdata2:2000M:autoextend
#
# Set buffer pool size to 50-80% of your computer's memory,
# but make sure on Linux x86 total memory usage is &lt; 2GB
innodb_buffer_pool_size=1G
innodb_additional_mem_pool_size=20M
innodb_log_group_home_dir = /dr3/iblogs
#
# Set the log file size to about 25% of the buffer pool size
innodb_log_file_size=250M
innodb_log_buffer_size=8M
#
innodb_flush_log_at_trx_commit=1
innodb_lock_wait_timeout=50
#
# Uncomment the next line if you want to use it
#innodb_thread_concurrency=5
</pre><h3><a name="idm139979074087200"></a>InnoDB の最大メモリー割り当ての決定</h3><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
      32 ビット版の GNU/Linux x86 では、高すぎるメモリー使用率を設定しないように注意してください。<code class="literal">glibc</code> では、プロセスヒープがスレッドスタック上で増加することが許可されている可能性があるため、サーバーがクラッシュします。次の式の値が 2G バイトに近づいていたり、超えていたりする場合は危険です。
    </p><pre class="programlisting">
innodb_buffer_pool_size
+ key_buffer_size
+ max_connections*(sort_buffer_size+read_buffer_size+binlog_cache_size)
+ max_connections*2MB
</pre><p>
      各スレッドではスタックが使用され (多くの場合は 2M バイトですが、Oracle Corporation が提供する MySQL バイナリでは 256K バイトだけです)、最悪のケースでは、<code class="literal">sort_buffer_size + read_buffer_size</code> の追加メモリーも使用されます。
    </p></div><p>
    <span class="bold"><strong>その他の <span class="command"><strong>mysqld</strong></span> サーバーパラメータの調整。</strong></span>次の値は典型的であり、ほとんどのユーザーに適しています。
  </p><pre class="programlisting">
[mysqld]
skip-external-locking
max_connections=200
read_buffer_size=1M
sort_buffer_size=1M
#
# Set key_buffer to 5 - 50% of your RAM depending on how much
# you use MyISAM tables, but keep key_buffer_size + InnoDB
# buffer pool size &lt; 80% of your RAM
key_buffer_size=<em class="replaceable"><code>value</code></em>
</pre><p>
    Linux の場合、カーネルで大規模ページのサポートが有効になっていれば、<code class="literal">InnoDB</code> は、バッファープールや追加メモリープールのメモリーを割り当てる際に大規模なページを使用できます。<a class="xref" href="optimization.html#large-page-support" title="8.11.4.2 ラージページのサポートの有効化">セクション8.11.4.2「ラージページのサポートの有効化」</a>を参照してください。
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-read-only-instance"></a>14.3.1 読み取り専用操作用の InnoDB の構成</h3></div></div></div><p>
      現在は、サーバーの起動時に <code class="literal">--innodb-read-only</code> 構成オプションを有効にすることで、MySQL データディレクトリが読み取り専用メディア上にある <code class="literal">InnoDB</code> テーブルでクエリーを実行できます。
    </p><h4><a name="idm139979074072048"></a>有効にする方法</h4><p>
      読み取り操作用にインスタンスを準備するには、必要なすべての情報が読み取り専用メディア上に格納される前に、データファイルに<a class="link" href="glossary.html#glos_flush" title="フラッシュ">フラッシュ</a>されることを確認します。変更バッファーが無効になっている (<code class="literal">innodb_change_buffering=0</code>) サーバーを実行し、<a class="link" href="glossary.html#glos_slow_shutdown" title="低速シャットダウン">低速シャットダウン</a>を実行します。
    </p><p>
      MySQL インスタンス全体にわたって読み取り専用モードを有効にするには、サーバーの起動時に次の構成オプションを指定します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">--innodb-read-only=1</code>
        </p></li><li class="listitem"><p>
          インスタンスが DVD や CD などの読み取り専用メディア上にある場合、または <code class="filename">/var</code> ディレクトリがすべてのユーザーから書き込み可能でない場合: <code class="literal">--pid-file=<em class="replaceable"><code>path_on_writeable_media</code></em></code> および <code class="literal">--event-scheduler=disabled</code>
        </p></li></ul></div><h4><a name="idm139979074061344"></a>使用シナリオ</h4><p>
      この操作モードは、次のような状況に適しています。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          DVD や CD などの読み取り専用ストレージメディア上に、MySQL アプリケーションまたは MySQL データセットを配布する。
        </p></li><li class="listitem"><p>
          (一般に、データウェアハウス構成で) 同じデータディレクトリで同時にクエリーを実行する複数の MySQL インスタンス。この方法を使用すれば、負荷の高い MySQL インスタンスで発生する可能性のある<a class="link" href="glossary.html#glos_bottleneck" title="ボトルネック">ボトルネック</a>を回避したり、さまざまなインスタンスに対してさまざまな構成オプションを使用して、特定の種類のクエリーを個別に調整したりできる場合があります。
        </p></li><li class="listitem"><p>
          安全性またはデータの完全性の理由により読み取り専用の状態になったデータ (アーカイブされたバックアップデータなど) のクエリーを実行する。
        </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        この機能の目的は、読み取り専用の側面に基づいた生のパフォーマンスではなく、主に配布および配備する際の柔軟性です。サーバー全体を読み取り専用にする必要なしで、読み取り専用クエリーのパフォーマンスを調整する方法については、<a class="xref" href="innodb-storage-engine.html#innodb-performance-ro-txn" title="14.13.14 InnoDB の読み取り専用トランザクションの最適化">セクション14.13.14「InnoDB の読み取り専用トランザクションの最適化」</a>を参照してください。
      </p></div><h4><a name="idm139979074052832"></a>動作</h4><p>
      <code class="literal">--innodb-read-only</code> オプションを使用して、サーバーが読み取り専用モードで実行されると、特定の <code class="literal">InnoDB</code> 機能およびコンポーネントが減少したり、完全に無効になったりします。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="link" href="glossary.html#glos_change_buffering" title="変更バッファリング">変更バッファー</a> (特に、変更バッファーからのマージ) は実行されません。読み取り専用操作用にインスタンスを準備するときに、変更バッファーが空になっていることを確認するには、変更バッファーを無効にして (<code class="literal">innodb_change_buffering=0</code>)、まず<a class="link" href="glossary.html#glos_slow_shutdown" title="低速シャットダウン">低速シャットダウン</a>を実行します。
        </p></li><li class="listitem"><p>
          起動時には<a class="link" href="glossary.html#glos_crash_recovery" title="クラッシュリカバリ">クラッシュリカバリ</a>フェーズがありません。インスタンスを読み取り専用状態にする前に、<a class="link" href="glossary.html#glos_slow_shutdown" title="低速シャットダウン">低速シャットダウン</a>が実行されている必要があります。
        </p></li><li class="listitem"><p>
          読み取り専用操作では <a class="link" href="glossary.html#glos_redo_log" title="Redo ログ">Redo ログ</a>が使用されないため、インスタンスを読み取り専用にする前に、<code class="literal">innodb_log_file_size</code> を最小限のサイズ (1M バイト) に設定できます。
        </p></li><li class="listitem"><p>
          I/O 読み取りスレッド以外のバックグラウンドスレッドがすべて無効になります。その結果、読み取り専用インスタンスで<a class="link" href="glossary.html#glos_deadlock" title="デッドロック">デッドロック</a>が発生する可能性がなくなります。
        </p></li><li class="listitem"><p>
          デッドロックに関する情報やモニターの出力などは、一時ファイルに書き込まれません。その結果、<code class="literal">SHOW ENGINE INNODB STATUS</code> で出力が生成されなくなります。
        </p></li><li class="listitem"><p>
          <code class="literal">--innodb-read-only</code> を使用して MySQL サーバーが起動されているが、まだデータディレクトリが書き込み可能メディア上にある場合は、root ユーザーが引き続き、<code class="literal">GRANT</code> や <code class="literal">REVOKE</code> などの <a class="link" href="glossary.html#glos_dcl" title="DCL">DCL</a> 操作を実行できます。
        </p></li><li class="listitem"><p>
          構成オプションの設定を変更すると、通常は書き込み操作の動作が変更されますが、サーバーが読み取り専用モードになっている場合は影響がありません。
        </p></li><li class="listitem"><p>
          <a class="link" href="glossary.html#glos_isolation_level" title="分離レベル">分離レベル</a>を強制的に適用する <a class="link" href="glossary.html#glos_mvcc" title="MVCC">MVCC</a> 処理が無効になります。更新も削除もできないため、すべてのクエリーで最新バージョンのレコードが読み取られます。
        </p></li><li class="listitem"><p>
          <a class="link" href="glossary.html#glos_undo_log" title="Undo ログ">Undo ログ</a>は使用されません。<code class="literal">innodb_undo_tablespaces</code> および <code class="literal">innodb_undo_directory</code> 構成オプションの設定を無効にします。
        </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-administration"></a>14.4 InnoDB の管理</h2></div></div></div><p>
    <code class="literal">InnoDB</code> に関連する管理タスクには、主に次のような側面が伴います。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">システムテーブルスペース</a>、<code class="literal">InnoDB</code> テーブル、およびそれらに関連付けられたインデックスを表す<a class="link" href="glossary.html#glos_data_files" title="データファイル">データファイル</a>の管理。これらのファイルをレイアウトおよび分割する方法は変更できますが、特定のテーブルで実現可能なパフォーマンスと機能の両方が影響を受けます。
      </p></li><li class="listitem"><p>
        <a class="link" href="glossary.html#glos_crash_recovery" title="クラッシュリカバリ">クラッシュリカバリ</a>で使用される <a class="link" href="glossary.html#glos_redo_log" title="Redo ログ">Redo ログ</a>ファイルの管理。これらのファイルのサイズを指定できます。
      </p></li><li class="listitem"><p>
        <code class="literal">InnoDB</code> が別のストレージエンジンでなく、目的のテーブルで使用されているかどうかの確認。
      </p></li><li class="listitem"><p>
        パフォーマンスに関連する一般的な管理タスク。アプリケーションの設計フェーズ時にアプリケーション開発者に相談したり、システム設定が正常に機能していることを確認するために継続的にパフォーマンスをモニターしたり、突然に発生したパフォーマンスや容量の問題を診断して修正したりする場合があります。
      </p></li></ul></div><p>
    現在は <code class="literal">InnoDB</code> テーブルが MySQL のデフォルトであるため、関連する管理資料の大半は主要な<span class="quote">「<span class="quote">管理</span>」</span>の章、<a class="xref" href="server-administration.html" title="第 5 章 MySQL サーバーの管理">第5章「<i>MySQL サーバーの管理</i>」</a>に記載されています。
  </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-tablespace"></a>14.5 InnoDB テーブルスペース管理</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-init">14.5.1 InnoDB テーブルスペースの作成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-multiple-tablespaces">14.5.2 InnoDB File-Per-Table モード</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#tablespace-enabling">14.5.3 File-Per-Table モードの有効化および無効化</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#tablespace-placing">14.5.4 テーブルスペースの位置の指定</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#tablespace-copying">14.5.5 テーブルスペースの別のサーバーへのコピー (トランスポータブルテーブルスペース)</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-undo-tablespace">14.5.6 個別のテーブルスペースへの InnoDB Undo ログの格納</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-data-log-reconfiguration">14.5.7 InnoDB ログファイルの数またはサイズの変更、および InnoDB テーブルスペースのサイズの変更</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-raw-devices">14.5.8 共有テーブルスペースでの RAW ディスクパーティションの使用</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-init"></a>14.5.1 InnoDB テーブルスペースの作成</h3></div></div></div><a class="indexterm" name="idm139979074004320"></a><p>
    MySQL をインストールし、必要な <code class="literal">InnoDB</code> 構成パラメータが含まれるようにオプションファイルを編集したと仮定します。MySQL を起動する前に、<code class="literal">InnoDB</code> のデータファイルおよびログファイルに指定したディレクトリが存在し、MySQL サーバーがそれらのディレクトリへのアクセス権を持っていることを確認します。<code class="literal">InnoDB</code> はファイルだけを作成し、ディレクトリは作成しません。データファイルおよびログファイル用のディスク領域が十分にあることもチェックします。
  </p><p>
    <code class="literal">InnoDB</code> が有効になっている状態でサーバーをはじめて起動するときの最適な方法は、MySQL サーバー <span class="command"><strong>mysqld</strong></span> を <span class="command"><strong>mysqld_safe</strong></span> からでも、Windows サービスとしてでもなく、コマンドプロンプトから実行することです。コマンドプロンプトから実行すると、<span class="command"><strong>mysqld</strong></span> で出力される内容および発生している事象が表示されます。Unix では、単に <span class="command"><strong>mysqld</strong></span> を呼び出すだけです。Windows では、出力先がコンソールウィンドウになるように、<code class="option">--console</code> オプションを付けて <span class="command"><strong>mysqld</strong></span> を起動します。
  </p><p>
    オプションファイル内ではじめて <code class="literal">InnoDB</code> を構成したあとに、MySQL サーバーを起動すると、<code class="literal">InnoDB</code> によってデータファイルおよびログファイルが作成され、次のような内容が出力されます。
  </p><pre class="programlisting">
InnoDB: The first specified datafile /home/heikki/data/ibdata1
did not exist:
InnoDB: a new database to be created!
InnoDB: Setting file /home/heikki/data/ibdata1 size to 134217728
InnoDB: Database physically writes the file full: wait...
InnoDB: datafile /home/heikki/data/ibdata2 did not exist:
new to be created
InnoDB: Setting file /home/heikki/data/ibdata2 size to 262144000
InnoDB: Database physically writes the file full: wait...
InnoDB: Log file /home/heikki/data/logs/ib_logfile0 did not exist:
new to be created
InnoDB: Setting log file /home/heikki/data/logs/ib_logfile0 size
to 5242880
InnoDB: Log file /home/heikki/data/logs/ib_logfile1 did not exist:
new to be created
InnoDB: Setting log file /home/heikki/data/logs/ib_logfile1 size
to 5242880
InnoDB: Doublewrite buffer not found: creating new
InnoDB: Doublewrite buffer created
InnoDB: Creating foreign key constraint system tables
InnoDB: Foreign key constraint system tables created
InnoDB: Started
mysqld: ready for connections
</pre><p>
    この時点で、<code class="literal">InnoDB</code> によってテーブルスペースおよびログファイルが初期化されています。<span class="command"><strong>mysql</strong></span> と同様に、通常の MySQL クライアントプログラムを使用して MySQL サーバーに接続できます。<span class="command"><strong>mysqladmin shutdown</strong></span> を使用して MySQL サーバーをシャットダウンすると、次のように出力されます。
  </p><pre class="programlisting">
010321 18:33:34  mysqld: Normal shutdown
010321 18:33:34  mysqld: Shutdown Complete
InnoDB: Starting shutdown...
InnoDB: Shutdown completed
</pre><p>
    データファイルおよびログディレクトリを調査すれば、そこに作成されたファイルを確認できます。MySQL が再起動されるときには、データファイルおよびログファイルはすでに作成されているため、出力はさらに簡潔になります。
  </p><pre class="programlisting">
InnoDB: Started
mysqld: ready for connections
</pre><p>
    <code class="literal">innodb_file_per_table</code> オプションを <code class="filename">my.cnf</code> に追加すると、<code class="literal">InnoDB</code> では各テーブルが、<code class="filename">.frm</code> ファイルが作成された場所と同じ MySQL データベースディレクトリにある独自の <code class="filename">.ibd</code> ファイルに格納されます。<a class="xref" href="innodb-storage-engine.html#innodb-multiple-tablespaces" title="14.5.2 InnoDB File-Per-Table モード">セクション14.5.2「InnoDB File-Per-Table モード」</a>を参照してください。
  </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-multiple-tablespaces"></a>14.5.2 InnoDB File-Per-Table モード</h3></div></div></div><a class="indexterm" name="idm139979073975584"></a><a class="indexterm" name="idm139979073973440"></a><a class="indexterm" name="idm139979073972096"></a><p>
      従来、<code class="literal">InnoDB</code> のすべてのテーブルとインデックスは、<a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">システムテーブルスペース</a>に格納されていました。このモノリシック方式は、データの拡大を綿密に計画した、データベース処理に完全に特化したマシンに対象を絞った方式です。この方式では、MySQL に割り当てられるどのディスクストレージも、他の目的のために要求されることはありません。<code class="literal">InnoDB</code> の <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> モードは、<code class="literal">InnoDB</code> の各テーブルとそのインデックスを個別のファイルに格納する方式の、柔軟性を向上した代替手段です。<a class="link" href="glossary.html#glos_ibd_file" title=".ibd ファイル"><code class="literal">.ibd</code></a> のような各ファイルは、それぞれの<a class="link" href="glossary.html#glos_tablespace" title="テーブルスペース">テーブルスペース</a>を表します。このモードは <code class="literal">innodb_file_per_table</code> 構成オプションで制御され、MySQL 5.6.6 以降ではデフォルトです。
    </p><h4><a name="idm139979073962016"></a>File-Per-Table モードの利点</h4><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          テーブルを切り詰めたり、削除したりするときに、オペレーティングシステムのディスクスペースを再利用できます。file-per-table モードがオフに切り替えられたときに作成されたテーブルの場合、テーブルを切り詰めたり、削除したりすると、内部的に <a class="link" href="glossary.html#glos_ibdata_file" title="ibdata ファイル">ibdata ファイル</a>に空き領域が作成されますが、その空き領域は新しい <code class="literal">InnoDB</code> データにのみ使用できます。
        </p></li><li class="listitem"><p>
          <code class="literal">TRUNCATE TABLE</code> 操作は、個々の <code class="filename">.ibd</code> ファイルで実行する場合よりも高速です。
        </p></li><li class="listitem"><p>
          I/O の最適化、容量管理、またはバップアップのために、特定のテーブルを別々のストレージデバイスに格納することができます。前のリリースでは、<a class="xref" href="optimization.html#symbolic-links" title="8.11.3.1 シンボリックリンクの使用">セクション8.11.3.1「シンボリックリンクの使用」</a>で述べられているように、ほかのドライブにデータベースディレクトリ全体を移動し、MySQL データディレクトリにシンボリックリンクを作成する必要がありました。MySQL 5.6.6 以降では、<a class="xref" href="innodb-storage-engine.html#tablespace-placing" title="14.5.4 テーブルスペースの位置の指定">セクション14.5.4「テーブルスペースの位置の指定」</a>で述べられているように、構文 <code class="literal">CREATE TABLE ... DATA DIRECTORY = <em class="replaceable"><code>absolute_path_to_directory</code></em></code> を使用して各テーブルの位置を特定できます。
        </p></li><li class="listitem"><p>
          <code class="literal">OPTIMIZE TABLE</code> を実行して、テーブルスペースを圧縮または再作成できます。<code class="literal">OPTIMIZE TABLE</code> を実行すると、<code class="literal">InnoDB</code> は実際のデータの格納に必要なスペースだけを使用して、一時名を持つ新しい <code class="filename">.ibd</code> ファイルを作成します。最適化が完了すると、<code class="literal">InnoDB</code> は古い <code class="filename">.ibd</code> ファイルを削除し、新しい <code class="filename">.ibd</code> ファイルで置き換えます。前の <code class="filename">.ibd</code> ファイルは非常に大きくなったが、実際のデータはそのサイズの一部を占めるだけの場合、<code class="literal">OPTIMIZE TABLE</code> を実行すると、未使用領域を再利用できます。
        </p></li><li class="listitem"><p>
          データベース全体ではなく、個別の <code class="literal">InnoDB</code> テーブルを移動できます。
        </p></li><li class="listitem"><p>
          ある MySQL インスタンスから別のインスタンスに個別の <code class="literal">InnoDB</code> テーブルをコピーできます (<a class="link" href="glossary.html#glos_transportable_tablespace" title="トランスポータブルテーブルスペース">トランスポータブルテーブルスペース</a> 機能として知られています)。
        </p></li><li class="listitem"><p>
          <code class="literal">innodb_file_per_table</code> が有効なときに作成されたテーブルは、<a class="link" href="glossary.html#glos_barracuda" title="Barracuda">Barracuda</a> ファイル形式を使用できます。Barracuda ファイル形式は、<a class="link" href="glossary.html#glos_compressed_row_format" title="圧縮行フォーマット">圧縮</a> および <a class="link" href="glossary.html#glos_dynamic_row_format" title="動的行フォーマット">ダイナミック</a> の行フォーマットなどの機能に対応します。<code class="literal">innodb_file_per_table</code> がオフのときに作成されたテーブルは、これらの機能を使用できません。これらの機能を既存のテーブルに利用するには、file-per-table 設定をオンにして、既存のテーブルで <code class="literal">ALTER TABLE <em class="replaceable"><code>t</code></em> ENGINE=INNODB</code> を実行します。テーブルを変換する前に、<a class="xref" href="innodb-storage-engine.html#converting-tables-to-innodb" title="14.6.4 MyISAM から InnoDB へのテーブルの変換">セクション14.6.4「MyISAM から InnoDB へのテーブルの変換」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <a class="link" href="glossary.html#glos_dynamic_row_format" title="動的行フォーマット">ダイナミック行フォーマット</a>を使用して、大きな BLOB またはテキストカラムを持つテーブルでストレージ効率を向上させることができます。
        </p></li><li class="listitem"><p>
          <code class="literal">innodb_file_per_table</code> を使用すると、リカバリが成功する可能性が高くなることがあります。また破損が発生した場合、サーバーが再起動できない場合、またはバックアップおよびバイナリログが使用できない場合に、時間が節約できる可能性があります。
        </p></li><li class="listitem"><p>
          MySQL Enterprise Backup 製品を使用して、他の <code class="literal">InnoDB</code> テーブルの使用を中断せずに、単一のテーブルを迅速にバックアップしたり、リストアしたりできます。詳細は、<a class="ulink" href="http://dev.mysql.com/doc/mysql-enterprise-backup/3.12/en/backup-partial-options.html" target="_top">Partial Backup and Restore Options</a>を参照してください。
        </p></li><li class="listitem"><p>
          File-per-table モードを使用すると、バックアップからテーブルを除外できます。これは、それほど頻繁にバックアップを取る必要のないテーブル、または別のスケジュールでバックアップが必要なテーブルに有効です。
        </p></li><li class="listitem"><p>
          file-per-table モードは、テーブルをコピーまたはバックアップするときにレポートする、テーブルごとのステータスに便利です。
        </p></li><li class="listitem"><p>
          file-per-table モードを使用すると、MySQL にアクセスせずに、ファイルシステムレベルでテーブルサイズをモニターできます。
        </p></li><li class="listitem"><p>
          一般的な Linux ファイルシステムでは、<code class="literal">innodb_flush_method</code> が <code class="literal">O_DIRECT</code> に設定されていると、1 つのファイルへの並列書き込みは許可されていません。その結果、<code class="literal">innodb_flush_method</code> と併せて <code class="literal">innodb_file_per_table</code> を使用すると、パフォーマンスが向上する可能性があります。
        </p></li><li class="listitem"><p>
          <code class="literal">innodb_file_per_table</code> が無効な場合、テーブル、データディクショナリ、および Undo ログに対して 1 つの共有テーブルスペース （システムテーブルスペース） があります。この 1 つのテーブルスペースのサイズの制限値は 64TB です。<code class="literal">innodb_file_per_table</code> が有効である場合、各テーブルには独自のテーブルスペースがあり、各テーブルスペースのサイズの制限値は 64TB です。関連情報については、<a class="xref" href="restrictions.html#table-size-limit" title="D.10.3 テーブルサイズの制限">セクションD.10.3「テーブルサイズの制限」</a>を参照してください。
        </p></li></ul></div><h4><a name="idm139979073909008"></a>File-Per-Table モードの考えられる短所</h4><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">innodb_file_per_table</code> の場合、各テーブルには未使用のテーブルスペースがある場合があり、そのテーブルスペースを利用できるのは同じテーブルの行だけです。これは、テーブルスペースが適切に管理されていないと、無駄なテーブルスペースが減るのではなく、増える結果となる可能性があります。
        </p></li><li class="listitem"><p>
          <code class="literal">fsync</code> 操作は、1 つのファイルではなく、各オープンテーブルで実行する必要があります。ファイルごとに別々の <code class="literal">fsync</code> 操作があるため、複数のテーブルへの書き込み操作を 1 つの I/O 操作に結合することはできません。このため、<code class="literal">InnoDB</code> は <code class="literal">fsync</code> 操作の総数を増やして実行する必要がある可能性があります。
        </p></li><li class="listitem"><p>
          <span class="command"><strong>mysqld</strong></span> では、テーブル当たり 1 つのオープンファイルの処理を維持する必要があるため、大量のテーブルがある場合、パフォーマンスに影響が出る可能性があります。
        </p></li><li class="listitem"><p>
          より多くのファイルディスクリプタが使用されます。
        </p></li><li class="listitem"><p>
          <code class="literal">innodb_file_per_table</code> は、MySQL 5.6.6 以降ではデフォルトでオンです。MySQL 5.5 または 5.1 との下位互換性に懸念がある場合、無効化の検討をお勧めします。<code class="literal">innodb_file_per_table</code> を無効にすると、<code class="literal">ALTER TABLE</code> がテーブル (<code class="literal">ALGORITHM=COPY</code>) を再作成する場合、<code class="literal">ALTER TABLE</code> で <code class="literal">InnoDB</code> テーブルがシステムのテーブルスペースから個々の <code class="filename">.ibd</code> ファイルに移動するのが抑えられます。
        </p><p>
          たとえば、<code class="literal">InnoDB</code> テーブルのクラスタインデックスを再構築する場合、テーブルは<code class="literal">innodb_file_per_table</code> の現在の設定を使用して再作成されます。この動作は、<code class="literal">InnoDB</code> のセカンダリインデックスを追加または削除するときには適用されません。セカンダリインデックスがテーブルを再構築しないで作成された場合、現在の <code class="literal">innodb_file_per_table</code> 設定にかかわらず、そのインデックスはテーブルデータと同じファイルに格納されます。
        </p></li><li class="listitem"><p>
          テーブルが増えていくと、<code class="literal">DROP TABLE</code> およびテーブルスキャンのパフォーマンスが下がることがあるフラグメンテーションが増える可能性があります。しかし、フラグメンテーションが管理されている場合、ファイル自身のテーブルスペース内にファイルがあると、パフォーマンスが向上する可能性があります。
        </p></li><li class="listitem"><p>
          バッファープールはテーブルごとのテーブルスペースを削除するときにスキャンされるため、サイズが数十ギガバイトのバッファープールに数秒かかる場合があります。スキャンは広範囲に内部ロックをかけて実行されるため、他の操作を遅らせる場合があります。共有テーブルスペース内のテーブルには影響ありません。
        </p></li><li class="listitem"><p>
          自動拡張の共有テーブルスペースが満杯になったときに、そのサイズを拡張する場合の増分サイズ (MB 単位) を定義する <code class="literal">innodb_autoextend_increment</code> 変数は、file-per-table テーブルスペースファイルに適用されません。<code class="literal">innodb_autoextend_increment</code> の値にかかわらず、file-per-table テーブルスペースファイルは自動拡張です。拡張は少量で始まり、その後の拡張は増分が 4MB で発生します。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="tablespace-enabling"></a>14.5.3 File-Per-Table モードの有効化および無効化</h3></div></div></div><p>
      file-per-table モードを MySQL サーバーのデフォルトにするには、<code class="option">--innodb_file_per_table</code> コマンド行オプションでサーバーを起動するか、<code class="filename">my.cnf</code> の <code class="literal">[mysqld]</code> セクションに次の行を追加します。
    </p><pre class="programlisting">
[mysqld]
innodb_file_per_table
</pre><p>
      サーバーが動作している間に、コマンドを発行することもできます。
    </p><pre class="programlisting">
SET GLOBAL innodb_file_per_table=1;
</pre><p>
      file-per-table モードが有効な場合、<code class="literal">InnoDB</code> は、適切なデータベースディレクトリ内の独自の <code class="filename"><em class="replaceable"><code>tbl_name</code></em>.ibd</code> ファイルに、新しく作成された各テーブルを格納します。<code class="literal">MyISAM</code> ストレージエンジンとは異なり、インデックスとデータにそれぞれ <code class="filename"><em class="replaceable"><code>tbl_name</code></em>.MYD</code> と <code class="filename"><em class="replaceable"><code>tbl_name</code></em>.MYI</code> ファイルがあると、<code class="literal">InnoDB</code> はデータとインデックスを一緒に 1 つの <code class="filename">.ibd</code> ファイルに格納します。それでも、<code class="filename"><em class="replaceable"><code>tbl_name</code></em>.frm</code> ファイルは従来どおり作成されます。
    </p><p>
      使用する起動オプションから <code class="literal">innodb_file_per_table</code> を削除してサーバーを再起動する場合、または <code class="literal">SET GLOBAL</code> コマンドでオプションをオフにした場合、<code class="literal">InnoDB</code> はシステムのテーブルスペース内に新しいテーブルを作成します。
    </p><p>
      file-per-table 設定にかかわらず、<code class="literal">InnoDB</code> テーブルの読み取りおよび書き込みは常に実行できます。
    </p><p>
      テーブルをシステムテーブルスペースから自身のテーブルスペースへ移動するには、またはその反対方向にテーブルを移動するには、<code class="literal">innodb_file_per_table</code> 設定を変更してテーブルを再作成します。
    </p><pre class="programlisting">
-- Move table from system tablespace to its own tablespace.
SET GLOBAL innodb_file_per_table=1;
ALTER TABLE <em class="replaceable"><code>table_name</code></em> ENGINE=InnoDB;
-- Move table from its own tablespace to system tablespace.
SET GLOBAL innodb_file_per_table=0;
ALTER TABLE <em class="replaceable"><code>table_name</code></em> ENGINE=InnoDB;
      </pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">InnoDB</code> は、内部の<a class="link" href="glossary.html#glos_data_dictionary" title="データディクショナリ">データディクショナリ</a> と <a class="link" href="glossary.html#glos_undo_log" title="Undo ログ">Undo ログ</a>をシステムのテーブルスペースに配置するため、常にこのテーブルスペースが必要です。<code class="filename">.ibd</code> ファイルは <code class="literal">InnoDB</code> が動作するのには十分ではありません。
      </p><p>
        システムテーブルスペースから独自の <code class="filename">.ibd</code> ファイルにテーブルが移動された場合、システムテーブルスペースを構成するデータファイルのサイズは維持されます。以前にテーブルが占有したスペースは、新しい <code class="literal">InnoDB</code> データ用に再利用できますが、オペレーティングシステム用には再利用されません。システムテーブルスペースから、ディスクスペースが限られているところへ大規模な <code class="literal">InnoDB</code> テーブルを移動する場合、<code class="literal">innodb_file_per_table</code> をオンにしてから <span class="command"><strong>mysqldump</strong></span> コマンドを使用してインスタンス全体を再作成することをお勧めします。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="tablespace-placing"></a>14.5.4 テーブルスペースの位置の指定</h3></div></div></div><p>
      新しい <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> テーブルスペースを MySQL データディレクトリの外側の特定の位置に作成するには、<code class="literal">CREATE TABLE</code> ステートメントの <code class="literal">DATA DIRECTORY = <em class="replaceable"><code>absolute_path_to_directory</code></em></code> 句を使用します。
    </p><p>
      あらかじめ位置について計画を立てます。<code class="literal">ALTER TABLE</code> ステートメントで <code class="literal">DATA DIRECTORY</code> 句を使用できないためです。指定するディレクトリは、高速の <a class="link" href="glossary.html#glos_ssd" title="SSD">SSD</a> や大容量の <a class="link" href="glossary.html#glos_hdd" title="HDD">HDD</a> など、パフォーマンスや容量に際だった特徴のあるほかのストレージデバイス上に置くことも可能です。
    </p><p>
      MySQL は、目的のディレクトリ内にデータベース名に対応するサブディレクトリを作成し、その中に、新しいテーブル用の <a class="link" href="glossary.html#glos_ibd_file" title=".ibd ファイル">.ibd ファイル</a> を作成します。MySQL は、MySQL <code class="literal">DATADIR</code> ディレクトリの下のデータベースディレクトリに、テーブルのパス名を含む <code class="literal"><em class="replaceable"><code>table_name</code></em>.isl</code> ファイル作成します。<a class="link" href="glossary.html#glos_isl_file" title=".isl ファイル">.isl file</a> は MySQL によってシンボリックリンクのように処理されます。(<a class="link" href="optimization.html#symbolic-links" title="8.11.3.1 シンボリックリンクの使用">実際のシンボリックリンクを使用すること</a>は <code class="literal">InnoDB</code> テーブルではサポートされませんでした。)
    </p><p>
      次の例では、MySQL の開発またはテスト用の小さなインスタンスを、95% が使用済みのプライマリハードドライブを搭載したノート型パソコンで実行し、空きスペースが多い別のストレージデバイス上に名前が <code class="literal">EXTERNAL</code> の新しいテーブルを配置する方法について示します。シェルコマンドは、<code class="literal">DATADIR</code> ディレクトリの下のデフォルトの位置にある <code class="literal">LOCAL</code> テーブルおよび指定した位置にある <code class="literal">EXTERNAL</code> テーブルへのさまざまなパスを示します。
    </p><pre class="programlisting">

mysql&gt; \! df -k .
Filesystem   1024-blocks      Used Available Capacity  iused   ifree %iused  Mounted on
/dev/disk0s2   244277768 231603532  12418236    95% 57964881 3104559   95%   /

mysql&gt; use test;
Database changed
mysql&gt; show variables like 'innodb_file_per_table';
+-----------------------+-------+
| Variable_name         | Value |
+-----------------------+-------+
| innodb_file_per_table | ON    |
+-----------------------+-------+
1 row in set (0.00 sec)

mysql&gt; \! pwd
/usr/local/mysql
mysql&gt; create table local (x int unsigned not null primary key);
Query OK, 0 rows affected (0.03 sec)

mysql&gt; \! ls -l data/test/local.ibd
-rw-rw----  1 cirrus  staff  98304 Nov 13 15:24 data/test/local.ibd

mysql&gt; create table external (x int unsigned not null primary key) data directory = '/volumes/external1/data';
Query OK, 0 rows affected (0.03 sec)

mysql&gt; \! ls -l /volumes/external1/data/test/external.ibd
-rwxrwxrwx  1 cirrus  staff  98304 Nov 13 15:34 /volumes/external1/data/test/external.ibd

mysql&gt; select count(*) from local;
+----------+
| count(*) |
+----------+
|        0 |
+----------+
1 row in set (0.01 sec)

mysql&gt; select count(*) from external;
+----------+
| count(*) |
+----------+
|        0 |
+----------+
1 row in set (0.01 sec)

</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注:</div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            最初、MySQL は <code class="literal">.ibd</code> ファイルを開いたままにして、デバイスがマウント解除されないようにしていますが、サーバーがビジーになると、結果的にテーブルを閉じることになる場合があります。MySQL の動作中に誤って外部デバイスをマウント解除したり、デバイスが接続されていないときに MySQL を起動したりしないように注意してください。関連する <code class="literal">.ibd</code> ファイルが欠けているときにテーブルにアクセスしようとすると、サーバーの再起動が必要となる重大なエラーの原因となります。
          </p><p>
            それでも <code class="literal">.ibd</code> ファイルが期待するパス上にない場合、サーバーの再起動が失敗する可能性があります。この場合、手動でデータベースディレクトリ内の <code class="literal"><em class="replaceable"><code>table_name</code></em>.isl</code> ファイルを削除し、再起動後に <code class="literal">DROP TABLE</code> を実行して <code class="literal">.frm</code> ファイルを削除し、テーブルに関する情報を<a class="link" href="glossary.html#glos_data_dictionary" title="データディクショナリ">データディクショナリ</a>から削除します。
          </p></li><li class="listitem"><p>
            NFS がマウントされたボリュームに MySQL テーブルを配置しないでください。NFS はメッセージパッシングプロトコルを使用してファイルに書き込むため、ネットワークメッセージが失われたり、順序どおりに受信しなかったりした場合に、データの一貫性が失われる原因となる可能性があります。
          </p></li><li class="listitem"><p>
            LVM スナップショット、ファイルのコピー、または他のファイルベースのメカニズムを使用して、<code class="literal">.ibd</code> ファイルのバックアップを取る場合、必ず最初に <code class="literal">FLUSH TABLES ... FOR EXPORT</code> ステートメントを使用して、メモリーにバッファリングされたすべての変更が、バックアップを行う前にディスクに<a class="link" href="glossary.html#glos_flush" title="フラッシュ">フラッシュ</a>されていることを確認します。
          </p></li><li class="listitem"><p>
            <code class="literal">DATA DIRECTORY</code> 句は <a class="link" href="optimization.html#symbolic-links" title="8.11.3.1 シンボリックリンクの使用">シンボリックリンクの使用</a> のサポート済み代替手段です。これはずっと問題があり、各 <code class="literal">InnoDB</code> テーブルには決してサポートされませんでした。
          </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="tablespace-copying"></a>14.5.5 テーブルスペースの別のサーバーへのコピー (トランスポータブルテーブルスペース)</h3></div></div></div><a class="indexterm" name="idm139979073802112"></a><p>
      このセクションでは、<a class="link" href="glossary.html#glos_transportable_tablespace" title="トランスポータブルテーブルスペース">Transportable Tablespace</a> 機能を使用して、<a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> テーブルスペース (<code class="filename">.idb</code> ファイル) をあるデータベースサーバーから別のデータベースサーバーにコピーする方法について説明します。
    </p><p>
      他の <code class="literal">InnoDB</code> テーブルコピー方式について詳しくは、<a class="xref" href="innodb-storage-engine.html#innodb-migration" title="14.6.2 別のマシンへの InnoDB テーブルの移動またはコピー">セクション14.6.2「別のマシンへの InnoDB テーブルの移動またはコピー」</a>を参照してください。
    </p><p>
      <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> テーブルスペースを別のデータベースサーバーにコピーすることをお勧めするのには、多くの理由があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          本番サーバーに余計な負荷を掛けずにレポートを実行するため。
        </p></li><li class="listitem"><p>
          新しい<a class="link" href="glossary.html#glos_slave_server" title="スレーブサーバー">スレーブサーバー</a>に、あるテーブルとまったく同じデータをセットアップするため。
        </p></li><li class="listitem"><p>
          問題や誤りが発生したあとに、テーブルのバックアップ版をリストアするため。
        </p></li><li class="listitem"><p>
          <span class="command"><strong>mysqldump</strong></span> コマンドの結果をインポートするよりも、データを移動させる方が速いため。データの再挿入とインデックスの再構築を行うよりも、データがすぐに使用できるためです。
        </p></li><li class="listitem"><p>
          システム要件により適したストレージ媒体を持つサーバーに <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> テーブルスペースを移動するため。たとえば、アクセス頻度の高いテーブルを <a class="link" href="glossary.html#glos_ssd" title="SSD">SSD</a> デバイスに置いたり、大規模なテーブルを大容量の <a class="link" href="glossary.html#glos_hdd" title="HDD">HDD</a> デバイスに置いたりする場合です。
        </p></li></ul></div><h4><a name="idm139979073782832"></a>テーブルスペースのコピーの制限と使用方法に関する注意 (トランスポータブルテーブルスペース)</h4><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          テーブルスペースのコピー手順は、<code class="literal">innodb_file_per_table</code> が <code class="literal">ON</code> (MySQL 5.6.6 以降ではデフォルトです) に設定されている場合にのみ可能です。共有のシステムテーブルスペースにあるテーブルは休止できません。
        </p></li><li class="listitem"><p>
          テーブルが休止されると、影響を受けたテーブルでは読み取り専用のトランザクションのみが許可されます。
        </p></li><li class="listitem"><p>
          テーブルスペースをインポートする場合、ページサイズはインポートするインスタンスのページサイズに一致する必要があります。
        </p></li><li class="listitem"><p>
          <code class="literal">DISCARD TABLESPACE</code> がパーティション化されたテーブルでサポートされていないということは、トランスポータブルテーブルスペースも未サポートであることを意味します。パーティション化されたテーブルで <code class="literal">ALTER TABLE ... DISCARD TABLESPACE</code> を実行すると、次のエラーが返されます。<span class="errortext">ERROR 1031 (HY000): Table storage engine for 'part' doesn't have this option</span>.
        </p></li><li class="listitem"><p>
          <code class="literal">DISCARD TABLESPACE</code> は、<code class="literal">foreign_key_checks</code> が <code class="literal">1</code> に設定されている親/子 (主キー/外部キー) 関係を持つテーブルスペースをサポートしていません。親子関係のテーブルのテーブルスペースを破棄する前に、<code class="literal">foreign_key_checks=0</code> を設定します。
        </p></li><li class="listitem"><p>
          <code class="literal">ALTER TABLE ... IMPORT TABLESPACE</code> は、インポートされたデータに対して外部キー制約を課しません。テーブル間に外部キー制約がある場合、すべてのテーブルを同じ (論理上の) 時点でエクスポートしてください。
        </p></li><li class="listitem"><p>
          <code class="literal">ALTER TABLE ... IMPORT TABLESPACE</code> では、テーブルスペースをインポートするための <code class="filename">.cfg</code> メタデータファイルは必要ありません。ただし、<code class="filename">.cfg</code> ファイルなしでインポートした場合は、メタデータのチェックは実行されず、次に類似した警告が発行されます。
        </p><pre class="programlisting">
Message: InnoDB: IO Read error: (2, No such file or directory) Error opening '.\
test\t.cfg', will attempt to import without schema verification
1 row in set (0.00 sec) 
</pre><p>
          <code class="filename">.cfg</code> ファイルなしでインポートする機能は、スキーマの不一致が予想されない場合に、使い勝手が高まる可能性があります。また、<code class="filename">.cfg</code> ファイルなしでインポートする機能は、メタデータが <code class="filename">.ibd</code> ファイルから収集できないクラッシュリカバリシナリオで役立つ可能性があります。
        </p></li><li class="listitem"><p>
          MySQL 5.6 以降では、両方のサーバーが GA (一般提供) ステータスであり、両者のバージョンが同じシリーズである場合に、テーブルスペースファイルの別のサーバーからのインポートが機能します。そうでないと、インポート先のサーバーにファイルが作成されていなければなりません。
        </p></li><li class="listitem"><p>
          レプリケーションシナリオでは、マスターとスレーブの両方で <code class="literal">innodb_file_per_table</code> が <code class="literal">ON</code> に設定されている必要があります。
        </p></li><li class="listitem"><p>
          Windows では、<code class="literal">InnoDB</code> はデータベース、テーブルスペース、およびテーブル名を内部的に小文字で格納します。Linux や UNIX など、大文字と小文字を区別するオペレーティングシステムでインポートの問題を回避するには、すべてのデータベース、テーブルスペース、およびテーブルを小文字名を使用して作成します。これを遂行する便利な方法は、データベース、テーブルスペース、またはテーブルを作成する前に、<code class="filename">my.cnf</code> または <code class="filename">my.ini</code> ファイルの <code class="literal">[mysqld]</code> セクションに次の行を追加することです。
        </p><pre class="programlisting">
[mysqld]
lower_case_table_names=1
</pre></li></ul></div><h4><a name="idm139979073748096"></a>手順の例: あるサーバーから別のサーバーへのテーブルスペースのコピー (トランスポータブルテーブルスペース)</h4><p>
      この手順では、MySQL の実行中のサーバーインスタンスから実行中の別のインスタンスへテーブルをコピーする方法について説明します。同じ手順は、微調整を加えると、同じインスタンスでテーブルの完全なリストアを実行するために使用できます。
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          ソースサーバーで、テーブルがまだ存在していない場合、テーブルを作成します。
        </p><pre class="programlisting">
mysql&gt; use test;
mysql&gt; CREATE TABLE t(c1 INT) engine=InnoDB;
</pre></li><li class="listitem"><p>
          目的サーバーで、テーブルが存在していない場合、テーブルを作成します。
        </p><pre class="programlisting">
mysql&gt; use test;
mysql&gt; CREATE TABLE t(c1 INT) engine=InnoDB;
</pre></li><li class="listitem"><p>
          目的サーバーで、既存のテーブルスペースを破棄します。(テーブルスペースをインポートする前に、<code class="literal">InnoDB</code> は受け取り側のテーブルにアタッチされたテーブルスペースを破棄します。)
        </p><pre class="programlisting">
mysql&gt; ALTER TABLE t DISCARD TABLESPACE;
</pre></li><li class="listitem"><p>
          ソースサーバーでは、<code class="literal">FLUSH TABLES ... FOR EXPORT</code> を実行してテーブルを休止し、<code class="filename">.cfg</code> メタデータファイルを作成します。
        </p><pre class="programlisting">
mysql&gt; use test;
mysql&gt; FLUSH TABLES t FOR EXPORT;
</pre><p>
          メタデータ (<code class="filename">.cfg</code>) ファイルは <code class="literal">InnoDB</code> データディレクトリに作成されます。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            <code class="literal">FLUSH TABLES ... FOR EXPORT</code> は MySQL 5.6.6 以降で使用できます。このステートメントは、サーバー稼働中にバイナリテーブルのコピーができるように、名前付きテーブルへの変更をディスクにフラッシュします。<code class="literal">FLUSH TABLES ... FOR EXPORT</code> が実行されると、<code class="literal">InnoDB</code> はテーブルと同じデータベースディレクトリに <code class="filename">.cfg</code> ファイルを作成します。<code class="filename">.cfg</code> ファイルには、テーブルスペースファイルをインポートするときのスキーマの検証に使用されるメタデータが含まれます。
          </p></div></li><li class="listitem"><p>
          <code class="filename">.ibd</code> ファイルおよび <code class="filename">.cfg</code> メタデータファイルをソースサーバーから目的サーバーにコピーします。例:
        </p><pre class="programlisting">
shell&gt; scp <em class="replaceable"><code>/path/to/datadir</code></em>/test/t.{ibd,cfg} destination-server:<em class="replaceable"><code>/path/to/datadir</code></em>/test
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            <code class="filename">.ibd</code> ファイルおよび <code class="filename">.cfg</code> ファイルは、次の手順で示すように、共有ロックを解放する前にコピーする必要があります。
          </p></div></li><li class="listitem"><p>
          ソースサーバーでは、<code class="literal">UNLOCK TABLES</code> を使用して、<code class="literal">FLUSH TABLES ... FOR EXPORT</code> によって取得されたロックを解放します。
        </p><pre class="programlisting">
mysql&gt; use test;
mysql&gt; UNLOCK TABLES;
</pre></li><li class="listitem"><p>
          目的サーバーで、テーブルスペースをインポートします。
        </p><pre class="programlisting">
mysql&gt; use test;
mysql&gt; ALTER TABLE t IMPORT TABLESPACE;
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            <code class="literal">ALTER TABLE ... IMPORT TABLESPACE</code> 機能は、インポートされたデータに対して外部キー制約を課しません。テーブル間に外部キー制約がある場合、すべてのテーブルを同じ (論理上の) 時点でエクスポートしてください。この場合、テーブルの更新を停止し、すべてのトランザクションをコミットし、テーブルで共有ロックを取得してから、エクスポート操作を実行します。
          </p></div></li></ol></div><h4><a name="idm139979073711424"></a>テーブルスペースのコピーの内部情報 (トランスポータブルテーブルスペース)</h4><p>
      次の情報では、トランスポータブルテーブルスペースのコピー手順に関する内部情報とエラーログについて説明します。
    </p><p>
      <code class="literal">ALTER TABLE ... DISCARD TABLESPACE</code> が目的のインスタンスで実行された場合。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          テーブルは X モードでロックされています。
        </p></li><li class="listitem"><p>
          テーブルスペースがテーブルから切り離されています。
        </p></li></ul></div><p>
      <code class="literal">FLUSH TABLES ... FOR EXPORT</code> がソースインスタンスで実行された場合。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          エクスポートのためにフラッシュされたテーブルが共有モードでロックされています。
        </p></li><li class="listitem"><p>
          パージコーディネータのスレッドが停止しています。
        </p></li><li class="listitem"><p>
          ダーティーページがディスクに同期しています。
        </p></li><li class="listitem"><p>
          テーブルのメタデータがバイナリの <code class="filename">.cfg</code> ファイルに書き込まれました。
        </p></li></ul></div><p>
      この操作で予想されるエラーログメッセージです。
    </p><pre class="programlisting">
2013-07-18 14:47:31 34471 [Note] InnoDB: Sync to disk of '"test"."t"' started.
2013-07-18 14:47:31 34471 [Note] InnoDB: Stopping purge
2013-07-18 14:47:31 34471 [Note] InnoDB: Writing table metadata to './test/t.cfg'
2013-07-18 14:47:31 34471 [Note] InnoDB: Table '"test"."t"' flushed to disk
 </pre><p>
      <code class="literal">UNLOCK TABLES</code> がソースインスタンスで実行された場合。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          バイナリの .cfg ファイルが削除されました。
        </p></li><li class="listitem"><p>
          インポートされたテーブル (または複数のテーブル) の共有ロックが解放され、パージコーディネータのスレッドが再起動されました。
        </p></li></ul></div><p>
      この操作で予想されるエラーログメッセージです。
    </p><pre class="programlisting">
2013-07-18 15:01:40 34471 [Note] InnoDB: Deleting the meta-data file './test/t.cfg'
2013-07-18 15:01:40 34471 [Note] InnoDB: Resuming purge
</pre><p>
      <code class="literal">ALTER TABLE ... IMPORT TABLESPACE</code> が目的のインスタンスで実行されると、インポートのアルゴリズムはインポートされたテーブルスペースごとに次の操作を実行します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          テーブルスペースの各ページに破損があるかどうかをチェックします。
        </p></li><li class="listitem"><p>
          各ページのスペース ID とログシーケンス番号 (LSN) が更新されます。
        </p></li><li class="listitem"><p>
          フラグが検証され、ヘッダーページの LSN が更新されます。
        </p></li><li class="listitem"><p>
          B ツリーページが更新されます。
        </p></li><li class="listitem"><p>
          ページの状態がディスクに書き込まれるように、この状態をダーティーに設定します。
        </p></li></ul></div><p>
      この操作で予想されるエラーログメッセージです。
    </p><pre class="programlisting">
2013-07-18 15:15:01 34960 [Note] InnoDB: Importing tablespace for table 'test/t' that was exported from host 'ubuntu'
2013-07-18 15:15:01 34960 [Note] InnoDB: Phase I - Update all pages
2013-07-18 15:15:01 34960 [Note] InnoDB: Sync to disk
2013-07-18 15:15:01 34960 [Note] InnoDB: Sync to disk - done!
2013-07-18 15:15:01 34960 [Note] InnoDB: Phase III - Flush changes to disk
2013-07-18 15:15:01 34960 [Note] InnoDB: Phase IV - Flush complete
      </pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        テーブルスペースが破棄されたこと (目的のテーブルのテーブルスペースを破棄した場合) を伝える警告、および <code class="filename">.ibd</code> ファイルがないために統計値が計算できなかったことを伝えるメッセージも受け取る場合があります。
      </p><pre class="programlisting">
2013-07-18 15:14:38 34960 [Warning] InnoDB: Table "test"."t" tablespace is set as discarded.
2013-07-18 15:14:38 7f34d9a37700 InnoDB: cannot calculate statistics for table "test"."t" because the .ibd file is missing. For help, please refer to 
http://dev.mysql.com/doc/refman/5.7/en/innodb-troubleshooting.html
</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-undo-tablespace"></a>14.5.6 個別のテーブルスペースへの InnoDB Undo ログの格納</h3></div></div></div><a class="indexterm" name="idm139979073678400"></a><a class="indexterm" name="idm139979073676976"></a><p>
      MySQL 5.6.3 以降は、<a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">システムテーブルスペース</a>を除く 1 つ以上の個別の <a class="link" href="glossary.html#glos_undo_tablespace" title="Undo テーブルスペース">Undo テーブルスペース</a>に <code class="literal">InnoDB</code> の <a class="link" href="glossary.html#glos_undo_log" title="Undo ログ">Undo ログ</a>を格納することができます。このレイアウトは、Undo ログが <a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">システムテーブルスペース</a>の一部であるデフォルト構成とは異なります。Undo ログの I/O パターンにより、これらのテーブルスペースは <a class="link" href="glossary.html#glos_ssd" title="SSD">SSD</a> ストレージへの移動に適した候補になります。一方、システムテーブルスペースはハードディスクストレージに維持します。ユーザーは、<code class="literal">InnoDB</code> の Undo ログを保持するために作成された個々のテーブルスペース、およびそのテーブルスペース内の各<a class="link" href="glossary.html#glos_segment" title="セグメント">セグメント</a>を削除できません。
    </p><p>
      これらのファイルで、システムテーブルスペース内で以前に実行された I/O 操作を処理するため、これらの新しいファイルを加えるように、システムテーブルスペースの定義を拡張します。
    </p><p>
      Undo ログは<a class="link" href="glossary.html#glos_rollback_segment" title="ロールバックセグメント">ロールバックセグメント</a>としても知られています。
    </p><p>
      この機能には、次の新しい構成オプションまたは名前の変わった構成オプションが含まれます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">innodb_undo_tablespaces</code>。
        </p></li><li class="listitem"><p>
          <code class="literal">innodb_undo_directory</code>。
        </p></li><li class="listitem"><p>
          <code class="literal">innodb_rollback_segments</code> は <code class="literal">innodb_undo_logs</code> になります。互換性のため、古い名前も使用できます。
        </p></li></ul></div><p>
      <code class="literal">InnoDB</code> の <a class="link" href="glossary.html#glos_undo_log" title="Undo ログ">Undo ログ</a>機能には 2 つの非動的起動変数 (<code class="literal">innodb_undo_tablespaces</code> および <code class="literal">innodb_undo_directory</code>) の設定を伴うため、この機能は MySQL インスタンスを初期化する場合にのみ有効化できます。
    </p><h4><a name="idm139979073653504"></a>使用上の注意</h4><p>
      この機能を使用するには、次の手順に従います。
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          Undo ログを保持するパスを決めます。MySQL 構成ファイルまたは起動スクリプトにある <code class="literal">innodb_undo_directory</code> オプションの引数としてそのパスを指定します。
        </p></li><li class="listitem"><p>
          <code class="literal">innodb_undo_logs</code> オプションにゼロでない開始値を指定します。比較的小さい値から始めて、パフォーマンスの効果を調べて徐々に値を増やすことができます。
        </p></li><li class="listitem"><p>
          <code class="literal">innodb_undo_tablespaces</code> オプションにゼロでない値を指定します。<code class="literal">innodb_undo_logs</code> 値で指定された複数の Undo ログは、この数の個々のテーブルスペース (<a class="link" href="glossary.html#glos_ibd_file" title=".ibd ファイル"><code class="filename">.ibd</code></a> ファイルで指定) に分割されます。この値は、MySQL インスタンスが有効である間は固定されるため、最適値が確かでない場合は、どちらかというと高く見積もります。
        </p></li><li class="listitem"><p>
          構成ファイルまたは MySQL 起動スクリプトで選択した値を使用して、新しい MySQL インスタンスを作成します。本番サーバーに類似したデータ量の現実的なワークロードを使用します。また、トランスポータブルテーブルスペース機能を使用して、既存のデータベースのテーブルを新しく構成した MySQL インスタンスにコピーします。詳細は、<a class="xref" href="innodb-storage-engine.html#tablespace-copying" title="14.5.5 テーブルスペースの別のサーバーへのコピー (トランスポータブルテーブルスペース)">セクション14.5.5「テーブルスペースの別のサーバーへのコピー (トランスポータブルテーブルスペース)」</a>を参照してください。
        </p></li><li class="listitem"><p>
          I/O が多いワークロードのパフォーマンスのベンチマーク。
        </p></li><li class="listitem"><p>
          繰り返し、<code class="literal">innodb_undo_logs</code> の値を増やして、パフォーマンステストをやり直します。I/O パフォーマンスゲインが停止する値を見つけます。
        </p></li><li class="listitem"><p>
          これらのオプションに理想的な設定を使用して、新しい本番インスタンスを配備します。<a class="link" href="glossary.html#glos_replication" title="レプリケーション">レプリケーション</a>構成で<a class="link" href="glossary.html#glos_slave_server" title="スレーブサーバー">スレーブサーバー</a>として設定するか、以前の本番インスタンスからデータを移動します。
        </p></li></ol></div><h4><a name="idm139979073634064"></a>パフォーマンスおよびスケーラビリティーに関する考慮事項</h4><p>
      Undo ログを個々のファイルに保持すると、MySQL チームはこのトランザクションデータに関連した、I/O とメモリーの最適化を実装できます。たとえば、Undo データはディスクに書き込まれ、その上まれにしか使用されないため (クラッシュリカバリの場合にのみ)、ファイルシステムのメモリーキャッシュに保持しておく必要がなく、その結果、より多くのシステムメモリーを <code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a> に割り当てることができます。
    </p><p>
      <code class="literal">InnoDB</code> システムのテーブルスペースをハードドライブに保持し、テーブルごとのテーブルスペースを SSD に移動するという、典型的な SSD ベストプラクティスは、Undo 情報を個々のテーブルスペースファイルに移動することで役に立ちます。
    </p><h4><a name="idm139979073628912"></a>内部情報</h4><p>
      物理的なテーブルスペースファイルの名前は <code class="filename">undo<em class="replaceable"><code>N</code></em></code> です。ここで、<em class="replaceable"><code>N</code></em> はスペース ID (頭のゼロを含む) です。
    </p><p>
      現在、個々の Undo テーブルスペースを含む MySQL インスタンスは、MySQL 5.5 や 5.1 などの以前のリリースにはダウングレードできません。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-data-log-reconfiguration"></a>14.5.7 InnoDB ログファイルの数またはサイズの変更、および InnoDB テーブルスペースのサイズの変更</h3></div></div></div><a class="indexterm" name="idm139979073623952"></a><a class="indexterm" name="idm139979073621808"></a><a class="indexterm" name="idm139979073619776"></a><p>
    このセクションでは、<code class="literal">InnoDB</code> の <a class="link" href="glossary.html#glos_redo_log" title="Redo ログ">Redo ログ</a>ファイルの数またはサイズを変更する方法、および <code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">システムテーブルスペース</a>のサイズを増加または減少する方法について説明します。
  </p><h4><a name="idm139979073614752"></a>InnoDB ログファイルの数またはサイズの変更</h4><p>
    MySQL 5.6.7 以前で <code class="literal">InnoDB</code> の Redo ログファイルの数またはサイズを変更するには、次の手順を実行します。
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
        <code class="literal">innodb_fast_shutdown</code> が 2 に設定されている場合は、<code class="literal">innodb_fast_shutdown</code> を 1 に設定します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET GLOBAL innodb_fast_shutdown = 1;</code></strong>
</pre></li><li class="listitem"><p>
        <code class="literal">innodb_fast_shutdown</code> が 2 に設定されていないことを確認したあとに、MySQL サーバーを停止し、エラーなしでシャットダウンされること (ログ内に未処理のトランザクションに関する情報が存在しないこと) を確認します。
      </p></li><li class="listitem"><p>
        シャットダウン中に何か問題が発生して、テーブルスペースをリカバリするために古いログファイルが必要となる場合に備えて、それらのログファイルを安全な場所にコピーします。
      </p></li><li class="listitem"><p>
        ログファイルディレクトリから古いログファイルを削除します。
      </p></li><li class="listitem"><p>
        <code class="filename">my.cnf</code> を編集して、ログファイルの構成を変更します。
      </p></li><li class="listitem"><p>
        MySQL を再起動します。<span class="command"><strong>mysqld</strong></span> によって、起動時に <code class="literal">InnoDB</code> ログファイルが存在しないことが表示され、新しいログファイルが作成されます。
      </p></li></ol></div><p>
    MySQL 5.6.8 の時点では、<code class="literal">InnoDB</code> ログファイルの数またはサイズを変更する際に、<code class="literal">innodb_fast_shutdown</code> 設定が関連しなくなりました。さらに、古いログファイルを削除する必要もなくなりました。ただし、バックアップとして古いログファイルを安全な場所にコピーすることはあります。<code class="literal">InnoDB</code> のログファイルの数またはサイズを変更するには、次の手順を実行します。
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
        MySQL サーバーを停止し、エラーなしでシャットダウンされることを確認します。
      </p></li><li class="listitem"><p>
        <code class="filename">my.cnf</code> を編集して、ログファイルの構成を変更します。ログファイルのサイズを変更するには、<code class="literal">innodb_log_file_size</code> を構成します。ログファイルの数を多くするには、<code class="literal">innodb_log_files_in_group</code> を構成します。
      </p></li><li class="listitem"><p>
        MySQL サーバーを再起動します。
      </p></li></ol></div><p>
    <code class="literal">InnoDB</code> で <code class="literal">innodb_log_file_size</code> が Redo ログファイルのサイズと異なることが検出された場合は、ログチェックポイントが書き込まれ、古いログファイルが閉じられてから削除され、リクエストされたサイズで新しいファイルが作成され、その新しいログファイルが開かれます。
  </p><h4><a name="idm139979073585232"></a>InnoDB テーブルスペースのサイズの増加</h4><p>
    <code class="literal">InnoDB</code> システムテーブルスペースのサイズを大きくするもっとも簡単な方法は、最初から自動拡張として構成することです。テーブルスペース定義内の最後のデータファイルに <code class="literal">autoextend</code> 属性を指定します。これにより、<code class="literal">InnoDB</code> が領域を使い果たすと、そのファイルのサイズが自動的に 8M バイトずつ増加します。<code class="literal">innodb_autoextend_increment</code> システム変数の値を設定すると、増分のサイズを変更できます。このサイズは、M バイト単位で測定されます。
  </p><p>
    別のデータファイルを追加すると、システムテーブルスペースを定義された量だけ拡大できます。
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
        MySQL サーバーをシャットダウンします。
      </p></li><li class="listitem"><p>
        以前の最後のデータファイルが <code class="literal">autoextend</code> というキーワードを使用して定義されている場合は、実際に増加した大きさに基づいて、固定サイズが使用されるようにその定義を変更します。データファイルのサイズをチェックし、それを 1024 × 1024 バイト (= 1M バイト) にもっとも近い倍数に丸め、この丸められたサイズを <code class="literal">innodb_data_file_path</code> に明示的に指定します。
      </p></li><li class="listitem"><p>
        新しいデータファイルを <code class="literal">innodb_data_file_path</code> の末尾に追加します。これにより、オプションでそのファイルが自動拡張になります。<code class="literal">innodb_data_file_path</code> で自動拡張として指定できるのは、最後のデータファイルのみです。
      </p></li><li class="listitem"><p>
        MySQL サーバーを再起動します。
      </p></li></ol></div><p>
    たとえば、このテーブルスペースには、<code class="filename">ibdata1</code> という 1 つの自動拡張データファイルしか存在しません。
  </p><pre class="programlisting">
innodb_data_home_dir =
innodb_data_file_path = /ibdata/ibdata1:10M:autoextend
</pre><p>
    このデータファイルが、時間をかけて 988M バイトまで増加したと仮定します。次に、固定サイズが使用されるように元のデータファイルを変更し、新しい自動拡張データファイルを追加したあとの構成行を示します。
  </p><pre class="programlisting">
innodb_data_home_dir =
innodb_data_file_path = /ibdata/ibdata1:988M;/disk2/ibdata2:50M:autoextend
</pre><p>
    新しいデータファイルをシステムテーブルスペース構成に追加する際に、そのファイル名が既存のファイルを参照していないことを確認してください。<code class="literal">InnoDB</code> は、サーバーの起動時にファイルを作成し、初期化します。
  </p><h4><a name="idm139979073562656"></a>InnoDB テーブルスペースのサイズの減少</h4><p>
    現在は、システムテーブルスペースからデータファイルを削除できません。システムテーブルスペースのサイズを小さくするには、次の手順を使用します。
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
        <span class="command"><strong>mysqldump</strong></span> を使用して、MySQL データベース内に配置されている <code class="literal">InnoDB</code> テーブルを含む、すべての <code class="literal">InnoDB</code> テーブルをダンプします。5.6 の時点では、MySQL データベース内に 5 つの <code class="literal">InnoDB</code> テーブルが含まれています。
      </p><pre class="programlisting">
mysql&gt; select table_name from information_schema.tables where table_schema='mysql' and engine='InnoDB';
+----------------------+
| table_name           |
+----------------------+
| innodb_index_stats   |
| innodb_table_stats   |
| slave_master_info    |
| slave_relay_log_info |
| slave_worker_info    |
+----------------------+
5 rows in set (0.00 sec)
      </pre></li><li class="listitem"><p>
        サーバーを停止します。
      </p></li><li class="listitem"><p>
        <code class="filename">ibdata</code> および <code class="filename">ib_log</code> ファイルを含む、すべての既存のテーブルスペースファイル (<code class="filename">*.ibd</code>) を削除します。MySQL データベース内に配置されているテーブルの <code class="filename">*.ibd</code> ファイルも忘れずに削除してください。
      </p></li><li class="listitem"><p>
        <code class="literal">InnoDB</code> テーブルのすべての <code class="filename">.frm</code> ファイルを削除します。
      </p></li><li class="listitem"><p>
        新しいテーブルスペースを構成します。
      </p></li><li class="listitem"><p>
        サーバーを再起動します。
      </p></li><li class="listitem"><p>
        ダンプファイルをインポートします。
      </p></li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
      データベースで <code class="literal">InnoDB</code> エンジンのみが使用されている場合は、<span class="bold"><strong>すべての</strong></span>データベースをダンプし、サーバーを停止し、すべてのデータベースおよび <code class="literal">InnoDB</code> のログファイルを削除し、サーバーを再起動し、ダンプファイルをインポートした方が簡単な可能性があります。
    </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-raw-devices"></a>14.5.8 共有テーブルスペースでの RAW ディスクパーティションの使用</h3></div></div></div><a class="indexterm" name="idm139979073539856"></a><a class="indexterm" name="idm139979073537696"></a><p>
    <code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">システムテーブルスペース</a>では、データファイルとして RAW ディスクパーティションを使用できます。この方法を使用すると、ファイルシステムのオーバーヘッドが発生せずに、Windows 上および一部の Linux と Unix 上でバッファーに入れられない I/O が有効になります。RAW パーティションを使用する場合と使用しない場合でテストを実行して、この変更によって実際にシステム上のパフォーマンスが改善されるかどうかを確認します。
  </p><p>
    RAW ディスクパーティションを使用する場合は、MySQL サーバーを実行しているユーザー ID がそのパーティションに対する読み取り権限および書き込み権限を持っていることを確認します。たとえば、<code class="literal">mysql</code> ユーザーとしてサーバーを実行する場合は、そのパーティションが <code class="literal">mysql</code> によって読み取り可能および書き込み可能である必要があります。<code class="option">--memlock</code> オプションを付けてサーバーを実行する場合は、サーバーを <code class="literal">root</code> として実行する必要があるため、パーティションが <code class="literal">root</code> によって読み取り可能および書き込み可能である必要があります。
  </p><p>
    次で説明する手順には、オプションファイルの変更が伴います。追加情報については、<a class="xref" href="programs.html#option-files" title="4.2.6 オプションファイルの使用">セクション4.2.6「オプションファイルの使用」</a>を参照してください。
  </p><h4><a name="idm139979073526464"></a>Linux および Unix システムでの RAW ディスクパーティションの割り当て</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
        新しいデータファイルを作成する際は、<code class="literal">innodb_data_file_path</code> オプションのデータファイルサイズの直後に、<code class="literal">newraw</code> というキーワードを指定します。パーティションは、少なくとも指定したサイズと同じである必要があります。ディスク指定の 1M バイトは通常 1,000,000 バイトを意味するのに対して、<code class="literal">InnoDB</code> 内の 1M バイトは 1024 × 1024 バイトであることに注意してください。
      </p><pre class="programlisting">
[mysqld]
innodb_data_home_dir=
innodb_data_file_path=/dev/hdd1:3Gnewraw;/dev/hdd2:2Gnewraw
</pre></li><li class="listitem"><p>
        サーバーを再起動します。<code class="literal">InnoDB</code> によって <code class="literal">newraw</code> キーワードが認識され、新しいパーティションが初期化されます。ただし、まだ <code class="literal">InnoDB</code> テーブルを作成したり変更したりしないでください。そうしなければ、サーバーを次に再起動したときに <code class="literal">InnoDB</code> によってパーティションが再初期化され、変更がすべて失われます。(安全策として、<code class="literal">InnoDB</code> では、<code class="literal">newraw</code> を含むパーティションが指定されたときにユーザーがデータを更新することが回避されます。)
      </p></li><li class="listitem"><p>
        <code class="literal">InnoDB</code> によって新しいパーティションが初期化されたら、サーバーを停止し、データファイルの指定で <code class="literal">newraw</code> を <code class="literal">raw</code> に変更します。
      </p><pre class="programlisting">
[mysqld]
innodb_data_home_dir=
innodb_data_file_path=/dev/hdd1:3Graw;/dev/hdd2:2Graw
</pre></li><li class="listitem"><p>
        サーバーを再起動します。これにより、<code class="literal">InnoDB</code> で変更を行うことが許可されます。
      </p></li></ol></div><h4><a name="idm139979073507968"></a>Windows での RAW ディスクパーティションの割り当て</h4><p>
    Windows システムでは、Linux および Unix システムで説明したものと同じ手順および付随するガイドラインが適用されます。ただし、Windows では <code class="literal">innodb_data_file_path</code> の設定がわずかに異なります。
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
        新しいデータファイルを作成する際は、<code class="literal">innodb_data_file_path</code> オプションのデータファイルサイズの直後に、<code class="literal">newraw</code> というキーワードを指定します。
      </p><pre class="programlisting">
[mysqld]
innodb_data_home_dir=
innodb_data_file_path=//./D::10Gnewraw
</pre><p>
        <code class="filename">//./</code> は、物理ドライブにアクセスするための Windows の構文 <code class="filename">\\.\</code> に対応しています。前述の例では、<code class="literal">D:</code> がパーティションのドライブ文字です。
      </p></li><li class="listitem"><p>
        サーバーを再起動します。<code class="literal">InnoDB</code> によって <code class="literal">newraw</code> キーワードが認識され、新しいパーティションが初期化されます。
      </p></li><li class="listitem"><p>
        <code class="literal">InnoDB</code> によって新しいパーティションが初期化されたら、サーバーを停止し、データファイルの指定で <code class="literal">newraw</code> を <code class="literal">raw</code> に変更します。
      </p><pre class="programlisting">
[mysqld]
innodb_data_home_dir=
innodb_data_file_path=//./D::10Graw
</pre></li><li class="listitem"><p>
        サーバーを再起動します。これにより、<code class="literal">InnoDB</code> で変更を行うことが許可されます。
      </p></li></ol></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-tables"></a>14.6 InnoDB テーブルの管理</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#using-innodb-tables">14.6.1 InnoDB テーブルの作成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-migration">14.6.2 別のマシンへの InnoDB テーブルの移動またはコピー</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-transactions-with-different-apis">14.6.3 トランザクションを使用した DML 操作のグループ化</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#converting-tables-to-innodb">14.6.4 MyISAM から InnoDB へのテーブルの変換</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-auto-increment-handling">14.6.5 InnoDB での AUTO_INCREMENT 処理</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-foreign-key-constraints">14.6.6 InnoDB と FOREIGN KEY 制約</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-restrictions">14.6.7 InnoDB テーブル上の制限</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="using-innodb-tables"></a>14.6.1 InnoDB テーブルの作成</h3></div></div></div><a class="indexterm" name="idm139979073487312"></a><p>
      <code class="literal">InnoDB</code> テーブルを作成するには、特別な句を付けずに <code class="literal">CREATE TABLE</code> ステートメントを使用します。以前は、<code class="literal">ENGINE=InnoDB</code> 句が必要でしたが、<code class="literal">InnoDB</code> がデフォルトのストレージエンジンとなったため必要なくなりました。(デフォルトのストレージエンジンが <code class="literal">MyISAM</code> である MySQL 5.1 以前が実行されているサーバー上で、<span class="command"><strong>mysqldump</strong></span> またはレプリケーションを使用して <code class="literal">CREATE TABLE</code> ステートメントを再現する予定がある場合は、その句を引き続き使用できます。)
    </p><pre class="programlisting">
-- Default storage engine = InnoDB.
CREATE TABLE t1 (a INT, b CHAR (20), PRIMARY KEY (a));
-- Backward-compatible with older MySQL.
CREATE TABLE t2 (a INT, b CHAR (20), PRIMARY KEY (a)) ENGINE=InnoDB;
</pre><p>
      <code class="literal">innodb_file_per_table</code> の設定に応じて、<code class="literal">InnoDB</code> では<a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">システムテーブルスペース</a>内またはテーブルごとの別個のテーブルスペース (<a class="link" href="glossary.html#glos_ibd_file" title=".ibd ファイル">.ibd ファイル</a>で表されます) 内に、各テーブルおよび関連付けられた主キーインデックスが作成されます。MySQL では、MySQL データベースディレクトリの下にある <code class="filename">test</code> ディレクトリ内に、<code class="filename">t1.frm</code> および <code class="filename">t2.frm</code> ファイルが作成されます。内部的に、<code class="literal">InnoDB</code> 独自のデータディクショナリにテーブルのエントリが追加されます。このエントリには、データベース名が含まれます。たとえば、<code class="literal">t1</code> テーブルが作成されるデータベースが <code class="literal">test</code> である場合、エントリは <code class="literal">'test/t1'</code> となります。つまり、ほかのいくつかのデータベースに同じ名前 <code class="literal">t1</code> のテーブルを作成でき、<code class="literal">InnoDB</code> 内部でテーブル名の競合は発生しません。
    </p><p>
      これらのテーブルのプロパティーを表示するには、<code class="literal">SHOW TABLE STATUS</code> ステートメントを発行します。
    </p><pre class="programlisting">
SHOW TABLE STATUS FROM test LIKE 't%' \G;
</pre><p>
      ステータスの出力には、これらの 1 番目のテーブルの<a class="link" href="glossary.html#glos_row_format" title="行フォーマット">行フォーマット</a>プロパティーが<code class="literal">「Compact」</code>であることが表示されます。この設定は基本的な実験には適していますが、もっとも強力な <code class="literal">InnoDB</code> のパフォーマンス機能を活用するには、すぐに<code class="literal"><a class="link" href="glossary.html#glos_dynamic_row_format" title="動的行フォーマット">「Dynamic」</a></code>や<code class="literal"><a class="link" href="glossary.html#glos_compressed_row_format" title="圧縮行フォーマット">「Compressed」</a></code>などのその他の行フォーマットの使用に進んでください。これらの値を使用するには、最初に少しの設定が必要です。
    </p><pre class="programlisting">
set global innodb_file_per_table=1;
set global innodb_file_format=barracuda;
CREATE TABLE t3 (a INT, b CHAR (20), PRIMARY KEY (a)) row_format=dynamic;
CREATE TABLE t4 (a INT, b CHAR (20), PRIMARY KEY (a)) row_format=compressed;
</pre><p>
      必ず、<code class="literal">InnoDB</code> テーブルごとに<a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a>を設定し、次のようなカラム (複数の場合あり) を指定してください。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          もっとも重要なクエリーで参照される。
        </p></li><li class="listitem"><p>
          ブランクのままになっていない。
        </p></li><li class="listitem"><p>
          重複する値がない。
        </p></li><li class="listitem"><p>
          挿入後に値が変更されるとしても、きわめてまれである。
        </p></li></ul></div><p>
      たとえば、人に関する情報を含むテーブルでは、複数の人が同じ名前を持つ可能性もあり、名字をブランクにしたり、名前を変更したりする人もいるため、<code class="literal">(名、姓)</code> 上には主キーを作成しません。制約が非常に多く、主キーとして使用する明確なカラムセットがないことも多い場合には、主キーの全部または一部として機能する数値 ID の新しいカラムを作成してください。行が挿入されると自動的に昇順の値が入力されるように、<a class="link" href="glossary.html#glos_auto_increment" title="自動インクリメント">自動インクリメント</a>カラムを宣言できます。
    </p><pre class="programlisting">
-- The value of ID can act like a pointer between related items in different tables.
CREATE TABLE t5 (id INT AUTO_INCREMENT, b CHAR (20), PRIMARY KEY (id));
-- The primary key can consist of more than one column. Any autoinc column must come first.
CREATE TABLE t6 (id INT AUTO_INCREMENT, a INT, b CHAR (20), PRIMARY KEY (id,a));
</pre><p>
      主キーを定義しなくてもテーブルは正常に<span class="emphasis"><em>機能</em></span>しますが、主キーは多くのパフォーマンス要素に関連し、大きなテーブルや頻繁に使用されるテーブルにとって重要な設計要素です。常に <code class="literal">CREATE TABLE</code> ステートメントで指定することを習慣にしてください。(テーブルを作成し、データをロードしてから、<code class="literal">ALTER TABLE</code> を実行してあとで主キーを追加する場合の操作は、テーブルの作成時に主キーを定義するよりも大幅に時間がかかります。)
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-migration"></a>14.6.2 別のマシンへの InnoDB テーブルの移動またはコピー</h3></div></div></div><a class="indexterm" name="idm139979073441424"></a><p>
    このセクションでは、一部またはすべての <code class="literal">InnoDB</code> テーブルを別のサーバーに移動またはコピーするための方法について説明します。たとえば、MySQL インスタンス全体をより大規模で高速なサーバーに移動したり、MySQL インスタンス全体のクローンを新しいレプリケーションスレーブサーバーに作成したり、アプリケーションを開発およびテストするために各テーブルを別のサーバーにコピーしたり、レポートを生成するためにデータウェアハウスサーバーにコピーしたりする場合があります。
  </p><p>
    <code class="literal">InnoDB</code> テーブルを移動またはコピーするための方法は、次のとおりです。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <a class="xref" href="innodb-storage-engine.html#copy-tables-transportable-tablespaces" title="トランスポータブルテーブルスペース">Transportable Tablespaces</a>
      </p></li><li class="listitem"><p>
        <a class="xref" href="innodb-storage-engine.html#copy-tables-meb" title="MySQL Enterprise Backup"> MySQL Enterprise Backup</a>
      </p></li><li class="listitem"><p>
        <a class="xref" href="innodb-storage-engine.html#copy-tables-cold-backup" title="データファイルのコピー (コールドバックアップ方式)">Copying Data Files (Cold Backup Method)</a>
      </p></li><li class="listitem"><p>
        <a class="xref" href="innodb-storage-engine.html#copy-tables-export-import" title="エクスポートとインポート (mysqldump)">Export and Import (mysqldump)</a>
      </p></li></ul></div><h4><a name="idm139979073428592"></a>小文字の名前を使用したプラットフォーム間の移動またはコピー</h4><p>
    Windows 上の <code class="literal">InnoDB</code> では常に、データベース名およびテーブル名が内部的に小文字で格納されます。バイナリ形式のデータベースを Unix から Windows に、または Windows から Unix に移動するには、すべてのデータベースおよびテーブルを小文字の名前を使用して作成します。これを実現する便利な方法は、データベースやテーブルを作成する前に、<code class="filename">my.cnf</code> または <code class="filename">my.ini</code> ファイルの <code class="literal">[mysqld]</code> セクションに次の行を追加することです。
  </p><pre class="programlisting">
[mysqld]
lower_case_table_names=1
</pre><h4><a name="copy-tables-transportable-tablespaces"></a>トランスポータブルテーブルスペース</h4><p>
    MySQL 5.6.6 で導入されたトランスポータブルテーブルスペース機能では、あるサーバーインスタンスから別のサーバーインスタンスにコピーするように <code class="literal">InnoDB</code> を準備する際に、<code class="literal">FLUSH TABLES ... FOR EXPORT</code> が使用されます。この機能を使用するには、各 <code class="literal">InnoDB</code> テーブルが独自のテーブルスペースを持つように、<code class="literal">innodb_file_per_table</code> を <code class="literal">ON</code> に設定した状態で <code class="literal">InnoDB</code> テーブルを作成する必要があります。使用法については、<a class="xref" href="innodb-storage-engine.html#tablespace-copying" title="14.5.5 テーブルスペースの別のサーバーへのコピー (トランスポータブルテーブルスペース)">セクション14.5.5「テーブルスペースの別のサーバーへのコピー (トランスポータブルテーブルスペース)」</a>を参照してください。
  </p><h4><a name="copy-tables-meb"></a>MySQL Enterprise Backup</h4><p>
    MySQL Enterprise Backup 製品を使用すると、実行中の MySQL データベース (<code class="literal">InnoDB</code> および <code class="literal">MyISAM</code> テーブルを含む) を、データベースの整合性のあるスナップショットを生成しながら、操作の中断を最小限に抑えてバックアップできます。MySQL Enterprise Backup が <code class="literal">InnoDB</code> テーブルをコピーしている間は、<code class="literal">InnoDB</code> テーブルと <code class="literal">MyISAM</code> テーブルの両方に対する読み取りと書き込みを続行できます。<code class="literal">MyISAM</code> およびその他の InnoDB 以外のテーブルのコピー中は、これらのテーブルに対する (書き込みではなく) 読み取りが許可されます。さらに、MySQL Enterprise Backup では、圧縮バックアップファイルを作成したり、<code class="literal">InnoDB</code> テーブルのサブセットをバックアップしたりすることもできます。MySQL のバイナリログと組み合わせると、ポイントインタイムリカバリを実行できます。MySQL Enterprise Backup は、MySQL Enterprise サブスクリプションの一部として含まれています。
  </p><p>
    MySQL Enterprise Backup についての詳細は、<a class="xref" href="mysql-enterprise.html#mysql-enterprise-backup" title="25.2 MySQL Enterprise Backup">セクション25.2「MySQL Enterprise Backup」</a>を参照してください。
  </p><h4><a name="copy-tables-cold-backup"></a>データファイルのコピー (コールドバックアップ方式)</h4><p>
    単に、<a class="xref" href="innodb-storage-engine.html#innodb-backup" title="14.16 InnoDB のバックアップとリカバリ">セクション14.16「InnoDB のバックアップとリカバリ」</a>の「コールドバックアップ」で一覧表示した関連ファイルをすべてコピーするだけで、<code class="literal">InnoDB</code> データベースを移動できます。
  </p><p>
    <code class="literal">MyISAM</code> データファイルと同様に、<code class="literal">InnoDB</code> のデータファイルとログファイルにも、同じ浮動小数点数形式を持つすべてのプラットフォーム上でのバイナリ互換性があります。浮動小数点形式が異なっている場合でも、テーブル内で <code class="literal">FLOAT</code> または <code class="literal">DOUBLE</code> データ型を使用していなければ、手順は同じです。単に、関連するファイルをコピーするだけです。
  </p><h4><a name="idm139979073397216"></a>.ibd ファイルの移植性に関する考慮事項</h4><p>
    <code class="filename">.ibd</code> ファイルを移動またはコピーする際は、ソースシステムと宛先システムでデータベースディレクトリ名を同じにする必要があります。データベース名は、<code class="literal">InnoDB</code> の共有テーブルスペース内に格納されているテーブル定義に含まれています。テーブルスペースファイル内に格納されているトランザクション ID およびログシーケンス番号も、データベース間で異なります。
  </p><p>
    あるデータベースから別のデータベースに <code class="filename">.ibd</code> ファイルとそれに関連付けられたテーブルを移動するには、<code class="literal">RENAME TABLE</code> ステートメントを使用します。
  </p><pre class="programlisting">
RENAME TABLE <em class="replaceable"><code>db1.tbl_name</code></em> TO <em class="replaceable"><code>db2.tbl_name</code></em>;
</pre><a class="indexterm" name="idm139979073389712"></a><a class="indexterm" name="idm139979073388368"></a><p>
    

    <code class="filename">.ibd</code> ファイルの<span class="quote">「<span class="quote">クリーンな</span>」</span>バックアップがある場合は、次のように、そのバックアップが生成された MySQL インストールにリストアできます。
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
        <code class="filename">.ibd</code> ファイルをコピーすると、テーブルスペース内に格納されたテーブル ID が変更されるため、それ以降はテーブルの削除または切り捨ては実行されなかったはずです。
      </p></li><li class="listitem"><p>
        次の <code class="literal">ALTER TABLE</code> ステートメントを発行して、現在の <code class="filename">.ibd</code> ファイルを削除します。
      </p><pre class="programlisting">
ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> DISCARD TABLESPACE;
</pre></li><li class="listitem"><p>
        バックアップ <code class="filename">.ibd</code> ファイルを適切なデータベースディレクトリにコピーします。
      </p></li><li class="listitem"><p>
        次の <code class="literal">ALTER TABLE</code> ステートメントを発行して、このテーブルで新しい <code class="filename">.ibd</code> ファイルを使用するように <code class="literal">InnoDB</code> に指示します。
      </p><pre class="programlisting">
ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> IMPORT TABLESPACE;
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">ALTER TABLE ... IMPORT TABLESPACE</code> 機能は、インポートされたデータに対して外部キー制約を課しません。
        </p></div></li></ol></div><p>
    このコンテキストでは、<span class="quote">「<span class="quote">クリーンな</span>」</span> <code class="filename">.ibd</code> バックアップファイルとは、次の要件を満たすファイルです。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="filename">.ibd</code> ファイル内には、トランザクションによってコミットされていない変更はありません。
      </p></li><li class="listitem"><p>
        <code class="filename">.ibd</code> ファイル内にマージされていない挿入バッファーエントリはありません。
      </p></li><li class="listitem"><p>
        パージによって、<code class="filename">.ibd</code> ファイルから削除マークが付けられたすべてのインデックスレコードが削除されました。
      </p></li><li class="listitem"><p>
        <span class="command"><strong>mysqld</strong></span> によって、<code class="filename">.ibd</code> ファイルの変更されたページがすべてバッファープールからファイルにフラッシュされました。
      </p></li></ul></div><p>
    次の方法を使用すると、クリーンなバックアップ <code class="filename">.ibd</code> ファイルを作成できます。
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
        <span class="command"><strong>mysqld</strong></span> サーバーからのすべてのアクティビティーを停止し、すべてのトランザクションをコミットします。
      </p></li><li class="listitem"><p>
        <code class="literal">SHOW ENGINE INNODB STATUS</code> でデータベース内にアクティブなトランザクションがないことが表示され、<code class="literal">InnoDB</code> のメインスレッドステータスが<code class="literal">「Waiting for server activity」</code>になるまで待機します。これにより、<code class="filename">.ibd</code> ファイルのコピーを作成できるようになります。
      </p></li></ol></div><p>
    <code class="filename">.ibd</code> ファイルのクリーンなコピーを作成するためのもう 1 つの方法は、MySQL Enterprise Backup 製品を使用することです。
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
        MySQL Enterprise Backup を使用して、<code class="literal">InnoDB</code> インストールをバックアップします。
      </p></li><li class="listitem"><p>
        2 番目の <span class="command"><strong>mysqld</strong></span> サーバーをバックアップ上で起動します。そのサーバーで、バックアップ内の <code class="filename">.ibd</code> ファイルがクリーンアップされます。
      </p></li></ol></div><h4><a name="copy-tables-export-import"></a>エクスポートとインポート (mysqldump)</h4><p>
    <span class="command"><strong>mysqldump</strong></span> を使用すると、あるマシン上でテーブルをダンプしてから、別のマシン上でそのダンプファイルをインポートできます。この方式を使用すれば、形式が異なっているかどうかや、テーブルに浮動小数点データが含まれているかどうかは関係ありません。
  </p><p>
    インポートトランザクションで生成される巨大なロールバックセグメント用の領域がテーブルスペースに十分にあると仮定すれば、この方式のパフォーマンスを向上させる方法の 1 つは、データのインポート時に<a class="link" href="glossary.html#glos_autocommit" title="自動コミット">自動コミット</a>モードをオフにすることです。コミットは、テーブル全体またはテーブルのセグメントをインポートしたあとでのみ行なってください。
  </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-transactions-with-different-apis"></a>14.6.3 トランザクションを使用した DML 操作のグループ化</h3></div></div></div><a class="indexterm" name="idm139979073337776"></a><p>
      デフォルトでは、MySQL サーバーへの接続は、<a class="link" href="glossary.html#glos_autocommit" title="自動コミット">自動コミット</a>モードが有効になっている状態で開始されるため、SQL ステートメントは実行するたびに自動的にコミットされます。一連の <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> ステートメントを発行し、すべてまとめてコミットまたはロールバックすることが標準操作となっているほかのデータベースシステムの使用経験がある場合は、この操作モードに馴染みがないかもしれません。
    </p><p>
      複数ステートメントの<a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a>を使用するには、SQL ステートメント <code class="literal">SET autocommit = 0</code> を使用して自動コミットをオフにして、必要に応じて <code class="literal">COMMIT</code> または <code class="literal">ROLLBACK</code> を使用して各トランザクションを終了します。自動コミットをオンのままにするには、<code class="literal">START TRANSACTION</code> を使用して各トランザクションを開始し、<code class="literal">COMMIT</code> または <code class="literal">ROLLBACK</code> を使用して終了します。次の例は 2 つのトランザクションを表しています。1 番目はコミットされ、2 番目はロールバックされています。
    </p><pre class="programlisting">
shell&gt; <strong class="userinput"><code>mysql test</code></strong>

mysql&gt; <strong class="userinput"><code>CREATE TABLE customer (a INT, b CHAR (20), INDEX (a));</code></strong>
Query OK, 0 rows affected (0.00 sec)
mysql&gt; <strong class="userinput"><code>-- Do a transaction with autocommit turned on.</code></strong>
mysql&gt; <strong class="userinput"><code>START TRANSACTION;</code></strong>
Query OK, 0 rows affected (0.00 sec)
mysql&gt; <strong class="userinput"><code>INSERT INTO customer VALUES (10, 'Heikki');</code></strong>
Query OK, 1 row affected (0.00 sec)
mysql&gt; <strong class="userinput"><code>COMMIT;</code></strong>
Query OK, 0 rows affected (0.00 sec)
mysql&gt; <strong class="userinput"><code>-- Do another transaction with autocommit turned off.</code></strong>
mysql&gt; <strong class="userinput"><code>SET autocommit=0;</code></strong>
Query OK, 0 rows affected (0.00 sec)
mysql&gt; <strong class="userinput"><code>INSERT INTO customer VALUES (15, 'John');</code></strong>
Query OK, 1 row affected (0.00 sec)
mysql&gt; <strong class="userinput"><code>INSERT INTO customer VALUES (20, 'Paul');</code></strong>
Query OK, 1 row affected (0.00 sec)
mysql&gt; <strong class="userinput"><code>DELETE FROM customer WHERE b = 'Heikki';</code></strong>
Query OK, 1 row affected (0.00 sec)
mysql&gt; <strong class="userinput"><code>-- Now we undo those last 2 inserts and the delete.</code></strong>
mysql&gt; <strong class="userinput"><code>ROLLBACK;</code></strong>
Query OK, 0 rows affected (0.00 sec)
mysql&gt; <strong class="userinput"><code>SELECT * FROM customer;</code></strong>
+------+--------+
| a    | b      |
+------+--------+
|   10 | Heikki |
+------+--------+
1 row in set (0.00 sec)
mysql&gt;
</pre><h4><a name="idm139979073312208"></a>クライアント側言語でのトランザクション</h4><p>
      PHP、Perl DBI、JDBC、ODBC などの API または MySQL の標準 C 呼び出しインタフェースでは、<code class="literal">COMMIT</code> などのトランザクション制御ステートメントを <code class="literal">SELECT</code> や <code class="literal">INSERT</code> などのその他の SQL ステートメントと同様の文字列として、MySQL サーバーに送信できます。一部の API では、別個の特別なトランザクションコミットおよびロールバックの関数やメソッドも提供されています。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="converting-tables-to-innodb"></a>14.6.4 MyISAM から InnoDB へのテーブルの変換</h3></div></div></div><a class="indexterm" name="idm139979073305856"></a><a class="indexterm" name="idm139979073302944"></a><p>
    信頼性および拡張性を改善するために、既存のテーブルを使用するアプリケーションを <code class="literal">InnoDB</code> に変換する場合は、次のガイドラインおよびヒントを使用します。このセクションでは、このようなテーブルの大部分が当初は、以前のデフォルトの <code class="literal">MyISAM</code> であったことが前提となっています。
  </p><h4><a name="innodb-convert-memory-usage"></a>MyISAM のメモリー使用量の減少、InnoDB のメモリー使用量の増加</h4><p>
    <code class="literal">MyISAM</code> テーブルから移行するときに、結果をキャッシュする際に必要でなくなったメモリーが解放されるように、<code class="literal">key_buffer_size</code> 構成オプションの値を小さくします。<code class="literal">InnoDB</code> テーブル用のキャッシュメモリー割り当てと同様の役割を担う <code class="literal">innodb_buffer_pool_size</code> 構成オプションの値を大きくします。<code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>には、テーブルデータとインデックスデータの両方がキャッシュされるため、クエリーの検索速度を上げることと、再使用するためにクエリー結果をメモリー内に保持することの 2 つ役割があります。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        このオプションには、できるかぎり多くのメモリー (多くの場合、最大でサーバー上の物理メモリーの 80% まで) を割り当てます。
      </p></li><li class="listitem"><p>
        オペレーティングシステムでその他のプロセス用のメモリーが不足し、スワップが発生し始めた場合は、<code class="literal">innodb_buffer_pool_size</code> の値を小さくします。スワップとは、キャッシュメモリーの利点が大幅に減少するような負荷の高い操作です。
      </p></li><li class="listitem"><p>
        <code class="literal">innodb_buffer_pool_size</code> 値が数ギガバイト以上である場合は、<code class="literal">innodb_buffer_pool_instances</code> の値を大きくすることを検討してください。これを行うと、同時に数多くの接続がキャッシュにデータを読み込む高負荷のサーバーで役立ちます。
      </p></li><li class="listitem"><p>
        高負荷のサーバーでは、クエリーキャッシュをオフにしてベンチマークを実行します。<code class="literal">InnoDB</code> のバッファープールでも同様の利点が得られるため、クエリーキャッシュを使用すると、不必要にメモリーが停止する可能性があります。
      </p></li></ul></div><h4><a name="innodb-convert-transactions"></a>長すぎるまたは短すぎるトランザクションの監視</h4><p>
    <code class="literal">MyISAM</code> テーブルでは<a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a>がサポートされていないため、<code class="literal">autocommit</code> 構成オプションと、<code class="literal">COMMIT</code> および <code class="literal">ROLLBACK</code> ステートメントに多くの注意が払われていない可能性があります。これらのキーワードは、複数のセッションが並列して <code class="literal">InnoDB</code> テーブルの読み取りおよび書き込みを行うことを許可する際に重要となります。これにより、書き込み負荷の高いワークロードで十分な拡張性の利点が得られます。
  </p><p>
    トランザクションが開いている間は、トランザクションの開始時に見られるようなデータのスナップショットがシステムで保持されます。これにより、未処理のトランザクションが動作し続けている間に、システムで数百万行の挿入、更新、および削除が行われると、相当なオーバーヘッドが発生する可能性があります。そのため、動作時間が長すぎるトランザクションは回避するように注意してください。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        インタラクティブな実験で <span class="command"><strong>mysql</strong></span> セッションを使用している場合は、完了後に必ず、(変更を完了させる場合は) <code class="literal">COMMIT</code>、または (変更を取り消す場合は) <code class="literal">ROLLBACK</code> を実行します。誤ってトランザクションが長時間開いたままになることを回避するには、インタラクティブなセッションを長時間開いたままにせず、閉じてください。
      </p></li><li class="listitem"><p>
        アプリケーション内の任意のエラーハンドラでも、不完全な変更の <code class="literal">ROLLBACK</code> が実行されるか、完了した変更の <code class="literal">COMMIT</code> が実行されることを確認します。
      </p></li><li class="listitem"><p>
        <code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、および <code class="literal">DELETE</code> 操作は、ほとんどの変更は正常にコミットされ、ロールバックはまれにしか発生しないという見込みで、<code class="literal">COMMIT</code> よりも前に <code class="literal">InnoDB</code> テーブルに書き込まれるため、<code class="literal">ROLLBACK</code> は比較的負荷の高い操作です。大量のデータを使用して実験する際は、多数の行に変更を加えてから、それらの変更をロールバックすることは回避してください。
      </p></li><li class="listitem"><p>
        一連の <code class="literal">INSERT</code> ステートメントを使用して大量のデータをロードする際は、トランザクションが数時間存続することを回避するために、定期的に結果の <code class="literal">COMMIT</code> を実行します。データウェアハウスでの一般的なロード操作では、何か問題が発生した場合に、ユーザーは <code class="literal">ROLLBACK</code> を行うのではなく、<code class="literal">TRUNCATE TABLE</code> を実行し、最初からやり直します。
      </p></li></ul></div><p>
    前述のヒントを使用すると、長すぎるトランザクション中に無駄になる可能性のあるメモリーおよびディスク容量を節約できます。トランザクションが本来よりも短い場合は、過剰な I/O が問題となります。MySQL では、<code class="literal">COMMIT</code> が実行されるたびに、各変更が安全にディスクに記録されていることが確認されます。これには、多少の I/O が伴います。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="literal">InnoDB</code> テーブル上のほとんどの操作では、<code class="literal">autocommit=0</code> の設定を使用するようにしてください。効率性の観点から見ると、これにより、多数の連続した <code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、または <code class="literal">DELETE</code> ステートメントを発行したときの不要な I/O が回避されます。安全性の観点から見ると、これにより、<span class="command"><strong>mysql</strong></span> コマンド行またはアプリケーションの例外ハンドラに誤りがあった場合に、<code class="literal">ROLLBACK</code> ステートメントを発行することで、失ったデータや文字化けしたデータをリカバリできます。
      </p></li><li class="listitem"><p>
        <code class="literal">InnoDB</code> テーブルに <code class="literal">autocommit=1</code> を設定することが適している状況は、レポートの生成または統計の分析を行うために一連のクエリーを実行するときです。このような状況では、<code class="literal">COMMIT</code> または <code class="literal">ROLLBACK</code> に関連する I/O ペナルティーが発生せず、<code class="literal">InnoDB</code> は<a class="link" href="innodb-storage-engine.html#innodb-performance-ro-txn" title="14.13.14 InnoDB の読み取り専用トランザクションの最適化">自動的に読み取り専用のワークロードを最適化できます</a>。
      </p></li><li class="listitem"><p>
        関連する一連の変更を行う場合は、最後に 1 回 <code class="literal">COMMIT</code> を実行して、これらのすべての変更を一度に完了させます。たとえば、情報の関連部分を複数のテーブルに挿入する場合は、すべての変更を行なったあとに、<code class="literal">COMMIT</code> を 1 回実行します。また、連続する多数の <code class="literal">INSERT</code> ステートメントを実行する場合は、すべてのデータがロードされたあとに、<code class="literal">COMMIT</code> を 1 回実行します。何百万もの <code class="literal">INSERT</code> ステートメントを実行する場合は、一万または一千レコードごとに <code class="literal">COMMIT</code> を発行することで、巨大なトランザクションを分割することがあります。
      </p></li><li class="listitem"><p>
        <code class="literal">SELECT</code> ステートメントでもトランザクションが開かれるため、インタラクティブな <span class="command"><strong>mysql</strong></span> セッションで一部のレポートを実行したり、クエリーをデバッグしたりしたあとは、<code class="literal">COMMIT</code> を発行するか、または <span class="command"><strong>mysql</strong></span> セッションを閉じます。
      </p></li></ul></div><h4><a name="innodb-convert-deadlock"></a>デッドロックを心配しすぎないこと</h4><p>
    MySQL のエラーログまたは <code class="literal">SHOW ENGINE INNODB STATUS</code> の出力に、<span class="quote">「<span class="quote">デッドロック</span>」</span>に言及する警告メッセージが表示されることがあります。<a class="link" href="glossary.html#glos_deadlock" title="デッドロック">デッドロック</a>は、恐ろしい響きの名前にもかかわらず、<code class="literal">InnoDB</code> テーブルにとっては重大な問題でなく、修正アクションは何も必要ありません。2 つのトランザクションが複数のテーブルを変更し、そのテーブルに別々の順序でアクセスし始めると、各トランザクションが相互に待機し合って、どちらも処理できない状態に達する可能性があります。すぐに MySQL によって、この状況が検出され、<span class="quote">「<span class="quote">小さい方の</span>」</span>トランザクションが取り消され (<a class="link" href="glossary.html#glos_rollback" title="ロールバック">ロールバック</a>され)、他方が処理できるようになります。
  </p><p>
    アプリケーションには、このように強制的に取り消されたトランザクションを再開するためのエラー処理ロジックが必要です。以前と同じ SQL ステートメントを再発行するときは、元のタイミングの問題は適用されません。他方のトランザクションがすでに完了したため一方を処理できるか、他方のトランザクションがまだ処理中で、これが完了するまで一方が待機しているかのいずれかです。
  </p><p>
    デッドロックの警告が常に発生する場合は、アプリケーションコードを再確認して、一貫性のある方法で SQL 操作を再指示したり、トランザクションを短くしたりすることがあります。<code class="literal">innodb_print_all_deadlocks</code> オプションを有効にしてテストすれば、<code class="literal">SHOW ENGINE INNODB STATUS</code> 出力の最後の警告だけでなく、MySQL のエラーログにもすべてのデッドロックの警告を表示できます。
  </p><h4><a name="innodb-convert-plan-storage"></a>ストレージレイアウトの計画</h4><p>
    <code class="literal">InnoDB</code> テーブルから最高のパフォーマンスを引き出すために、ストレージレイアウトに関連する数多くのパラメータを調整できます。
  </p><p>
    頻繁にアクセスされ、重要なデータが保持されている大きな <code class="literal">MyISAM</code> テーブルを変換する際は、<code class="literal">innodb_file_per_table</code>、<code class="literal">innodb_file_format</code>、<code class="literal">innodb_page_size</code> 構成オプション、および <code class="literal">CREATE TABLE</code> ステートメントの <a class="link" href="innodb-storage-engine.html#innodb-row-format" title="14.9 InnoDB の行ストレージと行フォーマット"><code class="literal">ROW_FORMAT</code> と <code class="literal">KEY_BLOCK_SIZE</code> 句</a>を調査および検討してください。
  </p><p>
    初期の実験時に、もっとも重要となる設定は <code class="literal">innodb_file_per_table</code> です。新しい <code class="literal">InnoDB</code> テーブルを作成する前に、このオプションを有効にすると、<code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">システムテーブルスペース</a>ファイルを使用して、すべての <code class="literal">InnoDB</code> データ用のディスク領域が永続的に割り当てられなくなります。<code class="literal">innodb_file_per_table</code> を有効にすると、<code class="literal">DROP TABLE</code> および <code class="literal">TRUNCATE TABLE</code> を発行することで、要求どおりにディスク領域が解放されます。
  </p><h4><a name="innodb-convert-convert"></a>既存テーブルの変換</h4><p>
    <code class="literal">InnoDB</code> を使用するように <code class="literal">InnoDB</code> 以外のテーブルを変換するには、<code class="literal">ALTER TABLE</code> を使用します。
  </p><pre class="programlisting">
ALTER TABLE <em class="replaceable"><code>table_name</code></em> ENGINE=InnoDB;
</pre><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
      <code class="literal">mysql</code> データベース内の MySQL システムテーブル (<code class="literal">user</code> や <code class="literal">host</code> など) を <code class="literal">InnoDB</code> 型に変換しないでください。これはサポートされていない操作です。システムテーブルの型は、必ず <code class="literal">MyISAM</code> にする必要があります。
    </p></div><h4><a name="innodb-convert-clone"></a>テーブル構造のクローニング</h4><p>
    古いテーブルと新しいテーブルを切り替える前に並列してテストする際に、<code class="literal">ALTER TABLE</code> 変換を行うのではなく、MyISAM テーブルのクローンである InnoDB テーブルを作成することがあります。
  </p><p>
    同じカラムとインデックスの定義を持つ空の <code class="literal">InnoDB</code> テーブルを作成します。<code class="literal">show create table <em class="replaceable"><code>table_name</code></em>\G</code> を使用して、使用される完全な <code class="literal">CREATE TABLE</code> ステートメントを表示します。<code class="literal">ENGINE</code> 句を <code class="literal">ENGINE=INNODB</code> に変更します。
  </p><h4><a name="innodb-convert-transfer"></a>既存データの転送</h4><p>
    前のセクションで示したように、作成された空の <code class="literal">InnoDB</code> テーブルに大量のデータを転送するには、<code class="literal">INSERT INTO <em class="replaceable"><code>innodb_table</code></em> SELECT * FROM <em class="replaceable"><code>myisam_table</code></em> ORDER BY <em class="replaceable"><code>primary_key_columns</code></em></code> を使用して行を挿入します。
  </p><p>
    データを挿入したあとに、<code class="literal">InnoDB</code> テーブル用のインデックスを作成することもできます。従来、新しいセカンダリインデックスを作成することは、InnoDB にとって低速な操作でしたが、現在は、インデックスの作成ステップで比較的小さいオーバーヘッドでデータがロードされたあとに、インデックスを作成できるようになりました。
  </p><p>
    副キー上に <code class="literal">UNIQUE</code> 制約がある場合は、インポート操作中に一意性チェックを一時的にオフにすることで、テーブルインポートの速度を上げることができます。
  </p><pre class="programlisting">
SET unique_checks=0;
<em class="replaceable"><code>... import operation ...</code></em>
SET unique_checks=1;
</pre><p>
    大きいテーブルの場合、<code class="literal">InnoDB</code> はその<a class="link" href="glossary.html#glos_insert_buffer" title="挿入バッファー">挿入バッファー</a>を使用して、一括してセカンダリインデックスレコードを書き込むことができるため、これにより、大量のディスク I/O が節約されます。データに重複キーが含まれないようにします。<code class="literal">unique_checks</code> では、ストレージエンジンが重複キーを無視することが許可されていますが、必須ではありません。
  </p><p>
    挿入プロセスをより適切に制御するために、大きなテーブルを分割して挿入することがあります。
  </p><pre class="programlisting">
INSERT INTO newtable SELECT * FROM oldtable
   WHERE yourkey &gt; <em class="replaceable"><code>something</code></em> AND yourkey &lt;= <em class="replaceable"><code>somethingelse</code></em>;
</pre><p>
    すべてのレコードが挿入されたあとに、テーブルの名前を変更できます。
  </p><p>
    ディスク I/O を削減するには、大きなテーブルの変換時に、最大で物理メモリーの 80% まで <code class="literal">InnoDB</code> バッファープールのサイズを大きくします。<code class="literal">InnoDB</code> ログファイルのサイズを大きくすることもできます。
  </p><h4><a name="innodb-convert-plan-storage-2"></a>ストレージ要件</h4><p>
    すでに説明したように、この時点で、すでに <code class="literal">innodb_file_per_table</code> オプションが有効になっている必要があります。これにより、<code class="literal">InnoDB</code> テーブル内にデータの複数のコピーを一時的に作成している場合は、あとで不要なテーブルを削除することで、そのディスク領域をすべてリカバリできます。
  </p><p>
    <code class="literal">MyISAM</code> テーブルを直接変換するのか、クローンの <code class="literal">InnoDB</code> テーブルを作成するのかには関係なく、プロセス中に古いテーブルと新しいテーブルの両方を保持するのに十分なディスク領域があることを確認します。<code class="literal">InnoDB</code> テーブルには、<code class="literal">MyISAM</code> テーブルよりも多くのディスク領域が必要です。<code class="literal">ALTER TABLE</code> 操作によって領域が使い果たされると、ロールバックが開始されますが、ディスクバウンドの場合は、数時間かかる可能性があります。挿入の場合、<code class="literal">InnoDB</code> はバッチ内のインデックスにセカンダリインデックスレコードをマージする際に、挿入バッファーを使用します。これにより、大量のディスク I/O が節約されます。ロールバックでは、このようなメカニズムは使用されません。ロールバックは挿入よりも、30 倍長い時間がかかる可能性があります。
  </p><p>
    ランナウェイロールバックの場合は、データベースに貴重なデータがなければ、何百万ものディスク I/O 操作が完了するまで待機するのではなく、データベースプロセスを強制終了することをお勧めします。完全な手順については、<a class="xref" href="innodb-storage-engine.html#forcing-innodb-recovery" title="14.19.2 InnoDB のリカバリの強制的な実行">セクション14.19.2「InnoDB のリカバリの強制的な実行」</a>を参照してください。
  </p><h4><a name="innodb-convert-primary-key"></a>テーブルごとの主キーの慎重な選択</h4><p>
    <code class="literal">PRIMARY KEY</code> 句は、MySQL クエリーのパフォーマンスや、テーブルおよびインデックス用の領域使用量に影響を与える重要な要素です。おそらく、金融機関に電話をかけ、口座番号を求められた経験があるでしょう。その番号を持っていない場合は、自分自身を<span class="quote">「<span class="quote">一意に識別する</span>」</span>ために、多種多様な情報が求められます。主キーは、テーブル内の情報を問い合わせたり、変更したりする際に、すぐに仕事に取りかかるための一意の口座番号のようなものです。テーブル内のすべて行が主キー値を持っている必要があり、2 つの行が同じ主キー値を持つことはできません。
  </p><p>
    次に、主キーに関するいくつかのガイドラインに続き、さらに詳細な説明を示します。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        テーブルごとに <code class="literal">PRIMARY KEY</code> を宣言します。一般に、単一の行を検索するときに参照される <code class="literal">WHERE</code> 句内のカラムの中で、もっとも重要なものです。
      </p></li><li class="listitem"><p>
        あとで <code class="literal">ALTER TABLE</code> ステートメントを使用して追加するのではなく、元の <code class="literal">CREATE TABLE</code> ステートメントで <code class="literal">PRIMARY KEY</code> 句を宣言します。
      </p></li><li class="listitem"><p>
        カラムとそのデータ型は慎重に選択してください。文字または文字列のカラムよりも、数値のカラムを優先してください。
      </p></li><li class="listitem"><p>
        別の安定していて、一意で、非 NULL で、数値のカラムが使用できない場合は、自動インクリメントカラムを使用することを検討してください。
      </p></li><li class="listitem"><p>
        主キーカラムの値が変更されたかどうかが疑わしい場合にも、自動インクリメントは適切な選択です。主キーカラムの値を変更することは、負荷の高い操作であり、テーブル内および各セカンダリインデックス内でデータの再編成が伴う可能性があります。
      </p></li></ul></div><p>
    <a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a>がまだ存在しないテーブルには、追加することを検討してください。計画されたテーブルの最大サイズに基づいて、現実的な最小の数値型を使用します。これにより、各行をわずかにコンパクトにすることができ、大きなテーブル用に相当な領域を節約できます。主キー値は、セカンダリインデックスが入力されるたびに繰り返されるため、テーブルが任意の<a class="link" href="glossary.html#glos_secondary_index" title="セカンダリインデックス">セカンダリインデックス</a>を持っている場合は、領域の節約も倍増します。小さな主キーを使用すると、ディスク上のデータサイズが削減されることに加えて、より多くのデータを<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>内に収容できるため、すべての種類の操作の速度が上がり、並列性が改善されます。
  </p><p>
    すでにテーブルの多少長いカラム (<code class="literal">VARCHAR</code> など) 上に主キーが存在する場合は、そのカラムがクエリーで参照されていなくても、新しい符号なし <code class="literal">AUTO_INCREMENT</code> カラムを追加し、主キーをそのカラムに切り替えることを検討してください。このような設計の変更によって、セカンダリインデックス内の相当な領域を節約できます。以前の主キーカラムを <code class="literal">UNIQUE NOT NULL</code> として指定すると、<code class="literal">PRIMARY KEY</code> 句と同じ制約を強制的に適用できます (つまり、これらのすべてのカラムにわたって重複する値や NULL 値を回避できます)。
  </p><p>
    関連する情報を複数のテーブルに分散させる場合は、一般に各テーブルで、その主キー用に同じカラムが使用されます。たとえば、人事部のデータベースには複数のテーブルが含まれ、各テーブルには従業員番号の主キーが含まれている場合があります。営業部のデータベースには、顧客番号の主キーを含むテーブルや、注文番号の主キーを含むテーブルが含まれている場合があります。主キーを使用した検索は非常に高速であるため、このようなテーブルには効率的な結合クエリーを構築できます。
  </p><p>
    <code class="literal">PRIMARY KEY</code> 句を完全に削除すると、MySQL によって自動的に非表示の主キーが作成されます。これは、必要以上に長くなる可能性のある 6 バイトの値であるため、領域が無駄になります。これは非表示であるため、クエリーで参照できません。
  </p><h4><a name="innodb-convert-application-performance"></a>アプリケーションのパフォーマンスに関する考慮事項</h4><p>
    <code class="literal">InnoDB</code> の追加の信頼性および拡張性機能を使用するには、同等の <code class="literal">MyISAM</code> テーブルよりも多くのディスクストレージが必要となります。領域の使用率を改善し、結果セットを処理する際の I/O およびメモリーの消費を削減し、インデックス検索を効率的に使用するクエリーの最適化計画を改善するために、カラムおよびインデックスの定義をわずかに変更することがあります。
  </p><p>
    主キーに数値の ID カラムを設定する場合 (特に、<a class="link" href="glossary.html#glos_join" title="結合">結合</a>クエリーの場合) は、その値を使用して、その他の任意のテーブル内の関連する値と相互参照します。たとえば、入力として国名を受け入れ、同じ名前を検索するクエリーを実行するのではなく、国 ID を確認するための検索を 1 回実行してから、複数のテーブルにわたって関連情報を検索するための別のクエリー (または 1 回の結合クエリー) を実行します。顧客番号またはカタログ項目番号を数字の文字列として格納すると、数バイトを使い果たす可能性があるため、その代わりに、格納およびクエリー用に数値の ID に変換します。4 バイトの符号なし <code class="literal">INT</code> カラムでは、40 億を超える項目 (アメリカ合衆国での billion の意味: 10 億) にインデックスを付けることができます。さまざまな整数型の範囲については、<a class="xref" href="data-types.html#integer-types" title="11.2.1 整数型 (真数値) - INTEGER、INT、SMALLINT、TINYINT、MEDIUMINT、BIGINT">セクション11.2.1「整数型 (真数値) - INTEGER、INT、SMALLINT、TINYINT、MEDIUMINT、BIGINT」</a>を参照してください。
  </p><h4><a name="innodb-convert-understand-files"></a>InnoDB テーブルに関連付けられたファイルの理解</h4><p>
    <code class="literal">InnoDB</code> ファイルを使用する際は、<code class="literal">MyISAM</code> ファイルよりも多くの注意および計画が必要となります。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">システムテーブルスペース</a>を表す <a class="link" href="glossary.html#glos_ibdata_file" title="ibdata ファイル">ibdata ファイル</a>は削除しないでください。
      </p></li><li class="listitem"><p>
        あるサーバーから別のサーバーに InnoDB テーブルをコピーするには、まず <code class="literal">FLUSH TABLES ... FOR EXPORT</code> ステートメントを発行してから、<code class="literal"><em class="replaceable"><code>table_name</code></em>.ibd</code> ファイルとともに <code class="literal"><em class="replaceable"><code>table_name</code></em>.cfg</code> ファイルをコピーする必要があります。
      </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-auto-increment-handling"></a>14.6.5 InnoDB での AUTO_INCREMENT 処理</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-auto-increment-traditional">14.6.5.1 従来の InnoDB の自動インクリメントロック</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-auto-increment-configurable">14.6.5.2 構成可能な InnoDB の自動インクリメントロック</a></span></dt></dl></div><a class="indexterm" name="idm139979073092720"></a><p>
      <code class="literal">InnoDB</code> では、<code class="literal">AUTO_INCREMENT</code> カラムを含むテーブルに行を挿入する SQL ステートメントの拡張性およびパフォーマンスが大幅に改善される最適化が提供されています。<code class="literal">InnoDB</code> テーブルで <code class="literal">AUTO_INCREMENT</code> メカニズムを使用するには、テーブルで最大カラム値を取得するインデックス <code class="literal">SELECT MAX(<em class="replaceable"><code>ai_col</code></em>)</code> ルックアップと同等の操作を実行できるように、<code class="literal">AUTO_INCREMENT</code> カラム <em class="replaceable"><code>ai_col</code></em> をインデックスの一部として定義する必要があります。一般に、これはカラムをどこかのテーブルインデックスの 1 番目のカラムにすることで実現されます。
    </p><p>
      このセクションでは、<code class="literal">InnoDB</code> の自動インクリメントロックの元の (<span class="quote">「<span class="quote">従来の</span>」</span>) 実装に関する背景情報を提供し、構成可能なロックメカニズムについて説明し、このメカニズムを構成するためのパラメータを示し、その動作やレプリケーションとの相互作用について説明します。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-auto-increment-traditional"></a>14.6.5.1 従来の InnoDB の自動インクリメントロック</h4></div></div></div><p>
        <code class="literal">InnoDB</code> の自動インクリメント処理の元の実装では、ステートメントベースレプリケーションや特定のリカバリシナリオでバイナリログを使用すると発生する問題を回避するために、次のような方針が使用されています。
      </p><p>
        <code class="literal">InnoDB</code> テーブルに <code class="literal">AUTO_INCREMENT</code> カラムを指定すると、<code class="literal">InnoDB</code> データディクショナリ内のテーブルハンドルに、カラムに新しい値を割り当てる際に使用される自動インクリメントカウンタと呼ばれる特別なカウンタが含まれます。このカウンタは、ディスク上には格納されず、メインメモリー内にのみ格納されます。
      </p><p>
        <code class="literal">InnoDB</code> では、<code class="literal">ai_col</code> という名前の <code class="literal">AUTO_INCREMENT</code> カラムを含むテーブル <code class="literal">t</code> に自動インクリメントカウンタを初期化するために、次のようなアルゴリズムが使用されます。サーバーの起動のあとで、テーブル <code class="literal">t</code> への最初の挿入をするために、<code class="literal">InnoDB</code> は次のステートメントと同等なものを実行します。
      </p><pre class="programlisting">
SELECT MAX(ai_col) FROM t FOR UPDATE;
</pre><p>
        <code class="literal">InnoDB</code> は、ステートメントで取得された値を増分し、それをテーブルのカラムおよび自動インクリメントカウンタに割り当てます。デフォルトでは、値が 1 ずつ増分されます。このデフォルトは、<code class="literal">auto_increment_increment</code> 構成の設定でオーバーライドできます。
      </p><p>
        テーブルが空の場合、<code class="literal">InnoDB</code> では値 <code class="literal">1</code> が使用されます。このデフォルトは、<code class="literal">auto_increment_offset</code> 構成の設定でオーバーライドできます。
      </p><p>
        自動インクリメントカウンタが初期化される前に、<code class="literal">SHOW TABLE STATUS</code> ステートメントで <code class="literal">t</code> テーブルが調査される場合は、<code class="literal">InnoDB</code> によって値は初期化されますが、増分されず、後続の挿入で使用するために格納されます。この初期化では、テーブル上で通常の排他ロック読み取りが使用され、そのロックはトランザクションの最後まで存続します。
      </p><p>
        <code class="literal">InnoDB</code> は、新たに作成されたテーブル用に自動インクリメントカウンタを初期化するときと同じ手順に従います。
      </p><p>
        自動インクリメントカウンタが初期化されたあとに、<code class="literal">AUTO_INCREMENT</code> カラムの値を明示的に指定しない場合は、<code class="literal">InnoDB</code> によってカウンタが増分され、新しい値がカラムに割り当てられます。カラム値を明示的に指定する行を挿入するときに、その値が現在のカウンタ値よりも大きい場合は、カウンタが指定されたカラム値に設定されます。
      </p><p>
        ユーザーが <code class="literal">INSERT</code> で <code class="literal">AUTO_INCREMENT</code> カラムに <code class="literal">NULL</code> または <code class="literal">0</code> を指定すると、<code class="literal">InnoDB</code> では、値が指定されなかった場合と同様にその行が処理され、新しい値が生成されます。
      </p><p>
        カラムに負の値を割り当てる場合や、値が指定された整数型に格納できる最大整数よりも大きくなる場合は、自動インクリメントメカニズムの動作が定義されません。
      </p><p>
        自動インクリメントカウンタにアクセスするときに、<code class="literal">InnoDB</code> では、トランザクションの最後までではなく、現在の SQL ステートメントの最後まで存続する特別なテーブルレベルの <code class="literal">AUTO-INC</code> ロックが使用されます。<code class="literal">AUTO_INCREMENT</code> カラムを含むテーブルへの挿入の並列性を改善するために、特別なロック解放方針が導入されました。それにもかかわらず、2 つのトランザクションが同時に <code class="literal">AUTO-INC</code> ロックを同じテーブル上で持つことはできません。これにより、<code class="literal">AUTO-INC</code> ロックが長時間保持されると、パフォーマンスが影響を受ける可能性があります。これは、あるテーブルから別のテーブルにすべての行を挿入する <code class="literal">INSERT INTO t1 ... SELECT ... FROM t2</code> などのステートメントの場合に発生する可能性があります。
      </p><p>
        <code class="literal">InnoDB</code> では、サーバーが実行されていれば、インメモリーの自動インクリメントカウンタが使用されます。前に説明したように、サーバーが停止して再起動されると、テーブルへの最初の <code class="literal">INSERT</code> 時に、<code class="literal">InnoDB</code> によってテーブルごとにカウンタが再初期化されます。
      </p><p>
        サーバーが再起動されると、<code class="literal">CREATE TABLE</code> および <code class="literal">ALTER TABLE</code> ステートメントの <code class="literal">AUTO_INCREMENT = <em class="replaceable"><code>N</code></em></code> テーブルオプションの効果も取り消されます。このオプションを <code class="literal">InnoDB</code> テーブルで使用すると、初期のカウンタの値を設定したり、現在のカウンタ値を変更したりできます。
      </p><p>
        カウンタを使用して数値が生成されたトランザクションをロールバックすると、<code class="literal">AUTO_INCREMENT</code> カラムに割り当てられた一連の値でギャップが見つかることがあります。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-auto-increment-configurable"></a>14.6.5.2 構成可能な InnoDB の自動インクリメントロック</h4></div></div></div><p>
        前のセクションで説明したように、<code class="literal">InnoDB</code> では <code class="literal">AUTO_INCREMENT</code> カラムを含むテーブルへの挿入を行う際に、<code class="literal">AUTO-INC</code> ロックと呼ばれる特殊なテーブルレベルロックが使用されます。このロックは通常、指定された一連の <code class="literal">INSERT</code> ステートメントに予測可能かつ繰り返し可能な順序で自動インクリメント番号が割り当てられるように、(トランザクションが終了するまでではなく) ステートメントが終了するまで保持されます。
      </p><p>
        ステートメントベースのレプリケーションの場合、これは、ある SQL ステートメントがスレーブサーバーで複製される際に、自動インクリメントカラムでマスターサーバーと同じ値が使用されることを意味します。複数の <code class="literal">INSERT</code> ステートメントの実行結果は決定的であり、マスター上と同じデータがスレーブで再生成されます。複数の <code class="literal">INSERT</code> ステートメントによって生成された自動インクリメント値がインターリーブされた場合は、2 つの並列 <code class="literal">INSERT</code> ステートメントの結果は非決定的であり、ステートメントベースのレプリケーションを使用してスレーブサーバーに伝搬される際の信頼性も低くなる可能性があります。
      </p><p>
        この点が明確になるように、次のテーブルを使用する例を考えてみましょう。
      </p><pre class="programlisting">
CREATE TABLE t1 (
  c1 INT(11) NOT NULL AUTO_INCREMENT,
  c2 VARCHAR(10) DEFAULT NULL,
  PRIMARY KEY (c1)
) ENGINE=InnoDB;
</pre><p>
        実行中のトランザクションが 2 つ存在しており、それぞれ <code class="literal">AUTO_INCREMENT</code> カラムを含むテーブル内に行を挿入しているものとします。1 つのトランザクションは 1000 行を挿入する <code class="literal">INSERT ... SELECT</code> ステートメントを使用しており、もう 1 つのトランザクションは 1 行を挿入する単純な <code class="literal">INSERT</code> ステートメントを使用しています。
      </p><pre class="programlisting">
Tx1: INSERT INTO t1 (c2) SELECT 1000 rows from another table ...
Tx2: INSERT INTO t1 (c2) VALUES ('xxx');
</pre><p>
        <code class="literal">InnoDB</code> は、Tx1 の <code class="literal">INSERT</code> ステートメント内の <code class="literal">SELECT</code> から取得される行数を事前に知ることができないため、そのステートメントの処理を進める際に、自動インクリメント値を一度に 1 つずつ割り当てます。ステートメントの終了まで保持されるテーブルレベルロックが存在しているため、ある時点で実行可能な <code class="literal">INSERT</code> ステートメントはテーブル <code class="literal">t1</code> を参照している 1 つのステートメントだけであり、複数ステートメントによって自動インクリメント番号の生成がインターリーブされることはありません。Tx1 の <code class="literal">INSERT ... SELECT</code> ステートメントで生成される自動インクリメント値は連続した番号となり、Tx2 の <code class="literal">INSERT</code> ステートメントで使用される (単一の) 自動インクリメント値は、どちらのステートメントが先に実行されるかに応じて、Tx1 で使用されるすべての値よりも小さいか大きい値になります。
      </p><p>
        (ステートメントベースのレプリケーション使用時やリカバリシナリオで) バイナリログから再現する際に SQL ステートメントが同じ順番で実行されるかぎり、その結果は、Tx1 と Tx2 が最初に実行されたときと同じになります。したがって、ステートメントの終了まで保持されるテーブルレベルロックが存在することで、自動インクリメントを使用する <code class="literal">INSERT</code> ステートメントをステートメントベースのレプリケーションで安全に使用できるようになります。ただし、このようなロックでは、複数のトランザクションで挿入ステートメントが同時に実行されるときの並列性および拡張性が制限されます。
      </p><p>
        前述の例でテーブルレベルロックが存在しなかった場合、Tx2 の <code class="literal">INSERT</code> で使用される自動インクリメントカラムの値は、ステートメントが実際に実行されるタイミングに応じて変更されます。Tx1 の <code class="literal">INSERT</code> の (実行前や完了後ではなく) 実行中に、Tx2 の <code class="literal">INSERT</code> が実行された場合、その 2 つの <code class="literal">INSERT</code> ステートメントで割り当てられる具体的な自動インクリメント値は非決定的となり、実行するたびに値が異なる可能性があります。
      </p><p>
        <code class="literal">InnoDB</code> では、行数が事前にわかっている場合は、<code class="literal">INSERT</code> ステートメントのクラスに対してテーブルレベル <code class="literal">AUTO-INC</code> ロックが使用されることを回避できますが、ステートメントベースのレプリケーションの決定的な実行および安全性は、引き続き保持されます。さらに、リカバリまたはレプリケーションの一部として SQL ステートメントを再現する際にバイナリログを使用しない場合は、並列性およびパフォーマンスをさらに改善するために、テーブルレベル <code class="literal">AUTO-INC</code> ロックの使用を完全に除去できますが、ステートメントで割り当てられた自動インクリメント数のギャップが許可され、並列実行されるステートメントで割り当てられた数がインターリーブされる可能性があるという犠牲が伴います。
      </p><p>
        ステートメントの処理開始時点で挿入行数がわかっているような <code class="literal">INSERT</code> ステートメントでは、<code class="literal">InnoDB</code> はロックを一切使用せずに必要な数の自動インクリメント値をすばやく割り当てます。ただし、テーブルレベル <code class="literal">AUTO-INC</code> ロックをすでに保持している並列セッションが存在しない場合に限ります (その別のステートメントが処理中に自動インクリメント値を 1 つずつ割り当てるため)。より正確に言えば、このような <code class="literal">INSERT</code> ステートメントは、ステートメントの完了まででは<span class="emphasis"><em>なく</em></span>、割り当て処理の期間だけ保持される相互排他ロック (軽量ロック) の制御下で自動インクリメント値を取得します。
      </p><p>
        この新しいロックスキームを使用すると、拡張性を大幅に改善できますが、元のメカニズムと比べて、自動インクリメント値が割り当てられる方法にわずかな相違が散見されます。<code class="literal">InnoDB</code> での自動インクリメントの動作を説明するために、次の説明でいくつかの用語を定義し、サーバーの起動時に設定できる <code class="literal">innodb_autoinc_lock_mode</code> 構成パラメータのさまざまな設定を使用した <code class="literal">InnoDB</code> の動作について説明します。自動インクリメントロックの動作説明のあとで、追加の注意事項について説明します。
      </p><p>
        まず、いくつかの定義を次に示します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <span class="quote">「<span class="quote"><code class="literal">INSERT</code> のような</span>」</span>ステートメント
          </p><p>
            <code class="literal">INSERT</code>、<code class="literal">INSERT ... SELECT</code>、<code class="literal">REPLACE</code>、<code class="literal">REPLACE ... SELECT</code>、<code class="literal">LOAD DATA</code> など、テーブル内に新しい行を生成するすべてのステートメントです。
          </p></li><li class="listitem"><p>
            <span class="quote">「<span class="quote">単純挿入</span>」</span>
          </p><p>
            挿入行数を事前に (ステートメントの初期処理時に) 決定できるステートメントです。これには、ネストしたサブクエリーを持たない単一行および複数行の <code class="literal">INSERT</code> および <code class="literal">REPLACE</code> ステートメントが含まれますが、<code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> は含まれません。
          </p></li><li class="listitem"><p>
            <span class="quote">「<span class="quote">一括挿入</span>」</span>
          </p><p>
            挿入行数 (および必要な自動インクリメント値の数) が事前にわからないステートメントです。これには、<code class="literal">INSERT ... SELECT</code>、<code class="literal">REPLACE ... SELECT</code>、および <code class="literal">LOAD DATA</code> ステートメントが含まれますが、単純な <code class="literal">INSERT</code> は含まれません。<code class="literal">InnoDB</code> は各行を処理する際に、<code class="literal">AUTO_INCREMENT</code> カラムの新しい値を一度に 1 つずつ割り当てます。
          </p></li><li class="listitem"><p>
            <span class="quote">「<span class="quote">混在モード挿入</span>」</span>
          </p><p>
            これらは、新しい行の一部 (全部ではない) の自動インクリメント値を指定する <span class="quote">「<span class="quote">単純挿入</span>」</span> ステートメントです。次の例を示します。<code class="literal">c1</code> はテーブル <code class="literal">t1</code> の <code class="literal">AUTO_INCREMENT</code> カラムです。
          </p><pre class="programlisting">
INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d');
</pre><p>
            <code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> は別のタイプの <span class="quote">「<span class="quote">混在モード挿入</span>」</span> で、最悪の場合には実質 <code class="literal">INSERT</code> のあとに <code class="literal">UPDATE</code> を実行することに相当しますが、<code class="literal">AUTO_INCREMENT</code> カラムに割り当てられた値は、更新フェーズで使用される可能性も使用されない可能性もあります。
          </p></li></ul></div><p>
        <code class="literal">innodb_autoinc_lock_mode</code> パラメータには、次の 3 つの設定を指定できます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">innodb_autoinc_lock_mode = 0</code> (<span class="quote">「<span class="quote">従来</span>」</span> ロックモード)
          </p><p>
            このロックモードでは、<code class="literal">innodb_autoinc_lock_mode</code> が存在する前と同じ動作が提供されます。すべての <span class="quote">「<span class="quote"><code class="literal">INSERT</code> のような</span>」</span>ステートメントでは、特殊なテーブルレベル <code class="literal">AUTO-INC</code> ロックが取得され、ステートメントの終了まで保持されます。これにより、特定のステートメントによって割り当てられた自動インクリメント値が連続的になります。
          </p><p>
            このロックモードの用途は次のとおりです。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                下位互換性。
              </p></li><li class="listitem"><p>
                パフォーマンスのテスト。
              </p></li><li class="listitem"><p>
                <span class="quote">「<span class="quote">混在モード挿入</span>」</span>での問題の対処 (あとで説明するセマンティクスに相違がある可能性があるため)。
              </p></li></ul></div></li><li class="listitem"><p>
            <code class="literal">innodb_autoinc_lock_mode = 1</code> (<span class="quote">「<span class="quote">連続</span>」</span> ロックモード)
          </p><p>
            これがデフォルトのロックモードです。このモードでは、<span class="quote">「<span class="quote">一括挿入</span>」</span> は特殊な <code class="literal">AUTO-INC</code> テーブルレベルロックを使用し、そのロックをステートメントの終了まで保持します。これは、<code class="literal">INSERT ... SELECT</code>、<code class="literal">REPLACE ... SELECT</code>、<code class="literal">LOAD DATA</code> のすべてのステートメントに当てはまります。一度に実行できるステートメントは、<code class="literal">AUTO-INC</code> ロックを保持している 1 つのステートメントだけです。
          </p><p>
            このロックモードでは、<span class="quote">「<span class="quote">単純挿入</span>」</span> (のみ) が、自動インクリメント値の割り当てのときに軽量相互排他ロックが使用される新しいロックモデルを使用します。別のトランザクションがテーブルレベル <code class="literal">AUTO-INC</code> ロックを保持していないかぎり、<code class="literal">AUTO-INC</code> ロックは使用されません。別のトランザクションが <code class="literal">AUTO-INC</code> ロックを保持している場合、<span class="quote">「<span class="quote">単純挿入</span>」</span>は<span class="quote">「<span class="quote">一括ロック</span>」</span>と同様に、<code class="literal">AUTO-INC</code> ロックを待機します。
          </p><p>
            このロックモードでは、行数が事前にわからない (したがってステートメントの処理中に自動インクリメント番号が割り当てられる) <code class="literal">INSERT</code> ステートメントが存在する場合には、任意の <span class="quote">「<span class="quote"><code class="literal">INSERT</code> のような</span>」</span> ステートメントによって割り当てられたすべての自動インクリメント値が必ず連続した値になるため、その処理は、ステートメントベースのレプリケーションで使用しても安全です。
          </p><p>
            簡単に言えば、このロックモードの重要な効果は、拡張性の大幅な向上です。このモードは、ステートメントベースのレプリケーションで使用しても安全です。さらに、<span class="quote">「<span class="quote">従来</span>」</span>ロックモードの場合と同じく、任意のステートメントによって割り当てられた自動インクリメント番号が<span class="emphasis"><em>連続的</em></span>になります。このモードでは <span class="quote">「<span class="quote">従来</span>」</span> モードと比較して、1 つの重要な例外を除けば、自動インクリメントを使用するステートメントのセマンティクスに<span class="emphasis"><em>変更点はありません</em></span>。
          </p><p>
            例外は<span class="quote">「<span class="quote">混在モード挿入</span>」</span>です。この挿入では、ユーザーは複数行の<span class="quote">「<span class="quote">単純挿入</span>」</span>で、明示的な値を全部ではなく、一部の行の <code class="literal">AUTO_INCREMENT</code> カラムに指定します。このような挿入の場合、<code class="literal">InnoDB</code> は挿入される行数よりも大きい自動インクリメント値を割り当てます。ただし、自動的に割り当てられる値はすべて連続的に生成されるため、直前に実行されたステートメントによって生成された自動インクリメント値よりも値が大きくなります。<span class="quote">「<span class="quote">余分</span>」</span>な番号は失われます。
          </p></li><li class="listitem"><p>
            <code class="literal">innodb_autoinc_lock_mode = 2</code> (<span class="quote">「<span class="quote">インターリーブ</span>」</span> ロックモード)
          </p><p>
            このロックモードでは、テーブルレベル <code class="literal">AUTO-INC</code> ロックを使用する <span class="quote">「<span class="quote"><code class="literal">INSERT</code> のような</span>」</span>ステートメントは 1 つも存在しないため、複数のステートメントを同時に実行できます。これはもっとも高速で、もっとも拡張性の高いロックモードです。ただし、ステートメントベースのレプリケーションを使用する場合や、リカバリシナリオでバイナリログから SQL ステートメントを再現する際には、<span class="emphasis"><em>安全ではありません</em></span>。
          </p><p>
            このロックモードでは、自動インクリメント値は一意であり、並列実行されているすべての <span class="quote">「<span class="quote"><code class="literal">INSERT</code> のような</span>」</span>ステートメントにわたって単調に増加することが保証されます。ただし、複数のステートメントが同時に番号を生成している (つまり番号の割り当てが複数のステートメント間で<span class="emphasis"><em>インターリーブ</em></span>されている) 可能性があるため、任意のステートメントによって挿入される行に対して生成された値が連続的でない可能性があります。
          </p><p>
            唯一のステートメントの実行が、挿入される行数が事前にわかっている<span class="quote">「<span class="quote">単純挿入</span>」</span>である場合は、<span class="quote">「<span class="quote">混在モード挿入</span>」</span>を除いて、単一のステートメントで生成される数にギャップがありません。ただし、<span class="quote">「<span class="quote">一括挿入</span>」</span>が実行されると、特定のステートメントで割り当てられた自動インクリメント値にギャップが発生する可能性があります。
          </p></li></ul></div><p>
        <code class="literal">innodb_autoinc_lock_mode</code> によって提供される自動インクリメントロックモードには、次のように使用上の暗黙の前提がいくつかあります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            レプリケーションでの自動インクリメントの使用
          </p><p>
            ステートメントベースレプリケーションを使用している場合は、<code class="literal">innodb_autoinc_lock_mode</code> を 0 または 1 に設定し、マスターとそのスレーブで同じ値を使用してください。<code class="literal">innodb_autoinc_lock_mode</code> = 2 (<span class="quote">「<span class="quote">インターリーブ</span>」</span>)、またはマスターとスレーブが同じロックモードを使用しない構成を使用する場合は、マスターとスレーブで自動インクリメント値が同じになることは保証されません。
          </p><p>
            行ベースレプリケーションは SQL ステートメントの実行順序に左右されない (混在形式は、ステートメントベースレプリケーションでは安全でないステートメントで行ベースレプリケーションを使用する) ため、行ベースまたは混在形式レプリケーションを使用している場合は、すべての自動インクリメントロックモードが安全です。
          </p></li><li class="listitem"><p>
            <span class="quote">「<span class="quote">失われた</span>」</span>自動インクリメント値とシーケンスギャップ
          </p><p>
            すべてのロックモード (0、1、および 2) では、自動インクリメント値を生成したトランザクションがロールバックされると、これらの自動インクリメント値が<span class="quote">「<span class="quote">失われます</span>」</span>。<span class="quote">「<span class="quote"><code class="literal">INSERT</code> のような</span>」</span>ステートメントが完了したかどうか、およびそれを含むトランザクションがロールバックされたかどうかに関係なく、自動インクリメントカラムの値は一度生成されたら、ロールバックできません。このような失われた値は再使用されません。したがって、テーブルの <code class="literal">AUTO_INCREMENT</code> カラムに格納されている値にはギャップが存在する可能性があります。
          </p></li><li class="listitem"><p>
            <span class="quote">「<span class="quote">一括挿入</span>」</span>の自動インクリメント値のギャップ
          </p><p>
            <code class="literal">innodb_autoinc_lock_mode</code> が 0 (<span class="quote">「<span class="quote">従来</span>」</span>) または 1 (<span class="quote">「<span class="quote">連続</span>」</span>) に設定されている場合、テーブルレベル <code class="literal">AUTO-INC</code> ロックがステートメントの終了まで保持され、同時に実行できるステートメントはこのような 1 つのステートメントだけであるため、任意のステートメントによって生成される自動インクリメント値は、ギャップのない連続的なものとなります。
          </p><p>
            <code class="literal">innodb_autoinc_lock_mode</code> が 2 (<span class="quote">「<span class="quote">インターリーブ</span>」</span>) に設定されている場合、<span class="quote">「<span class="quote">一括挿入</span>」</span>によって生成された自動インクリメント値にギャップが存在する可能性がありますが、並列実行中の <span class="quote">「<span class="quote"><code class="literal">INSERT</code> のような</span>」</span>ステートメントが存在する場合に限ります。
          </p><p>
            一括挿入では、各ステートメントで必要となる自動インクリメント値の正確な数がわからず、過大評価される可能性があるため、ロックモードが 1 または 2 の場合は、連続したステートメント間でギャップが発生する可能性があります。
          </p></li><li class="listitem"><p>
            <span class="quote">「<span class="quote">混在モード挿入</span>」</span>によって割り当てられる自動インクリメント値
          </p><p>
            <span class="quote">「<span class="quote">単純挿入</span>」</span>が (全部ではなく) 一部の結果行の自動インクリメント値を指定する<span class="quote">「<span class="quote">混在モード挿入</span>」</span>を検討します。このようなステートメントの動作は、ロックモード 0、1、および 2 で異なります。たとえば、<code class="literal">c1</code> はテーブル <code class="literal">t1</code> の <code class="literal">AUTO_INCREMENT</code> カラムで、自動生成されたシーケンス番号の最新値が 100 であるとします。次のような<span class="quote">「<span class="quote">混在モード挿入</span>」</span>ステートメントを検討します。
          </p><pre class="programlisting">
INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d');
</pre><p>
            <code class="literal">innodb_autoinc_lock_mode</code> が 0 (<span class="quote">「<span class="quote">従来</span>」</span>) に設定されている場合、4 つの新しい行は次のようになります。
          </p><pre class="programlisting">
+-----+------+
| c1  | c2   |
+-----+------+
|   1 | a    |
| 101 | b    |
|   5 | c    |
| 102 | d    |
+-----+------+
</pre><p>
            自動インクリメント値は、ステートメントの実行開始時に一度にすべての値が割り当てられるのではなく、一度に 1 つずつ割り当てられるため、次に使用可能な自動インクリメント値は 103 になります。この結果は、並列実行中の (任意の型の) <span class="quote">「<span class="quote"><code class="literal">INSERT</code> のような</span>」</span>ステートメントが存在するかどうかに左右されません。
          </p><p>
            <code class="literal">innodb_autoinc_lock_mode</code> が 1 (<span class="quote">「<span class="quote">連続</span>」</span>) に設定されている場合も、4 つの新しい行は次のようになります。
          </p><pre class="programlisting">
+-----+------+
| c1  | c2   |
+-----+------+
|   1 | a    |
| 101 | b    |
|   5 | c    |
| 102 | d    |
+-----+------+
</pre><p>
            ただし、この場合、ステートメントの処理時に自動インクリメント値が 4 つ割り当てられましたが、そのうちの 2 つだけが使用されたため、次に使用可能な自動インクリメント値は 103 ではなく、105 になります。この結果は、並列実行中の (任意の型の) <span class="quote">「<span class="quote"><code class="literal">INSERT</code> のような</span>」</span>ステートメントが存在するかどうかに左右されません。
          </p><p>
            <code class="literal">innodb_autoinc_lock_mode</code> が 2 (<span class="quote">「<span class="quote">インターリーブ</span>」</span>) に設定されている場合、4 つの新しい行は次のようになります。
          </p><pre class="programlisting">
+-----+------+
| c1  | c2   |
+-----+------+
|   1 | a    |
|   <em class="replaceable"><code>x</code></em> | b    |
|   5 | c    |
|   <em class="replaceable"><code>y</code></em> | d    |
+-----+------+
</pre><p>
            <em class="replaceable"><code>x</code></em> と <em class="replaceable"><code>y</code></em> の値は一意であり、以前に生成されたどの行よりも大きくなります。ただし、<em class="replaceable"><code>x</code></em> と <em class="replaceable"><code>y</code></em> の具体的な値は、並列実行中のステートメントによって生成された自動インクリメント値の個数によって変わります。
          </p><p>
            最後に、生成された最新のシーケンス番号が値 4 だったときに、次のステートメントを発行した場合を検討します。
          </p><pre class="programlisting">
INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d');
</pre><p>
            どのように <code class="literal">innodb_autoinc_lock_mode</code> を設定しても、行 <code class="literal">(NULL, 'b')</code> に対して 5 が割り当てられ、行 <code class="literal">(5, 'c')</code> の挿入が失敗するため、このステートメントから重複キーエラー 23000 (<code class="literal">Can't write; duplicate key in table</code>) が生成されます。
          </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-foreign-key-constraints"></a>14.6.6 InnoDB と FOREIGN KEY 制約</h3></div></div></div><a class="indexterm" name="idm139979072848688"></a><a class="indexterm" name="idm139979072846576"></a><a class="indexterm" name="idm139979072844528"></a><p>
      このセクションでは、InnoDB ストレージエンジンでの外部キー処理と、MySQL サーバーでの処理とを比較したときの相違点について説明します。
    </p><h4><a name="idm139979072841680"></a>外部キーの定義</h4><p>
      <code class="literal">InnoDB</code> テーブルの外部キー定義は、次のような条件の対象となります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">InnoDB</code> では、外部キーが任意のインデックスカラムまたはカラムのグループを参照することが許可されます。ただし、参照されるテーブルには、参照されるカラムが同じ順序で<span class="emphasis"><em>最初の</em></span>カラムとして一覧表示されているインデックスが存在する必要があります。
        </p></li><li class="listitem"><p>
          現在、<code class="literal">InnoDB</code> ではユーザー定義のパーティションを持つテーブルの外部キーがサポートされていません。つまり、ユーザーがパーティション化した <code class="literal">InnoDB</code> テーブルには、外部キーで参照される外部キー参照またはカラムが含まれる可能性がありません。
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> では、外部キー制約が一意でないキーを参照することが許可されます。<span class="emphasis"><em>これは、標準 SQL の <code class="literal">InnoDB</code> 拡張です。</em></span>
        </p></li></ul></div><h4><a name="idm139979072830880"></a>参照アクション</h4><p>
      <code class="literal">InnoDB</code> テーブルの外部キーに関する参照アクションは、次のような条件の対象となります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">SET DEFAULT</code> は、MySQL サーバーで許可されていますが、<code class="literal">InnoDB</code> では無効として拒否されます。この句を使用した <code class="literal">CREATE TABLE</code> および <code class="literal">ALTER TABLE</code> ステートメントは、InnoDB テーブルで許可されていません。
        </p></li><li class="listitem"><p>
          同じ参照キー値を持つ複数の行が親テーブルにある場合、<code class="literal">InnoDB</code> は、同じキー値を持つほかの親の行が存在しないかのように、外部キーチェックで動作します。たとえば、<code class="literal">RESTRICT</code> 型の制約が定義されていて、複数の親の行を含む子の行が存在する場合は、これらの親の行のいずれかを削除することが <code class="literal">InnoDB</code> で許可されません。
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> では、外部キー制約に対応するインデックス内のレコードに基づいて、深さ優先アルゴリズムを使用したカスケード操作が実行されます。
        </p></li><li class="listitem"><p>
          <code class="literal">ON UPDATE CASCADE</code> または <code class="literal">ON UPDATE SET NULL</code> は、カスケード中に以前に更新していた<span class="emphasis"><em>同じテーブル</em></span>を更新するように再帰する場合、<code class="literal">RESTRICT</code> と同様に機能します。つまり、自己参照型 <code class="literal">ON UPDATE CASCADE</code> または <code class="literal">ON UPDATE SET NULL</code> 操作は使用できません。この目的は、カスケード更新で発生する無限ループを回避することです。反対に、自己参照型 <code class="literal">ON DELETE SET NULL</code> は、自己参照型 <code class="literal">ON DELETE CASCADE</code> と同様に動作できます。カスケード操作は、15 レベルよりも深くネストされる可能性がありません。
        </p></li><li class="listitem"><p>
          一般的な MySQL と同様に、多数の行を挿入、削除、または更新する SQL ステートメントでは、<code class="literal">InnoDB</code> によって <code class="literal">UNIQUE</code> および <code class="literal">FOREIGN KEY</code> 制約が 1 行ずつチェックされます。外部キーチェックの実行時に、<code class="literal">InnoDB</code> は、調査対象の子または親のレコード上に共有の行レベルロックを設定します。<code class="literal">InnoDB</code> では、即座に外部キー制約がチェックされ、そのチェックはトランザクションのコミットまで遅延されません。SQL 標準によると、デフォルトの動作は遅延チェックにするべきです。つまり、<span class="emphasis"><em>SQL ステートメント全体</em></span>が処理されたあとにはじめて、制約がチェックされます。<code class="literal">InnoDB</code> で制約の遅延チェックが実装されるまで、外部キーを使用してそれ自体を参照するレコードを削除するなどの一部の操作が実行できません。
        </p></li></ul></div><h4><a name="idm139979072803968"></a>外部キーの使用法とエラー情報</h4><p>
      外部キーおよびそれらの使用法に関する一般的な情報は、<code class="literal">INFORMATION_SCHEMA.KEY_COLUMN_USAGE</code> テーブルでクエリーを実行することで取得できます。<code class="literal">InnoDB</code> テーブルに固有の詳細な情報は、<code class="literal">INNODB_SYS_FOREIGN</code> および <code class="literal">INNODB_SYS_FOREIGN_COLS</code> テーブル、または <code class="literal">INFORMATION_SCHEMA</code> データベースで見つかります。<a class="xref" href="sql-syntax.html#create-table-foreign-keys" title="13.1.17.2 外部キー制約の使用">セクション13.1.17.2「外部キー制約の使用」</a>も参照してください。
    </p><p>
      <code class="literal">SHOW ERRORS</code> 以外でも、<code class="literal">InnoDB</code> テーブルが関与する外部キーエラー (通常、MySQL サーバーではエラー 150) の発生時に、<code class="literal">SHOW ENGINE INNODB STATUS</code> の出力をチェックすることで、最近の <code class="literal">InnoDB</code> 外部キーエラーの詳細な説明を取得できます。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-restrictions"></a>14.6.7 InnoDB テーブル上の制限</h3></div></div></div><a class="indexterm" name="idm139979072790768"></a><a class="indexterm" name="idm139979072788608"></a><a class="indexterm" name="idm139979072786688"></a><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
        <code class="literal">mysql</code> データベース内の MySQL システムテーブルを <code class="literal">MyISAM</code> から <code class="literal">InnoDB</code> テーブルに変換<span class="emphasis"><em>しない</em></span>でください。これはサポートされていない操作です。これを行うと、<span class="command"><strong>mysql_install_db</strong></span> プログラムを使用してバックアップから古いシステムテーブルをリストアするか、再生成するまで、MySQL は再起動されません。
      </p></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
        <a class="indexterm" name="idm139979072778560"></a> <a class="indexterm" name="idm139979072776592"></a>NFS ボリューム上でデータファイルやログファイルが使用されるように <code class="literal">InnoDB</code> を構成することは、適切ではありません。それ以外の場合は、ファイルがほかのプロセスによってロックされ、MySQL で使用できなくなる可能性があります。
      </p></div><h4><a name="idm139979072772912"></a>最大と最小</h4><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          テーブルには、最大で 1017 個のカラムを含めることができます (MySQL 5.6.9 で、以前の 1000 個の制限から上昇されました)。
        </p></li><li class="listitem"><p>
          テーブルには、最大で 64 個の<a class="link" href="glossary.html#glos_secondary_index" title="セカンダリインデックス">セカンダリインデックス</a>を含めることができます。
        </p></li><li class="listitem"><p>
          デフォルトでは、単一カラムインデックスのインデックスキーを最大で 767 バイトにすることができます。インデックスキープリフィクスにも同じ長さ制限が適用されます。<a class="xref" href="sql-syntax.html#create-index" title="13.1.13 CREATE INDEX 構文">セクション13.1.13「CREATE INDEX 構文」</a>を参照してください。たとえば、UTF-8 文字セットと文字ごとに最大 3 バイトを使用すると仮定すれば、<code class="literal">TEXT</code> または <code class="literal">VARCHAR</code> カラム上で 255 文字よりも長い<a class="link" href="glossary.html#glos_column_prefix" title="カラムプリフィクス">カラムプリフィクス</a>インデックスを使用すると、この制限に達する可能性があります。<code class="literal">innodb_large_prefix</code> 構成オプションを有効にすると、<code class="literal"><a class="link" href="glossary.html#glos_dynamic_row_format" title="動的行フォーマット">DYNAMIC</a></code> および <code class="literal"><a class="link" href="glossary.html#glos_compressed_row_format" title="圧縮行フォーマット">COMPRESSED</a></code> 行フォーマットを使用する <code class="literal">InnoDB</code> テーブルで、この長さ制限が 3072 バイトに上昇します。
        </p><p>
          許可されている最大値よりも長いインデックスプリフィクス長を使用しようとすると、エラーが生成されます。スレーブ上でも <code class="literal">innodb_large_prefix</code> オプションを設定できなく、この制限の影響を受ける可能性のある一意のインデックスをスレーブが持っている場合は、レプリケーション構成でこのようなエラーを回避するために、このオプションをマスター上で設定することを避けてください。
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> の内部的な最大キー長は 3500 バイトですが、MySQL 自体では 3072 バイトに制限されています。この制限は、複数カラムインデックス内の結合されたインデックスキーの長さに適用されます。
        </p></li><li class="listitem"><p>
          MySQL インスタンスの作成時に <code class="literal">innodb_page_size</code> オプションを指定して、<code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_page_size" title="page size">ページサイズ</a>を 8K バイトまたは 4K バイトまで小さくすると、16K バイトのページサイズに対応する 3072 バイトの制限に基づいて、比例的にインデックスキーの最大長も短くなります。つまり、インデックスキーの最大長は、ページサイズが 8K バイトのときは 1536 バイト、ページサイズが 4K バイトのときは 768 バイトになります。
        </p></li><li class="listitem"><p>
          可変長カラム (<code class="literal">VARBINARY</code>、<code class="literal">VARCHAR</code>、<code class="literal">BLOB</code>、および <code class="literal">TEXT</code>) を除き、行の最大長はデータベースページの半分より少し短くなります。つまり、デフォルトページサイズの 16K バイトでは、行の最大長が約 8000 バイトになります。MySQL インスタンスの作成時に <code class="literal">innodb_page_size</code> オプションを指定してページサイズを小さくすると、行の最大長は、8K バイトのページでは 4000 バイト、4K バイトのページでは 2000 バイトになります。<code class="literal">LONGBLOB</code> および <code class="literal">LONGTEXT</code> カラムは 4G バイト未満である必要があり、<code class="literal">BLOB</code> および <code class="literal">TEXT</code> カラムを含む行全体の長さは 4G バイト未満である必要があります。
        </p><p>
          行の長さが 1 ページの半分より短い場合は、行全体がそのページ内にローカルに格納されます。<a class="xref" href="innodb-storage-engine.html#innodb-file-space" title="14.10.2 ファイル領域管理">セクション14.10.2「ファイル領域管理」</a>で説明したように、半ページを超える行では、その行が半ページ以内に収まるように、可変長カラムが外部オフページストレージの対象として選択されます。
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> では内部的に 65,535 バイトを超える行サイズがサポートされていますが、MySQL 自体では、すべてのカラムを結合したサイズに 65,535 行のサイズ制限が課されています。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE t (a VARCHAR(8000), b VARCHAR(10000),</code></strong>
    -&gt; <strong class="userinput"><code>c VARCHAR(10000), d VARCHAR(10000), e VARCHAR(10000),</code></strong>
    -&gt; <strong class="userinput"><code>f VARCHAR(10000), g VARCHAR(10000)) ENGINE=InnoDB;</code></strong>
ERROR 1118 (42000): Row size too large. The maximum row size for the
used table type, not counting BLOBs, is 65535. You have to change some
columns to TEXT or BLOBs
</pre><p>
          <a class="xref" href="restrictions.html#column-count-limit" title="D.10.4 テーブルカラム数と行サイズの制限">セクションD.10.4「テーブルカラム数と行サイズの制限」</a>を参照してください。
        </p></li><li class="listitem"><p>
          一部の古いオペレーティングシステムでは、ファイルは 2G バイトよりも小さくする必要があります。これは、<code class="literal">InnoDB</code> 自体の制限ではありません。ただし、大きいテーブルスペースが必要な場合は、1 つではなく複数の小さいデータファイルを使用して構成するか、より大きいデータファイルを作成する必要があります。
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> ログファイルを結合したサイズは、最大で 512G バイトまでにすることができます。
        </p></li><li class="listitem"><p>
          テーブルスペースの最小サイズは、10M バイトをわずかに超える大きさです。テーブルスペースの最大サイズは、40 億データベースページ (64T バイト) です。これはテーブルの最大サイズでもあります。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979072724608"></a> <a class="indexterm" name="idm139979072722576"></a><code class="literal">InnoDB</code> のデフォルトのデータベースページサイズは 16K バイトですが、MySQL インスタンスの作成時に <code class="literal">innodb_page_size</code> オプションを指定すれば、ページサイズを 8K バイトまたは 4K バイトまで小さくすることができます。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            ページサイズを大きくすることは、サポートされている操作ではありません。<code class="literal">InnoDB</code> では、16K バイトを超えるページサイズでは通常な動作が保証されません。InnoDB をコンパイルまたは実行するときに、問題が発生する可能性があります。特に、Barracuda ファイル形式の <code class="literal">ROW_FORMAT=COMPRESSED</code> では、ページサイズが 16K バイトで、14 ビットのポインタを使用することが前提となっています。
          </p><p>
            特定の <code class="literal">InnoDB</code> ページサイズを使用している MySQL インスタンスは、別のページサイズを使用するインスタンスのデータファイルやログファイルを使用できません。この制限によって、16K バイト以外のページサイズがサポートされている MySQL 5.6 のデータを使用したリストアまたはダウングレード操作が影響を受ける可能性があります。
          </p></div></li></ul></div><h4><a name="idm139979072712976"></a>インデックスの型</h4><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          MySQL 5.6.4 以降では、<code class="literal">InnoDB</code> テーブルで <code class="literal">FULLTEXT</code> インデックスがサポートされています。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-fulltext-index" title="14.2.13.3 FULLTEXT インデックス">セクション14.2.13.3「FULLTEXT インデックス」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> テーブルでは空間データ型がサポートされますが、そのインデックスはサポートされません。
        </p></li></ul></div><h4><a name="idm139979072706176"></a>InnoDB テーブル上の制約</h4><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          各インデックスツリーに<a class="link" href="glossary.html#glos_random_dive" title="ランダムダイブ">ランダムダイブ</a>を行い、それに従ってインデックスカーディナリティーの見積もりを更新すると、(<code class="literal">SHOW INDEX</code> 出力の<code class="literal">「Cardinality」</code>カラムに表示されるように) <code class="literal">ANALYZE TABLE</code> でインデックスカーディナリティーが決定されます。これらは単なる見積もりであるため、<code class="literal">ANALYZE TABLE</code> を繰り返し実行すると、別の数値が生成される可能性があります。これによって <code class="literal">ANALYZE TABLE</code> の <code class="literal">InnoDB</code> テーブル上での速度は速くなりますが、すべての行が考慮されているわけではないため、100% 正確とは言えません。
        </p><p>
          <a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="14.13.16.1 永続的オプティマイザ統計のパラメータの構成">セクション14.13.16.1「永続的オプティマイザ統計のパラメータの構成」</a>で説明したように、<code class="literal">innodb_stats_persistent</code> 構成オプションをオンにすると、<code class="literal">ANALYZE TABLE</code> で収集された<a class="link" href="glossary.html#glos_statistics" title="統計">統計</a>の正確性および安定性を向上させることができます。統計は定期的に再計算されないため、この設定を有効にした場合は、従来と同様に、インデックス付きカラムデータの主要な変更後 (サーバーの再起動後など) に、<code class="literal">ANALYZE TABLE</code> を実行することが重要です。
        </p><p>
          <code class="literal">innodb_stats_persistent_sample_pages</code> システム変数 (永続的な統計設定がオンになっている場合)、または <code class="literal">innodb_stats_transient_sample_pages</code> システム変数 (永続的な統計設定がオフになっている場合) を変更すると、ランダムダイブの数を変更できます。
        </p><p>
          MySQL では、結合の最適化時にのみインデックスカーディナリティーの見積もりが使用されます。一部の結合が適切に最適化されない場合は、<code class="literal">ANALYZE TABLE</code> を使用してみてください。<code class="literal">ANALYZE TABLE</code> では特定のテーブルに十分な値が生成されない場合は、特定のインデックスの使用を強制するクエリーとともに <code class="literal">FORCE INDEX</code> を使用するか、または MySQL でテーブルスキャンよりもインデックス検索が優先されるように <code class="literal">max_seeks_for_key</code> システム変数を設定してください。<a class="xref" href="server-administration.html#server-system-variables" title="5.1.4 サーバーシステム変数">セクション5.1.4「サーバーシステム変数」</a>、および<a class="xref" href="error-handling.html#optimizer-issues" title="B.5.6 オプティマイザ関連の問題">セクションB.5.6「オプティマイザ関連の問題」</a>を参照してください。
        </p></li><li class="listitem"><p>
          テーブル上でステートメントまたはトランザクションが実行されていて、<code class="literal">ANALYZE TABLE</code> のあとに同じテーブル上で 2 番目の <code class="literal">ANALYZE TABLE</code> 操作が実行されると、そのステートメントまたはトランザクションが完了するまで、2 番目の <code class="literal">ANALYZE TABLE</code> 操作はブロックされます。この動作が発生する原因は、<code class="literal">ANALYZE TABLE</code> の実行が完了すると、<code class="literal">ANALYZE TABLE</code> によって現在ロード中のテーブル定義に非推奨のマークが付けられるためです。新しいステートメントまたはトランザクション (2 番目の <code class="literal">ANALYZE TABLE</code> ステートメントを含む) は、新しいテーブル定義をテーブルキャッシュにロードする必要があります。この動作は、現在実行中のステートメントまたはトランザクションが完了し、古いテーブル定義がパージされるまで発生する可能性がありません。複数の並列テーブル定義をロードすることは、サポートされていません。
        </p></li><li class="listitem"><p>
          <code class="literal">SHOW TABLE STATUS</code> では、テーブルで予約された物理サイズを除き、<code class="literal">InnoDB</code> テーブルに関する正確な統計が得られません。行カウントは、単に SQL 最適化で使用される概算見積もりです。
        </p></li><li class="listitem"><p>
          並列トランザクションでは同時にさまざまな数の行が<span class="quote">「<span class="quote">参照</span>」</span>される可能性があるため、<code class="literal">InnoDB</code> のテーブルには、行の内部的なカウントが保持されません。<code class="literal">SELECT COUNT(*) FROM t</code> ステートメントを処理するために、<code class="literal">InnoDB</code> ではテーブルのインデックスがスキャンされますが、インデックスが完全にバッファープール内にない場合は多少時間がかかります。テーブルが頻繁に変更されない場合は、MySQL クエリーキャッシュを使用することが適切な解決策となります。すばやくカウントするには、自分で作成したカウンタテーブルを使用し、実行される挿入および削除に応じてアプリケーションで更新できるようにする必要があります。概算の行カウントでは十分でない場合は、<code class="literal">SHOW TABLE STATUS</code> を使用できます。<a class="xref" href="optimization.html#optimizing-innodb" title="8.5 InnoDB テーブルの最適化">セクション8.5「InnoDB テーブルの最適化」</a>を参照してください。
        </p></li><li class="listitem"><p>
          Windows 上の <code class="literal">InnoDB</code> では常に、データベース名およびテーブル名が内部的に小文字で格納されます。バイナリ形式のデータベースを Unix から Windows に、または Windows から Unix に移動するには、すべてのデータベースおよびテーブルを小文字の名前を使用して作成します。
        </p></li><li class="listitem"><p>
          最大カラム値を取得するためにテーブルでのインデックス付きの <code class="literal">SELECT MAX(<em class="replaceable"><code>ai_col</code></em>)</code> 検索と同等の操作を実行できるように、<code class="literal">AUTO_INCREMENT</code> カラム <em class="replaceable"><code>ai_col</code></em> をインデックスの一部として定義する必要があります。一般に、これはカラムをどこかのテーブルインデックスの 1 番目のカラムにすることで実現されます。
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> は、テーブル上に事前に指定された <code class="literal">AUTO_INCREMENT</code> カラムの初期化中に、<code class="literal">AUTO_INCREMENT</code> カラムに関連付けられたインデックスの最後に排他ロックを設定します。自動インクリメントカウンタにアクセスするときに <code class="literal">InnoDB</code> では、トランザクション全体の最後までではなく、現在の SQL ステートメントの最後まで存続する特別な <code class="literal">AUTO-INC</code> テーブルロックモードが使用されます。<code class="literal">AUTO-INC</code> テーブルロックが保持されている間は、ほかのクライアントはそのテーブルに挿入できません。<a class="xref" href="innodb-storage-engine.html#innodb-auto-increment-handling" title="14.6.5 InnoDB での AUTO_INCREMENT 処理">セクション14.6.5「InnoDB での AUTO_INCREMENT 処理」</a>を参照してください。
        </p></li><li class="listitem"><p>
          MySQL サーバーを再起動すると、<code class="literal">AUTO_INCREMENT</code> カラム用に生成されたが一度も格納されなかった古い値 (つまり、ロールバックされた古いトランザクション内で生成された値) が <code class="literal">InnoDB</code> で再使用される可能性があります。
        </p></li><li class="listitem"><p>
          <code class="literal">AUTO_INCREMENT</code> 整数カラムの値を使い果たすと、後続の <code class="literal">INSERT</code> 操作で重複キーエラーが返されます。これは一般的な MySQL の動作であり、<code class="literal">MyISAM</code> の動作と似ています。
        </p></li><li class="listitem"><p>
          <code class="literal">DELETE FROM <em class="replaceable"><code>tbl_name</code></em></code> はテーブルを再生成しませんが、その代わりにすべての行を 1 つずつ削除します。
        </p></li><li class="listitem"><p>
          現在、カスケードされた外部キーのアクションではトリガーがアクティブになっていません。
        </p></li><li class="listitem"><p>
          内部 InnoDB カラム (<code class="literal">DB_ROW_ID</code>、<code class="literal">DB_TRX_ID</code>、<code class="literal">DB_ROLL_PTR</code>、<code class="literal">DB_MIX_ID</code> など) の名前と一致するカラム名を持つテーブルを作成することはできません。サーバーはエラー 1005 をレポートし、エラーメッセージ内のエラー −1 を参照します。この制約は、大文字の名前を使用する場合にのみ適用されます。
        </p></li></ul></div><h4><a name="idm139979072633568"></a>ロックとトランザクション</h4><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">innodb_table_locks=1</code> (デフォルト) の場合、<code class="literal">LOCK TABLES</code> で各テーブル上に 2 つのロックが取得されます。MySQL レイヤーでのテーブルロックに加えて、<code class="literal">InnoDB</code> テーブルロックも取得されます。バージョン 4.1.2 よりも前の MySQL では、<code class="literal">InnoDB</code> テーブルロックが取得されませんでした。この古い動作は、<code class="literal">innodb_table_locks=0</code> を設定すれば選択できます。<code class="literal">InnoDB</code> テーブルロックが取得されない場合は、テーブルの一部のレコードがほかのトランザクションによってロックされなくても、<code class="literal">LOCK TABLES</code> が完了します。
        </p><p>
          MySQL 5.6 では、<code class="literal">LOCK TABLES ... WRITE</code> を使用して明示的にロックされたテーブルには、<code class="literal">innodb_table_locks=0</code> が無効です。<code class="literal">LOCK TABLES ... WRITE</code> で暗黙的に (たとえば、トリガーを使用して)、または <code class="literal">LOCK TABLES ... READ</code> によって、読み取りまたは書き込み用にロックされたテーブルには有効です。
        </p></li><li class="listitem"><p>
          トランザクションで保持されているすべての <code class="literal">InnoDB</code> ロックは、トランザクションがコミットまたは中止されると解放されます。したがって、<code class="literal">autocommit=1</code> モードの <code class="literal">InnoDB</code> テーブル上で <code class="literal">LOCK TABLES</code> を呼び出しても、取得された <code class="literal">InnoDB</code> テーブルロックはすぐに解放されてしまうため、まったく意味がありません。
        </p></li><li class="listitem"><p>
          <code class="literal">LOCK TABLES</code> では暗黙的な <code class="literal">COMMIT</code> および <code class="literal">UNLOCK TABLES</code> が実行されるため、トランザクションの実行中に追加のテーブルをロックできません。
        </p></li><li class="listitem"><p>
          並列データ変更トランザクションの 1023 個の制限は、MySQL 5.5 以上で上昇されました。現在、その制限は、Undo レコードが生成される 128 * 1023 個の並列トランザクションになりました。適切なトランザクション構造を変更する必要のある回避策 (より頻繁にコミットするなど) をすべて解除できます。
        </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-compression"></a>14.7 InnoDB 圧縮テーブル</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-compression-background">14.7.1 テーブル圧縮の概要</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-compression-usage">14.7.2 テーブル圧縮の有効化</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-compression-tuning">14.7.3 InnoDB テーブルの圧縮の調整</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-compression-tuning-monitoring">14.7.4 実行時の圧縮のモニタリング</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-compression-internals">14.7.5 InnoDB テーブルでの圧縮の動作</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-compression-oltp">14.7.6 OLTP ワークロードの圧縮</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-compression-syntax-warnings">14.7.7 SQL 圧縮構文の警告とエラー</a></span></dt></dl></div><a class="indexterm" name="idm139979072605232"></a><a class="indexterm" name="idm139979072603808"></a><p>
    <a class="link" href="glossary.html#glos_compression" title="圧縮">圧縮</a>するための SQL 構文および MySQL 構成オプションを使用すると、データが圧縮形式で格納されるテーブルを作成できます。圧縮を使用すると、生のパフォーマンスと拡張性の両方を改善する際に役立つことがあります。圧縮とは、ディスクとメモリー間で転送されるデータの量が少なくなり、ディスク上とメモリー内で占有される領域の量が少なくなることを意味します。インデックスデータも圧縮されるため、<a class="link" href="glossary.html#glos_secondary_index" title="セカンダリインデックス">セカンダリインデックス</a>を含むテーブルでは利点も増幅されます。<a class="link" href="glossary.html#glos_ssd" title="SSD">SSD</a> ストレージデバイスは、<a class="link" href="glossary.html#glos_hdd" title="HDD">HDD</a> デバイスよりも容量が小さくなる傾向があるため、圧縮が特に重要となる可能性があります。
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-compression-background"></a>14.7.1 テーブル圧縮の概要</h3></div></div></div><a class="indexterm" name="idm139979072596320"></a><p>
      プロセッサおよびキャッシュメモリーは、ディスクストレージデバイスよりも速度が上昇しているため、多くのワークロードが<a class="link" href="glossary.html#glos_disk_bound" title="ディスクバウンド">ディスクバウンド</a>になります。データ<a class="link" href="glossary.html#glos_compression" title="圧縮">圧縮</a>を使用すると、データベースのサイズが小さくなり、I/O が削減され、スループットが改善されますが、CPU 使用率が上昇するという少しの犠牲が伴います。圧縮は、頻繁に使用されるデータをメモリー内に保持するために十分な RAM が搭載されたシステム上で、読み取り負荷の高いアプリケーションを実行する際に、特に有効です。
    </p><p>
      <code class="literal">ROW_FORMAT=COMPRESSED</code> で作成された InnoDB テーブルでは、通常の 16K バイトのデフォルトよりも小さい<a class="link" href="glossary.html#glos_page_size" title="page size">ページサイズ</a>をディスク上で使用できます。ページが小さいほど、ディスクから読み取られる I/O とディスクに書き込まれる I/O が少なくなるため、<a class="link" href="glossary.html#glos_ssd" title="SSD">SSD</a> デバイスを使用する際に、特に有効です。
    </p><p>
      ページサイズは、<code class="literal">KEY_BLOCK_SIZE</code> パラメータを使用して指定されます。ページサイズが異なる場合は、テーブルを<a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">システムテーブルスペース</a>内でなく、独自の <code class="literal">.ibd</code> ファイルに格納する必要があります。そのためには、<code class="literal">innodb_file_per_table</code> オプションを有効にする必要があります。圧縮レベルは、<code class="literal">KEY_BLOCK_SIZE</code> の値に関係なく同じです。<code class="literal">KEY_BLOCK_SIZE</code> に小さい値を指定するほど、徐々にページが小さくなるという I/O の利点が得られます。ただし、小さすぎる値を指定すると、各ページ内に複数の行を収容できるほど十分にデータ値を圧縮できない場合に、ページを再編成するための追加のオーバーヘッドが発生します。そのインデックスごとのキーカラムの長さに基づいて、どのくらい小さい <code class="literal">KEY_BLOCK_SIZE</code> をテーブルに指定できるのかについて、ハード制限が課されています。小さすぎる値を指定すると、<code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> ステートメントが失敗します。
    </p><p>
      バッファープールには、圧縮済みデータが <code class="literal">KEY_BLOCK_SIZE</code> の値に基づいたページサイズの小さなページで保持されます。カラム値を抽出または更新すると、MySQL のバッファープールには、非圧縮データを含む 16K バイトのページも作成されます。バッファープール内では、非圧縮ページへの更新が同等の圧縮済みページに再度書き込まれます。圧縮済みページと非圧縮ページの両方の追加データが収容されるように、バッファーページのサイズを変更する必要がある場合もあります。ただし、非圧縮のページは、領域が必要になるとバッファープールから<a class="link" href="glossary.html#glos_eviction" title="エビクション">解放</a>され、次のアクセス時に再度圧縮が解除されます。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-compression-usage"></a>14.7.2 テーブル圧縮の有効化</h3></div></div></div><a class="indexterm" name="idm139979072573776"></a><a class="indexterm" name="idm139979072571600"></a><a class="indexterm" name="idm139979072570368"></a><a class="indexterm" name="idm139979072568336"></a><a class="indexterm" name="idm139979072566304"></a><a class="indexterm" name="idm139979072564256"></a><a class="indexterm" name="idm139979072562736"></a><a class="indexterm" name="idm139979072561488"></a><p>
      圧縮テーブルを作成する前に、<code class="literal">innodb_file_per_table</code> 構成オプションが有効になっていること、および <code class="literal">innodb_file_format</code> が <code class="literal">Barracuda</code> に設定されていることを確認してください。これらのパラメータは、MySQL <a class="link" href="glossary.html#glos_configuration_file" title="構成ファイル">構成ファイル</a> <code class="literal">my.cnf</code> または <code class="literal">my.ini</code> で設定することも、MySQL サーバーをシャットダウンせずに <code class="literal">SET</code> ステートメントを使用して設定することもできます。
    </p><p>
      テーブルの圧縮を有効にするには、<code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> ステートメントで <code class="literal">ROW_FORMAT=COMPRESSED</code> 句、<code class="literal">KEY_BLOCK_SIZE</code> 句、またはその両方を使用します。
    </p><p>
      圧縮テーブルを作成するには、次のようなステートメントを使用するとよいでしょう。
    </p><pre class="programlisting">
SET GLOBAL innodb_file_per_table=1;
SET GLOBAL innodb_file_format=Barracuda;
CREATE TABLE t1
 (c1 INT PRIMARY KEY) 
 ROW_FORMAT=COMPRESSED 
 KEY_BLOCK_SIZE=8;
</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">ROW_FORMAT=COMPRESSED</code> を指定する場合は、<code class="literal">KEY_BLOCK_SIZE</code> を省略できます。<code class="literal">innodb_page_size</code> 値の半分であるデフォルトのページサイズ値が使用されます。
        </p></li><li class="listitem"><p>
          <code class="literal">KEY_BLOCK_SIZE</code> を指定する場合は、<code class="literal">ROW_FORMAT=COMPRESSED</code> を省略できます。圧縮は自動的に有効になります。
        </p></li><li class="listitem"><p>
          <code class="literal">KEY_BLOCK_SIZE</code> の最適な値を決定するには、一般に、この句にさまざまな値を指定した同じテーブルのコピーをいくつか作成してから、結果として生成される <code class="literal">.ibd</code> ファイルのサイズを計測し、現実的な<a class="link" href="glossary.html#glos_workload" title="ワークロード">ワークロード</a>で各動作のパフォーマンスを確認します。
        </p></li><li class="listitem"><p>
          <code class="literal">KEY_BLOCK_SIZE</code> 値は、ヒントとして処理されます。<code class="literal">InnoDB</code> では、必要に応じて異なるサイズが使用される可能性があります。値 0 は、<code class="literal">innodb_page_size</code> 値の半分であるデフォルトの圧縮済みページサイズを表します。<code class="literal">KEY_BLOCK_SIZE</code> は、<code class="literal">innodb_page_size</code> 値以下にしかできません。<code class="literal">innodb_page_size</code> 値を超える値を指定した場合は、指定された値が無視され、警告が発行されます。また、<code class="literal">KEY_BLOCK_SIZE</code> は <code class="literal">innodb_page_size</code> 値の半分に設定されます。<code class="literal">innodb_strict_mode=ON</code> の場合、無効な <code class="literal">KEY_BLOCK_SIZE</code> 値を指定するとエラーが返されます。
        </p></li><li class="listitem"><p>
          パフォーマンス関連の追加の構成オプションについては、<a class="xref" href="innodb-storage-engine.html#innodb-compression-tuning" title="14.7.3 InnoDB テーブルの圧縮の調整">セクション14.7.3「InnoDB テーブルの圧縮の調整」</a>を参照してください。
        </p></li></ul></div><p>
      <code class="literal">InnoDB</code> データ<a class="link" href="glossary.html#glos_page" title="ページ">ページ</a>のデフォルトの非圧縮サイズは、16K バイトです。オプション値の組み合わせに応じて、MySQL ではテーブルの <code class="literal">.ibd</code> ファイルに対応した 1K バイト、2K バイト、4K バイト、8K バイト、または 16K バイトのページサイズが使用されます。実際の圧縮アルゴリズムは、<code class="literal">KEY_BLOCK_SIZE</code> 値の影響を受けません。この値によって、各圧縮済みチャンクの大きさが決定されるため、各圧縮済みページに詰め込むことができる行数が影響を受けます。
    </p><p>
      一般に、<code class="literal">KEY_BLOCK_SIZE</code> を <code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_page_size" title="page size">ページサイズ</a>に等しい値に設定しても、大量の圧縮は発生しません。たとえば、<code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_page_size" title="page size">ページサイズ</a>は 16K バイトであるため、一般に <code class="literal">KEY_BLOCK_SIZE=16</code> を設定しても、大量の圧縮は発生しません。多くの場合、このような値で適切に圧縮されるため、この設定は多くの長い <code class="literal">BLOB</code>、<code class="literal">VARCHAR</code>、または <code class="literal">TEXT</code> カラムを持つテーブルで引き続き役立つことがあります。したがって、<a class="xref" href="innodb-storage-engine.html#innodb-compression-internals" title="14.7.5 InnoDB テーブルでの圧縮の動作">セクション14.7.5「InnoDB テーブルでの圧縮の動作」</a>で説明したように、必要となる<a class="link" href="glossary.html#glos_overflow_page" title="オーバーフローページ">オーバーフローページ</a>が少なくなる可能性もあります。
    </p><p>
      テーブルのすべてのインデックス (<a class="link" href="glossary.html#glos_clustered_index" title="クラスタ化されたインデックス">クラスタ化されたインデックス</a>を含む) は、<code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> ステートメントで指定されたものと同じページサイズを使用して圧縮されます。<code class="literal">ROW_FORMAT</code> や <code class="literal">KEY_BLOCK_SIZE</code> などのテーブル属性は、<code class="literal">InnoDB</code> テーブルの <code class="literal">CREATE INDEX</code> 構文の一部ではないため、指定しても無視されます (ただし、<code class="literal">SHOW CREATE TABLE</code> ステートメントの出力には表示されます)。
    </p><h4><a name="idm139979072502784"></a>圧縮テーブル上の制約</h4><p>
      バージョン 5.1 よりも前の MySQL では圧縮テーブルを処理できないため、圧縮を使用するには、偶然に互換性の問題が発生することを回避するために、<code class="literal">innodb_file_format=Barracuda</code> 構成パラメータを指定する必要があります。
    </p><p>
      テーブルの圧縮は、InnoDB の<a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">システムテーブルスペース</a>でも使用できません。システムテーブルスペース (スペース 0、<code class="literal">ibdata*</code> ファイル) にはユーザーデータを含めることができますが、内部システム情報も含まれているため、圧縮されません。そのため、圧縮は独自のテーブルスペースに格納されているテーブル (およびインデックス) にのみ適用されます。つまり、<code class="literal">innodb_file_per_table</code> オプションが有効になっている状態で作成されます。
    </p><p>
      句の名前が <code class="literal">ROW_FORMAT</code> であるにもかかわらず、圧縮は個別の行にではなく、テーブル全体およびそれに関連付けられたすべてのインデックスに適用されます。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-compression-tuning"></a>14.7.3 InnoDB テーブルの圧縮の調整</h3></div></div></div><a class="indexterm" name="idm139979072493536"></a><a class="indexterm" name="idm139979072491392"></a><p>
      ほとんどの場合、<a class="xref" href="innodb-storage-engine.html#innodb-compression-internals-storage" title="InnoDB データストレージと圧縮">InnoDB Data Storage and Compression</a>で説明した内部的な最適化によって、圧縮済みデータを使用してもシステムは適切に動作します。ただし、圧縮の効率性はデータの特性によって異なるため、圧縮テーブルのパフォーマンスに影響を与える決定を行うことができます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          圧縮するテーブル。
        </p></li><li class="listitem"><p>
          使用する圧縮済みページサイズ。
        </p></li><li class="listitem"><p>
          実行時のパフォーマンス特性 (システムでデータの圧縮および圧縮解除に要する時間など) に基づいて、バッファープールのサイズを調整するかどうか。ワークロードが<a class="link" href="glossary.html#glos_data_warehouse" title="データウェアハウス">データウェアハウス</a> (主にクエリー) または <a class="link" href="glossary.html#glos_oltp" title="OLTP">OLTP</a> システム (クエリーと <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> の混在) に似ているかどうか。
        </p></li><li class="listitem"><p>
          システムの圧縮テーブル上で DML 操作が実行されているときに、データを配布する方法によって実行時に負荷の高い<a class="link" href="glossary.html#glos_compression_failure" title="圧縮失敗">圧縮が失敗</a>する場合は、追加の高度な構成オプションを調整することがあります。
        </p></li></ul></div><p>
      このセクションのガイドラインを使用すると、このようなアーキテクチャー上および構成上の選択を行う際に役立ちます。長期間のテストを実施し、圧縮テーブルを本番環境に移行する準備ができたら、これらの選択を現実の状況で行なった場合の効率性を検証する方法について、<a class="xref" href="innodb-storage-engine.html#innodb-compression-tuning-monitoring" title="14.7.4 実行時の圧縮のモニタリング">セクション14.7.4「実行時の圧縮のモニタリング」</a>を参照してください。
    </p><h4><a name="innodb-compression-tuning-when"></a>圧縮を使用するタイミング</h4><p>
      一般に、圧縮は、適当な数の文字列カラムが含まれ、データの書き込みよりも読み取りの頻度の方がはるかに高いテーブルで最適に動作します。特定の状況で圧縮の利点が得られるかどうかを予測するための保証された方法はないため、必ず、代表的な構成で実行する特定の<a class="link" href="glossary.html#glos_workload" title="ワークロード">ワークロード</a>およびデータセットをテストしてください。圧縮するテーブルを決定する際は、次の要素を検討してください。
    </p><h4><a name="innodb-compression-tuning-when-data"></a>データの特性と圧縮</h4><a class="indexterm" name="idm139979072472560"></a><p>
      データファイルのサイズを削減する際に圧縮の効率性の決定要因となるものは、データ自体の特性です。圧縮は、データのブロックで繰り返されるバイト文字列を識別することで動作していることを思い出してください。完全にランダム化されたデータは、最悪のケースです。多くの場合、一般的なデータには繰り返し値が含まれているため、効率的に圧縮されます。<code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、<code class="literal">TEXT</code>、または <code class="literal">BLOB</code> のいずれのカラムに定義されているのかに関係なく、多くの場合、文字列は効率的に圧縮されます。その一方で、一般に、ほとんどがバイナリデータ (整数または浮動小数) や以前に圧縮されたデータ (<acronym class="acronym">JPEG</acronym> または <acronym class="acronym">PNG</acronym> イメージなど) を含むテーブルは、大幅にまたはまったく効率的に圧縮されない可能性があります。
    </p><p>
      InnoDB テーブルごとに圧縮を有効にするかどうかを選択します。テーブルおよびそのすべてのインデックスでは、同じ (圧縮済み) <a class="link" href="glossary.html#glos_page_size" title="page size">ページサイズ</a>が使用されます。すべてのテーブルカラムのデータを含む<a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a> (クラスタ化) インデックスは、セカンダリインデックスよりも効率的に圧縮される可能性があります。長い行が存在する場合に圧縮を使用すると、<a class="xref" href="innodb-storage-engine.html#innodb-row-format-dynamic" title="14.9.3 DYNAMIC および COMPRESSED 行フォーマット">セクション14.9.3「DYNAMIC および COMPRESSED 行フォーマット」</a>で説明したように、長いカラム値が<span class="quote">「<span class="quote">オフページ</span>」</span>に格納される可能性があります。このようなオーバーフローページは、効率的に圧縮される可能性があります。これらの検討事項を考慮すると、多くのアプリケーションでは、一部のテーブルがその他よりも効率的に圧縮され、圧縮されたテーブルのサブセットを含むワークロードのみが最適に動作する場合もあります。
    </p><p>
      特定のテーブルを圧縮するかどうかを決定するには、実験を行います。非圧縮テーブルの <a class="link" href="glossary.html#glos_ibd_file" title=".ibd ファイル">.ibd ファイル</a>のコピー上に、LZ77 圧縮 (<code class="literal">gzip</code> や WinZip など) が実装されたユーティリティーを使用すると、データを圧縮する際の効率性の概算見積もりを取得できます。MySQL では<a class="link" href="glossary.html#glos_page_size" title="page size">ページサイズ</a> (デフォルトは 16K バイト) に基づいたチャンク単位でデータが圧縮されるため、MySQL で圧縮されたテーブルからは、ファイルベースの圧縮ツールよりも低い圧縮率が得られると予測できます。ページ形式には、ユーザーデータに加えて、圧縮されていない内部システムデータもいくつか含まれます。ファイルベースの圧縮ユーティリティーでは、さらに大きなデータチャンクを調査できるため、MySQL の各ページで見つかるよりも多くの繰り返し文字列が巨大なファイルで見つかる可能性があります。
    </p><p>
      特定のテーブル上で圧縮をテストするもう 1 つの方法は、いくつかのデータを非圧縮テーブルから同様の (同じインデックスをすべて含む) 圧縮テーブルにコピーし、結果として生成される <code class="literal">.ibd</code> ファイルのサイズを確認することです。例:
    </p><pre class="programlisting">
use test;
set global innodb_file_per_table=1;
set global innodb_file_format=Barracuda;
set global autocommit=0;

-- Create an uncompressed table with a million or two rows.
create table big_table as select * from information_schema.columns;
insert into big_table select * from big_table;
insert into big_table select * from big_table;
insert into big_table select * from big_table;
insert into big_table select * from big_table;
insert into big_table select * from big_table;
insert into big_table select * from big_table;
insert into big_table select * from big_table;
insert into big_table select * from big_table;
insert into big_table select * from big_table;
insert into big_table select * from big_table;
commit;
alter table big_table add id int unsigned not null primary key auto_increment;

show create table big_table\G

select count(id) from big_table;

-- Check how much space is needed for the uncompressed table.
\! ls -l data/test/big_table.ibd

create table key_block_size_4 like big_table;
alter table key_block_size_4 key_block_size=4 row_format=compressed;

insert into key_block_size_4 select * from big_table;
commit;

-- Check how much space is needed for a compressed table
-- with particular compression settings.
\! ls -l data/test/key_block_size_4.ibd
</pre><p>
      この実験では、次のような数値が生成されました。当然、テーブル構造やデータによって、数値が大幅に異なる可能性があります。
    </p><pre class="programlisting">
-rw-rw----  1 cirrus  staff  310378496 Jan  9 13:44 data/test/big_table.ibd
-rw-rw----  1 cirrus  staff  83886080 Jan  9 15:10 data/test/key_block_size_4.ibd
</pre><p>
      特定の<a class="link" href="glossary.html#glos_workload" title="ワークロード">ワークロード</a>で圧縮が効率的かどうかを確認するには:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          単純なテストでは、その他の圧縮テーブルが含まれない MySQL インスタンスを使用して、<code class="literal">INFORMATION_SCHEMA.INNODB_CMP</code> テーブルに対してクエリーを実行します。
        </p></li><li class="listitem"><p>
          複数の圧縮テーブルが含まれるワークロードが関与するより詳細なテストでは、<code class="literal">INFORMATION_SCHEMA.INNODB_CMP_PER_INDEX</code> テーブルに対してクエリーを実行します。<code class="literal">INNODB_CMP_PER_INDEX</code> テーブルの統計を収集すると負荷が高くなるため、そのテーブルのクエリーを実行する前に、<code class="literal">innodb_cmp_per_index_enabled</code> 構成オプションを有効にする必要があります。このようなテストは、開発サーバーやクリティカルでない<a class="link" href="glossary.html#glos_slave_server" title="スレーブサーバー">スレーブサーバー</a>に限定されることもあります。
        </p></li><li class="listitem"><p>
          テスト中の圧縮テーブルに対して、一般的な SQL ステートメントをいくつか実行します。
        </p></li><li class="listitem"><p>
          <code class="literal">INFORMATION_SCHEMA.INNODB_CMP</code> または <code class="literal">INFORMATION_SCHEMA.INNODB_CMP_PER_INDEX</code> テーブルのクエリーを実行し、<code class="literal">COMPRESS_OPS</code> と <code class="literal">COMPRESS_OPS_OK</code> を比較することで、圧縮操作全体に対する正常な圧縮操作の比率を調査します。
        </p></li><li class="listitem"><p>
          圧縮操作が正常に完了した比率が高い場合は、そのテーブルが圧縮対象の候補である可能性が高くなります。
        </p></li><li class="listitem"><p>
          <a class="link" href="glossary.html#glos_compression_failure" title="圧縮失敗">圧縮が失敗</a>する比率が高い場合は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-compression-oltp" title="14.7.6 OLTP ワークロードの圧縮">セクション14.7.6「OLTP ワークロードの圧縮」</a>で説明したように、<code class="literal">innodb_compression_level</code>、<code class="literal">innodb_compression_failure_threshold_pct</code>、および <code class="literal">innodb_compression_pad_pct_max</code> オプションを調整すれば、さらに詳細なテストを試すことができます。
        </p></li></ul></div><h4><a name="innodb-compression-application"></a>データベースの圧縮とアプリケーションの圧縮</h4><a class="indexterm" name="idm139979072427264"></a><p>
      アプリケーション内とテーブル内のどちらでデータを圧縮するかどうかを決定します。同じデータで両方のタイプの圧縮を使用しないでください。アプリケーション内でデータを圧縮し、その結果を圧縮テーブルに格納すると、追加の領域が節約される可能性は大幅に低くなり、二重圧縮によって単に CPU サイクルが無駄になるだけです。
    </p><h4><a name="innodb-compression-in-database"></a>データベース内での圧縮</h4><p>
      これを有効にすると、MySQL テーブルの圧縮は自動的になり、すべてのカラムおよびインデックス値に適用されます。<code class="literal">LIKE</code> などの演算子を含むカラムも引き続きテストでき、インデックス値が圧縮されている場合でも、ソート操作でインデックスを引き続き使用できます。多くの場合、インデックスがデータベースの合計サイズの相当な割合を占めるため、圧縮を使用すると、ストレージ、I/O、またはプロセッサ時間が大幅に節約される可能性があります。圧縮および圧縮解除の操作は、予期される負荷を処理できるようにサイズ変更された強力なシステムとなる可能性が高いデータベースサーバー上で発生します。
    </p><h4><a name="innodb-compression-in-application"></a>アプリケーション内での圧縮</h4><p>
      テキストなどのデータをアプリケーション内で圧縮してから、データベースに挿入する場合は、一部のカラムは圧縮されるが、その他は圧縮されないことで効率的に圧縮されないデータで、オーバーヘッドが節約される可能性があります。このアプローチでは、圧縮および圧縮解除用の CPU サイクルがデータベースサーバー上ではなく、クライアントマシン上で使用されるため、多数のクライアントが含まれる分散アプリケーションや、予備の CPU サイクルを備えたクライアントマシンに適している場合があります。
    </p><h4><a name="innodb-compression-hybrid"></a>ハイブリッドアプローチ</h4><p>
      当然、これらのアプローチは組み合わせることができます。一部のアプリケーションでは、いくつかの圧縮テーブルといくつかの非圧縮テーブルを使用することが適切である場合があります。一部のデータを外部で圧縮して (それを非圧縮テーブルに格納して)、アプリケーション内のその他のテーブル (の一部) を MySQL で圧縮できるようにすることが最適な方法である場合もあります。通常どおり、適切な決定に達するには、事前の設計および現実のテストが重要となります。
    </p><h4><a name="innodb-compression-tuning-when-workload"></a>ワークロードの特性と圧縮</h4><a class="indexterm" name="idm139979072413088"></a><p>
      圧縮するテーブル (およびページサイズ) を選択することに加えて、ワークロードはもう 1 つのパフォーマンスの主要な決定要因でもあります。アプリケーションが更新ではなく、読み取りで占有されている場合は、圧縮済みデータ用に MySQL で保持されるページごとの<span class="quote">「<span class="quote">変更ログ</span>」</span>用の空き領域がインデックスページによって使い果たされたあとに、再編成および再圧縮する必要のあるページが少なくなります。更新によって、インデックスなしのカラムまたはそれらが含まれている <code class="literal">BLOB</code> や、偶然に<span class="quote">「<span class="quote">オフページ</span>」</span>に格納される大きな文字列が主に変更される場合は、圧縮のオーバーヘッドが許容可能になる可能性があります。単調に増加する主キーを使用する <code class="literal">INSERT</code> がテーブルへの唯一の変更であり、セカンダリインデックスがほとんどない場合は、インデックスページを再編成および再圧縮する必要もほとんどありません。MySQL では、非圧縮データを変更することで、<span class="quote">「<span class="quote">適切に</span>」</span>、圧縮済みページ上のデータに<span class="quote">「<span class="quote">削除マークを付け</span>」</span>てから削除できるため、テーブル上の <code class="literal">DELETE</code> 操作は比較的効率的に行われます。
    </p><p>
      環境によっては、データのロードに要する時間がリアルタイム検索と同じくらいに重要である場合があります。特にデータウェアハウス環境では、数多くのテーブルが読み取り専用または読み取りが大半になっている可能性があります。このような場合、結果として少数のディスク読み取りとストレージコストの節約が重要である場合を除いて、ロード時間が長くなるという点で圧縮の犠牲を払うことが許容できる場合と、許容できない場合があります。
    </p><p>
      本来は、データを圧縮および圧縮解除する際に CPU 時間を使用できるときに、圧縮が最適に動作します。そのため、ワークロードが CPU バウンドではなく、I/O バウンドである場合に、圧縮を使用することで全体的なパフォーマンスを改善できることがわかるでしょう。さまざまな圧縮構成でアプリケーションのパフォーマンスをテストする際は、計画した本番システム構成と同様のプラットフォーム上でテストしてください。
    </p><h4><a name="innodb-compression-tuning-when-config"></a>構成の特性と圧縮</h4><a class="indexterm" name="idm139979072400960"></a><p>
      データベース<a class="link" href="glossary.html#glos_page" title="ページ">ページ</a>のディスクからの読み取りとディスクへの書き込みは、システムパフォーマンスのもっとも低速な側面です。圧縮では、CPU 時間を使用してデータを圧縮および圧縮解除することで I/O の削減が試みられるため、プロセッササイクルと比べて、I/O が比較的少ないリソースであるときに、もっとも効率性が高くなります。
    </p><p>
      多くの場合、これは特に、高速のマルチコア CPU が搭載された複数ユーザー環境で動作しているときに当てはまります。圧縮テーブルのページがメモリー内にあるときは、MySQL では多くの場合、ページの非圧縮コピー用の<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>内で追加のメモリー (一般に 16K バイト) が使用されます。適応型 LRU アルゴリズムでは、I/O バウンドと CPU バウンドのどちらの方式でワークロードが動作しているのかに関係なく、考慮される圧縮済みページと非圧縮ページ間でメモリー使用のバランスを調整しようと試みられます。メモリーが非常に制約されている構成よりも、バッファープール専用のメモリーがより多く搭載された構成の方が、圧縮テーブルを使用するときに適切に動作する傾向があります。
    </p><h4><a name="innodb-compression-tuning-when-size"></a>圧縮済みページサイズの選択</h4><a class="indexterm" name="idm139979072392544"></a><a class="indexterm" name="idm139979072390512"></a><a class="indexterm" name="idm139979072388592"></a><a class="indexterm" name="idm139979072386560"></a><p>
      圧縮済みページサイズの最適な設定は、テーブルおよびそのインデックスに含まれるデータの型および分布によって異なります。圧縮済みページのサイズは、常に最大のレコードサイズよりも大きくするようにしてください。そうでなければ、<a class="xref" href="innodb-storage-engine.html#innodb-compression-internals-storage-btree" title="B ツリーページの圧縮">Compression of B-Tree Pages</a>で注記したように、操作に失敗する可能性があります。
    </p><p>
      圧縮済みページサイズの設定が大きすぎると、一部の領域が無駄になりますが、頻繁にページを圧縮する必要はなくなります。圧縮済みページサイズが小さすぎると、挿入時または更新時に時間のかかる再圧縮が必要になる可能性があり、より頻繁な B ツリーノードの分割が必要になる可能性もあります。これにより、データファイルが大きくなり、インデックス作成の効率性が低くなります。
    </p><p>
      一般に、圧縮済みページサイズは 8K バイトまたは 4K バイトに設定されます。InnoDB テーブルの最大行サイズが約 8K とすれば、通常、<code class="literal">KEY_BLOCK_SIZE=8</code> は安全な選択です。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-compression-tuning-monitoring"></a>14.7.4 実行時の圧縮のモニタリング</h3></div></div></div><a class="indexterm" name="idm139979072378608"></a><p>
      アプリケーション全体のパフォーマンス、CPU と I/O の使用率、およびディスクファイルのサイズは、アプリケーションでの圧縮の効率姓を示す適切な指標です。このセクションは、<a class="xref" href="innodb-storage-engine.html#innodb-compression-tuning" title="14.7.3 InnoDB テーブルの圧縮の調整">セクション14.7.3「InnoDB テーブルの圧縮の調整」</a>に示したパフォーマンスチューニングのアドバイスに基づいて構成され、初期のテスト時には発生する可能性のない問題を見つける方法を示しています。
    </p><p>
      圧縮テーブルのパフォーマンス上の考慮事項をさらに深く掘り下げるには、<a class="xref" href="innodb-storage-engine.html#innodb-information-schema-examples-compression" title="例 14.10 圧縮情報スキーマテーブルの使用">例14.10「圧縮情報スキーマテーブルの使用」</a>に記載した<a class="link" href="glossary.html#glos_information_schema" title="INFORMATION_SCHEMA">「情報スキーマ」</a>テーブルを使用すれば、実行時に圧縮のパフォーマンスをモニターできます。これらのテーブルは、メモリーの内部使用および全体的に使用される圧縮の比率を反映しています。
    </p><p>
      <code class="literal">INNODB_CMP</code> テーブルには、使用中の圧縮済みページサイズ (<code class="literal">KEY_BLOCK_SIZE</code>) ごとに、圧縮アクティビティーに関する情報がレポートされます。これらのテーブル内の情報は、システム全体のものであり、データベース内のすべての圧縮テーブルにわたる圧縮の統計を集約したものです。このデータを使用すると、その他の圧縮テーブルがアクセスしていないときに、これらのテーブルを調査することでテーブルを圧縮するかどうかを決定する際に役立ちます。これには、サーバー上で比較的小さいオーバーヘッドが伴うため、圧縮失敗の全体的な効率性をチェックするために、本番環境サーバー上で定期的にクエリーを実行することがあります。
    </p><p>
      <code class="literal">INNODB_CMP_PER_INDEX</code> テーブルには、個別のテーブルおよびインデックスごとに、圧縮アクティビティーに関する情報がレポートされます。この情報は、圧縮の効率性を評価し、一度に 1 つのテーブルまたはインデックスのパフォーマンス問題を診断する際に、より的を絞ることができ、より役立ちます。(各 <code class="literal">InnoDB</code> テーブルはクラスタ化されたインデックスとして表されるため、このコンテキストでは、MySQL でテーブルとインデックス間で大きな区別が行われません。)<code class="literal">INNODB_CMP_PER_INDEX</code> テーブルには大量のオーバーヘッドが伴うため、さまざまな<a class="link" href="glossary.html#glos_workload" title="ワークロード">ワークロード</a>、データ、および圧縮設定の効果を分離して比較できる開発サーバーにより適しています。このモニタリングのオーバーヘッドが誤って課されることを防ぐには、<code class="literal">INNODB_CMP_PER_INDEX</code> テーブルのクエリーを実行する前に、<code class="literal">innodb_cmp_per_index_enabled</code> 構成オプションを有効にする必要があります。
    </p><p>
      考慮するべき主要な統計は、圧縮および圧縮解除操作の数、および実行に要する時間数です。B ツリーノードがいっぱいになって、変更後に圧縮済みデータを含めることができなくなると、MySQL によって B ツリーノードが分割されるため、<span class="quote">「<span class="quote">正常な</span>」</span>圧縮操作の数と、このような操作全体の数を比較します。<code class="literal">INNODB_CMP</code> および <code class="literal">INNODB_CMP_PER_INDEX</code> テーブル内の情報、およびアプリケーション全体のパフォーマンスとハードウェアリソースの使用率に基づいて、ハードウェア構成の変更を行なったり、バッファープールのサイズを調整したり、別のページサイズを選択したり、圧縮する別のテーブルセットを選択したりすることがあります。
    </p><p>
      圧縮および圧縮解除するために必要な CPU 時間の合計が大きい場合は、高速またはマルチコアの CPU に変更すると、同じデータ、アプリケーションのワークロード、および圧縮テーブルのセットを使用してパフォーマンスを改善する際に役立つことがあります。バッファープールのサイズを大きくすると、パフォーマンスの改善に役立つこともあります。これにより、より多くの非圧縮ページをメモリー内に滞在できるようになるため、圧縮形式でのみメモリー内に存在するページを圧縮解除する必要が少なくなります。
    </p><p>
      (アプリケーションでの <code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、および <code class="literal">DELETE</code> 操作の数、およびデータベースのサイズと比較して) 圧縮操作全体の数が大きい場合は、効率的な圧縮としては、圧縮テーブルの一部が更新される頻度が高すぎることを示している可能性があります。その場合は、より大きなページサイズを選択するか、圧縮するテーブルをより慎重に選択してください。
    </p><p>
      <span class="quote">「<span class="quote">正常な</span>」</span>圧縮操作の数 (<code class="literal">COMPRESS_OPS_OK</code>) が圧縮操作の合計数 (<code class="literal">COMPRESS_OPS</code>) の高い比率を占めている場合は、システムが正常に実行されている可能性が高くなります。比率が低い場合は、MySQL によって理想よりも頻繁に、B ツリーノードの再編成、再圧縮、および分割が行われます。この場合、一部のテーブルの圧縮を回避するか、圧縮テーブルの一部で <code class="literal">KEY_BLOCK_SIZE</code> を大きくしてください。テーブルの圧縮をオフにすると、アプリケーション内での<span class="quote">「<span class="quote">圧縮失敗</span>」</span>の数が合計の 1% または 2% を上回る可能性があります。(このような失敗の比率は、データのロードなどの一時的な操作時には許容範囲内である場合もあります)。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-compression-internals"></a>14.7.5 InnoDB テーブルでの圧縮の動作</h3></div></div></div><a class="indexterm" name="idm139979072345952"></a><p>
      このセクションでは、InnoDB テーブルの<a class="link" href="glossary.html#glos_compression" title="圧縮">圧縮</a>に関する一部の内部実装について詳細に説明します。ここで示す情報は、パフォーマンスを調整する際に役立つことがありますが、圧縮の基本的な使用を理解する必要はありません。
    </p><h4><a name="innodb-compression-internals-algorithms"></a>圧縮アルゴリズム</h4><a class="indexterm" name="idm139979072341040"></a><p>
      一部のオペレーティングシステムでは、ファイルシステムのレベルで圧縮が実装されています。一般に、ファイルは、可変サイズのブロックに圧縮される固定サイズのブロックに分割されるため、簡単に断片化されます。ブロック内部で何かが変更されるたびに、ブロック全体が再圧縮されてからディスクに書き込まれます。これらのプロパティーを使用すると、この圧縮方法が更新の多いデータベースシステムでの使用には適さなくなります。
    </p><p>
      MySQL では、LZ77 圧縮アルゴリズムが実装されている有名な <a class="ulink" href="http://www.zlib.net/" target="_top">zlib ライブラリ</a>の支援を得て、圧縮が実装されています。この圧縮アルゴリズムは十分に発達し、強固であり、CPU の使用率とデータサイズの削減の両方の点で効率的です。このアルゴリズムは<span class="quote">「<span class="quote">損失なし</span>」</span>であるため、常に、元の非圧縮データを圧縮形式から再構築できます。LZ77 圧縮は、圧縮されるデータ内で繰り返される一連のデータを見つけることで動作します。データ内の値のパターンによって、圧縮の効率性が決定されますが、多くの場合、一般的なユーザーデータは 50% 以上圧縮されます。
    </p><p>
      アプリケーションで実行される圧縮や、その他の一部のデータベース管理システムの圧縮機能とは異なり、InnoDB の圧縮は、ユーザーデータとインデックスの両方に適用されます。多くの場合、インデックスがデータベースの合計サイズの 40-50% 以上を占める可能性があるため、この相違点は重要です。データセットの圧縮が正常に動作しているときは、InnoDB のデータファイル (<code class="literal">.idb</code> ファイル) のサイズが非圧縮サイズの 25% - 50%、場合によってはそれよりも小さくなります。<a class="link" href="glossary.html#glos_workload" title="ワークロード">ワークロード</a>によっては、このようにデータベースを小さくすることにより、CPU 使用率を少し増加させるだけで I/O を削減してスループットを増加できます。<code class="literal">innodb_compression_level</code> 構成オプションを変更すると、圧縮のレベルと CPU のオーバーヘッド間のバランスを調整できます。
    </p><h4><a name="innodb-compression-internals-storage"></a>InnoDB データストレージと圧縮</h4><a class="indexterm" name="idm139979169035008"></a><p>
      InnoDB テーブル内のすべてのユーザーデータは、<a class="link" href="glossary.html#glos_b_tree" title="B ツリー">B ツリー</a>インデックス (<a class="link" href="glossary.html#glos_clustered_index" title="クラスタ化されたインデックス">クラスタ化されたインデックス</a>) を構成しているページに格納されます。その他の一部のデータベースシステムでは、このタイプのインデックスは<span class="quote">「<span class="quote">インデックス編成テーブル</span>」</span>と呼ばれます。インデックスノード内の各行には、(ユーザーが指定した、またはシステムで生成された) <a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a>の値およびテーブルのその他のすべてのカラムが含まれています。
    </p><p>
      InnoDB テーブル内の<a class="link" href="glossary.html#glos_secondary_index" title="セカンダリインデックス">セカンダリインデックス</a>は、値のペア (インデックスキーと、クラスタ化されたインデックス内の行へのポインタ) を含む B ツリーでもあります。実際は、ポインタはテーブルの主キーの値であり、インデックスキーおよび主キー以外のカラムが必要な場合に、クラスタ化されたインデックスにアクセスする際に使用されます。常に、セカンダリインデックスのレコードは、B ツリーページ上に収容される必要があります。
    </p><p>
      次のセクションで説明するように、(クラスタ化インデックスとセカンダリインデックスの両方の) B ツリーノードの圧縮は、長い <code class="literal">VARCHAR</code>、<code class="literal">BLOB</code>、または <code class="literal">TEXT</code> カラムを格納するために使用される<a class="link" href="glossary.html#glos_overflow_page" title="オーバーフローページ">オーバーフロー</a>の圧縮とは異なる方法で処理されます。
    </p><h4><a name="innodb-compression-internals-storage-btree"></a>B ツリーページの圧縮</h4><a class="indexterm" name="idm139979072299824"></a><p>
      B ツリーページは頻繁に更新されるため、特別な処理が必要です。B ツリーノードが分割される回数を最小限にし、それらの内容を圧縮解除および再圧縮する必要性も最小限にすることが重要となります。
    </p><p>
      MySQL で使用される技術の 1 つでは、一部のシステム情報が非圧縮形式で B ツリーノード内に保持されるため、特定のインプレース更新が容易になります。たとえば、これにより、圧縮操作なしで行に削除のマークを付け、その行を削除できます。
    </p><p>
      さらに、MySQL では、インデックスページが変更されたときに、不要な圧縮解除および再圧縮を回避しようと試みられます。システムの各 B ツリーページ内には、ページに行われた変更を記録するための非圧縮の<span class="quote">「<span class="quote">変更ログ</span>」</span>が保持されます。小さいレコードの更新および挿入は、ページ全体を完全に再構築する必要なしで、この変更ログに書き込まれる場合があります。
    </p><p>
      変更ログ用の領域を使い果たすと、InnoDB によってページが圧縮解除され、変更が適用され、ページが再圧縮されます。再圧縮に失敗すると (<a class="link" href="glossary.html#glos_compression_failure" title="圧縮失敗">圧縮の失敗</a>と呼ばれる状況)、B ツリーノードが分割され、更新または挿入に成功するまでプロセスが繰り返されます。
    </p><p>
      <a class="link" href="glossary.html#glos_oltp" title="OLTP">OLTP</a> アプリケーションなどで、書き込み負荷の高いワークロードでの頻繁な圧縮の失敗を回避するために、MySQL では、ページ内にいくつかの空のスペース (パディング) が予約されている場合があります。これにより、変更ログがより早く埋められ、分割を回避するための十分な空き領域がまだある間にページが再圧縮されます。各ページに残されるパディングスペースの量は、システムでページ分割の頻度が追跡されるにつれて変化します。圧縮テーブルへの書き込みが頻繁に行われる高負荷のサーバー上では、<code class="literal">innodb_compression_failure_threshold_pct</code> および <code class="literal">innodb_compression_pad_pct_max</code> 構成オプションを調整すると、このメカニズムを微調整できます。
    </p><p>
      一般に、MySQL では、InnoDB テーブル内の各 B ツリーページに 2 つ以上のレコードを収容できます。圧縮テーブルに対しては、この要件が緩和されました。B ツリーノードのリーフページには (主キーとセカンダリインデックスのどちらでも)、1 つのレコードのみが収容される必要がありますが、そのレコードはページごとの変更ログに非圧縮形式で収まる必要があります。<code class="literal">innodb_strict_mode</code> が <code class="literal">ON</code> の場合は、<code class="literal">CREATE TABLE</code> または <code class="literal">CREATE INDEX</code> の実行中に、MySQL によって行の最大サイズがチェックされます。行が収まらない場合は、<code class="literal">「ERROR HY000: Too big row」</code>というエラーメッセージが発行されます。
    </p><p>
      <code class="literal">innodb_strict_mode</code> が OFF のときにテーブルを作成した場合に、後続の <code class="literal">INSERT</code> または <code class="literal">UPDATE</code> ステートメントで圧縮済みページのサイズに収まらないインデックスエントリの作成が試みられると、その操作に失敗し、<code class="literal">「ERROR 42000: Row size too large」</code>というエラーが表示されます。(このエラーメッセージは、レコードが長すぎるインデックスの名前を示すものでも、その特定のインデックスページ上のインデックスレコードの長さや最大レコードサイズを示すものでもありません。)この問題を解決するには、<code class="literal">ALTER TABLE</code> を使用してテーブルを再構築し、より大きな圧縮済みページサイズ (<code class="literal">KEY_BLOCK_SIZE</code>) を選択して、任意のカラムプリフィクスのインデックスを短くするか、<code class="literal">ROW_FORMAT=DYNAMIC</code> または <code class="literal">ROW_FORMAT=COMPACT</code> を使用して圧縮を完全に無効にします。
    </p><h4><a name="innodb-compression-internals-storage-blobs"></a>BLOB、VARCHAR、および TEXT カラムの圧縮</h4><a class="indexterm" name="idm139979072272368"></a><a class="indexterm" name="idm139979072270160"></a><a class="indexterm" name="idm139979072268224"></a><a class="indexterm" name="idm139979072266192"></a><p>
      InnoDB テーブルでは、主キーの一部ではない <code class="literal">BLOB</code>、<code class="literal">VARCHAR</code>、および <code class="literal">TEXT</code> カラムが、個別に割り当てられた<a class="link" href="glossary.html#glos_overflow_page" title="オーバーフローページ">オーバーフローページ</a>に格納される場合があります。このようなカラムは、<a class="link" href="glossary.html#glos_off_page_column" title="オフページカラム">オフページカラム</a>と呼ばれています。これらの値は、オーバーフローページの片方向リストに格納されます。
    </p><p>
      <code class="literal">ROW_FORMAT=DYNAMIC</code> または <code class="literal">ROW_FORMAT=COMPRESSED</code> で作成されたテーブルでは、カラムの長さおよび行全体の長さによっては、<code class="literal">BLOB</code>、<code class="literal">TEXT</code>、または <code class="literal">VARCHAR</code> カラムの値が完全にオフページに格納される場合もあります。オフページに格納されるカラムでは、クラスタ化されたインデックスのレコードに、オーバーフローページへの 20 バイトのポインタのみがカラムごとに 1 つずつ含まれます。カラムがオフページに格納されるかどうかは、ページサイズおよび行の合計サイズによって異なります。行がクラスタ化されたインデックスのページ内に完全に収まらないほど長い場合は、クラスタ化されたインデックスページ上に行が収まるまで、MySQL によってオフページストレージに合った最長のカラムが選択されます。前述の注で示したように、行自体が圧縮済みページ上に収まらない場合は、エラーが発生します。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">ROW_FORMAT=DYNAMIC</code> または <code class="literal">ROW_FORMAT=COMPRESSED</code> で作成されたテーブルでは、40 バイト以下の <code class="literal">TEXT</code> および <code class="literal">BLOB</code> カラムは、常にインラインに格納されます。
      </p></div><p>
      古いバージョンの MySQL で作成されたテーブルでは、<code class="literal">ROW_FORMAT=REDUNDANT</code> と <code class="literal">ROW_FORMAT=COMPACT</code> のみがサポートされている <a class="link" href="glossary.html#glos_antelope" title="Antelope">Antelope</a> ファイル形式が使用されます。MySQL では、これらの形式で、クラスタ化されたインデックスレコード内に <code class="literal">BLOB</code>、<code class="literal">VARCHAR</code>、および <code class="literal">TEXT</code> カラムの最初の 768 バイトが主キーとともに格納されます。768 バイトのプリフィクスのあとには、残りのカラム値を含むオーバーフローページへの 20 バイトのポインタが続きます。
    </p><p>
      テーブルの形式が <code class="literal">COMPRESSED</code> である場合は、オーバーフローページに書き込まれるすべてのデータが<span class="quote">「<span class="quote">そのまま</span>」</span>圧縮されます。つまり、MySQL では、データ項目全体に zlib 圧縮アルゴリズムが適用されます。圧縮済みのオーバーフローページには、データ以外では特に、ページチェックサムを構成する非圧縮のヘッダーとトレーラ、および次のオーバーフローページへのリンクが含まれます。したがって、テキストデータを使用した場合に多く見られるように、データの圧縮性が高い場合は、長い <code class="literal">BLOB</code>、<code class="literal">TEXT</code>、または <code class="literal">VARCHAR</code> カラムで非常に大幅なストレージの節約が実現されます。一般に、<code class="literal">JPEG</code> などのイメージデータはすでに圧縮されているため、圧縮テーブルに格納される利点がほとんど得られません。領域の節約がほとんどない、またはまったくない場合は、二重圧縮によって CPU サイクルが無駄になる可能性があります。
    </p><p>
      オーバーフローページのサイズは、その他のページと同じです。カラムの合計長が 8K バイトのみである場合でも、オフページに格納される 10 個のカラムを含む行で、10 個のオーバーフローページが占有されます。非圧縮テーブルでは、10 個の非圧縮オーバーフローページで 160K バイトが占有されます。ページサイズが 8K の圧縮テーブルでは、80K バイトのみが占有されます。そのため、長いカラム値を含むテーブルでは、圧縮テーブル形式を使用すると効率性が高くなることが多くあります。
    </p><p>
      16K の圧縮済みページサイズを使用すると、多くの場合、このようなデータが効率的に圧縮されることで、必要なオーバーフローページが少なくなる可能性があるため、B ツリーノード自体のページ数は非圧縮形式の場合と同じであるにもかかわらず、<code class="literal">BLOB</code>、<code class="literal">VARCHAR</code>、または <code class="literal">TEXT</code> カラムのストレージおよび I/O コストを削減できます。
    </p><h4><a name="innodb-compression-internals-pool"></a>圧縮と InnoDB バッファープール</h4><a class="indexterm" name="idm139979072227040"></a><a class="indexterm" name="idm139979072224848"></a><p>
      圧縮済みの InnoDB テーブル (1K、2K、4、または 8K) は、16K バイト (<code class="literal">innodb_page_size</code> が設定されている場合は、さらに小さいサイズ) の非圧縮ページに対応しています。ページ内のデータにアクセスするために、MySQL は、圧縮済みページが<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>内にすでに存在しない場合、そのページをディスクから読み取ってから、その元の形式に圧縮解除します。このセクションでは、圧縮テーブルのページに関して、バッファープールが InnoDB で管理される方法について説明します。
    </p><p>
      I/O を最小限にして、ページを圧縮解除する必要性を削減するために、バッファープールに圧縮済み形式と非圧縮形式の両方のデータベースページが含まれることがあります。その他の必要なデータベースページ用の空き領域を作成するために、MySQL ではメモリー内に圧縮済みページを残しながら、バッファープールから非圧縮ページを<a class="link" href="glossary.html#glos_eviction" title="エビクション">エビクション</a>できます。また、しばらくの間ページがアクセスされていない場合は、その他のデータ用に領域を解放するために、圧縮形式のページがディスクに書き込まれることもあります。したがって、そのときどきで、バッファープールに圧縮形式と非圧縮形式の両方のページが含まれている場合、圧縮形式のページのみが含まれている場合、どちらも含まれていない場合があります。
    </p><p>
      MySQL では、<a class="link" href="glossary.html#glos_hot" title="ホット">ホット</a> (頻繁にアクセスされる) データがメモリー内に滞在する傾向となるように、最近もっとも使用されていない (<a class="link" href="glossary.html#glos_lru" title="LRU">LRU</a>) リストを使用して、メモリー内に保持されるページおよび削除されるページが追跡されます。圧縮テーブルにアクセスすると、MySQL は適応型 LRU アルゴリズムを使用して、メモリー内の圧縮済みページと非圧縮ページの適切なバランスを実現します。この適応型アルゴリズムは、システムが <a class="link" href="glossary.html#glos_io_bound" title="I/O バウンド">I/O バウンド</a>と <a class="link" href="glossary.html#glos_cpu_bound" title="CPU バウンド">CPU バウンド</a>のどちらの方式で実行されているかどうかの影響を受けやすくなります。この目的は、CPU の負荷が高いときにページを圧縮解除するために要する処理時間が長くなりすぎることを回避すること、および (メモリー内にすでに存在する可能性のある) 圧縮済みページを圧縮解除するために使用できる予備のサイクルが CPU に備わっているときに過剰な I/O が発生することを回避することです。システムが I/O バウンドの場合、このアルゴリズムでは、その他のディスクページ用により多くの空き領域を作成することでメモリーが常駐になるように、ページの両方のコピーではなく、非圧縮コピーを削除することが優先されます。システムが CPU バウンドの場合、MySQL では、<span class="quote">「<span class="quote">ホット</span>」</span>ページ用に使用できるメモリーが多くなり、圧縮形式でのみメモリー内のデータを圧縮解除する必要性が少なくなるように、圧縮済みページと非圧縮ページの両方を削除することが優先されます。
    </p><h4><a name="innodb-compression-internals-log"></a>圧縮と InnoDB の Redo ログファイル</h4><a class="indexterm" name="idm139979072208048"></a><p>
      圧縮済みページが<a class="link" href="glossary.html#glos_data_files" title="データファイル">データファイル</a>に書き込まれる前に、MySQL によってページのコピーが Redo ログに書き込まれます (最後にデータベースに書き込まれた以降に再圧縮された場合)。これは、<code class="literal">zlib</code> ライブラリがアップグレードされ、その変更によって圧縮済みデータとの互換性の問題が発生する可能性が低い場合でも、<a class="link" href="glossary.html#glos_crash_recovery" title="クラッシュリカバリ">クラッシュリカバリ</a>時に Redo ログを使用できるかどうかを確認するために行われます。したがって、圧縮の使用時に、<a class="link" href="glossary.html#glos_log_file" title="ログファイル">ログファイル</a>のサイズを多少大きくすること、またはより頻繁に<a class="link" href="glossary.html#glos_checkpoint" title="チェックポイント">チェックポイント</a>を発生させる必要性を多少多くすることが要求される可能性があります。ログファイルのサイズを大きくする量またはチェックポイントの頻度を多くする数は、再構成および再圧縮が必要となる方法で圧縮済みページが変更される回数によって異なります。
    </p><p>
      圧縮テーブルでは、Redo ログおよびテーブルごとのテーブルスペースに使用されるファイル形式が MySQL 5.1 以前とは異なることに注意してください。<a class="link" href="glossary.html#glos_mysql_enterprise_backup" title="MySQL Enterprise Backup">MySQL Enterprise Backup</a> 製品では、圧縮済み InnoDB テーブル用に、この最新の <a class="link" href="glossary.html#glos_barracuda" title="Barracuda">Barracuda</a> ファイル形式がサポートされています。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-performance-compression-oltp"></a>14.7.6 OLTP ワークロードの圧縮</h3></div></div></div><p>
      従来、<code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_compression" title="圧縮">圧縮</a>機能は、<a class="link" href="glossary.html#glos_data_warehouse" title="データウェアハウス">データウェアハウス</a>構成などで、主に読み取り専用または読み取りが大半の<a class="link" href="glossary.html#glos_workload" title="ワークロード">ワークロード</a>に対して使用することが推奨されていました。高速だが、比較的小型で高価である <a class="link" href="glossary.html#glos_ssd" title="SSD">SSD</a> ストレージデバイスを増加すると、<code class="literal">OLTP</code> ワークロードでも圧縮が魅力的なものとなります。高トラフィックでインタラクティブな Web サイトでは、頻繁に <code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、および <code class="literal">DELETE</code> 操作を実行するアプリケーションで圧縮テーブルを使用することで、ストレージの要件および 1 秒あたりの I/O 操作 (<a class="link" href="glossary.html#glos_iops" title="IOPS">IOPS</a>) を削減できます。
    </p><p>
      MySQL 5.6 で導入された構成オプションを使用すると、書き込み負荷の高い操作のパフォーマンスおよび拡張性に重点を置いて、特定の MySQL インスタンスに合わせて圧縮の動作を調整できます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">innodb_compression_level</code> を使用すると、圧縮の程度を上げたり、下げたりできます。値を大きくすると、ストレージデバイス上に収容できるデータ量が多くなりますが、圧縮時の CPU オーバーヘッドも多くなるという犠牲が伴います。値を小さくすると、ストレージ領域がクリティカルでない場合に、CPU のオーバーヘッドを削減できます。それ以外の場合は、データが特に圧縮可能でないと予測されます。
        </p></li><li class="listitem"><p>
          <code class="literal">innodb_compression_failure_threshold_pct</code> には、圧縮テーブルへの更新時に<a class="link" href="glossary.html#glos_compression_failure" title="圧縮失敗">圧縮が失敗</a>したときのカットオフポイントが指定されます。このしきい値を超えると、MySQL は、最大で <code class="literal">innodb_compression_pad_pct_max</code> で指定されたページサイズの割合まで空き領域の量を動的に調整することで、新しい各圧縮済みページ内に追加の空き領域を残し始めます。
        </p></li><li class="listitem"><p>
          <code class="literal">innodb_compression_pad_pct_max</code> を使用すると、ページ全体を再度圧縮する必要なしで、変更を圧縮済み行に記録するための各<a class="link" href="glossary.html#glos_page" title="ページ">ページ</a>内に予約されている領域の最大量を調整できます。値を大きくすると、ページを再度圧縮せずに記録できる変更の量が多くなります。MySQL では、実行時に指定した割合の圧縮操作に<span class="quote">「<span class="quote"><a class="link" href="glossary.html#glos_compression_failure" title="圧縮失敗">失敗した</a></span>」</span>ときにのみ、各圧縮テーブル内にあるページ用に可変量の空き領域が使用されますが、圧縮済みページを分割するために負荷の高い操作が必要となります。
        </p></li></ul></div><p>
      圧縮済みデータを操作すると、圧縮済みと非圧縮の両方のバージョンのページが同時にメモリー内に保持されるため、OLTP スタイルのワークロードで圧縮を使用するときは、<code class="literal">innodb_buffer_pool_size</code> 構成オプションの値を大きくする準備をしてください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-compression-syntax-warnings"></a>14.7.7 SQL 圧縮構文の警告とエラー</h3></div></div></div><p>
      Barracuda ファイル形式が有効になっていない場合に、<code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> ステートメントで <code class="literal">ROW_FORMAT=COMPRESSED</code> または <code class="literal">KEY_BLOCK_SIZE</code> を指定すると、次のような警告が生成されます。<code class="literal">SHOW WARNINGS</code> ステートメントを使用すると、これらを表示できます。
    </p><div class="informaltable"><table summary="Barracuda ファイル形式を必要とする圧縮機能が使用されると生成される可能性のあるメッセージに対応する警告レベル、エラーコード、およびメッセージテキスト。" border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">レベル</th><th scope="col">コード</th><th scope="col">メッセージ</th></tr></thead><tbody><tr><td scope="row">警告</td><td>1478</td><td><code class="literal">InnoDB: KEY_BLOCK_SIZE requires innodb_file_per_table.</code></td></tr><tr><td scope="row">警告</td><td>1478</td><td><code class="literal">InnoDB: KEY_BLOCK_SIZE requires innodb_file_format=1</code></td></tr><tr><td scope="row">警告</td><td>1478</td><td><code class="literal">InnoDB: ignoring KEY_BLOCK_SIZE=<em class="replaceable"><code>4</code></em>.</code></td></tr><tr><td scope="row">警告</td><td>1478</td><td><code class="literal">InnoDB: ROW_FORMAT=COMPRESSED requires innodb_file_per_table.</code></td></tr><tr><td scope="row">警告</td><td>1478</td><td><code class="literal">InnoDB: assuming ROW_FORMAT=COMPACT.</code></td></tr></tbody></table></div><p>
      注:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          デフォルトでは、これらのメッセージはエラーではなく、単なる警告です。テーブルは、オプションを指定しなかった場合と同様に、圧縮なしで作成されます。
        </p></li><li class="listitem"><p>
          <code class="literal">innodb_strict_mode</code> を有効にすると、MySQL では、このような場合に警告ではなく、エラーが生成されます。現在の構成では圧縮テーブルの使用が許可されていないため、テーブルは作成されません。
        </p></li></ul></div><p>
      <span class="quote">「<span class="quote">厳密でない</span>」</span>動作を使用すると、ソースデータベースに圧縮テーブルが含まれていない場合でも、圧縮テーブルがサポートされていないデータベースに <code class="literal">mysqldump</code> ファイルをインポートできます。この場合、MySQL は操作を回避する代わりに、<code class="literal">ROW_FORMAT=COMPACT</code> 内にテーブルを作成します。
    </p><p>
      新しいデータベースにダンプファイルをインポートし、元のデータベース内に存在するときにテーブルが再作成されるようにするには、サーバーで <code class="literal">innodb_file_format</code> および <code class="literal">innodb_file_per_table</code> 構成パラメータが適切に設定されていることを確認します。
    </p><p>
      <code class="literal">KEY_BLOCK_SIZE</code> 属性は、<code class="literal">ROW_FORMAT</code> が <code class="literal">COMPRESSED</code> として指定されているか、省略されている場合にのみ許可されます。その他の <code class="literal">ROW_FORMAT</code> とともに <code class="literal">KEY_BLOCK_SIZE</code> を指定すると、<code class="literal">SHOW WARNINGS</code> を使用して表示できる警告が生成されます。ただし、テーブルは非圧縮です。つまり、指定された <code class="literal">KEY_BLOCK_SIZE</code> は無視されます。
    </p><div class="informaltable"><table summary="InnoDB テーブルの圧縮で競合する句が使用されると生成される可能性のあるメッセージに対応する警告レベル、エラーコード、およびメッセージテキスト。" border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">レベル</th><th scope="col">コード</th><th scope="col">メッセージ</th></tr></thead><tbody><tr><td scope="row">警告</td><td>1478</td><td><code class="literal"> InnoDB: ignoring KEY_BLOCK_SIZE=<em class="replaceable"><code>n</code></em> unless ROW_FORMAT=COMPRESSED. </code></td></tr></tbody></table></div><p>
      <code class="literal">innodb_strict_mode</code> が有効になっている状態で実行している場合は、<code class="literal">COMPRESSED</code> 以外の任意の <code class="literal">ROW_FORMAT</code> と <code class="literal">KEY_BLOCK_SIZE</code> を組み合わせると警告ではなく、エラーが生成され、テーブルは作成されません。
    </p><p>
      <a class="xref" href="innodb-storage-engine.html#innodb-compression-create-and-alter-options-table" title="表 14.2 CREATE TABLE および ALTER TABLE オプションの意味">表14.2「CREATE TABLE および ALTER TABLE オプションの意味」</a>では、<code class="literal">CREATE TABLE</code> および <code class="literal">ALTER TABLE</code> 上でさまざまなオプションが処理される方法が要約されています。
    </p><div class="table"><a name="innodb-compression-create-and-alter-options-table"></a><p class="title"><b>表 14.2 CREATE TABLE および ALTER TABLE オプションの意味</b></p><div class="table-contents"><table summary="CREATE TABLE および ALTER TABLE オプションの意味" border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">オプション</th><th scope="col">使用法</th><th scope="col">説明</th></tr></thead><tbody><tr><td scope="row"><code class="literal">ROW_FORMAT=​REDUNDANT</code></td><td>MySQL 5.0.3 よりも前で使用されていたストレージフォーマット</td><td><code class="literal">ROW_FORMAT=COMPACT</code> よりも効率性が低く、下位互換性を保つためのものです。</td></tr><tr><td scope="row"><code class="literal">ROW_FORMAT=​COMPACT</code></td><td>MySQL 5.0.3 以降でのデフォルトのストレージフォーマット</td><td>クラスタ化されたインデックスページに、768 バイトの長いカラム値のプリフィクスが格納され、残りのバイトはオーバーフローページに格納されます。</td></tr><tr><td scope="row"><code class="literal">ROW_FORMAT=​DYNAMIC</code></td><td><code class="literal">innodb_file​_format=Barracuda</code> とともにのみ使用可能</td><td>クラスタ化されたインデックスページ内に収まる場合は、そのページ内に値が保存されます。収まらない場合は、オーバーフローページへの 20 バイトのポインタのみが (プリフィクスなしで) 格納されます。</td></tr><tr><td scope="row"><code class="literal">ROW_FORMAT=​COMPRESSED</code></td><td><code class="literal">innodb_file​_format=Barracuda</code> とともにのみ使用可能</td><td>zlib を使用してテーブルおよびインデックスをデフォルトの圧縮済みページサイズの 8K バイトに圧縮します。暗黙的に <code class="literal">ROW_FORMAT=DYNAMIC</code> を示します。</td></tr><tr><td scope="row"><code class="literal">KEY_BLOCK_​SIZE=<em class="replaceable"><code>n</code></em></code></td><td><code class="literal">innodb_file​_format=Barracuda</code> とともにのみ使用可能</td><td>1、2、4、8、または 16K バイトの圧縮済みページサイズを指定します。暗黙的に <code class="literal">ROW_FORMAT=DYNAMIC</code> および <code class="literal">ROW_FORMAT=COMPRESSED</code> を示します。</td></tr></tbody></table></div></div><br class="table-break"><p>
      <a class="xref" href="innodb-storage-engine.html#innodb-compression-create-and-alter-errors-table" title="表 14.3 InnoDB 厳密モードがオフになっているときの CREATE/ALTER TABLE の警告とエラー">表14.3「InnoDB 厳密モードがオフになっているときの CREATE/ALTER TABLE の警告とエラー」</a>では、<code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> ステートメント上で、構成パラメータとオプションの特定の組み合わせで発生するエラー状況、およびオプションが <code class="literal">SHOW TABLE STATUS</code> の出力に表示される方法について簡単に説明しています。
    </p><p>
      <code class="literal">innodb_strict_mode</code> が <code class="literal">OFF</code> の場合、MySQL によってテーブルが作成または変更されますが、次に示すように特定の設定は無視されます。警告メッセージは、MySQL エラーログで確認できます。<code class="literal">innodb_strict_mode</code> が <code class="literal">ON</code> の場合、このような特定のオプションの組み合わせでエラーが生成され、テーブルは作成または変更されません。エラー状況の完全な説明を参照するには、次に示すように、<code class="literal">SHOW ERRORS</code> ステートメントを発行します。

</p><pre class="screen">
mysql&gt; <strong class="userinput"><code>CREATE TABLE x (id INT PRIMARY KEY, c INT)
</code></strong>
-&gt; <strong class="userinput"><code>ENGINE=INNODB KEY_BLOCK_SIZE=33333;
</code></strong>
ERROR 1005 (HY000): Can't create table 'test.x' (errno: 1478)

mysql&gt; <strong class="userinput"><code>SHOW ERRORS;</code></strong>
+-------+------+-------------------------------------------+ 
| Level | Code | Message                                   | 
+-------+------+-------------------------------------------+ 
| Error | 1478 | InnoDB: invalid KEY_BLOCK_SIZE=33333.     | 
| Error | 1005 | Can't create table 'test.x' (errno: 1478) | 
+-------+------+-------------------------------------------+ 

2 rows in set (0.00 sec)
</pre><p>
    </p><div class="table"><a name="innodb-compression-create-and-alter-errors-table"></a><p class="title"><b>表 14.3 InnoDB 厳密モードがオフになっているときの CREATE/ALTER TABLE の警告とエラー</b></p><div class="table-contents"><table summary="InnoDB 厳密モードがオフになっているときの CREATE/ALTER TABLE の警告とエラー" border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">構文</th><th scope="col">警告またはエラーの状況</th><th scope="col">結果として <code class="literal">SHOW TABLE STATUS</code> に表示される <code class="literal">ROW_FORMAT</code></th></tr></thead><tbody><tr><td scope="row"><code class="literal">ROW_FORMAT=REDUNDANT</code></td><td>なし</td><td><code class="literal">REDUNDANT</code></td></tr><tr><td scope="row"><code class="literal">ROW_FORMAT=COMPACT</code></td><td>なし</td><td><code class="literal">COMPACT</code></td></tr><tr><td scope="row"><code class="literal">ROW_FORMAT=COMPRESSED</code> または <code class="literal">ROW_FORMAT=DYNAMIC</code>、または <code class="literal">KEY_BLOCK_SIZE</code> が指定されている</td><td><code class="literal">innodb_file_format</code><code class="literal">=Barracuda</code> と <code class="literal">innodb_file_per_table</code> の両方が有効になっていなければ無視されます。</td><td><code class="literal">COMPACT</code></td></tr><tr><td scope="row">無効な <code class="literal">KEY_BLOCK_SIZE</code> (1、2、4、8、または 16 以外) が指定されている</td><td><code class="literal">KEY_BLOCK_SIZE</code> が無視されます。</td><td>リクエストされたもの、または <code class="literal">COMPACT</code> (デフォルト)</td></tr><tr><td scope="row"><code class="literal">ROW_FORMAT=COMPRESSED</code> および有効な <code class="literal">KEY_BLOCK_SIZE</code> が指定されている</td><td>なし。デフォルトの 8K ではなく、指定された <code class="literal">KEY_BLOCK_SIZE</code> が使用されます。</td><td><code class="literal">COMPRESSED</code></td></tr><tr><td scope="row"><code class="literal">REDUNDANT</code>、<code class="literal">COMPACT</code>、または <code class="literal">DYNAMIC</code> 行フォーマットを使用して <code class="literal">KEY_BLOCK_SIZE</code> が指定されている</td><td><code class="literal">KEY_BLOCK_SIZE</code> が無視されます。</td><td><code class="literal">REDUNDANT</code>、<code class="literal">COMPACT</code>、または <code class="literal">DYNAMIC</code></td></tr><tr><td scope="row"><code class="literal">ROW_FORMAT</code> が <code class="literal">REDUNDANT</code>、<code class="literal">COMPACT</code>、<code class="literal">DYNAMIC</code>、または <code class="literal">COMPRESSED</code> のいずれでもない</td><td>MySQL パーサーで認識される場合は無視されます。その他の場合は、エラーが発行されます。</td><td><code class="literal">COMPACT</code> または該当なし</td></tr></tbody></table></div></div><br class="table-break"><p>
      <code class="literal">innodb_strict_mode</code> が <code class="literal">ON</code> の場合、MySQL では無効な <code class="literal">ROW_FORMAT</code> または <code class="literal">KEY_BLOCK_SIZE</code> パラメータが拒否されます。以前のバージョンの MySQL との互換性を保つために、厳密モードはデフォルトで有効になっていません。その代わりに、MySQL では、無視された無効なパラメータに対応した警告 (エラーではない) が発行されます。
    </p><p>
      <code class="literal">SHOW TABLE STATUS</code> を使用しても、選択した <code class="literal">KEY_BLOCK_SIZE</code> を表示できないことに注意してください。<code class="literal">SHOW CREATE TABLE</code> ステートメントでは、(テーブルの作成時に無視された場合でも) <code class="literal">KEY_BLOCK_SIZE</code> が表示されます。テーブルの実際の圧縮済みページサイズは、MySQL では表示できません。
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-file-format"></a>14.8 InnoDB のファイル形式管理</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-format-enabling">14.8.1 ファイル形式の有効化</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-format-compatibility">14.8.2 ファイル形式の互換性の確認</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-format-identifying">14.8.3 使用されているファイル形式の識別</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-format-downgrading">14.8.4 ファイル形式のダウングレード</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-format-future">14.8.5 将来の InnoDB ファイル形式</a></span></dt></dl></div><a class="indexterm" name="idm139979072027568"></a><a class="indexterm" name="idm139979072026128"></a><a class="indexterm" name="idm139979072024896"></a><a class="indexterm" name="idm139979072023392"></a><p>
    InnoDB が進化するにつれ、新機能をサポートするために、新しいディスク上のデータ構造が必要になる場合があります。圧縮テーブル (<a class="xref" href="innodb-storage-engine.html#innodb-compression" title="14.7 InnoDB 圧縮テーブル">セクション14.7「InnoDB 圧縮テーブル」</a>を参照してください) や、オフページに格納された長い可変長カラム (<a class="xref" href="innodb-storage-engine.html#innodb-row-format" title="14.9 InnoDB の行ストレージと行フォーマット">セクション14.9「InnoDB の行ストレージと行フォーマット」</a>を参照してください) などの機能には、以前のバージョンの InnoDB とは互換性のないデータファイル形式が必要です。これらのどちらの機能にも、新しい <a class="link" href="glossary.html#glos_barracuda" title="Barracuda">Barracuda</a> ファイル形式の使用が必要です。
  </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
      その他の新機能はすべて、元の <a class="link" href="glossary.html#glos_antelope" title="Antelope">Antelope</a> ファイル形式と互換性があるため、Barracuda ファイル形式を必要としません。
    </p></div><p>
    このセクションでは、新しい InnoDB テーブルのためのファイル形式の有効化、MySQL リリース間での異なるファイル形式の互換性の確認、使用されているファイル形式の識別、ファイル形式のダウングレード、および将来使用される可能性のあるファイル形式名について説明します。
  </p><p><a name="innodb-file-format-named"></a><b>指定されたファイル形式 </b>
      InnoDB は、アップグレードやダウングレードの状況、または異なるレベルの MySQL を実行している異機種混在システムで互換性を管理しやすくするために、指定されたファイル形式を使用します。現在は、<a class="link" href="glossary.html#glos_antelope" title="Antelope">Antelope</a> および <a class="link" href="glossary.html#glos_barracuda" title="Barracuda">Barracuda</a> ファイル形式がサポートされています。<a class="link" href="glossary.html#glos_barracuda" title="Barracuda">Barracuda</a> は最新のファイル形式です。これは、圧縮テーブルや、より効率的な BLOB ストレージのための <code class="literal">DYNAMIC</code> 行フォーマットなどの重要な InnoDB 機能をサポートします。以前は名前が付いていなかった元の InnoDB ファイル形式は現在、<a class="link" href="glossary.html#glos_antelope" title="Antelope">Antelope</a> と呼ばれます。InnoDB の将来のバージョンでは、<a class="link" href="innodb-storage-engine.html#innodb-file-format-future" title="14.8.5 将来の InnoDB ファイル形式">動物の名前で識別される</a>一連のファイル形式が昇順のアルファベット順に導入される可能性があります。
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-file-format-enabling"></a>14.8.1 ファイル形式の有効化</h3></div></div></div><p>
      <code class="literal">innodb_file_format</code> 構成パラメータは、新しい <code class="literal">InnoDB</code> テーブルに使用するファイル形式を定義します。このパラメータは、独自のテーブルスペースを持つテーブルにのみ適用できるため、<code class="literal">innodb_file_per_table</code> を有効にする必要があります。
    </p><p>
      <code class="literal">innodb_file_format</code> パラメータは現在、<a class="link" href="glossary.html#glos_antelope" title="Antelope">Antelope</a> および <a class="link" href="glossary.html#glos_barracuda" title="Barracuda">Barracuda</a> ファイル形式をサポートしています。テーブル圧縮や新しい <code class="literal">DYNAMIC</code> 行フォーマットなどの、Barracuda ファイル形式によってサポートされる機能を利用する新しいテーブルを作成するには、<code class="literal">innodb_file_format</code> を <code class="literal">BARRACUDA</code> に設定します。
    </p><p>
      MySQL 5.1 以前のリリースで組み込み InnoDB がデータベースにアクセスできなくなるような、Barracuda ファイル形式によってサポートされる新機能の使用を除外するには、<code class="literal">innodb_file_format</code> を省略するか、またはそれを Antelope に設定します。
    </p><p>
      <code class="literal">innodb_file_format</code> の値は、<code class="literal">mysqld</code> の起動時にコマンド行で設定するか、あるいはオプションファイル <code class="literal">my.cnf</code> (Unix オペレーティングシステム) または <code class="literal">my.ini</code> (Windows) で設定できます。また、<code class="literal">SET GLOBAL</code> ステートメントで動的に変更することもできます。
    </p><pre class="programlisting">
mysql&gt; SET GLOBAL innodb_file_format=BARRACUDA;
Query OK, 0 rows affected (0.00 sec)
    </pre><p>
      可能な場合、新しいテーブルには Barracuda 形式を使用することをお勧めしますが、MySQL 5.5 では、異なる MySQL リリースを含むレプリケーション構成との最大限の互換性のために、デフォルトのファイル形式は引き続き <a class="link" href="glossary.html#glos_antelope" title="Antelope">Antelope</a> です。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-file-format-compatibility"></a>14.8.2 ファイル形式の互換性の確認</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-format-compatibility-checking">14.8.2.1 InnoDB が起動されたときの互換性チェック</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-format-compatibility-checking-table-access">14.8.2.2 テーブルが開かれたときの互換性チェック</a></span></dt></dl></div><a class="indexterm" name="idm139979071983808"></a><p>
      InnoDB 1.1 には、新しいファイル形式を使用している InnoDB データファイルに対して古いリリースの MySQL サーバーを実行した場合に発生する可能性のあるクラッシュやデータ破損から保護するためのチェックがいくつか組み込まれています。これらのチェックは、サーバーが起動されたときと、テーブルに最初にアクセスしたときに実行されます。このセクションでは、これらのチェック、それらを制御する方法、および発生する可能性のあるエラーや警告の状態について説明します。
    </p><h4><a name="idm139979071980576"></a>下位互換性</h4><p>
      下位互換性の考慮事項は、最新バージョンの InnoDB (InnoDB Plugin、または InnoDB 1.1 を含む MySQL 5.5 以降) を古いバージョン (MySQL 5.1 以前、InnoDB Plugin ではなく組み込み InnoDB を含む) とともに使用している場合にのみ適用されます。互換性の問題が発生する可能性を最小限に抑えるために、MySQL 5.1 以前のすべてのデータベースサーバーを InnoDB Plugin に基づいて標準化できます。
    </p><p>
      一般に、新しいバージョンの InnoDB は、クラッシュ、ハングアップ、結果の誤り、破損などのリスクなしでは、以前のバージョンの InnoDB で安全に読み取りまたは書き込みができないテーブルまたはインデックスを作成する可能性があります。InnoDB 1.1 には、これらの状態から保護するとともに、データベースファイルや InnoDB のバージョン間での互換性の維持に役立つメカニズムが含まれています。このメカニズムを使用すると、下位互換性のないディスクファイルを作成する新機能の誤った使用を回避することによって、InnoDB リリースのいくつかの新機能 (パフォーマンス向上やバグ修正など) を利用しながら、引き続き以前のバージョンの InnoDB でデータベースを使用するオプションを保持できます。
    </p><p>
      あるバージョンの InnoDB によって特定のファイル形式がサポートされている場合は (その形式がデフォルトであるかどうかにかかわらず)、その形式または以前の形式を必要とするすべてのテーブルをクエリーして更新することができます。新機能を使用する新しいテーブルの作成だけは、有効になっている特定のファイル形式に基づいて制限されます。逆に、あるテーブルスペースに、現在実行中のソフトウェアでサポートされていないファイル形式を使用するテーブルまたはインデックスが含まれている場合は、読み取りアクセスであっても、そのテーブルスペースにはまったくアクセスできません。
    </p><p>
      InnoDB テーブルスペースを以前のファイル形式に<span class="quote">「<span class="quote">ダウングレード</span>」</span>するには、以前の形式を使用するテーブルスペース内の新しいテーブルにデータをコピーするしか方法がありません。これは、<a class="xref" href="innodb-storage-engine.html#innodb-file-format-downgrading" title="14.8.4 ファイル形式のダウングレード">セクション14.8.4「ファイル形式のダウングレード」</a>で説明されている <code class="literal">ALTER TABLE</code> ステートメントで実行できます。
    </p><p>
      既存の InnoDB テーブルスペースのファイル形式を判定するためのもっとも簡単な方法は、<code class="literal">SHOW TABLE STATUS</code> コマンドを使用するか、またはテーブル <code class="literal">INFORMATION_SCHEMA.TABLES</code> をクエリーして、そこに含まれているテーブルのプロパティーを検査することです。テーブルの <code class="literal">Row_format</code> が <code class="literal">'Compressed'</code> または <code class="literal">'Dynamic'</code> としてレポートされた場合、そのテーブルを含むテーブルスペースは Barracuda 形式を使用しています。それ以外の場合は、以前の InnoDB ファイル形式である Antelope を使用しています。
    </p><h4><a name="idm139979071966352"></a>内部の詳細</h4><p>
      InnoDB のテーブルごとのテーブルスペースファイル (<code class="literal">*.ibd</code> ファイルによって表されます) にはすべて、ファイル形式識別子のラベルが付けられます。システムテーブルスペース (<code class="literal">ibdata</code> ファイルによって表されます) には、InnoDB データベースファイルのグループで使用される<span class="quote">「<span class="quote">最高の</span>」</span>ファイル形式のタグが付けられ、そのファイルが開かれるときにこのタグがチェックされます。
    </p><p>
      圧縮テーブルを作成するか、または <code class="literal">ROW_FORMAT=DYNAMIC</code> でテーブルを作成すると、対応する <code class="literal">.ibd</code> ファイルのファイルヘッダーと InnoDB データディクショナリ内のテーブルタイプが Barracuda ファイル形式の識別子で更新されます。その時点から、このテーブルは、この新しいファイル形式をサポートしていない InnoDB のバージョンでは使用できなくなります。異常な動作から保護するために、InnoDB バージョン 5.0.21 以降では、テーブルが開かれるときに互換性チェックを実行します。(多くの場合、<code class="literal">ALTER TABLE</code> ステートメントはテーブルを再作成し、それによってそのプロパティーを変更します。テーブルを再構築することなくインデックスを追加または削除する特殊なケースについては、<a class="ulink" href="http://dev.mysql.com/doc/refman/5.5/en/innodb-create-index.html" target="_top">InnoDB Fast Index Creation</a>で説明されています。)
    </p><h4><a name="idm139979071956144"></a>ib-file セットの定義</h4><p>
      混乱を避けるために、この説明では<span class="quote">「<span class="quote">ib-file セット</span>」</span>という用語を、InnoDB が単位として管理する一連のオペレーティングシステムファイルを示すものとして定義します。ib-file セットには、次のファイルが含まれています。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          システムテーブルスペース (1 つ以上の <code class="literal">ibdata</code> ファイル)。これには、内部のシステム情報 (内部のカタログや Undo 情報を含む) が含まれるほか、ユーザーデータとインデックスも含まれる可能性があります。
        </p></li><li class="listitem"><p>
          0 個以上の単一テーブルのテーブルスペース (<span class="quote">「<span class="quote">file per table</span>」</span> ファイルとも呼ばれ、<code class="literal">*.ibd</code> ファイルという名前が付けられます)。
        </p></li><li class="listitem"><p>
          InnoDB ログファイル。通常は、<code class="literal">ib_logfile0</code> と <code class="literal">ib_logfile1</code> の 2 つです。クラッシュリカバリやバックアップに使用されます。
        </p></li></ul></div><p>
      <span class="quote">「<span class="quote">ib-file セット</span>」</span>には、InnoDB テーブルに関するメタデータが含まれた、対応する <code class="literal">.frm</code> ファイルは含まれません。<code class="literal">.frm</code> ファイルは MySQL によって作成および管理され、InnoDB 内部のメタデータとの同期がとれなくなる場合があります。
    </p><p>
      1 つの<span class="quote">「<span class="quote">ib-file セット</span>」</span>に (場合によっては複数のデータベースの) 複数のテーブルを格納できます。(MySQL では、<span class="quote">「<span class="quote">データベース</span>」</span>は、ほかのシステムでは<span class="quote">「<span class="quote">スキーマ</span>」</span>または<span class="quote">「<span class="quote">カタログ</span>」</span>と呼ばれる、テーブルの論理的なコレクションです。)
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-file-format-compatibility-checking"></a>14.8.2.1 InnoDB が起動されたときの互換性チェック</h4></div></div></div><a class="indexterm" name="idm139979071939056"></a><a class="indexterm" name="idm139979071937680"></a><p>
        InnoDB は、ib-file セットを開いたときに発生する可能性のあるクラッシュまたはデータ破損を回避するために、その ib-file セット内で使用されているファイル形式を完全にサポートできることをチェックします。システムがクラッシュまたは<span class="quote">「<span class="quote">高速シャットダウン</span>」</span> (つまり、<code class="literal">innodb_fast_shutdown</code> が 0 より大きい) のあとに再起動された場合は、現在のソフトウェアにとっては<span class="quote">「<span class="quote">新しすぎる</span>」</span>形式のデータ構造 (Redo または Undo エントリや、二重書き込みページなど) がディスク上に存在する可能性があります。これらのデータ構造にアクセスすると、リカバリプロセス中に、データファイルの重大な破損が発生する場合があります。ファイル形式の起動チェックは、どのリカバリプロセスが開始されるよりも先に実行されるため、新しいテーブルとの一貫性の問題や MySQL サーバーの起動時の問題が回避されます。
      </p><p>
        バージョン InnoDB 1.0.1 から、システムテーブルスペースは、ib-file セットの一部であるいずれかのテーブルスペース内のいずれかのテーブルによって使用されている<span class="quote">「<span class="quote">最高の</span>」</span>ファイル形式の識別子またはタグを記録します。このファイル形式タグに対するチェックは、構成パラメータ <code class="literal">innodb_file_format_check</code> (デフォルトでは <code class="literal">ON</code>) によって制御されます。
      </p><p>
        システムテーブルスペース内のファイル形式タグが、現在実行中の特定のソフトウェアによってサポートされる最高のバージョンより新しいか、または高い値であり、かつ <code class="literal">innodb_file_format_check</code> が <code class="literal">ON</code> である場合は、サーバーが起動されたときに次のエラーが発行されます。
      </p><pre class="programlisting">
InnoDB: Error: the system tablespace is in a
file format that this version doesn't support
</pre><p>
        <code class="literal">innodb_file_format</code> をファイル形式名に設定することもできます。それにより、指定されたファイル形式が現在のソフトウェアでサポートされていない場合は InnoDB が起動されなくなります。また、<span class="quote">「<span class="quote">高位境界値</span>」</span>も指定した値に設定されます。<code class="literal">innodb_file_format_check</code> を設定する機能は、ib-file セット内のすべてのテーブルを手動で<span class="quote">「<span class="quote">ダウングレード</span>」</span>する場合 (<a class="ulink" href="http://dev.mysql.com/doc/refman/5.5/en/innodb-downgrading.html" target="_top">Downgrading the InnoDB Storage Engine</a>で説明されています) に (InnoDB の将来のリリースで) 役立ちます。それにより、あとで古いバージョンの InnoDB を使用して ib-file セットにアクセスする場合は、起動時のファイル形式のチェックを使用できます。
      </p><p>
        一部の限られた状況では、サーバーを起動し、<span class="quote">「<span class="quote">新しすぎる</span>」</span>形式 (使用しているソフトウェアではサポートされていない形式) の ib-file セットを使用することが必要になる場合があります。構成パラメータ <code class="literal">innodb_file_format_check</code> を <code class="literal">OFF</code> に設定すると、InnoDB はデータベースを開きますが、エラーログに次の警告メッセージを発行します。
      </p><pre class="programlisting">
InnoDB: Warning: the system tablespace is in a
file format that this version doesn't support
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          これによりリカバリプロセスの実行が許可され、前回のシャットダウンがクラッシュまたは<span class="quote">「<span class="quote">高速シャットダウン</span>」</span>であった場合はデータベースが破損する可能性があるため、これは非常に危険な設定です。<code class="literal">innodb_file_format_check</code> を <code class="literal">OFF</code> に設定するのは、前回のシャットダウンが <code class="literal">innodb_fast_shutdown=0</code> で実行されたことが確実である場合だけにし、基本的にリカバリプロセスが発生しないようにしてください。将来のリリースでは、このパラメータ設定は <code class="literal">OFF</code> から <code class="literal">UNSAFE</code> に名前が変更される可能性があります。(ただし、追加のファイル形式をサポートする InnoDB の新しいリリースが公開されるまでは、起動チェックを無効にしたとしても実際には<span class="quote">「<span class="quote">安全です</span>」</span>。)
        </p></div><p>
        パラメータ <code class="literal">innodb_file_format_check</code> は、データベースが開かれたときの動作にのみ影響を与え、そのあとには影響を与えません。逆に、パラメータ <code class="literal">innodb_file_format</code> (これは、特定の形式を有効にします) は、有効になっている形式で新しいテーブルを作成できるかどうかだけを決定し、データベースを開くことができるかどうかには影響を与えません。
      </p><p>
        ファイル形式タグは<span class="quote">「<span class="quote">高位境界値</span>」</span>であるため、<span class="quote">「<span class="quote">より高い</span>」</span>形式のテーブルが作成されるか、または既存のテーブルが読み取りまたは書き込みのためにアクセスされる (その形式がサポートされていると仮定します) と、サーバーが起動されたあとに増加します。実行中のソフトウェアがサポートしている形式より高い形式の既存のテーブルにアクセスした場合は、<a class="xref" href="innodb-storage-engine.html#innodb-file-format-compatibility-checking-table-access" title="14.8.2.2 テーブルが開かれたときの互換性チェック">セクション14.8.2.2「テーブルが開かれたときの互換性チェック」</a>で説明されているように、システムテーブルスペースのタグは更新されませんが、テーブルレベルの互換性チェックが適用されます (また、エラーが発行されます)。高位境界値が更新されると常に <code class="literal">innodb_file_format_check</code> の値も更新されるため、コマンド <code class="literal">SELECT @@innodb_file_format_check;</code> では、現在開いている ib-file セット内のテーブルによって使用され、現在実行中のソフトウェアによってサポートされることがわかっている最新のファイル形式の名前が表示されます。
      </p><p>
        この動作をもっとも適切に示すために、<a class="xref" href="innodb-storage-engine.html#innodb-file-format-compatibility-table" title="表 14.4 InnoDB データファイルの互換性および関連する InnoDB パラメータ">表14.4「InnoDB データファイルの互換性および関連する InnoDB パラメータ」</a>で説明されているシナリオを考えてみます。ある将来のバージョンの InnoDB が Cheetah 形式をサポートし、ib-file セットがそのバージョンで使用されてきたとします。
      </p><div class="table"><a name="innodb-file-format-compatibility-table"></a><p class="title"><b>表 14.4 InnoDB データファイルの互換性および関連する InnoDB パラメータ</b></p><div class="table-contents"><table summary="InnoDB データファイルの互換性および関連する InnoDB パラメータ" border="1"><colgroup><col><col><col><col><col></colgroup><thead><tr><th scope="col">innodb ファイル形式のチェック</th><th scope="col">innodb ファイル形式</th><th scope="col">ib-file セットで使用される最高のファイル形式</th><th scope="col">InnoDB によってサポートされる最高のファイル形式</th><th scope="col">結果</th></tr></thead><tbody><tr><td scope="row"><code class="literal">OFF</code></td><td><code class="literal">Antelope</code> または <code class="literal">Barracuda</code></td><td><code class="literal">Barracuda</code></td><td><code class="literal">Barracuda</code></td><td>データベースを開くことができます。Antelope または Barracuda ファイル形式を必要とするテーブルを作成できます</td></tr><tr><td scope="row"><code class="literal">OFF</code></td><td><code class="literal">Antelope</code> または <code class="literal">Barracuda</code></td><td><code class="literal">Cheetah</code></td><td><code class="literal">Barracuda</code></td><td>データベースには<span class="quote">「<span class="quote">新しすぎる</span>」</span>形式のファイルが含まれているため、データベースを開くと警告が表示されます。Antelope または Barracuda ファイル形式のテーブルを作成できます。Cheetah 形式のテーブルにはアクセスできません</td></tr><tr><td scope="row"><code class="literal">OFF</code></td><td><code class="literal">Cheetah</code></td><td><code class="literal">Barracuda</code></td><td><code class="literal">Barracuda</code></td><td>データベースを開くことができません。<code class="literal">innodb_file_format</code> を Cheetah に設定できません</td></tr><tr><td scope="row"><code class="literal">ON</code></td><td><code class="literal">Antelope</code> または <code class="literal">Barracuda</code></td><td><code class="literal">Barracuda</code></td><td><code class="literal">Barracuda</code></td><td>データベースを開くことができます。Antelope または Barracuda ファイル形式のテーブルを作成できます</td></tr><tr><td scope="row"><code class="literal">ON</code></td><td><code class="literal">Antelope</code> または <code class="literal">Barracuda</code></td><td><code class="literal">Cheetah</code></td><td><code class="literal">Barracuda</code></td><td>データベースには<span class="quote">「<span class="quote">新しすぎる</span>」</span>形式 (Cheetah) のファイルが含まれているため、データベースを開くことができません</td></tr><tr><td scope="row"><code class="literal">ON</code></td><td><code class="literal">Cheetah</code></td><td><code class="literal">Barracuda</code></td><td><code class="literal">Barracuda</code></td><td>データベースを開くことができません。<code class="literal">innodb_file_format</code> を Cheetah に設定できません</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-file-format-compatibility-checking-table-access"></a>14.8.2.2 テーブルが開かれたときの互換性チェック</h4></div></div></div><p>
        テーブルがはじめてアクセスされると、InnoDB (InnoDB 1.0 の前のいくつかのリリースを含む) は、そのテーブルが格納されているテーブルスペースのファイル形式が完全にサポートされていることをチェックします。このチェックによって、チェックしないと、<span class="quote">「<span class="quote">新しすぎる</span>」</span>データ構造を使用しているテーブルが検出された場合に発生するクラッシュまたは破損が回避されます。
      </p><p>
        あるリリースによってサポートされるいずれかのファイル形式を使用しているすべてのテーブルの読み取りまたは書き込みが可能です (ユーザーに十分な権限があると仮定します)。システム構成パラメータ <code class="literal">innodb_file_format</code> を設定すると、特定のファイル形式が特定のリリースによってサポートされている場合でも、そのファイル形式を使用する新しいテーブルが作成されるのを防ぐことができます。このような設定は下位互換性を維持するために使用される可能性がありますが、サポートされているいずれかの形式を使用するテーブルへのアクセスは防げません。
      </p><p>
        <a class="xref" href="innodb-storage-engine.html#innodb-file-format-named" title="指定されたファイル形式">指定されたファイル形式</a>に示されているように、5.0.21 より古いバージョンの MySQL は、テーブルが作成されるときに新しいファイル形式が使用された場合、新しいバージョンによって作成されたデータベースファイルを確実に使用することができません。さまざまなエラー状態または破損を回避するために、InnoDB は、ファイルを開くときに (たとえば、テーブルへの最初のアクセス時に) ファイル形式の互換性をチェックします。現在実行中のバージョンの InnoDB が InnoDB データディクショナリ内のテーブルタイプで識別されるファイル形式をサポートしていない場合、MySQL は次のエラーをレポートします。
      </p><pre class="programlisting">
ERROR 1146 (42S02): Table '<em class="replaceable"><code>test</code></em>.<em class="replaceable"><code>t1</code></em>' doesn't exist
</pre><p>
        InnoDB はまた、エラーログにもメッセージを書き込みます。
      </p><pre class="programlisting">
InnoDB: table <em class="replaceable"><code>test</code></em>/<em class="replaceable"><code>t1</code></em>: unknown table type <em class="replaceable"><code>33</code></em>
</pre><p>
        このテーブルタイプは、<a class="xref" href="innodb-storage-engine.html#innodb-file-format-identifying" title="14.8.3 使用されているファイル形式の識別">セクション14.8.3「使用されているファイル形式の識別」</a>で説明されている、ファイル形式のバージョンを含むテーブルスペースフラグに等しいはずです。
      </p><p>
        MySQL 4.1 の前のバージョンの InnoDB では、データベースファイルにテーブル形式の識別子が含まれていませんでした。また、MySQL 5.0.21 の前のバージョンには、テーブル形式の互換性チェックが含まれていませんでした。そのため、<span class="quote">「<span class="quote">新しすぎる</span>」</span>形式のテーブルが 5.0.21 の前のバージョンの InnoDB で使用されている場合、正しい動作を保証するための方法はありません。
      </p><p>
        InnoDB 1.0 以降のファイル形式管理機能 (テーブルスペースのタグ付けおよび実行時チェック) を使用すると、InnoDB は、実行中のバージョンのソフトウェアがデータベース内の既存のテーブルを正しく処理できることをできるだけ早く確認できます。
      </p><p>
        InnoDB が、サポートしていない形式のファイルを含むデータベースを開くことを (パラメータ <code class="literal">innodb_file_format_check</code> を <code class="literal">OFF</code> に設定することによって) 許可した場合も、このセクションで説明したテーブルレベルのチェックが引き続き適用されます。
      </p><p>
        InnoDB Plugin を含む MySQL 5.1 より古いリリースの InnoDB では Barracuda ファイル形式のテーブルを含むデータベースファイルを使用しないようにすることを<span class="emphasis"><em>強く</em></span>お勧めします。このようなテーブルは、<a class="xref" href="innodb-storage-engine.html#innodb-file-format-downgrading" title="14.8.4 ファイル形式のダウングレード">セクション14.8.4「ファイル形式のダウングレード」</a>で説明されている手順を使用して Antelope 形式に<span class="quote">「<span class="quote">ダウングレード</span>」</span>できます。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-file-format-identifying"></a>14.8.3 使用されているファイル形式の識別</h3></div></div></div><a class="indexterm" name="idm139979071834864"></a><a class="indexterm" name="idm139979071832720"></a><p>
      <code class="literal">innodb_file_format</code> 構成オプションを使用して別の<a class="link" href="glossary.html#glos_file_format" title="ファイル形式">ファイル形式</a>を有効にした場合、その変更は新しく作成されたテーブルにのみ適用されます。また、新しいテーブルを作成した場合、そのテーブルを含むテーブルスペースには、そのテーブルの機能をサポートするために必要な<span class="quote">「<span class="quote">もっとも早い</span>」</span>、または<span class="quote">「<span class="quote">もっとも単純な</span>」</span>ファイル形式のタグが付けられます。たとえば、<code class="literal">Barracuda</code> ファイル形式を有効にして、Dynamic または Compressed 行フォーマットを使用しない新しいテーブルを作成した場合、そのテーブルを含む新しいテーブルスペースには <code class="literal">Antelope</code> ファイル形式の使用のタグが付けられます。
    </p><p>
      特定のテーブルによって使用されるファイル形式を識別することは容易です。<code class="literal">SHOW TABLE STATUS</code> によってレポートされた行フォーマットが <code class="literal">Compact</code> または <code class="literal">Redundant</code> である場合、このテーブルは <code class="literal">Antelope</code> ファイル形式を使用します。<code class="literal">SHOW TABLE STATUS</code> によってレポートされた行フォーマットが <code class="literal">Compressed</code> または <code class="literal">Dynamic</code> である場合、このテーブルは <code class="literal">Barracuda</code> ファイル形式を使用します。
    </p><pre class="programlisting">
mysql&gt; SHOW TABLE STATUS\G
*************************** 1. row ***************************
           Name: t1
         Engine: InnoDB
        Version: 10
     Row_format: Compact
           Rows: 0
 Avg_row_length: 0
    Data_length: 16384
Max_data_length: 0
   Index_length: 16384
      Data_free: 0
 Auto_increment: 1
    Create_time: 2014-11-03 13:32:10
    Update_time: NULL
     Check_time: NULL
      Collation: latin1_swedish_ci
       Checksum: NULL
 Create_options: 
        Comment: 
1 row in set (0.00 sec)
</pre><p>
      <code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code> テーブルを使用して、特定のテーブルまたはテーブルスペースによって使用されるファイル形式を識別することもできます。例:
    </p><pre class="programlisting">mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_TABLES WHERE NAME='test/t1'\G 
*************************** 1. row ***************************
     TABLE_ID: 44
         NAME: test/t1
         FLAG: 1
       N_COLS: 6
        SPACE: 30
  FILE_FORMAT: Antelope
   ROW_FORMAT: Compact
ZIP_PAGE_SIZE: 0
1 row in set (0.00 sec)
    
mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_TABLESPACES WHERE NAME='test/t1'\G
*************************** 1. row ***************************
        SPACE: 30
         NAME: test/t1
         FLAG: 0
  FILE_FORMAT: Antelope
   ROW_FORMAT: Compact or Redundant
    PAGE_SIZE: 16384
ZIP_PAGE_SIZE: 0
1 row in set (0.00 sec)
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-file-format-downgrading"></a>14.8.4 ファイル形式のダウングレード</h3></div></div></div><a class="indexterm" name="idm139979071811824"></a><p>
      各 InnoDB テーブルスペースファイル (名前は <code class="literal">*.ibd</code> に一致します) には、そのテーブルとインデックスを作成するために使用されるファイル形式のタグが付けられます。テーブルスペースをダウングレードする方法として、テーブルとそのインデックスを再作成します。テーブルとそのインデックスを再作成するためのもっとも簡単な方法は、次のコマンドの使用です。
    </p><pre class="programlisting">
ALTER TABLE <em class="replaceable"><code>t</code></em> ROW_FORMAT=<em class="replaceable"><code>COMPACT</code></em>;
</pre><p>
      これを、ダウングレードする各テーブルに対して実行します。<code class="literal">COMPACT</code> 行フォーマットは、ファイル形式 Antelope を使用します。これは MySQL 5.0.3 で導入されました。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-file-format-future"></a>14.8.5 将来の InnoDB ファイル形式</h3></div></div></div><p>
      MySQL 5.1 の標準の組み込み InnoDB によって使用されるファイル形式は、<a class="link" href="glossary.html#glos_antelope" title="Antelope">Antelope</a> 形式です。InnoDB Plugin 1.0 で導入されたファイル形式は、<a class="link" href="glossary.html#glos_barracuda" title="Barracuda">Barracuda</a> 形式です。追加の新しいファイル形式を必要とする新機能はまだ発表されていませんが、InnoDB ファイル形式のメカニズムでは将来の拡張が可能になっています。
    </p><p>
      完全性のために、将来のファイル形式に使用される可能性のあるファイル形式名を次に示します。Antelope、Barracuda、Cheetah、Dragon、Elk、Fox、Gazelle、Hornet、Impala、Jaguar、Kangaroo、Leopard、Moose、Nautilus、Ocelot、Porpoise、Quail、Rabbit、Shark、Tiger、Urchin、Viper、Whale、Xenops、Yak、および Zebra。これらのファイル形式は、内部の識別子 0 - 25 に対応しています。
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-row-format"></a>14.9 InnoDB の行ストレージと行フォーマット</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-row-format-overview">14.9.1 InnoDB 行ストレージの概要</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-row-format-specification">14.9.2 テーブルの行フォーマットの指定</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-row-format-dynamic">14.9.3 DYNAMIC および COMPRESSED 行フォーマット</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-row-format-antelope">14.9.4 COMPACT および REDUNDANT 行フォーマット</a></span></dt></dl></div><p>
    このセクションでは、テーブル<a class="link" href="glossary.html#glos_compression" title="圧縮">圧縮</a>や長いカラムのオフページストレージなどの特定の InnoDB 機能が、<code class="literal">CREATE TABLE</code> ステートメントの <code class="literal">ROW_FORMAT</code> 句によってどのように制御されるかについて説明します。ここでは、正しい行フォーマットを選択するための考慮事項、および MySQL リリース間の行フォーマットの互換性について説明します。
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-row-format-overview"></a>14.9.1 InnoDB 行ストレージの概要</h3></div></div></div><p>
      行とそれに関連付けられたカラムのストレージが、クエリーや DML 操作のパフォーマンスに影響を与えます。1 つのディスク<a class="link" href="glossary.html#glos_page" title="ページ">ページ</a>に収まる行数が多いほど、クエリーやインデックスルックアップの処理は速くなり、InnoDB バッファープールで必要なキャッシュメモリーは減り、数値カラムや短い文字列カラムの更新された値を書き出すために必要な I/O も少なくなります。
    </p><p>
      各 InnoDB テーブル内のデータは、<a class="link" href="glossary.html#glos_page" title="ページ">ページ</a>に分割されます。各テーブルを構成するページは、<a class="link" href="glossary.html#glos_b_tree" title="B ツリー">B ツリーインデックス</a>と呼ばれるツリーデータ構造で配置されます。テーブルデータと<a class="link" href="glossary.html#glos_secondary_index" title="セカンダリインデックス">セカンダリインデックス</a>はどちらも、このタイプの構造を使用します。テーブル全体を表す B ツリーインデックスは、<a class="link" href="glossary.html#glos_clustered_index" title="クラスタ化されたインデックス">クラスタ化されたインデックス</a>と呼ばれます。これは、<a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a>カラムに従って編成されます。インデックスデータ構造のノードには、その行内のすべてのカラム (クラスタ化されたインデックスの場合)、またはインデックスカラムと主キーカラム (セカンダリインデックスの場合) の値が含まれています。
    </p><p>
      可変長カラムは、このルールの例外です。B ツリーページに収めるには長すぎる <code class="literal">BLOB</code> や <code class="literal">VARCHAR</code> などのカラムは、<a class="link" href="glossary.html#glos_overflow_page" title="オーバーフローページ">オーバーフローページ</a>と呼ばれる、個別に割り当てられたディスクページに格納されます。このようなカラムを、<a class="link" href="glossary.html#glos_off_page_column" title="オフページカラム">オフページカラム</a>と呼びます。これらのカラムの値は、オーバーフローページの片方向リンクリストに格納され、このような各カラムには 1 つ以上のオーバーフローページの独自のリストがあります。場合によっては、ストレージの浪費を避け、また個別のページを読み取る必要をなくすために、長いカラム値のすべてまたはプリフィクスが B ツリーに格納されます。
    </p><p>
      次のセクションでは、これらの可変長カラムを表す方法を制御するために <code class="literal">CREATE TABLE</code> および <code class="literal">ALTER TABLE</code> ステートメントで使用できる句である <code class="literal">ROW_FORMAT</code> と <code class="literal">KEY_BLOCK_SIZE</code> について説明します。これらの句を使用するには、<code class="literal">innodb_file_per_table</code> および <code class="literal">innodb_file_format</code> 構成オプションの設定の変更も必要になる可能性があります。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-row-format-specification"></a>14.9.2 テーブルの行フォーマットの指定</h3></div></div></div><a class="indexterm" name="idm139979071771424"></a><a class="indexterm" name="idm139979071769392"></a><p>
      テーブルの行フォーマットは、<code class="literal">CREATE TABLE</code> および <code class="literal">ALTER TABLE</code> ステートメントの <code class="literal">ROW_FORMAT</code> 句で指定します。例:
    </p><pre class="programlisting">
CREATE TABLE t1 (f1 int unsigned) ROW_FORMAT=DYNAMIC ENGINE=INNODB;
    </pre><p>
      <code class="literal">InnoDB</code> <code class="literal">ROW_FORMAT</code> オプションには、<a class="link" href="glossary.html#glos_compact_row_format" title="コンパクト行フォーマット">COMPACT</a>、<a class="link" href="glossary.html#glos_redundant_row_format" title="冗長行フォーマット">REDUNDANT</a>、<a class="link" href="glossary.html#glos_dynamic_row_format" title="動的行フォーマット">DYNAMIC</a>、および <a class="link" href="glossary.html#glos_compressed_row_format" title="圧縮行フォーマット">COMPRESSED</a> が含まれます。<code class="literal">InnoDB</code> テーブルの場合、デフォルトでは、行は <code class="literal">COMPACT</code> フォーマット (<code class="literal">ROW_FORMAT=COMPACT</code>) で格納されます。<code class="literal">ROW_FORMAT</code> テーブルオプションの詳細は、<code class="literal">CREATE TABLE</code> のドキュメントを参照してください。
    </p><p>
      <code class="literal">InnoDB</code> テーブルの物理的な行構造は、指定した <code class="literal">ROW_FORMAT</code> によって異なります。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-physical-record" title="14.2.13.7 物理的な行構造">セクション14.2.13.7「物理的な行構造」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-row-format-dynamic"></a>14.9.3 DYNAMIC および COMPRESSED 行フォーマット</h3></div></div></div><a class="indexterm" name="idm139979071749840"></a><a class="indexterm" name="idm139979071747840"></a><a class="indexterm" name="idm139979071746400"></a><a class="indexterm" name="idm139979071744480"></a><a class="indexterm" name="idm139979071742976"></a><p>
      このセクションでは、InnoDB テーブルの <code class="literal">DYNAMIC</code> および <code class="literal">COMPRESSED</code> 行フォーマットについて説明します。これらの種類のテーブルは、<code class="literal">innodb_file_format</code> 構成オプションが <code class="literal">Barracuda</code> に設定されている場合にのみ作成できます。(Barracuda ファイル形式では、<code class="literal">COMPACT</code> および <code class="literal">REDUNDANT</code> 行フォーマットも許可されます。)
    </p><p>
      テーブルが <code class="literal">ROW_FORMAT=DYNAMIC</code> または <code class="literal">ROW_FORMAT=COMPRESSED</code> で作成された場合、長いカラム値は完全にオフページに格納され、クラスタ化されたインデックスレコードにはオーバーフローページへの 20 バイトのポインタのみが含まれます。
    </p><p>
      カラムがオフページに格納されるかどうかは、ページサイズおよび行の合計サイズによって異なります。その行が長すぎる場合は、クラスタ化されたインデックスレコードが B ツリーページに収まるまで、InnoDB はオフページストレージのもっとも長いカラムを選択します。40 バイト以下の <code class="literal">TEXT</code> および <code class="literal">BLOB</code> カラムは、常にインラインに格納されます。
    </p><p>
      <code class="literal">DYNAMIC</code> 行フォーマットは、(<code class="literal">COMPACT</code> および <code class="literal">REDUNDANT</code> フォーマットと同様に) 収まる場合は行全体をインデックスノード内に格納する効率性を維持しますが、この新しいフォーマットでは、長いカラムの多数のデータバイトで B ツリーノードがいっぱいになる問題が回避されます。<code class="literal">DYNAMIC</code> フォーマットは、長いデータ値の一部がオフページに格納される場合は通常、すべての値をオフページに格納するのがもっとも効率的であるという考え方に基づいています。<code class="literal">DYNAMIC</code> フォーマットでは、短いカラムは B ツリーノード内に残る可能性があるため、特定の行に必要なオーバーフローページの数が最小限に抑えられます。
    </p><p>
      <code class="literal">COMPRESSED</code> 行フォーマットは、オフページストレージに関して <code class="literal">DYNAMIC</code> 行フォーマットと同様の内部の詳細を使用するほか、追加のストレージ、圧縮されるテーブルおよびインデックスデータからのパフォーマンスの考慮事項、および小さいページサイズを使用します。<code class="literal">COMPRESSED</code> 行フォーマットでは、オプション <code class="literal">KEY_BLOCK_SIZE</code> によって、クラスタ化されたインデックスに格納されるカラムデータの量、およびオーバーフローページに配置される量が制御されます。<code class="literal">COMPRESSED</code> 行フォーマットの詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-compression" title="14.7 InnoDB 圧縮テーブル">セクション14.7「InnoDB 圧縮テーブル」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-row-format-antelope"></a>14.9.4 COMPACT および REDUNDANT 行フォーマット</h3></div></div></div><a class="indexterm" name="idm139979071716992"></a><a class="indexterm" name="idm139979071714960"></a><a class="indexterm" name="idm139979071713504"></a><a class="indexterm" name="idm139979071711584"></a><a class="indexterm" name="idm139979071710080"></a><p>
      InnoDB の早期のバージョンでは、データベースファイルに名前のないファイル形式 (現在は <a class="link" href="glossary.html#glos_antelope" title="Antelope">Antelope</a> と呼ばれます) を使用していました。そのファイル形式では、テーブルは <code class="literal">ROW_FORMAT=COMPACT</code> または <code class="literal">ROW_FORMAT=REDUNDANT</code> で定義されます。InnoDB は、可変長カラム (<code class="literal">BLOB</code> や <code class="literal">VARCHAR</code> など) の最初の 768 バイトまでを B ツリーノード内のインデックスレコードに格納し、残りの部分はオーバーフローページに格納されます。
    </p><p>
      これらの以前のバージョンとの互換性を維持するために、最新の InnoDB で作成されたテーブルは、デフォルトで <code class="literal">COMPACT</code> 行フォーマットになります。新しい <code class="literal">DYNAMIC</code> および <code class="literal">COMPRESSED</code> 行フォーマットについては、<a class="xref" href="innodb-storage-engine.html#innodb-row-format-dynamic" title="14.9.3 DYNAMIC および COMPRESSED 行フォーマット">セクション14.9.3「DYNAMIC および COMPRESSED 行フォーマット」</a>を参照してください。
    </p><p>
      Antelope ファイル形式では、カラムの値が 768 バイト以下の場合、オーバーフローページは必要なく、値が B ツリーノード内に格納されるために I/O がある程度削減される可能性があります。これは、比較的短い <code class="literal">BLOB</code> の場合に適切に機能しますが、B ツリーノードがキー値ではなくデータでいっぱいになり、それによって効率が低下する可能性があります。多数の <code class="literal">BLOB</code> カラムを含むテーブルでは、B ツリーノードがデータでいっぱいになり、含まれる行数が少なすぎるために、行が短い場合や、カラム値がオフページに格納される場合に比べてインデックス全体の効率が低下することがあります。
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-disk-management"></a>14.10 InnoDB のディスク I/O とファイル領域管理</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-disk-io">14.10.1 InnoDB ディスク I/O</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-space">14.10.2 ファイル領域管理</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-checkpoints">14.10.3 InnoDB チェックポイント</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-file-defragmenting">14.10.4 テーブルのデフラグ</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-truncate-table-reclaim-space">14.10.5 TRUNCATE TABLE によるディスク領域の再利用</a></span></dt></dl></div><p>
    DBA は、I/O サブシステムが飽和状態にならないようにディスク I/O を管理するとともに、ストレージデバイスがいっぱいにならないようにディスク領域を管理する必要があります。<a class="link" href="glossary.html#glos_acid" title="ACID">ACID</a> 設計モデルには、冗長に見える可能性はあっても、データの信頼性の確保に役立つ、ある一定の量の I/O が必要です。これらの制約の中で、<code class="literal">InnoDB</code> は、ディスク I/O の量を最小限に抑えるためにデータベースの動作やディスクファイルの編成を最適化しようとします。場合によって、I/O は、データベースがビジー状態でなくなるまで、または<a class="link" href="glossary.html#glos_fast_shutdown" title="高速シャットダウン">高速シャットダウン</a>のあとのデータベースの再起動中など、すべてを一貫性のある状態に移行することが必要になるまで延期されます。
  </p><p>
    このセクションでは、デフォルトの種類の MySQL テーブル (<code class="literal">InnoDB</code> テーブルとも呼ばれます) での I/O とディスク領域に関する主な考慮事項について説明します。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        クエリーパフォーマンスを向上させるために使用されるバックグラウンド I/O の量の制御。
      </p></li><li class="listitem"><p>
        追加の I/O を削減する代わりに耐久性を向上させる機能の有効化または無効化。
      </p></li><li class="listitem"><p>
        テーブルの、多数の小さなファイル、いくつかのより大きなファイル、またはその両方の組み合わせへの編成。
      </p></li><li class="listitem"><p>
        Redo ログファイルのサイズと、ログファイルがいっぱいになったときに発生する I/O アクティビティーとのバランス。
      </p></li><li class="listitem"><p>
        テーブルを最適なクエリーパフォーマンスのために再編成する方法。
      </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-disk-io"></a>14.10.1 InnoDB ディスク I/O</h3></div></div></div><a class="indexterm" name="idm139979071680720"></a><p>
      <code class="literal">InnoDB</code> は、可能であれば、I/O 操作を処理するための複数のスレッドを作成することによって非同期ディスク I/O を使用します。それにより、その I/O がまだ進行中の間もほかのデータベース操作を続行できるようにします。Linux および Windows プラットフォームでは、InnoDB は、使用可能な OS とライブラリ関数を使用して<span class="quote">「<span class="quote">ネイティブな</span>」</span>非同期 I/O を実行します。その他のプラットフォームの場合も、InnoDB は引き続き I/O スレッドを使用しますが、これらのスレッドが実際には I/O 要求の完了を待つ可能性があります。この手法は<span class="quote">「<span class="quote">シミュレートされた</span>」</span>非同期 I/O と呼ばれます。
    </p><h4><a name="idm139979071675696"></a>先読み</h4><p>
      InnoDB は、データがすぐに必要になる可能性が高いと判断できる場合は先読み操作を実行して、そのデータをメモリー内で使用できるようにバッファープールに移動します。連続したデータに対しては、いくつかの大きな読み取り要求を作成する方が、複数の拡散した小さな要求を作成するより効率的である場合があります。InnoDB には、次の 2 つの先読みに関する経験則があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          シーケンシャル先読みでは、テーブルスペース内のセグメントへのアクセスパターンがシーケンシャルであることに気付くと、<code class="literal">InnoDB</code> はデータベースページの読み取りのバッチを I/O システムにあらかじめ送信します。
        </p></li><li class="listitem"><p>
          ランダム先読みでは、テーブルスペース内の一部の領域がバッファープールに完全に読み取られている最中であることに気付くと、<code class="literal">InnoDB</code> は残りの読み取りを I/O システムに送信します。
        </p></li></ul></div><h4><a name="idm139979071669488"></a>二重書き込みバッファー</h4><a class="indexterm" name="idm139979071668768"></a><a class="indexterm" name="idm139979071667392"></a><p>
      <code class="literal">InnoDB</code> は、<a class="link" href="glossary.html#glos_doublewrite_buffer" title="二重書き込みバッファー">二重書き込みバッファー</a>と呼ばれる構造に関連した斬新なファイルフラッシュ手法を使用しています。これはデフォルトで有効になっています (<code class="literal">innodb_doublewrite=ON</code>)。これにより、クラッシュや停電のあとのリカバリの安全性が高まるだけでなく、<code class="literal">fsync()</code> 操作の必要性が減るため、ほとんどの種類の Unix でパフォーマンスが向上します。
    </p><p>
      データファイルにページを書き込む前に、<code class="literal">InnoDB</code> はまず、それらのページを二重書き込みバッファーと呼ばれる連続したテーブルスペース領域に書き込みます。二重書き込みバッファーへの書き込みとフラッシュが完了したあとにはじめて、<code class="literal">InnoDB</code> はそれらのページをデータファイル内の適切な位置に書き込みます。ページ書き込みの最中にオペレーティングシステム、ストレージサブシステム、または <span class="command"><strong>mysqld</strong></span> プロセスのクラッシュ (それによる<a class="link" href="glossary.html#glos_torn_page" title="破損ページ">破損ページ</a>の状態) が発生した場合、<code class="literal">InnoDB</code> は、あとでリカバリ中にそのページの正常なコピーを二重書き込みバッファーから見つけることができます。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-file-space"></a>14.10.2 ファイル領域管理</h3></div></div></div><a class="indexterm" name="idm139979071652672"></a><p>
      構成ファイルで定義するデータファイルによって、<code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">システムテーブルスペース</a>が形成されます。これらのファイルは、テーブルスペースを形成するために論理的に連結されます。ストライピングは使用されません。現在、テーブルスペース内のどこにテーブルが割り当てられるかを定義することはできません。新しく作成されたテーブルスペースでは、<code class="literal">InnoDB</code> は最初のデータファイルから領域を割り当てます。
    </p><p>
      システムテーブルスペースの内部にすべてのテーブルおよびインデックスを格納することによって発生する問題を回避するために、<code class="literal">innodb_file_per_table</code> 構成オプションをオンにすることができます。このオプションは、新しく作成された各テーブルを個別のテーブルスペースファイル内に (拡張子 <code class="literal">.ibd</code> で) 格納します。この方法で格納されたテーブルの場合、ディスクファイル内の断片化は減少し、テーブルが切り捨てられると、その領域は InnoDB によって引き続きシステムテーブルスペース内に予約されるのではなく、オペレーティングシステムに返されます。
    </p><h4><a name="idm139979071643376"></a>ページ、エクステント、セグメント、およびテーブルスペース</h4><p>
      各テーブルスペースは、データベース<a class="link" href="glossary.html#glos_page" title="ページ">ページ</a>で構成されます。MySQL インスタンス内のテーブルスペースはすべて、同じ<a class="link" href="glossary.html#glos_page_size" title="page size">ページサイズ</a>を持っています。デフォルトでは、すべてのテーブルスペースが 16K バイトのページサイズを持っています。このページサイズを 8K バイトまたは 4K バイトに減らすには、MySQL インスタンスを作成するときに <code class="literal">innodb_page_size</code> オプションを指定します。
    </p><p>
      これらのページは、サイズ 1M バイトの<a class="link" href="glossary.html#glos_extent" title="エクステント">エクステント</a> (連続した 64 個の 16K バイトページ、128 個の 8K バイトページ、または 256 個の 4K バイトページ) にグループ化されます。<code class="literal">InnoDB</code> では、テーブルスペース内部の<span class="quote">「<span class="quote">ファイル</span>」</span>を<a class="link" href="glossary.html#glos_segment" title="セグメント">セグメント</a>と呼びます。(これらのセグメントは、実際に多数のテーブルスペースセグメントが含まれている<a class="link" href="glossary.html#glos_rollback_segment" title="ロールバックセグメント">ロールバックセグメント</a>とは異なります。)
    </p><p>
      セグメントがテーブルスペース内部で拡張される場合、<code class="literal">InnoDB</code> は、そのセグメントに最初の 32 ページを一度に割り当てます。そのあと、<code class="literal">InnoDB</code> は、そのセグメントへのすべてのエクステントの割り当てを開始します。<code class="literal">InnoDB</code> は、データの良好な連続性を保証するために、大きなセグメントには 1 回につき最大 4 つのエクステントを追加できます。
    </p><p>
      <code class="literal">InnoDB</code> では、各インデックスに 2 つのセグメントが割り当てられます。1 つは B ツリーの非リーフノード用、もう 1 つはリーフノード用です。リーフノードをディスク上で連続した状態に維持すると、これらのリーフノードには実際のテーブルデータが含まれているため、シーケンシャル I/O 操作の性能が向上します。
    </p><p>
      テーブルスペース内の一部のページにはほかのページのビットマップが含まれているため、<code class="literal">InnoDB</code> テーブルスペース内のいくつかのエクステントは全体としてではなく、個々のページとしてのみセグメントに割り当てることができます。
    </p><p>
      <code class="literal">SHOW TABLE STATUS</code> ステートメントを発行することによってテーブルスペース内の使用可能な空き領域を求めると、<code class="literal">InnoDB</code> は、テーブルスペース内の確実に空いているエクステントをレポートします。<code class="literal">InnoDB</code> は、常にいくつかのエクステントをクリーンアップやその他の内部の目的のために予約します。これらの予約されたエクステントは空き領域に含まれません。
    </p><p>
      テーブルからデータを削除すると、<code class="literal">InnoDB</code> は、対応する B ツリーインデックスを短くします。解放された領域をほかのユーザーが使用できるようになるかどうかは、削除のパターンがテーブルスペースに対して個々のページまたはエクステントのどちらを解放するかによって異なります。テーブルを削除したりテーブルのすべての行を削除したりすると、その領域は確実にほかのユーザーに解放されますが、それらの削除された行は、それの行がトランザクションロールバックまたは一貫性読み取りに必要なくなったあと、しばらくして自動的に発生する<a class="link" href="glossary.html#glos_purge" title="パージ">パージ</a>操作によってのみ物理的に削除されることに注意してください。(<a class="xref" href="innodb-storage-engine.html#innodb-multi-versioning" title="14.2.12 InnoDB マルチバージョン">セクション14.2.12「InnoDB マルチバージョン」</a>を参照してください。)
    </p><a class="indexterm" name="idm139979071619472"></a><a class="indexterm" name="idm139979071617360"></a><a class="indexterm" name="idm139979071615440"></a><p>
      テーブルスペースに関する情報を表示するには、テーブルスペースモニターを使用します。<a class="xref" href="innodb-storage-engine.html#innodb-monitors" title="14.15 InnoDB モニター">セクション14.15「InnoDB モニター」</a>を参照してください。
    </p><h4><a name="idm139979071611888"></a>ページのテーブル行への関連付け</h4><p>
      可変長カラム (<code class="literal">VARBINARY</code>、<code class="literal">VARCHAR</code>、<code class="literal">BLOB</code>、および <code class="literal">TEXT</code>) を除き、行の最大長はデータベースページの半分より少し短くなります。つまり、行の最大長は約 8000 バイトです。<code class="literal">LONGBLOB</code> および <code class="literal">LONGTEXT</code> カラムは 4G バイト未満である必要があり、<code class="literal">BLOB</code> および <code class="literal">TEXT</code> カラムを含む行全体の長さは 4G バイト未満である必要があります。
    </p><p>
      行の長さが 1 ページの半分より短い場合は、行全体がそのページ内にローカルに格納されます。それが 1 ページの半分を超える場合は、行が 1 ページの半分内に収まるまで、外部のオフページストレージとして可変長カラムが選択されます。オフページストレージとして選択されたカラムの場合、<code class="literal">InnoDB</code> は最初の 768 バイトをその行にローカルに格納し、残りを外部のオーバーフローページに格納します。このような各カラムには、オーバーフローページの独自のリストがあります。768 バイトのプリフィクスには、そのカラムの実際の長さを格納し、値の残りの部分が格納されているオーバーフローページリストを指す 20 バイトの値が付随します。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-checkpoints"></a>14.10.3 InnoDB チェックポイント</h3></div></div></div><a class="indexterm" name="idm139979071597600"></a><p>
      <a class="link" href="glossary.html#glos_log_file" title="ログファイル">ログファイル</a>を非常に大きくすると、<a class="link" href="glossary.html#glos_checkpoint" title="チェックポイント">チェックポイント設定</a>中のディスク I/O が少なくなる可能性があります。ログファイルの合計サイズは多くの場合、バッファープールと同じか、またはそれより大きい設定が適切です。以前は、ログファイルが大きいとクラッシュリカバリに非常に長い時間がかかることがありましたが、MySQL 5.5 以降では、クラッシュリカバリのパフォーマンス向上により、クラッシュ後の起動を高速にして大きなログファイルを使用することが可能になっています。(厳密に言うと、このパフォーマンス向上は、InnoDB Plugin 1.0.7 以降を含む MySQL 5.1 で実現できます。この向上をデフォルトの InnoDB ストレージエンジンで実現できるのは MySQL 5.5 からです。)
    </p><h4><a name="idm139979071591312"></a>チェックポイント処理の動作のしくみ</h4><p>
      <code class="literal">InnoDB</code> は、<a class="link" href="glossary.html#glos_fuzzy_checkpointing" title="ファジーチェックポイント">ファジーチェックポイント設定</a>と呼ばれる<a class="link" href="glossary.html#glos_checkpoint" title="チェックポイント">チェックポイント</a>メカニズムを実装しています。<code class="literal">InnoDB</code> は、変更されたデータベースページをバッファープールから小さなバッチにフラッシュします。バッファープールを 1 つのバッチにフラッシュする必要はありません。それを行うと、チェックポイント設定プロセス中にユーザーの SQL ステートメントの処理が中断されます。
    </p><p>
      <a class="link" href="glossary.html#glos_crash_recovery" title="クラッシュリカバリ">クラッシュリカバリ</a>中に、<code class="literal">InnoDB</code> は、ログファイルに書き込まれたチェックポイントラベルを探します。それは、そのラベルの前にあるデータベースへのすべての変更がデータベースのディスクイメージ内に存在することを知っています。次に、<code class="literal">InnoDB</code> はそのチェックポイントから前方にログファイルをスキャンしながら、ログに記録された変更をデータベースに適用します。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-file-defragmenting"></a>14.10.4 テーブルのデフラグ</h3></div></div></div><a class="indexterm" name="idm139979071580720"></a><a class="indexterm" name="idm139979071577824"></a><p>
      セカンダリインデックスへのランダムな挿入やセカンダリインデックスからのランダムな削除によって、インデックスが断片化される場合があります。断片化とは、ディスク上のインデックスページの物理的な順序がページ上のレコードのインデックス順序とかけ離れているか、またはインデックスに割り当てられた 64 ページのブロック内に未使用のページが多数存在することを示します。
    </p><p>
      断片化の 1 つの現象として、あるテーブルが占めている領域が、本来占めている<span class="quote">「<span class="quote">はずの</span>」</span>領域より大きいことがあります。それが正確にどの程度かを判定するのは困難です。<code class="literal">InnoDB</code> のデータとインデックスはすべて B ツリー内に格納され、それらの<a class="link" href="glossary.html#glos_fill_factor" title="フィルファクタ">フィルファクタ</a>は 50% から 100% まで変動する可能性があります。断片化の別の現象として、次のようなテーブルスキャンにかかる時間が、本来かかる<span class="quote">「<span class="quote">はずの</span>」</span>時間より長いことがあります。
    </p><pre class="programlisting">
SELECT COUNT(*) FROM t WHERE <em class="replaceable"><code>non_indexed_column</code></em> &lt;&gt; 12345;
</pre><p>
      前のクエリーでは、MySQL が、大きなテーブルに対してもっとも遅いタイプのクエリーであるフルテーブルスキャンを実行する必要があります。
    </p><p>
      インデックススキャンを高速化するために、MySQL にテーブルを再構築させる次の<span class="quote">「<span class="quote">null</span>」</span> <code class="literal">ALTER TABLE</code> 操作を定期的に実行できます。
    </p><pre class="programlisting">
ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> ENGINE=INNODB
</pre><p>
      MySQL 5.6.3 の時点では、<code class="literal">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> FORCE</code> を使用して、テーブルを再構築する<span class="quote">「<span class="quote">null</span>」</span>変更操作を実行することもできます。以前は、<code class="literal">FORCE</code> オプションは認識されましたが、無視されました。
    </p><p>
      MySQL 5.6.17 の時点では、<code class="literal">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> ENGINE=INNODB</code> と <code class="literal">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> FORCE</code> の両方が<a class="link" href="innodb-storage-engine.html#innodb-online-ddl" title="14.11 InnoDB とオンライン DDL">オンライン DDL</a> (<code class="literal">ALGORITHM=COPY</code>) を使用します。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-create-index-overview" title="14.11.1 オンライン DDL の概要">セクション14.11.1「オンライン DDL の概要」</a>を参照してください。
    </p><p>
      デフラグ操作を実行するための別の方法として、<span class="command"><strong>mysqldump</strong></span> を使用してテーブルをテキストファイルにダンプし、テーブルを削除してから、それをダンプファイルからリロードする方法があります。
    </p><p>
      インデックスへの挿入が常に昇順であり、かつレコードが末尾からしか削除されない場合は、<code class="literal">InnoDB</code> のファイル領域管理アルゴリズムにより、インデックス内の断片化は発生しないことが保証されます。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-truncate-table-reclaim-space"></a>14.10.5 TRUNCATE TABLE によるディスク領域の再利用</h3></div></div></div><p>
      <code class="literal">InnoDB</code> テーブルを<a class="link" href="glossary.html#glos_truncate" title="切り捨て">切り捨てる</a>ときにオペレーティングシステムのディスク領域を再利用するには、そのテーブルが独自の <a class="link" href="glossary.html#glos_ibd_file" title=".ibd ファイル">.ibd</a> ファイルに格納されている必要があります。独自の <a class="link" href="glossary.html#glos_ibd_file" title=".ibd ファイル">.ibd</a> ファイルに格納されるテーブルの場合は、そのテーブルを作成するときに <code class="literal">innodb_file_per_table</code> を有効にする必要があります。さらに、切り捨てられるテーブルとその他のテーブルの間に<a class="link" href="glossary.html#glos_foreign_key" title="外部キー">外部キー</a>制約が存在していてはいけません。そうしないと、<code class="literal">TRUNCATE TABLE</code> 操作は失敗します。ただし、同じテーブル内の 2 つのカラム間の外部キー制約は許可されます。
    </p><p>
      テーブルが切り捨てられると、そのテーブルが削除されて新しい <code class="filename">.ibd</code> ファイル内に再作成され、解放された領域はオペレーティングシステムに返されます。これは、<code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">システムテーブルスペース</a>内に格納されている <code class="literal">InnoDB</code> テーブル (<code class="literal">innodb_file_per_table=OFF</code> のときに作成されるテーブル) の切り捨てとは対照的です。この場合は、そのテーブルが切り捨てられたあと、解放された領域は <code class="literal">InnoDB</code> しか使用できません。
    </p><p>
      テーブルを切り捨て、そのディスク領域をオペレーティングシステムに返す機能はまた、<a class="link" href="glossary.html#glos_physical_backup" title="物理バックアップ">物理バックアップ</a>を小さくすることもできます。システムテーブルスペースに格納されているテーブル (<code class="literal">innodb_file_per_table=OFF</code> のときに作成されるテーブル) の切り詰めでは、未使用領域のブロックがシステムテーブルスペース内に残されます。
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-online-ddl"></a>14.11 InnoDB とオンライン DDL</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-create-index-overview">14.11.1 オンライン DDL の概要</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-create-index-concurrency">14.11.2 オンライン DDL でのパフォーマンスと並列性に関する考慮事項</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-online-ddl-syntax">14.11.3 オンライン DDL の SQL 構文</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-online-ddl-single-multi">14.11.4 DDL ステートメントの結合または分離</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-create-index-examples">14.11.5 オンライン DDL の例</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-create-index-implementation">14.11.6 オンライン DDL の実装の詳細</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-create-index-recovery">14.11.7 オンライン DDL でのクラッシュリカバリの動作のしくみ</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#online-ddl-partitioning">14.11.8 パーティション化された InnoDB テーブルに対するオンライン DDL</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-create-index-limitations">14.11.9 オンライン DDL の制限</a></span></dt></dl></div><a class="indexterm" name="idm139979071533152"></a><a class="indexterm" name="idm139979071531680"></a><a class="indexterm" name="idm139979071530336"></a><p>
    <a class="link" href="glossary.html#glos_online_ddl" title="オンライン DDL">オンライン DDL</a> 機能は、MySQL 5.1 および MySQL 5.5 で使用可能な<a class="ulink" href="http://dev.mysql.com/doc/refman/5.5/en/innodb-create-index.html" target="_top">InnoDB Fast Index Creation</a>機能に基づいて構築されています。<a class="ulink" href="http://dev.mysql.com/doc/refman/5.5/en/innodb-create-index.html" target="_top">InnoDB Fast Index Creation</a>機能は、テーブルコピー動作を行わないように <code class="literal">CREATE INDEX</code> と <code class="literal">DROP INDEX</code> を最適化しました。MySQL 5.6 で導入された<a class="link" href="glossary.html#glos_online_ddl" title="オンライン DDL">オンライン DDL</a> 機能は、ほかのタイプの多くの <code class="literal">ALTER TABLE</code> 操作を、テーブルコピー、<a class="link" href="glossary.html#glos_ddl" title="DDL">DDL</a> が進行中の <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> 操作のブロック化、またはその両方を行わないように拡張しています。
  </p><p>
    <a class="link" href="glossary.html#glos_online_ddl" title="オンライン DDL">オンライン DDL</a> 機能には、次の利点があります。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        インデックスやカラム定義を変更する場合は常に、テーブルを数分または数時間にわたって使用できなくすることが現実的でないビジー状態の本番環境での応答性と可用性を向上させます。
      </p></li><li class="listitem"><p>
        テーブルへのアクセスを完全にブロックするか (<code class="literal">LOCK=EXCLUSIVE</code> 句)、クエリーを許可するが、DML は許可しないか (<code class="literal">LOCK=SHARED</code> 句)、またはテーブルへの完全なクエリーおよび DML アクセスを許可するか (<code class="literal">LOCK=NONE</code> 句) どうかを選択することによって、DDL 操作中のパフォーマンスと並列性のバランスを調整できます。<code class="literal">LOCK</code> 句を省略するか、または <code class="literal">LOCK=DEFAULT</code> を指定すると、MySQL は、操作の種類に応じてできるだけ高い並列性を許可します。
      </p></li><li class="listitem"><p>
        テーブルの新しいコピーを作成するのではなく、可能な場合はインプレースで変更を行うことによって、テーブルのコピーおよびすべてのセカンダリインデックスの再構築のためのディスク領域の使用量や I/O オーバーヘッドの一時的な増加が回避されます。
      </p></li></ul></div><p>
    MySQL クラスタの <code class="literal">NDB</code> ストレージエンジンは、オンラインのテーブルスキーマ変更もサポートしていますが、<code class="literal">InnoDB</code> のオンライン操作に使用されるものとは互換性のない独自の構文を使用します。詳細は、<a class="xref" href="sql-syntax.html#alter-table-online-operations" title="13.1.7.2 MySQL Cluster での ALTER TABLE オンライン操作">セクション13.1.7.2「MySQL Cluster での ALTER TABLE オンライン操作」</a>を参照してください。
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-create-index-overview"></a>14.11.1 オンライン DDL の概要</h3></div></div></div><a class="indexterm" name="idm139979071505744"></a><a class="indexterm" name="idm139979071504400"></a><p>
      従来より、<code class="literal">InnoDB</code> テーブルでの多くの <a class="link" href="glossary.html#glos_ddl" title="DDL">DDL</a> 操作は高いコストを必要としました。多くの <code class="literal">ALTER TABLE</code> 操作は、要求されたテーブルオプションとインデックスを使用して定義された新しい空のテーブルを作成してから、既存の行を新しいテーブルに 1 つずつコピーし、行が挿入されるたびにインデックスを更新することによって機能しました。元のテーブルのすべての行がコピーされたあと、古いテーブルが削除され、そのコピーの名前が元のテーブルの名前に変更されました。
    </p><p>
      MySQL 5.5、および InnoDB Plugin を含む MySQL 5.1 は、テーブルコピー動作を行わないように <code class="literal">CREATE INDEX</code> と <code class="literal">DROP INDEX</code> を最適化しました。その機能は、<a class="link" href="glossary.html#glos_fast_index_creation" title="高速インデックス作成">高速インデックス作成</a>と呼ばれました。MySQL 5.6 は、ほかのタイプの多くの <code class="literal">ALTER TABLE</code> 操作を、テーブルのコピーを行わないように拡張しています。別の拡張では、テーブルが変更されている最中に <code class="literal">SELECT</code> クエリーや <code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、および <code class="literal">DELETE</code> (<a class="link" href="glossary.html#glos_dml" title="DML">DML</a>) ステートメントの処理を続行できるようになります。この機能の組み合わせは現在、<a class="link" href="glossary.html#glos_online_ddl" title="オンライン DDL">オンライン DDL</a> と呼ばれます。
    </p><p>
      この新しいメカニズムはまた、一般に、セカンダリインデックスなしでテーブルを作成し、データがロードされたあとにセカンダリインデックスを追加することによって、テーブルとそれに関連付けられたインデックスを作成およびロードするプロセス全体を高速化できることも示しています。
    </p><p>
      <code class="literal">CREATE INDEX</code> または <code class="literal">DROP INDEX</code> コマンドで構文の変更は必要ありませんが、この操作のパフォーマンス、領域使用量、およびセマンティクスに影響を与える要因がいくつかあります (<a class="xref" href="innodb-storage-engine.html#innodb-create-index-limitations" title="14.11.9 オンライン DDL の制限">セクション14.11.9「オンライン DDL の制限」</a>を参照してください)。
    </p><p>
      MySQL 5.6 のオンライン DDL 拡張によって、以前はテーブルコピー、テーブルでの DML 操作のブロック、またはその両方を必要とした多くの DDL 操作が改善されます。<a class="xref" href="innodb-storage-engine.html#innodb-online-ddl-summary-grid" title="表 14.5 DDL 操作のオンラインステータスのサマリー">表14.5「DDL 操作のオンラインステータスのサマリー」</a>は、<code class="literal">ALTER TABLE</code> ステートメントの各種類と、オンライン DDL 機能がそれぞれにどのように適用されるかを示しています。
    </p><p>
      <code class="literal">ALTER TABLE</code> のパーティション化句を除き、パーティション化された <code class="literal">InnoDB</code> テーブルに対するオンライン DDL 操作は、通常の <code class="literal">InnoDB</code> テーブルに適用されるのと同じルールに従います。詳細は、<a class="xref" href="innodb-storage-engine.html#online-ddl-partitioning" title="14.11.8 パーティション化された InnoDB テーブルに対するオンライン DDL">セクション14.11.8「パーティション化された InnoDB テーブルに対するオンライン DDL」</a>を参照してください。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <span class="quote">「<span class="quote">インプレース?</span>」</span>カラムは、どの操作の場合に <code class="literal">ALGORITHM=INPLACE</code> 句が許可されるかを示しています。推奨される値は<span class="quote">「<span class="quote">はい</span>」</span>です。
        </p></li><li class="listitem"><p>
          <span class="quote">「<span class="quote">テーブルをコピー?</span>」</span>カラムは、どの操作の場合にコストの高いテーブルコピー操作を回避できるかを示しています。推奨される値は<span class="quote">「<span class="quote">いいえ</span>」</span>です。<code class="literal">ALGORITHM=INPLACE</code> は許可されるが、ある程度の量のテーブルコピーが引き続き必要な操作がいくつかある点を除き、このカラムはほぼ、<span class="quote">「<span class="quote">インプレース?</span>」</span>カラムの反対です。
        </p></li><li class="listitem"><p>
          <span class="quote">「<span class="quote">並列 DML を許可?</span>」</span>カラムは、どの操作を完全にオンラインで実行できるかを示しています。推奨される値は<span class="quote">「<span class="quote">はい</span>」</span>です。DDL 中に完全な並列性が許可されることを表明するために <code class="literal">LOCK=NONE</code> を指定できますが、MySQL は、可能な場合は自動的にこのレベルの並列性を許可します。並列 DML が許可されている場合は、並列クエリーも常に許可されます。
        </p></li><li class="listitem"><p>
          <span class="quote">「<span class="quote">並列クエリーを許可?</span>」</span>カラムは、どの DDL 操作の場合に、その操作の進行中にテーブルに対するクエリーが許可されるかを示しています。推奨される値は<span class="quote">「<span class="quote">はい</span>」</span>です。並列クエリーは、すべてのオンライン DDL 操作中に許可されます。これは、参考のために、すべてのセルに表示されている<span class="quote">「<span class="quote">はい</span>」</span>で示されています。DDL 中に並列クエリーが許可されることを表明するために <code class="literal">LOCK=SHARED</code> を指定できますが、MySQL は、可能な場合は自動的にこのレベルの並列性を許可します。
        </p></li><li class="listitem"><p>
          <span class="quote">「<span class="quote">注</span>」</span>カラムは、構成オプションの設定または DDL ステートメント内のほかの句によって答えが異なる場合など、ほかのカラムの<span class="quote">「<span class="quote">はい/いいえ</span>」</span>の値に例外がある場合はそれについて説明します。<span class="quote">「<span class="quote">はい*</span>」</span>と<span class="quote">「<span class="quote">いいえ*</span>」</span>の値は、これらの追加の注によって答えが異なることを示します。
        </p></li></ul></div><div class="table"><a name="innodb-online-ddl-summary-grid"></a><p class="title"><b>表 14.5 DDL 操作のオンラインステータスのサマリー</b></p><div class="table-contents"><table summary="DDL 操作のオンラインステータスのサマリー" border="1"><colgroup><col align="left"><col align="center"><col align="center"><col align="center"><col align="center"><col align="left"></colgroup><thead><tr><th scope="col" align="left">操作</th><th scope="col" align="center">インプレース?</th><th scope="col" align="center">テーブルをコピー?</th><th scope="col" align="center">並列 DML を許可?</th><th scope="col" align="center">並列クエリーを許可?</th><th scope="col" align="left">メモ</th></tr></thead><tbody><tr><td scope="row" align="left"><code class="literal">CREATE INDEX</code>、<code class="literal">ADD INDEX</code></td><td align="center">はい*</td><td align="center">いいえ*</td><td align="center">はい</td><td align="center">はい</td><td align="left"><code class="literal">FULLTEXT</code> インデックスにはいくつかの制限があります。次の行を参照してください。現在は、作成対象の同じインデックスも同じ <code class="literal">ALTER TABLE</code> ステートメント内の前の句によって削除された場合、この操作はインプレースではありません (つまり、テーブルをコピーします)。</td></tr><tr><td scope="row" align="left"><code class="literal">ADD FULLTEXT INDEX</code></td><td align="center">はい</td><td align="center">いいえ*</td><td align="center">いいえ</td><td align="center">はい</td><td align="left">ユーザーが指定した <code class="literal">FTS_DOC_ID</code> カラムがないかぎり、テーブルの最初の <code class="literal">FULLTEXT</code> インデックスの作成にはテーブルコピーが必要です。同じテーブル上の以降の <code class="literal">FULLTEXT</code> インデックスは、インプレースで作成できます。</td></tr><tr><td scope="row" align="left"><code class="literal">DROP INDEX</code></td><td align="center">はい</td><td align="center">いいえ</td><td align="center">はい</td><td align="center">はい</td><td align="left">データファイルではなく、<code class="literal">.frm</code> ファイルのみを変更します。</td></tr><tr><td scope="row" align="left"><code class="literal">OPTIMIZE TABLE</code></td><td align="center">はい</td><td align="center">はい</td><td align="center">はい</td><td align="center">はい</td><td align="left">MySQL 5.6.17 の時点では、<code class="literal">ALGORITHM=INPLACE</code> を使用します。<code class="literal">old_alter_table=1</code> または <span class="command"><strong>mysqld</strong></span> <code class="literal">--skip-new</code> オプションが有効になっている場合は、<code class="literal">ALGORITHM=COPY</code> が使用されます。FULLTEXT インデックスを含むテーブルでは、オンライン DDL (<code class="literal">ALGORITHM=INPLACE</code>) を使用した <code class="literal">OPTIMIZE TABLE</code> はサポートされません。</td></tr><tr><td scope="row" align="left">カラムのデフォルト値を設定する</td><td align="center">はい</td><td align="center">いいえ</td><td align="center">はい</td><td align="center">はい</td><td align="left">データファイルではなく、<code class="literal">.frm</code> ファイルのみを変更します。</td></tr><tr><td scope="row" align="left">カラムの<a class="link" href="glossary.html#glos_auto_increment" title="自動インクリメント">自動インクリメント</a>値を変更する</td><td align="center">はい</td><td align="center">いいえ</td><td align="center">はい</td><td align="center">はい</td><td align="left">データファイルではなく、メモリーに格納された値を変更します。</td></tr><tr><td scope="row" align="left"><a class="link" href="glossary.html#glos_foreign_key_constraint" title="FOREIGN KEY 制約">外部キー制約</a>を追加する</td><td align="center">はい*</td><td align="center">いいえ*</td><td align="center">はい</td><td align="center">はい</td><td align="left">テーブルのコピーを行わないようにするには、制約の作成中に <code class="literal">foreign_key_checks</code> を無効にします。</td></tr><tr><td scope="row" align="left"><a class="link" href="glossary.html#glos_foreign_key_constraint" title="FOREIGN KEY 制約">外部キー制約</a>を削除する</td><td align="center">はい</td><td align="center">いいえ</td><td align="center">はい</td><td align="center">はい</td><td align="left"><code class="literal">foreign_key_checks</code> オプションを有効または無効にすることができます。</td></tr><tr><td scope="row" align="left">カラムを名前変更する</td><td align="center">はい*</td><td align="center">いいえ*</td><td align="center">はい*</td><td align="center">はい</td><td align="left">並列 DML を許可するには、同じデータ型を維持し、カラム名のみを変更します。</td></tr><tr><td scope="row" align="left">カラムを追加する</td><td align="center">はい</td><td align="center">はい</td><td align="center">はい*</td><td align="center">はい</td><td align="left"><a class="link" href="glossary.html#glos_auto_increment" title="自動インクリメント">自動インクリメント</a>カラムを追加する場合は、並列 DML が許可されません。<code class="literal">ALGORITHM=INPLACE</code> は許可されますが、データが大幅に再編成されるため、依然としてコストの高い操作です。</td></tr><tr><td scope="row" align="left">カラムを削除する</td><td align="center">はい</td><td align="center">はい</td><td align="center">はい</td><td align="center">はい</td><td align="left"><code class="literal">ALGORITHM=INPLACE</code> は許可されますが、データが大幅に再編成されるため、依然としてコストの高い操作です。</td></tr><tr><td scope="row" align="left">カラムを並べ替える</td><td align="center">はい</td><td align="center">はい</td><td align="center">はい</td><td align="center">はい</td><td align="left"><code class="literal">ALGORITHM=INPLACE</code> は許可されますが、データが大幅に再編成されるため、依然としてコストの高い操作です。</td></tr><tr><td scope="row" align="left"><code class="literal">ROW_FORMAT</code> プロパティーを変更する</td><td align="center">はい</td><td align="center">はい</td><td align="center">はい</td><td align="center">はい</td><td align="left"><code class="literal">ALGORITHM=INPLACE</code> は許可されますが、データが大幅に再編成されるため、依然としてコストの高い操作です。</td></tr><tr><td scope="row" align="left"><code class="literal">KEY_BLOCK_SIZE</code> プロパティーを変更する</td><td align="center">はい</td><td align="center">はい</td><td align="center">はい</td><td align="center">はい</td><td align="left"><code class="literal">ALGORITHM=INPLACE</code> は許可されますが、データが大幅に再編成されるため、依然としてコストの高い操作です。</td></tr><tr><td scope="row" align="left">カラム <code class="literal">NULL</code> を作成する</td><td align="center">はい</td><td align="center">はい</td><td align="center">はい</td><td align="center">はい</td><td align="left"><code class="literal">ALGORITHM=INPLACE</code> は許可されますが、データが大幅に再編成されるため、依然としてコストの高い操作です。</td></tr><tr><td scope="row" align="left">カラム <code class="literal">NOT NULL</code> を作成する</td><td align="center">はい*</td><td align="center">はい</td><td align="center">はい</td><td align="center">はい</td><td align="left"><code class="literal">SQL_MODE</code> に <code class="literal">strict_all_tables</code> または <code class="literal">strict_all_tables</code> が含まれている場合は、カラムに Null が含まれていると操作は失敗します。<code class="literal">ALGORITHM=INPLACE</code> は許可されますが、データが大幅に再編成されるため、依然としてコストの高い操作です。</td></tr><tr><td scope="row" align="left">カラムのデータ型を変更する</td><td align="center">いいえ</td><td align="center">はい</td><td align="center">いいえ</td><td align="center">はい</td><td align="left"> </td></tr><tr><td scope="row" align="left"><a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a>を追加する</td><td align="center">はい*</td><td align="center">はい</td><td align="center">はい</td><td align="center">はい</td><td align="left"><code class="literal">ALGORITHM=INPLACE</code> は許可されますが、データが大幅に再編成されるため、依然としてコストの高い操作です。カラムを <code class="literal">NOT NULL</code> に変換する必要がある場合は、特定の状況では <code class="literal">ALGORITHM=INPLACE</code> が許可されません。<a class="xref" href="innodb-storage-engine.html#online-ddl-ex-primary-key" title="例 14.9 主キーの作成および削除">例14.9「主キーの作成および削除」</a>を参照してください。</td></tr><tr><td scope="row" align="left"><a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a>を削除して別の主キーを追加する</td><td align="center">はい</td><td align="center">はい</td><td align="center">はい</td><td align="center">はい</td><td align="left"><code class="literal">ALGORITHM=INPLACE</code> は、同じ <code class="literal">ALTER TABLE</code> で新しい主キーを追加する場合にのみ許可されます。データが大幅に再編成されるため、これは依然としてコストの高い操作です。</td></tr><tr><td scope="row" align="left"><a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a>を削除する</td><td align="center">いいえ</td><td align="center">はい</td><td align="center">いいえ</td><td align="center">はい</td><td align="left">同じ <code class="literal">ALTER TABLE</code> ステートメントで新しい主キーを追加することなく主キーを削除する場合は、制限が適用されます。</td></tr><tr><td scope="row" align="left">文字セットを変換する</td><td align="center">いいえ</td><td align="center">はい</td><td align="center">いいえ</td><td align="center">はい</td><td align="left">新しい文字エンコーディングが別のものである場合は、テーブルを再構築します。</td></tr><tr><td scope="row" align="left">文字セットを指定する</td><td align="center">いいえ</td><td align="center">はい</td><td align="center">いいえ</td><td align="center">はい</td><td align="left">新しい文字エンコーディングが別のものである場合は、テーブルを再構築します。</td></tr><tr><td scope="row" align="left"><code class="literal">FORCE</code> オプションを使用して再構築する</td><td align="center">はい</td><td align="center">はい</td><td align="center">はい</td><td align="center">はい</td><td align="left">MySQL 5.6.17 の時点では、<code class="literal">ALGORITHM=INPLACE</code> を使用します。<code class="literal">old_alter_table=1</code> または <span class="command"><strong>mysqld</strong></span> <code class="literal">--skip-new</code> オプションが有効になっている場合は、<code class="literal">ALGORITHM=COPY</code> が使用されます。FULLTEXT インデックスを含むテーブルでは、オンライン DDL (<code class="literal">ALGORITHM=INPLACE</code>) を使用したテーブル再構築はサポートされません。</td></tr><tr><td scope="row" align="left"><span class="quote">「<span class="quote">null</span>」</span> <code class="literal">ALTER TABLE ... ENGINE=INNODB</code> を使用して再構築する</td><td align="center">はい</td><td align="center">はい</td><td align="center">はい</td><td align="center">はい</td><td align="left">MySQL 5.6.17 の時点では、<code class="literal">ALGORITHM=INPLACE</code> を使用します。<code class="literal">old_alter_table=1</code> または <span class="command"><strong>mysqld</strong></span> <code class="literal">--skip-new</code> オプションが有効になっている場合は、<code class="literal">ALGORITHM=COPY</code> が使用されます。FULLTEXT インデックスを含むテーブルでは、オンライン DDL (<code class="literal">ALGORITHM=INPLACE</code>) を使用したテーブル再構築はサポートされません。</td></tr><tr><td scope="row" align="left">テーブルレベルの<a class="link" href="glossary.html#glos_persistent_statistics" title="永続的統計">永続的統計</a>オプション (<code class="literal">STATS_PERSISTENT</code>、<code class="literal">STATS_AUTO_RECALC</code> <code class="literal">STATS_SAMPLE_PAGES</code>) を設定する</td><td align="center">はい</td><td align="center">いいえ</td><td align="center">はい</td><td align="center">はい</td><td align="left">データファイルではなく、<code class="literal">.frm</code> ファイルのみを変更します。</td></tr></tbody></table></div></div><br class="table-break"><p>
      次の各セクションでは、並列 DML、インプレース、またはその両方で実行できる主な操作のそれぞれについて、オンライン DDL に関連した基本的な構文と使用上の注意を示します。
    </p><h4><a name="idm139979071320864"></a>セカンダリインデックス</h4><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="link" href="glossary.html#glos_secondary_index" title="セカンダリインデックス">セカンダリインデックス</a>を作成する: <code class="literal">CREATE INDEX <em class="replaceable"><code>name</code></em> ON <em class="replaceable"><code>table</code></em> (<em class="replaceable"><code>col_list</code></em>)</code> または <code class="literal">ALTER TABLE <em class="replaceable"><code>table</code></em> ADD INDEX <em class="replaceable"><code>name</code></em> (<em class="replaceable"><code>col_list</code></em>)</code>。(<code class="literal">FULLTEXT</code> インデックスの作成にはテーブルのロックが引き続き必要です。)
        </p></li><li class="listitem"><p>
          <a class="link" href="glossary.html#glos_secondary_index" title="セカンダリインデックス">セカンダリインデックス</a>を削除する: <code class="literal">DROP INDEX <em class="replaceable"><code>name</code></em> ON <em class="replaceable"><code>table</code></em>;</code> または <code class="literal">ALTER TABLE <em class="replaceable"><code>table</code></em> DROP INDEX <em class="replaceable"><code>name</code></em></code>
        </p></li></ul></div><p>
      <code class="literal">InnoDB</code> テーブルでのセカンダリインデックスの作成および削除では、MySQL 5.5 や <code class="literal">InnoDB</code> Plugin を含む MySQL 5.1 と同様に、テーブルコピー動作がスキップされます。
    </p><p>
      MySQL 5.6 以降では、インデックスが作成または削除されている間も、そのテーブルの読み取りおよび書き込み操作は可能なままです。<code class="literal">CREATE INDEX</code> または <code class="literal">DROP INDEX</code> ステートメントは、インデックスの初期状態にテーブルの最新の内容が反映されるように、そのテーブルにアクセスしているすべてのトランザクションが完了したあとでのみ完了します。以前は、インデックスが作成または削除されている間にテーブルを変更すると、通常は<a class="link" href="glossary.html#glos_deadlock" title="デッドロック">デッドロック</a>が発生し、それによりテーブルでの <code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、または <code class="literal">DELETE</code> ステートメントが取り消されました。
    </p><h4><a name="idm139979071299152"></a>カラムのプロパティー</h4><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          カラムのデフォルト値を設定する: <code class="literal">ALTER TABLE <em class="replaceable"><code>tbl</code></em> ALTER COLUMN <em class="replaceable"><code>col</code></em> SET DEFAULT <em class="replaceable"><code>literal</code></em></code> または <code class="literal">ALTER TABLE <em class="replaceable"><code>tbl</code></em> ALTER COLUMN <em class="replaceable"><code>col</code></em> DROP DEFAULT</code>
        </p><p>
          カラムのデフォルト値は、<code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_data_dictionary" title="データディクショナリ">データディクショナリ</a>ではなく、そのテーブルの <a class="link" href="glossary.html#glos_frm_file" title=".frm ファイル">.frm ファイル</a>に格納されます。
        </p></li><li class="listitem"><p>
          カラムの<a class="link" href="glossary.html#glos_auto_increment" title="自動インクリメント">自動インクリメント</a>値の変更: <code class="literal">ALTER TABLE <em class="replaceable"><code>table</code></em> AUTO_INCREMENT=<em class="replaceable"><code>next_value</code></em>;</code>
        </p><p>
          特に、レプリケーションまたはシャーディングを使用した分散システムでは、テーブルの自動インクリメントカウンタを特定の値にリセットする場合があります。テーブルに挿入された次の行は、その自動インクリメントカラムの指定された値を使用します。この手法はまた、すべてのテーブルを定期的に空にしてリロードするデータウェアハウス環境でも使用できます。それにより、自動インクリメントのシーケンスを 1 から再開できます。
        </p></li><li class="listitem"><p>
          カラムの名前変更: <code class="literal">ALTER TABLE <em class="replaceable"><code>tbl</code></em> CHANGE <em class="replaceable"><code>old_col_name</code></em> <em class="replaceable"><code>new_col_name</code></em> <em class="replaceable"><code>datatype</code></em></code>
        </p><p>
          同じデータ型と <code class="literal">[NOT] NULL</code> 属性を維持して、カラム名のみを変更する場合、この操作は常にオンラインで実行できます。
        </p><p>
          この拡張の一部として、外部キー制約の一部であるカラムを名前変更できるようになりました。これは、以前は許可されていませんでした。外部キー定義は、新しいカラム名を使用するように自動的に更新されます。外部キーに参加しているカラムの名前変更は、<code class="literal">ALTER TABLE</code> のインプレースモードでのみ機能します。<code class="literal">ALGORITHM=COPY</code> 句を使用するか、またはその他の何らかの条件によってコマンドが内部的に <code class="literal">ALGORITHM=COPY</code> を使用した場合、<code class="literal">ALTER TABLE</code> ステートメントは失敗します。

        </p></li></ul></div><h4><a name="idm139979071277504"></a>外部キー</h4><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="link" href="glossary.html#glos_foreign_key_constraint" title="FOREIGN KEY 制約">外部キー制約</a>の追加または削除:
        </p><pre class="programlisting">
ALTER TABLE <em class="replaceable"><code>tbl1</code></em> ADD CONSTRAINT <em class="replaceable"><code>fk_name</code></em> FOREIGN KEY <em class="replaceable"><code>index</code></em> (<em class="replaceable"><code>col1</code></em>) REFERENCES <em class="replaceable"><code>tbl2</code></em>(<em class="replaceable"><code>col2</code></em>) <em class="replaceable"><code>referential_actions</code></em>;
ALTER TABLE <em class="replaceable"><code>tbl</code></em> DROP FOREIGN KEY <em class="replaceable"><code>fk_name</code></em>;
</pre><p>
          外部キーの削除は、<code class="literal">foreign_key_checks</code> オプションが有効または無効になった状態でオンラインで実行できます。外部キーをオンラインで作成するには、<code class="literal">foreign_key_checks</code> が無効になっている必要があります。
        </p><p>
          特定のテーブル上の外部キー制約の名前がわからない場合は、次のステートメントを発行し、各外部キーに対する <code class="literal">CONSTRAINT</code> 句で制約名を見つけます。
        </p><pre class="programlisting">
show create table <em class="replaceable"><code>table</code></em>\G
</pre><p>
          または、<code class="literal">information_schema.table_constraints</code> テーブルをクエリーし、<code class="literal">constraint_name</code> および <code class="literal">constraint_type</code> カラムを使用して外部キー名を識別します。
        </p><p>
          この拡張の結果として、外部キーとそれに関連付けられたインデックスを 1 つのステートメントで削除することも可能になりました。これは以前、厳密な順序で並べられた個別のステートメントを必要としました。
        </p><pre class="programlisting">
ALTER TABLE <em class="replaceable"><code>table</code></em> DROP FOREIGN KEY <em class="replaceable"><code>constraint</code></em>, DROP INDEX <em class="replaceable"><code>index</code></em>;
</pre></li></ul></div><p>
      変更されるテーブル内に<a class="link" href="glossary.html#glos_foreign_key" title="外部キー">外部キー</a>がすでに存在する (つまり、そのテーブルがいずれかの <code class="literal">FOREIGN KEY ... REFERENCE</code> 句を含む<a class="link" href="glossary.html#glos_child_table" title="子テーブル">子テーブル</a>である) 場合は、外部キーカラムに直接関連しない操作であっても、オンライン DDL 操作には次の追加の制限が適用されます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          このような子テーブルでのオンライン DDL 操作中は、並列 DML が許可されません。(この制限はバグとして評価中であり、解除される可能性があります。)
        </p></li><li class="listitem"><p>
          親テーブルが変更されたために、<code class="literal">CASCADE</code> または <code class="literal">SET NULL</code> パラメータを使用した <code class="literal">ON UPDATE</code> または <code class="literal">ON DELETE</code> 句によって子テーブル内で関連する変更が発生した場合は、子テーブルに対する <code class="literal">ALTER TABLE</code> が別のトランザクションのコミットも待機する可能性があります。
        </p></li></ul></div><p>
      同様に、あるテーブルが外部キー関係にある<a class="link" href="glossary.html#glos_parent_table" title="親テーブル">親テーブル</a>である場合、そこには <code class="literal">FOREIGN KEY</code> 句が含まれていなくても、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、または <code class="literal">DELETE</code> ステートメントによって子テーブル内で <code class="literal">ON UPDATE</code> または <code class="literal">ON DELETE</code> アクションが発生した場合は、そのテーブルが <code class="literal">ALTER TABLE</code> の完了を待機する可能性があります。
    </p><h4><a name="idm139979071239216"></a>ALGORITHM=COPY に関する注意</h4><p>
      <code class="literal">ALGORITHM=COPY</code> 句で実行される <code class="literal">ALTER TABLE</code> 操作はすべて、並列 DML 操作を妨げます。並列クエリーは、引き続き許可されます。つまり、テーブルコピー操作には常に、少なくとも <code class="literal">LOCK=SHARED</code> (クエリーを許可するが、DML は許可しない) の並列性の制限が含まれます。<code class="literal">LOCK=EXCLUSIVE</code> (DML とクエリーを妨げる) を指定することによって、このような操作の並列性をさらに制限できます。
    </p><h4><a name="idm139979071234080"></a>並列 DML ではあるが、テーブルコピーが引き続き必要</h4><p>
      その他の一部の <code class="literal">ALTER TABLE</code> 操作では、並列 DML は許可されますが、テーブルコピーが引き続き必要です。ただし、これらの操作のテーブルコピーは MySQL 5.5 以前の処理と比べて高速です。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          カラムの追加、削除、または並べ替え。
        </p></li><li class="listitem"><p>
          <a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a>の追加または削除。
        </p></li><li class="listitem"><p>
          テーブルの <code class="literal">ROW_FORMAT</code> または <code class="literal">KEY_BLOCK_SIZE</code> プロパティーの変更。
        </p></li><li class="listitem"><p>
          カラムの Null にできるステータスの変更。
        </p></li><li class="listitem"><p>
          <code class="literal">OPTIMIZE TABLE</code>
        </p></li><li class="listitem"><p>
          <code class="literal">FORCE</code> オプションを使用したテーブルの再構築
        </p></li><li class="listitem"><p>
          <span class="quote">「<span class="quote">null</span>」</span> <code class="literal">ALTER TABLE ... ENGINE=INNODB</code> ステートメントを使用したテーブルの再構築
        </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        新しいカラム、データ型、制約、インデックスなどによってデータベーススキーマが進化するにつれ、<code class="literal">CREATE TABLE</code> ステートメントを最新のテーブル定義が適用されるように維持してください。オンライン DDL のパフォーマンス向上があったとしても、スキーマの一部を作成し、そのあとに <code class="literal">ALTER TABLE</code> ステートメントを発行するより、最初から安定したデータベース構造を作成する方が効率的です。
      </p><p>
        このガイドラインの主な例外は、多数の行を含むテーブル上の<a class="link" href="glossary.html#glos_secondary_index" title="セカンダリインデックス">セカンダリインデックス</a>に関するものです。通常は、セカンダリインデックスを除き、すべての詳細が指定された状態でテーブルを作成し、データをロードしてから、セカンダリインデックスを作成する方法がもっとも効率的です。初期のデータがクリーンであることがわかっていて、ロードプロセス中に一貫性チェックが必要ない場合は、<a class="link" href="glossary.html#glos_foreign_key" title="外部キー">外部キー</a>でも同じ手法を使用できます (最初にデータをロードしてから、外部キーを設定します)。
      </p><p>
        <code class="literal">CREATE TABLE</code>、<code class="literal">CREATE INDEX</code>、<code class="literal">ALTER TABLE</code>、および同様のステートメントのどのようなシーケンスでテーブルを作成した場合でも、ステートメント <code class="literal">SHOW CREATE TABLE <em class="replaceable"><code>table</code></em>\G</code> (正式な形式には大文字の <code class="literal">\G</code> が必要です) を発行することによって、現在の形式のテーブルを再構築するために必要な SQL を取得できます。この出力には、場合によっては内部的に追加され、また新しいシステム上でのテーブルのクローニングや、同一の型を持つ外部キーカラムの設定を行うときに通常であれば省略する可能性がある数値精度、<code class="literal">NOT NULL</code>、<code class="literal">CHARACTER SET</code> などの句が示されます。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-create-index-concurrency"></a>14.11.2 オンライン DDL でのパフォーマンスと並列性に関する考慮事項</h3></div></div></div><a class="indexterm" name="idm139979071203344"></a><p>
      <a class="link" href="glossary.html#glos_online_ddl" title="オンライン DDL">オンライン DDL</a> によって、パフォーマンス、並列性、可用性、スケーラビリティーなどの MySQL 操作のいくつかの側面が改善されます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          テーブルでのクエリーや <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> 操作は DDL の進行中も処理を続行できるため、そのテーブルにアクセスするアプリケーションの応答性が向上します。MySQL サーバー全体にわたってほかのリソースの<a class="link" href="glossary.html#glos_locking" title="ロック">ロック</a>や待機が削減されるため、変更されるテーブルには関連しない操作であっても、スケーラビリティーの向上がもたらされます。
        </p></li><li class="listitem"><p>
          インプレース操作では、テーブルを再構築するためのディスク I/O や CPU サイクルが回避されるため、データベースにかかる全体的な負荷が最小限に抑えられるとともに、DDL 操作中に良好なパフォーマンスと高いスループットが維持されます。
        </p></li><li class="listitem"><p>
          インプレース操作では、すべてのデータがコピーされる場合に比べて<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>に読み取られるデータが削減されるため、以前は DDL 操作のあとの一時的なパフォーマンス低下の原因になる可能性のあった、頻繁にアクセスされるデータのメモリーからのパージが回避されます。
        </p></li></ul></div><p>
      オンライン操作に一時ファイルが必要な場合、<code class="literal">InnoDB</code> はそれらのファイルを元のテーブルを含むディレクトリではなく、一時ファイルディレクトリ内に作成します。このディレクトリがそのようなファイルを保持するほどに十分に大きくない場合は、<code class="literal">tmpdir</code> システム変数に別のディレクトリを設定する必要があることがあります。(<a class="xref" href="error-handling.html#temporary-files" title="B.5.4.4 MySQL が一時ファイルを格納する場所">セクションB.5.4.4「MySQL が一時ファイルを格納する場所」</a>を参照してください。)
    </p><h4><a name="idm139979071189040"></a>オンライン DDL のロックオプション</h4><p>
      InnoDB テーブルが DDL 操作によって変更されている間は、その操作の内部動作や <code class="literal">ALTER TABLE</code> ステートメントの <code class="literal">LOCK</code> 句に応じて、そのテーブルは<a class="link" href="glossary.html#glos_locking" title="ロック">ロックされる</a>場合とされない場合があります。デフォルトでは、MySQL は DDL 操作中にできるだけ少ないロックを使用します。この句は、ロックを通常の場合より制限的にする (それによって並列 DML、または DML とクエリーを制限する) ためか、またはある操作に対して何らかの期待されるレベルのロックが確実に許可されるようにするために指定します。主キーの作成または削除中に <code class="literal">LOCK</code> 句がその特定の種類の DDL 操作では使用できないロックのレベル (<code class="literal">LOCK=SHARED</code> や <code class="literal">LOCK=NONE</code> など) を指定している場合は、この句が表明のように機能するため、このステートメントはエラーで失敗します。次のリストは、もっとも許容的な場合からもっとも制限的な場合までの <code class="literal">LOCK</code> 句のさまざまな可能性を示しています。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">LOCK=NONE</code> を使用した DDL 操作では、クエリーと並列 DML の両方が許可されます。この句は、要求されたロックのタイプでこの種類の DDL 操作を実行できないと <code class="literal">ALTER TABLE</code> を失敗させるため、<code class="literal">LOCK=NONE</code> は、テーブルを完全に使用可能な状態に維持することが不可欠であり、かつそれができなければ DDL を取り消してもかまわない場合に指定します。たとえば、この句は、顧客のサインアップまたは購入に関連するテーブルの DDL で、コストの高い <code class="literal">ALTER TABLE</code> ステートメントの誤った発行によってこれらのテーブルが使用不可能にならないようにするために使用できます。
        </p></li><li class="listitem"><p>
          

          <code class="literal">LOCK=SHARED</code> を使用した DDL 操作では、テーブルへの書き込み (つまり、DML 操作) がすべてブロックされますが、そのテーブル内のデータは読み取ることができます。この句は、要求されたロックのタイプでこの種類の DDL 操作を実行できないと <code class="literal">ALTER TABLE</code> を失敗させるため、<code class="literal">LOCK=SHARED</code> は、テーブルをクエリーに対して使用可能な状態に維持することが不可欠であり、かつそれができなければ DDL を取り消してもかまわない場合に指定します。たとえば、この句は、DDL が完了するまでデータロード操作を遅らせてもかまわないが、クエリーを長時間遅らせることはできないデータウェアハウス内のテーブルの DDL で使用できます。
        </p></li><li class="listitem"><p>
          <code class="literal">LOCK=DEFAULT</code> を使用するか、または <code class="literal">LOCK</code> 句が省略された DDL 操作では、MySQL はその種類の操作で使用可能なもっとも低いレベルのロックを使用することにより、可能な場合は常に並列クエリー、DML、またはその両方を許可します。これは、そのテーブルのワークロードに基づいて可用性に関する問題が発生しないことがわかっている、事前に計画およびテストされた変更を行う場合に使用する設定です。
        </p></li><li class="listitem"><p>
          

          <code class="literal">LOCK=EXCLUSIVE</code> を使用した DDL 操作では、クエリーと DML 操作の両方がブロックされます。この句は、要求されたロックのタイプでこの種類の DDL 操作を実行できないと <code class="literal">ALTER TABLE</code> を失敗させるため、<code class="literal">LOCK=EXCLUSIVE</code> は、主な関心事が DDL を可能性のある最短の時間で完了させることであり、かつテーブルにアクセスしようとするアプリケーションを待機させてもかまわない場合に指定します。<code class="literal">LOCK=EXCLUSIVE</code> はまた、テーブルへの予期しないアクセスを回避するために、サーバーがアイドル状態であると想定される場合にも使用できます。
        </p></li></ul></div><p>
      InnoDB テーブルに対するオンライン DDL ステートメントは、DDL ステートメントの準備中に短時間だけテーブルへの排他的アクセスが必要なため、そのテーブルにアクセスしている現在実行中のトランザクションが<a class="link" href="glossary.html#glos_commit" title="コミット">コミット</a>または<a class="link" href="glossary.html#glos_rollback" title="ロールバック">ロールバック</a>するのを常に待機します。同様に、完了前にも、短時間だけテーブルへの排他的アクセスが必要です。そのため、オンライン DDL ステートメントは、その DDL が完了する前に、DDL の進行中に開始され、テーブルをクエリーまたは変更するすべてのトランザクションがコミットまたはロールバックするのを待機します。
    </p><p>
      並列 DML 操作によって行われた変更を記録したあと、最後にこれらの変更を適用するにはある程度の処理が必要であるため、オンライン DDL 操作には、ほかのセッションからのテーブルアクセスをブロックする古いスタイルのメカニズムに比べて全体的に長い時間がかかる可能性があります。raw パフォーマンスの低下は、そのテーブルを使用するアプリケーションの応答性の向上とバランスがとれています。テーブル構造を変更するための理想的な手法を評価する場合は、Web ページのロード時間などの要因に基づいて、エンドユーザーのパフォーマンスの認識を考慮してください。
    </p><p>
      新しく作成された InnoDB セカンダリインデックスには、<code class="literal">CREATE INDEX</code> または <code class="literal">ALTER TABLE</code> ステートメントが実行を完了した時点でのテーブル内のコミットされたデータのみが含まれています。コミットされていない値や古いバージョンの値、または削除対象としてマークされているが、まだ古いインデックスから削除されていない値は含まれていません。
    </p><h4><a name="idm139979071151680"></a>インプレース DDL 操作とテーブルコピー DDL 操作のパフォーマンスの比較</h4><p>
      オンライン DDL 操作の raw パフォーマンスは、その操作がインプレースで実行されるか、またはテーブル全体のコピーと再構築が必要かによってほとんど決定されます。インプレースで実行できる操作の種類や、テーブルコピー操作を行わないための何らかの要件を確認するには、<a class="xref" href="innodb-storage-engine.html#innodb-online-ddl-summary-grid" title="表 14.5 DDL 操作のオンラインステータスのサマリー">表14.5「DDL 操作のオンラインステータスのサマリー」</a>を参照してください。
    </p><p>
      インプレース DDL のパフォーマンス向上は、主キーのインデックスではなく、セカンダリインデックスに対する操作に適用されます。InnoDB テーブルの行は、<a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a>に基づいて編成された<a class="link" href="glossary.html#glos_clustered_index" title="クラスタ化されたインデックス">クラスタ化されたインデックス</a>に格納されます。これにより、一部のデータベースシステムで<span class="quote">「<span class="quote">インデックス編成テーブル</span>」</span>と呼ばれるものが形成されます。このテーブル構造は主キーにきわめて密接に結び付けられているため、主キーの再定義にはデータのコピーが引き続き必要です。
    </p><p>
      主キーに対する操作で <code class="literal">ALGORITHM=INPLACE</code> が使用される場合は、データが引き続きコピーされるにもかかわらず、次の理由で <code class="literal">ALGORITHM=COPY</code> を使用するより効率的です。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">ALGORITHM=INPLACE</code> には、Undo ロギングやそれに関連する Redo ロギングが必要ありません。これらの操作は、<code class="literal">ALGORITHM=COPY</code> を使用する DDL ステートメントのオーバーヘッドを増やします。
        </p></li><li class="listitem"><p>
          セカンダリインデックスエントリは事前にソートされているため、順番にロードできます。
        </p></li><li class="listitem"><p>
          セカンダリインデックスへのランダムアクセス挿入は存在しないため、変更バッファーは使用されません。
        </p></li></ul></div><p>
      オンライン DDL 操作の相対的なパフォーマンスを評価するには、現在のバージョンと以前のバージョンの MySQL を使用して、このような操作を大きな <code class="literal">InnoDB</code> テーブルで実行できます。また、すべてのパフォーマンステストを最新の MySQL バージョンで実行することもできます。つまり、<code class="literal">old_alter_table</code> システム変数を設定することにより、以前の DDL 動作をシミュレートして<span class="quote">「<span class="quote">前の</span>」</span>結果を求めます。セッション内でステートメント <code class="literal">set old_alter_table=1</code> を発行し、DDL パフォーマンスを測定して<span class="quote">「<span class="quote">前の</span>」</span>数値を記録します。次に、<code class="literal">set old_alter_table=0</code> を発行して新しい、高速な動作を再度有効にし、DDL 操作を再度実行して<span class="quote">「<span class="quote">あとの</span>」</span>数値を記録します。
    </p><p>
      DDL 操作がその変更をインプレースで行うか、またはテーブルコピーを実行するかの基本的な考え方については、コマンドが完了したあとに表示される<span class="quote">「<span class="quote">rows affected</span>」</span>の値を見てください。たとえば、さまざまなタイプの DDL 操作を実行したあとに表示される可能性のある行を次に示します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          カラムのデフォルト値の変更 (非常に高速であり、テーブルデータにはまったく影響を与えません):
        </p><pre class="programlisting">
Query OK, 0 rows affected (0.07 sec)
</pre></li><li class="listitem"><p>
          インデックスの追加 (時間はかかりますが、<code class="literal">0 rows affected</code> はテーブルがコピーされないことを示しています):
        </p><pre class="programlisting">
Query OK, 0 rows affected (21.42 sec)
</pre></li><li class="listitem"><p>
          カラムのデータ型の変更 (かなりの時間がかかり、テーブルのすべての行の再構築が必要です):
        </p><pre class="programlisting">
Query OK, 1671168 rows affected (1 min 35.54 sec)
</pre></li></ul></div><p>
      たとえば、大きなテーブルで DDL 操作を実行する前に、その操作が速いか遅いかを次のようにチェックできます。
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          テーブル構造をクローニングします。
        </p></li><li class="listitem"><p>
          クローニングされたテーブルに非常に少量のデータを移入します。
        </p></li><li class="listitem"><p>
          クローニングされたテーブルで DDL 操作を実行します。
        </p></li><li class="listitem"><p>
          <span class="quote">「<span class="quote">rows affected</span>」</span>の値が 0 かどうかをチェックします。0 以外の値は、この操作にはテーブル全体の再構築が必要なため、特別な計画が必要になる可能性があることを示します。たとえば、この DDL 操作をスケジュールされたダウンタイムの期間中に、または各レプリケーションスレーブサーバー上で一度に 1 つずつ実行することができます。
        </p></li></ol></div><p>
      MySQL 処理の削減をより深く理解するには、DDL 操作の前後に <code class="literal">InnoDB</code> に関連した <code class="literal">performance_schema</code> および <code class="literal">INFORMATION_SCHEMA</code> テーブルを検査して、物理的な読み取り、書き込み、メモリー割り当てなどの数を確認します。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-online-ddl-syntax"></a>14.11.3 オンライン DDL の SQL 構文</h3></div></div></div><p>
      通常、<code class="literal">InnoDB</code> テーブルに対して <code class="literal">ALTER TABLE</code> ステートメントを使用する場合、<a class="link" href="glossary.html#glos_online_ddl" title="オンライン DDL">オンライン DDL</a> を有効にするために特殊なことをする必要はありません。インプレースで実行できるか、並列 DML を許可するか、またはその両方の DDL 操作の種類については、<a class="xref" href="innodb-storage-engine.html#innodb-online-ddl-summary-grid" title="表 14.5 DDL 操作のオンラインステータスのサマリー">表14.5「DDL 操作のオンラインステータスのサマリー」</a>を参照してください。一部の種類には、構成設定または <code class="literal">ALTER TABLE</code> 句の特定の組み合わせが必要になります。
    </p><p>
      <code class="literal">ALTER TABLE</code> ステートメントの <code class="literal">LOCK</code> および <code class="literal">ALGORITHM</code> 句を使用することによって、特定のオンライン DDL 操作のさまざまな側面を制御できます。これらの句はステートメントの最後に現れ、テーブルやカラムの指定とはカンマで区切られます。<code class="literal">LOCK</code> 句は、テーブルへの並列アクセスの程度を微調整するのに役立ちます。<code class="literal">ALGORITHM</code> 句は、主にパフォーマンス比較を目的にしているほか、既存の DDL コードで何らかの問題が発生した場合の古いテーブルコピー動作へのフォールバックとしても使用されます。例:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          テーブルの読み取り、書き込み、またはその両方を誤って不可能にしてしまうことがないようにするには、<code class="literal">ALTER TABLE</code> ステートメントで <code class="literal">LOCK=NONE</code> (読み取りと書き込みの両方を許可する) や <code class="literal">LOCK=SHARED</code> (読み取りを許可する) などの句を指定できます。要求されたレベルの並列性が使用できない場合、操作はただちに停止します。
        </p></li><li class="listitem"><p>
          パフォーマンスを比較するには、<code class="literal">old_alter_table</code> 構成オプションを設定する代わりに、1 つのステートメントを <code class="literal">ALGORITHM=INPLACE</code> で、もう 1 つのステートメントを <code class="literal">ALGORITHM=COPY</code> で実行できます。
        </p></li><li class="listitem"><p>
          テーブルをコピーした <code class="literal">ALTER TABLE</code> を実行することによってサーバーが結合されてしまう可能性をなくすには、インプレースメカニズムを使用できなければステートメントがただちに停止するように <code class="literal">ALGORITHM=INPLACE</code> を含めることができます。インプレースで実行できるか、またはできない DDL 操作のリストについては、<a class="xref" href="innodb-storage-engine.html#innodb-online-ddl-summary-grid" title="表 14.5 DDL 操作のオンラインステータスのサマリー">表14.5「DDL 操作のオンラインステータスのサマリー」</a>を参照してください。
        </p></li></ul></div><p>
      <code class="literal">LOCK</code> 句の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-create-index-concurrency" title="14.11.2 オンライン DDL でのパフォーマンスと並列性に関する考慮事項">セクション14.11.2「オンライン DDL でのパフォーマンスと並列性に関する考慮事項」</a>を参照してください。オンライン DDL の使用の完全な例については、<a class="xref" href="innodb-storage-engine.html#innodb-create-index-examples" title="14.11.5 オンライン DDL の例">セクション14.11.5「オンライン DDL の例」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-online-ddl-single-multi"></a>14.11.4 DDL ステートメントの結合または分離</h3></div></div></div><p>
      <a class="link" href="glossary.html#glos_online_ddl" title="オンライン DDL">オンライン DDL</a> が導入される前は、多くの DDL 操作を 1 つの <code class="literal">ALTER TABLE</code> ステートメントに結合することが一般的な習慣でした。各 <code class="literal">ALTER TABLE</code> ステートメントにはテーブルのコピーと再構築が含まれていたため、テーブルに対するすべての変更を 1 回の再構築操作で実行できたことから、同じテーブルへのいくつかの変更を一度に行う方が効率的でした。マイナス面としては、DDL 操作に関連する SQL コードが保守しにくく、別のスクリプトでの再利用も難しい点がありました。特定の変更が毎回異なっていたとすると、少し異なるシナリオごとに、新しい複雑な <code class="literal">ALTER TABLE</code> の構築が必要になる可能性があります。
    </p><p>
      インプレースで実行できる DDL 操作の場合は、<a class="xref" href="innodb-storage-engine.html#innodb-online-ddl-summary-grid" title="表 14.5 DDL 操作のオンラインステータスのサマリー">表14.5「DDL 操作のオンラインステータスのサマリー」</a>に示すように、効率を犠牲にすることなく、スクリプト作成や保守を容易にするために DDL 操作を個々の <code class="literal">ALTER TABLE</code> ステートメントに分離できるようになりました。たとえば、次のような複雑なステートメントを取り上げ、
    </p><pre class="programlisting">
alter table t1 add index i1(c1), add unique index i2(c2), change c4_old_name c4_new_name integer unsigned;
</pre><p>
      それを独立してテストおよび実行できる、次のようなより簡単な部分に分解することができます。
    </p><pre class="programlisting">
alter table t1 add index i1(c1);
alter table t1 add unique index i2(c2);
alter table t1 change c4_old_name c4_new_name integer unsigned not null;
</pre><p>
      複数の部分からなる <code class="literal">ALTER TABLE</code> ステートメントは、次の目的に引き続き使用できます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          特定のシーケンスで実行する必要のある操作。たとえば、インデックスの作成に続けて、そのインデックスを使用する外部キー制約を作成する場合など。
        </p></li><li class="listitem"><p>
          グループとして成功または失敗するようにしたい、すべてが同じ特定の <code class="literal">LOCK</code> 句を使用している操作。
        </p></li><li class="listitem"><p>
          インプレースで実行できない、つまり、引き続きテーブルをコピーして再構築する操作。
        </p></li><li class="listitem"><p>
          特殊なシナリオでの正確な下位互換性のために必要な場合に強制的にテーブルコピー動作を行うために、<code class="literal">ALGORITHM=COPY</code> または <code class="literal">old_alter_table=1</code> を指定する操作。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-create-index-examples"></a>14.11.5 オンライン DDL の例</h3></div></div></div><a class="indexterm" name="idm139979071064864"></a><p>
      次の各コード例は、そのパフォーマンス、並列性、およびスケーラビリティーが最新の<a class="link" href="glossary.html#glos_online_ddl" title="オンライン DDL">オンライン DDL</a> 拡張によって向上したいくつかの操作を示しています。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="xref" href="innodb-storage-engine.html#online-ddl-ex-setup" title="例 14.1 オンライン DDL 実験のためのスキーマ設定コード">例14.1「オンライン DDL 実験のためのスキーマ設定コード」</a>では、以降の例で使用される <code class="literal">BIG_TABLE</code> と <code class="literal">SMALL_TABLE</code> という名前のテーブルを設定します。
        </p></li><li class="listitem"><p>
          <a class="xref" href="innodb-storage-engine.html#online-ddl-ex-create-drop-index" title="例 14.2 CREATE INDEX および DROP INDEX の速度と効率">例14.2「CREATE INDEX および DROP INDEX の速度と効率」</a>は、インデックスの作成および削除のパフォーマンスの側面を示しています。
        </p></li><li class="listitem"><p>
          <a class="xref" href="innodb-storage-engine.html#online-ddl-ex-concurrent-dml" title="例 14.3 CREATE INDEX および DROP INDEX 中の並列 DML">例14.3「CREATE INDEX および DROP INDEX 中の並列 DML」</a>は、<code class="literal">DROP INDEX</code> 操作中に実行されるクエリーと DML ステートメントを示しています。
        </p></li><li class="listitem"><p>
          <a class="xref" href="innodb-storage-engine.html#online-ddl-ex-rename-column" title="例 14.4 カラムの名前変更">例14.4「カラムの名前変更」</a>は、カラムの名前変更の速度向上、および名前変更操作を行うときにデータ型を正確に同じ状態に維持するために必要な注意事項を示しています。
        </p></li><li class="listitem"><p>
          <a class="xref" href="innodb-storage-engine.html#online-ddl-ex-drop-foreign-key" title="例 14.5 外部キーの削除">例14.5「外部キーの削除」</a>は、外部キーがオンライン DDL でどのように機能するかを示しています。外部キーの操作には 2 つのテーブルが関連しているため、ロックに関する追加の考慮事項があります。そのため、外部キーを含むテーブルには、オンライン DDL 操作での制限が存在する場合があります。
        </p></li><li class="listitem"><p>
          <a class="xref" href="innodb-storage-engine.html#online-ddl-ex-auto-increment" title="例 14.6 自動インクリメント値の変更">例14.6「自動インクリメント値の変更」</a>は、自動インクリメントカラムがオンライン DDL でどのように機能するかを示しています。自動インクリメントカラムを含むテーブルには、オンライン DDL 操作での制限が存在する場合があります。
        </p></li><li class="listitem"><p>
          <a class="xref" href="innodb-storage-engine.html#online-ddl-ex-lock-clause" title="例 14.7 LOCK 句を使用した並列性の制御">例14.7「LOCK 句を使用した並列性の制御」</a>は、オンライン DDL 操作の進行中の並列クエリーと DML 操作を許可または制限するためのオプションを示しています。これは、DDL ステートメントが待機するか、並列トランザクションが待機するか、またはデッドロックエラーのために並列トランザクションが DML ステートメントを取り消す可能性がある状況を示しています。
        </p></li><li class="listitem"><p>
          <a class="xref" href="innodb-storage-engine.html#online-ddl-ex-multi-create-index" title="例 14.8 オンライン DDL 実験のためのスキーマ設定コード">例14.8「オンライン DDL 実験のためのスキーマ設定コード」</a>は、1 つのステートメントでの複数のインデックスの作成および削除を示しています。これは、インデックス操作ごとに個別のステートメントを使用するより効率的である場合があります。
        </p></li><li class="listitem"><p>
          <a class="xref" href="innodb-storage-engine.html#online-ddl-ex-primary-key" title="例 14.9 主キーの作成および削除">例14.9「主キーの作成および削除」</a>は、<a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a>はテーブルの作成時に定義する方が効率的であり、あとで追加した場合はコストがかなり高くなることを示しています。
        </p></li></ul></div><div class="example"><a name="online-ddl-ex-setup"></a><p class="title"><b>例 14.1 オンライン DDL 実験のためのスキーマ設定コード</b></p><div class="example-contents"><p>
        これらのデモで使用される初期のテーブルを設定するコードを次に示します。
      </p><a name="online-ddl-setup"></a><pre class="programlisting">
/* 
Setup code for the online DDL demonstration:
- Set up some config variables.
- Create 2 tables that are clones of one of the INFORMATION_SCHEMA tables
  that always has some data. The "small" table has a couple of thousand rows.
  For the "big" table, keep doubling the data until it reaches over a million rows.
- Set up a primary key for the sample tables, since we are demonstrating InnoDB aspects.
*/ 

set autocommit = 0;
set foreign_key_checks = 1;
set global innodb_file_per_table = 1;
set old_alter_table=0;
prompt mysql: 

use test;

\! echo "Setting up 'small' table:"
drop table if exists small_table;
create table small_table as select * from information_schema.columns;
alter table small_table add id int unsigned not null primary key auto_increment;
select count(id) from small_table;

\! echo "Setting up 'big' table:"
drop table if exists big_table;
create table big_table as select * from information_schema.columns;
show create table big_table\G

insert into big_table select * from big_table;
insert into big_table select * from big_table;
insert into big_table select * from big_table;
insert into big_table select * from big_table;
insert into big_table select * from big_table;
insert into big_table select * from big_table;
insert into big_table select * from big_table;
insert into big_table select * from big_table;
insert into big_table select * from big_table;
insert into big_table select * from big_table;
commit;

alter table big_table add id int unsigned not null primary key auto_increment;
select count(id) from big_table;
</pre><p>
        このコードを実行すると、簡略化のために圧縮され、もっとも重要な点が太字で示された次の出力が得られます。
      </p><pre class="programlisting">
Setting up 'small' table:
Query OK, 0 rows affected (0.01 sec)

Query OK, 1678 rows affected (0.13 sec)
Records: 1678  Duplicates: 0  Warnings: 0

Query OK, 1678 rows affected (0.07 sec)
Records: 1678  Duplicates: 0  Warnings: 0

+-----------+
| count(id) |
+-----------+
|      <span class="bold"><strong>1678</strong></span> |
+-----------+
1 row in set (0.00 sec)

Setting up 'big' table:
Query OK, 0 rows affected (0.16 sec)

Query OK, 1678 rows affected (0.17 sec)
Records: 1678  Duplicates: 0  Warnings: 0

*************************** 1. row ***************************
       Table: big_table
Create Table: CREATE TABLE `big_table` (
  `TABLE_CATALOG` varchar(512) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `TABLE_SCHEMA` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `TABLE_NAME` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `COLUMN_NAME` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `ORDINAL_POSITION` bigint(21) unsigned NOT NULL DEFAULT '0',
  `COLUMN_DEFAULT` longtext CHARACTER SET utf8,
  `IS_NULLABLE` varchar(3) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `DATA_TYPE` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `CHARACTER_MAXIMUM_LENGTH` bigint(21) unsigned DEFAULT NULL,
  `CHARACTER_OCTET_LENGTH` bigint(21) unsigned DEFAULT NULL,
  `NUMERIC_PRECISION` bigint(21) unsigned DEFAULT NULL,
  `NUMERIC_SCALE` bigint(21) unsigned DEFAULT NULL,
  `DATETIME_PRECISION` bigint(21) unsigned DEFAULT NULL,
  `CHARACTER_SET_NAME` varchar(32) CHARACTER SET utf8 DEFAULT NULL,
  `COLLATION_NAME` varchar(32) CHARACTER SET utf8 DEFAULT NULL,
  `COLUMN_TYPE` longtext CHARACTER SET utf8 NOT NULL,
  `COLUMN_KEY` varchar(3) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `EXTRA` varchar(30) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `PRIVILEGES` varchar(80) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `COLUMN_COMMENT` varchar(1024) CHARACTER SET utf8 NOT NULL DEFAULT ''
) ENGINE=InnoDB DEFAULT CHARSET=latin1
1 row in set (0.00 sec)

Query OK, 1678 rows affected (0.09 sec)
Records: 1678  Duplicates: 0  Warnings: 0

Query OK, 3356 rows affected (0.07 sec)
Records: 3356  Duplicates: 0  Warnings: 0

Query OK, 6712 rows affected (0.17 sec)
Records: 6712  Duplicates: 0  Warnings: 0

Query OK, 13424 rows affected (0.44 sec)
Records: 13424  Duplicates: 0  Warnings: 0

Query OK, 26848 rows affected (0.63 sec)
Records: 26848  Duplicates: 0  Warnings: 0

Query OK, 53696 rows affected (1.72 sec)
Records: 53696  Duplicates: 0  Warnings: 0

Query OK, 107392 rows affected (3.02 sec)
Records: 107392  Duplicates: 0  Warnings: 0

Query OK, 214784 rows affected (6.28 sec)
Records: 214784  Duplicates: 0  Warnings: 0

Query OK, 429568 rows affected (13.25 sec)
Records: 429568  Duplicates: 0  Warnings: 0

Query OK, 859136 rows affected (28.16 sec)
Records: 859136  Duplicates: 0  Warnings: 0

Query OK, 0 rows affected (0.03 sec)

Query OK, 1718272 rows affected (1 min 9.22 sec)
Records: 1718272  Duplicates: 0  Warnings: 0

+-----------+
| count(id) |
+-----------+
|   <span class="bold"><strong>1718272</strong></span> |
+-----------+
1 row in set (1.75 sec)
</pre></div></div><br class="example-break"><div class="example"><a name="online-ddl-ex-create-drop-index"></a><p class="title"><b>例 14.2 CREATE INDEX および DROP INDEX の速度と効率</b></p><div class="example-contents"><p>
        次のステートメントシーケンスは、<code class="literal">CREATE INDEX</code> および <code class="literal">DROP INDEX</code> ステートメントの相対的な速度を示しています。小さなテーブルの場合は、速い方法と遅い方法のどちらを使用しても経過時間は 1 秒未満であるため、<span class="quote">「<span class="quote">rows affected</span>」</span>の出力を見て、どちらの操作がテーブル再構築を回避できるかを確認します。大きなテーブルの場合は、テーブル再構築のスキップによってかなりの時間が節約されるため、効率の違いは明らかです。
      </p><a name="online-ddl-create_drop_index"></a><pre class="programlisting">
\! clear

\! echo "=== Create and drop index (small table, new/fast technique) ==="
\! echo
\! echo "Data size (kilobytes) before index created: "
\! du -k data/test/small_table.ibd
create index i_dtyp_small on small_table (data_type)<span class="bold"><strong>, algorithm=inplace</strong></span>;
\! echo "Data size after index created: "
\! du -k data/test/small_table.ibd
drop index i_dtyp_small on small_table<span class="bold"><strong>, algorithm=inplace</strong></span>;

-- Compare against the older slower DDL.

\! echo "=== Create and drop index (small table, old/slow technique) ==="
\! echo
\! echo "Data size (kilobytes) before index created: "
\! du -k data/test/small_table.ibd
create index i_dtyp_small on small_table (data_type)<span class="bold"><strong>, algorithm=copy</strong></span>;
\! echo "Data size after index created: "
\! du -k data/test/small_table.ibd
drop index i_dtyp_small on small_table<span class="bold"><strong>, algorithm=copy</strong></span>;

-- In the above example, we examined the "rows affected" number,
-- ideally looking for a zero figure. Let's try again with a larger
-- sample size, where we'll see that the actual time taken can
-- vary significantly.

\! echo "=== Create and drop index (big table, new/fast technique) ==="
\! echo
\! echo "Data size (kilobytes) before index created: "
\! du -k data/test/big_table.ibd
create index i_dtyp_big on big_table (data_type)<span class="bold"><strong>, algorithm=inplace</strong></span>;
\! echo "Data size after index created: "
\! du -k data/test/big_table.ibd
drop index i_dtyp_big on big_table<span class="bold"><strong>, algorithm=inplace</strong></span>;

\! echo "=== Create and drop index (big table, old/slow technique) ==="
\! echo
\! echo "Data size (kilobytes) before index created: "
\! du -k data/test/big_table.ibd
create index i_dtyp_big on big_table (data_type)<span class="bold"><strong>, algorithm=copy</strong></span>;
\! echo "Data size after index created: "
\! du -k data/test/big_table.ibd
drop index i_dtyp_big on big_table<span class="bold"><strong>, algorithm=copy</strong></span>;
</pre><p>
        このコードを実行すると、簡略化のために圧縮され、もっとも重要な点が太字で示された次の出力が得られます。
      </p><pre class="programlisting">
Query OK, 0 rows affected (0.00 sec)

=== Create and drop index (small table, new/fast technique) ===

Data size (kilobytes) before index created: 
384  data/test/small_table.ibd
Query OK, <span class="bold"><strong>0 rows affected</strong></span> (0.04 sec)
Records: 0  Duplicates: 0  Warnings: 0

Data size after index created: 
432  data/test/small_table.ibd
Query OK, <span class="bold"><strong>0 rows affected</strong></span> (0.02 sec)
Records: 0  Duplicates: 0  Warnings: 0

Query OK, 0 rows affected (0.00 sec)

=== Create and drop index (small table, old/slow technique) ===

Data size (kilobytes) before index created: 
432  data/test/small_table.ibd
Query OK, <span class="bold"><strong>1678 rows affected</strong></span> (0.12 sec)
Records: 1678  Duplicates: 0  Warnings: 0

Data size after index created: 
448  data/test/small_table.ibd
Query OK, <span class="bold"><strong>1678 rows affected</strong></span> (0.10 sec)
Records: 1678  Duplicates: 0  Warnings: 0

Query OK, 0 rows affected (0.00 sec)

=== Create and drop index (big table, new/fast technique) ===

Data size (kilobytes) before index created: 
315392  data/test/big_table.ibd
Query OK, <span class="bold"><strong>0 rows affected</strong></span> (33.32 sec)
Records: 0  Duplicates: 0  Warnings: 0

Data size after index created: 
335872  data/test/big_table.ibd
Query OK, <span class="bold"><strong>0 rows affected</strong></span> (0.02 sec)
Records: 0  Duplicates: 0  Warnings: 0

Query OK, 0 rows affected (0.00 sec)

=== Create and drop index (big table, old/slow technique) ===

Data size (kilobytes) before index created: 
335872  data/test/big_table.ibd
Query OK, <span class="bold"><strong>1718272 rows affected</strong></span> (1 min 5.01 sec)
Records: 1718272  Duplicates: 0  Warnings: 0

Data size after index created: 
348160  data/test/big_table.ibd
Query OK, <span class="bold"><strong>1718272 rows affected</strong></span> (46.59 sec)
Records: 1718272  Duplicates: 0  Warnings: 0
</pre></div></div><br class="example-break"><div class="example"><a name="online-ddl-ex-concurrent-dml"></a><p class="title"><b>例 14.3 CREATE INDEX および DROP INDEX 中の並列 DML</b></p><div class="example-contents"><p>
        <code class="literal">CREATE INDEX</code> および <code class="literal">DROP INDEX</code> と同時に実行されている DML ステートメント (挿入、更新、または削除) を示すために、次に、同じデータベースに接続された個別の <span class="command"><strong>mysql</strong></span> セッションで実行したいくつかのコードスニペットを示します。
      </p><pre class="programlisting">
/*
CREATE INDEX statement to run against a table while 
insert/update/delete statements are modifying the
column being indexed.
*/

-- We'll run this script in one session, while simultaneously creating and dropping
-- an index on test/big_table.table_name in another session.

use test;
create index i_concurrent on big_table(table_name);
</pre><pre class="programlisting">
/*
DROP INDEX statement to run against a table while
insert/update/delete statements are modifying the
column being indexed.
*/

-- We'll run this script in one session, while simultaneously creating and dropping
-- an index on test/big_table.table_name in another session.

use test;
drop index i_concurrent on big_table;
</pre><pre class="programlisting">
/*
Some queries and insert/update/delete statements to run against a table
while an index is being created or dropped. Previously, these operations
would have stalled during the index create/drop period and possibly
timed out or deadlocked.
*/

-- We'll run this script in one session, while simultaneously creating and dropping
-- an index on test/big_table.table_name in another session.

-- In our test instance, that column has about 1.7M rows, with 136 different values.
-- Sample values: COLUMNS (20480), ENGINES (6144), EVENTS (24576), FILES (38912), TABLES (21504), VIEWS (10240).

set autocommit = 0;
use test;

select distinct character_set_name from big_table where table_name = 'FILES';
delete from big_table where table_name = 'FILES';
select distinct character_set_name from big_table where table_name = 'FILES';

-- I'll issue the final rollback interactively, not via script,
-- the better to control the timing.
-- rollback;
</pre><p>
        このコードを実行すると、簡略化のために圧縮され、もっとも重要な点が太字で示された次の出力が得られます。
      </p><pre class="programlisting">
mysql: source concurrent_ddl_create.sql
Database changed
Query OK, <span class="bold"><strong>0 rows affected</strong></span> (1 min 25.15 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql: source concurrent_ddl_drop.sql
Database changed
Query OK, <span class="bold"><strong>0 rows affected</strong></span> (24.98 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql: source concurrent_dml.sql
Query OK, 0 rows affected (0.00 sec)

Database changed
+--------------------+
| character_set_name |
+--------------------+
| NULL               |
| utf8               |
+--------------------+
2 rows in set (0.32 sec)

Query OK, <span class="bold"><strong>38912 rows affected</strong></span> (1.84 sec)

Empty set (0.01 sec)

mysql: rollback;
Query OK, 0 rows affected (1.05 sec)
</pre></div></div><br class="example-break"><div class="example"><a name="online-ddl-ex-rename-column"></a><p class="title"><b>例 14.4 カラムの名前変更</b></p><div class="example-contents"><p>
        <code class="literal">ALTER TABLE</code> を使用したカラムの名前変更のデモを次に示します。新しい、高速な DDL メカニズムを使用して名前を変更してから、古い、低速な DDL メカニズムを (<code class="literal">old_alter_table=1</code> とともに) 使用して元のカラム名をリストアします。
      </p><p>
        注:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            カラムの名前変更の構文にはデータ型の再指定も含まれるため、コストの高いテーブル再構築を回避するために、まったく同じデータ型を指定するよう十分に注意してください。この場合は、<code class="literal">show create table <em class="replaceable"><code>table</code></em>\G</code> の出力をチェックし、元のカラム定義から <code class="literal">CHARACTER SET</code> や <code class="literal">NOT NULL</code> などの句をすべてコピーしました。
          </p></li><li class="listitem"><p>
            この場合も、小さなテーブルのカラムの名前変更は十分高速であるため、新しい DDL メカニズムが古いメカニズムより効率的であることを確認するには <span class="quote">「<span class="quote">rows affected</span>」</span> の数値を検査する必要があります。大きなテーブルでは、経過時間の違いによって速度の向上が明らかになります。
          </p></li></ul></div><a name="online-ddl-rename_column"></a><pre class="programlisting">
/*
Run through a sequence of 'rename column' statements.
Because this operation involves only metadata, not table data,
it is fast for big and small tables, with new or old DDL mechanisms.
*/

\! clear

\! echo "Rename column (fast technique, small table):"
alter table small_table change `IS_NULLABLE` `NULLABLE` varchar(3) character set utf8 not null<span class="bold"><strong>, algorithm=inplace</strong></span>;
\! echo "Rename back to original name (slow technique):"
alter table small_table change `NULLABLE` `IS_NULLABLE` varchar(3) character set utf8 not null<span class="bold"><strong>, algorithm=copy</strong></span>;


\! echo "Rename column (fast technique, big table):"
alter table big_table change `IS_NULLABLE` `NULLABLE` varchar(3) character set utf8 not null<span class="bold"><strong>, algorithm=inplace</strong></span>;
\! echo "Rename back to original name (slow technique):"
alter table big_table change `NULLABLE` `IS_NULLABLE` varchar(3) character set utf8 not null<span class="bold"><strong>, algorithm=copy</strong></span>;
</pre><p>
        このコードを実行すると、簡略化のために圧縮され、もっとも重要な点が太字で示された次の出力が得られます。
      </p><pre class="programlisting">
Rename column (fast technique, small table):
Query OK, 0 rows affected (0.05 sec)

Query OK, <span class="bold"><strong>0 rows affected</strong></span> (0.13 sec)
Records: 0  Duplicates: 0  Warnings: 0

Rename back to original name (slow technique):
Query OK, 0 rows affected (0.00 sec)

Query OK, <span class="bold"><strong>1678 rows affected</strong></span> (0.35 sec)
Records: 1678  Duplicates: 0  Warnings: 0

Rename column (fast technique, big table):
Query OK, 0 rows affected (0.00 sec)

Query OK, 0 <span class="bold"><strong>rows affected</strong></span> (0.11 sec)
Records: 0  Duplicates: 0  Warnings: 0

Rename back to original name (slow technique):
Query OK, 0 rows affected (0.00 sec)

Query OK, <span class="bold"><strong>1718272 rows affected</strong></span> (1 min 0.00 sec)
Records: 1718272  Duplicates: 0  Warnings: 0

Query OK, 0 rows affected (0.00 sec)
</pre></div></div><br class="example-break"><div class="example"><a name="online-ddl-ex-drop-foreign-key"></a><p class="title"><b>例 14.5 外部キーの削除</b></p><div class="example-contents"><p>
        外部キーのデモ (外部キー制約の削除の速度の向上を含む) を次に示します。
      </p><a name="online-ddl-foreign_key"></a><pre class="programlisting">
/*
Demonstrate aspects of foreign keys that are or aren't affected by the DDL improvements.
- Create a new table with only a few values to serve as the parent table.
- Set up the 'small' and 'big' tables as child tables using a foreign key.
- Verify that the ON DELETE CASCADE clause makes changes ripple from parent to child tables.
- Drop the foreign key constraints, and optionally associated indexes. (This is the operation that is sped up.)
*/

\! clear

-- Make sure foreign keys are being enforced, and allow
-- rollback after doing some DELETEs that affect both
-- parent and child tables.
set foreign_key_checks = 1;
set autocommit = 0;

-- Create a parent table, containing values that we know are already present
-- in the child tables.
drop table if exists schema_names;
create table schema_names (id int unsigned not null primary key auto_increment, schema_name varchar(64) character set utf8 not null, index i_schema (schema_name)) as select distinct table_schema schema_name from small_table;

show create table schema_names\G
show create table small_table\G
show create table big_table\G

-- Creating the foreign key constraint still involves a table rebuild when foreign_key_checks=1,
-- as illustrated by the "rows affected" figure.
alter table small_table add constraint small_fk foreign key i_table_schema (table_schema) references schema_names(schema_name) on delete cascade;
alter table big_table add constraint big_fk foreign key i_table_schema (table_schema) references schema_names(schema_name) on delete cascade;

show create table small_table\G
show create table big_table\G

select schema_name from schema_names order by schema_name;
select count(table_schema) howmany, table_schema from small_table group by table_schema;
select count(table_schema) howmany, table_schema from big_table group by table_schema;

-- big_table is the parent table.
-- schema_names is the parent table.
-- big_table is the child table.
-- (One row in the parent table can have many "children" in the child table.)
-- Changes to the parent table can ripple through to the child table.
-- For example, removing the value 'test' from schema_names.schema_name will
-- result in the removal of 20K or so rows from big_table.

delete from schema_names where schema_name = 'test';

select schema_name from schema_names order by schema_name;
select count(table_schema) howmany, table_schema from small_table group by table_schema;
select count(table_schema) howmany, table_schema from big_table group by table_schema;

-- Because we've turned off autocommit, we can still get back those deleted rows
-- if the DELETE was issued by mistake.
rollback;

select schema_name from schema_names order by schema_name;
select count(table_schema) howmany, table_schema from small_table group by table_schema;
select count(table_schema) howmany, table_schema from big_table group by table_schema;

-- All of the cross-checking between parent and child tables would be
-- deadly slow if there wasn't the requirement for the corresponding
-- columns to be indexed!

-- But we can get rid of the foreign key using a fast operation
-- that doesn't rebuild the table.
-- If we didn't specify a constraint name when setting up the foreign key, we would
-- have to find the auto-generated name such as 'big_table_ibfk_1' in the
-- output from 'show create table'.

-- For the small table, we'll drop the foreign key and the associated index.
-- Having an index on a small table is less critical.

\! echo "DROP FOREIGN KEY and INDEX from small_table:"
alter table small_table drop foreign key small_fk, drop index small_fk;

-- For the big table, we'll drop the foreign key and leave the associated index.
-- If we are still doing queries that reference the indexed column, the index is
-- very important to avoid a full table scan of the big table.
\! echo "DROP FOREIGN KEY from big_table:"
alter table big_table drop foreign key big_fk;


show create table small_table\G
show create table big_table\G
</pre><p>
        このコードを実行すると、簡略化のために圧縮され、もっとも重要な点が太字で示された次の出力が得られます。
      </p><pre class="programlisting">
Query OK, 0 rows affected (0.00 sec)

Query OK, 0 rows affected (0.00 sec)

Query OK, 0 rows affected (0.01 sec)

Query OK, 4 rows affected (0.03 sec)
Records: 4  Duplicates: 0  Warnings: 0

*************************** 1. row ***************************
       Table: schema_names
Create Table: CREATE TABLE `schema_names` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `schema_name` varchar(64) CHARACTER SET utf8 NOT NULL,
  PRIMARY KEY (`id`),
  KEY `i_schema` (`schema_name`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=latin1
1 row in set (0.00 sec)

*************************** 1. row ***************************
       Table: small_table
Create Table: CREATE TABLE `small_table` (
  `TABLE_CATALOG` varchar(512) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `TABLE_SCHEMA` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `TABLE_NAME` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `COLUMN_NAME` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `ORDINAL_POSITION` bigint(21) unsigned NOT NULL DEFAULT '0',
  `COLUMN_DEFAULT` longtext CHARACTER SET utf8,
  `IS_NULLABLE` varchar(3) CHARACTER SET utf8 NOT NULL,
  `DATA_TYPE` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `CHARACTER_MAXIMUM_LENGTH` bigint(21) unsigned DEFAULT NULL,
  `CHARACTER_OCTET_LENGTH` bigint(21) unsigned DEFAULT NULL,
  `NUMERIC_PRECISION` bigint(21) unsigned DEFAULT NULL,
  `NUMERIC_SCALE` bigint(21) unsigned DEFAULT NULL,
  `DATETIME_PRECISION` bigint(21) unsigned DEFAULT NULL,
  `CHARACTER_SET_NAME` varchar(32) CHARACTER SET utf8 DEFAULT NULL,
  `COLLATION_NAME` varchar(32) CHARACTER SET utf8 DEFAULT NULL,
  `COLUMN_TYPE` longtext CHARACTER SET utf8 NOT NULL,
  `COLUMN_KEY` varchar(3) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `EXTRA` varchar(30) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `PRIVILEGES` varchar(80) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `COLUMN_COMMENT` varchar(1024) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1679 DEFAULT CHARSET=latin1
1 row in set (0.00 sec)

*************************** 1. row ***************************
       Table: big_table
Create Table: CREATE TABLE `big_table` (
  `TABLE_CATALOG` varchar(512) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `TABLE_SCHEMA` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `TABLE_NAME` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `COLUMN_NAME` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `ORDINAL_POSITION` bigint(21) unsigned NOT NULL DEFAULT '0',
  `COLUMN_DEFAULT` longtext CHARACTER SET utf8,
  `IS_NULLABLE` varchar(3) CHARACTER SET utf8 NOT NULL,
  `DATA_TYPE` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `CHARACTER_MAXIMUM_LENGTH` bigint(21) unsigned DEFAULT NULL,
  `CHARACTER_OCTET_LENGTH` bigint(21) unsigned DEFAULT NULL,
  `NUMERIC_PRECISION` bigint(21) unsigned DEFAULT NULL,
  `NUMERIC_SCALE` bigint(21) unsigned DEFAULT NULL,
  `DATETIME_PRECISION` bigint(21) unsigned DEFAULT NULL,
  `CHARACTER_SET_NAME` varchar(32) CHARACTER SET utf8 DEFAULT NULL,
  `COLLATION_NAME` varchar(32) CHARACTER SET utf8 DEFAULT NULL,
  `COLUMN_TYPE` longtext CHARACTER SET utf8 NOT NULL,
  `COLUMN_KEY` varchar(3) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `EXTRA` varchar(30) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `PRIVILEGES` varchar(80) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `COLUMN_COMMENT` varchar(1024) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`id`),
  <span class="bold"><strong>KEY `big_fk` (`TABLE_SCHEMA`)</strong></span> 
) ENGINE=InnoDB AUTO_INCREMENT=1718273 DEFAULT CHARSET=latin1
1 row in set (0.00 sec)

Query OK, 1678 rows affected (0.10 sec)
Records: 1678  Duplicates: 0  Warnings: 0

Query OK, 1718272 rows affected (1 min 14.54 sec)
Records: 1718272  Duplicates: 0  Warnings: 0

*************************** 1. row ***************************
       Table: small_table
Create Table: CREATE TABLE `small_table` (
  `TABLE_CATALOG` varchar(512) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `TABLE_SCHEMA` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `TABLE_NAME` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `COLUMN_NAME` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `ORDINAL_POSITION` bigint(21) unsigned NOT NULL DEFAULT '0',
  `COLUMN_DEFAULT` longtext CHARACTER SET utf8,
  `IS_NULLABLE` varchar(3) CHARACTER SET utf8 NOT NULL,
  `DATA_TYPE` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `CHARACTER_MAXIMUM_LENGTH` bigint(21) unsigned DEFAULT NULL,
  `CHARACTER_OCTET_LENGTH` bigint(21) unsigned DEFAULT NULL,
  `NUMERIC_PRECISION` bigint(21) unsigned DEFAULT NULL,
  `NUMERIC_SCALE` bigint(21) unsigned DEFAULT NULL,
  `DATETIME_PRECISION` bigint(21) unsigned DEFAULT NULL,
  `CHARACTER_SET_NAME` varchar(32) CHARACTER SET utf8 DEFAULT NULL,
  `COLLATION_NAME` varchar(32) CHARACTER SET utf8 DEFAULT NULL,
  `COLUMN_TYPE` longtext CHARACTER SET utf8 NOT NULL,
  `COLUMN_KEY` varchar(3) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `EXTRA` varchar(30) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `PRIVILEGES` varchar(80) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `COLUMN_COMMENT` varchar(1024) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`id`),
  <span class="bold"><strong>KEY `small_fk` (`TABLE_SCHEMA`),</strong></span> 
  <span class="bold"><strong>CONSTRAINT `small_fk` FOREIGN KEY (`TABLE_SCHEMA`) REFERENCES `schema_names` (`schema_name`) ON DELETE CASCADE</strong></span> 
) ENGINE=InnoDB AUTO_INCREMENT=1679 DEFAULT CHARSET=latin1
1 row in set (0.12 sec)

*************************** 1. row ***************************
       Table: big_table
Create Table: CREATE TABLE `big_table` (
  `TABLE_CATALOG` varchar(512) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `TABLE_SCHEMA` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `TABLE_NAME` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `COLUMN_NAME` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `ORDINAL_POSITION` bigint(21) unsigned NOT NULL DEFAULT '0',
  `COLUMN_DEFAULT` longtext CHARACTER SET utf8,
  `IS_NULLABLE` varchar(3) CHARACTER SET utf8 NOT NULL,
  `DATA_TYPE` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `CHARACTER_MAXIMUM_LENGTH` bigint(21) unsigned DEFAULT NULL,
  `CHARACTER_OCTET_LENGTH` bigint(21) unsigned DEFAULT NULL,
  `NUMERIC_PRECISION` bigint(21) unsigned DEFAULT NULL,
  `NUMERIC_SCALE` bigint(21) unsigned DEFAULT NULL,
  `DATETIME_PRECISION` bigint(21) unsigned DEFAULT NULL,
  `CHARACTER_SET_NAME` varchar(32) CHARACTER SET utf8 DEFAULT NULL,
  `COLLATION_NAME` varchar(32) CHARACTER SET utf8 DEFAULT NULL,
  `COLUMN_TYPE` longtext CHARACTER SET utf8 NOT NULL,
  `COLUMN_KEY` varchar(3) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `EXTRA` varchar(30) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `PRIVILEGES` varchar(80) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `COLUMN_COMMENT` varchar(1024) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`id`),
  <span class="bold"><strong>KEY `big_fk` (`TABLE_SCHEMA`),</strong></span> 
  <span class="bold"><strong>CONSTRAINT `big_fk` FOREIGN KEY (`TABLE_SCHEMA`) REFERENCES `schema_names` (`schema_name`) ON DELETE CASCADE</strong></span> 
) ENGINE=InnoDB AUTO_INCREMENT=1718273 DEFAULT CHARSET=latin1
1 row in set (0.01 sec)

+--------------------+
| schema_name        |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| test               |
+--------------------+
4 rows in set (0.00 sec)

+---------+--------------------+
| howmany | table_schema       |
+---------+--------------------+
|     563 | information_schema |
|     286 | mysql              |
|     786 | performance_schema |
|      43 | test               |
+---------+--------------------+
4 rows in set (0.01 sec)

+---------+--------------------+
| howmany | table_schema       |
+---------+--------------------+
|  576512 | information_schema |
|  292864 | mysql              |
|  804864 | performance_schema |
|   44032 | test               |
+---------+--------------------+
4 rows in set (2.10 sec)

Query OK, 1 row affected (1.52 sec)

+--------------------+
| schema_name        |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
+--------------------+
3 rows in set (0.00 sec)

+---------+--------------------+
| howmany | table_schema       |
+---------+--------------------+
|     563 | information_schema |
|     286 | mysql              |
|     786 | performance_schema |
+---------+--------------------+
3 rows in set (0.00 sec)

+---------+--------------------+
| howmany | table_schema       |
+---------+--------------------+
|  576512 | information_schema |
|  292864 | mysql              |
|  804864 | performance_schema |
+---------+--------------------+
3 rows in set (1.74 sec)

Query OK, 0 rows affected (0.60 sec)

+--------------------+
| schema_name        |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| test               |
+--------------------+
4 rows in set (0.00 sec)

+---------+--------------------+
| howmany | table_schema       |
+---------+--------------------+
|     563 | information_schema |
|     286 | mysql              |
|     786 | performance_schema |
|      43 | test               |
+---------+--------------------+
4 rows in set (0.01 sec)

+---------+--------------------+
| howmany | table_schema       |
+---------+--------------------+
|  576512 | information_schema |
|  292864 | mysql              |
|  804864 | performance_schema |
|   44032 | test               |
+---------+--------------------+
4 rows in set (1.59 sec)

DROP FOREIGN KEY and INDEX from small_table:
Query OK, <span class="bold"><strong>0 rows affected</strong></span> (0.02 sec)
Records: 0  Duplicates: 0  Warnings: 0

DROP FOREIGN KEY from big_table:
Query OK, <span class="bold"><strong>0 rows affected</strong></span> (0.02 sec)
Records: 0  Duplicates: 0  Warnings: 0

*************************** 1. row ***************************
       Table: small_table
Create Table: CREATE TABLE `small_table` (
  `TABLE_CATALOG` varchar(512) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `TABLE_SCHEMA` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `TABLE_NAME` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `COLUMN_NAME` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `ORDINAL_POSITION` bigint(21) unsigned NOT NULL DEFAULT '0',
  `COLUMN_DEFAULT` longtext CHARACTER SET utf8,
  `IS_NULLABLE` varchar(3) CHARACTER SET utf8 NOT NULL,
  `DATA_TYPE` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `CHARACTER_MAXIMUM_LENGTH` bigint(21) unsigned DEFAULT NULL,
  `CHARACTER_OCTET_LENGTH` bigint(21) unsigned DEFAULT NULL,
  `NUMERIC_PRECISION` bigint(21) unsigned DEFAULT NULL,
  `NUMERIC_SCALE` bigint(21) unsigned DEFAULT NULL,
  `DATETIME_PRECISION` bigint(21) unsigned DEFAULT NULL,
  `CHARACTER_SET_NAME` varchar(32) CHARACTER SET utf8 DEFAULT NULL,
  `COLLATION_NAME` varchar(32) CHARACTER SET utf8 DEFAULT NULL,
  `COLUMN_TYPE` longtext CHARACTER SET utf8 NOT NULL,
  `COLUMN_KEY` varchar(3) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `EXTRA` varchar(30) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `PRIVILEGES` varchar(80) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `COLUMN_COMMENT` varchar(1024) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1679 DEFAULT CHARSET=latin1
1 row in set (0.00 sec)

*************************** 1. row ***************************
       Table: big_table
Create Table: CREATE TABLE `big_table` (
  `TABLE_CATALOG` varchar(512) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `TABLE_SCHEMA` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `TABLE_NAME` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `COLUMN_NAME` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `ORDINAL_POSITION` bigint(21) unsigned NOT NULL DEFAULT '0',
  `COLUMN_DEFAULT` longtext CHARACTER SET utf8,
  `IS_NULLABLE` varchar(3) CHARACTER SET utf8 NOT NULL,
  `DATA_TYPE` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `CHARACTER_MAXIMUM_LENGTH` bigint(21) unsigned DEFAULT NULL,
  `CHARACTER_OCTET_LENGTH` bigint(21) unsigned DEFAULT NULL,
  `NUMERIC_PRECISION` bigint(21) unsigned DEFAULT NULL,
  `NUMERIC_SCALE` bigint(21) unsigned DEFAULT NULL,
  `DATETIME_PRECISION` bigint(21) unsigned DEFAULT NULL,
  `CHARACTER_SET_NAME` varchar(32) CHARACTER SET utf8 DEFAULT NULL,
  `COLLATION_NAME` varchar(32) CHARACTER SET utf8 DEFAULT NULL,
  `COLUMN_TYPE` longtext CHARACTER SET utf8 NOT NULL,
  `COLUMN_KEY` varchar(3) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `EXTRA` varchar(30) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `PRIVILEGES` varchar(80) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `COLUMN_COMMENT` varchar(1024) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`id`),
  KEY `big_fk` (`TABLE_SCHEMA`)
) ENGINE=InnoDB AUTO_INCREMENT=1718273 DEFAULT CHARSET=latin1
1 row in set (0.00 sec)
</pre></div></div><br class="example-break"><div class="example"><a name="online-ddl-ex-auto-increment"></a><p class="title"><b>例 14.6 自動インクリメント値の変更</b></p><div class="example-contents"><p>
        テーブルカラムの<a class="link" href="glossary.html#glos_auto_increment" title="自動インクリメント">自動インクリメント</a>の下限値を増やすコードを次に示します。これは、この操作によってテーブル再構築がどのように回避されているか、さらには <code class="literal">InnoDB</code> の自動インクリメントカラムに関する興味深いその他のいくつかの事実を示しています。
      </p><a name="online-ddl-autoinc"></a><pre class="programlisting">
/*
If this script is run after foreign_key.sql, the schema_names table is
already set up. But to allow this script to run multiple times without
running into duplicate ID errors, we set up the schema_names table
all over again.
*/

\! clear

\! echo "=== Adjusting the Auto-Increment Limit for a Table ==="
\! echo

drop table if exists schema_names;
create table schema_names (id int unsigned not null primary key auto_increment,
  schema_name varchar(64) character set utf8 not null, index i_schema (schema_name))
  as select distinct table_schema schema_name from small_table;

\! echo "Initial state of schema_names table. AUTO_INCREMENT is included in SHOW CREATE TABLE output."
\! echo "Note how MySQL reserved a block of IDs, but only needed 4 of them in this transaction, so the next inserted values would get IDs 8 and 9."
show create table schema_names\G
select * from schema_names order by id;

\! echo "Inserting even a tiny amount of data can produce gaps in the ID sequence."
insert into schema_names (schema_name) values ('eight'), ('nine');

\! echo "Bumping auto-increment lower limit to 20 (fast mechanism):"
alter table schema_names auto_increment=20<span class="bold"><strong>, algorithm=inplace</strong></span>;

\! echo "Inserting 2 rows that should get IDs 20 and 21:"
insert into schema_names (schema_name) values ('foo'), ('bar');
commit;

\! echo "Bumping auto-increment lower limit to 30 (slow mechanism):"
alter table schema_names auto_increment=30<span class="bold"><strong>, algorithm=copy</strong></span>;

\! echo "Inserting 2 rows that should get IDs 30 and 31:"
insert into schema_names (schema_name) values ('bletch'),('baz');
commit;

select * from schema_names order by id;

\! echo "Final state of schema_names table. AUTO_INCREMENT value shows the next inserted row would get ID=32."
show create table schema_names\G
</pre><p>
        このコードを実行すると、簡略化のために圧縮され、もっとも重要な点が太字で示された次の出力が得られます。
      </p><pre class="programlisting">
=== Adjusting the Auto-Increment Limit for a Table ===

Query OK, 0 rows affected (0.01 sec)

Query OK, 4 rows affected (0.02 sec)
Records: 4  Duplicates: 0  Warnings: 0

Initial state of schema_names table. AUTO_INCREMENT is included in SHOW CREATE TABLE output.
Note how MySQL reserved a block of IDs, but only needed 4 of them in this transaction, so the next inserted values would get IDs 8 and 9.
*************************** 1. row ***************************
       Table: schema_names
Create Table: CREATE TABLE `schema_names` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `schema_name` varchar(64) CHARACTER SET utf8 NOT NULL,
  PRIMARY KEY (`id`),
  KEY `i_schema` (`schema_name`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=latin1
1 row in set (0.00 sec)

+----+--------------------+
| id | schema_name        |
+----+--------------------+
|  1 | information_schema |
|  2 | mysql              |
|  3 | performance_schema |
|  4 | test               |
+----+--------------------+
4 rows in set (0.00 sec)

Inserting even a tiny amount of data can produce gaps in the ID sequence.
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0

Query OK, 0 rows affected (0.00 sec)

Bumping auto-increment lower limit to 20 (fast mechanism):
Query OK, <span class="bold"><strong>0 rows affected</strong></span> (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0

Inserting 2 rows that should get IDs 20 and 21:
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0

Query OK, 0 rows affected (0.00 sec)

Query OK, 0 rows affected (0.00 sec)

Bumping auto-increment lower limit to 30 (slow mechanism):
Query OK, <span class="bold"><strong>8 rows affected</strong></span> (0.02 sec)
Records: 8  Duplicates: 0  Warnings: 0

Inserting 2 rows that should get IDs 30 and 31:
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0

Query OK, 0 rows affected (0.01 sec)

+----+--------------------+
| id | schema_name        |
+----+--------------------+
|  1 | information_schema |
|  2 | mysql              |
|  3 | performance_schema |
|  4 | test               |
|  8 | eight              |
|  9 | nine               |
| 20 | foo                |
| 21 | bar                |
| 30 | bletch             |
| 31 | baz                |
+----+--------------------+
10 rows in set (0.00 sec)

Query OK, 0 rows affected (0.00 sec)

Final state of schema_names table. AUTO_INCREMENT value shows the next inserted row would get ID=32.
*************************** 1. row ***************************
       Table: schema_names
Create Table: CREATE TABLE `schema_names` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `schema_name` varchar(64) CHARACTER SET utf8 NOT NULL,
  PRIMARY KEY (`id`),
  KEY `i_schema` (`schema_name`)
) ENGINE=InnoDB <span class="bold"><strong>AUTO_INCREMENT=32</strong></span> DEFAULT CHARSET=latin1
1 row in set (0.00 sec)
</pre></div></div><br class="example-break"><div class="example"><a name="online-ddl-ex-lock-clause"></a><p class="title"><b>例 14.7 LOCK 句を使用した並列性の制御</b></p><div class="example-contents"><p>
        この例は、<code class="literal">ALTER TABLE</code> ステートメントの <code class="literal">LOCK</code> 句を使用して、オンライン DDL 操作の進行中にテーブルへの並列アクセスを許可または拒否する方法を示しています。この句には、クエリーと <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> ステートメントを許可するか (<code class="literal">LOCK=NONE</code>)、<a class="link" href="glossary.html#glos_query" title="クエリー">クエリー</a>のみを許可するか (<code class="literal">LOCK=SHARED</code>)、または並列アクセスをまったく許可しない (<code class="literal">LOCK=EXCLUSIVE</code>) 設定があります。
      </p><p>
        ここでは、いずれかのセッションの待機中またはデッドロック中の動作を確認するために、<code class="literal">LOCK</code> 句の異なる値を使用して、1 つのセッションで連続した <code class="literal">ALTER TABLE</code> ステートメントを実行してインデックスを作成および削除します。前の例と同じ <code class="literal">BIG_TABLE</code> テーブルを使用し、約 170 万行から始めます。説明のために、<code class="literal">IS_NULLABLE</code> カラムに対してインデックス作成とクエリーを実行します。(ただし、実際には、固有の値が 2 つしかない非常に小さなカラムのインデックスを作成することはありえません。)
      </p><pre class="programlisting">
mysql: desc big_table;
+--------------------------+---------------------+------+-----+---------+----------------+
| Field                    | Type                | Null | Key | Default | Extra          |
+--------------------------+---------------------+------+-----+---------+----------------+
| TABLE_CATALOG            | varchar(512)        | NO   |     |         |                |
| TABLE_SCHEMA             | varchar(64)         | NO   |     |         |                |
| TABLE_NAME               | varchar(64)         | NO   |     |         |                |
| COLUMN_NAME              | varchar(64)         | NO   |     |         |                |
| ORDINAL_POSITION         | bigint(21) unsigned | NO   |     | 0       |                |
| COLUMN_DEFAULT           | longtext            | YES  |     | NULL    |                |

<span class="bold"><strong>| IS_NULLABLE              | varchar(3)          | NO   |     |         |                |</strong></span>
...
+--------------------------+---------------------+------+-----+---------+----------------+
21 rows in set (0.14 sec)

mysql: alter table big_table add index i1(is_nullable);
Query OK, 0 rows affected (20.71 sec)

mysql: alter table big_table drop index i1;
Query OK, 0 rows affected (0.02 sec)

mysql: alter table big_table add index i1(is_nullable)<span class="bold"><strong>, lock=exclusive</strong></span>;
Query OK, 0 rows affected (19.44 sec)

mysql: alter table big_table drop index i1;
Query OK, 0 rows affected (0.03 sec)

mysql: alter table big_table add index i1(is_nullable)<span class="bold"><strong>, lock=shared</strong></span>;
Query OK, 0 rows affected (16.71 sec)

mysql: alter table big_table drop index i1;
Query OK, 0 rows affected (0.05 sec)

mysql: alter table big_table add index i1(is_nullable)<span class="bold"><strong>, lock=none</strong></span>;
Query OK, 0 rows affected (12.26 sec)

mysql: alter table big_table drop index i1;
Query OK, 0 rows affected (0.01 sec)

... repeat statements like the above while running queries ...
... and DML statements at the same time in another session ...
</pre><p>
        DDL ステートメントを実行しているセッションでは、特別なことは何も発生しません。場合によっては、別のトランザクションが DDL 中にテーブルを変更したか、または DDL の前にテーブルをクエリーしたとき、そのトランザクションの完了を待機しているために <code class="literal">ALTER TABLE</code> に非常に長い時間がかかることがあります。
      </p><pre class="programlisting">
mysql: alter table big_table add index i1(is_nullable), lock=none;

<span class="bold"><strong>Query OK, 0 rows affected (59.27 sec)</strong></span>

mysql: -- The previous ALTER took so long because it was waiting for all the concurrent
mysql: -- transactions to commit or roll back.

mysql: alter table big_table drop index i1;
<span class="bold"><strong>Query OK, 0 rows affected (41.05 sec)</strong></span>

mysql: -- Even doing a SELECT on the table in the other session first causes
mysql: -- the ALTER TABLE above to stall until the transaction
mysql: -- surrounding the SELECT is committed or rolled back.
</pre><p>
        同時に実行されている別のセッションのログを次に示します。ここでは、前のリストに示されている DDL 操作の前、最中、およびあとにテーブルに対してクエリーと DML ステートメントを発行しています。この最初のリストは、クエリーのみを示しています。<code class="literal">LOCK=NONE</code> または <code class="literal">LOCK=SHARED</code> を使用して DDL 操作中にクエリーが許可されること、および <code class="literal">ALTER TABLE</code> ステートメントに <code class="literal">LOCK=EXCLUSIVE</code> が含まれている場合は DDL が完了するまでクエリーが待機することを予測しています。
      </p><pre class="programlisting">
mysql: show variables like 'autocommit';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
1 row in set (0.01 sec)

mysql: -- A trial query before any ADD INDEX in the other session:
mysql: -- Note: because autocommit is enabled, each
mysql: -- transaction finishes immediately after the query.
mysql: select distinct is_nullable from big_table;
+-------------+
| is_nullable |
+-------------+
| NO          |
| YES         |
+-------------+
2 rows in set (4.49 sec)

mysql: -- Index is being created with LOCK=EXCLUSIVE on the ALTER statement.
mysql: -- The query waits until the DDL is finished before proceeding.
mysql: select distinct is_nullable from big_table;
+-------------+
| is_nullable |
+-------------+
| NO          |
| YES         |
+-------------+

<span class="bold"><strong>2 rows in set (17.26 sec)</strong></span>

mysql: -- Index is being created with LOCK=SHARED on the ALTER statement.
mysql: -- The query returns its results while the DDL is in progress.
mysql: -- The same thing happens with LOCK=NONE on the ALTER statement.
mysql: select distinct is_nullable from big_table;
+-------------+
| is_nullable |
+-------------+
| NO          |
| YES         |
+-------------+
<span class="bold"><strong>2 rows in set (3.11 sec)</strong></span>

mysql: -- Once the index is created, and with no DDL in progress,
mysql: -- queries referencing the indexed column are very fast:
mysql: select count(*) from big_table where is_nullable = 'YES';
+----------+
| count(*) |
+----------+
|   411648 |
+----------+
<span class="bold"><strong>1 row in set (0.20 sec)</strong></span>

mysql: select distinct is_nullable from big_table;
+-------------+
| is_nullable |
+-------------+
| NO          |
| YES         |
+-------------+
<span class="bold"><strong>2 rows in set (0.00 sec)</strong></span>
</pre><p>
        次に、この並列セッションで、DML ステートメントまたは DML ステートメントとクエリーの組み合わせを含むいくつかのトランザクションを実行します。テーブルへの予測可能かつ検証可能な変更を示すために、<code class="literal">DELETE</code> ステートメントを使用します。この部分にあるトランザクションは複数のステートメントにまたがる場合があるため、これらのテストは <code class="literal">autocommit</code> がオフになった状態で実行します。
      </p><pre class="programlisting">
mysql: set global autocommit = off;
Query OK, 0 rows affected (0.00 sec)

mysql: -- Count the rows that will be involved in our DELETE statements:
mysql: select count(*) from big_table where is_nullable = 'YES';
+----------+
| count(*) |
+----------+
|   411648 |
+----------+
1 row in set (0.95 sec)

mysql: -- After this point, any DDL statements back in the other session 
mysql: -- stall until we commit or roll back.

mysql: delete from big_table where is_nullable = 'YES' limit 11648;
Query OK, 11648 rows affected (0.14 sec)

mysql: select count(*) from big_table where is_nullable = 'YES';
+----------+
| count(*) |
+----------+
|   400000 |
+----------+
1 row in set (1.04 sec)

mysql: rollback;
Query OK, 0 rows affected (0.09 sec)

mysql: select count(*) from big_table where is_nullable = 'YES';
+----------+
| count(*) |
+----------+
|   411648 |
+----------+
1 row in set (0.93 sec)

mysql: -- OK, now we're going to try that during index creation with LOCK=NONE.
mysql: delete from big_table where is_nullable = 'YES' limit 11648;
Query OK, 11648 rows affected (0.21 sec)

mysql: -- We expect that now there will be 400000 'YES' rows left:
mysql: select count(*) from big_table where is_nullable = 'YES';
+----------+
| count(*) |
+----------+
|   400000 |
+----------+
1 row in set (1.25 sec)

mysql: -- In the other session, the ALTER TABLE is waiting before finishing,
mysql: -- because _this_ transaction hasn't committed or rolled back yet.
mysql: rollback;
Query OK, 0 rows affected (0.11 sec)

mysql: select count(*) from big_table where is_nullable = 'YES';
+----------+
| count(*) |
+----------+
|   411648 |
+----------+
1 row in set (0.19 sec)

mysql: -- The ROLLBACK left the table in the same state we originally found it.
mysql: -- Now let's make a permanent change while the index is being created,
mysql: -- again with ALTER TABLE ... , LOCK=NONE.
mysql: -- First, commit so the DROP INDEX in the other shell can finish;
mysql: -- the previous SELECT started a transaction that accessed the table.
mysql: commit;
Query OK, 0 rows affected (0.00 sec)

mysql: -- Now we add the index back in the other shell, then issue DML in this one
mysql: -- while the DDL is running.
mysql: delete from big_table where is_nullable = 'YES' limit 11648;
Query OK, 11648 rows affected (0.23 sec)

mysql: commit;
Query OK, 0 rows affected (0.01 sec)

mysql: -- In the other shell, the ADD INDEX has finished.
mysql: select count(*) from big_table where is_nullable = 'YES';
+----------+
| count(*) |
+----------+
|   400000 |
+----------+
1 row in set (0.19 sec)

mysql: -- At the point the new index is finished being created, it contains entries
mysql: -- only for the 400000 'YES' rows left when all concurrent transactions are finished.
mysql: 
mysql: -- Now we will run a similar test, while ALTER TABLE ... , LOCK=SHARED is running.
mysql: -- We expect a query to complete during the ALTER TABLE, but for the DELETE
mysql: -- to run into some kind of issue.
mysql: commit;
Query OK, 0 rows affected (0.00 sec)

mysql: -- As expected, the query returns results while the LOCK=SHARED DDL is running:
mysql: select count(*) from big_table where is_nullable = 'YES';
+----------+
| count(*) |
+----------+
|   400000 |
+----------+
1 row in set (2.07 sec)

mysql: -- The DDL in the other session is not going to finish until this transaction
mysql: -- is committed or rolled back. If we tried a DELETE now and it waited because
mysql: -- of LOCK=SHARED on the DDL, both transactions would wait forever (deadlock).
mysql: -- MySQL detects this condition and cancels the attempted DML statement.
mysql: delete from big_table where is_nullable = 'YES' limit 100000;
ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction
mysql: -- The transaction here is still going, so in the other shell, the ADD INDEX operation
mysql: -- is waiting for this transaction to commit or roll back.
mysql: rollback;
Query OK, 0 rows affected (0.00 sec)

mysql: -- Now let's try issuing a query and some DML, on one line, while running
mysql: -- ALTER TABLE ... , LOCK=EXCLUSIVE in the other shell.
mysql: -- Notice how even the query is held up until the DDL is finished.
mysql: -- By the time the DELETE is issued, there is no conflicting access
mysql: -- to the table and we avoid the deadlock error.
mysql: select count(*) from big_table where is_nullable = 'YES'; delete from big_table where is_nullable = 'YES' limit 100000;
+----------+
| count(*) |
+----------+
|   400000 |
+----------+

<span class="bold"><strong>1 row in set (15.98 sec)</strong></span>

Query OK, 100000 rows affected (2.81 sec)

mysql: select count(*) from big_table where is_nullable = 'YES';
+----------+
| count(*) |
+----------+
|   300000 |
+----------+
1 row in set (0.17 sec)

mysql: rollback;
Query OK, 0 rows affected (1.36 sec)

mysql: select count(*) from big_table where is_nullable = 'YES';
+----------+
| count(*) |
+----------+
|   400000 |
+----------+
1 row in set (0.19 sec)

mysql: commit;
Query OK, 0 rows affected (0.00 sec)

mysql: -- Next, we try ALTER TABLE ... , LOCK=EXCLUSIVE in the other session
mysql: -- and only issue DML, not any query, in the concurrent transaction here.
mysql: delete from big_table where is_nullable = 'YES' limit 100000;
<span class="bold"><strong>Query OK, 100000 rows affected (16.37 sec)</strong></span>

mysql: -- That was OK because the ALTER TABLE did not have to wait for the transaction
mysql: -- here to complete. The DELETE in this session waited until the index was ready.
mysql: select count(*) from big_table where is_nullable = 'YES';
+----------+
| count(*) |
+----------+
|   300000 |
+----------+
1 row in set (0.16 sec)

mysql: commit;
Query OK, 0 rows affected (0.00 sec)
</pre><p>
        前のリスト例では、次のことがわかりました。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">ALTER TABLE</code> の <code class="literal">LOCK</code> 句は、ステートメントの残りの部分からカンマで区切られます。
          </p></li><li class="listitem"><p>
            オンライン DDL 操作は、テーブルにアクセスする以前のいずれかのトランザクションがコミットまたはロールバックされるまで、開始前に待機する可能性があります。
          </p></li><li class="listitem"><p>
            オンライン DDL 操作は、テーブルにアクセスするいずれかの並列トランザクションがコミットまたはロールバックされるまで、完了前に待機する可能性があります。
          </p></li><li class="listitem"><p>
            <code class="literal">ALTER TABLE</code> ステートメントが <code class="literal">LOCK=NONE</code> または <code class="literal">LOCK=SHARED</code> を使用しているかぎり、オンライン DDL 操作が実行されている間の並列クエリーの動作は比較的単純です。
          </p></li><li class="listitem"><p>
            <code class="literal">autocommit</code> がオンとオフのどちらになっているかに注意を払ってください。オフになっている場合は、テーブルで DDL 操作を実行する前にほかのセッションのトランザクション (クエリーだけであっても) を終了するときは注意してください。
          </p></li><li class="listitem"><p>
            <code class="literal">LOCK=SHARED</code> では、クエリーと DML が混在した並列トランザクションでデッドロックエラーが発生する可能性があるため、DDL が完了したあとにこれらのトランザクションを再開する必要があります。
          </p></li><li class="listitem"><p>
            <code class="literal">LOCK=NONE</code> では、並列トランザクションにクエリーと DML を自由に混在させることができます。DDL 操作は、並列トランザクションがコミットまたはロールバックされるまで待機します。
          </p></li><li class="listitem"><p>
            <code class="literal">LOCK=EXCLUSIVE</code> では、並列トランザクションにクエリーと DML を自由に混在させることができますが、これらのトランザクションは、DDL 操作が完了するまで待機したあとでしかテーブルにアクセスできません。
          </p></li></ul></div></div></div><br class="example-break"><div class="example"><a name="online-ddl-ex-multi-create-index"></a><p class="title"><b>例 14.8 オンライン DDL 実験のためのスキーマ設定コード</b></p><div class="example-contents"><p>
        1 つの <code class="literal">ALTER TABLE</code> ステートメントでテーブル上に複数のインデックスを作成できます。テーブルのクラスタ化されたインデックスは 1 回しかスキャンする必要がない (ただし、データは新しいインデックスごとに個別にソートされます) ため、これはかなり効率的です。例:
      </p><pre class="programlisting">
CREATE TABLE T1(A INT PRIMARY KEY, B INT, C CHAR(1)) ENGINE=InnoDB;
INSERT INTO T1 VALUES (1,2,'a'), (2,3,'b'), (3,2,'c'), (4,3,'d'), (5,2,'e');
COMMIT;
ALTER TABLE T1 ADD INDEX (B), ADD UNIQUE INDEX (C);
</pre><p>
        カラム <code class="literal">A</code> に主キーを持つ上のステートメント CREATE TABLE <code class="literal">T1</code> は、いくつかの行を挿入したあと、カラム <code class="literal">B</code> と <code class="literal">C</code> に 2 つの新しいインデックスを構築します。<code class="literal">ALTER TABLE</code> ステートメントの前に <code class="literal">T1</code> に多数の行が挿入されていたとすると、このアプローチは、データをロードする前にすべてのセカンダリインデックスを作成するよりはるかに効率的です。

        
      </p><p>
        InnoDB セカンダリインデックスの削除にもテーブルデータのコピーは必要ないため、1 つの <code class="literal">ALTER TABLE</code> ステートメントまたは複数の <code class="literal">DROP INDEX</code> ステートメントで複数のインデックスを削除することは等しく効率的です。
      </p><pre class="programlisting">
ALTER TABLE T1 DROP INDEX B, DROP INDEX C;
</pre><p>
        または
      </p><pre class="programlisting">
DROP INDEX B ON T1;
DROP INDEX C ON T1;
</pre></div></div><br class="example-break"><div class="example"><a name="online-ddl-ex-primary-key"></a><p class="title"><b>例 14.9 主キーの作成および削除</b></p><div class="example-contents"><p>
        <code class="literal">InnoDB</code> テーブルの<a class="link" href="glossary.html#glos_clustered_index" title="クラスタ化されたインデックス">クラスタ化されたインデックス</a>の再構成には常に、テーブルデータのコピーが必要です。そのため、テーブルの再構築を回避するために、あとで <code class="literal">ALTER TABLE ... ADD PRIMARY KEY</code> を発行するのではなく、テーブルの作成時に<a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a>を定義することをお勧めします。
      </p><p>
        次の例のように、あとで <code class="literal">PRIMARY KEY</code> を定義した場合はデータがコピーされます。
      </p><pre class="programlisting">
CREATE TABLE T2 (A INT, B INT);
INSERT INTO T2 VALUES (NULL, 1);
ALTER TABLE T2 ADD PRIMARY KEY (B);
</pre><p>
        <code class="literal">UNIQUE</code> または <code class="literal">PRIMARY KEY</code> インデックスを作成したとき、MySQL は、いくつかの追加の作業を行う必要があります。<code class="literal">UNIQUE</code> インデックスの場合、MySQL は、テーブルに重複したキーの値が含まれていないことをチェックします。<code class="literal">PRIMARY KEY</code> インデックスの場合も、MySQL は、どの <code class="literal">PRIMARY KEY</code> カラムにも <code class="literal">NULL</code> が含まれていないことをチェックします。
      </p><p>
        

        <code class="literal">ALGORITHM=COPY</code> 句を使用して主キーを追加したとき、MySQL は実際には、関連付けられたカラム内の <code class="literal">NULL</code> 値をデフォルト値、つまり、数値の場合は 0、文字ベースのカラムや BLOB の場合は空の文字列、および <code class="literal">DATETIME</code> の場合は 0000-00-00 00:00:00 に変換します。これは非標準の動作であるため、これに依存しないようにすることをお勧めします。<code class="literal">ALGORITHM=INPLACE</code> を使用した主キーの追加は、<code class="literal">SQL_MODE</code> 設定に <code class="literal">strict_trans_tables</code> または <code class="literal">strict_all_tables</code> フラグが含まれている場合にのみ許可されます。<code class="literal">SQL_MODE</code> 設定が厳密である場合は、<code class="literal">ADD PRIMARY KEY ... , ALGORITHM=INPLACE</code> が許可されますが、要求された主キーカラムに <code class="literal">NULL</code> 値が含まれているとステートメントは引き続き失敗します。<code class="literal">ALGORITHM=INPLACE</code> の動作は、より標準に準拠しています。
      </p><p>
        次の例は、<code class="literal">ADD PRIMARY KEY</code> 句のいくつかの可能性を示しています。<code class="literal">ALGORITHM=COPY</code> 句を使用した場合、主キーカラム内に <code class="literal">NULL</code> 値が存在していても操作は成功します。データは暗黙のうちに変更され、それによって問題が発生する可能性があります。
      </p><pre class="programlisting">mysql&gt; CREATE TABLE add_pk_via_copy (c1 INT, c2 VARCHAR(10), c3 DATETIME);
Query OK, 0 rows affected (0.03 sec)

mysql&gt; INSERT INTO add_pk_via_copy VALUES (1,'a','2014-11-03 11:01:37'),(NULL,NULL,NULL);
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql&gt; SET sql_mode = '';
Query OK, 0 rows affected (0.00 sec)

mysql&gt; ALTER TABLE add_pk_via_copy ADD PRIMARY KEY (c1,c2,c3), ALGORITHM=COPY;
Query OK, 2 rows affected, 3 warnings (0.07 sec)
Records: 2  Duplicates: 0  Warnings: 3

mysql&gt; SHOW WARNINGS;
+---------+------+-----------------------------------------+
| Level   | Code | Message                                 |
+---------+------+-----------------------------------------+
| Warning | 1265 | Data truncated for column 'c1' at row 2 |
| Warning | 1265 | Data truncated for column 'c2' at row 2 |
| Warning | 1265 | Data truncated for column 'c3' at row 2 |
+---------+------+-----------------------------------------+
3 rows in set (0.00 sec)

mysql&gt; SELECT * FROM add_pk_via_copy;
+----+----+---------------------+
| c1 | c2 | c3                  |
+----+----+---------------------+
|  0 |    | 0000-00-00 00:00:00 |
|  1 | a  | 2014-11-03 11:01:37 |
+----+----+---------------------+
2 rows in set (0.00 sec)
        
      </pre><p>
        <code class="literal">ALGORITHM=INPLACE</code> 句を使用した場合、この設定ではデータの整合性を高い優先度とみなしているため、操作はさまざまな理由で失敗する可能性があります。このステートメントは、<code class="literal">SQL_MODE</code> 設定が十分に<span class="quote">「<span class="quote">厳密</span>」</span>でない場合、または主キーカラムに <code class="literal">NULL</code> 値が含まれている場合にエラーを出力します。これらの両方の要件に対応すれば、<code class="literal">ALTER TABLE</code> 操作は成功します。
      </p><pre class="programlisting">mysql&gt; CREATE TABLE add_pk_via_inplace (c1 INT, c2 VARCHAR(10), c3 DATETIME);
Query OK, 0 rows affected (0.02 sec)

mysql&gt; INSERT INTO add_pk_via_inplace VALUES (1,'a','2014-11-03 11:01:37'),(NULL,NULL,NULL);
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql&gt; SELECT * FROM add_pk_via_inplace;
+------+------+---------------------+
| c1   | c2   | c3                  |
+------+------+---------------------+
|    1 | a    | 2014-11-03 11:01:37 |
| NULL | NULL | NULL                |
+------+------+---------------------+
2 rows in set (0.00 sec)

mysql&gt; SET sql_mode = '';
Query OK, 0 rows affected (0.00 sec)

mysql&gt; ALTER TABLE add_pk_via_inplace ADD PRIMARY KEY (c1,c2,c3), ALGORITHM=INPLACE;
ERROR 1846 (0A000): ALGORITHM=INPLACE is not supported. Reason: cannot silently convert NULL values, 
as required in this SQL_MODE. Try ALGORITHM=COPY.

mysql&gt; SET sql_mode ='strict_trans_tables';
Query OK, 0 rows affected (0.00 sec)

mysql&gt; ALTER TABLE add_pk_via_inplace ADD PRIMARY KEY (c1,c2,c3), ALGORITHM=INPLACE;
ERROR 1138 (22004): Invalid use of NULL value
mysql&gt; DELETE FROM add_pk_via_inplace WHERE c1 IS NULL OR c2 IS NULL OR c3 IS NULL;
Query OK, 1 row affected (0.01 sec)

mysql&gt; SELECT * FROM add_pk_via_inplace;
+------+------+---------------------+
| c1   | c2   | c3                  |
+------+------+---------------------+
|    1 | a    | 2014-11-03 11:01:37 |
+------+------+---------------------+
1 row in set (0.00 sec)

mysql&gt; ALTER TABLE add_pk_via_inplace ADD PRIMARY KEY (c1,c2,c3), ALGORITHM=INPLACE;
Query OK, 0 rows affected (0.09 sec)
Records: 0  Duplicates: 0  Warnings: 0
</pre><p>
        主キーなしでテーブルを作成すると、InnoDB は、主キーを自動的に選択します。これは、<code class="literal">NOT NULL</code> カラムで定義された最初の <code class="literal">UNIQUE</code> キー、またはシステムで生成されたキーである場合があります。隠れた余分なカラムの不確実性や、それに対して領域要件が発生する可能性を排除するには、<code class="literal">CREATE TABLE</code> ステートメントの一部として <code class="literal">PRIMARY KEY</code> 句を指定します。
      </p></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-create-index-implementation"></a>14.11.6 オンライン DDL の実装の詳細</h3></div></div></div><a class="indexterm" name="idm139979070797984"></a><a class="indexterm" name="idm139979070795824"></a><p>
      <code class="literal">InnoDB</code> テーブルに対する各 <code class="literal">ALTER TABLE</code> 操作は、次のいくつかの側面によって制御されます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          テーブルの物理表現への何らかの変更があるかどうか、またはそれが純粋に、テーブル自体を変更することなく実行できるメタデータへの変更であるかどうか。
        </p></li><li class="listitem"><p>
          テーブル内のデータの量が同じままか、増えているか、または減っているか。
        </p></li><li class="listitem"><p>
          テーブルデータ内の変更がクラスタ化されたインデックス、セカンダリインデックス、またはその両方に関連しているかどうか。
        </p></li><li class="listitem"><p>
          変更されるテーブルとその他のテーブルの間に何らかの<a class="link" href="glossary.html#glos_foreign_key" title="外部キー">外部キー</a>関係が存在するかどうか。このメカニクスは、<code class="literal">foreign_key_checks</code> 構成オプションが有効または無効のどちらになっているかによって異なります。
        </p></li><li class="listitem"><p>
          テーブルがパーティション化されているかどうか。<code class="literal">ALTER TABLE</code> のパーティション化句は 1 つ以上のテーブルに関連する低レベルの操作に変換され、これらの操作はオンライン DDL の通常のルールに従います。
        </p></li><li class="listitem"><p>
          テーブルデータをコピーする必要があるかどうか、テーブルを<span class="quote">「<span class="quote">インプレース</span>」</span>で再編成できるかどうか、またはその両方の組み合わせか。
        </p></li><li class="listitem"><p>
          テーブルに<a class="link" href="glossary.html#glos_auto_increment" title="自動インクリメント">自動インクリメント</a>カラムが含まれているかどうか。
        </p></li><li class="listitem"><p>
          ベースとなるデータベース操作の性質、または <code class="literal">ALTER TABLE</code> ステートメントで指定した <code class="literal">LOCK</code> 句によって、どのようなレベルの<a class="link" href="glossary.html#glos_locking" title="ロック">ロック</a>が必要とされるか。
        </p></li></ul></div><p>
      このセクションでは、これらの要因が <code class="literal">InnoDB</code> テーブルでのさまざまな種類の <code class="literal">ALTER TABLE</code> 操作にどのような影響を与えるかについて説明します。
    </p><h4><a name="idm139979070772896"></a>オンライン DDL のエラー状態</h4><p>
      オンライン DDL 操作が失敗する可能性がある主な理由を次に示します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">LOCK</code> 句が、特定のタイプの DDL 操作とは互換性のない低レベルのロック (<code class="literal">SHARED</code> または <code class="literal">NONE</code>) を指定している場合。
        </p></li><li class="listitem"><p>
          DDL 操作の初期および最終フェーズ中に短時間だけ必要な、テーブルに対する<a class="link" href="glossary.html#glos_exclusive_lock" title="排他ロック">排他的ロック</a>の取得を待機している間にタイムアウトが発生した場合。
        </p></li><li class="listitem"><p>
          インデックス作成中に MySQL がディスク上に一時的なソートファイルを書き込んでいる間に <code class="literal">tmpdir</code> ファイルシステムのディスク領域が不足した場合。
        </p></li><li class="listitem"><p>
          <code class="literal">ALTER TABLE</code> に長い時間がかかりすぎたり、並列 DML によるテーブル変更が多すぎたりして、一時的なオンラインログのサイズが <code class="literal">innodb_online_alter_log_max_size</code> 構成オプションの値を超えた場合。この状態は <code class="literal">DB_ONLINE_LOG_TOO_BIG</code> エラーの原因になります。
        </p></li><li class="listitem"><p>
          並列 DML が、元のテーブル定義では許可されるが、新しいテーブル定義では許可されないテーブルに変更を加えた場合。この操作は、MySQL がいちばん最後に、並列 DML ステートメントからのすべての変更を適用しようとしたときにのみ失敗します。たとえば、一意のインデックスの作成中にカラムに重複した値を挿入したり、そのカラムでの<a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a>のインデックスの作成中にカラムに <code class="literal">NULL</code> 値を挿入したりすることがあります。並列 DML によって行われた変更が優先され、<code class="literal">ALTER TABLE</code> 操作は実質的に<a class="link" href="glossary.html#glos_rollback" title="ロールバック">ロールバック</a>されます。
        </p></li></ul></div><p>
      構成オプション <code class="literal">innodb_file_per_table</code> は <code class="literal">InnoDB</code> テーブルの表現に大きな影響を与えますが、そのオプションが有効または無効のどちらになっているかや、テーブルが物理的に独自の <a class="link" href="glossary.html#glos_ibd_file" title=".ibd ファイル">.ibd ファイル</a>内または<a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">システムテーブルスペース</a>の内部のどちらに配置されているかにかかわらず、すべてのオンライン DDL 操作が同様に適切に機能します。
    </p><p>
      InnoDB には、テーブル内のすべてのデータを表す<a class="link" href="glossary.html#glos_clustered_index" title="クラスタ化されたインデックス">クラスタ化されたインデックス</a>と、クエリーを高速化するためのオプションの<a class="link" href="glossary.html#glos_secondary_index" title="セカンダリインデックス">セカンダリインデックス</a>という 2 つのタイプのインデックスがあります。クラスタ化されたインデックスにはその B ツリーノード内のデータ値が含まれているため、クラスタ化されたインデックスの追加または削除には、データのコピーおよびテーブルの新しいコピーの作成が含まれます。ただし、セカンダリインデックスには、インデックスキーと主キーの値のみが含まれます。このタイプのインデックスは、クラスタ化されたインデックス内のデータをコピーすることなく作成または削除できます。各セカンダリインデックスには主キー値のコピー (必要に応じて、クラスタ化されたインデックスにアクセスするために使用されます) が含まれているため、主キーの定義を変更すると、すべてのセカンダリインデックスも再作成されます。
    </p><p>
      セカンダリインデックスの削除は単純です。内部の InnoDB システムテーブルと MySQL データディクショナリテーブルが、このインデックスは存在しなくなったという事実を反映するように更新されるだけです。InnoDB は、このインデックスに使用されているストレージをそれが含まれていたテーブルスペースに返して、新しいインデックスまたは追加のテーブル行がこの領域を使用できるようにします。
    </p><p>
      既存のテーブルにセカンダリインデックスを追加するには、InnoDB はそのテーブルをスキャンし、メモリーバッファーや一時ファイルを使用して各行をセカンダリインデックスキーカラムの値で順番にソートします。次に、B ツリーがキー値の順序で構築されます。これは、行をインデックスにランダムな順序で挿入するより効率的です。B ツリーノードはいっぱいになると分割されるため、このようにしてインデックスを構築するとインデックスのフィルファクタが高くなり、以降のアクセスがより効率的になります。
    </p><h4><a name="innodb-online-ddl-implementation"></a>主キーと副キーのインデックス</h4><p>
      従来より、MySQL サーバーと <code class="literal">InnoDB</code> はそれぞれ、テーブルおよびインデックス構造に関する独自のメタデータを保持しています。MySQL サーバーがこれらの情報を、トランザクションメカニズムによって保護されない <a class="link" href="glossary.html#glos_frm_file" title=".frm ファイル">.frm ファイル</a>内に格納するのに対して、<code class="literal">InnoDB</code> は、独自の<a class="link" href="glossary.html#glos_data_dictionary" title="データディクショナリ">データディクショナリ</a>を<a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">システムテーブルスペース</a>の一部として保持しています。DDL 操作が途中でクラッシュまたはその他の予期しないイベントによって中断された場合は、メタデータがこれらの 2 つの場所の間で整合性がない状態のままになり、起動エラーや、変更の途中であったテーブルへのアクセス不可などの問題が発生する可能性があります。<code class="literal">InnoDB</code> は現在、デフォルトのストレージエンジンであるため、このような問題への対処は高い優先度を持っています。これらの DDL 操作への拡張により、このような問題が発生する可能性のある期間が削減されます。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-create-index-recovery"></a>14.11.7 オンライン DDL でのクラッシュリカバリの動作のしくみ</h3></div></div></div><a class="indexterm" name="idm139979070733840"></a><p>
      <code class="literal">ALTER TABLE</code> ステートメントの実行中にサーバーがクラッシュしてもデータは失われませんが、<a class="link" href="glossary.html#glos_crash_recovery" title="クラッシュリカバリ">クラッシュリカバリ</a>のプロセスは、<a class="link" href="glossary.html#glos_clustered_index" title="クラスタ化されたインデックス">クラスタ化されたインデックス</a>の場合と<a class="link" href="glossary.html#glos_secondary_index" title="セカンダリインデックス">セカンダリインデックス</a>の場合で異なります。
    </p><p>
      InnoDB セカンダリインデックスの作成中にサーバーがクラッシュした場合、MySQL はリカバリ時に、部分的に作成されたインデックスをすべて削除します。<code class="literal">ALTER TABLE</code> または <code class="literal">CREATE INDEX</code> ステートメントを再実行する必要があります。
    </p><p>
      InnoDB のクラスタ化されたインデックスの作成中にクラッシュが発生した場合は、テーブル内のデータをまったく新しいクラスタ化されたインデックスにコピーする必要があるため、リカバリはより複雑です。すべての InnoDB テーブルが、クラスタ化されたインデックスとして格納されることに注意してください。次の説明では、テーブルとクラスタ化されたインデックスという言葉を区別なく使用しています。
    </p><p>
      MySQL は、既存のデータを元の InnoDB テーブルから目的のインデックス構造を持つ一時テーブルにコピーすることによって、新しいクラスタ化されたインデックスを作成します。データがこの一時テーブルに完全にコピーされたら、元のテーブルの名前が別の一時テーブル名に変更されます。新しいクラスタ化されたインデックスで構成される一時テーブルの名前が元のテーブルの名前に変更され、元のテーブルはデータベースから削除されます。
    </p><p>
      新しいクラスタ化されたインデックスの作成中にシステムクラッシュが発生した場合、データは失われませんが、このプロセス中に存在する一時テーブルを使用してリカバリプロセスを完了する必要があります。クラスタ化されたインデックスを再作成したり、大きなテーブルで主キーを再定義したり、あるいはこの操作中にシステムクラッシュが発生したりすることはまれであるため、このマニュアルではこのシナリオからのリカバリに関する情報は提供していません。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="online-ddl-partitioning"></a>14.11.8 パーティション化された InnoDB テーブルに対するオンライン DDL</h3></div></div></div><p>
      <code class="literal">ALTER TABLE</code> のパーティション化句を除き、パーティション化された <code class="literal">InnoDB</code> テーブルに対するオンライン DDL 操作は、通常の <code class="literal">InnoDB</code> テーブルに適用されるのと同じルールに従います。オンライン DDL のルールは、<a class="xref" href="innodb-storage-engine.html#innodb-online-ddl-summary-grid" title="表 14.5 DDL 操作のオンラインステータスのサマリー">表14.5「DDL 操作のオンラインステータスのサマリー」</a>で概説されています。
    </p><p>
      <code class="literal">ALTER TABLE</code> のパーティション化句は、通常のパーティション化されていない <code class="literal">InnoDB</code> テーブルと同じ内部のオンライン DDL API を経由せず、<code class="literal">ALGORITHM=DEFAULT</code> および <code class="literal">LOCK=DEFAULT</code> との組み合わせでのみ許可されます。
    </p><p>
      <code class="literal">ALTER TABLE</code> ステートメントで ALTER TABLE のパーティション化句を使用した場合、パーティション化されたテーブルは、<code class="literal">ALTER TABLE</code> <code class="literal">COPY</code> アルゴリズムを使用して<span class="quote">「<span class="quote">再パーティション化</span>」</span>されます。つまり、新しいパーティション化されたテーブルは、新しいパーティション化スキームで作成されます。新しく作成されたテーブルには <code class="literal">ALTER TABLE</code> ステートメントによって適用されたすべての変更が含まれ、テーブルデータが新しいテーブル構造にコピーされます。
    </p><p>
      <code class="literal">ALTER TABLE</code> のパーティション化句を使用してテーブルのパーティション化を変更しない場合、または <code class="literal">ALTER TABLE</code> ステートメントでほかの何らかのパーティション管理を実行した場合、<code class="literal">ALTER TABLE</code> は、各テーブルパーティションで <code class="literal">INPLACE</code> アルゴリズムを使用します。ただし、<code class="literal">INPLACE</code> <code class="literal">ALTER TABLE</code> 操作が各パーティションで実行されると、複数のパーティションで実行されている操作のために、システムリソースへの要求が増加することに注意してください。
    </p><p>
      <code class="literal">ALTER TABLE</code> ステートメントのパーティション化句が、通常のパーティション化されていない <code class="literal">InnoDB</code> テーブルと同じ内部のオンライン DDL API を経由しないにもかかわらず、MySQL は引き続き、可能な場合はデータコピーとロックを最小限に抑えようとします。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">RANGE</code> または <code class="literal">LIST</code> によってパーティション化されたテーブルに対する <code class="literal">ADD PARTITION</code> および <code class="literal">DROP PARTITION</code> では、どの既存のデータもコピーされません。
        </p></li><li class="listitem"><p>
          <code class="literal">TRUNCATE PARTITION</code> では、すべてのタイプのパーティション化されたテーブルについて、どの既存のデータもコピーされません。
        </p></li><li class="listitem"><p>
          並列クエリーは、<code class="literal">HASH</code> または <code class="literal">LIST</code> によってパーティション化されたテーブルに対する <code class="literal">ADD PARTITION</code> および <code class="literal">COALESCE PARTITION</code> 中に許可されます。MySQL は、共有ロックを保持している間にデータをコピーします。
        </p></li><li class="listitem"><p>
          <code class="literal">REORGANIZE PARTITION</code>、<code class="literal">REBUILD PARTITION</code>、あるいは <code class="literal">LINEAR HASH</code> または <code class="literal">LIST</code> によってパーティション化されたテーブルに対する <code class="literal">ADD PARTITION</code> または <code class="literal">COALESCE PARTITION</code> では、並列クエリーが許可されます。影響を受けるパーティションからのデータは、テーブルレベルの共有メタデータ (読み取り) ロックを保持している間にコピーされます。
        </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">InnoDB</code> のパーティション化されたテーブルでは、全文検索 (FTS) と外部キーはサポートされていません。詳細は、<a class="xref" href="functions.html#fulltext-restrictions" title="12.9.5 全文制限">セクション12.9.5「全文制限」</a>および<a class="xref" href="partitioning.html#partitioning-limitations-storage-engines" title="19.6.2 ストレージエンジンに関連するパーティショニング制限">セクション19.6.2「ストレージエンジンに関連するパーティショニング制限」</a>を参照してください。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-create-index-limitations"></a>14.11.9 オンライン DDL の制限</h3></div></div></div><a class="indexterm" name="idm139979070674208"></a><a class="indexterm" name="idm139979070672064"></a><a class="indexterm" name="idm139979070670016"></a><p>
      オンライン DDL 操作を実行する場合は、次の制限を考慮に入れてください。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          テーブルをコピーするオンライン DDL 操作中に、ファイルは一時ディレクトリ (Unix では <code class="literal">$TMPDIR</code>、Windows では <code class="literal">%TEMP%</code>、または <code class="literal">--tmpdir</code> 構成変数で指定されたディレクトリ) に書き込まれます。各一時ファイルは、新しいテーブルまたはインデックス内に 1 つのカラムを保持できるだけの十分な大きさを持ち、最終的なテーブルまたはインデックスにマージされたらすぐに削除されます。
        </p></li><li class="listitem"><p>
          どちらも同じインデックスを指定する <code class="literal">DROP INDEX</code> および <code class="literal">ADD INDEX</code> 句を含む <code class="literal">ALTER TABLE</code> ステートメントは、高速インデックス作成ではなくテーブルコピーを使用します。
        </p></li><li class="listitem"><p>
          <code class="literal">TEMPORARY TABLE</code> でインデックスを作成した場合は、高速インデックス作成が使用されるのではなく、テーブルがコピーされます。これは MySQL Bug #39833 としてレポートされています。
        </p></li><li class="listitem"><p>
          InnoDB は、外部キーに必要なインデックスをユーザーが削除しようとしたときにエラー事例を処理します。エラー <code class="literal">1553</code> に関連した詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-error-codes" title="14.19.5 InnoDB のエラーコード">セクション14.19.5「InnoDB のエラーコード」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">ALTER TABLE</code> の句 <code class="literal">LOCK=NONE</code> は、テーブル上に <code class="literal">ON...CASCADE</code> または <code class="literal">ON...SET NULL</code> 制約が存在する場合は許可されません。
        </p></li><li class="listitem"><p>
          オンライン DDL の各 <code class="literal">ALTER TABLE</code> ステートメント中に、<code class="literal">LOCK</code> 句には関係なく、テーブルに対する<a class="link" href="glossary.html#glos_exclusive_lock" title="排他ロック">排他的ロック</a> (<code class="literal">LOCK=EXCLUSIVE</code> 句で指定されるのと同じ種類のロック) を必要とする短い期間が最初と最後に存在します。そのため、そのテーブル上で挿入、更新、削除、または <code class="literal">SELECT ... FOR UPDATE</code> を実行している長時間実行されるトランザクションが存在する場合は、オンライン DDL 操作が開始前に待機する可能性があります。また、<code class="literal">ALTER TABLE</code> の進行中に同様の長時間実行されるトランザクションが開始された場合は、オンライン DDL 操作が完了前に待機する可能性があります。
        </p></li><li class="listitem"><p>
          オンライン <code class="literal">ALTER TABLE</code> 操作の実行時に、<code class="literal">ALTER TABLE</code> 操作を実行しているスレッドは、その同じテーブルに対してほかの接続スレッドから同時に実行された DML 操作の<span class="quote">「<span class="quote">オンラインログ</span>」</span>を適用します。これらの DML 操作が適用されると、重複したキーエントリのエラー (<span class="errortext">ERROR 1062 (23000): 重複したエントリ</span>) が発生する可能性があります。これは、重複したエントリが一時的なだけで、<span class="quote">「<span class="quote">オンラインログ</span>」</span>のあとの方のエントリによって元に戻されるとしても同じです。これは、トランザクション中は制約を保持する必要のある、<code class="literal">InnoDB</code> での外部キー制約チェックの考え方に似ています。
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> テーブルに対する <code class="literal">OPTIMIZE TABLE</code> は、テーブルを再構築して、インデックス統計を更新し、クラスタ化されたインデックス内の未使用領域を解放するための <code class="literal">ALTER TABLE</code> 操作にマップされます。5.6.17 より前は、この操作に対する<a class="link" href="innodb-storage-engine.html#innodb-online-ddl" title="14.11 InnoDB とオンライン DDL">オンライン DDL</a> のサポートはありません。主キーに現れる順序でキーが挿入されるため、セカンダリインデックスはそれほど効率的に作成されません。5.6.17 の時点では、<code class="literal">InnoDB</code> の通常のテーブルとパーティション化されたテーブルを再構築するための<a class="link" href="innodb-storage-engine.html#innodb-online-ddl" title="14.11 InnoDB とオンライン DDL">オンライン DDL</a> のサポートの追加によって、<code class="literal">OPTIMIZE TABLE</code> がサポートされます。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-create-index-overview" title="14.11.1 オンライン DDL の概要">セクション14.11.1「オンライン DDL の概要」</a>を参照してください。
        </p></li><li class="listitem"><p>
          MySQL 5.6 より前に作成された <code class="literal">InnoDB</code> テーブルは、一時的なカラム (<code class="literal">DATE</code>、<code class="literal">DATETIME</code>、または <code class="literal">TIMESTAMP</code>) を含み、かつ <code class="literal">ALTER TABLE ... ALGORITHM=COPY</code> を使用して再構築されていないテーブルに対する <code class="literal">ALTER TABLE ... ALGORITHM=INPLACE</code> をサポートしていません。この場合は、<code class="literal">ALTER TABLE ... ALGORITHM=INPLACE</code> 操作によって次のエラーが返されます。
        </p><pre class="programlisting">
ERROR 1846 (0A000): ALGORITHM=INPLACE is not supported. 
Reason: Cannot change column type INPLACE. Try ALGORITHM=COPY.
</pre></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-parameters"></a>14.12 InnoDB の起動オプションおよびシステム変数</h2></div></div></div><a class="indexterm" name="idm139979070615440"></a><a class="indexterm" name="idm139979070613312"></a><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          true または false であるシステム変数は、サーバー起動時に変数の名前を指定することで有効にすることができ、<code class="literal">--skip-</code> プリフィクスを使用することで無効にすることができます。たとえば、<code class="literal">InnoDB</code> 適応型ハッシュインデックスを有効または無効にするには、コマンド行で <code class="option">--innodb_adaptive_hash_index</code> または <code class="option">--skip-innodb_adaptive_hash_index</code> を使用するか、オプションファイルで <code class="literal">innodb_adaptive_hash_index</code> または <code class="literal">skip-innodb_adaptive_hash_index</code> を使用します。
        </p></li><li class="listitem"><p>
          数値が指定されるシステム変数は、コマンド行で <code class="option">--<em class="replaceable"><code>var_name</code></em>=<em class="replaceable"><code>value</code></em></code> として指定するか、オプションファイルで <code class="literal"><em class="replaceable"><code>var_name</code></em>=<em class="replaceable"><code>value</code></em></code> として指定できます。
        </p></li><li class="listitem"><p>
          多くのシステム変数は、実行時に変更できます (<a class="xref" href="server-administration.html#dynamic-system-variables" title="5.1.5.2 動的システム変数">セクション5.1.5.2「動的システム変数」</a>を参照してください)。
        </p></li><li class="listitem"><p>
          <code class="literal">GLOBAL</code> および <code class="literal">SESSION</code> 変数スコープ修飾子については、<code class="literal">SET</code> ステートメントのドキュメントを参照してください。
        </p></li><li class="listitem"><p>
          特定のオプションでは、<code class="literal">InnoDB</code> データファイルの場所およびレイアウトが制御されます。<a class="xref" href="innodb-storage-engine.html#innodb-configuration" title="14.3 InnoDB の構成">セクション14.3「InnoDB の構成」</a>では、これらのオプションを使用する方法について説明します。
        </p></li><li class="listitem"><p>
          初期段階では使用しないような一部のオプションは、マシンの処理能力やデータベースの<a class="link" href="glossary.html#glos_workload" title="ワークロード">ワークロード</a>に基づいて、<code class="literal">InnoDB</code> のパフォーマンス特性を調整する際に役立ちます。
        </p></li><li class="listitem"><p>
          オプションおよびシステム変数の指定に関する詳細は、<a class="xref" href="programs.html#program-options" title="4.2.3 プログラムオプションの指定">セクション4.2.3「プログラムオプションの指定」</a>を参照してください。
        </p></li></ul></div><div class="table"><a name="idm139979070588704"></a><p class="title"><b>表 14.6 <code class="literal">InnoDB</code> オプション/変数のリファレンス</b></p><div class="table-contents"><table summary="InnoDB オプション/変数のリファレンス" border="1"><colgroup><col class="name"><col class="cmd-line"><col class="option_file"><col class="system_var"><col class="status_var"><col class="var_scope"><col class="dynamic"></colgroup><thead><tr><th scope="col">名前</th><th scope="col">コマンド行</th><th scope="col">オプションファイル</th><th scope="col">システム変数</th><th scope="col">ステータス変数</th><th scope="col">変数スコープ</th><th scope="col">動的</th></tr></thead><tbody><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_enable_binlog">daemon_memcached_enable_binlog</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_engine_lib_name">daemon_memcached_engine_lib_name</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_engine_lib_path">daemon_memcached_engine_lib_path</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_option">daemon_memcached_option</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_r_batch_size">daemon_memcached_r_batch_size</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_w_batch_size">daemon_memcached_w_batch_size</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#sysvar_foreign_key_checks">foreign_key_checks</a></td><td> </td><td> </td><td>はい</td><td> </td><td>両方</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#sysvar_have_innodb">have_innodb</a></td><td> </td><td> </td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#option_mysqld_ignore-builtin-innodb">ignore-builtin-innodb</a></td><td>はい</td><td>はい</td><td> </td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"> - <span class="emphasis"><em>変数</em></span>: <a class="link" href="innodb-storage-engine.html#sysvar_ignore_builtin_innodb">ignore_builtin_innodb</a></td><td> </td><td> </td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#option_mysqld_innodb">innodb</a></td><td>はい</td><td>はい</td><td> </td><td> </td><td> </td><td> </td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_flushing">innodb_adaptive_flushing</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_flushing_lwm">innodb_adaptive_flushing_lwm</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_hash_index">innodb_adaptive_hash_index</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_max_sleep_delay">innodb_adaptive_max_sleep_delay</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_additional_mem_pool_size">innodb_additional_mem_pool_size</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_bk_commit_interval">innodb_api_bk_commit_interval</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_disable_rowlock">innodb_api_disable_rowlock</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_enable_binlog">innodb_api_enable_binlog</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_enable_mdl">innodb_api_enable_mdl</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_trx_level">innodb_api_trx_level</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoextend_increment">innodb_autoextend_increment</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoinc_lock_mode">innodb_autoinc_lock_mode</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_available_undo_logs">Innodb_available_undo_logs</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_bytes_data">Innodb_buffer_pool_bytes_data</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_bytes_dirty">Innodb_buffer_pool_bytes_dirty</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_dump_at_shutdown">innodb_buffer_pool_dump_at_shutdown</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_dump_now">innodb_buffer_pool_dump_now</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_dump_status">Innodb_buffer_pool_dump_status</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_filename">innodb_buffer_pool_filename</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances">innodb_buffer_pool_instances</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_load_abort">innodb_buffer_pool_load_abort</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_load_at_startup">innodb_buffer_pool_load_at_startup</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_load_now">innodb_buffer_pool_load_now</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_load_status">Innodb_buffer_pool_load_status</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_pages_data">Innodb_buffer_pool_pages_data</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_pages_dirty">Innodb_buffer_pool_pages_dirty</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_pages_flushed">Innodb_buffer_pool_pages_flushed</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_pages_free">Innodb_buffer_pool_pages_free</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_pages_latched">Innodb_buffer_pool_pages_latched</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_pages_misc">Innodb_buffer_pool_pages_misc</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_pages_total">Innodb_buffer_pool_pages_total</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_read_ahead">Innodb_buffer_pool_read_ahead</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_read_ahead_evicted">Innodb_buffer_pool_read_ahead_evicted</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_read_requests">Innodb_buffer_pool_read_requests</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_reads">Innodb_buffer_pool_reads</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size">innodb_buffer_pool_size</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_wait_free">Innodb_buffer_pool_wait_free</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_buffer_pool_write_requests">Innodb_buffer_pool_write_requests</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_change_buffer_max_size">innodb_change_buffer_max_size</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_change_buffering">innodb_change_buffering</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_checksum_algorithm">innodb_checksum_algorithm</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_checksums">innodb_checksums</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_cmp_per_index_enabled">innodb_cmp_per_index_enabled</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_commit_concurrency">innodb_commit_concurrency</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_compression_failure_threshold_pct">innodb_compression_failure_threshold_pct</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_compression_level">innodb_compression_level</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_compression_pad_pct_max">innodb_compression_pad_pct_max</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_concurrency_tickets">innodb_concurrency_tickets</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_file_path">innodb_data_file_path</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_data_fsyncs">Innodb_data_fsyncs</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_home_dir">innodb_data_home_dir</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_data_pending_fsyncs">Innodb_data_pending_fsyncs</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_data_pending_reads">Innodb_data_pending_reads</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_data_pending_writes">Innodb_data_pending_writes</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_data_read">Innodb_data_read</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_data_reads">Innodb_data_reads</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_data_writes">Innodb_data_writes</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_data_written">Innodb_data_written</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_dblwr_pages_written">Innodb_dblwr_pages_written</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_dblwr_writes">Innodb_dblwr_writes</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_disable_sort_file_cache">innodb_disable_sort_file_cache</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_doublewrite">innodb_doublewrite</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_fast_shutdown">innodb_fast_shutdown</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format">innodb_file_format</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format_check">innodb_file_format_check</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format_max">innodb_file_format_max</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table">innodb_file_per_table</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_log_at_timeout">innodb_flush_log_at_timeout</a></td><td> </td><td> </td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_log_at_trx_commit">innodb_flush_log_at_trx_commit</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_method">innodb_flush_method</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_neighbors">innodb_flush_neighbors</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_flushing_avg_loops">innodb_flushing_avg_loops</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_force_load_corrupted">innodb_force_load_corrupted</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_force_recovery">innodb_force_recovery</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_aux_table">innodb_ft_aux_table</a></td><td> </td><td> </td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_cache_size">innodb_ft_cache_size</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_enable_diag_print">innodb_ft_enable_diag_print</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_enable_stopword">innodb_ft_enable_stopword</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_max_token_size">innodb_ft_max_token_size</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_min_token_size">innodb_ft_min_token_size</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_num_word_optimize">innodb_ft_num_word_optimize</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_result_cache_limit">innodb_ft_result_cache_limit</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_server_stopword_table">innodb_ft_server_stopword_table</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_sort_pll_degree">innodb_ft_sort_pll_degree</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_total_cache_size">innodb_ft_total_cache_size</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_user_stopword_table">innodb_ft_user_stopword_table</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>両方</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_have_atomic_builtins">Innodb_have_atomic_builtins</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity">innodb_io_capacity</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity_max">innodb_io_capacity_max</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_large_prefix">innodb_large_prefix</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_lock_wait_timeout">innodb_lock_wait_timeout</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>両方</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_locks_unsafe_for_binlog">innodb_locks_unsafe_for_binlog</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_buffer_size">innodb_log_buffer_size</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_compressed_pages">innodb_log_compressed_pages</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_file_size">innodb_log_file_size</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_files_in_group">innodb_log_files_in_group</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_group_home_dir">innodb_log_group_home_dir</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_log_waits">Innodb_log_waits</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_log_write_requests">Innodb_log_write_requests</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_log_writes">Innodb_log_writes</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_lru_scan_depth">innodb_lru_scan_depth</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_dirty_pages_pct">innodb_max_dirty_pages_pct</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_dirty_pages_pct_lwm">innodb_max_dirty_pages_pct_lwm</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_purge_lag">innodb_max_purge_lag</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_purge_lag_delay">innodb_max_purge_lag_delay</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_mirrored_log_groups">innodb_mirrored_log_groups</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_disable">innodb_monitor_disable</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_enable">innodb_monitor_enable</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_reset">innodb_monitor_reset</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_reset_all">innodb_monitor_reset_all</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_num_open_files">Innodb_num_open_files</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_old_blocks_pct">innodb_old_blocks_pct</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_old_blocks_time">innodb_old_blocks_time</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_online_alter_log_max_size">innodb_online_alter_log_max_size</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_open_files">innodb_open_files</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_optimize_fulltext_only">innodb_optimize_fulltext_only</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_os_log_fsyncs">Innodb_os_log_fsyncs</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_os_log_pending_fsyncs">Innodb_os_log_pending_fsyncs</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_os_log_pending_writes">Innodb_os_log_pending_writes</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_os_log_written">Innodb_os_log_written</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size">innodb_page_size</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_page_size">Innodb_page_size</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_pages_created">Innodb_pages_created</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_pages_read">Innodb_pages_read</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_pages_written">Innodb_pages_written</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_print_all_deadlocks">innodb_print_all_deadlocks</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_purge_batch_size">innodb_purge_batch_size</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_purge_threads">innodb_purge_threads</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_random_read_ahead">innodb_random_read_ahead</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_read_ahead_threshold">innodb_read_ahead_threshold</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_read_io_threads">innodb_read_io_threads</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_read_only">innodb_read_only</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_replication_delay">innodb_replication_delay</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_rollback_on_timeout">innodb_rollback_on_timeout</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_rollback_segments">innodb_rollback_segments</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_row_lock_current_waits">Innodb_row_lock_current_waits</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_row_lock_time">Innodb_row_lock_time</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_row_lock_time_avg">Innodb_row_lock_time_avg</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_row_lock_time_max">Innodb_row_lock_time_max</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_row_lock_waits">Innodb_row_lock_waits</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_rows_deleted">Innodb_rows_deleted</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_rows_inserted">Innodb_rows_inserted</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_rows_read">Innodb_rows_read</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_rows_updated">Innodb_rows_updated</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_sort_buffer_size">innodb_sort_buffer_size</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_spin_wait_delay">innodb_spin_wait_delay</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_auto_recalc">innodb_stats_auto_recalc</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_method">innodb_stats_method</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_on_metadata">innodb_stats_on_metadata</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent">innodb_stats_persistent</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent_sample_pages">innodb_stats_persistent_sample_pages</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_sample_pages">innodb_stats_sample_pages</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_transient_sample_pages">innodb_stats_transient_sample_pages</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#option_mysqld_innodb-status-file">innodb-status-file</a></td><td>はい</td><td>はい</td><td> </td><td> </td><td> </td><td> </td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_status_output">innodb_status_output</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_status_output_locks">innodb_status_output_locks</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_strict_mode">innodb_strict_mode</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>両方</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_support_xa">innodb_support_xa</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>両方</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_sync_array_size">innodb_sync_array_size</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_sync_spin_loops">innodb_sync_spin_loops</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_table_locks">innodb_table_locks</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>両方</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_thread_concurrency">innodb_thread_concurrency</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_thread_sleep_delay">innodb_thread_sleep_delay</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#statvar_Innodb_truncated_status_writes">Innodb_truncated_status_writes</a></td><td> </td><td> </td><td> </td><td>はい</td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_directory">innodb_undo_directory</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_logs">innodb_undo_logs</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_tablespaces">innodb_undo_tablespaces</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_use_native_aio">innodb_use_native_aio</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_use_sys_malloc">innodb_use_sys_malloc</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_version">innodb_version</a></td><td> </td><td> </td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_write_io_threads">innodb_write_io_threads</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#sysvar_timed_mutexes">timed_mutexes</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#sysvar_unique_checks">unique_checks</a></td><td> </td><td> </td><td>はい</td><td> </td><td>両方</td><td>はい</td></tr></tbody></table></div></div><br class="table-break"><h3><a name="idm139979069965184"></a>InnoDB コマンドオプション</h3><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="option_mysqld_ignore-builtin-innodb"></a>
          <a class="indexterm" name="idm139979069963328"></a> <a class="indexterm" name="idm139979069961088"></a> <code class="option">--ignore-builtin-innodb</code>
        </p><div class="informaltable"><table summary="Options for ignore-builtin-innodb" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>非推奨</strong></span></td><td colspan="3">5.5.22</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--ignore-builtin-innodb</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_ignore_builtin_innodb">ignore_builtin_innodb</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr></tbody></table></div><p>
          MySQL 5.1 では、このオプションを使用すると、サーバーは組み込み <code class="literal">InnoDB</code> が存在しない場合と同様に動作し、代わりに <code class="literal">InnoDB Plugin</code> を使用できました。MySQL 5.6 では、<code class="literal">InnoDB</code> がデフォルトのストレージエンジンとなり、<code class="literal">InnoDB Plugin</code> は使用されないため、このオプションは無効です。MySQL 5.6.5 の時点では、無視されます。
        </p></li><li class="listitem"><p><a name="option_mysqld_innodb"></a>
          <a class="indexterm" name="idm139979069934816"></a> <a class="indexterm" name="idm139979069932672"></a> <code class="option">--innodb[=<em class="replaceable"><code>value</code></em>]</code>
        </p><div class="informaltable"><table summary="Options for innodb" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>非推奨</strong></span></td><td colspan="3">5.6.21</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb[=value]</code></td></tr><tr><td scope="row" rowspan="5"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">列挙</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">ON</code></td></tr><tr><td scope="row" rowspan="3" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">ON</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">FORCE</code></td></tr></tbody></table></div><p>
          サーバーが <code class="literal">InnoDB</code> サポートでコンパイルされた場合に、<code class="literal">InnoDB</code> ストレージエンジンのロードを制御します。このオプションの形式はトライステートであり、指定可能な値は <code class="literal">OFF</code>、<code class="literal">ON</code>、または <code class="literal">FORCE</code> です。<a class="xref" href="server-administration.html#server-plugin-loading" title="5.1.8.1 プラグインのインストールおよびアンインストール">セクション5.1.8.1「プラグインのインストールおよびアンインストール」</a>を参照してください。
        </p><p>
          <code class="literal">InnoDB</code> を無効にするには、<code class="option">--innodb=OFF</code> または <code class="option">--skip-innodb</code> を使用します。この場合、デフォルトのストレージエンジンは <code class="literal">InnoDB</code> であるため、<code class="option">--default-storage-engine</code> および <code class="option">--default-tmp-storage-engine</code> を使用して、永続テーブルと <code class="literal">TEMPORARY</code> テーブルの両方についてデフォルトを別のエンジンに設定しないかぎりサーバーは開始しません。
        </p><p>
          MySQL 5.6.21 の時点では、<code class="option">--innodb=OFF</code> および <code class="option">--skip-innodb</code> オプションが非推奨となり、使用すると警告が発生します。これらのオプションは、今後の MySQL リリースで削除されます。
        </p></li><li class="listitem"><p><a name="option_mysqld_innodb-status-file"></a>
          <a class="indexterm" name="idm139979069895088"></a> <a class="indexterm" name="idm139979069892928"></a> <code class="option">--innodb-status-file</code>
        </p><div class="informaltable"><table summary="Options for innodb-status-file" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb-status-file</code></td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> が MySQL データディレクトリに <code class="filename">innodb_status.<em class="replaceable"><code>pid</code></em></code> という名前のファイルを作成するかどうかを制御します。有効にすると、<code class="literal">InnoDB</code> は定期的に <code class="literal">SHOW ENGINE INNODB STATUS</code> の出力をこのファイルに書き込みます。
        </p><p>
          このファイルはデフォルトでは作成されません。これを作成するには、<code class="option">--innodb-status-file=1</code> オプションを付けて <span class="command"><strong>mysqld</strong></span> を起動します。このファイルは、通常のシャットダウン中に削除されます。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979069870944"></a> <a class="indexterm" name="idm139979069868752"></a> <code class="option">--skip-innodb</code>
        </p><p>
          <code class="literal">InnoDB</code> ストレージエンジンを無効にします。<code class="option">--innodb</code> の説明を参照してください。
        </p></li></ul></div><h3><a name="idm139979069863328"></a>InnoDB システム変数</h3><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="sysvar_daemon_memcached_enable_binlog"></a>
          <a class="indexterm" name="idm139979069861424"></a> <code class="literal">daemon_memcached_enable_binlog</code>
        </p><div class="informaltable"><table summary="Options for daemon_memcached_enable_binlog" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.6</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--daemon_memcached_enable_binlog=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_enable_binlog">daemon_memcached_enable_binlog</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">false</code></td></tr></tbody></table></div><p></p><p>
          このオプションの使用法の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-memcached" title="14.18 InnoDB と memcached の統合">セクション14.18「InnoDB と memcached の統合」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_daemon_memcached_engine_lib_name"></a>
          <a class="indexterm" name="idm139979069835552"></a> <code class="literal">daemon_memcached_engine_lib_name</code>
        </p><div class="informaltable"><table summary="Options for daemon_memcached_engine_lib_name" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.6</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--daemon_memcached_engine_lib_name=library</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_engine_lib_name">daemon_memcached_engine_lib_name</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ファイル名</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">innodb_engine.so</code></td></tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインを実装する共有ライブラリを指定します。
        </p><p>
          このオプションの使用法の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-memcached" title="14.18 InnoDB と memcached の統合">セクション14.18「InnoDB と memcached の統合」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_daemon_memcached_engine_lib_path"></a>
          <a class="indexterm" name="idm139979069808016"></a> <code class="literal">daemon_memcached_engine_lib_path</code>
        </p><div class="informaltable"><table summary="Options for daemon_memcached_engine_lib_path" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.6</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--daemon_memcached_engine_lib_path=directory</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_engine_lib_path">daemon_memcached_engine_lib_path</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ディレクトリ名</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">NULL</code></td></tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインを実装する共有ライブラリを含むディレクトリのパスです。デフォルト値は、MySQL プラグインディレクトリを表す NULL です。MySQL プラグインディレクトリの外部に配置されている別のストレージエンジンの <code class="literal">memcached</code> プラグインを指定していなければ、このパラメータを変更する必要はないはずです。
        </p><p>
          このオプションの使用法の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-memcached" title="14.18 InnoDB と memcached の統合">セクション14.18「InnoDB と memcached の統合」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_daemon_memcached_option"></a>
          <a class="indexterm" name="idm139979069779088"></a> <code class="literal">daemon_memcached_option</code>
        </p><div class="informaltable"><table summary="Options for daemon_memcached_option" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.6</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--daemon_memcached_option=options</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_option">daemon_memcached_option</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal"></code></td></tr></tbody></table></div><p>
          起動時に、空白文字で区切られた memcached オプションをベースとなる <span class="command"><strong>memcached</strong></span> メモリーオブジェクトのキャッシュデーモンに渡すために使用されます。たとえば、<span class="command"><strong>memcached</strong></span> が待機するポートを変更したり、同時接続の最大数を削減したり、鍵と値のペアの最大メモリーサイズを変更したり、エラーログに関するメッセージのデバッグを有効にしたりします。
        </p><p>
          このオプションの使用法の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-memcached" title="14.18 InnoDB と memcached の統合">セクション14.18「InnoDB と memcached の統合」</a>を参照してください。memcached のオプションについては、memcached のマニュアルページを参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_daemon_memcached_r_batch_size"></a>
          <a class="indexterm" name="idm139979069750864"></a> <code class="literal">daemon_memcached_r_batch_size</code>
        </p><div class="informaltable"><table summary="Options for daemon_memcached_r_batch_size" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.6</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--daemon_memcached_r_batch_size=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_r_batch_size">daemon_memcached_r_batch_size</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr></tbody></table></div><p>
          <code class="literal">COMMIT</code> を実行して新しいトランザクションを開始する前に、実行される <span class="command"><strong>memcached</strong></span> 読み取り操作 (<code class="literal">get</code>) の数を指定します。<code class="literal">daemon_memcached_w_batch_size</code> の対の片方です。
        </p><p>
          この値は、SQL ステートメントを使用してテーブルに行われた変更がすぐに <span class="command"><strong>memcached</strong></span> 操作に表示されるように、デフォルトで 1 に設定されています。ベースとなるテーブルが <span class="command"><strong>memcached</strong></span> インタフェースからのみアクセスされているシステム上で、頻繁なコミットによるオーバーヘッドを削減するために、これを大きくすることがあります。大きすぎる値を設定すると、Undo データまたは Redo データの量によっては、長時間実行されるトランザクションの場合と同様に、一部のストレージでオーバーヘッドが発生する可能性があります。
        </p><p>
          このオプションの使用法の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-memcached" title="14.18 InnoDB と memcached の統合">セクション14.18「InnoDB と memcached の統合」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_daemon_memcached_w_batch_size"></a>
          <a class="indexterm" name="idm139979069718416"></a> <code class="literal">daemon_memcached_w_batch_size</code>
        </p><div class="informaltable"><table summary="Options for daemon_memcached_w_batch_size" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.6</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--daemon_memcached_w_batch_size=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_daemon_memcached_w_batch_size">daemon_memcached_w_batch_size</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr></tbody></table></div><p>
          <code class="literal">COMMIT</code> を実行して新しいトランザクションを開始する前に、実行される <span class="command"><strong>memcached</strong></span> 書き込み操作 (<code class="literal">add</code>、<code class="literal">set</code>、<code class="literal">incr</code> など) の数を指定します。<code class="literal">daemon_memcached_r_batch_size</code> の対の一方です。
        </p><p>
          この値は、格納されるデータはすべて停止に備えて保持しておくことが重要であり、すぐにコミットされるべきであるという仮定に基づいて、デフォルトで 1 に設定されています。クリティカルでないデータを格納するときは、頻繁なコミットによるオーバーヘッドを削減するために、この値を大きくすることがあります。ただし、クラッシュ時に、コミットされていない最後の <em class="replaceable"><code>N</code></em>-1 回の書き込み操作が失われる可能性があります。
        </p><p>
          このオプションの使用法の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-memcached" title="14.18 InnoDB と memcached の統合">セクション14.18「InnoDB と memcached の統合」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_ignore_builtin_innodb"></a>
          <a class="indexterm" name="idm139979069685792"></a> <a class="indexterm" name="idm139979069684272"></a> <code class="literal">ignore_builtin_innodb</code>
        </p><div class="informaltable"><table summary="Options for ignore-builtin-innodb" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>非推奨</strong></span></td><td colspan="3">5.5.22</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--ignore-builtin-innodb</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_ignore_builtin_innodb">ignore_builtin_innodb</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr></tbody></table></div><p>
          このセクションの前半の <span class="quote">「<span class="quote"><code class="literal">InnoDB</code> コマンドオプション</span>」</span>の下にある <code class="option">--ignore-builtin-innodb</code> の説明を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_adaptive_flushing"></a>
          <a class="indexterm" name="idm139979069659344"></a> <a class="indexterm" name="idm139979069657792"></a> <code class="literal">innodb_adaptive_flushing</code>
        </p><div class="informaltable"><table summary="Options for innodb_adaptive_flushing" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_adaptive_flushing=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_flushing">innodb_adaptive_flushing</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">ON</code></td></tr></tbody></table></div><a class="indexterm" name="idm139979069635952"></a><p>
          ワークロードに基づいて、<code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>内の<a class="link" href="glossary.html#glos_dirty_page" title="ダーティーページ">ダーティーページ</a>をフラッシュする比率を動的に調整するかどうかを指定します。フラッシュ比率を動的に調整する目的は、I/O アクティビティーのバーストを回避することです。この設定はデフォルトで有効になっています。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-adaptive_flushing" title="14.13.1.2 InnoDB バッファープールのフラッシュの頻度の構成">セクション14.13.1.2「InnoDB バッファープールのフラッシュの頻度の構成」</a>を参照してください。一般的な I/O チューニングのアドバイスについては、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.7 InnoDB ディスク I/O の最適化">セクション8.5.7「InnoDB ディスク I/O の最適化」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_adaptive_flushing_lwm"></a>
          <a class="indexterm" name="idm139979069628704"></a> <code class="literal">innodb_adaptive_flushing_lwm</code>
        </p><div class="informaltable"><table summary="Options for innodb_adaptive_flushing_lwm" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.6</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_adaptive_flushing_lwm=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_flushing_lwm">innodb_adaptive_flushing_lwm</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">10</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">70</code></td></tr></tbody></table></div><p>
          <a class="link" href="glossary.html#glos_adaptive_flushing" title="適応型フラッシュ">適応型フラッシュ</a>が有効になっている <a class="link" href="glossary.html#glos_redo_log" title="Redo ログ">Redo ログ</a>容量の割合を表す低位境界値です。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_adaptive_hash_index"></a>
          <a class="indexterm" name="idm139979069597808"></a> <a class="indexterm" name="idm139979069596336"></a> <code class="literal">innodb_adaptive_hash_index</code>
        </p><div class="informaltable"><table summary="Options for innodb_adaptive_hash_index" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_adaptive_hash_index=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_hash_index">innodb_adaptive_hash_index</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">ON</code></td></tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_adaptive_hash_index" title="適応型ハッシュインデックス">適応型ハッシュインデックス</a>が有効と無効のどちらになっているのかを示します。ワークロードに応じて、<a class="link" href="glossary.html#glos_adaptive_hash_index" title="適応型ハッシュインデックス">適応型ハッシュインデックスの作成</a>を動的に有効または無効にして、クエリーのパフォーマンスを改善することが望ましい場合があります。適応型ハッシュインデックスがすべてのワークロードに役立つとは限らないため、現実的なワークロードを使用して、有効と無効の両方でベンチマークを実施してください。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-adaptive-hash" title="14.2.13.6 適応型ハッシュインデックス">セクション14.2.13.6「適応型ハッシュインデックス」</a>を参照してください。
        </p><p>
          この変数はデフォルトで有効になっています。<code class="literal">SET GLOBAL</code> ステートメントを使用すると、サーバーを再起動せずに、このパラメータを変更できます。この設定を変更するには、<code class="literal">SUPER</code> 権限が必要です。また、サーバーの起動時に <code class="option">--skip-innodb_adaptive_hash_index</code> を使用すると、無効にすることができます。
        </p><p>
          適応型ハッシュインデックスを無効にすると、すぐにハッシュテーブルが空になります。ハッシュテーブルが空になっても通常の操作は続行でき、ハッシュテーブルを使用していた実行中のクエリーは、代わりにインデックスの B ツリーに直接アクセスします。適応型ハッシュインデックスを再度有効にすると、通常の操作時にハッシュテーブルが再度移入されます。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_adaptive_max_sleep_delay"></a>
          <a class="indexterm" name="idm139979069564848"></a> <code class="literal">innodb_adaptive_max_sleep_delay</code>
        </p><div class="informaltable"><table summary="Options for innodb_adaptive_max_sleep_delay" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.3</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_adaptive_max_sleep_delay=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_adaptive_max_sleep_delay">innodb_adaptive_max_sleep_delay</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">150000</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">1000000</code></td></tr></tbody></table></div><p>
          現在のワークロードに応じて、<code class="literal">InnoDB</code> によって自動的に <code class="literal">innodb_thread_sleep_delay</code> の値が上下に調整されるようにします。ゼロ以外の値に指定すると、最大で <code class="literal">innodb_adaptive_max_sleep_delay</code> オプションで指定された最大値まで、自動的に <code class="literal">innodb_thread_sleep_delay</code> 値の動的な調整が行われます。値はマイクロ秒数を表しています。このオプションは、<code class="literal">InnoDB</code> スレッド数が 16 個を上回る高負荷のシステムで役立つことがあります。(実際には、同時接続数が数百または数千になる MySQL システムの大部分の変数です。)
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-thread_concurrency" title="14.13.5 InnoDB のスレッド並列性の構成">セクション14.13.5「InnoDB のスレッド並列性の構成」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_additional_mem_pool_size"></a>
          <a class="indexterm" name="idm139979069529152"></a> <a class="indexterm" name="idm139979069527680"></a> <code class="literal">innodb_additional_mem_pool_size</code>
        </p><div class="informaltable"><table summary="Options for innodb_additional_mem_pool_size" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>非推奨</strong></span></td><td colspan="3">5.6.3</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_additional_mem_pool_size=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_additional_mem_pool_size">innodb_additional_mem_pool_size</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">8388608</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">2097152</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">4294967295</code></td></tr></tbody></table></div><p>
          <a class="link" href="glossary.html#glos_data_dictionary" title="データディクショナリ">データディクショナリ</a>情報およびその他の内部データ構造を格納する際に <code class="literal">InnoDB</code> で使用されるメモリープールのサイズ (バイト単位) です。アプリケーションに存在するテーブル数が多いほど、ここで割り当てるメモリー量も多くなります。このプール内のメモリーが <code class="literal">InnoDB</code> によって使い果たされると、オペレーティングシステムからのメモリーの割り当てが開始され、MySQL エラーログに警告メッセージが書き込まれます。デフォルトの値は 8M バイトです。
        </p><p>
          この変数は、<code class="literal">InnoDB</code> の内部メモリーアロケータに関連します。これは、<code class="literal">innodb_use_sys_malloc</code> が有効になっている場合は使用されません。MySQL 5.6.3 の時点では、<code class="literal">innodb_additional_mem_pool_size</code> は非推奨となり、今後の MySQL リリースで削除される予定です。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_api_bk_commit_interval"></a>
          <a class="indexterm" name="idm139979069491120"></a> <code class="literal">innodb_api_bk_commit_interval</code>
        </p><div class="informaltable"><table summary="Options for innodb_api_bk_commit_interval" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.7</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_api_bk_commit_interval=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_bk_commit_interval">innodb_api_bk_commit_interval</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">5</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">1073741824 </code></td></tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> インタフェースが使用されるアイドル状態の接続が自動コミットされる頻度 (秒単位) です。このオプションの使用法の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-memcached" title="14.18 InnoDB と memcached の統合">セクション14.18「InnoDB と memcached の統合」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_api_disable_rowlock"></a>
          <a class="indexterm" name="idm139979069459536"></a> <code class="literal">innodb_api_disable_rowlock</code>
        </p><div class="informaltable"><table summary="Options for innodb_api_disable_rowlock" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.6</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_api_disable_rowlock=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_disable_rowlock">innodb_api_disable_rowlock</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr></tbody></table></div><p>
          この変数を使用すると、<code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> で DML 操作が実行されるときに、行ロックが無効になります。デフォルトでは、<code class="literal">innodb_api_disable_rowlock</code> は <code class="literal">OFF</code> に設定されており、<span class="command"><strong>memcached</strong></span> が get および set 操作の行ロックをリクエストします。<code class="literal">innodb_api_disable_rowlock</code> を <code class="literal">ON</code> に設定すると、<span class="command"><strong>memcached</strong></span> は行ロックの代わりに、テーブルロックをリクエストします。
        </p><p>
          <code class="literal">innodb_api_disable_rowlock</code> オプションは動的ではありません。これは <span class="command"><strong>mysqld</strong></span> コマンド行で指定するか、または MySQL 構成ファイルに入力する必要があります。構成は、MySQL サーバーが起動されるたびに行うプラグインのインストール時に有効になります。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_api_enable_binlog"></a>
          <a class="indexterm" name="idm139979069426096"></a> <code class="literal">innodb_api_enable_binlog</code>
        </p><div class="informaltable"><table summary="Options for innodb_api_enable_binlog" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.6</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_api_enable_binlog=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_enable_binlog">innodb_api_enable_binlog</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr></tbody></table></div><p>
          MySQL <a class="link" href="glossary.html#glos_binary_log" title="バイナリログ">バイナリログ</a>とともに、<code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインを使用できます。このオプションの使用法の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-memcached" title="14.18 InnoDB と memcached の統合">セクション14.18「InnoDB と memcached の統合」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_api_enable_mdl"></a>
          <a class="indexterm" name="idm139979069398080"></a> <code class="literal">innodb_api_enable_mdl</code>
        </p><div class="informaltable"><table summary="Options for innodb_api_enable_mdl" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.6</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_api_enable_mdl=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_enable_mdl">innodb_api_enable_mdl</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインで使用されるテーブルをロックします。これにより、SQL インタフェースから <a class="link" href="glossary.html#glos_ddl" title="DDL">DDL</a> によって削除または変更できなくなります。このオプションの使用法の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-memcached" title="14.18 InnoDB と memcached の統合">セクション14.18「InnoDB と memcached の統合」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_api_trx_level"></a>
          <a class="indexterm" name="idm139979069370096"></a> <code class="literal">innodb_api_trx_level</code>
        </p><div class="informaltable"><table summary="Options for innodb_api_trx_level" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.6</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_api_trx_level=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_api_trx_level">innodb_api_trx_level</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr></tbody></table></div><p>
          <span class="command"><strong>memcached</strong></span> インタフェースで処理されたクエリー上のトランザクション<a class="link" href="glossary.html#glos_isolation_level" title="分離レベル">分離レベル</a>を制御できます。このオプションの使用法の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-memcached" title="14.18 InnoDB と memcached の統合">セクション14.18「InnoDB と memcached の統合」</a>を参照してください。よく聞く名前に対応する定数は、次のとおりです。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              0 = <code class="literal">READ UNCOMMITTED</code>
            </p></li><li class="listitem"><p>
              1 = <code class="literal">READ COMMITTED</code>
            </p></li><li class="listitem"><p>
              2 = <code class="literal">REPEATABLE READ</code>
            </p></li><li class="listitem"><p>
              3 = <code class="literal">SERIALIZABLE</code>
            </p></li></ul></div></li><li class="listitem"><p><a name="sysvar_innodb_autoextend_increment"></a>
          <a class="indexterm" name="idm139979069335520"></a> <a class="indexterm" name="idm139979069334064"></a> <code class="literal">innodb_autoextend_increment</code>
        </p><div class="informaltable"><table summary="Options for innodb_autoextend_increment" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_autoextend_increment=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoextend_increment">innodb_autoextend_increment</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (&lt;= 5.6.5)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">8</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">1000</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (&gt;= 5.6.6)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">64</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">1000</code></td></tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> の自動拡張<a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">システムテーブルスペース</a>ファイルがいっぱいになったときに、そのサイズを拡張する際の増分サイズ (M バイト単位) です。デフォルト値は、MySQL 5.6.6 の時点では 64、それよりも前では 8 です。この変数によって、<code class="literal">innodb_file_per_table=1</code> を使用した場合に作成されるテーブルごとのテーブルスペースファイルは影響を受けません。<code class="literal">innodb_autoextend_increment</code> の値には関係なく、これらのファイルは自動拡張されます。拡張は少量で始まり、その後の拡張は増分が 4MB で発生します。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_autoinc_lock_mode"></a>
          <a class="indexterm" name="idm139979069291408"></a> <a class="indexterm" name="idm139979069289856"></a> <code class="literal">innodb_autoinc_lock_mode</code>
        </p><div class="informaltable"><table summary="Options for innodb_autoinc_lock_mode" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_autoinc_lock_mode=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_autoinc_lock_mode">innodb_autoinc_lock_mode</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="5"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row" rowspan="3" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">2</code></td></tr></tbody></table></div><p>
          <a class="link" href="glossary.html#glos_auto_increment" title="自動インクリメント">自動インクリメント</a>値を生成する際に使用される<a class="link" href="glossary.html#glos_lock_mode" title="lock mode">ロックモード</a>です。許可される値は、<span class="quote">「<span class="quote">従来</span>」</span>を表す 0、<span class="quote">「<span class="quote">連続</span>」</span> を表す 1、または <span class="quote">「<span class="quote">インターリーブ</span>」</span> を表す 2 です。<a class="xref" href="innodb-storage-engine.html#innodb-auto-increment-handling" title="14.6.5 InnoDB での AUTO_INCREMENT 処理">セクション14.6.5「InnoDB での AUTO_INCREMENT 処理」</a>では、これらのモードの特性について説明します。
        </p><p>
          この変数のデフォルトは、1 (<span class="quote">「<span class="quote">連続</span>」</span>ロックモード) です。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_buffer_pool_dump_at_shutdown"></a>
          <a class="indexterm" name="idm139979069256064"></a> <code class="literal">innodb_buffer_pool_dump_at_shutdown</code>
        </p><div class="informaltable"><table summary="Options for innodb_buffer_pool_dump_at_shutdown" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.3</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_buffer_pool_dump_at_shutdown=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_dump_at_shutdown">innodb_buffer_pool_dump_at_shutdown</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr></tbody></table></div><p>
          次回再起動時の<a class="link" href="glossary.html#glos_warm_up" title="ウォームアップ">ウォームアップ</a>プロセスの時間を短縮するために、MySQL サーバーのシャットダウン時に、InnoDB の<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>にキャッシュされるページを記録するかどうかを指定します。一般に、<code class="literal">innodb_buffer_pool_load_at_startup</code> と組み合わせて使用されます。
        </p><p>
          関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool" title="14.13.1.5 再起動を高速化するための InnoDB バッファープールのプリロード">セクション14.13.1.5「再起動を高速化するための InnoDB バッファープールのプリロード」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_buffer_pool_dump_now"></a>
          <a class="indexterm" name="idm139979069227056"></a> <code class="literal">innodb_buffer_pool_dump_now</code>
        </p><div class="informaltable"><table summary="Options for innodb_buffer_pool_dump_now" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.3</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_buffer_pool_dump_now=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_dump_now">innodb_buffer_pool_dump_now</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr></tbody></table></div><p>
          InnoDB の<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>にキャッシュされるページをすぐに記録します。一般に、<code class="literal">innodb_buffer_pool_load_now</code> と組み合わせて使用されます。
        </p><p>
          関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool" title="14.13.1.5 再起動を高速化するための InnoDB バッファープールのプリロード">セクション14.13.1.5「再起動を高速化するための InnoDB バッファープールのプリロード」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_buffer_pool_filename"></a>
          <a class="indexterm" name="idm139979069199056"></a> <code class="literal">innodb_buffer_pool_filename</code>
        </p><div class="informaltable"><table summary="Options for innodb_buffer_pool_filename" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.3</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_buffer_pool_filename=file</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_filename">innodb_buffer_pool_filename</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ファイル名</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">ib_buffer_pool</code></td></tr></tbody></table></div><p>
          <code class="literal">innodb_buffer_pool_dump_at_shutdown</code> または <code class="literal">innodb_buffer_pool_dump_now</code> で生成されるテーブルスペース ID およびページ ID のリストを保持するファイルの名前を指定します。テーブルスペース ID およびページ ID は、<code class="literal">space, page_id</code> という形式で保存されます。デフォルトでは、このファイルは <code class="literal">InnoDB</code> データディレクトリに配置されます。
        </p><p>
          関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool" title="14.13.1.5 再起動を高速化するための InnoDB バッファープールのプリロード">セクション14.13.1.5「再起動を高速化するための InnoDB バッファープールのプリロード」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_buffer_pool_instances"></a>
          <a class="indexterm" name="idm139979069169008"></a> <a class="indexterm" name="idm139979069167536"></a> <code class="literal">innodb_buffer_pool_instances</code>
        </p><div class="informaltable"><table summary="Options for innodb_buffer_pool_instances" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_buffer_pool_instances=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_instances">innodb_buffer_pool_instances</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (&lt;= 5.6.5)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">64</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (Windows, 32 ビットプラットフォーム, &gt;= 5.6.6)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">(autosized)</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">64</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (その他, &gt;= 5.6.6)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">8</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">64</code></td></tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>が分割される領域の数です。バッファープールが数 G バイトの範囲にあるシステムでは、バッファープールを個別のインスタンスに分割すると、キャッシュされたページに対して異なるスレッドが読み取りおよび書き込みを行うときの競合が減るため、並列性が向上する場合があります。バッファープールに格納される各ページまたはバッファープールから読み取られる各ページは、ハッシュ関数を使用して、バッファープールインスタンスのいずれかにランダムに割り当てられます。各バッファープールは、独自の空きリスト、<a class="link" href="glossary.html#glos_flush_list" title="フラッシュリスト">フラッシュリスト</a>、<a class="link" href="glossary.html#glos_lru" title="LRU">LRU</a>、およびバッファープールに接続されたその他のすべてのデータ構造を管理し、独自のバッファープール<a class="link" href="glossary.html#glos_mutex" title="相互排他ロック">相互排他ロック</a>によって保護されます。
        </p><p>
          このオプションは、<code class="literal">innodb_buffer_pool_size</code> を 1G バイト以上のサイズに設定した場合にのみ有効になります。指定した合計サイズは、すべてのバッファープール間で分割されます。最高の効率を得るには、<code class="literal">innodb_buffer_pool_instances</code> と <code class="literal">innodb_buffer_pool_size</code> の組み合わせを、各バッファープールインスタンスが少なくとも 1G バイトになるように指定します。
        </p><p>
          MySQL 5.6.6 より前では、デフォルトは 1 です。MySQL 5.6.6 の時点では、デフォルトは 8 です。ただし、32 ビットの Windows システムでは、デフォルトは <code class="literal">innodb_buffer_pool_size</code> の値に依存します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">innodb_buffer_pool_size</code> が 1.3G バイトよりも大きい場合は、<code class="literal">innodb_buffer_pool_instances</code> のデフォルトが <code class="literal">innodb_buffer_pool_size</code>/128M バイトになり、チャンクごとに個別のメモリー割り当てリクエストを持ちます。32 ビット版 Windows で単一のバッファープールで必要となる連続したアドレス空間を割り当てることができないという重大なリスクが存在する境界として、1.3G バイトが選択されました。
            </p></li><li class="listitem"><p>
              それ以外の場合、デフォルトは 1 です。
            </p></li></ul></div></li><li class="listitem"><p><a name="sysvar_innodb_buffer_pool_load_abort"></a>
          <a class="indexterm" name="idm139979069101728"></a> <code class="literal">innodb_buffer_pool_load_abort</code>
        </p><div class="informaltable"><table summary="Options for innodb_buffer_pool_load_abort" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.3</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_buffer_pool_load_abort=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_load_abort">innodb_buffer_pool_load_abort</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr></tbody></table></div><p>
          <code class="literal">innodb_buffer_pool_load_at_startup</code> または <code class="literal">innodb_buffer_pool_load_now</code> でトリガーされる InnoDB の<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>の内容をリストアするプロセスを中断します。
        </p><p>
          関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool" title="14.13.1.5 再起動を高速化するための InnoDB バッファープールのプリロード">セクション14.13.1.5「再起動を高速化するための InnoDB バッファープールのプリロード」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_buffer_pool_load_at_startup"></a>
          <a class="indexterm" name="idm139979069072752"></a> <code class="literal">innodb_buffer_pool_load_at_startup</code>
        </p><div class="informaltable"><table summary="Options for innodb_buffer_pool_load_at_startup" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.3</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_buffer_pool_load_at_startup=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_load_at_startup">innodb_buffer_pool_load_at_startup</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr></tbody></table></div><p>
          MySQL サーバーの起動時に、以前に保持されたときと同じページをロードすることで、InnoDB の<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>が自動的に<a class="link" href="glossary.html#glos_warm_up" title="ウォームアップ">ウォームアップ</a>されるように指定します。一般に、<code class="literal">innodb_buffer_pool_dump_at_shutdown</code> と組み合わせて使用されます。
        </p><p>
          関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool" title="14.13.1.5 再起動を高速化するための InnoDB バッファープールのプリロード">セクション14.13.1.5「再起動を高速化するための InnoDB バッファープールのプリロード」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_buffer_pool_load_now"></a>
          <a class="indexterm" name="idm139979069043680"></a> <code class="literal">innodb_buffer_pool_load_now</code>
        </p><div class="informaltable"><table summary="Options for innodb_buffer_pool_load_now" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.3</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_buffer_pool_load_now=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_load_now">innodb_buffer_pool_load_now</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr></tbody></table></div><p>
          サーバーの再起動を待機せずにデータページのセットをロードすることで、InnoDB の<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>をすぐに<a class="link" href="glossary.html#glos_warm_up" title="ウォームアップ">ウォームアップ</a>します。ベンチマーク時にキャッシュメモリーを既知の状態に戻したり、レポートやメンテナンスのためにクエリーを実行したあとに、MySQL サーバーの通常のワークロードを再開する準備をしたりする際に役立ちます。
        </p><p>
          関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-preload-buffer-pool" title="14.13.1.5 再起動を高速化するための InnoDB バッファープールのプリロード">セクション14.13.1.5「再起動を高速化するための InnoDB バッファープールのプリロード」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_buffer_pool_size"></a>
          <a class="indexterm" name="idm139979069015232"></a> <a class="indexterm" name="idm139979069013680"></a> <code class="literal">innodb_buffer_pool_size</code>
        </p><div class="informaltable"><table summary="Options for innodb_buffer_pool_size" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_buffer_pool_size=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_buffer_pool_size">innodb_buffer_pool_size</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (32 ビットプラットフォーム)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">134217728</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">5242880</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">2**32-1</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (64 ビットプラットフォーム)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">134217728</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">5242880</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">2**64-1</code></td></tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> がテーブルおよびインデックスのデータをキャッシュするメモリー領域である<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>のサイズ (バイト単位) です。デフォルト値は 128M バイトです。最大値は、CPU アーキテクチャーによって異なります。最大値は、32 ビットシステムでは 4294967295 (2<sup>32</sup>-1)、64 ビットシステムでは 18446744073709551615 (2<sup>64</sup>-1) です。32 ビットシステムでは、CPU アーキテクチャーおよびオペレーティングシステムに、指定された最大値よりも小さい実用的な最大サイズが課されている可能性があります。バッファープールのサイズが 1G バイトよりも大きい場合に、<code class="literal">innodb_buffer_pool_instances</code> を 1 よりも大きい値に設定すると、高負荷のサーバーで拡張性を改善できます。
        </p><p>
          この値を大きく設定するほど、テーブル内の同じデータに複数回アクセスするために必要なディスク I/O が少なくなります。専用のデータベースサーバーでは、これを最大でマシンの物理メモリーサイズの 80% まで設定することがあります。次のようなその他の問題が発生した場合は、この値を小さくする準備をしてください。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              物理メモリーが競合すると、オペレーティングシステムでページングが発生する可能性があります。
            </p></li><li class="listitem"><p>
              <code class="literal">InnoDB</code> では、割り当てられた領域の合計が指定されたサイズよりも約 10% 大きくなるように、バッファーおよび制御構造用に追加のメモリーが予約されています。
            </p></li><li class="listitem"><p>
              アドレス空間は隣接しているはすです。これにより、Windows システムで特定のアドレスにロードする DLL に関する問題が発生する可能性があります。
            </p></li><li class="listitem"><p>
              バッファープールを初期化する時間は、ほぼそのサイズに比例しています。大規模なインストールでは、この初期化時間が重要となる場合もあります。たとえば、最新の Linux x86_64 サーバーで 10G バイトのバッファープールを初期化するには、約 6 秒かかります。<a class="xref" href="optimization.html#innodb-buffer-pool" title="8.9.1 InnoDB バッファープール">セクション8.9.1「InnoDB バッファープール」</a>を参照してください。
            </p></li></ul></div></li><li class="listitem"><p><a name="sysvar_innodb_change_buffer_max_size"></a>
          <a class="indexterm" name="idm139979068962800"></a> <code class="literal">innodb_change_buffer_max_size</code>
        </p><div class="informaltable"><table summary="Options for innodb_change_buffer_max_size" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.2</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_change_buffer_max_size=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_change_buffer_max_size">innodb_change_buffer_max_size</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">25</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">50</code></td></tr></tbody></table></div><p>
          <a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>の合計サイズの割合として示した、InnoDB の<a class="link" href="glossary.html#glos_change_buffer" title="変更バッファー">変更バッファー</a>の最大サイズです。この値は、MySQL サーバーで頻繁に挿入、更新、および削除アクティビティーが発生する場合は大きくし、MySQL サーバーでレポート用に使用されるデータが変更されない場合は小さくするとよいでしょう。一般的な I/O チューニングのアドバイスについては、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.7 InnoDB ディスク I/O の最適化">セクション8.5.7「InnoDB ディスク I/O の最適化」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_change_buffering"></a>
          <a class="indexterm" name="idm139979068930512"></a> <a class="indexterm" name="idm139979068928960"></a> <code class="literal">innodb_change_buffering</code>
        </p><div class="informaltable"><table summary="Options for innodb_change_buffering" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_change_buffering=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_change_buffering">innodb_change_buffering</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="8"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">列挙</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">all</code></td></tr><tr><td scope="row" rowspan="6" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">inserts</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">deletes</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">purges</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">changes</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">all</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">none</code></td></tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> が<a class="link" href="glossary.html#glos_change_buffering" title="変更バッファリング">バッファリングの変更</a> (I/O 操作を連続して実行できるように、セカンダリインデックスへの書き込み操作を遅延させる最適化) を実行するかどうかを指定します。許可される値は <code class="literal">inserts</code> (挿入操作のバッファリング)、<code class="literal">deletes</code> (削除操作のバッファリング。厳密に言えば、パージ操作時にあとで削除するインデックスレコードにマークを付ける書き込み)、<code class="literal">changes</code> (挿入操作および削除マーク操作のバッファリング)、<code class="literal">purges</code> (<a class="link" href="glossary.html#glos_purge" title="パージ">パージ</a>操作のバッファリング。削除されたインデックスエントリのガベージコレクションが最終的に実行される書き込み)、<code class="literal">all</code> (挿入、削除マーク、パージ操作のバッファリング)、および <code class="literal">none</code> (操作のバッファリングなし) です。デフォルトは <code class="literal">all</code> です。詳細については、<a class="xref" href="innodb-storage-engine.html#innodb-performance-change_buffering" title="14.13.4 InnoDB 変更バッファリングの構成">セクション14.13.4「InnoDB 変更バッファリングの構成」</a>を参照してください。一般的な I/O チューニングのアドバイスについては、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.7 InnoDB ディスク I/O の最適化">セクション8.5.7「InnoDB ディスク I/O の最適化」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_checksum_algorithm"></a>
          <a class="indexterm" name="idm139979068885584"></a> <code class="literal">innodb_checksum_algorithm</code>
        </p><div class="informaltable"><table summary="Options for innodb_checksum_algorithm" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.3</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_checksum_algorithm=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_checksum_algorithm">innodb_checksum_algorithm</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="8"><span class="bold"><strong>許可されている値</strong></span> (&lt;= 5.6.5)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">列挙</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">innodb</code></td></tr><tr><td scope="row" rowspan="6" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">innodb</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">crc32</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">none</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">strict_innodb</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">strict_crc32</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">strict_none</code></td></tr><tr><td scope="row" rowspan="8"><span class="bold"><strong>許可されている値</strong></span> (5.6.6)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">列挙</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">crc32</code></td></tr><tr><td scope="row" rowspan="6" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">innodb</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">crc32</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">none</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">strict_innodb</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">strict_crc32</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">strict_none</code></td></tr><tr><td scope="row" rowspan="8"><span class="bold"><strong>許可されている値</strong></span> (&gt;= 5.6.7)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">列挙</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">innodb</code></td></tr><tr><td scope="row" rowspan="6" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">innodb</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">crc32</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">none</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">strict_innodb</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">strict_crc32</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">strict_none</code></td></tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> の各<a class="link" href="glossary.html#glos_tablespace" title="テーブルスペース">テーブルスペース</a>の各ディスクブロックに格納されている<a class="link" href="glossary.html#glos_checksum" title="チェックサム">チェックサム</a>を生成および検証する方法を指定します。
        </p><p>
          MySQL 5.6.3 の時点で <code class="literal">innodb_checksums</code> オプションは、<code class="literal">innodb_checksum_algorithm</code> で置き換えられました。次の値は、互換性を保つために提供されています。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">innodb_checksum_algorithm=innodb</code> は <code class="literal">innodb_checksums=ON</code> と同じです。
            </p></li><li class="listitem"><p>
              <code class="literal">innodb_checksum_algorithm=none</code> は <code class="literal">innodb_checksums=OFF</code> と同じです。
            </p></li></ul></div><p>
          競合を回避するには、構成ファイルおよび MySQL 起動スクリプトから <code class="literal">innodb_checksums</code> への参照を削除します。
        </p><p>
          値 <code class="literal">innodb</code> は、すべての MySQL バージョンとの下位互換性があります。値 <code class="literal">crc32</code> では、より高速に、変更されたすべてのブロックのチェックサムを計算し、ディスク読み取りごとにチェックサムをチェックするアルゴリズムが使用されます。値 <code class="literal">none</code> では、ブロックデータに基づいて値が計算されるのではなく、チェックサムフィールドに定数値が書き込まれます。テーブルスペース内のブロックは、古い値、新しい値、およびチェックサムなしの値を混在させて使用でき、データが更新されるにつれ徐々に更新されます。テーブルスペース内のブロックが <code class="literal">crc32</code> アルゴリズムを使用するように変更されたあとは、関連付けられたテーブルを以前のバージョンの MySQL で読み取ることはできません。
        </p><p>
          <code class="literal">strict_*</code> 形式の機能は、<code class="literal">innodb</code>、<code class="literal">crc32</code>、および <code class="literal">none</code> と同じです。ただし、<code class="literal">InnoDB</code> は、同じテーブルスペース内でチェックサム値の混在が発生した場合に停止します。これらのオプションを完全に新しいインスタンスで使用するだけで、はじめてでもすべてのテーブルスペースを設定できます。<code class="literal">strict_*</code> 設定では、ディスクの読み取り時に新しいチェックサム値と古いチェックサム値の両方を受け入れるために、その両方を計算する必要がないため、多少高速になります。
        </p><p>
          次の表には、<code class="literal">none</code>、<code class="literal">innodb</code>、<code class="literal">crc32</code> オプション値、およびそれぞれに対応する <code class="literal">strict_</code> オプション値間の相違点を示します。<code class="literal">none</code>、<code class="literal">innodb</code>、および <code class="literal">crc32</code> では、特定のタイプのチェックサム値が各データブロックに書き込まれますが、互換性を保つために、読み取り操作中にブロックを検証する際に、その他のチェックサム値のいずれかが受け入れられます。<code class="literal">strict_</code> 形式の各パラメータでは、1 種類のチェックサムのみが認識されます。これにより、検証が高速になりますが、インスタンス内のすべての <code class="literal">InnoDB</code> データファイルが同じ <code class="literal">innodb_checksum_algorithm</code> 値で作成される必要があります。
        </p><div class="table"><a name="idm139979068789488"></a><p class="title"><b>表 14.7 innodb_checksum_algorithm で許可される設定</b></p><div class="table-contents"><table summary="innodb_checksum_algorithm で許可される設定" border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">値</th><th scope="col">生成されるチェックサム (書き込み時)</th><th scope="col">許可されるチェックサム (読み取り時)</th></tr></thead><tbody><tr><td scope="row">none</td><td>定数。</td><td><code class="literal">none</code>、<code class="literal">innodb</code>、または <code class="literal">crc32</code> で生成されるチェックサムのいずれか。</td></tr><tr><td scope="row">innodb</td><td>ソフトウェアで <code class="literal">InnoDB</code> の元のアルゴリズムを使用して計算されたチェックサム。</td><td><code class="literal">none</code>、<code class="literal">innodb</code>、または <code class="literal">crc32</code> で生成されるチェックサムのいずれか。</td></tr><tr><td scope="row">crc32</td><td><code class="literal">crc32</code> アルゴリズムを使用して計算されたチェックサム (ハードウェアの支援を得て実行される可能性もあります)。</td><td><code class="literal">none</code>、<code class="literal">innodb</code>、または <code class="literal">crc32</code> で生成されるチェックサムのいずれか。</td></tr><tr><td scope="row">strict_none</td><td>定数</td><td><code class="literal">none</code> で生成されるチェックサムのみ。</td></tr><tr><td scope="row">strict_innodb</td><td>ソフトウェアで <code class="literal">InnoDB</code> の元のアルゴリズムを使用して計算されたチェックサム。</td><td><code class="literal">innodb</code> で生成されるチェックサムのみ。</td></tr><tr><td scope="row">strict_crc32</td><td><code class="literal">crc32</code> アルゴリズムを使用して計算されたチェックサム (ハードウェアの支援を得て実行される可能性もあります)。</td><td><code class="literal">crc32</code> で生成されるチェックサムのみ。</td></tr></tbody></table></div></div><br class="table-break"><p>
          <code class="literal">innodb_checksum_algorithm</code> のデフォルト値は MySQL 5.6.6 で <code class="literal">innodb</code> から <code class="literal">crc32</code> に変更されましたが、以前の MySQL バージョンへのダウングレード中の <code class="literal">InnoDB</code> データファイルの互換性向上のため、および <a class="link" href="mysql-enterprise.html#mysql-enterprise-backup" title="25.2 MySQL Enterprise Backup">MySQL Enterprise Backup</a> で使用するために 5.6.7 で <code class="literal">innodb</code> に戻されました。検出された制限には、次のものが含まれます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              CRC32 チェックサムを含む <code class="literal">.ibd</code> ファイルは、5.6.3 より前の MySQL バージョンへのダウングレード中に問題が発生する可能性があります。MySQL 5.6.3 以降では、ディスクからブロックを読み取るとき、そのブロックの新しいチェックサム値と古いチェックサム値のどちらも正しいとして認識します。それにより、アルゴリズムの設定には関係なく、アップグレードおよびダウングレード中にそのデータブロックの互換性を保証します。新しいチェックサム値で書き込まれたデータが 5.6.3 より前のレベルの MySQL によって処理された場合は、破損しているとしてレポートされる可能性があります。
            </p></li><li class="listitem"><p>
              3.8.0 までのバージョンの <a class="link" href="mysql-enterprise.html#mysql-enterprise-backup" title="25.2 MySQL Enterprise Backup">MySQL Enterprise Backup</a> は、CRC32 チェックサムを使用するテーブルスペースのバックアップをサポートしていません。<a class="link" href="mysql-enterprise.html#mysql-enterprise-backup" title="25.2 MySQL Enterprise Backup">MySQL Enterprise Backup</a> は、CRC32 チェックサムのサポートを 3.8.1 で (いくつかの制限付きで) 追加しています。詳細は、<a class="link" href="mysql-enterprise.html#mysql-enterprise-backup" title="25.2 MySQL Enterprise Backup">MySQL Enterprise Backup</a> 3.8.1 の変更履歴を参照してください。
            </p></li></ul></div><p>
          <code class="literal">crc32</code> チェックサムアルゴリズムに関する追加情報については、<a class="xref" href="innodb-storage-engine.html#innodb-crc32-checksum" title="14.13.15 チェックサムの高速化のための CRC32 チェックサムアルゴリズムの使用">セクション14.13.15「チェックサムの高速化のための CRC32 チェックサムアルゴリズムの使用」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_checksums"></a>
          <a class="indexterm" name="idm139979068746560"></a> <a class="indexterm" name="idm139979068745056"></a> <code class="literal">innodb_checksums</code>
        </p><div class="informaltable"><table summary="Options for innodb_checksums" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>非推奨</strong></span></td><td colspan="3">5.6.3</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_checksums</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_checksums">innodb_checksums</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">ON</code></td></tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> では、ディスクから読み取られるすべてのテーブルスペースページ上で<a class="link" href="glossary.html#glos_checksum" title="チェックサム">チェックサム</a>検証を使用することで、ハードウェアの障害やデータファイルの破損に対する追加のフォールトトレランスを実現できます。この検証はデフォルトで有効になっています。特殊な状況 (ベンチマークの実行時など) では、このような追加の安全機能は <code class="option">--skip-innodb-checksums</code> を使用して無効にすることができます。<code class="literal">innodb_checksum_algorithm</code> を使用すると、チェックサムを計算する方法を指定できます。
        </p><p>
          MySQL 5.6.3 以降では、このオプションは非推奨となり、<code class="literal">innodb_checksum_algorithm</code> で置き換えられました。<code class="literal">innodb_checksum_algorithm=innodb</code> は <code class="literal">innodb_checksums=ON</code> (デフォルト) と同じです。<code class="literal">innodb_checksum_algorithm=none</code> は <code class="literal">innodb_checksums=OFF</code> と同じです。<code class="literal">innodb_checksum_algorithm</code> との競合を回避するために、構成ファイルおよび起動スクリプトからすべての <code class="literal">innodb_checksums</code> オプションを削除してください。<code class="literal">innodb_checksums=OFF</code> によって自動的に <code class="literal">innodb_checksum_algorithm=none</code> が設定され、<code class="literal">innodb_checksums=ON</code> は無視され、<code class="literal">innodb_checksum_algorithm</code> のその他の設定でオーバーライドされます。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_cmp_per_index_enabled"></a>
          <a class="indexterm" name="idm139979068706352"></a> <code class="literal">innodb_cmp_per_index_enabled</code>
        </p><div class="informaltable"><table summary="Options for innodb_cmp_per_index_enabled" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.7</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_cmp_per_index_enabled=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_cmp_per_index_enabled">innodb_cmp_per_index_enabled</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr><tr><td scope="row" rowspan="2" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">ON</code></td></tr></tbody></table></div><p>
          <code class="literal">INFORMATION_SCHEMA.INNODB_CMP_PER_INDEX</code> テーブルでインデックスごとの圧縮関連の統計を有効にします。これらの統計を収集すると負荷が高くなるため、このオプションは、<code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_compression" title="圧縮">圧縮済み</a>テーブルに関連するパフォーマンスチューニング時に開発、テスト、またはスレーブのインスタンス上でのみ有効にしてください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_commit_concurrency"></a>
          <a class="indexterm" name="idm139979068674544"></a> <a class="indexterm" name="idm139979068673088"></a> <a class="indexterm" name="idm139979068671056"></a> <code class="literal">innodb_commit_concurrency</code>
        </p><div class="informaltable"><table summary="Options for innodb_commit_concurrency" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_commit_concurrency=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_commit_concurrency">innodb_commit_concurrency</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">1000</code></td></tr></tbody></table></div><p>
          同時に<a class="link" href="glossary.html#glos_commit" title="コミット">コミット</a>できる<a class="link" href="glossary.html#glos_thread" title="スレッド">スレッド</a>の数です。値を 0 (デフォルト) にすると、任意の数の<a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a>を同時にコミットすることが許可されます。
        </p><p>
          <code class="literal">innodb_commit_concurrency</code> の値は、実行時にゼロからゼロ以外 (またはその逆) に変更できません。ゼロ以外の値から別のゼロ以外の値に変更することはできます。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_compression_failure_threshold_pct"></a>
          <a class="indexterm" name="idm139979068637936"></a> <code class="literal">innodb_compression_failure_threshold_pct</code>
        </p><div class="informaltable"><table summary="Options for innodb_compression_failure_threshold_pct" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.7</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_compression_failure_threshold_pct=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_compression_failure_threshold_pct">innodb_compression_failure_threshold_pct</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">5</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">100</code></td></tr></tbody></table></div><p>
          高負荷での<a class="link" href="glossary.html#glos_compression_failure" title="圧縮失敗">圧縮の失敗</a>を回避するために、<a class="link" href="glossary.html#glos_compression" title="圧縮">圧縮された</a>ページ内のパディングの追加が MySQL で開始されるカットオフポイントを設定します。値をゼロにすると、圧縮の効率性をモニターするメカニズムが無効になり、パディングの量が動的に調整されます。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_compression_level"></a>
          <a class="indexterm" name="idm139979068606640"></a> <code class="literal">innodb_compression_level</code>
        </p><div class="informaltable"><table summary="Options for innodb_compression_level" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.7</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_compression_level=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_compression_level">innodb_compression_level</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">6</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">9</code></td></tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_compression" title="圧縮">圧縮された</a>テーブルおよびインデックスで使用される zlib 圧縮のレベルを指定します。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_compression_pad_pct_max"></a>
          <a class="indexterm" name="idm139979068575888"></a> <code class="literal">innodb_compression_pad_pct_max</code>
        </p><div class="informaltable"><table summary="Options for innodb_compression_pad_pct_max" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.7</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_compression_pad_pct_max=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_compression_pad_pct_max">innodb_compression_pad_pct_max</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">50</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">75</code></td></tr></tbody></table></div><p>
          圧縮された各<a class="link" href="glossary.html#glos_page" title="ページ">ページ</a>内の空き領域として予約できる最大の割合を指定します。これにより、<a class="link" href="glossary.html#glos_compression" title="圧縮">圧縮された</a>テーブルまたはインデックスが更新され、データが再度圧縮される可能性があるときに、ページ内のデータおよび変更ログを再編成する余地が得られます。<code class="literal">innodb_compression_failure_threshold_pct</code> がゼロ以外の値に設定され、<a class="link" href="glossary.html#glos_compression_failure" title="圧縮失敗">圧縮エラー</a>の比率がカットオフポイントを超えたときにのみ適用されます。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_concurrency_tickets"></a>
          <a class="indexterm" name="idm139979068542688"></a> <a class="indexterm" name="idm139979068541232"></a> <a class="indexterm" name="idm139979068539200"></a> <code class="literal">innodb_concurrency_tickets</code>
        </p><div class="informaltable"><table summary="Options for innodb_concurrency_tickets" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_concurrency_tickets=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_concurrency_tickets">innodb_concurrency_tickets</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (&lt;= 5.6.5)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">500</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">4294967295</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (&gt;= 5.6.6)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">5000</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">4294967295</code></td></tr></tbody></table></div><p>
          同時に <code class="literal">InnoDB</code> に入ることができる<a class="link" href="glossary.html#glos_thread" title="スレッド">スレッド</a>の数を決定します。スレッドが <code class="literal">InnoDB</code> に入ろうとしたときに、すでにスレッド数が並列実行の制限に達している場合は、そのスレッドがキューに配置されます。スレッドが <code class="literal">InnoDB</code> に入ることが許可されている場合は、<code class="literal">innodb_concurrency_tickets</code> の値に等しい数の<span class="quote">「<span class="quote">空きチケット</span>」</span>が付与され、スレッドはそのチケットを使い果たすまで自由に <code class="literal">InnoDB</code> に出入りすることができます。それ以降は、スレッドが次に <code class="literal">InnoDB</code> に入ろうとしたときに、再度並列実行チェックの対象となります (キューに入る対象となる可能性もあります)。デフォルト値は、MySQL 5.6.6 の時点では 5000、それよりも前では 500 です。
        </p><p>
          <code class="literal">innodb_concurrency_tickets</code> 値を小さくすると、1、2 行しか処理する必要のない小規模なトランザクションと、多数の行を処理する大規模なトランザクションが競合する可能性が高くなります。<code class="literal">innodb_concurrency_tickets</code> 値を小さくする欠点は、大規模なトランザクションが完了するまでに何回もキュー間をループする必要があるため、タスクを完了するために必要な時間が長くなる点です。
        </p><p>
          <code class="literal">innodb_concurrency_tickets</code> 値を大きくすると、大規模なトランザクションで (<code class="literal">innodb_thread_concurrency</code> で制御される) キューの終了時の位置を待機する時間が短くなり、行を取得する時間が長くなります。また、大規模なトランザクションでは、タスクを完了するために必要なキューとの間の移動も少なくなります。<code class="literal">innodb_concurrency_tickets</code> 値を大きくする欠点は、同時に実行する大規模なトランザクションの数が非常に多くなることで、小規模なトランザクションが実行されるまでの待機時間が長くなるため、枯渇する可能性がある点です。
        </p><p>
          <code class="literal">innodb_thread_concurrency</code> 値をゼロ以外にすると、大規模なトランザクションと小規模なトランザクション間の適切なバランスを見つけるために、<code class="literal">innodb_concurrency_tickets</code> 値を上下に調整する必要がある場合があります。<code class="literal">SHOW ENGINE INNODB STATUS</code> レポートには、キューを通過する現時点で実行中のトランザクション用に残されているチケットの数が表示されます。このデータは、<code class="literal">INFORMATION_SCHEMA.INNODB_TRX</code> テーブルの <code class="literal">TRX_CONCURRENCY_TICKETS</code> カラムから取得することもできます。
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-thread_concurrency" title="14.13.5 InnoDB のスレッド並列性の構成">セクション14.13.5「InnoDB のスレッド並列性の構成」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_data_file_path"></a>
          <a class="indexterm" name="idm139979068480224"></a> <a class="indexterm" name="idm139979068478672"></a> <code class="literal">innodb_data_file_path</code>
        </p><div class="informaltable"><table summary="Options for innodb_data_file_path" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_data_file_path=name</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_file_path">innodb_data_file_path</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span> (&lt;= 5.6.6)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">ibdata1:10M:autoextend</code></td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span> (&gt;= 5.6.7)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">ibdata1:12M:autoextend</code></td></tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> の各<a class="link" href="glossary.html#glos_data_files" title="データファイル">データファイル</a>へのパスとそれらのサイズです。各データファイルへの完全ディレクトリパスは、ここに指定された各パスに <code class="literal">innodb_data_home_dir</code> を結合することで形成されます。サイズ値に <code class="literal">K</code>、<code class="literal">M</code>、または <code class="literal">G</code> を追加することで、ファイルサイズが K バイト、M バイト、または G バイト (1024M バイト) で指定されます。データファイルのサイズをキロバイト (K バイト) で指定する場合は、1024 の倍数で指定してください。それ以外の場合は、K バイト値はもっとも近いメガバイト (M バイト) の境界で丸められます。ファイルサイズの合計は、わずかに 10M バイトを上回る大きさにする必要があります。<code class="literal">innodb_data_file_path</code> を指定しない場合は、デフォルトの動作で、<code class="filename">ibdata1</code> という名前の単一の自動拡張データファイルが 12M バイトをわずかに上回る大きさで作成されます。各ファイルのサイズ制限は、オペレーティングシステムによって決定されます。大きいファイルをサポートするオペレーティングシステムでは、4G バイトよりも大きいファイルサイズを設定できます。<a class="link" href="innodb-storage-engine.html#innodb-raw-devices" title="14.5.8 共有テーブルスペースでの RAW ディスクパーティションの使用">データファイルとして生のディスクパーティションを使用する</a>こともできます。<code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_tablespace" title="テーブルスペース">テーブルスペース</a>ファイルの構成についての詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-configuration" title="14.3 InnoDB の構成">セクション14.3「InnoDB の構成」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_data_home_dir"></a>
          <a class="indexterm" name="idm139979068438592"></a> <a class="indexterm" name="idm139979068437072"></a> <code class="literal">innodb_data_home_dir</code>
        </p><div class="informaltable"><table summary="Options for innodb_data_home_dir" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_data_home_dir=path</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_home_dir">innodb_data_home_dir</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ディレクトリ名</code></td></tr></tbody></table></div><p>
          <a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">システムテーブルスペース</a>内のすべての <code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_data_files" title="データファイル">データファイル</a>のディレクトリパスに共通する部分です。この設定によって、<code class="literal">innodb_file_per_table</code> を有効にしたときの <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> テーブルスペースの場所は影響を受けません。デフォルト値は、MySQL の <code class="filename">data</code> ディレクトリです。値を空の文字列として指定した場合は、<code class="literal">innodb_data_file_path</code> 内で完全なファイルパスを使用できます。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_disable_sort_file_cache"></a>
          <a class="indexterm" name="idm139979068408688"></a> <a class="indexterm" name="idm139979068407216"></a> <code class="literal">innodb_disable_sort_file_cache</code>
        </p><div class="informaltable"><table summary="Options for innodb_disable_sort_file_cache" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.4</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_disable_sort_file_cache=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_disable_sort_file_cache">innodb_disable_sort_file_cache</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr></tbody></table></div><p>
          この変数を有効にすると、マージソート一時ファイル用のオペレーティングシステムファイルシステムのキャッシュが無効になります。その結果、このようなファイルが <code class="literal">O_DIRECT</code> の同等のものとともに開きます。この変数は MySQL 5.6.4 で追加されました。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_doublewrite"></a>
          <a class="indexterm" name="idm139979068380448"></a> <a class="indexterm" name="idm139979068378896"></a> <a class="indexterm" name="idm139979068377008"></a> <code class="literal">innodb_doublewrite</code>
        </p><div class="informaltable"><table summary="Options for innodb_doublewrite" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb-doublewrite</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_doublewrite">innodb_doublewrite</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">ON</code></td></tr></tbody></table></div><p>
          この変数を有効にすると (デフォルト)、<code class="literal">InnoDB</code> にすべてのデータが 2 回 (まず<a class="link" href="glossary.html#glos_doublewrite_buffer" title="二重書き込みバッファー">二重書き込みバッファー</a>、次に実際の<a class="link" href="glossary.html#glos_data_files" title="データファイル">データファイル</a>に) 格納されます。データの整合性や失敗の可能性の懸念より、ベンチマークや最高のパフォーマンスが必要なケースでは、<code class="option">--skip-innodb_doublewrite</code> を使用すれば、この変数を無効にすることができます。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_fast_shutdown"></a>
          <a class="indexterm" name="idm139979068350848"></a> <a class="indexterm" name="idm139979068349296"></a> <code class="literal">innodb_fast_shutdown</code>
        </p><div class="informaltable"><table summary="Options for innodb_fast_shutdown" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_fast_shutdown[=#]</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_fast_shutdown">innodb_fast_shutdown</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="5"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row" rowspan="3" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">2</code></td></tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_shutdown" title="シャットダウン">シャットダウン</a>モードです。この値を 0 にすると、<code class="literal">InnoDB</code> は<a class="link" href="glossary.html#glos_slow_shutdown" title="低速シャットダウン">低速シャットダウン</a>、完全な<a class="link" href="glossary.html#glos_purge" title="パージ">パージ</a>、および挿入バッファーのマージを実行してから、シャットダウンします。この値を 1 (デフォルト) にすると、<code class="literal">InnoDB</code> はシャットダウン時に、これらの操作をスキップします。このプロセスは、<a class="link" href="glossary.html#glos_fast_shutdown" title="高速シャットダウン">高速シャットダウン</a>と呼ばれます。この値を 2 にすると、<code class="literal">InnoDB</code> は MySQL がクラッシュした場合と同様に、そのログをフラッシュし、コールドシャットダウンを実行します。コミットされていないトランザクションは失われませんが、<a class="link" href="glossary.html#glos_crash_recovery" title="クラッシュリカバリ">クラッシュリカバリ</a>操作によって次回の起動時間が長くなります。
        </p><p>
          低速シャットダウンには数分間かかる可能性があり、大量のデータがバッファーに存在する極端なケースでは、数時間かかる可能性もあります。MySQL のメジャーリリース間でアップグレードまたはダウングレードを行う前には、アップグレードプロセスによってファイル形式が更新される場合に備えて、すべてのデータファイルが完全に準備されるように、低速シャットダウン技術を使用してください。
        </p><p>
          データが破損するリスクがある場合に、完全な最速のシャットダウンを行うには、緊急事態またはトラブルシューティングの状況で <code class="literal">innodb_fast_shutdown=2</code> を使用してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_file_format"></a>
          <a class="indexterm" name="idm139979068309824"></a> <a class="indexterm" name="idm139979068308272"></a> <a class="indexterm" name="idm139979068306384"></a> <a class="indexterm" name="idm139979068304880"></a> <code class="literal">innodb_file_format</code>
        </p><div class="informaltable"><table summary="Options for innodb_file_format" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_file_format=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format">innodb_file_format</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">Antelope</code></td></tr><tr><td scope="row" rowspan="2" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">Antelope</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">Barracuda</code></td></tr></tbody></table></div><p>
          新しい <code class="literal">InnoDB</code> テーブルで使用される<a class="link" href="glossary.html#glos_file_format" title="ファイル形式">ファイル形式</a>です。現在は、<code class="literal">Antelope</code> および <code class="literal">Barracuda</code> がサポートされています。これは、独自の<a class="link" href="glossary.html#glos_tablespace" title="テーブルスペース">テーブルスペース</a>を持つテーブルにのみ適用されるため、これを有効にするには、<code class="literal">innodb_file_per_table</code> が有効になっている必要があります。テーブルの<a class="link" href="glossary.html#glos_compression" title="圧縮">圧縮</a>などの特定の InnoDB 機能を使用するには、<a class="link" href="glossary.html#glos_barracuda" title="Barracuda">Barracuda</a> ファイル形式が必要です。
        </p><p>
          <code class="literal">InnoDB</code> のテーブル (<code class="literal">ALGORITHM=COPY</code>) を再作成する <code class="literal">ALTER TABLE</code> 操作では、現在の <code class="literal">innodb_file_format</code> 設定が使用される (前述の状況が適用される) ことに注意してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_file_format_check"></a>
          <a class="indexterm" name="idm139979068267184"></a> <a class="indexterm" name="idm139979068265632"></a> <code class="literal">innodb_file_format_check</code>
        </p><div class="informaltable"><table summary="Options for innodb_file_format_check" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_file_format_check=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format_check">innodb_file_format_check</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">ON</code></td></tr></tbody></table></div><p>
          この変数をサーバーの起動時に 1 または 0 に設定すると、<code class="literal">InnoDB</code> が<a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">システムテーブルスペース</a>の<a class="link" href="glossary.html#glos_file_format" title="ファイル形式">ファイル形式</a>タグ (<code class="literal">Antelope</code> や <code class="literal">Barracuda</code> など) をチェックするかどうかを有効または無効にすることができます。チェックされたタグが最新バージョンの <code class="literal">InnoDB</code> でサポートされているよりも大きい場合は、エラーが発生し、<code class="literal">InnoDB</code> は起動されません。このタグの方が大きくない場合は、<code class="literal">InnoDB</code> によって <code class="literal">innodb_file_format_max</code> の値がファイル形式タグに設定されます。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            デフォルト値が <code class="literal">ON</code> または <code class="literal">OFF</code> と表示されることがあるにもかかわらず、このオプションを構成ファイルまたはコマンド行でオンまたはオフに切り替えるには、常に数値 1 または 0 を使用します。
          </p></div></li><li class="listitem"><p><a name="sysvar_innodb_file_format_max"></a>
          <a class="indexterm" name="idm139979068231680"></a> <a class="indexterm" name="idm139979068230128"></a> <code class="literal">innodb_file_format_max</code>
        </p><div class="informaltable"><table summary="Options for innodb_file_format_max" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_file_format_max=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_format_max">innodb_file_format_max</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">Antelope</code></td></tr><tr><td scope="row" rowspan="2" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">Antelope</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">Barracuda</code></td></tr></tbody></table></div><p>
          サーバーの起動時に <code class="literal">InnoDB</code> によって、この変数の値が<a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">システムテーブルスペース</a>の<a class="link" href="glossary.html#glos_file_format" title="ファイル形式">ファイル形式</a>タグ (<code class="literal">Antelope</code> や <code class="literal">Barracuda</code> など) に設定されます。サーバーで<span class="quote">「<span class="quote">大きい</span>」</span>ファイル形式のテーブルが作成されたり、開かれたりすると、<code class="literal">innodb_file_format_max</code> の値がそのファイル形式に設定されます。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_file_per_table"></a>
          <a class="indexterm" name="idm139979068196928"></a> <a class="indexterm" name="idm139979068195376"></a> <code class="literal">innodb_file_per_table</code>
        </p><div class="informaltable"><table summary="Options for innodb_file_per_table" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_file_per_table</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_file_per_table">innodb_file_per_table</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span> (&lt;= 5.6.5)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span> (&gt;= 5.6.6)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">ON</code></td></tr></tbody></table></div><p>
          <code class="literal">innodb_file_per_table</code> が有効になっている (5.6.6 以上のデフォルト) 場合、<code class="literal">InnoDB</code> では、新たに作成された各テーブルのデータおよびインデックスがシステムテーブルスペースではなく、個別の <a class="link" href="glossary.html#glos_ibd_file" title=".ibd ファイル"><code class="filename">.ibd</code> ファイル</a>に格納されます。これらの <code class="literal">InnoDB</code> テーブル用のストレージは、テーブルが削除されたり、切り捨てられたりすると再利用されます。このように設定すると、テーブルの<a class="link" href="glossary.html#glos_compression" title="圧縮">圧縮</a>などのその他のいくつかの <code class="literal">InnoDB</code> 機能が有効になります。このような機能、および file-per-table テーブルスペースを使用する利点および欠点についての詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-multiple-tablespaces" title="14.5.2 InnoDB File-Per-Table モード">セクション14.5.2「InnoDB File-Per-Table モード」</a>を参照してください。
        </p><p>
          <code class="literal">ALTER TABLE</code> でテーブルが再作成されるケース (<code class="literal">ALGORITHM=COPY</code>) では、<code class="literal">innodb_file_per_table</code> を有効にすることは、<code class="literal">ALTER TABLE</code> 操作によって <code class="literal">InnoDB</code> テーブルがシステムテーブルスペースから個々の <code class="filename">.ibd</code> ファイルに移動されることも意味することに注意してください。
        </p><p>
          <code class="literal">innodb_file_per_table</code> を無効にすると、<code class="literal">InnoDB</code> ではすべてのテーブルおよびインデックス用のデータが、<a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">システムテーブルスペース</a>を構成する <a class="link" href="glossary.html#glos_ibdata_file" title="ibdata ファイル">ibdata ファイル</a>に格納されます。このように設定すると、<code class="literal">DROP TABLE</code> や <code class="literal">TRUNCATE TABLE</code> などの操作で、ファイルシステム操作のパフォーマンスオーバーヘッドが削減されます。これは、ストレージデバイス全体が MySQL データ専用になっているサーバー環境に最適です。システムテーブルスペースは縮小されず、<a class="link" href="glossary.html#glos_instance" title="インスタンス">インスタンス</a>内のすべてのデータベースにわたって共有されないため、<code class="literal">innodb_file_per_table=OFF</code> のときは、領域が制約されているシステムで一時データを大量にロードすることは回避してください。このような場合は、領域を再利用するためにインスタンス全体を削除できるように、個別のインスタンスを設定します。
        </p><p>
          MySQL 5.6.6 の時点では、デフォルトで <code class="literal">innodb_file_per_table</code> が有効になっています。それよりも前では、無効になっています。MySQL 5.5 または 5.1 との下位互換性が懸念事項となっている場合は、これを無効にすることを検討してください。これにより、<code class="literal">ALTER TABLE</code> によって <code class="literal">InnoDB</code> テーブルがシステムテーブルスペースから個々の <code class="filename">.ibd</code> ファイルに移動することが回避されます。
        </p><p>
          <code class="literal">innodb_file_per_table</code> は動的であり、<code class="literal">SET GLOBAL</code> を使用して <code class="literal">ON</code> または <code class="literal">OFF</code> に設定できます。このパラメータは、MySQL <a class="link" href="glossary.html#glos_configuration_file" title="構成ファイル">構成ファイル</a> (<code class="filename">my.cnf</code> または <code class="filename">my.ini</code>) でも設定できますが、このためにはサーバーをシャットダウンしてから再起動する必要があります。
        </p><p>
          このパラメータの値を動的に変更するには、<code class="literal">SUPER</code> 権限が必要です。動的に変更すると、すべての接続の操作がすぐに影響を受けます。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_flush_log_at_timeout"></a>
          <a class="indexterm" name="idm139979068132384"></a> <a class="indexterm" name="idm139979068130912"></a> <code class="literal">innodb_flush_log_at_timeout</code>
        </p><div class="informaltable"><table summary="Options for innodb_flush_log_at_timeout" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.6</td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_log_at_timeout">innodb_flush_log_at_timeout</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">2700</code></td></tr></tbody></table></div><p>
          ログを <em class="replaceable"><code>N</code></em> 秒ごとに書き込んで、フラッシュします。<code class="literal">innodb_flush_log_at_timeout</code> は MySQL 5.6.6 で導入されました。フラッシュを減らし、バイナリロググループのコミット時のパフォーマンスへの影響を回避するために、フラッシュ間のタイムアウト期間を長くすることができます。MySQL 5.6.6 よりも前では、フラッシュの頻度は 1 秒ごとに 1 回でした。<code class="literal">innodb_flush_log_at_timeout</code> のデフォルト設定も 1 秒ごとに 1 回です。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_flush_log_at_trx_commit"></a>
          <a class="indexterm" name="idm139979068100096"></a> <a class="indexterm" name="idm139979068098624"></a> <code class="literal">innodb_flush_log_at_trx_commit</code>
        </p><div class="informaltable"><table summary="Options for innodb_flush_log_at_trx_commit" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_flush_log_at_trx_commit[=#]</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_log_at_trx_commit">innodb_flush_log_at_trx_commit</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="5"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">列挙</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row" rowspan="3" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">2</code></td></tr></tbody></table></div><p>
          <a class="link" href="glossary.html#glos_commit" title="コミット">コミット</a>操作に対する厳密な <a class="link" href="glossary.html#glos_acid" title="ACID">ACID</a> コンプライアンスと、コミット関連の I/O 操作が再編成およびバッチ処理されるときに実現可能な高いパフォーマンスとの間のバランスを制御します。デフォルト値を変更するとパフォーマンスを改善できますが、クラッシュ時にトランザクションが最大で 1 秒間失われる可能性があります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              完全に ACID コンプライアンスに従うには、デフォルト値の 1 を使用する必要があります。この値を使用すると、トランザクションコミットのたびに、<code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_log_buffer" title="ログバッファー">ログバッファー</a>の内容が<a class="link" href="glossary.html#glos_log_file" title="ログファイル">ログファイル</a>に書き込まれ、ログファイルがディスクに<a class="link" href="glossary.html#glos_flush" title="フラッシュ">フラッシュ</a>されます。
            </p></li><li class="listitem"><p>
              値を 0 にすると、約 1 秒ごとに 1 回、<code class="literal">InnoDB</code> のログバッファーの内容がログファイルに書き込まれ、ログファイルがディスクにフラッシュされます。ログバッファーからログファイルに書き込みは、トランザクションコミット時には実行されません。プロセスのスケジューリングの問題が原因で、1 秒ごとに 1 回のフラッシュが毎秒発生する 100% の保証はありません。ディスク操作へのフラッシュは約 1 秒ごとに 1 回しか発生しないため、任意の <span class="command"><strong>mysqld</strong></span> プロセスがクラッシュすると、トランザクションが最大で 1 秒間失われる可能性があります。
            </p></li><li class="listitem"><p>
              値を 2 にすると、トランザクションコミットのたびに、<code class="literal">InnoDB</code> のログバッファーの内容がログファイルに書き込まれ、約 1 秒ごとに 1 回ログファイルがディスクにフラッシュされます。プロセスのスケジューリングの問題が原因で、1 秒ごとに 1 回のフラッシュが毎秒発生する 100% の保証はありません。ディスク操作へのフラッシュは約 1 秒ごとに 1 回しか発生しないため、オペレーティングシステムがクラッシュしたり、停電が発生したりすると、トランザクションが最大で 1 秒間失われる可能性があります。
            </p></li><li class="listitem"><p>
              MySQL 5.6.6 の時点では、<code class="filename">InnoDB</code> でのログフラッシュの頻度が <code class="literal">innodb_flush_log_at_timeout</code> で制御されます。これにより、ログフラッシュの頻度を <em class="replaceable"><code>N</code></em> 秒間に設定できます (ここで、<em class="replaceable"><code>N</code></em> は <code class="literal">1 ... 2700</code> で、デフォルト値は 1 です)。ただし、任意の <span class="command"><strong>mysqld</strong></span> プロセスがクラッシュすると、トランザクションが最大で <em class="replaceable"><code>N</code></em> 秒間消失する可能性があります。
            </p></li><li class="listitem"><p>
              <code class="literal">innodb_flush_log_at_trx_commit</code> の設定とは関係なく、DDL の変更やその他の <code class="literal">InnoDB</code> アクティビティーによって、<code class="literal">InnoDB</code> のログがフラッシュされます。
            </p></li><li class="listitem"><p>
              <code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_crash_recovery" title="クラッシュリカバリ">クラッシュリカバリ</a>は、<code class="literal">innodb_flush_log_at_trx_commit</code> の設定に関係なく機能します。トランザクションは完全に適用されるか、完全に消去されるかのいずれかです。
            </p></li></ul></div><p>
          トランザクションで <code class="literal">InnoDB</code> が使用されるレプリケーションセットアップの持続性および一貫性を保つ場合:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              バイナリロギングが有効になっている場合は、<code class="literal">sync_binlog=1</code> を設定します。
            </p></li><li class="listitem"><p>
              常に <code class="literal">innodb_flush_log_at_trx_commit=1</code> を設定します。
            </p></li></ul></div><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注意</div><p>
            多くのオペレーティングシステムや一部のディスクハードウェアは、ディスクへのフラッシュ操作を行なったと欺きます。フラッシュが行われていなくても、行われたと <span class="command"><strong>mysqld</strong></span> に通知される可能性があります。そのため、1 を設定してもトランザクションの持続性は保証されず、最悪のケースでは、停電によって <code class="literal">InnoDB</code> のデータが破損する可能性もあります。バッテリーバックアップのディスクキャッシュを SCSI ディスクコントローラ内やディスク自体で使用すると、ファイルフラッシュの速度が上がり、操作が安全になります。ハードウェアキャッシュ内でディスク書き込みのキャッシュを無効にするために、Unix コマンド <span class="command"><strong>hdparm</strong></span> を使用してみたり、ハードウェアベンダー固有のその他のコマンドを使用したりすることもできます。
          </p></div></li><li class="listitem"><p><a name="sysvar_innodb_flush_method"></a>
          <a class="indexterm" name="idm139979068034032"></a> <a class="indexterm" name="idm139979068032480"></a> <code class="literal">innodb_flush_method</code>
        </p><div class="informaltable"><table summary="Options for innodb_flush_method" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_flush_method=name</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_method">innodb_flush_method</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span> (Windows)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">async_unbuffered</code></td></tr><tr><td scope="row" rowspan="5"><span class="bold"><strong>許可されている値</strong></span> (Unix, &lt;= 5.6.6)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">fsync</code></td></tr><tr><td scope="row" rowspan="3" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">fsync</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">O_DSYNC</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">O_DIRECT</code></td></tr><tr><td scope="row" rowspan="6"><span class="bold"><strong>許可されている値</strong></span> (Unix, &gt;= 5.6.7)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">fsync</code></td></tr><tr><td scope="row" rowspan="4" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">fsync</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">O_DSYNC</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">O_DIRECT</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">O_DIRECT_NO_FSYNC</code></td></tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_data_files" title="データファイル">データファイル</a>および<a class="link" href="glossary.html#glos_log_file" title="ログファイル">ログファイル</a>にデータを<a class="link" href="glossary.html#glos_flush" title="フラッシュ">フラッシュ</a>する際に使用される方法を定義します。これにより、I/O スループットが影響を受ける可能性があります。この変数は、Unix および Linux システムでのみ構成可能です。Windows システムでは、フラッシュ方法は常に <code class="literal">async_unbuffered</code> であり、変更できません。
        </p><p>
          <code class="literal">innodb_flush_method</code> オプションの内容は、次のとおりです。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">fsync</code>: <code class="literal">InnoDB</code> は <code class="literal">fsync()</code> システムコールを使用して、データファイルとログファイルの両方をフラッシュします。<code class="literal">fsync</code> はデフォルト設定です。
            </p></li><li class="listitem"><p>
              <code class="literal">O_DSYNC</code>: <code class="literal">InnoDB</code> は、<code class="literal">O_SYNC</code> を使用してログファイルを開いてフラッシュし、<code class="literal">fsync()</code> を使用してデータファイルをフラッシュします。さまざまな種類の Unix で問題が発生しているため、<code class="literal">InnoDB</code> では直接 <code class="literal">O_DSYNC</code> が使用されません。
            </p></li><li class="listitem"><p>
              <code class="literal">O_DIRECT</code>: <code class="literal">InnoDB</code> は、<code class="literal">O_DIRECT</code> (Solaris では <code class="literal">directio()</code>) を使用してデータファイルを開き、<code class="literal">fsync()</code> を使用してデータファイルとログファイルの両方をフラッシュします。このオプションは、一部の GNU/Linux バージョン、FreeBSD、および Solaris で使用可能です。
            </p></li><li class="listitem"><p>
              <code class="literal">O_DIRECT_NO_FSYNC</code>: <code class="literal">InnoDB</code> は、I/O のフラッシュ時に <code class="literal">O_DIRECT</code> を使用しますが、後続の <code class="literal">fsync()</code> システムコールはスキップします。この設定は、一部のタイプのファイルシステムには適していますが、その他には適していません。たとえば、XFS には適していません。たとえば、使用中のファイルシステムですべてのファイルメタデータを保持するために、<code class="literal">fsync()</code> が必要であるのかどうかが不明な場合は、代わりに <code class="literal">O_DIRECT</code> を使用してください。このオプションは MySQL 5.6.7 (Bug #11754304、Bug #45892) で導入されました。
            </p></li></ul></div><p>
          各設定によるパフォーマンスへの影響度は、ハードウェア構成およびワークロードによって異なります。使用する設定を決定したり、デフォルト設定のままにするかどうかを決定したりするには、特定の構成でベンチマークを実施します。設定ごとに <code class="literal">fsync()</code> 呼び出しの全体数を確認するには、<code class="literal">Innodb_data_fsyncs</code> ステータス変数を調査します。ワークロードに読み取り操作と書き込み操作を混在させると、一部の設定での実行が影響を受ける可能性があります。たとえば、ハードウェア RAID コントローラおよびバッテリーでバックアップされる書き込みキャッシュが搭載されたシステムでは、<code class="literal">InnoDB</code> のバッファープールとオペレーティングシステムのファイルシステムキャッシュ間での二重バッファリングを回避する際に、<code class="literal">O_DIRECT</code> が役立つことがあります。<code class="literal">InnoDB</code> のデータファイルとログファイルが SAN 上に配置されている一部のシステムでは、大部分の <code class="literal">SELECT</code> ステートメントを含む読み取り負荷の高いワークロードで、デフォルト値または <code class="literal">O_DSYNC</code> の速度が速くなる可能性があります。このパラメータは、必ず、本番環境が反映されたハードウェアおよびワークロードでテストしてください。一般的な I/O チューニングのアドバイスについては、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.7 InnoDB ディスク I/O の最適化">セクション8.5.7「InnoDB ディスク I/O の最適化」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_flush_neighbors"></a>
          <a class="indexterm" name="idm139979067948752"></a> <code class="literal">innodb_flush_neighbors</code>
        </p><div class="informaltable"><table summary="Options for innodb_flush_neighbors" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.3</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_flush_neighbors</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_flush_neighbors">innodb_flush_neighbors</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="5"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">列挙</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row" rowspan="3" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">2</code></td></tr></tbody></table></div><p>
          InnoDB の<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>からページを<a class="link" href="glossary.html#glos_flush" title="フラッシュ">フラッシュ</a>すると、同じ<a class="link" href="glossary.html#glos_extent" title="エクステント">エクステント</a>内のその他の<a class="link" href="glossary.html#glos_dirty_page" title="ダーティーページ">ダーティーページ</a>もフラッシュされるかどうかを指定します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              デフォルト値の 1 では、バッファープールから同じエクステント内の連続するダーティーページがフラッシュされます。
            </p></li><li class="listitem"><p>
              0 を設定すると、<code class="literal">innodb_flush_neighbors</code> がオフになり、その他のダーティーページはバッファープールからフラッシュされません。
            </p></li><li class="listitem"><p>
              2 を設定すると、同じエクステント内のダーティーページがバッファープールからフラッシュされます。
            </p></li></ul></div><p>
          テーブルデータが従来の <a class="link" href="glossary.html#glos_hdd" title="HDD">HDD</a> ストレージデバイスに格納されている場合は、1 回の操作でこのような<a class="link" href="glossary.html#glos_neighbor_page" title="隣接ページ">隣接ページ</a>をフラッシュすると、さまざまな時間に個々のページをフラッシュする場合と比較して、(主にディスクシーク操作の) I/O オーバーヘッドが削減されます。テーブルデータが <a class="link" href="glossary.html#glos_ssd" title="SSD">SSD</a> 上に格納されている場合は、シーク時間が重要な要素ではないため、この設定をオフにすれば、書き込み操作を分散できます。一般的な I/O チューニングのアドバイスについては、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.7 InnoDB ディスク I/O の最適化">セクション8.5.7「InnoDB ディスク I/O の最適化」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_flushing_avg_loops"></a>
          <a class="indexterm" name="idm139979067906016"></a> <code class="literal">innodb_flushing_avg_loops</code>
        </p><div class="informaltable"><table summary="Options for innodb_flushing_avg_loops" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.6</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_flushing_avg_loops=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_flushing_avg_loops">innodb_flushing_avg_loops</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">30</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">1000</code></td></tr></tbody></table></div><p>
          InnoDB が以前に計算されたフラッシュ状態のスナップショットを保持する繰り返しの数です。これにより、<a class="link" href="glossary.html#glos_adaptive_flushing" title="適応型フラッシュ">適応型フラッシュ</a>が<a class="link" href="glossary.html#glos_workload" title="ワークロード">ワークロード</a>の変更に対応する速度が制御されます。この値を大きくすると、ワークロードが変化するにつれて、<a class="link" href="glossary.html#glos_flush" title="フラッシュ">フラッシュ</a>操作の速度が円滑かつ徐々に変化します。この値を小さくすると、適応型フラッシュがワークロードの変化にすばやく適応します。これにより、ワークロードが突然に増減した場合に、フラッシュアクティビティーが急増する可能性があります。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_force_load_corrupted"></a>
          <a class="indexterm" name="idm139979067873264"></a> <code class="literal">innodb_force_load_corrupted</code>
        </p><div class="informaltable"><table summary="Options for innodb_force_load_corrupted" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.3</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_force_load_corrupted</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_force_load_corrupted">innodb_force_load_corrupted</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr></tbody></table></div><p>
          InnoDB の起動時に、破損マークが付けられたテーブルをロードできます。トラブルシューティング時に、何も対処しなければアクセスできないデータをリカバリする際にのみ使用してください。トラブルシューティングが完了したら、この設定をオフに戻して、サーバーを再起動します。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_force_recovery"></a>
          <a class="indexterm" name="idm139979067847616"></a> <a class="indexterm" name="idm139979067846064"></a> <code class="literal">innodb_force_recovery</code>
        </p><div class="informaltable"><table summary="Options for innodb_force_recovery" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_force_recovery=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_force_recovery">innodb_force_recovery</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">6</code></td></tr></tbody></table></div><p>
          <a class="link" href="glossary.html#glos_crash_recovery" title="クラッシュリカバリ">クラッシュリカバリ</a>モードです。一般に、重大なトラブルシューティングの状況でのみ変更されます。指定可能な値は 0 から 6 までです。これらの値の意味および <code class="literal">innodb_force_recovery</code> に関する重要な情報については、<a class="xref" href="innodb-storage-engine.html#forcing-innodb-recovery" title="14.19.2 InnoDB のリカバリの強制的な実行">セクション14.19.2「InnoDB のリカバリの強制的な実行」</a>を参照してください。
        </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
            緊急状況でのみ、この変数を 0 よりも大きい値に設定してください。これにより、<code class="literal">InnoDB</code> を起動し、テーブルをダンプできるようになります。安全対策として、<code class="literal">innodb_force_recovery</code> を 0 よりも大きくすると、<code class="literal">InnoDB</code> で <code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、または <code class="literal">DELETE</code> 操作が回避されます。また、5.6.15 の時点では、<code class="literal">innodb_force_recovery</code> の設定を 4 よりも大きくすると、<code class="literal">InnoDB</code> が読み取り専用モードになります。
          </p><p>
            このような制約のために、<code class="option">--relay-log-info-repository=TABLE</code> や <code class="option">--master-info-repository=TABLE</code> などのレプリケーションオプションによって <code class="literal">InnoDB</code> 内のテーブルに情報が格納されると、レプリケーション管理コマンドに失敗し、エラーが発生する可能性があります。
          </p></div></li><li class="listitem"><p><a name="sysvar_innodb_ft_aux_table"></a>
          <a class="indexterm" name="idm139979067804528"></a> <code class="literal">innodb_ft_aux_table</code>
        </p><div class="informaltable"><table summary="Options for innodb_ft_aux_table" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.4</td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_aux_table">innodb_ft_aux_table</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr></tbody></table></div><p>
          <code class="literal">FULLTEXT</code> インデックスを含む <code class="literal">InnoDB</code> テーブルの修飾名を指定します。この変数は診断のために使用され、実行時にのみ設定できます。例:
        </p><pre class="programlisting">
mysql&gt; set global innodb_ft_aux_table = 'test/t1';
</pre><p>
          この変数を起動時に設定しようとすると、<span class="quote">「<span class="quote"><span class="errortext">mysqld: option '--innodb-ft-aux-table' cannot take an argument</span></span>」</span>エラーが発生し、起動が中止されます。この変数を <code class="literal"><em class="replaceable"><code>db_name</code></em>/<em class="replaceable"><code>table_name</code></em></code> 形式の名前に設定すると、<code class="literal">INFORMATION_SCHEMA</code> テーブル <code class="literal">INNODB_FT_INDEX_TABLE</code>、<code class="literal">INNODB_FT_INDEX_CACHE</code>、<code class="literal">INNODB_FT_CONFIG</code>、<code class="literal">INNODB_FT_DELETED</code>、および <code class="literal">INNODB_FT_BEING_DELETED</code> に、指定されたテーブルの検索インデックスに関する情報が表示されます。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_ft_cache_size"></a>
          <a class="indexterm" name="idm139979067773216"></a> <code class="literal">innodb_ft_cache_size</code>
        </p><div class="informaltable"><table summary="Options for innodb_ft_cache_size" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.4</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_ft_cache_size=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_cache_size">innodb_ft_cache_size</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span> (&gt;= 5.6.4, &lt;= 5.6.9)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">32000000</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (&gt;= 5.6.10)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">8000000</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1600000</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">80000000</code></td></tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> の FULLTEXT 検索インデックスのキャッシュ用に割り当てられたメモリー量 (バイト単位) です。<code class="literal">InnoDB</code> の <code class="literal">FULLTEXT</code> インデックスの作成時に、この量の解析済みドキュメントがメモリー内に保持されます。<code class="literal">innodb_ft_cache_size</code> のサイズ制限に達すると、インデックスの挿入および更新のみがディスクにコミットされます。<code class="literal">innodb_ft_cache_size</code> では、キャッシュサイズがテーブルごとに定義されます。すべてのテーブルにグローバルな制限を設定する方法については、<code class="literal">innodb_ft_total_cache_size</code> を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_ft_enable_diag_print"></a>
          <a class="indexterm" name="idm139979067732176"></a> <code class="literal">innodb_ft_enable_diag_print</code>
        </p><div class="informaltable"><table summary="Options for innodb_ft_enable_diag_print" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.4</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_ft_enable_diag_print=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_enable_diag_print">innodb_ft_enable_diag_print</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span> (&lt;= 5.6.6)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">ON</code></td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span> (&gt;= 5.6.7)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr></tbody></table></div><p>
          追加の全文検索 (FTS) 診断の出力を有効にするかどうかを指定します。このオプションは、主に高度な FTS デバッグのために使用され、大部分のユーザーには関心がないものです。出力はエラーログに記録され、次のような情報が含まれています。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              FTS インデックス同期の進行状況 (FTS キャッシュ制限に達したとき)。例:
            </p><pre class="programlisting">
FTS SYNC for table test, deleted count: 100 size: 10000 bytes
SYNC words: 100 
</pre></li><li class="listitem"><p>
              FTS 最適化の進行状況。例:
            </p><pre class="programlisting">
FTS start optimize test
FTS_OPTIMIZE: optimize "mysql"
FTS_OPTIMIZE: processed "mysql" 
</pre></li><li class="listitem"><p>
              FTS インデックス構築の進行状況。例:
            </p><pre class="programlisting">
Number of doc processed: 1000
</pre></li><li class="listitem"><p>
              FTS クエリーでは、クエリー解析のツリー、単語の重み、クエリーの処理時間、およびメモリーの使用状況が出力されます。例:
            </p><pre class="programlisting">
FTS Search Processing time: 1 secs: 100 millisec: row(s) 10000
Full Search Memory: 245666 (bytes),  Row: 10000 
</pre></li></ul></div></li><li class="listitem"><p><a name="sysvar_innodb_ft_enable_stopword"></a>
          <a class="indexterm" name="idm139979067693200"></a> <code class="literal">innodb_ft_enable_stopword</code>
        </p><div class="informaltable"><table summary="Options for innodb_ft_enable_stopword" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.4</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_ft_enable_stopword=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_enable_stopword">innodb_ft_enable_stopword</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">ON</code></td></tr></tbody></table></div><p>
          インデックスの作成時に、一連の<a class="link" href="glossary.html#glos_stopword" title="ストップワード">ストップワード</a>が <code class="literal">InnoDB</code> の <code class="literal">FULLTEXT</code> インデックスに関連付けられることを指定します。<code class="literal">innodb_ft_user_stopword_table</code> オプションが設定されている場合は、そのテーブルからストップワードが取得されます。そうでなければ、<code class="literal">innodb_ft_server_stopword_table</code> オプションが設定されている場合は、そのテーブルからストップワードが取得されます。それ以外の場合は、組み込みのデフォルトストップワードセットが使用されます。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_ft_max_token_size"></a>
          <a class="indexterm" name="idm139979067662768"></a> <code class="literal">innodb_ft_max_token_size</code>
        </p><div class="informaltable"><table summary="Options for innodb_ft_max_token_size" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.4</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_ft_max_token_size=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_max_token_size">innodb_ft_max_token_size</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">84</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">10</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">252</code></td></tr></tbody></table></div><p>
          InnoDB の <code class="literal">FULLTEXT</code> インデックスに格納されている単語の最大長です。この値に制限を設定すると、実在の単語ではなく、検索語句になる可能性の低い英字の任意のコレクションや長いキーワードが省略されることで、インデックスのサイズが削減されるため、クエリーの速度が上がります。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_ft_min_token_size"></a>
          <a class="indexterm" name="idm139979067631904"></a> <code class="literal">innodb_ft_min_token_size</code>
        </p><div class="informaltable"><table summary="Options for innodb_ft_min_token_size" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.4</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_ft_min_token_size=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_min_token_size">innodb_ft_min_token_size</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">3</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">16</code></td></tr></tbody></table></div><p>
          InnoDB の <code class="literal">FULLTEXT</code> インデックスに格納されている単語の最小長です。この値を大きくすると、検索のコンテキストで重要となる可能性の低い一般的な単語 (<span class="quote">「<span class="quote">a</span>」</span> や <span class="quote">「<span class="quote">to</span>」</span> などの英単語) が省略されることで、インデックスのサイズが削減されるため、クエリーの速度が上がります。内容で CJK (中国語、日本語、韓国語) 文字セットが使用されている場合は、値 1 を指定します。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_ft_num_word_optimize"></a>
          <a class="indexterm" name="idm139979067599984"></a> <code class="literal">innodb_ft_num_word_optimize</code>
        </p><div class="informaltable"><table summary="Options for innodb_ft_num_word_optimize" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.4</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_ft_num_word_optimize=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_num_word_optimize">innodb_ft_num_word_optimize</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">2000</code></td></tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> の <code class="literal">FULLTEXT</code> インデックスでの各 <code class="literal">OPTIMIZE TABLE</code> 操作時に処理される単語数です。全文検索インデックスを含むテーブルへの一括挿入または一括更新操作では、すべての変更を組み込むために大量のインデックスのメンテナンスが必要となる可能性があるため、それぞれが最後に終了した場所から再開する一連の <code class="literal">OPTIMIZE TABLE</code> ステートメントを実行するとよいでしょう。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_ft_result_cache_limit"></a>
          <a class="indexterm" name="idm139979067570768"></a> <code class="literal">innodb_ft_result_cache_limit</code>
        </p><div class="informaltable"><table summary="Options for innodb_ft_result_cache_limit" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.13</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_ft_result_cache_limit=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_result_cache_limit">innodb_ft_result_cache_limit</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (Unix, 32 ビットプラットフォーム, &gt;= 5.6.13, &lt;= 5.6.16)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">2000000000</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1000000</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">2**32-1</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (Unix, 64 ビットプラットフォーム, &gt;= 5.6.13, &lt;= 5.6.16)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">2000000000</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1000000</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">2**64-1</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (Windows, &gt;= 5.6.13, &lt;= 5.6.16)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">2000000000</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1000000</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">2**32-1</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (&gt;= 5.6.17)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">2000000000</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1000000</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">2**32-1</code></td></tr></tbody></table></div><p>
          FTS クエリーごとまたはスレッドごとに、(バイト単位で定義された) <code class="literal">InnoDB</code> の FULLTEXT 検索 (FTS) クエリー結果のキャッシュ制限です。中間および最終の <code class="literal">InnoDB</code> FTS クエリー結果は、メモリー内で処理されます。<code class="literal">InnoDB</code> の FTS クエリー結果が非常に大きい (何百万や何億もの行数など) 場合に、過剰なメモリー消費を回避するには、<code class="literal">innodb_ft_result_cache_limit</code> を使用して <code class="literal">InnoDB</code> の FTS クエリー結果のキャッシュにサイズ制限を課します。メモリーは、FTS クエリーの処理時に必要に応じて割り当てられます。結果のキャッシュサイズ制限に達すると、クエリーで最大限に許可されるメモリー量を超えたことを示すエラーが返されます。
        </p><p>
          MySQL 5.6.17 の時点では、すべてのプラットフォームタイプおよびプラットフォームビットサイズに対応した <code class="literal">innodb_ft_result_cache_limit</code> の最大値は、2**32-1 です。Bug #71554。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_ft_server_stopword_table"></a>
          <a class="indexterm" name="idm139979067503760"></a> <code class="literal">innodb_ft_server_stopword_table</code>
        </p><div class="informaltable"><table summary="Options for innodb_ft_server_stopword_table" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.4</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_ft_server_stopword_table=db_name/table_name</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_server_stopword_table">innodb_ft_server_stopword_table</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">NULL</code></td></tr></tbody></table></div><p>
          このオプションは、すべての <code class="literal">InnoDB</code> テーブルに対応した独自の <code class="literal">InnoDB</code> の <code class="literal">FULLTEXT</code> インデックスストップワードリストを指定する際に使用されます。特定の <code class="literal">InnoDB</code> テーブルに独自のストップワードリストを構成するには、<code class="literal">innodb_ft_user_stopword_table</code> を使用します。
        </p><p>
          <code class="literal"><em class="replaceable"><code>db_name</code></em>/<em class="replaceable"><code>table_name</code></em></code> の形式で、<code class="literal">innodb_ft_server_stopword_table</code> をストップワードリストを含むテーブルの名前に設定します。
        </p><p>
          <code class="literal">innodb_ft_server_stopword_table</code> を構成する前に、ストップワードテーブルが存在する必要があります。<code class="literal">FULLTEXT</code> インデックスを作成する前に、<code class="literal">innodb_ft_enable_stopword</code> を有効にして、<code class="literal">innodb_ft_server_stopword_table</code> オプションを構成する必要あります。
        </p><p>
          ストップワードテーブルは、<code class="literal">VALUE</code> という名前の単一の <code class="literal">VARCHAR</code> カラムを含む <code class="literal">InnoDB</code> テーブルにする必要があります。
        </p><p>
          詳細は、<a class="xref" href="functions.html#fulltext-stopwords" title="12.9.4 全文ストップワード">セクション12.9.4「全文ストップワード」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_ft_sort_pll_degree"></a>
          <a class="indexterm" name="idm139979067463984"></a> <code class="literal">innodb_ft_sort_pll_degree</code>
        </p><div class="informaltable"><table summary="Options for innodb_ft_sort_pll_degree" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.4</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_ft_sort_pll_degree=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_sort_pll_degree">innodb_ft_sort_pll_degree</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">2</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">32</code></td></tr></tbody></table></div><p>
          <a class="link" href="glossary.html#glos_search_index" title="検索インデックス">検索インデックス</a>の構築時に、<code class="literal">InnoDB</code> の <code class="literal">FULLTEXT</code> インデックス内のテキストのインデックス作成およびトークン化を行う際に、並列して使用されるスレッド数です。使用法の追加情報については、<code class="literal">innodb_sort_buffer_size</code> を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_ft_total_cache_size"></a>
          <a class="indexterm" name="idm139979067430752"></a> <code class="literal">innodb_ft_total_cache_size</code>
        </p><div class="informaltable"><table summary="Options for innodb_ft_total_cache_size" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.13</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_ft_total_cache_size=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_total_cache_size">innodb_ft_total_cache_size</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">640000000</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">32000000</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">1600000000</code></td></tr></tbody></table></div><p>
          すべてのテーブルに対応した <code class="literal">InnoDB</code> の <code class="literal">FULLTEXT</code> 検索インデックスキャッシュ用に割り当てられた合計メモリー量 (バイト単位) です。それぞれが全文検索インデックスを持つ多数のテーブルを作成すると、使用可能なメモリーの大部分が消費される可能性があります。<code class="literal">innodb_ft_total_cache_size</code> では、過剰なメモリー消費を回避する際に役立つ、すべての全文検索インデックスに対応したグローバルなメモリー制限が定義されます。インデックス操作でグローバルな制限に達すると、強制的な同期がトリガーされます。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_ft_user_stopword_table"></a>
          <a class="indexterm" name="idm139979067397520"></a> <code class="literal">innodb_ft_user_stopword_table</code>
        </p><div class="informaltable"><table summary="Options for innodb_ft_user_stopword_table" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.4</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_ft_user_stopword_table=db_name/table_name</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_ft_user_stopword_table">innodb_ft_user_stopword_table</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル、セッション</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">NULL</code></td></tr></tbody></table></div><p>
          このオプションは、特定のテーブルに独自の <code class="literal">InnoDB</code> の <code class="literal">FULLTEXT</code> インデックスストップワードリストを指定する際に使用されます。すべての <code class="literal">InnoDB</code> テーブル用に独自のストップワードリストを構成するには、<code class="literal">innodb_ft_server_stopword_table</code> を使用します。
        </p><p>
          <code class="literal"><em class="replaceable"><code>db_name</code></em>/<em class="replaceable"><code>table_name</code></em></code> の形式で、<code class="literal">innodb_ft_user_stopword_table</code> をストップワードリストを含むテーブルの名前に設定します。
        </p><p>
          <code class="literal">innodb_ft_user_stopword_table</code> を構成する前に、ストップワードテーブルが存在する必要があります。<code class="literal">FULLTEXT</code> インデックスを作成する前に、<code class="literal">innodb_ft_enable_stopword</code> を有効にして、<code class="literal">innodb_ft_user_stopword_table</code> オプションを構成する必要あります。
        </p><p>
          ストップワードテーブルは、<code class="literal">VALUE</code> という名前の単一の <code class="literal">VARCHAR</code> カラムを含む <code class="literal">InnoDB</code> テーブルにする必要があります。
        </p><p>
          詳細は、<a class="xref" href="functions.html#fulltext-stopwords" title="12.9.4 全文ストップワード">セクション12.9.4「全文ストップワード」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_io_capacity"></a>
          <a class="indexterm" name="idm139979067358464"></a> <a class="indexterm" name="idm139979067356944"></a> <code class="literal">innodb_io_capacity</code>
        </p><div class="informaltable"><table summary="Options for innodb_io_capacity" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_io_capacity=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity">innodb_io_capacity</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (32 ビットプラットフォーム)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">200</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">100</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">2**32-1</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (64 ビットプラットフォーム)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">200</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">100</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">2**64-1</code></td></tr></tbody></table></div><p>
          <code class="literal">innodb_io_capacity</code> パラメータは、<code class="literal">InnoDB</code> バックグラウンドタスクで実行される I/O アクティビティー (<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>からのページの<a class="link" href="glossary.html#glos_flush" title="フラッシュ">フラッシュ</a>や<a class="link" href="glossary.html#glos_insert_buffer" title="挿入バッファー">挿入バッファー</a>からのデータのマージなど) に上限を設定します。デフォルト値は 200 です。高い I/O レートを処理できる高負荷のシステムでは、サーバーの起動時に大きい値を設定すると、サーバーが高いレートの行変更に関連付けられたバックグラウンドメンテナンス作業を処理できるようになります。
        </p><p>
          <code class="literal">innodb_io_capacity</code> の制限は、すべてのバッファープールインスタンスに対する合計の制限です。ダーティーページがフラッシュされるとき、<code class="literal">innodb_io_capacity</code> 制限は、バッファープールインスタンス間で均等に分割されます。
        </p><p>
          個別の 5400 RPM または 7200 RPM ドライブが搭載されたシステムでは、元のデフォルトの <code class="literal">100</code> まで値を小さくするとよいでしょう。
        </p><p>
          このパラメータはほぼ、システムが 1 秒あたりに実行できる I/O 操作の数に設定するようにしてください。理想的には、この設定はできるだけ小さく保ちます。ただし、これらのバックグラウンドアクティビティーに遅延が発生するほど小さくしないでください。値が大きすぎる場合は、データがバッファープールおよび挿入バッファーから瞬時に削除されるため、キャッシュを使用する重要な利点が得られません。
        </p><p>
          この値は、約 100 IOPS を実行できる旧世代のディスクドライブで実現可能な IOPS (I/O Operations Per Second) の推定比率を表します。現在のデフォルトの 200 は、最新のストレージデバイスがさらに高い I/O レートを処理できることを反映しています。
        </p><p>
          一般に、<code class="literal">InnoDB</code> の I/O で使用されるドライブ (特に、高い数値の IOPS を処理できる高速ドライブ) の数に応じて、値を大きくすることができます。たとえば、<code class="literal">InnoDB</code> 用に複数のディスクまたはソリッドステートディスクを使用するシステムでは、このパラメータを制御する機能の利点が得られる可能性が高くなります。
        </p><p>
          非常に大きい数値も指定できますが、実際にはこのような大きな値にすると、利点を得られるとしてもわずかです。たとえば、100 万は非常に大きい値と考えられます。
        </p><p>
          <code class="literal">innodb_io_capacity</code> の値は、<code class="literal">innodb_io_capacity_max</code> で定義された最大値まで、100 以上の任意の数値に設定できます。デフォルト値は <code class="literal">200</code> です。このパラメータの値は MySQL オプションファイル (<code class="literal">my.cnf</code> または <code class="literal">my.ini</code>) で設定するか、あるいは <code class="literal">SET GLOBAL</code> コマンド (これには <code class="literal">SUPER</code> 権限が必要です) で動的に変更できます。
        </p><p>
          このオプションに関する詳細なガイドラインについては、<a class="xref" href="innodb-storage-engine.html#innodb-performance-thread_io_rate" title="14.13.8 InnoDB マスタースレッドの I/O レートの構成">セクション14.13.8「InnoDB マスタースレッドの I/O レートの構成」</a>を参照してください。InnoDB の I/O パフォーマンスに関する一般的な情報については、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.7 InnoDB ディスク I/O の最適化">セクション8.5.7「InnoDB ディスク I/O の最適化」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_io_capacity_max"></a>
          <a class="indexterm" name="idm139979067294768"></a> <code class="literal">innodb_io_capacity_max</code>
        </p><div class="informaltable"><table summary="Options for innodb_io_capacity_max" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.6</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_io_capacity_max=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_io_capacity_max">innodb_io_capacity_max</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (32 ビットプラットフォーム)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">see description</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">2000</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">2**32-1</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (Unix, 64 ビットプラットフォーム)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">see description</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">2000</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">2**64-1</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (Windows, 64 ビットプラットフォーム)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">2000</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">2000</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">2**32-1</code></td></tr></tbody></table></div><p>
          緊急時に <code class="literal">innodb_io_capacity</code> の設定を拡張する際に、<code class="literal">InnoDB</code> で許可されている上限です。起動時に <code class="literal">innodb_io_capacity</code> の設定を指定し、<code class="literal">innodb_io_capacity_max</code> に値を指定しない場合は、<code class="literal">innodb_io_capacity_max</code> のデフォルト値が <code class="literal">innodb_io_capacity</code> の 2 倍となり、下限が 2000 となります。また、2000 は初期のデフォルト <code class="literal">innodb_io_capacity_max</code> 構成値です。
        </p><p>
          <code class="literal">innodb_io_capacity_max</code> 設定は、すべてのバッファープールインスタンスに対する合計の制限です。
        </p><p>
          MySQL 5.6 開発中の短期間は、この変数は <code class="literal">innodb_max_io_capacity</code> と呼ばれていました。MySQL 5.6.7 では、<code class="literal">innodb_io_capacity</code> オプションとの関係を強調するために、<code class="literal">innodb_io_capacity_max</code> という名前に変更されました。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_large_prefix"></a>
          <a class="indexterm" name="idm139979067233312"></a> <a class="indexterm" name="idm139979067231760"></a> <code class="literal">innodb_large_prefix</code>
        </p><div class="informaltable"><table summary="Options for innodb_large_prefix" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.3</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_large_prefix</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_large_prefix">innodb_large_prefix</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr></tbody></table></div><p>
          このオプションを有効にすると、<code class="literal"><a class="link" href="glossary.html#glos_dynamic_row_format" title="動的行フォーマット">DYNAMIC</a></code> および <code class="literal"><a class="link" href="glossary.html#glos_compressed_row_format" title="圧縮行フォーマット">COMPRESSED</a></code> 行フォーマットを使用する <code class="literal">InnoDB</code> テーブルで、767 バイトよりも長い (最大で 3072 バイトの) <a class="link" href="glossary.html#glos_index_prefix" title="インデックスプリフィクス">インデックスキープリフィクス</a>が許可されます。(このようなテーブルの作成には、<code class="literal">innodb_file_format=barracuda</code> および <code class="literal">innodb_file_per_table=true</code> のオプション値も必要になります。)さまざまな設定でインデックスキープリフィクスに関連付けられた関連性の最大値については、<a class="xref" href="innodb-storage-engine.html#innodb-restrictions" title="14.6.7 InnoDB テーブル上の制限">セクション14.6.7「InnoDB テーブル上の制限」</a>を参照してください。
        </p><p>
          <code class="literal"><a class="link" href="glossary.html#glos_redundant_row_format" title="冗長行フォーマット">REDUNDANT</a></code> および <code class="literal"><a class="link" href="glossary.html#glos_compact_row_format" title="コンパクト行フォーマット">COMPACT</a></code> 行フォーマットを使用したテーブルでは、このオプションによってキープリフィクスの長さは影響を受けません。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_lock_wait_timeout"></a>
          <a class="indexterm" name="idm139979067195104"></a> <a class="indexterm" name="idm139979067193552"></a> <code class="literal">innodb_lock_wait_timeout</code>
        </p><div class="informaltable"><table summary="Options for innodb_lock_wait_timeout" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_lock_wait_timeout=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_lock_wait_timeout">innodb_lock_wait_timeout</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル、セッション</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">50</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">1073741824</code></td></tr></tbody></table></div><p>
          <a class="link" href="glossary.html#glos_row_lock" title="行ロック">行ロック</a>が解除されるまで <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a>が待機する時間の長さ (秒単位) です。デフォルト値は 50 秒です。別の <code class="literal">InnoDB</code> トランザクションでロックされている行へのアクセスを試みるトランザクションは、行への書き込みアクセスを最大でこの秒数間待機してから、次のエラーを発行します。
        </p><pre class="programlisting">
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
</pre><p>
          ロック待機のタイムアウトが発生すると、(トランザクション全体ではなく) 現在のステートメントが<a class="link" href="glossary.html#glos_rollback" title="ロールバック">ロールバック</a>されます。トランザクション全体をロールバックするには、<code class="option">--innodb_rollback_on_timeout</code> オプションを付けてサーバーを起動します。<a class="xref" href="innodb-storage-engine.html#innodb-error-handling" title="14.19.4 InnoDB のエラー処理">セクション14.19.4「InnoDB のエラー処理」</a>も参照してください。
        </p><p>
          高度にインタラクティブなアプリケーションまたは <a class="link" href="glossary.html#glos_oltp" title="OLTP">OLTP</a> システムでは、ユーザーのフィードバックをすばやく表示したり、あとで処理するために更新をキューに入れたりするために、この値を小さくするとよいでしょう。長時間実行されるバックエンド操作 (その他の大規模な挿入操作や更新操作が完了するまで待機するデータウェアハウスでの変換ステップなど) では、この値を大きくするとよいでしょう。
        </p><p>
          <code class="literal">innodb_lock_wait_timeout</code> は <code class="literal">InnoDB</code> の行ロックにのみ適用されます。MySQL の<a class="link" href="glossary.html#glos_table_lock" title="テーブルロック">テーブルロック</a>は <code class="literal">InnoDB</code> 内部では発生せず、このタイムアウトはテーブルロックの待機には適用されません。
        </p><p>
          <a class="link" href="glossary.html#glos_deadlock" title="デッドロック">デッドロック</a>は <code class="literal">InnoDB</code> によってすぐに検出され、デッドロックになったトランザクションのいずれかがロールバックされるため、デッドロックにはロック待機のタイムアウト値が適用されません。
        </p><p>
          <code class="literal">innodb_lock_wait_timeout</code> は、実行時に <code class="literal">SET GLOBAL</code> または <code class="literal">SET SESSION</code> ステートメントとともに設定できます。<code class="literal">GLOBAL</code> 値を変更するには、<code class="literal">SUPER</code> 権限が必要です。これを変更すると、それ以降に接続するすべてのクライアントの操作が影響を受けます。任意のクライアントが <code class="literal">innodb_lock_wait_timeout</code> の <code class="literal">SESSION</code> 設定を変更でき、そのクライアントのみが影響を受けます。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_locks_unsafe_for_binlog"></a>
          <a class="indexterm" name="idm139979067143392"></a> <a class="indexterm" name="idm139979067141920"></a> <code class="literal">innodb_locks_unsafe_for_binlog</code>
        </p><div class="informaltable"><table summary="Options for innodb_locks_unsafe_for_binlog" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>非推奨</strong></span></td><td colspan="3">5.6.3</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_locks_unsafe_for_binlog</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_locks_unsafe_for_binlog">innodb_locks_unsafe_for_binlog</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr></tbody></table></div><a class="indexterm" name="idm139979067118112"></a><a class="indexterm" name="idm139979067115936"></a><a class="indexterm" name="idm139979067113872"></a><a class="indexterm" name="idm139979067111808"></a><a class="indexterm" name="idm139979067109776"></a><a class="indexterm" name="idm139979067107712"></a><a class="indexterm" name="idm139979067105760"></a><a class="indexterm" name="idm139979067103696"></a><a class="indexterm" name="idm139979067101632"></a><a class="indexterm" name="idm139979067099600"></a><p>
          この変数によって、<code class="literal">InnoDB</code> が検索およびインデックススキャンで<a class="link" href="glossary.html#glos_gap_lock" title="ギャップロック">ギャップロック</a>を使用する方法が影響を受けます。MySQL 5.6.3 の時点では、<code class="literal">innodb_locks_unsafe_for_binlog</code> は非推奨となり、今後の MySQL リリースで削除される予定です。
        </p><p>
          通常、<code class="literal">InnoDB</code> では、インデックス行ロックと<a class="link" href="glossary.html#glos_gap_lock" title="ギャップロック">ギャップロック</a>を組み合わせた「ネクストキーロック」と呼ばれるアルゴリズムが使用されます。<code class="literal">InnoDB</code> は、テーブルインデックスを検索またはスキャンするときに、生成されたインデックスレコード上に共有ロックまたは排他ロックを設定するという方法で、行レベルロックを実行します。したがって、行レベルロックは、実際にはインデックスレコードロックです。さらに、あるインデックスレコードに対するネクストキーロックによって、そのインデックスレコードの前の<span class="quote">「<span class="quote">ギャップ</span>」</span>も影響を受けます。つまり、ネクストキーロックは、インデックスレコードロックと、そのインデックスレコードの前のギャップに対するギャップロックとを組み合わせたものです。あるセッションがインデックス内のレコード <code class="literal">R</code> 上に共有ロックまたは排他ロックを持っている場合は、別のセッションがインデックスの順番で <code class="literal">R</code> の直前にあるギャップに新しいインデックスレコードを挿入できません。<a class="xref" href="innodb-storage-engine.html#innodb-record-level-locks" title="14.2.6 InnoDB のレコード、ギャップ、およびネクストキーロック">セクション14.2.6「InnoDB のレコード、ギャップ、およびネクストキーロック」</a>を参照してください。
        </p><p>
          <code class="literal">innodb_locks_unsafe_for_binlog</code> の値はデフォルトで 0 (無効) になっていますが、これは、ギャップロックが有効であることを意味します。<code class="literal">InnoDB</code> はネクストキーロックを使用して、検索およびインデックススキャンを実行します。この変数を有効にするには、値を 1 に設定します。これにより、ギャップロックが無効になります。<code class="literal">InnoDB</code> はインデックスレコードロックのみを使用して、検索およびインデックススキャンを実行します。
        </p><p>
          <code class="literal">innodb_locks_unsafe_for_binlog</code> を有効にしても、外部キー制約チェックや重複キーチェックでのギャップロックの使用は無効になりません。
        </p><p>
          <code class="literal">innodb_locks_unsafe_for_binlog</code> を有効にした場合の影響は、トランザクション分離レベルを <code class="literal">READ COMMITTED</code> に設定した場合の影響に似ていますが、同じではありません。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">innodb_locks_unsafe_for_binlog</code> を有効にすることはグローバルな設定であるため、すべてのセッションが影響を受けます。その一方で、分離レベルは、すべてのセッションに対してグローバルに設定することも、セッションごとに個別に設定することもできます。
            </p></li><li class="listitem"><p>
              <code class="literal">innodb_locks_unsafe_for_binlog</code> はサーバー起動時にしか設定できないのに対して、分離レベルは起動時に設定することも、実行時に変更することもできます。
            </p></li></ul></div><p>
          したがって、<code class="literal">READ COMMITTED</code> では <code class="literal">innodb_locks_unsafe_for_binlog</code> よりも細かく柔軟な制御が提供されます。ギャップロックに対する分離レベルの影響に関する追加の詳細については、<a class="xref" href="sql-syntax.html#set-transaction" title="13.3.6 SET TRANSACTION 構文">セクション13.3.6「SET TRANSACTION 構文」</a>を参照してください。
        </p><p>
          ギャップロックが無効になるとほかのセッションが新しい行をギャップに挿入できるため、<code class="literal">innodb_locks_unsafe_for_binlog</code> を有効にすると、ファントムの問題が発生する可能性があります。<code class="literal">child</code> テーブルの <code class="literal">id</code> カラム上にインデックスがあり、識別子の値が 100 よりも大きいすべての行をテーブルから読み取り、選択された行の一部のカラムをあとで更新するという意図でロックすると仮定します。
        </p><pre class="programlisting">
SELECT * FROM child WHERE id &gt; 100 FOR UPDATE;
</pre><p>
          クエリーでは、<code class="literal">id</code> が 100 より大きい最初のレコードからインデックスがスキャンされます。その範囲内のインデックスレコード上に設定されたロックによって、ギャップへの挿入がロックアウトされていない場合は、別のセッションがそのテーブルに新しい行を挿入できます。したがって、同じトランザクション内で同じ <code class="literal">SELECT</code> を再度実行すると、クエリーから返された結果セット内に新しい行を見つけることができます。これは、データベースに新しい項目が追加された場合は、<code class="literal">InnoDB</code> で直列化可能性が保証されないことも意味します。したがって、<code class="literal">innodb_locks_unsafe_for_binlog</code> が有効な場合に <code class="literal">InnoDB</code> によって保証される最大の分離レベルは、<code class="literal">READ COMMITTED</code> になります。(競合直列化可能性は引き続き保証されます。)ファントムの追加情報については、<a class="xref" href="innodb-storage-engine.html#innodb-next-key-locking" title="14.2.7 ネクストキーロックによるファントム問題の回避">セクション14.2.7「ネクストキーロックによるファントム問題の回避」</a>を参照してください。
        </p><p>
          <code class="literal">innodb_locks_unsafe_for_binlog</code> を有効にした場合には、次のような影響も発生します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">UPDATE</code> または <code class="literal">DELETE</code> ステートメントでは、<code class="literal">InnoDB</code> は更新または削除の対象となる行に対してのみ、ロックを保持します。一致しなかった行のレコードロックは、MySQL による <code class="literal">WHERE</code> 条件の評価後に解除されます。これにより、デッドロックの可能性が大幅に低くなりますが、まだ発生する可能性はあります。
            </p></li><li class="listitem"><p>
              <code class="literal">UPDATE</code> ステートメントである行がすでにロックされていた場合、<code class="literal">InnoDB</code> は <span class="quote">「<span class="quote">半一貫性</span>」</span> 読み取りを実行し、最後にコミットされたバージョンを MySQL に返すため、MySQL はその行が <code class="literal">UPDATE</code> の <code class="literal">WHERE</code> 条件に一致するかどうかを判断できます。その行が一致した場合 (その行を更新する必要がある場合)、MySQL はその行を再度読み取り、<code class="literal">InnoDB</code> は今度はその行をロックするか、その行のロックが解除されるまで待機します。
            </p></li></ul></div><p>
          次のような例について、このテーブルから検討します。
        </p><pre class="programlisting">
CREATE TABLE t (a INT NOT NULL, b INT) ENGINE = InnoDB;
INSERT INTO t VALUES (1,2),(2,3),(3,2),(4,3),(5,2);
COMMIT;
</pre><p>
          この場合は、テーブルにインデックスが設定されていないため、検索およびインデックススキャンでは、非表示のクラスタ化されたインデックスを使用してレコードのロックが行われます (<a class="xref" href="innodb-storage-engine.html#innodb-index-types" title="14.2.13.2 クラスタインデックスとセカンダリインデックス">セクション14.2.13.2「クラスタインデックスとセカンダリインデックス」</a>を参照してください)。
        </p><p>
          あるクライアントが次のステートメントを使用して、<code class="literal">UPDATE</code> を実行すると仮定します。
        </p><pre class="programlisting">
SET autocommit = 0;
UPDATE t SET b = 5 WHERE b = 3;
</pre><p>
          また、2 番目のクライアントが 1 番目のクライアントの実行後に次のステートメントを実行することで、<code class="literal">UPDATE</code> を実行すると仮定します。
        </p><pre class="programlisting">
SET autocommit = 0;
UPDATE t SET b = 4 WHERE b = 2;
</pre><p>
          <code class="literal">InnoDB</code> は各 <code class="literal">UPDATE</code> を実行する際に、まず各行の排他ロックを取得し、次にその行を変更するかどうかを判断します。<code class="literal">InnoDB</code> がその行を変更せず、かつ <code class="literal">innodb_locks_unsafe_for_binlog</code> が有効な場合は、そのロックが解除されます。それ以外の場合、トランザクションが終了するまで <code class="literal">InnoDB</code> はそのロックを保持します。これにより、トランザクション処理が次のような影響を受けます。
        </p><p>
          <code class="literal">innodb_locks_unsafe_for_binlog</code> が無効な場合は次のように、最初の <code class="literal">UPDATE</code> は X ロックを取得し、そのいずれも解除しません。
        </p><pre class="programlisting">
x-lock(1,2); retain x-lock
x-lock(2,3); update(2,3) to (2,5); retain x-lock
x-lock(3,2); retain x-lock
x-lock(4,3); update(4,3) to (4,5); retain x-lock
x-lock(5,2); retain x-lock
</pre><p>
          次のように、2 番目の <code class="literal">UPDATE</code> は (1 番目の更新がすべての行のロックを保持しているため)、ロックを取得しようとしてもすぐにブロックされ、1 番目の <code class="literal">UPDATE</code> がコミットまたはロールバックを実行するまで続行されません。
        </p><pre class="programlisting">
x-lock(1,2); block and wait for first UPDATE to commit or roll back
</pre><p>
          <code class="literal">innodb_locks_unsafe_for_binlog</code> が有効な場合は次のように、最初の <code class="literal">UPDATE</code> は X ロックを取得したあとに、変更されない行のロックを解除します。
        </p><pre class="programlisting">
x-lock(1,2); unlock(1,2)
x-lock(2,3); update(2,3) to (2,5); retain x-lock
x-lock(3,2); unlock(3,2)
x-lock(4,3); update(4,3) to (4,5); retain x-lock
x-lock(5,2); unlock(5,2)
</pre><p>
          2 番目の <code class="literal">UPDATE</code> では次のように、<code class="literal">InnoDB</code> は <span class="quote">「<span class="quote">半一貫性</span>」</span> 読み取りを行い、最後にコミットされたバージョンを MySQL に返すため、MySQL はその行が <code class="literal">UPDATE</code> の <code class="literal">WHERE</code> 条件に一致するかどうかを判断できます。
        </p><pre class="programlisting">
x-lock(1,2); update(1,2) to (1,4); retain x-lock
x-lock(2,3); unlock(2,3)
x-lock(3,2); update(3,2) to (3,4); retain x-lock
x-lock(4,3); unlock(4,3)
x-lock(5,2); update(5,2) to (5,4); retain x-lock
</pre></li><li class="listitem"><p><a name="sysvar_innodb_log_buffer_size"></a>
          <a class="indexterm" name="idm139979067016704"></a> <a class="indexterm" name="idm139979067015152"></a> <code class="literal">innodb_log_buffer_size</code>
        </p><div class="informaltable"><table summary="Options for innodb_log_buffer_size" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_log_buffer_size=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_buffer_size">innodb_log_buffer_size</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">8388608</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">262144</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">4294967295</code></td></tr></tbody></table></div><p>
          ディスク上の<a class="link" href="glossary.html#glos_log_file" title="ログファイル">ログファイル</a>に書き込む際に <code class="literal">InnoDB</code> で使用されるバッファーのサイズ (バイト単位) です。デフォルトの値は 8M バイトです。<a class="link" href="glossary.html#glos_log_buffer" title="ログバッファー">ログバッファー</a>を大きくすると、トランザクションが<a class="link" href="glossary.html#glos_commit" title="コミット">コミット</a>する前にディスクにログを書き込まなくても、大規模な<a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a>を実行できます。したがって、多数の行を更新、挿入、または削除するトランザクションの場合、ログバッファーを大きくすると、ディスク I/O を節約できます。一般的な I/O チューニングのアドバイスについては、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.7 InnoDB ディスク I/O の最適化">セクション8.5.7「InnoDB ディスク I/O の最適化」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_log_compressed_pages"></a>
          <a class="indexterm" name="idm139979066981856"></a> <code class="literal">innodb_log_compressed_pages</code>
        </p><div class="informaltable"><table summary="Options for innodb_log_compressed_pages" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.11</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_log_compressed_pages=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_compressed_pages">innodb_log_compressed_pages</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">ON</code></td></tr></tbody></table></div><p>
          <a class="link" href="glossary.html#glos_compression" title="圧縮">再圧縮された</a><a class="link" href="glossary.html#glos_page" title="ページ">ページ</a>のイメージが <code class="literal">InnoDB</code> の <a class="link" href="glossary.html#glos_redo_log" title="Redo ログ">Redo ログ</a>に格納されるかどうかを指定します。
        </p><p>
          この変数は MySQL 5.6.11 で追加されました。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_log_file_size"></a>
          <a class="indexterm" name="idm139979066952672"></a> <a class="indexterm" name="idm139979066951120"></a> <code class="literal">innodb_log_file_size</code>
        </p><div class="informaltable"><table summary="Options for innodb_log_file_size" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_log_file_size=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_file_size">innodb_log_file_size</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (&lt;= 5.6.2)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">5242880</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1048576</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">4GB / innodb_log_files_in_group</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (&gt;= 5.6.3, &lt;= 5.6.7)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">5242880</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1048576</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">512GB / innodb_log_files_in_group</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (&gt;= 5.6.8)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">50331648</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1048576</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">512GB / innodb_log_files_in_group</code></td></tr></tbody></table></div><p>
          <a class="link" href="glossary.html#glos_log_group" title="ロググループ">ロググループ</a>内の各<a class="link" href="glossary.html#glos_log_file" title="ログファイル">ログファイル</a>のサイズ (バイト単位) です。ログファイルを結合したサイズ (<code class="literal">innodb_log_file_size</code> * <code class="literal">innodb_log_files_in_group</code>) は、512G バイトよりもわずかに小さい最大値を上回ることができません。たとえば、255G バイトのログファイルのペアを使用すれば、制限に近づくことはできますが、上回ることはできません。デフォルト値は 48M バイトです。適切な値の範囲は、1M バイトから 1/<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>の <em class="replaceable"><code>N</code></em> 番目のサイズまでです。ここで、<em class="replaceable"><code>N</code></em> はグループ内のログファイルの数です。値を大きくするほど、バッファープール内で必要となるチェックポイントフラッシュアクティビティーの数が少なくなるため、ディスク I/O を節約できます。また、ログファイルを大きくすると、<a class="link" href="glossary.html#glos_crash_recovery" title="クラッシュリカバリ">クラッシュリカバリ</a>の速度が遅くなります。ただし、MySQL 5.5 以上ではリカバリのパフォーマンスが改善されているため、ログファイルのサイズに対する考慮事項も少なくなります。一般的な I/O チューニングのアドバイスについては、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.7 InnoDB ディスク I/O の最適化">セクション8.5.7「InnoDB ディスク I/O の最適化」</a>を参照してください。
        </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
            Bug #69477 が原因で、外部に格納された大きな <code class="literal">BLOB</code> フィールドに対する Redo ログの書き込みによって、最新のチェックポイントが上書きされる可能性があります。このバグに対処するために MySQL 5.6.20 で導入されたパッチを適用すれば、<code class="literal">BLOB</code> で書き込まれる Redo ログのサイズが Redo ログファイルサイズの 10% に制限されます。この制限の結果として、<code class="literal">innodb_log_file_size</code> は、テーブルの行で見つかった最大の <code class="literal">BLOB</code> データサイズの 10 倍よりも大きい値に、その他の変数の長さフィールド (<code class="literal">VARCHAR</code>、<code class="literal">VARBINARY</code>、および <code class="literal">TEXT</code> 型のフィールド) の長さを加えた値に設定されるはずです。
          </p><p>
            MySQL 5.6.22 では、Redo ログ <code class="literal">BLOB</code> の書き込み制限は <span class="emphasis"><em>合計 Redo ログサイズ</em></span> (<code class="literal">innodb_log_file_size</code> * <code class="literal">innodb_log_files_in_group</code>) の 10% に緩められました。(Bug #19498877)
          </p></div></li><li class="listitem"><p><a name="sysvar_innodb_log_files_in_group"></a>
          <a class="indexterm" name="idm139979066881136"></a> <a class="indexterm" name="idm139979066879664"></a> <code class="literal">innodb_log_files_in_group</code>
        </p><div class="informaltable"><table summary="Options for innodb_log_files_in_group" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_log_files_in_group=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_files_in_group">innodb_log_files_in_group</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">2</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">2</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">100</code></td></tr></tbody></table></div><p>
          <a class="link" href="glossary.html#glos_log_group" title="ロググループ">ロググループ</a>内の<a class="link" href="glossary.html#glos_log_file" title="ログファイル">ログファイル</a>の数です。<code class="literal">InnoDB</code> はファイルに輪状に書き込みをします。デフォルト (推奨) 値は 2 です。これらのファイルの場所は、<code class="literal">innodb_log_group_home_dir</code> で指定されます。ログファイルを結合したサイズ (<code class="literal">innodb_log_file_size</code> * <code class="literal">innodb_log_files_in_group</code>) は、最大で 512G バイトにすることができます。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_log_group_home_dir"></a>
          <a class="indexterm" name="idm139979066846160"></a> <a class="indexterm" name="idm139979066844688"></a> <code class="literal">innodb_log_group_home_dir</code>
        </p><div class="informaltable"><table summary="Options for innodb_log_group_home_dir" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_log_group_home_dir=path</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_group_home_dir">innodb_log_group_home_dir</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ディレクトリ名</code></td></tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> の <a class="link" href="glossary.html#glos_redo_log" title="Redo ログ">Redo ログ</a>ファイルへのディレクトリパスです。この数は、<code class="literal">innodb_log_files_in_group</code> で指定されます。どの <code class="literal">InnoDB</code> ログ変数も指定しない場合は、デフォルトで、MySQL データディレクトリ内に <code class="filename">ib_logfile0</code> および <code class="filename">ib_logfile1</code> という名前の 2 つのファイルが作成されます。これらのサイズは、<code class="literal">innodb_log_file_size</code> システム変数のサイズで指定されます。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_lru_scan_depth"></a>
          <a class="indexterm" name="idm139979066817136"></a> <code class="literal">innodb_lru_scan_depth</code>
        </p><div class="informaltable"><table summary="Options for innodb_lru_scan_depth" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.3</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_lru_scan_depth=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_lru_scan_depth">innodb_lru_scan_depth</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (32 ビットプラットフォーム)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">1024</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">100</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">2**32-1</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (64 ビットプラットフォーム)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">1024</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">100</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">2**64-1</code></td></tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>での<a class="link" href="glossary.html#glos_flush" title="フラッシュ">フラッシュ</a>操作のアルゴリズムおよびヒューリスティクスに影響を与えるパラメータです。主に、I/O インテンシブなワークロードを調整するパフォーマンスの専門家が関心を持つものです。バッファープールインスタンスごとに、<code class="literal">page_cleaner</code> スレッドがフラッシュする<a class="link" href="glossary.html#glos_dirty_page" title="ダーティーページ">ダーティーページ</a>を検索する際に、どのくらいの深さまでバッファープール LRU リストをスキャンするのかが指定されます。これは、1 秒ごとに 1 回実行されるバックグラウンド操作です。一般的なワークロードで予備の I/O 容量を持っている場合は、この値を大きくします。書き込みが集中するワークロードで I/O 容量がいっぱいになった場合は、この値を小さくします (特に大きなバッファープールを持っている場合)。一般的な I/O チューニングのアドバイスについては、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.7 InnoDB ディスク I/O の最適化">セクション8.5.7「InnoDB ディスク I/O の最適化」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_max_dirty_pages_pct"></a>
          <a class="indexterm" name="idm139979066771344"></a> <a class="indexterm" name="idm139979066769872"></a> <code class="literal">innodb_max_dirty_pages_pct</code>
        </p><div class="informaltable"><table summary="Options for innodb_max_dirty_pages_pct" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_max_dirty_pages_pct=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_dirty_pages_pct">innodb_max_dirty_pages_pct</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">75</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">99</code></td></tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> は、<a class="link" href="glossary.html#glos_dirty_page" title="ダーティーページ">ダーティーページ</a>の割合がこの値を超えないように、<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>からデータを<a class="link" href="glossary.html#glos_flush" title="フラッシュ">フラッシュ</a>しようと試みます。0 から 99 までの範囲内の整数を指定します。デフォルト値は 75 です。
        </p><p>
          <code class="literal">innodb_max_dirty_pages_pct</code> 設定は、フラッシュアクティビティーのターゲットを確立します。フラッシュの頻度には影響を与えません。フラッシュの頻度の管理については、<a class="xref" href="innodb-storage-engine.html#innodb-performance-adaptive_flushing" title="14.13.1.2 InnoDB バッファープールのフラッシュの頻度の構成">セクション14.13.1.2「InnoDB バッファープールのフラッシュの頻度の構成」</a>を参照してください。
        </p><p>
          この変数に関する追加情報については、<a class="xref" href="innodb-storage-engine.html#innodb-lru-background-flushing" title="14.13.1.6 InnoDB バッファープールのフラッシュのチューニング">セクション14.13.1.6「InnoDB バッファープールのフラッシュのチューニング」</a>を参照してください。一般的な I/O チューニングのアドバイスについては、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.7 InnoDB ディスク I/O の最適化">セクション8.5.7「InnoDB ディスク I/O の最適化」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_max_dirty_pages_pct_lwm"></a>
          <a class="indexterm" name="idm139979066732528"></a> <code class="literal">innodb_max_dirty_pages_pct_lwm</code>
        </p><div class="informaltable"><table summary="Options for innodb_max_dirty_pages_pct_lwm" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.6</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_max_dirty_pages_pct_lwm=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_dirty_pages_pct_lwm">innodb_max_dirty_pages_pct_lwm</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">99</code></td></tr></tbody></table></div><p>
          ダーティーページの比率を制御するために事前フラッシュが有効になっている場合に、<a class="link" href="glossary.html#glos_dirty_page" title="ダーティーページ">ダーティーページ</a>の割合を表す低位境界値です。デフォルトの 0 では、事前フラッシュの動作が完全に無効になります。この変数に関する追加情報については、<a class="xref" href="innodb-storage-engine.html#innodb-lru-background-flushing" title="14.13.1.6 InnoDB バッファープールのフラッシュのチューニング">セクション14.13.1.6「InnoDB バッファープールのフラッシュのチューニング」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_max_purge_lag"></a>
          <a class="indexterm" name="idm139979066701360"></a> <a class="indexterm" name="idm139979066699808"></a> <code class="literal">innodb_max_purge_lag</code>
        </p><div class="informaltable"><table summary="Options for innodb_max_purge_lag" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_max_purge_lag=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_purge_lag">innodb_max_purge_lag</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">4294967295</code></td></tr></tbody></table></div><p>
          この変数は、<a class="link" href="glossary.html#glos_purge" title="パージ">パージ</a>操作が遅れたときに、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、および <code class="literal">DELETE</code> 操作を遅延させる方法を制御します (<a class="xref" href="innodb-storage-engine.html#innodb-multi-versioning" title="14.2.12 InnoDB マルチバージョン">セクション14.2.12「InnoDB マルチバージョン」</a>を参照してください)。デフォルト値は 0 (遅延なし) です。
        </p><p>
          <code class="literal">InnoDB</code> トランザクションシステムでは、<code class="literal">UPDATE</code> または <code class="literal">DELETE</code> 操作で削除のマークが付けられたインデックスレコードを含むトランザクションのリストが保持されます。<em class="replaceable"><code>purge_lag</code></em> の値は、このリストの長さを表しています。<em class="replaceable"><code>purge_lag</code></em> が <code class="literal">innodb_max_purge_lag</code> を超えると、各 <code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、および <code class="literal">DELETE</code> 操作が遅延します。
        </p><p>
          <em class="replaceable"><code>purge_lag</code></em> が非常に大きくなるような極端な状況で、過剰な遅延を回避するには、<code class="literal">innodb_max_purge_lag_delay</code> 構成オプションを設定すれば、遅延の量に上限を設定できます。遅延は、パージバッチの開始時に計算されます。
        </p><p>
          トランザクションが小規模 (100 バイト程度のサイズ) であり、許可されている未パージの <code class="literal">InnoDB</code> テーブル行が 100M バイトであると仮定すると、問題のあるワークロードに適した一般的な設定が 100 万になる可能性があります。
        </p><p>
          遅延の値は、InnoDB Monitor 出力の <code class="literal">TRANSACTIONS</code> セクションに履歴リストの長さとして表示されます。たとえば、出力に次の行が含まれている場合は、遅延の値が 20 です。
        </p><pre class="programlisting">
------------
TRANSACTIONS
------------
Trx id counter 0 290328385
Purge done for trx's n:o &lt; 0 290315608 undo n:o &lt; 0 17
History list length 20
</pre><p>
          一般的な I/O チューニングのアドバイスについては、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.7 InnoDB ディスク I/O の最適化">セクション8.5.7「InnoDB ディスク I/O の最適化」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_max_purge_lag_delay"></a>
          <a class="indexterm" name="idm139979066651024"></a> <a class="indexterm" name="idm139979066649552"></a> <code class="literal">innodb_max_purge_lag_delay</code>
        </p><div class="informaltable"><table summary="Options for innodb_max_purge_lag_delay" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.5</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_max_purge_lag_delay=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_max_purge_lag_delay">innodb_max_purge_lag_delay</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr></tbody></table></div><p>
          <code class="literal">innodb_max_purge_lag</code> 構成オプションで課された遅延の最大遅延をミリ秒単位で指定します。ゼロ以外の値は、<code class="literal">innodb_max_purge_lag</code> の値に基づいて、公式から計算された遅延期間への上限を表します。デフォルトのゼロは、遅延間隔に上限が課されていないことを意味します。
        </p><p>
          一般的な I/O チューニングのアドバイスについては、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.7 InnoDB ディスク I/O の最適化">セクション8.5.7「InnoDB ディスク I/O の最適化」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_mirrored_log_groups"></a>
          <a class="indexterm" name="idm139979066618400"></a> <a class="indexterm" name="idm139979066616928"></a> <code class="literal">innodb_mirrored_log_groups</code>
        </p><p>
          効果はありません。この変数は MySQL 5.6.11 の時点で非推奨となり、将来の MySQL リリースで削除される予定です。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_monitor_disable"></a>
          <a class="indexterm" name="idm139979066612176"></a> <code class="literal">innodb_monitor_disable</code>
        </p><div class="informaltable"><table summary="Options for innodb_monitor_disable" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.2</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_monitor_disable=[counter|module|pattern|all]</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_disable">innodb_monitor_disable</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr></tbody></table></div><p>
          <code class="literal">INFORMATION_SCHEMA.INNODB_METRICS</code> テーブルで 1 つ以上の<a class="link" href="glossary.html#glos_counter" title="カウンタ">カウンタ</a>をオフにします。使用法については、<a class="xref" href="information-schema.html#innodb-metrics-table" title="21.29.19 INFORMATION_SCHEMA INNODB_METRICS テーブル">セクション21.29.19「INFORMATION_SCHEMA INNODB_METRICS テーブル」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_monitor_enable"></a>
          <a class="indexterm" name="idm139979066586752"></a> <code class="literal">innodb_monitor_enable</code>
        </p><div class="informaltable"><table summary="Options for innodb_monitor_enable" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.2</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_monitor_enable=[counter|module|pattern|all]</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_enable">innodb_monitor_enable</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr></tbody></table></div><p>
          <code class="literal">INFORMATION_SCHEMA.INNODB_METRICS</code> テーブルで 1 つ以上の<a class="link" href="glossary.html#glos_counter" title="カウンタ">カウンタ</a>をオンにします。使用法については、<a class="xref" href="information-schema.html#innodb-metrics-table" title="21.29.19 INFORMATION_SCHEMA INNODB_METRICS テーブル">セクション21.29.19「INFORMATION_SCHEMA INNODB_METRICS テーブル」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_monitor_reset"></a>
          <a class="indexterm" name="idm139979066561712"></a> <code class="literal">innodb_monitor_reset</code>
        </p><div class="informaltable"><table summary="Options for innodb_monitor_reset" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.2</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_monitor_reset=[counter|module|pattern|all]</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_reset">innodb_monitor_reset</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr></tbody></table></div><p>
          <code class="literal">INFORMATION_SCHEMA.INNODB_METRICS</code> テーブルで 1 つ以上の<a class="link" href="glossary.html#glos_counter" title="カウンタ">カウンタ</a>に対応するカウント値をゼロにリセットします。使用法については、<a class="xref" href="information-schema.html#innodb-metrics-table" title="21.29.19 INFORMATION_SCHEMA INNODB_METRICS テーブル">セクション21.29.19「INFORMATION_SCHEMA INNODB_METRICS テーブル」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_monitor_reset_all"></a>
          <a class="indexterm" name="idm139979066536624"></a> <code class="literal">innodb_monitor_reset_all</code>
        </p><div class="informaltable"><table summary="Options for innodb_monitor_reset_all" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.2</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_monitor_reset_all=[counter|module|pattern|all]</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_monitor_reset_all">innodb_monitor_reset_all</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">文字列</code></td></tr></tbody></table></div><p>
          <code class="literal">INFORMATION_SCHEMA.INNODB_METRICS</code> テーブルで 1 つ以上の<a class="link" href="glossary.html#glos_counter" title="カウンタ">カウンタ</a>に対応するすべての値 (最小、最大など) をリセットします。使用法については、<a class="xref" href="information-schema.html#innodb-metrics-table" title="21.29.19 INFORMATION_SCHEMA INNODB_METRICS テーブル">セクション21.29.19「INFORMATION_SCHEMA INNODB_METRICS テーブル」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_old_blocks_pct"></a>
          <a class="indexterm" name="idm139979066511488"></a> <a class="indexterm" name="idm139979066509968"></a> <code class="literal">innodb_old_blocks_pct</code>
        </p><div class="informaltable"><table summary="Options for innodb_old_blocks_pct" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_old_blocks_pct=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_old_blocks_pct">innodb_old_blocks_pct</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">37</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">5</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">95</code></td></tr></tbody></table></div><p>
          古いブロック<a class="link" href="glossary.html#glos_sublist" title="サブリスト">サブリスト</a>で使用される <code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>の概算割合を指定します。値の範囲は 5 から 95 です。デフォルト値は 37 (つまり、プールの 3/8 ) です。多くの場合、<code class="literal">innodb_old_blocks_time</code> と組み合わせて使用されます。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-midpoint_insertion" title="14.13.1.3 バッファープールをスキャンに耐えられるようにする">セクション14.13.1.3「バッファープールをスキャンに耐えられるようにする」</a>を参照してください。<a class="link" href="glossary.html#glos_lru" title="LRU">LRU</a> アルゴリズムや<a class="link" href="glossary.html#glos_eviction" title="エビクション">エビクション</a>ポリシーなどのバッファープール管理については、<a class="xref" href="optimization.html#innodb-buffer-pool" title="8.9.1 InnoDB バッファープール">セクション8.9.1「InnoDB バッファープール」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_old_blocks_time"></a>
          <a class="indexterm" name="idm139979066475152"></a> <a class="indexterm" name="idm139979066473632"></a> <code class="literal">innodb_old_blocks_time</code>
        </p><div class="informaltable"><table summary="Options for innodb_old_blocks_time" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_old_blocks_time=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_old_blocks_time">innodb_old_blocks_time</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (&lt;= 5.6.5)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">2**32-1</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (&gt;= 5.6.6)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">1000</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">2**32-1</code></td></tr></tbody></table></div><p>
          ゼロ以外の値にすると、<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>が<a class="link" href="glossary.html#glos_full_table_scan" title="テーブルの完全スキャン">テーブルの完全スキャン</a>時などの短期間でのみ参照されるデータでいっぱいになることから保護されます。この値を大きくすると、テーブルの完全スキャンがバッファープール内にキャッシュされたデータとやりとりすることからさらに保護されます。
        </p><p>
          最初のアクセス後に、古い<a class="link" href="glossary.html#glos_sublist" title="サブリスト">サブリスト</a>に挿入されるブロックが新しいサブリストに移動するまでに、そこに滞在する必要のある期間をミリ秒 (ms) 単位で指定します。値を 0 にすると、古いサブリストに挿入されたブロックは、挿入後にどのくらいの期間でアクセスが発生するのかには関係なく、最初のアクセスの直後に新しいサブリストに移動します。この値が 0 より大きい場合、ブロックは最初のアクセス後、少なくともそのミリ秒でアクセスが発生するまで、古いサブリストに残ります。たとえば、1000 の値では、ブロックは最初のアクセス後、それらが新しいサブリストに移動される資格を得るまで、1 秒間古いサブリストにとどまります。
        </p><p>
          デフォルト値は、MySQL 5.6.6 の時点では 1000、それよりも前では 0 です。
        </p><p>
          多くの場合、この変数は <code class="literal">innodb_old_blocks_pct</code> と組み合わせて使用されます。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-midpoint_insertion" title="14.13.1.3 バッファープールをスキャンに耐えられるようにする">セクション14.13.1.3「バッファープールをスキャンに耐えられるようにする」</a>を参照してください。<a class="link" href="glossary.html#glos_lru" title="LRU">LRU</a> アルゴリズムや<a class="link" href="glossary.html#glos_eviction" title="エビクション">エビクション</a>ポリシーなどのバッファープール管理については、<a class="xref" href="optimization.html#innodb-buffer-pool" title="8.9.1 InnoDB バッファープール">セクション8.9.1「InnoDB バッファープール」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_online_alter_log_max_size"></a>
          <a class="indexterm" name="idm139979066425216"></a> <code class="literal">innodb_online_alter_log_max_size</code>
        </p><div class="informaltable"><table summary="Options for innodb_online_alter_log_max_size" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.6</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_online_alter_log_max_size=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_online_alter_log_max_size">innodb_online_alter_log_max_size</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">134217728</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">65536</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">2**64-1</code></td></tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> テーブルに対する<a class="link" href="glossary.html#glos_online_ddl" title="オンライン DDL">オンライン DDL</a> 操作時に使用される一時ログファイルのサイズに上限を指定します。作成されるインデックスまたは変更されるテーブルごとに、このようなログファイルが 1 つ存在します。このログファイルには、DDL 操作時にテーブルで挿入、更新、または削除されたデータが格納されます。一時ログファイルは、<code class="literal">innodb_sort_buffer_size</code> の値で必要になったときに、最大で <code class="literal">innodb_online_alter_log_max_size</code> で指定された最大値まで拡張されます。一時ログファイルがサイズの上限を超えた場合は、<code class="literal">ALTER TABLE</code> 操作に失敗し、コミットされていない並列 DML 操作がすべてロールバックされます。したがって、このオプションの値を大きくすると、オンライン DDL 操作時に実行できる DML 数は多くなりますが、ログからデータを適用するためにテーブルがロックされると、DDL 操作の終了時の期間も長くなります。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_open_files"></a>
          <a class="indexterm" name="idm139979066390192"></a> <a class="indexterm" name="idm139979066388640"></a> <code class="literal">innodb_open_files</code>
        </p><div class="informaltable"><table summary="Options for innodb_open_files" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_open_files=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_open_files">innodb_open_files</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (&lt;= 5.6.5)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">300</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">10</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">4294967295</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (&gt;= 5.6.6)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">-1 (autosized)</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">10</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">4294967295</code></td></tr></tbody></table></div><p>
          この変数は、複数の <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_tablespace" title="テーブルスペース">テーブルスペース</a>を使用する場合にのみ関連します。MySQL で一度に開いたままにできる <a class="link" href="glossary.html#glos_ibd_file" title=".ibd ファイル"><code class="filename">.ibd</code> ファイル</a>の最大数が指定されます。最小値は 10 です。MySQL 5.6.6 の時点では、<code class="literal">innodb_file_per_table</code> が無効になっている場合のデフォルト値は 300 です。それ以外の場合は、300 よりも大きい値および <code class="literal">table_open_cache</code> です。5.6.6 よりも前のデフォルト値は 300 です。
        </p><p>
          <code class="filename">.ibd</code> ファイルで使用されるファイルディスクリプタは、<code class="literal">InnoDB</code> テーブルでのみ使用されます。それらは、<code class="option">--open-files-limit</code> サーバーオプションによって指定されたものからは独立していて、テーブルキャッシュの操作に影響を与えません。一般的な I/O チューニングのアドバイスについては、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.7 InnoDB ディスク I/O の最適化">セクション8.5.7「InnoDB ディスク I/O の最適化」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_optimize_fulltext_only"></a>
          <a class="indexterm" name="idm139979066341040"></a> <code class="literal">innodb_optimize_fulltext_only</code>
        </p><div class="informaltable"><table summary="Options for innodb_optimize_fulltext_only" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.4</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_optimize_fulltext_only=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_optimize_fulltext_only">innodb_optimize_fulltext_only</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> テーブルでの <code class="literal">OPTIMIZE TABLE</code> ステートメントの動作方法を変更します。<code class="literal">FULLTEXT</code> インデックスを含む <code class="literal">InnoDB</code> テーブルのメンテナンス操作時に、一時的に有効にするために使用されます。
        </p><p>
          デフォルトでは、<code class="literal">OPTIMIZE TABLE</code> はテーブルの<a class="link" href="glossary.html#glos_clustered_index" title="クラスタ化されたインデックス">クラスタ化されたインデックス</a>内のデータを再構成します。このオプションを有効にすると、<code class="literal">OPTIMIZE TABLE</code> はこのようなテーブルデータの再構成をスキップし、その代わりに <code class="literal">FULLTEXT</code> インデックス用に新たに追加、削除、および更新されたトークンデータを処理します。<code class="literal">InnoDB</code> テーブルの <code class="literal">FULLTEXT</code> インデックスについての詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-fulltext-index" title="14.2.13.3 FULLTEXT インデックス">セクション14.2.13.3「FULLTEXT インデックス」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_page_size"></a>
          <a class="indexterm" name="idm139979066306624"></a> <code class="literal">innodb_page_size</code>
        </p><div class="informaltable"><table summary="Options for innodb_page_size" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.4</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_page_size=#k</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_page_size">innodb_page_size</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="8"><span class="bold"><strong>許可されている値</strong></span> (&gt;= 5.6.4)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">列挙</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">16384</code></td></tr><tr><td scope="row" rowspan="6" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">4k</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">8k</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">16k</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">4096</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">8192</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">16384</code></td></tr></tbody></table></div><p>
          MySQL <a class="link" href="glossary.html#glos_instance" title="インスタンス">インスタンス</a>内のすべての <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_tablespace" title="テーブルスペース">テーブルスペース</a>の<a class="link" href="glossary.html#glos_page_size" title="page size">ページサイズ</a>を指定します。この値は、インスタンスが作成されたあとに、定数が残っている場合に設定されます。ページサイズは、値 <code class="literal">16k</code> (デフォルト)、<code class="literal">8k</code>、または <code class="literal">4k</code> を使用して指定できます。また、バイト単位 (4096、8192、16384) でページサイズを指定することもできます。
        </p><p>
          最大のページサイズでは、デフォルトが広範囲の<a class="link" href="glossary.html#glos_workload" title="ワークロード">ワークロード</a> (特に、テーブルスキャンを伴うクエリーや一括更新を伴う DML 操作) に適しています。ページサイズが小さいほど、多くの小規模な書き込みを伴う <a class="link" href="glossary.html#glos_oltp" title="OLTP">OLTP</a> ワークロードの効率性が高くなる可能性があります。その一方で、単一のページに数多くの行が含まれる場合は、競合の問題が発生する可能性もあります。ページを小さくすると、一般に小さなブロックサイズが使用される <a class="link" href="glossary.html#glos_ssd" title="SSD">SSD</a> ストレージデバイスの効率性が高くなる可能性もあります。<code class="literal">InnoDB</code> のページサイズをストレージデバイスのブロックサイズに近づけると、ディスクに再度書き込まれる未変更データの量が最小限になります。一般的な I/O チューニングのアドバイスについては、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.7 InnoDB ディスク I/O の最適化">セクション8.5.7「InnoDB ディスク I/O の最適化」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_print_all_deadlocks"></a>
          <a class="indexterm" name="idm139979066260208"></a> <a class="indexterm" name="idm139979066258736"></a> <code class="literal">innodb_print_all_deadlocks</code>
        </p><div class="informaltable"><table summary="Options for innodb_print_all_deadlocks" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.2</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_print_all_deadlocks=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_print_all_deadlocks">innodb_print_all_deadlocks</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr></tbody></table></div><a class="indexterm" name="idm139979066234832"></a><p>
          このオプションを有効にすると、<code class="literal">mysqld</code> <a class="link" href="server-administration.html#error-log" title="5.2.2 エラーログ">エラーログ</a>に、<code class="literal">InnoDB</code> のユーザートランザクション内のすべての<a class="link" href="glossary.html#glos_deadlock" title="デッドロック">デッドロック</a>に関する情報が記録されます。それ以外の場合は、<code class="literal">SHOW ENGINE INNODB STATUS</code> コマンドを使用すると、最後のデッドロックに関する情報のみが表示されます。不定期に発生する <code class="literal">InnoDB</code> のデッドロックは、<code class="literal">InnoDB</code> によってすぐに状況が検出され、自動的にトランザクションのいずれかがロールバックされるため、必ずしも問題になるとは限りません。アプリケーションにロールバックを検出し、その操作を再試行するための適切なエラー処理ロジックが存在しない場合は、デッドロックが発生する原因についてトラブルシューティングを行う際に、このオプションを使用するとよいでしょう。多数のデッドロックが発生する場合は、各トランザクションが同じ順序でテーブルにアクセスするように (これにより、デッドロックの状況が回避されます)、複数のテーブルに対して <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> または <code class="literal">SELECT ... FOR UPDATE</code> ステートメントを発行するトランザクションを再構築する必要があることを示している可能性があります。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_purge_batch_size"></a>
          <a class="indexterm" name="idm139979066222880"></a> <a class="indexterm" name="idm139979066221328"></a> <code class="literal">innodb_purge_batch_size</code>
        </p><div class="informaltable"><table summary="Options for innodb_purge_batch_size" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_purge_batch_size=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_purge_batch_size">innodb_purge_batch_size</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (&lt;= 5.6.2)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">20</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">5000</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (&gt;= 5.6.3)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">300</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">5000</code></td></tr></tbody></table></div><p>
          <a class="link" href="glossary.html#glos_redo_log" title="Redo ログ">Redo ログ</a>レコードの単位で表現される変更の粒度です。これにより、<a class="link" href="glossary.html#glos_purge" title="パージ">パージ</a>操作がトリガーされ、変更された<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>ブロックがディスクにフラッシュされます。このオプションは、<code class="literal">innodb_purge_threads=<em class="replaceable"><code>n</code></em></code> 設定と組み合わせてパフォーマンスを調整するために使用されるため、一般的なユーザーは変更する必要がありません。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_purge_threads"></a>
          <a class="indexterm" name="idm139979066179248"></a> <a class="indexterm" name="idm139979066177696"></a> <code class="literal">innodb_purge_threads</code>
        </p><div class="informaltable"><table summary="Options for innodb_purge_threads" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_purge_threads=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_purge_threads">innodb_purge_threads</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (&lt;= 5.6.1)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (&gt;= 5.6.2, &lt;= 5.6.4)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">32</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (&gt;= 5.6.5)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">32</code></td></tr></tbody></table></div><p>
          InnoDB の<a class="link" href="glossary.html#glos_purge" title="パージ">パージ</a>操作専用のバックグラウンドスレッドの数です。MySQL 5.6.5 での新しいデフォルトの最小値である 1 は、パージ操作が<a class="link" href="glossary.html#glos_master_thread" title="マスタースレッド">マスタースレッド</a>の一部としてではなく、常にバックグラウンドスレッドで実行されることを表します。ゼロ以外の値にすると、1 つ以上のバックグラウンドスレッドでパージ操作が実行されるため、InnoDB 内の内部競合を削減でき、拡張性が改善されます。この値を 1 よりも大きくすると、数多くの個別のパージスレッドが作成されるため、複数のテーブル上で <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> 操作が実行されるシステムの効率性を改善できます。最大値は 32 です。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_random_read_ahead"></a>
          <a class="indexterm" name="idm139979066125664"></a> <code class="literal">innodb_random_read_ahead</code>
        </p><div class="informaltable"><table summary="Options for innodb_random_read_ahead" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.3</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_random_read_ahead=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_random_read_ahead">innodb_random_read_ahead</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> の I/O を最適化するために、ランダムな<a class="link" href="glossary.html#glos_read_ahead" title="先読み">先読み</a>技術を有効にします。ランダム先読み機能は、<code class="literal">InnoDB Plugin</code> (バージョン 1.0.4) から削除されたため、<code class="literal">InnoDB Plugin</code> が <code class="literal">InnoDB</code> の<span class="quote">「<span class="quote">組み込みの</span>」</span>バージョンになった時点では MySQL 5.5.0 に含まれていませんでした。ランダム先読みは、<code class="literal">innodb_random_read_ahead</code> 構成オプション (デフォルトでは無効になっています) とともに、MySQL 5.1.59 および 5.5.16 以降でふたたび導入されました。
        </p><p>
          さまざまなタイプの先読みリクエストに関するパフォーマンスの考慮事項についての詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-read_ahead" title="14.13.1.1 InnoDB バッファープールのプリフェッチ (先読み) の構成">セクション14.13.1.1「InnoDB バッファープールのプリフェッチ (先読み) の構成」</a>を参照してください。一般的な I/O チューニングのアドバイスについては、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.7 InnoDB ディスク I/O の最適化">セクション8.5.7「InnoDB ディスク I/O の最適化」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_read_ahead_threshold"></a>
          <a class="indexterm" name="idm139979066093264"></a> <a class="indexterm" name="idm139979066091792"></a> <code class="literal">innodb_read_ahead_threshold</code>
        </p><div class="informaltable"><table summary="Options for innodb_read_ahead_threshold" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_read_ahead_threshold=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_read_ahead_threshold">innodb_read_ahead_threshold</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">56</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">64</code></td></tr></tbody></table></div><p>
          <a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>にページをプリフェッチする際に <code class="literal">InnoDB</code> で使用される線形の<a class="link" href="glossary.html#glos_read_ahead" title="先読み">先読み</a>の感度を制御します。<code class="literal">InnoDB</code> が少なくとも <code class="literal">innodb_read_ahead_threshold</code> ページを<a class="link" href="glossary.html#glos_extent" title="エクステント">エクステント</a> (64 ページ) から連続して読み取る場合は、次のエクステント全体の非同期読み取りが開始されます。許可される値の範囲は 0 から 64 までです。MySQL 5.6.1 の時点では、値を 0 にすると先読みが無効になります。5.6.1 よりも前では、値を 0 にすると、64 ページのエクステントの境界ページを読み取るときに、先読みがトリガーされました。デフォルトの 56 では、<code class="literal">InnoDB</code> は次のエクステント全体の非同期読み取りを開始するために、少なくとも 56 ページをエクステントから連続して読み取る必要があります。
        </p><p>
          この先読みメカニズムによって読み取られるページ数、およびその中でアクセスされずにバッファープールから削除される数を把握しておくと、<code class="literal">innodb_read_ahead_threshold</code> パラメータを微調整する際に役立ちます。MySQL 5.5 の時点では、<code class="literal">SHOW ENGINE INNODB STATUS</code> の出力に、<code class="literal">Innodb_buffer_pool_read_ahead</code> および <code class="literal">Innodb_buffer_pool_read_ahead_evicted</code> グローバルステータス変数からのカウンタ情報が表示されます。これらの変数は、先読みリクエストによって<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>に格納されるページの数、およびこのようなページの中で、個別にアクセスされずにバッファープールから<a class="link" href="glossary.html#glos_eviction" title="エビクション">エビクションされる</a>数を示します。これらのカウンタには、最後にサーバーが再起動された以降のグローバルな値が表示されます。
        </p><p>
          <code class="literal">SHOW ENGINE INNODB STATUS</code> には、先読みページが読み取られる比率、およびこのようなページがアクセスされずに削除される比率も表示されます。1 秒ごとの平均値は、最後に <code class="literal">SHOW ENGINE INNODB STATUS</code> が呼び出された以降に収集された統計に基づいて計算され、出力の <code class="literal">BUFFER POOL AND MEMORY</code> セクションに表示されます。
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-read_ahead" title="14.13.1.1 InnoDB バッファープールのプリフェッチ (先読み) の構成">セクション14.13.1.1「InnoDB バッファープールのプリフェッチ (先読み) の構成」</a>を参照してください。一般的な I/O チューニングのアドバイスについては、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.7 InnoDB ディスク I/O の最適化">セクション8.5.7「InnoDB ディスク I/O の最適化」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_read_io_threads"></a>
          <a class="indexterm" name="idm139979066044592"></a> <a class="indexterm" name="idm139979066043040"></a> <code class="literal">innodb_read_io_threads</code>
        </p><div class="informaltable"><table summary="Options for innodb_read_io_threads" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_read_io_threads=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_read_io_threads">innodb_read_io_threads</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">4</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">64</code></td></tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> での読み取り操作で使用される I/O スレッドの数です。デフォルト値は 4 です。書き込みスレッドで対応するものは、<code class="literal">innodb_write_io_threads</code> です。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-multiple_io_threads" title="14.13.6 InnoDB バックグラウンド I/O スレッドの数の構成">セクション14.13.6「InnoDB バックグラウンド I/O スレッドの数の構成」</a>を参照してください。一般的な I/O チューニングのアドバイスについては、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.7 InnoDB ディスク I/O の最適化">セクション8.5.7「InnoDB ディスク I/O の最適化」</a>を参照してください。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            Linux システムでは、デフォルトの <code class="literal">innodb_read_io_threads</code> 設定で複数 (一般には 12 台よりも多く) の MySQL サーバーを実行すると、<code class="literal">innodb_write_io_threads</code> および Linux の <code class="literal">aio-max-nr</code> 設定がシステムの制限を超過する可能性があります。理想的には <code class="literal">aio-max-nr</code> 設定を大きくします。回避策として、MySQL 構成オプションの一方または両方の設定を小さくするとよいでしょう。
          </p></div></li><li class="listitem"><p><a name="sysvar_innodb_read_only"></a>
          <a class="indexterm" name="idm139979066007056"></a> <code class="literal">innodb_read_only</code>
        </p><div class="informaltable"><table summary="Options for innodb_read_only" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.7</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_read_only=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_read_only">innodb_read_only</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr></tbody></table></div><p>
          サーバーを読み取り専用モードで起動します。読み取り専用メディア上のデータベースアプリケーションまたはデータセットを配布するために使用されます。複数のインスタンス間で同じデータディレクトリを共有する際に、データウェアハウスで使用することもできます。使用手順については、<a class="xref" href="innodb-storage-engine.html#innodb-read-only-instance" title="14.3.1 読み取り専用操作用の InnoDB の構成">セクション14.3.1「読み取り専用操作用の InnoDB の構成」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_replication_delay"></a>
          <a class="indexterm" name="idm139979065981088"></a> <a class="indexterm" name="idm139979065979536"></a> <code class="literal">innodb_replication_delay</code>
        </p><div class="informaltable"><table summary="Options for innodb_replication_delay" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_replication_delay=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_replication_delay">innodb_replication_delay</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">4294967295</code></td></tr></tbody></table></div><p>
          <code class="literal">innodb_thread_concurrency</code> に達した場合のスレーブサーバー上のレプリケーションスレッドの遅延 (ミリ秒単位) です。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_rollback_on_timeout"></a>
          <a class="indexterm" name="idm139979065950448"></a> <a class="indexterm" name="idm139979065948976"></a> <code class="literal">innodb_rollback_on_timeout</code>
        </p><div class="informaltable"><table summary="Options for innodb_rollback_on_timeout" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_rollback_on_timeout</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_rollback_on_timeout">innodb_rollback_on_timeout</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr></tbody></table></div><p>
          MySQL 5.6 では、<code class="literal">InnoDB</code> はデフォルトで、トランザクションタイムアウト時に最後のステートメントのみを<a class="link" href="glossary.html#glos_rollback" title="ロールバック">ロールバック</a>します。<code class="option">--innodb_rollback_on_timeout</code> を指定すると、トランザクションタイムアウトによって、<code class="literal">InnoDB</code> はトランザクション全体を中止してロールバックします (MySQL 4.1 と同じ動作です)。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_rollback_segments"></a>
          <a class="indexterm" name="idm139979065921888"></a> <code class="literal">innodb_rollback_segments</code>
        </p><div class="informaltable"><table summary="Options for innodb_rollback_segments" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.2</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_rollback_segments=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_rollback_segments">innodb_rollback_segments</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">128</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">128</code></td></tr></tbody></table></div><p>
          <a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a>内で InnoDB が使用する<a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">システムテーブルスペース</a>にある<a class="link" href="glossary.html#glos_rollback_segment" title="ロールバックセグメント">ロールバックセグメント</a>の数を定義します。この設定は引き続き有効ですが、<code class="literal">innodb_undo_logs</code> で置き換えられます。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_sort_buffer_size"></a>
          <a class="indexterm" name="idm139979065889104"></a> <code class="literal">innodb_sort_buffer_size</code>
        </p><div class="informaltable"><table summary="Options for innodb_sort_buffer_size" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.4</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_sort_buffer_size=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_sort_buffer_size">innodb_sort_buffer_size</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (5.6.4)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">1048576</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">524288</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">67108864</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (&gt;= 5.6.5)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">1048576</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">65536</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">67108864</code></td></tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> インデックスの作成時に、データを格納する際に使用されるソートバッファーのサイズを指定します。指定されたサイズでは、内部ソート用にメモリーに入力され、ディスクに書き込まれたデータの量が定義されます。これは、<span class="quote">「<span class="quote">実行</span>」</span>と呼ばれることもあります。マージフェーズ時に、指定されたサイズのバッファーのペアが<span class="quote">「<span class="quote">読み取られ</span>」</span>、マージされます。設定を大きくするほど、<span class="quote">「<span class="quote">実行</span>」</span>数およびマージ数が少なくなります。このことは、チューニングの観点から理解する際に重要です。
        </p><p>
          このソート領域は、後続のインデックスのメンテナンス操作時ではなく、インデックスの作成時のマージソートでのみ使用されます。インデックスの作成が完了すると、バッファーの割り当てが解除されます。
        </p><p>
          このオプションの値では、<a class="link" href="glossary.html#glos_online_ddl" title="オンライン DDL">オンライン DDL</a> の操作時に並列 DML を記録するために、一時ログファイルが拡張される量も制御されます。
        </p><p>
          この設定が構成可能になる前は、サイズが 1048576 バイト (1M バイト) にハードコーディングされていました。その値は、現在もデフォルトのままです。
        </p><p>
          インデックスを作成する <code class="literal">ALTER TABLE</code> または <code class="literal">CREATE TABLE</code> ステートメントの実行時に、それぞれが、このオプションで定義されたサイズを持つ 3 つのバッファーが割り当てられます。さらに、ポインタ上でソートを実行できるように、ソートバッファー内の行に補助ポインタが割り当てられます (これは、ソート操作時の行の移動とは異なります)。
        </p><p>
          一般的なソート操作では、次のような公式を使用して、メモリーの消費を見積もることができます。
        </p><pre class="programlisting">
(6 /*FTS_NUM_AUX_INDEX*/ *
(3*@@global.innodb_sort_buffer_size) + 2 * (
@@global.innodb_sort_buffer_size/dict_index_get_min_size(index)*/) 
* 8 /*64-bit sizeof *buf-&gt;tuples*/")
</pre><p>
          <span class="quote">「<span class="quote"><code class="literal">@@global.innodb_sort_buffer_size/dict_index_get_min_size(index)</code></span>」</span> は、保持される最大のタプル数を示します。<span class="quote">「<span class="quote"><code class="literal">2 * (@@global.innodb_sort_buffer_size/*dict_index_get_min_size(index)*/) * 8 /*64-bit size of *buf-&gt;tuples*/</code> は、割り当てられた補助ポインタ数を示します</span>」</span>。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            32 ビットの場合は、8 の代わりに 4 で乗算します。
          </p></div><p>
          全文インデックスでの並列ソートでは、<code class="literal">innodb_ft_sort_pll_degree</code> の設定で乗算します。
        </p><pre class="programlisting">
(6 /*FTS_NUM_AUX_INDEX*/ @@global.innodb_ft_sort_pll_degree)
</pre></li><li class="listitem"><p><a name="sysvar_innodb_spin_wait_delay"></a>
          <a class="indexterm" name="idm139979065832384"></a> <a class="indexterm" name="idm139979065830832"></a> <code class="literal">innodb_spin_wait_delay</code>
        </p><div class="informaltable"><table summary="Options for innodb_spin_wait_delay" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_spin_wait_delay=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_spin_wait_delay">innodb_spin_wait_delay</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">6</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">4294967295</code></td></tr></tbody></table></div><p>
          <a class="link" href="glossary.html#glos_spin" title="スピン">スピン</a>ロックでのポーリング間の最大遅延です。このメカニズムの低レベルの実装は、ハードウェアとオペレーティングシステムの組み合わせによって異なるため、遅延は一定の時間間隔に対応しません。デフォルト値は 6 です。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-spin_lock_polling" title="14.13.10 スピンロックのポーリングの構成">セクション14.13.10「スピンロックのポーリングの構成」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_stats_auto_recalc"></a>
          <a class="indexterm" name="idm139979065800784"></a> <code class="literal">innodb_stats_auto_recalc</code>
        </p><div class="informaltable"><table summary="Options for innodb_stats_auto_recalc" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.6</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_stats_auto_recalc=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_auto_recalc">innodb_stats_auto_recalc</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">ON</code></td></tr></tbody></table></div><p>
          テーブル内のデータが大幅に変更されたあとは、<code class="literal">InnoDB</code> によって自動的に<a class="link" href="glossary.html#glos_persistent_statistics" title="永続的統計">永続的統計</a>が再計算されます。現在のしきい値は、テーブル内の行の 10% です。この設定は、<code class="literal">innodb_stats_persistent</code> オプションが有効になっている場合や、<code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> ステートメントで <code class="literal">STATS_PERSISTENT=1</code> 句が有効になっている場合に、作成されたテーブルに適用されます。統計を生成するためにサンプルとして取得されるデータの量は、<code class="literal">innodb_stats_persistent_sample_pages</code> 構成オプションで制御されます。
        </p><p>
          <code class="literal">innodb_stats_auto_recalc</code> に関する追加情報については、<a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="14.13.16.1 永続的オプティマイザ統計のパラメータの構成">セクション14.13.16.1「永続的オプティマイザ統計のパラメータの構成」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_stats_method"></a>
          <a class="indexterm" name="idm139979065767088"></a> <a class="indexterm" name="idm139979065765568"></a> <code class="literal">innodb_stats_method</code>
        </p><div class="informaltable"><table summary="Options for innodb_stats_method" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.2</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_stats_method=name</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_method">innodb_stats_method</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="5"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">列挙</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">nulls_equal</code></td></tr><tr><td scope="row" rowspan="3" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">nulls_equal</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">nulls_unequal</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">nulls_ignored</code></td></tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> テーブルのインデックス値の分布に関する<a class="link" href="glossary.html#glos_statistics" title="統計">統計</a>を収集するときに、サーバーが <code class="literal">NULL</code> 値を処理する方法です。この変数は、<code class="literal">nulls_equal</code>、<code class="literal">nulls_unequal</code>、および <code class="literal">nulls_ignored</code> の 3 つの値を指定できます。<code class="literal">nulls_equal</code> の場合、すべての <code class="literal">NULL</code> インデックス値を同等として扱い、<code class="literal">NULL</code> 値の数とサイズが同等の単一値グループを生成します。<code class="literal">nulls_unequal</code> の場合、<code class="literal">NULL</code> 値同士を同等として扱わず、それぞれの <code class="literal">NULL</code> はサイズが 1 の別個のグループを生成します。<code class="literal">nulls_ignored</code> の場合、<code class="literal">NULL</code> 値は無視されます。
        </p><p>
          テーブル統計を生成するために使用する方法は、<a class="xref" href="optimization.html#myisam-index-statistics" title="8.3.7 InnoDB および MyISAM インデックス統計コレクション">セクション8.3.7「InnoDB および MyISAM インデックス統計コレクション」</a>に記載されているように、オプティマイザがクエリー実行のためのインデックスを選択する方法に影響を与えます。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_stats_on_metadata"></a>
          <a class="indexterm" name="idm139979065722416"></a> <a class="indexterm" name="idm139979065720896"></a> <code class="literal">innodb_stats_on_metadata</code>
        </p><div class="informaltable"><table summary="Options for innodb_stats_on_metadata" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_stats_on_metadata</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_on_metadata">innodb_stats_on_metadata</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span> (&lt;= 5.6.5)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">ON</code></td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span> (&gt;= 5.6.6)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr></tbody></table></div><p>
          この変数を有効にすると、<code class="literal">SHOW TABLE STATUS</code> や <code class="literal">SHOW INDEX</code> などのメタデータステートメントが実行されるときや、<code class="literal">INFORMATION_SCHEMA</code> テーブル <code class="literal">TABLES</code> または <code class="literal">STATISTICS</code> にアクセスするときに、<code class="literal">InnoDB</code> によって<a class="link" href="glossary.html#glos_statistics" title="統計">統計</a>が更新されます。(これらの更新は、<code class="literal">ANALYZE TABLE</code> で実行されるものに似ています。)無効にすると、これらの操作時に <code class="literal">InnoDB</code> によって統計が更新されません。この設定を無効のままにすると、多数のテーブルまたはインデックスを持つスキーマのアクセス速度を改善できます。<code class="literal">InnoDB</code> テーブルが関与するクエリーの<a class="link" href="glossary.html#glos_query_execution_plan" title="クエリー実行計画">実行計画</a>の安定性も改善できます。
        </p><p>
          設定を変更するには、<code class="literal">SET GLOBAL innodb_stats_on_metadata=<em class="replaceable"><code>mode</code></em></code> ステートメントを発行します。ここで、<code class="literal"><em class="replaceable"><code>mode</code></em></code> は <code class="literal">ON</code> と <code class="literal">OFF</code> のいずれか (または <code class="literal">1</code> と <code class="literal">0</code> のいずれか) です。この設定を変更するには、<code class="literal">SUPER</code> 権限が必要です。変更すると、すべての接続の操作がすぐに影響を受けます。
        </p><p>
          MySQL 5.6.6 の時点では、この変数はデフォルトで無効になっています。それよりも前では、有効になっています。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_stats_persistent"></a>
          <a class="indexterm" name="idm139979065674112"></a> <a class="indexterm" name="idm139979065672560"></a> <code class="literal">innodb_stats_persistent</code>
        </p><div class="informaltable"><table summary="Options for innodb_stats_persistent" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.6</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_stats_persistent=setting</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent">innodb_stats_persistent</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="6"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">ON</code></td></tr><tr><td scope="row" rowspan="4" valign="top"><span class="bold"><strong>有効な値</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">ON</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row" colspan="2"><code class="literal">1</code></td></tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> インデックスの統計がディスクに保持されるかどうかを指定します。それ以外の場合は、頻繁に統計が再計算される可能性があります。これにより、<a class="link" href="glossary.html#glos_query_execution_plan" title="クエリー実行計画">クエリーの実行計画</a>が変化する可能性があります。テーブルが作成されると、この設定が各テーブルとともに格納されます。テーブルを作成する前にグローバルレベルで <code class="literal">innodb_stats_persistent</code> を設定することも、<code class="literal">CREATE TABLE</code> および <code class="literal">ALTER TABLE</code> ステートメントで <code class="literal">STATS_PERSISTENT</code> 句を使用して、システム全体の設定をオーバーライドし、個々のテーブルの永続的統計を構成することもできます。
        </p><p>
          このオプションについての詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="14.13.16.1 永続的オプティマイザ統計のパラメータの構成">セクション14.13.16.1「永続的オプティマイザ統計のパラメータの構成」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_stats_persistent_sample_pages"></a>
          <a class="indexterm" name="idm139979065633168"></a> <code class="literal">innodb_stats_persistent_sample_pages</code>
        </p><div class="informaltable"><table summary="Options for innodb_stats_persistent_sample_pages" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.2</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_stats_persistent_sample_pages=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_persistent_sample_pages">innodb_stats_persistent_sample_pages</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">20</code></td></tr></tbody></table></div><p>
          インデックス付きカラムの<a class="link" href="glossary.html#glos_cardinality" title="カーディナリティー">カーディナリティー</a>やその他の<a class="link" href="glossary.html#glos_statistics" title="統計">統計</a> (<code class="literal">ANALYZE TABLE</code> で計算された統計など) を見積もるときに、サンプルとして取得されるインデックス<a class="link" href="glossary.html#glos_page" title="ページ">ページ</a>の数です。値を大きくすると、<a class="link" href="glossary.html#glos_query_execution_plan" title="クエリー実行計画">クエリーの実行計画</a>を改善するインデックス統計の精度が改善されますが、<code class="literal">InnoDB</code> テーブルに対する <code class="literal">ANALYZE TABLE</code> の実行時に I/O が増加することになります。追加情報については、<a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="14.13.16.1 永続的オプティマイザ統計のパラメータの構成">セクション14.13.16.1「永続的オプティマイザ統計のパラメータの構成」</a>を参照してください。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            <code class="literal">innodb_stats_persistent_sample_pages</code> に大きな値を設定すると、<code class="literal">ANALYZE TABLE</code> の実行時間が長くなる可能性があります。アクセスされるデータベースページの数を見積もる方法については、<a class="xref" href="innodb-storage-engine.html#innodb-analyze-table-complexity" title="14.13.17 InnoDB テーブルに対する ANALYZE TABLE の複雑さの推定">セクション14.13.17「InnoDB テーブルに対する ANALYZE TABLE の複雑さの推定」</a>を参照してください。
          </p></div><p>
          このオプションは、テーブルで <code class="literal">innodb_stats_persistent</code> 設定がオンになっている場合にのみ適用されます。このオプションがテーブルでオフになっている場合は、代わりに <code class="literal">innodb_stats_transient_sample_pages</code> 設定が適用されます。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_stats_sample_pages"></a>
          <a class="indexterm" name="idm139979065594576"></a> <a class="indexterm" name="idm139979065593120"></a> <code class="literal">innodb_stats_sample_pages</code>
        </p><div class="informaltable"><table summary="Options for innodb_stats_sample_pages" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>非推奨</strong></span></td><td colspan="3">5.6.3</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_stats_sample_pages=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_sample_pages">innodb_stats_sample_pages</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">8</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">2**64-1</code></td></tr></tbody></table></div><p>
          非推奨です。代わりに <code class="literal">innodb_stats_transient_sample_pages</code> を使用してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_stats_transient_sample_pages"></a>
          <a class="indexterm" name="idm139979065562192"></a> <code class="literal">innodb_stats_transient_sample_pages</code>
        </p><div class="informaltable"><table summary="Options for innodb_stats_transient_sample_pages" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.2</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_stats_transient_sample_pages=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_stats_transient_sample_pages">innodb_stats_transient_sample_pages</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">8</code></td></tr></tbody></table></div><p>
          インデックス付きカラムの<a class="link" href="glossary.html#glos_cardinality" title="カーディナリティー">カーディナリティー</a>やその他の<a class="link" href="glossary.html#glos_statistics" title="統計">統計</a> (<code class="literal">ANALYZE TABLE</code> で計算された統計など) を見積もるときに、サンプルとして取得されるインデックス<a class="link" href="glossary.html#glos_page" title="ページ">ページ</a>の数です。デフォルト値は 8 です。値を大きくすると、インデックス統計の精度が改善されます。これにより、<a class="link" href="glossary.html#glos_query_execution_plan" title="クエリー実行計画">クエリーの実行計画</a>を改善できますが、<code class="literal">InnoDB</code> テーブルを開くときや統計を再計算するときに I/O が増加するという犠牲が伴います。追加情報については <a class="xref" href="innodb-storage-engine.html#innodb-statistics-estimation" title="14.13.16.2 非永続的オプティマイザ統計のパラメータの構成">セクション14.13.16.2「非永続的オプティマイザ統計のパラメータの構成」</a>を参照してください。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            <code class="literal">innodb_stats_transient_sample_pages</code> に大きな値を設定すると、<code class="literal">ANALYZE TABLE</code> の実行時間が長くなる可能性があります。アクセスされるデータベースページの数を見積もる方法については、<a class="xref" href="innodb-storage-engine.html#innodb-analyze-table-complexity" title="14.13.17 InnoDB テーブルに対する ANALYZE TABLE の複雑さの推定">セクション14.13.17「InnoDB テーブルに対する ANALYZE TABLE の複雑さの推定」</a>を参照してください。
          </p></div><p>
          このオプションは、テーブルで <code class="literal">innodb_stats_persistent</code> 設定がオフになっている場合にのみ適用されます。このオプションがテーブルでオンになっている場合は、代わりに <code class="literal">innodb_stats_persistent_sample_pages</code> 設定が適用されます。<code class="literal">innodb_stats_sample_pages</code> オプションの場所を取得します。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_status_output"></a>
          <a class="indexterm" name="idm139979065523440"></a> <a class="indexterm" name="idm139979065521888"></a> <code class="literal">innodb_status_output</code>
        </p><div class="informaltable"><table summary="Options for innodb_status_output" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.16</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_status_output</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_status_output">innodb_status_output</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr></tbody></table></div><p>
          標準 <code class="literal">InnoDB</code> Monitor の定期的な出力を有効または無効にする際に使用されます。また、<code class="literal">InnoDB</code> Lock Monitor の定期的な出力を有効または無効にする際に、<code class="literal">innodb_status_output_locks</code> と組み合わせて使用されます。追加情報については、<a class="xref" href="innodb-storage-engine.html#innodb-monitors" title="14.15 InnoDB モニター">セクション14.15「InnoDB モニター」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_status_output_locks"></a>
          <a class="indexterm" name="idm139979065493072"></a> <a class="indexterm" name="idm139979065491632"></a> <code class="literal">innodb_status_output_locks</code>
        </p><div class="informaltable"><table summary="Options for innodb_status_output_locks" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.16</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_status_output_locks</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_status_output_locks">innodb_status_output_locks</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> Lock Monitor の定期的な出力を有効または無効にする際に使用されます。<code class="literal">innodb_status_output</code> と組み合わせて使用する必要があります。追加情報については、<a class="xref" href="innodb-storage-engine.html#innodb-monitors" title="14.15 InnoDB モニター">セクション14.15「InnoDB モニター」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_strict_mode"></a>
          <a class="indexterm" name="idm139979065463536"></a> <a class="indexterm" name="idm139979065462016"></a> <code class="literal">innodb_strict_mode</code>
        </p><div class="informaltable"><table summary="Options for innodb_strict_mode" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_strict_mode=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_strict_mode">innodb_strict_mode</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル、セッション</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">OFF</code></td></tr></tbody></table></div><p>
          <code class="literal">innodb_strict_mode</code> を <code class="literal">ON</code> にすると、<code class="literal">InnoDB</code> は特定の条件に対応した警告ではなく、エラーを返します。デフォルト値は <code class="literal">OFF</code> です。
        </p><p>
          <a class="link" href="glossary.html#glos_strict_mode" title="厳密モード">厳密モード</a>は、SQL 内の無視できる誤字や構文エラー、または操作モードと SQL ステートメントのさまざまな組み合わせによる意図しないその他の結果から保護する際に役立ちます。<code class="literal">innodb_strict_mode</code> を <code class="literal">ON</code> にすると、<code class="literal">InnoDB</code> は警告を発行して、指定されたステートメントを処理する (意図しない動作が伴う可能性があります) のではなく、特定のケースでエラー状況が発生します。これは、MySQL で受け入れられる SQL 構文を制御し、警告なしでエラーを無視するのか、入力構文とデータ値を検証するのかを決定する MySQL の <a class="link" href="server-administration.html#sql-mode" title="5.1.7 サーバー SQL モード"><code class="literal">sql_mode</code></a> と類似しています。
        </p><p>
          <code class="literal">innodb_strict_mode</code> の設定によって、<code class="literal">CREATE TABLE</code>、<code class="literal">ALTER TABLE</code>、および <code class="literal">CREATE INDEX</code> ステートメントの構文エラー処理が影響を受けます。<code class="literal">innodb_strict_mode</code> では、選択したページサイズに対してレコードが大きくなりすぎることが原因で、<code class="literal">INSERT</code> または <code class="literal">UPDATE</code> が失敗しないように、レコードサイズのチェックも有効になります。
        </p><p>
          オラクルでは、<code class="literal">CREATE TABLE</code>、<code class="literal">ALTER TABLE</code>、および <code class="literal">CREATE INDEX</code> ステートメントで <code class="literal">ROW_FORMAT</code> および <code class="literal">KEY_BLOCK_SIZE</code> 句を使用する際に、<code class="literal">innodb_strict_mode</code> を有効にすることが推奨されています。<code class="literal">innodb_strict_mode</code> を <code class="literal">OFF</code> にすると、<code class="literal">InnoDB</code> は競合する句を無視し、テーブルまたはインデックスを作成し、メッセージログに警告のみが表示されます。結果として生成されるテーブルでは、圧縮されたテーブルを作成しようとしても圧縮されないなど、意図したものとは異なる動作が発生する可能性があります。<code class="literal">innodb_strict_mode</code> を <code class="literal">ON</code> にすると、このような問題が発生するとすぐにエラーが生成され、テーブルまたはインデックスは作成されないため、後続のトラブルシューティングセッションが回避されます。
        </p><p>
          <code class="literal">mysqld</code> の起動時にコマンド行で、または <code class="filename">my.cnf</code> または <code class="filename">my.ini</code> <a class="link" href="glossary.html#glos_configuration_file" title="構成ファイル">構成ファイル</a>で、<code class="literal">innodb_strict_mode</code> の <code class="literal">ON</code> と <code class="literal">OFF</code> を切り替えることができます。<code class="literal">SET [GLOBAL|SESSION] innodb_strict_mode=<em class="replaceable"><code>mode</code></em></code> ステートメントを使用すれば、実行時に <code class="literal">innodb_strict_mode</code> を有効または無効にすることもできます。ここで、<code class="literal"><em class="replaceable"><code>mode</code></em></code> は <code class="literal">ON</code> と <code class="literal">OFF</code> のいずれかです。<code class="literal">GLOBAL</code> 値を変更するには、<code class="literal">SUPER</code> 権限が必要です。これを変更すると、それ以降に接続するすべてのクライアントの操作が影響を受けます。任意のクライアントが <code class="literal">innodb_strict_mode</code> の <code class="literal">SESSION</code> 設定を変更でき、そのクライアントのみが設定の影響を受けます。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_support_xa"></a>
          <a class="indexterm" name="idm139979065399552"></a> <a class="indexterm" name="idm139979065398000"></a> <a class="indexterm" name="idm139979065396112"></a> <code class="literal">innodb_support_xa</code>
        </p><div class="informaltable"><table summary="Options for innodb_support_xa" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_support_xa</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_support_xa">innodb_support_xa</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル、セッション</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">TRUE</code></td></tr></tbody></table></div><p>
          <a class="link" href="glossary.html#glos_xa" title="XA">XA</a> トランザクションの 2 相コミットで <code class="literal">InnoDB</code> のサポートを有効にします。これにより、トランザクションの準備時に追加のディスクフラッシュが発生します。この設定はデフォルトです。XA メカニズムは内部で使用されるため、バイナリログがオンになっていて、複数のスレッドからのデータの変更が許可されている任意のサーバーで重要となります。オフにすると、ライブデータベースがコミットするときとは異なる順序で、トランザクションがバイナリログに書き込まれる可能性があります。これにより、ディザスタリカバリ時やレプリケーションスレーブでバイナリログが再現されるときに、異なるデータが生成される可能性があります。1 つのスレッドしかデータを変更できない例外的な設定を使用している場合を除いて、レプリケーションマスターサーバーではオフにしないでください。
        </p><p>
          1 つのスレッドからのデータ変更のみが許可されているサーバーでは、<code class="literal">InnoDB</code> テーブルのパフォーマンスを改善するために、このオプションをオフにすることが安全であり、推奨されています。たとえば、レプリケーション SQL スレッドのみがデータを変更するレプリケーションスレーブでは、オフにすることができます。
        </p><p>
          また、安全なバイナリロギングまたはレプリケーションで必要でなく、外部の XA トランザクションマネージャーを使用しない場合でも、このオプションをオフにすることができます。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_sync_array_size"></a>
          <a class="indexterm" name="idm139979065367072"></a> <code class="literal">innodb_sync_array_size</code>
        </p><div class="informaltable"><table summary="Options for innodb_sync_array_size" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.3</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_sync_array_size=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_sync_array_size">innodb_sync_array_size</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">1024</code></td></tr></tbody></table></div><p>
          大量の待機中スレッドを含むワークロードの並列性を高くするために、スレッドの調整に使用される内部データ構造を分割します。この設定は MySQL インスタンスの起動時に構成する必要があり、あとで変更することはできません。大量の (一般に 768 を超える) 待機中スレッドが頻繁に生成されるワークロードでは、このオプション値を大きくすることをお勧めします。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_sync_spin_loops"></a>
          <a class="indexterm" name="idm139979065337328"></a> <a class="indexterm" name="idm139979065335776"></a> <code class="literal">innodb_sync_spin_loops</code>
        </p><div class="informaltable"><table summary="Options for innodb_sync_spin_loops" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_sync_spin_loops=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_sync_spin_loops">innodb_sync_spin_loops</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">30</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">4294967295</code></td></tr></tbody></table></div><p>
          スレッドが中断される前に、<code class="literal">InnoDB</code> 相互排他ロックが開放されるまでスレッドが待機する回数です。デフォルト値は 30 です。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_table_locks"></a>
          <a class="indexterm" name="idm139979065306928"></a> <a class="indexterm" name="idm139979065305376"></a> <code class="literal">innodb_table_locks</code>
        </p><div class="informaltable"><table summary="Options for innodb_table_locks" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_table_locks</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_table_locks">innodb_table_locks</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル、セッション</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">TRUE</code></td></tr></tbody></table></div><p>
          <code class="literal">autocommit = 0<code class="literal"> の場合、</code>InnoDB<code class="literal"> は </code>LOCK TABLES</code> の要求を受け入れます。MySQL はすべてのスレッドがテーブルに対するすべてのロックを解放するまで、<code class="literal">LOCK TABLES ... WRITE</code> から戻りません。<code class="literal">innodb_table_locks</code> のデフォルト値は 1 です。これは、<code class="literal">autocommit = 0</code>. の場合、<code class="literal">LOCK TABLES</code> によって InnoDB がテーブルを内部的にロックすることを意味します。
        </p><p>
          MySQL 5.6 では、<code class="literal">LOCK TABLES ... WRITE</code> を使用して明示的にロックされたテーブルには、<code class="literal">innodb_table_locks = 0</code> が無効です。<code class="literal">LOCK TABLES ... WRITE</code> で暗黙的に (たとえば、トリガーを使用して)、または <code class="literal">LOCK TABLES ... READ</code> によって、読み取りまたは書き込み用にロックされたテーブルには有効です。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_thread_concurrency"></a>
          <a class="indexterm" name="idm139979065269392"></a> <a class="indexterm" name="idm139979065267936"></a> <a class="indexterm" name="idm139979065265904"></a> <code class="literal">innodb_thread_concurrency</code>
        </p><div class="informaltable"><table summary="Options for innodb_thread_concurrency" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_thread_concurrency=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_thread_concurrency">innodb_thread_concurrency</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">1000</code></td></tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> は、この変数で指定された制限以下の数のオペレーティングシステムスレッドを同時に <code class="literal">InnoDB</code> 内部に保持しようと試みます (<code class="literal">InnoDB</code> では、ユーザートランザクションを処理する際にオペレーティングシステムのスレッドが使用されます)。スレッド数がこの制限に達すると、それ以降のスレッドは実行されるまで、<span class="quote">「<span class="quote">先入れ先出し</span>」</span> (FIFO) キュー内で待機状態になります。ロックを待機しているスレッドは、並列実行中のスレッドの数にカウントされません。
        </p><p>
          この変数の範囲は 0 から 1000 までです。値 0 (デフォルト) は、無制限の並列性 (並列性チェックなし) と解釈されます。スレッドの並列性チェックを無効にすると、<code class="literal">InnoDB</code> は必要な数だけのスレッドを作成できます。値を 0 にすると、<code class="literal">InnoDB 内部のクエリー</code>および <code class="literal">SHOW ENGINE INNODB STATUS</code> 出力の <code class="literal">ROW OPERATIONS</code> セクションにある<code class="literal">キューカウンタ内のクエリー</code>も無効になります。
        </p><p>
          MySQL インスタンスとその他のアプリケーションで CPU リソースを共有している場合や、ワークロードまたは並列ユーザー数が増加している場合は、この変数を設定することを検討してください。適切な設定は、ワークロード、コンピューティング環境、および実行中の MySQL のバージョンによって異なります。最適なパフォーマンスを実現する設定を決定するには、広範囲の値をテストする必要があります。<code class="literal">innodb_thread_concurrency</code> は動的な変数であるため、これを使用すれば、ライブテストシステムでさまざまな設定を試みることができます。特定の設定でパフォーマンスが低下した場合は、すぐに <code class="literal">innodb_thread_concurrency</code> を 0 に戻してください。
        </p><p>
          次のガイドラインに従うと、適切な設定を見つけて保持する際に役立ちます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              ワークロードに対する並列ユーザースレッドの数が 64 よりも少ない場合は、<code class="literal">innodb_thread_concurrency=0</code> を設定します。
            </p></li><li class="listitem"><p>
              ワークロードの負荷が常に高い場合や、ときどき急上昇する場合は、初めに <code class="literal">innodb_thread_concurrency=128</code> を設定してから、最適なパフォーマンスが実現されるスレッド数が見つかるまで、値を 96、80、64 と小さくしてください。たとえば、システムに通常は 40 - 50 のユーザーが存在しますが、定期的にその数が 60、70、さらには 200 まで上昇すると仮定します。パフォーマンスは、並列ユーザーが 80 のときは安定していますが、この数を上回ると低下が見られ始めます。この場合、パフォーマンスへの影響を回避するには、<code class="literal">innodb_thread_concurrency=80</code> を設定します。
            </p></li><li class="listitem"><p>
              <code class="literal">InnoDB</code> でユーザースレッド用に特定の数を上回る vCPU (たとえば、20 個の vCPU) が使用されないようにする場合は、<code class="literal">innodb_thread_concurrency</code> をその数 (またはパフォーマンスの結果によっては、さらに小さい数) に設定します。MySQL をその他のアプリケーションから分離することが目的である場合は、排他的に <code class="literal">mysqld</code> プロセスを vCPU にバインドすることを検討してみてください。ただし、<code class="literal">mysqld</code> プロセスの負荷が常に高いわけではない場合は、排他的なバインドによって最適なハードウェアの使用が実現されない可能性があります。この場合、<code class="literal">mysqld</code> プロセスを vCPU にバインドしても、その他のアプリケーションも vCPU の一部または全部を使用できます。
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
                オペレーティングシステムの観点から見ると、<code class="literal">mysqld</code> プロセスをバインドするよりも、リソース管理ソリューションを使用して (使用可能な場合)、アプリケーション間で CPU 時間を共有する方法を管理する方が適切な場合があります。たとえば、その他のクリティカルなプロセスが実行されて<span class="emphasis"><em>いない</em></span>場合は、vCPU 時間の 90% を特定のアプリケーションに割り当て、その他のクリティカルなプロセスが実行されて<span class="emphasis"><em>いる</em></span>場合は、その値を 40% に戻します。
              </p></div></li><li class="listitem"><p>
              <code class="literal">innodb_thread_concurrency</code> の値が大きすぎると、システム内部およびリソース上の競合が増加するため、パフォーマンスが低下する可能性があります。
            </p></li><li class="listitem"><p>
              場合によっては、最適な <code class="literal">innodb_thread_concurrency</code> が vCPU の数よりも小さくなる可能性もあります。
            </p></li><li class="listitem"><p>
              定期的にシステムをモニターし、分析してください。ワークロード、ユーザー数、またはコンピューティング環境を変更するために、<code class="literal">innodb_thread_concurrency</code> 設定の調整が必要なことがあります。
            </p></li></ul></div><p>
          関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-performance-thread_concurrency" title="14.13.5 InnoDB のスレッド並列性の構成">セクション14.13.5「InnoDB のスレッド並列性の構成」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_thread_sleep_delay"></a>
          <a class="indexterm" name="idm139979065204384"></a> <a class="indexterm" name="idm139979065202928"></a> <code class="literal">innodb_thread_sleep_delay</code>
        </p><div class="informaltable"><table summary="Options for innodb_thread_sleep_delay" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_thread_sleep_delay=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_thread_sleep_delay">innodb_thread_sleep_delay</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (32 ビットプラットフォーム, &lt;= 5.6.16)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">10000</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">4294967295</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (64 ビットプラットフォーム, &lt;= 5.6.16)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">10000</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">18446744073709551615</code></td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span> (&gt;= 5.6.17)</td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">10000</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">1000000</code></td></tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> キューに参加するまでに、<code class="literal">InnoDB</code> スレッドがスリープ状態になる期間 (マイクロ秒単位) です。デフォルト値は 10000 です。0 の値はスリープを無効にします。MySQL 5.6.3 以降では、構成オプション <code class="literal">innodb_adaptive_max_sleep_delay</code> を <code class="literal">innodb_thread_sleep_delay</code> で許可される最大の値に設定でき、InnoDB によって自動的に、現在のスレッドスケジューリングアクティビティーに応じて <code class="literal">innodb_thread_sleep_delay</code> が上下に調整されます。この動的な調整は、システムにかかる負荷が軽い期間や、システムがほぼ容量いっぱいで動作している期間に、スレッドスケジューリングメカニズムがスムーズに機能するのに役立ちます。
        </p><p>
          詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-thread_concurrency" title="14.13.5 InnoDB のスレッド並列性の構成">セクション14.13.5「InnoDB のスレッド並列性の構成」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_undo_directory"></a>
          <a class="indexterm" name="idm139979065147872"></a> <code class="literal">innodb_undo_directory</code>
        </p><div class="informaltable"><table summary="Options for innodb_undo_directory" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.3</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_undo_directory=dir_name</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_directory">innodb_undo_directory</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ディレクトリ名</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">.</code></td></tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> が Undo ログ用に個別のテーブルスペースを作成するディレクトリの相対パスまたは絶対パスです。一般に、これらのログを別のストレージデバイス上に配置する際に使用されます。<code class="literal">innodb_undo_logs</code> および <code class="literal">innodb_undo_tablespaces</code> と組み合わせて使用すると、<a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">システムテーブルスペース</a>外の Undo ログのディスクレイアウトが決定されます。デフォルト値の <code class="filename">.</code> は、<code class="literal">InnoDB</code> がデフォルトでその他のログファイルを作成するディレクトリと同じであることを表します。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_undo_logs"></a>
          <a class="indexterm" name="idm139979065117424"></a> <code class="literal">innodb_undo_logs</code>
        </p><div class="informaltable"><table summary="Options for innodb_undo_logs" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.3</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_undo_logs=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_logs">innodb_undo_logs</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">はい</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">128</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">128</code></td></tr></tbody></table></div><p>
          <a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a>内で <code class="literal">InnoDB</code> が使用する<a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">システムテーブルスペース</a>にある<a class="link" href="glossary.html#glos_rollback_segment" title="ロールバックセグメント">ロールバックセグメント</a>の数を定義します。この設定は、Undo ログに関連する相互排他競合が観察された場合のパフォーマンスのチューニングに適切です。<code class="literal">innodb_rollback_segments</code> 設定から置き換えられました。アクティブな Undo ログではなく、使用可能な Undo ログの合計数については、<code class="literal">Innodb_available_undo_logs</code> ステータス変数を参照してください。
        </p><p>
          トランザクション内で使用されるロールバックセグメントの数は大きくしたり、小さくしたりできますが、システム内に物理的に存在するロールバックセグメントの数は減少しません。したがって、あとで必要でなくなるロールバックセグメントが割り当てられることを回避するために、このパラメータは小さい値から始めて徐々に大きくするとよいでしょう。<code class="literal">innodb_undo_logs</code> が設定されていない場合は、デフォルトの最大値が 128 になります。ロールバックセグメントの管理については、<a class="xref" href="innodb-storage-engine.html#innodb-multi-versioning" title="14.2.12 InnoDB マルチバージョン">セクション14.2.12「InnoDB マルチバージョン」</a>を参照してください。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_undo_tablespaces"></a>
          <a class="indexterm" name="idm139979065079536"></a> <code class="literal">innodb_undo_tablespaces</code>
        </p><div class="informaltable"><table summary="Options for innodb_undo_tablespaces" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>導入</strong></span></td><td colspan="3">5.6.3</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_undo_tablespaces=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_tablespaces">innodb_undo_tablespaces</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">0</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">126</code></td></tr></tbody></table></div><p>
          ゼロ以外の <code class="literal">innodb_undo_logs</code> 設定を使用する場合に、<a class="link" href="glossary.html#glos_undo_log" title="Undo ログ">Undo ログ</a>が分割される<a class="link" href="glossary.html#glos_tablespace" title="テーブルスペース">テーブルスペース</a>ファイルの数です。デフォルトでは、すべての Undo ログは<a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">システムテーブルスペース</a>の一部であり、システムテーブルスペースには、<code class="literal">innodb_undo_tablespaces</code> で構成されたものに加えて、常に 1 つの Undo テーブルスペースが含まれています。長時間実行されるトランザクション中に Undo ログが大きくなる可能性があるため、Undo ログを複数のテーブルスペースに分割すると、任意の 1 つのテーブルスペースの最大サイズが削減されます。テーブルスペースファイルは、<code class="literal">innodb_undo_directory</code> で定義された場所に、<code class="filename">undo<em class="replaceable"><code>N</code></em></code> 形式の名前で作成されます。ここで <em class="replaceable"><code>N</code></em> は、先頭のゼロを含む一連の連続する整数です。Undo テーブルスペースファイルのデフォルトサイズは 10M です。はじめて <code class="literal">InnoDB</code> を初期化するときは、<code class="literal">innodb_undo_tablespaces</code> の数を設定する必要があります。最初にデータベースを作成したときに指定したときよりも多くの数の Undo テーブルスペースを持つ <code class="literal">InnoDB</code> を再起動しようとすると、起動に失敗し、<code class="literal">InnoDB</code> で予期された数の Undo テーブルスペースが見つからなかったことを示すエラーが表示されます。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_use_native_aio"></a>
          <a class="indexterm" name="idm139979065038400"></a> <a class="indexterm" name="idm139979065036848"></a> <code class="literal">innodb_use_native_aio</code>
        </p><div class="informaltable"><table summary="Options for innodb_use_native_aio" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_use_native_aio=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_use_native_aio">innodb_use_native_aio</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">ON</code></td></tr></tbody></table></div><p>
          Linux の非同期 I/O サブシステムを使用するかどうかを指定します。この変数は Linux システムにのみ適用され、サーバーの実行中は変更できません。このオプションはデフォルトで有効になっているため、通常は触れる必要がありません。
        </p><p>
          MySQL 5.5 の時点では、Windows システム上の <code class="literal">InnoDB</code> に備わっている<a class="link" href="glossary.html#glos_asynchronous_io" title="非同期 I/O">非同期 I/O</a> 機能が Linux システムでも使用できます。(その他の Unix に似たシステムでは、引き続き同期 I/O 呼び出しが使用されます。)この機能によって、I/O 負荷の高いシステムの拡張性が改善されます。一般に、<code class="literal">SHOW ENGINE INNODB STATUS\G</code> コマンドの出力に数多くの中断された読み取り/書き込みが表示されます。
        </p><p>
          大量の <code class="literal">InnoDB</code> I/O スレッドとともに実行すると (特に、同じサーバーマシン上で複数のこのようなインスタンスを実行すると)、Linux システムの能力制限を超える可能性があります。この場合、次のエラーを受信する可能性があります。
        </p><pre class="programlisting">
EAGAIN: The specified maxevents exceeds the user's limit of available events. 
</pre><p>
          一般に、<code class="literal">/proc/sys/fs/aio-max-nr</code> により大きな制限を記述すれば、このエラーに対処できます。
        </p><p>
          ただし、OS の非同期 I/O サブシステムの問題によって <code class="literal">InnoDB</code> が起動しない場合は、<code class="literal">innodb_use_native_aio=0</code> を無効にして (オプションファイルで <code class="literal">innodb_use_native_aio=0</code> を使用します)、サーバーを起動してください。また、<code class="literal">InnoDB</code> で <code class="literal">tmpdir</code> の場所、<code class="literal">tmpfs</code> ファイルシステム、および <code class="literal">tmpfs</code> 上で AIO がサポートされていない Linux カーネルなどを組み合わせた潜在的な問題が検出された場合に、このオプションが起動中に自動的にオフになる可能性もあります。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_use_sys_malloc"></a>
          <a class="indexterm" name="idm139979064998352"></a> <a class="indexterm" name="idm139979064996800"></a> <code class="literal">innodb_use_sys_malloc</code>
        </p><div class="informaltable"><table summary="Options for innodb_use_sys_malloc" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>非推奨</strong></span></td><td colspan="3">5.6.3</td></tr><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_use_sys_malloc=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_use_sys_malloc">innodb_use_sys_malloc</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="2"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">ブール</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">ON</code></td></tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> がオペレーティングシステムのメモリーアロケータを使用するのか (<code class="literal">ON</code>)、独自のものを使用するのか (<code class="literal">OFF</code>) を指定します。デフォルト値は <code class="literal">ON</code> です。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-use_sys_malloc" title="14.13.3 InnoDB のためのメモリーアロケータの構成">セクション14.13.3「InnoDB のためのメモリーアロケータの構成」</a>を参照してください。
        </p><p>
          MySQL 5.6.3 の時点では、<code class="literal">innodb_use_sys_malloc</code> は非推奨となり、今後の MySQL リリースで削除される予定です。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_version"></a>
          <a class="indexterm" name="idm139979064966240"></a> <a class="indexterm" name="idm139979064964736"></a> <code class="literal">innodb_version</code>
        </p><p>
          <code class="literal">InnoDB</code> のバージョン番号です。5.6.11 以降では、<code class="literal">InnoDB</code> ごとに個別の番号付与が廃止され、この値は <code class="literal">version</code> 変数の番号と同じです。
        </p></li><li class="listitem"><p><a name="sysvar_innodb_write_io_threads"></a>
          <a class="indexterm" name="idm139979064957744"></a> <a class="indexterm" name="idm139979064956192"></a> <code class="literal">innodb_write_io_threads</code>
        </p><div class="informaltable"><table summary="Options for innodb_write_io_threads" border="1"><colgroup><col class="title"><col class="vt"><col class="vd"><col class="v"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>コマンド行形式</strong></span></td><td colspan="3"><code class="literal">--innodb_write_io_threads=#</code></td></tr><tr><td scope="row" rowspan="3"><span class="bold"><strong>システム変数</strong></span></td><td><span class="bold"><strong>名前</strong></span></td><td colspan="2"><code class="literal"><a class="link" href="innodb-storage-engine.html#sysvar_innodb_write_io_threads">innodb_write_io_threads</a></code></td></tr><tr><td scope="row"><span class="bold"><strong>変数スコープ</strong></span></td><td colspan="2">グローバル</td></tr><tr><td scope="row"><span class="bold"><strong>動的変数</strong></span></td><td colspan="2">いいえ</td></tr><tr><td scope="row" rowspan="4"><span class="bold"><strong>許可されている値</strong></span></td><td><span class="bold"><strong>型</strong></span></td><td colspan="2"><code class="literal">数値</code></td></tr><tr><td scope="row"><span class="bold"><strong>デフォルト</strong></span></td><td colspan="2"><code class="literal">4</code></td></tr><tr><td scope="row"><span class="bold"><strong>最小値</strong></span></td><td colspan="2"><code class="literal">1</code></td></tr><tr><td scope="row"><span class="bold"><strong>最大値</strong></span></td><td colspan="2"><code class="literal">64</code></td></tr></tbody></table></div><p>
          <code class="literal">InnoDB</code> の書き込み操作で使用される I/O スレッドの数です。デフォルト値は 4 です。読み取りスレッドで対応するものは、<code class="literal">innodb_read_io_threads</code> です。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-multiple_io_threads" title="14.13.6 InnoDB バックグラウンド I/O スレッドの数の構成">セクション14.13.6「InnoDB バックグラウンド I/O スレッドの数の構成」</a>を参照してください。一般的な I/O チューニングのアドバイスについては、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.7 InnoDB ディスク I/O の最適化">セクション8.5.7「InnoDB ディスク I/O の最適化」</a>を参照してください。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            Linux システムでは、デフォルトの <code class="literal">innodb_read_io_threads</code> 設定で複数 (一般には 12 台よりも多く) の MySQL サーバーを実行すると、<code class="literal">innodb_write_io_threads</code> および Linux の <code class="literal">aio-max-nr</code> 設定がシステムの制限を超過する可能性があります。理想的には <code class="literal">aio-max-nr</code> 設定を大きくします。回避策として、MySQL 構成オプションの一方または両方の設定を小さくするとよいでしょう。
          </p></div></li></ul></div><p>
      また、ディスクへのバイナリログの同期を制御する <code class="literal">sync_binlog</code> の値も考慮に入れるようにしてください。
    </p><p>
      一般的な I/O チューニングのアドバイスについては、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.7 InnoDB ディスク I/O の最適化">セクション8.5.7「InnoDB ディスク I/O の最適化」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-performance"></a>14.13 InnoDB のパフォーマンス</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-buffer-pool">14.13.1 InnoDB バッファープールの構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-latching">14.13.2 InnoDB 相互排他ロックおよび読み取り/書き込みロックの実装</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-use_sys_malloc">14.13.3 InnoDB のためのメモリーアロケータの構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-change_buffering">14.13.4 InnoDB 変更バッファリングの構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-thread_concurrency">14.13.5 InnoDB のスレッド並列性の構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-multiple_io_threads">14.13.6 InnoDB バックグラウンド I/O スレッドの数の構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-group_commit">14.13.7 グループコミット</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-thread_io_rate">14.13.8 InnoDB マスタースレッドの I/O レートの構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-pause_instruction">14.13.9 InnoDB スピンループでの PAUSE 命令の使用</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-spin_lock_polling">14.13.10 スピンロックのポーリングの構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-schema">14.13.11 InnoDB の MySQL パフォーマンススキーマとの統合</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-multiple-rollback-segments">14.13.12 複数のロールバックセグメントによるスケーラビリティーの向上</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-improved-purge-scheduling">14.13.13 InnoDB のパージスケジューリングの構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-ro-txn">14.13.14 InnoDB の読み取り専用トランザクションの最適化</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-crc32-checksum">14.13.15 チェックサムの高速化のための CRC32 チェックサムアルゴリズムの使用</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-optimizer-statistics">14.13.16 オプティマイザ統計</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-analyze-table-complexity">14.13.17 InnoDB テーブルに対する ANALYZE TABLE の複雑さの推定</a></span></dt></dl></div><p>
    このセクションでは、パフォーマンスとスケーラビリティーに関連した <code class="literal">InnoDB</code> の機能および拡張に関する情報を提供します。
  </p><p>
    <code class="literal">InnoDB</code> テーブルをチューニングするためのヒントとガイドラインは、最適化の章に示されています。<a class="xref" href="optimization.html#optimizing-innodb" title="8.5 InnoDB テーブルの最適化">セクション8.5「InnoDB テーブルの最適化」</a>を参照してください。
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-performance-buffer-pool"></a>14.13.1 InnoDB バッファープールの構成</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-read_ahead">14.13.1.1 InnoDB バッファープールのプリフェッチ (先読み) の構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-adaptive_flushing">14.13.1.2 InnoDB バッファープールのフラッシュの頻度の構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-performance-midpoint_insertion">14.13.1.3 バッファープールをスキャンに耐えられるようにする</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-multiple-buffer-pools">14.13.1.4 複数のバッファープールインスタンスの使用</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-preload-buffer-pool">14.13.1.5 再起動を高速化するための InnoDB バッファープールのプリロード</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-lru-background-flushing">14.13.1.6 InnoDB バッファープールのフラッシュのチューニング</a></span></dt></dl></div><p>
      このセクションでは、<code class="literal">InnoDB</code> バッファープールのパフォーマンス関連の構成情報について説明します。詳細は、<a class="xref" href="optimization.html#innodb-buffer-pool" title="8.9.1 InnoDB バッファープール">セクション8.9.1「InnoDB バッファープール」</a>を参照してください。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-performance-read_ahead"></a>14.13.1.1 InnoDB バッファープールのプリフェッチ (先読み) の構成</h4></div></div></div><a class="indexterm" name="idm139979064908672"></a><a class="indexterm" name="idm139979064907376"></a><a class="indexterm" name="idm139979064905248"></a><a class="indexterm" name="idm139979064903104"></a><p>
        <a class="link" href="glossary.html#glos_read_ahead" title="先読み">先読み</a>要求とは、<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>内の複数のページがすぐに必要になるという予測のもとに、非同期にこれらのページのプリフェッチを行う I/O 要求のことです。これらの要求によって、すべてのページが 1 つの<a class="link" href="glossary.html#glos_extent" title="エクステント">エクステント</a>内に移動されます。InnoDB は、I/O パフォーマンスを向上させるために、次の 2 つの先読みアルゴリズムを使用します。
      </p><p>
        <span class="strong"><strong>線形</strong></span>先読みは、順次にアクセスされているバッファープール内のページに基づいて、どのページがすぐに必要になる可能性があるかを予測する手法です。構成パラメータ <code class="literal">innodb_read_ahead_threshold</code> を使用して、非同期読み取り要求をトリガーするために必要な順次ページアクセスの数を調整することにより、InnoDB がいつ先読み操作を実行するかを制御します。このパラメータが追加される前、InnoDB は現在のエクステントの最後のページを読み取るときに、次のエクステント全体に対する非同期プリフェッチ要求を発行するかどうかを推測するだけでした。
      </p><p>
        構成パラメータ <code class="literal">innodb_read_ahead_threshold</code> は、順次ページアクセスのパターンの検出において InnoDB がどれだけ早く反応するかを制御します。エクステントからシーケンシャルに読み取られるページの数が <code class="literal">innodb_read_ahead_threshold</code> 以上である場合、InnoDB は、次のエクステント全体の非同期先読み操作を開始します。これは 0 から 64 までの任意の値に設定できます。デフォルト値は 56 です。この値が大きいほど、アクセスパターンのチェックは厳密になります。たとえば、この値を 48 に設定すると、InnoDB は、現在のエクステント内の 48 ページが順次にアクセスされた場合にのみ線形先読み要求をトリガーします。この値が 8 である場合、InnoDB は、エクステント内の 8 ページが順次にアクセスされただけでも非同期先読みをトリガーします。このパラメータの値は MySQL <a class="link" href="glossary.html#glos_configuration_file" title="構成ファイル">構成ファイル</a>で設定するか、または <code class="literal">SET GLOBAL</code> コマンド (これには <code class="literal">SUPER</code> 権限が必要です) で動的に変更できます。
      </p><p>
        <span class="strong"><strong>ランダム</strong></span>先読みは、すでにバッファープール内に存在するページに基づいて、これらのページが読み取られた順序には関係なく、ページがいつ必要になる可能性があるかを予測する手法です。同じエクステントからの 13 個の連続したページがバッファープール内に見つかった場合、InnoDB は、そのエクステントの残りのページのプリフェッチを行う要求を非同期に発行します。
      </p><p>
        ランダム先読み機能は、<code class="literal">InnoDB Plugin</code> (バージョン 1.0.4) から削除されたため、<code class="literal">InnoDB Plugin</code> が <code class="literal">InnoDB</code> の<span class="quote">「<span class="quote">組み込みの</span>」</span>バージョンになった時点では MySQL 5.5.0 に含まれていませんでした。ランダム先読みは、<code class="literal">innodb_random_read_ahead</code> 構成オプション (デフォルトでは無効になっています) とともに、MySQL 5.1.59 および 5.5.16 以降でふたたび導入されました。この機能を有効にするには、構成変数 <code class="literal">innodb_random_read_ahead</code> を <code class="literal">ON</code> に設定します。
      </p><p>
        <code class="literal">SHOW ENGINE INNODB STATUS</code> コマンドは、先読みアルゴリズムの有効性を評価するのに役立つ統計を表示します。統計には、<code class="literal">Innodb_buffer_pool_read_ahead</code> および <code class="literal">Innodb_buffer_pool_read_ahead_evicted</code> グローバルステータス変数のカウンタ情報が含まれます。これらの情報は、<code class="literal">innodb_random_read_ahead</code> 設定を微調整する場合に役立つことがあります。
      </p><p>
        また、MySQL 5.6 でランダム先読み機能が復活したことにより、<code class="literal">SHOW ENGINE INNODB STATUS</code> コマンドには <code class="literal">Innodb_buffer_pool_read_ahead_rnd</code> がふたたび含まれています。<code class="literal">Innodb_buffer_pool_read_ahead</code> は、その現在の名前を維持しています。(以前のリリースでは、<code class="literal">Innodb_buffer_pool_read_ahead_seq</code> として示されていました。)
      </p><p>
        I/O パフォーマンスの詳細は、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.7 InnoDB ディスク I/O の最適化">セクション8.5.7「InnoDB ディスク I/O の最適化」</a>および<a class="xref" href="optimization.html#disk-issues" title="8.11.3 ディスク I/O の最適化">セクション8.11.3「ディスク I/O の最適化」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-performance-adaptive_flushing"></a>14.13.1.2 InnoDB バッファープールのフラッシュの頻度の構成</h4></div></div></div><a class="indexterm" name="idm139979064867760"></a><a class="indexterm" name="idm139979064866464"></a><a class="indexterm" name="idm139979064864336"></a><a class="indexterm" name="idm139979064862960"></a><a class="indexterm" name="idm139979064860784"></a><a class="indexterm" name="idm139979064858608"></a><p>
        InnoDB は、<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>からの<a class="link" href="glossary.html#glos_dirty_page" title="ダーティーページ">ダーティーページ</a> (変更されたが、まだデータベースファイルに書き込まれていないページ) の<a class="link" href="glossary.html#glos_flush" title="フラッシュ">フラッシュ</a>などの特定のタスクをバックグラウンドで実行します。InnoDB は現在、バッファープール内のダーティーページの割合 (%) が <code class="literal">innodb_max_dirty_pages_pct</code> を超えた場合にバッファープールページをフラッシュします。
      </p><p>
        InnoDB は、Redo ログ生成の速度とフラッシュの現在の頻度に基づいて、フラッシュの必要な頻度を推定するアルゴリズムを使用します。その目的は、バッファーのフラッシュアクティビティーが常に、バッファープールを<span class="quote">「<span class="quote">クリーンな</span>」</span>状態に維持する必要性に対応するようにして、全体的なパフォーマンスを平滑化することにあります。フラッシュ頻度の自動的な調整は、通常の読み取りおよび書き込みアクティビティーに使用可能な I/O 容量がバッファープールの過剰なフラッシュによって制限されるような場合、スループットの突然の低下を回避するのに役立つことがあります。
      </p><p>
        InnoDB は、そのログファイルを循環的に使用します。ログファイルのある部分を再利用する前に、InnoDB は、Redo エントリがログファイルのその部分に含まれているダーティーバッファープールページをすべてディスクにフラッシュします。このプロセスは、<a class="link" href="glossary.html#glos_sharp_checkpoint" title="シャープチェックポイント">シャープチェックポイント</a>と呼ばれます。書き込みの多いワークロードでは、そのすべてがログファイルに書き込まれる多くの Redo 情報が生成されます。ログファイル内の使用可能なすべての領域が使い果たされると、シャープチェックポイントが発生するため、スループットが一時的に低下します。この状況は、<code class="literal">innodb_max_dirty_pages_pct</code> に達していなくても発生する場合があります。
      </p><p>
        InnoDB は、バッファープール内のダーティーページの数と、Redo が生成されている割合を測定することによってこのようなシナリオを回避する、経験則に基づいたアルゴリズムを使用します。これらの数値に基づいて、InnoDB は、バッファープールから毎秒フラッシュするダーティーページの数を決定します。この自己適応型のアルゴリズムは、ワークロードの突然の変化に対処できます。
      </p><p>
        内部のベンチマークでも示されているように、このアルゴリズムは一定期間にわたってスループットを維持するだけでなく、全体的なスループットも大幅に向上させることができます。
      </p><p>
        適応型フラッシュはワークロードの I/O パターンに大きな影響を与える場合があるため、<code class="literal">innodb_adaptive_flushing</code> 構成パラメータを使用して、この機能を無効にすることができます。<code class="literal">innodb_adaptive_flushing</code> のデフォルト値は <code class="literal">TRUE</code> であり、適応型フラッシュアルゴリズムが有効になります。このパラメータの値は MySQL オプションファイル (<code class="literal">my.cnf</code> または <code class="literal">my.ini</code>) で設定するか、あるいは <code class="literal">SET GLOBAL</code> コマンド (これには <code class="literal">SUPER</code> 権限が必要です) で動的に変更できます。
      </p><p>
        InnoDB の I/O パフォーマンスの詳細は、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.7 InnoDB ディスク I/O の最適化">セクション8.5.7「InnoDB ディスク I/O の最適化」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-performance-midpoint_insertion"></a>14.13.1.3 バッファープールをスキャンに耐えられるようにする</h4></div></div></div><a class="indexterm" name="idm139979064834912"></a><a class="indexterm" name="idm139979064833472"></a><a class="indexterm" name="idm139979064832096"></a><a class="indexterm" name="idm139979064830848"></a><a class="indexterm" name="idm139979064829488"></a><a class="indexterm" name="idm139979064828000"></a><p>
        InnoDB は、<a class="link" href="glossary.html#glos_lru" title="LRU">LRU</a> アルゴリズムを厳密に使用するのではなく、<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>に読み取られたあと二度とアクセスされないデータの量を最小限に抑えるための手法を使用します。目標は、<a class="link" href="glossary.html#glos_read_ahead" title="先読み">先読み</a>や<a class="link" href="glossary.html#glos_full_table_scan" title="テーブルの完全スキャン">フルテーブルスキャン</a>によって、その後アクセスされるかどうかわからない新しいブロックが読み取られた場合でも、頻繁にアクセスされるページ (<span class="quote">「<span class="quote">ホットページ</span>」</span>) が確実にバッファープール内に残るようにすることです。
      </p><p>
        新しく読み取られたブロックは、LRU リストの途中に挿入されます。新しく読み取られたページはすべて、デフォルトでは LRU リストの末尾から <code class="literal">3/8</code> にあたる場所に挿入されます。これらのページは、はじめてバッファープール内でアクセスされたときに、リストの前面 (直近で使用された端) に移動されます。そのため、アクセスされることがないページは決して LRU リストの前面の部分には移動されず、厳密な LRU アプローチの場合より早く<span class="quote">「<span class="quote">古く</span>」</span>なります。この配置では、LRU リストが 2 つのセグメントに分割されます。つまり、挿入ポイントの下流にあるページは<span class="quote">「<span class="quote">古い</span>」</span>とみなされ、LRU のエビクションの望ましい対象になります。
      </p><p>
        InnoDB バッファープールの内部動作や、その LRU の置き換えアルゴリズムの詳細については、<a class="xref" href="optimization.html#innodb-buffer-pool" title="8.9.1 InnoDB バッファープール">セクション8.9.1「InnoDB バッファープール」</a>を参照してください。
      </p><p>
        LRU リスト内の挿入ポイントを制御したり、InnoDB が同じ最適化をテーブルまたはインデックススキャンによってバッファープールに読み取られたブロックにも適用するかどうかを選択したりできます。構成パラメータ <code class="literal">innodb_old_blocks_pct</code> は、LRU リスト内の<span class="quote">「<span class="quote">古い</span>」</span>ブロックの割合 (%) を制御します。<code class="literal">innodb_old_blocks_pct</code> のデフォルト値は <code class="literal">37</code> であり、元の固定された 3/8 の比率に対応します。この値の範囲は、<code class="literal">5</code> (バッファープール内の新しいページが非常に早く古くなります) から <code class="literal">95</code> (バッファープールの 5% しかホットページとして予約されないため、アルゴリズムがなじみのある LRU の方法に近くなります) までです。
      </p><p>
        バッファープールを先読みによって混乱した状態にならないように維持する最適化は、テーブルまたはインデックススキャンによる同様の問題も回避できます。これらのスキャンでは通常、データページはすばやく連続して数回アクセスされ、それ以降は二度とアクセスされません。構成パラメータ <code class="literal">innodb_old_blocks_time</code> は、あるページにはじめてアクセスしたあと、そのページが LRU リストの前面 (直近で使用された端) に移動されることなくアクセス可能になっている時間ウィンドウ (ミリ秒単位) を指定します。MySQL 5.6.6 より前は、<code class="literal">innodb_old_blocks_time</code> のデフォルト値は <code class="literal">0</code> であり、はじめてバッファープール内でアクセスされたときにページをバッファープールのリストの直近で使用された端に移動するという元の動作に対応します。この値を大きくすると、より多くのブロックがバッファープールから早く古くなる可能性があります。MySQL 5.6.6 の時点で、<code class="literal">innodb_old_blocks_time</code> のデフォルト値は、標準でのパフォーマンスを向上させるために <code class="literal">1000</code> に増やされました。
      </p><p>
        <code class="literal">innodb_old_blocks_pct</code> と <code class="literal">innodb_old_blocks_time</code> はどちらも動的かつグローバルであり、MySQL オプションファイル (<code class="literal">my.cnf</code> または <code class="literal">my.ini</code>) で指定するか、あるいは <code class="literal">SET GLOBAL</code> コマンドで実行時に変更できます。この設定を変更するには、<code class="literal">SUPER</code> 権限が必要です。
      </p><p>
        これらのパラメータを設定した場合の効果の測定に役立つように、<code class="literal">SHOW ENGINE INNODB STATUS</code> コマンドは追加の統計をレポートします。<code class="literal">BUFFER POOL AND MEMORY</code> セクションは次のようになります。
      </p><pre class="programlisting">
Total memory allocated 1107296256; in additional pool allocated 0
Dictionary memory allocated 80360
Buffer pool size   65535
Free buffers       0
Database pages     63920
Old database pages 23600
Modified db pages  34969
Pending reads 32
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 414946, not young 2930673
1274.75 youngs/s, 16521.90 non-youngs/s
Pages read 486005, created 3178, written 160585
2132.37 reads/s, 3.40 creates/s, 323.74 writes/s
Buffer pool hit rate 950 / 1000, young-making rate 30 / 1000 not 392 / 1000
Pages read ahead 1510.10/s, evicted without access 0.00/s
LRU len: 63920, unzip_LRU len: 0
I/O sum[43690]:cur[221], unzip sum[0]:cur[0]
</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">Old database pages</code> は、LRU リストの<span class="quote">「<span class="quote">古い</span>」</span>セグメント内のページの数です。
          </p></li><li class="listitem"><p>
            <code class="literal">Pages made young</code> と <code class="literal">not young</code> はそれぞれ、新しくなった<span class="quote">「<span class="quote">古い</span>」</span>ページの総数となっていないページの総数です。
          </p></li><li class="listitem"><p>
            <code class="literal">youngs/s</code> と <code class="literal">non-young/s</code> はそれぞれ、このコマンドの最後の呼び出しのあと、<span class="quote">「<span class="quote">古い</span>」</span>ページへのページアクセスによってこのようなページが新しくなった割合となっていない割合です。
          </p></li><li class="listitem"><p>
            <code class="literal">young-making rate</code> と <code class="literal">not</code> は、<span class="quote">「<span class="quote">古い</span>」</span>ページへのアクセスだけでなく、全体的なバッファープールアクセスの点から見た場合、同じ割合を示しています。
          </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">InnoDB</code> モニターの出力で示される 1 秒あたりの平均は、現在の時間と <code class="literal">InnoDB</code> モニターの出力が最後に出力された時間の間の経過時間に基づいています。
        </p></div><p>
        これらのパラメータの効果はハードウェア構成、使用しているデータ、およびワークロードの詳細によって大幅に異なる場合があるため、パフォーマンスが重要な環境や本番環境でこれらの設定を変更する前には、常にベンチマークによってその有効性を確認してください。
      </p><p>
        ほとんどのアクティビティーが、大規模なスキャンにつながる定期的なバッチレポートクエリーを含む OLTP タイプである混在ワークロード環境では、バッチの実行中に <code class="literal">innodb_old_blocks_time</code> の値を設定すると、通常のワークロードのワーキングセットをバッファープール内に維持するのに役立つ場合があります。
      </p><p>
        バッファープール内に完全には収まらない大きなテーブルをスキャンする場合は、<code class="literal">innodb_old_blocks_pct</code> を小さな値に設定すると、1 回しか読み取られないデータがバッファープールの大きな部分を消費することはなくなります。たとえば、<code class="literal">innodb_old_blocks_pct=5</code> を設定すると、1 回しか読み取られないこのデータがバッファープールの 5% に制限されます。
      </p><p>
        メモリーに収まる小さなテーブルをスキャンする場合は、バッファープール内でページを移動するためのオーバーヘッドが低いため、<code class="literal">innodb_old_blocks_pct</code> をデフォルト値のままにするか、あるいは場合によっては (<code class="literal">innodb_old_blocks_pct=50</code> などと) 増やすこともできます。
      </p><p>
        <code class="literal">innodb_old_blocks_time</code> パラメータの効果は、比較的効果の小さい <code class="literal">innodb_old_blocks_pct</code> パラメータに比べて予測が困難であり、ワークロードによる変動も大きくなります。最適な値に到達するには、<code class="literal">innodb_old_blocks_pct</code> の調整によるパフォーマンス向上が不十分な場合は独自のベンチマークを実施してください。
      </p><p>
        InnoDB バッファープールの詳細は、<a class="xref" href="optimization.html#innodb-buffer-pool" title="8.9.1 InnoDB バッファープール">セクション8.9.1「InnoDB バッファープール」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-multiple-buffer-pools"></a>14.13.1.4 複数のバッファープールインスタンスの使用</h4></div></div></div><a class="indexterm" name="idm139979064764336"></a><p>
        バッファープールが数 G バイトの範囲にあるシステムでは、バッファープールを個別のインスタンスに分割すると、キャッシュされたページに対して異なるスレッドが読み取りおよび書き込みを行うときの競合が減るため、並列性が向上する場合があります。この機能は通常、<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>のサイズが数 G バイトの範囲にあるシステムを対象にしています。複数のバッファープールインスタンスは <code class="literal">innodb_buffer_pool_instances</code> 構成オプションを使用して構成され、また <code class="literal">innodb_buffer_pool_size</code> 値を調整することもできます。
      </p><p>
        InnoDB バッファープールが大きい場合は、メモリーから取得することによって多くのデータ要求を満足できます。複数のスレッドが一度にバッファープールにアクセスしようとした場合は、ボトルネックが発生する可能性があります。この競合を最小限に抑えるために、複数のバッファープールを有効にすることができます。バッファープールに格納されるか、またはバッファープールから読み取られる各ページは、ハッシュ関数を使用して、いずれかのバッファープールにランダムに割り当てられます。各バッファープールは、独自の空きリスト、フラッシュリスト、LRU、およびバッファープールに接続されたその他のすべてのデータ構造を管理し、独自のバッファープール相互排他ロックによって保護されます。
      </p><p>
        複数のバッファープールインスタンスを有効にするには、<code class="literal">innodb_buffer_pool_instances</code> 構成オプションを 1 (デフォルト) より大きく 64 (最大) までの値に設定します。このオプションは、<code class="literal">innodb_buffer_pool_size</code> を 1G バイト以上のサイズに設定した場合にのみ有効になります。指定した合計サイズは、すべてのバッファープール間で分割されます。最高の効率を得るには、<code class="literal">innodb_buffer_pool_instances</code> と <code class="literal">innodb_buffer_pool_size</code> の組み合わせを、各バッファープールインスタンスが少なくとも 1G バイトになるように指定します。
      </p><p>
        InnoDB バッファープールの詳細は、<a class="xref" href="optimization.html#innodb-buffer-pool" title="8.9.1 InnoDB バッファープール">セクション8.9.1「InnoDB バッファープール」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-preload-buffer-pool"></a>14.13.1.5 再起動を高速化するための InnoDB バッファープールのプリロード</h4></div></div></div><p>
        特に、大きな<code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>を持つインスタンスの場合は、サーバーを再起動したあとの非常に長い<a class="link" href="glossary.html#glos_warm_up" title="ウォームアップ">ウォームアップ</a>期間を回避するために、サーバーのシャットダウン時に <code class="literal">InnoDB</code> バッファープールの状態を保存し、サーバーの起動時にバッファープールを同じ状態にリストアすることができます。
      </p><p>
        ビジー状態のサーバーを再起動したあと、通常は、<code class="literal">InnoDB</code> バッファープール内にあったディスクページがメモリーに戻されるにつれ (同じデータへのクエリーや更新などが実行されるにつれ)、スループットが着実に向上するウォームアップ期間が存在します。バッファープールをシャットダウン前の状態にリストアする機能により、DML 操作での対応する行へのアクセスを待つのではなく、再起動前にバッファープール内にあったディスクページをただちにリロードできるため、ウォームアップ期間が短くなります。I/O 要求を大きなバッチで実行できるため、I/O 全体がより高速になります。ページのロードはバックグラウンドで実行されるため、データベースの起動が遅れることはありません。
      </p><p>
        バッファープールの状態をシャットダウン時に保存し、起動時にリストアすることに加え、サーバーの実行中にも、バッファープールの状態をいつでも保存およびリストアすることができます。たとえば、定常状態のワークロードの下で安定したスループットに達したあとに、バッファープールの状態を保存できます。その操作の期間中にのみ必要なデータページをバッファープールに移動するレポートまたは保守ジョブを実行したあとや、標準的でないワークロードを使用したその他の一定期間のあとに、バッファープールの以前の状態をリストアできます。
      </p><p>
        バッファープール自体のサイズは何 G バイトもある可能性がありますが、<code class="literal">InnoDB</code> がディスク上に保存するデータはそれに比べて非常に少量です。該当するページを見つけるために必要なテーブルスペース ID とページ ID だけがディスクに保存されます。この情報は、<code class="literal">INNODB_BUFFER_PAGE_LRU</code> <code class="literal">INFORMATION_SCHEMA</code> テーブルから取得されます。デフォルトでは、テーブルスペース ID とページ ID のデータは、<code class="literal">InnoDB</code> データディレクトリに保存される <code class="filename">ib_buffer_pool</code> という名前のファイル内に保存されます。このファイル名は、<code class="literal">innodb_buffer_pool_filename</code> 構成パラメータを使用して変更できます。
      </p><p>
        ベースとなるメカニズムには、ダンプおよびロード操作を実行するためにディスパッチされるバックグラウンドスレッドが含まれています。
      </p><p>
        圧縮テーブルからのディスクページは、その圧縮された形式でバッファープールにロードされます。DML 操作の過程でページの内容がアクセスされると、圧縮解除が通常どおりに実行されます。圧縮解除は CPU を大量に消費するプロセスであるため、並列性としては、バッファープールのリストア操作を実行する単一スレッドではなく、接続スレッドのいずれかで操作を実行する方が効率的です。
      </p><p>
        デフォルトでは、バッファープールの状態は、<code class="literal">InnoDB</code> データディレクトリに保存される <code class="filename">ib_buffer_pool</code> という名前のファイル内に保存されます。このファイル名は、<code class="literal">innodb_buffer_pool_filename</code> 構成パラメータを使用して変更できます。
      </p><h5><a name="idm139979064728320"></a>バッファープールの状態の保存</h5><p>
        サーバーのシャットダウン時に <code class="literal">InnoDB</code> バッファープールの状態を保存するには、次のステートメントを発行します。
      </p><pre class="programlisting">SET GLOBAL innodb_buffer_pool_dump_at_shutdown=ON;</pre><p>
        MySQL サーバーの実行中に <code class="literal">InnoDB</code> バッファープールの状態を保存するには、次のステートメントを発行します。
      </p><pre class="programlisting">SET GLOBAL innodb_buffer_pool_dump_now=ON;</pre><h5><a name="idm139979064723280"></a>バッファープールの状態のリストア</h5><p>
        サーバーの起動時に <code class="literal">InnoDB</code> バッファープールの状態をリストアするには、サーバーを起動するときに <code class="literal">--innodb_buffer_pool_load_at_startup</code> オプションを指定します。
      </p><pre class="programlisting">mysqld --innodb_buffer_pool_load_at_startup=ON;</pre><p>
        MySQL の実行中に <code class="literal">InnoDB</code> バッファープールの状態をリストアするには、次のステートメントを発行します。
      </p><pre class="programlisting">SET GLOBAL innodb_buffer_pool_load_now=ON;</pre><h5><a name="idm139979064717472"></a>バッファープールのダンプの進行状況の表示</h5><p>
        <code class="literal">InnoDB</code> バッファープールの状態をディスクに保存しているときに進行状況を表示するには、次のいずれかのオプションを使用します。
      </p><pre class="programlisting">SHOW STATUS LIKE 'innodb_buffer_pool_dump_status';</pre><p>
        または
      </p><pre class="programlisting">SELECT variable_value FROM information_schema.global_status WHERE
variable_name = 'INNODB_BUFFER_POOL_DUMP_STATUS';</pre><p>
        操作がまだ開始されていない場合は、<span class="quote">「<span class="quote">not started</span>」</span> が返されます。操作が完了している場合は、完了時間が出力されます (たとえば、Finished at 110505 12:18:02)。操作が進行中である場合は、ステータス情報が表示されます (たとえば、Dumping buffer pool 5/7, page 237/2873)。
      </p><h5><a name="idm139979064711760"></a>バッファープールのロードの進行状況の表示</h5><p>
        <code class="literal">InnoDB</code> バッファープールをロードしているときに進行状況を表示するには、次のいずれかのオプションを使用します。
      </p><pre class="programlisting">SHOW STATUS LIKE 'innodb_buffer_pool_load_status';</pre><p>
        または
      </p><pre class="programlisting">SELECT variable_value FROM information_schema.global_status WHERE
variable_name = 'INNODB_BUFFER_POOL_LOAD_STATUS';</pre><p>
        操作がまだ開始されていない場合は、<span class="quote">「<span class="quote">not started</span>」</span> が返されます。操作が完了している場合は、完了時間が出力されます (たとえば、Finished at 110505 12:23:24)。操作が進行中である場合は、ステータス情報が表示されます (たとえば、Loaded 123/22301 pages)。
      </p><h5><a name="idm139979064706112"></a>バッファープールのロードの中止</h5><p>
        バッファープールのロード操作を中止するには、次のステートメントを発行します。
      </p><pre class="programlisting">SET innodb_buffer_pool_load_abort=ON;</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-lru-background-flushing"></a>14.13.1.6 InnoDB バッファープールのフラッシュのチューニング</h4></div></div></div><p>
        

        構成オプション <code class="literal">innodb_flush_neighbors</code> および <code class="literal">innodb_lru_scan_depth</code> を使用すると、<code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>に対する<a class="link" href="glossary.html#glos_flush" title="フラッシュ">フラッシュ</a>プロセスの特定の側面を微調整できます。これらのオプションは主に、書き込みの多い<a class="link" href="glossary.html#glos_workload" title="ワークロード">ワークロード</a>に役立ちます。負荷の高い <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> アクティビティーでは、それが十分に積極的でないとフラッシュが遅延して、バッファープールで過剰なメモリーが使用される場合があります。または、そのメカニズムが積極的すぎると、フラッシュによるディスク書き込みによって I/O 容量が飽和する場合があります。理想的な設定は、ワークロード、データのアクセスパターン、およびストレージ構成 (たとえば、データが <a class="link" href="glossary.html#glos_hdd" title="HDD">HDD</a> または <a class="link" href="glossary.html#glos_ssd" title="SSD">SSD</a> デバイスのどちらに格納されているか) によって異なります。
      </p><p>
        <a class="link" href="glossary.html#glos_workload" title="ワークロード">ワークロード</a>の負荷が常時高いシステム、またはワークロードが大幅に変動するシステムでは、複数の構成オプション <code class="literal">innodb_adaptive_flushing_lwm</code>、<code class="literal">innodb_max_dirty_pages_pct_lwm</code>、<code class="literal">innodb_io_capacity_max</code>、および <code class="literal">innodb_flushing_avg_loops</code> を使用して <code class="literal">InnoDB</code> テーブルに対する<a class="link" href="glossary.html#glos_flush" title="フラッシュ">フラッシュ</a>動作を微調整できます。これらのオプションは、<code class="literal">innodb_adaptive_flushing</code> オプションによって使用される計算式に入力されます。
      </p><p>
        <code class="literal">innodb_adaptive_flushing</code>、<code class="literal">innodb_io_capacity</code>、および <code class="literal">innodb_max_dirty_pages_pct</code> オプションは、次のオプション <code class="literal">innodb_adaptive_flushing_lwm</code>、<code class="literal">innodb_io_capacity_max</code>、および <code class="literal">innodb_max_dirty_pages_pct_lwm</code> によって制限または拡張されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_adaptive_flushing" title="適応型フラッシュ">適応型フラッシュ</a>メカニズムは、すべての場合に適切なわけではありません。これがもっとも大きな利点をもたらすのは、<a class="link" href="glossary.html#glos_redo_log" title="Redo ログ">Redo ログ</a>がいっぱいになるおそれがある場合です。<code class="literal">innodb_adaptive_flushing_lwm</code> オプションは、Redo ログ容量の<span class="quote">「<span class="quote">低位境界値</span>」</span>の割合 (%) を指定します。そのしきい値を超えると、<code class="literal">InnoDB</code> は、<code class="literal">innodb_adaptive_flushing</code> オプションで指定されていない場合でも適応型フラッシュを有効にします。
          </p></li><li class="listitem"><p>
            フラッシュアクティビティーが大幅に遅延した場合、<code class="literal">InnoDB</code> は、<code class="literal">innodb_io_capacity</code> で指定されているより積極的にフラッシュできます。<code class="literal">innodb_io_capacity_max</code> は、I/O のスパイクによってサーバーのすべての容量が消費されてしまわないように、このような緊急の状況で使用される I/O 容量の上限を表します。
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> は、ダーティーページの割合 (%) が <code class="literal">innodb_max_dirty_pages_pct</code> の値を超えないように、バッファープールからデータをフラッシュしようとします。<code class="literal">innodb_max_dirty_pages_pct</code> のデフォルト値は 75 です。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              <code class="literal">innodb_max_dirty_pages_pct</code> 設定は、フラッシュアクティビティーのターゲットを確立します。フラッシュの頻度には影響を与えません。フラッシュの頻度の管理については、<a class="xref" href="innodb-storage-engine.html#innodb-performance-adaptive_flushing" title="14.13.1.2 InnoDB バッファープールのフラッシュの頻度の構成">セクション14.13.1.2「InnoDB バッファープールのフラッシュの頻度の構成」</a>を参照してください。
            </p></div><p>
            <code class="literal">innodb_max_dirty_pages_pct_lwm</code> オプションは、ダーティーページの比率を制御するために事前フラッシュを有効にし、理想的にはダーティーページの割合 (%) が <code class="literal">innodb_max_dirty_pages_pct</code> に達しないようにするダーティーページの割合 (%) を表す、<span class="quote">「<span class="quote">低位境界値</span>」</span>の値を指定します。<code class="literal">innodb_max_dirty_pages_pct_lwm=0</code> の値を指定すると、<span class="quote">「<span class="quote">事前フラッシュ</span>」</span>動作が無効になります。
          </p></li></ul></div><p>
        上で参照されたオプションのほとんどは、書き込み負荷の高いワークロードを長期間にわたって実行しており、ディスクへの書き込みを待機している変更に追い付くためにロード時間の削減がほとんどないサーバーにもっとも適しています。
      </p><p>
        <code class="literal">innodb_flushing_avg_loops</code> は、<code class="literal">InnoDB</code> が以前に計算されたフラッシュ状態のスナップショットを保持する反復の数を定義します。これは、適応型フラッシュがフォアグラウンドの負荷の変化にどれだけすばやく応答するかを制御します。<code class="literal">innodb_flushing_avg_loops</code> に大きな値を設定すると、<code class="literal">InnoDB</code> が以前に計算されたスナップショットをより長く保持するため、適応型フラッシュはよりゆっくり応答します。大きな値ではまた、フォアグラウンド作業とバックグラウンド作業の間の正のフィードバックも削減されますが、大きな値を設定する場合は、<code class="literal">InnoDB</code> の Redo ログの使用率が 75% (非同期のフラッシュが開始されるハードコードされた制限) に達しないようにすること、および <code class="literal">innodb_max_dirty_pages_pct</code> 設定によってダーティーページの数がそのワークロードに適したレベルに維持されるようにすることが重要です。
      </p><p>
        ワークロードに一貫性があり、<code class="literal">innodb_log_file_size</code> が大きく、かつスパイクが小さいために Redo ログ領域の使用率が 75% に達しないシステムでは、フラッシュをできるだけ滑らかな状態に維持するために大きな <code class="literal">innodb_flushing_avg_loops</code> 値を使用するようにしてください。負荷のスパイクが極端なシステム、またはログファイルでは多くの領域が提供されないシステムでは、より小さな <code class="literal">innodb_flushing_avg_loops</code> 値を検討してください。この値を小さくすると、フラッシュで負荷を密接に追跡できるため、Redo ログ領域の使用率が 75% に達しないようにするのに役立ちます。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-performance-latching"></a>14.13.2 InnoDB 相互排他ロックおよび読み取り/書き込みロックの実装</h3></div></div></div><p>
      MySQL および <code class="literal">InnoDB</code> では、実行の複数のスレッドが共有データ構造にアクセスします。<code class="literal">InnoDB</code> は、これらのアクセスを<a class="link" href="glossary.html#glos_mutex" title="相互排他ロック">相互排他ロック</a>と<a class="link" href="glossary.html#glos_rw_lock" title="rw ロック (読み書きロック)">読み取り/書き込みロック</a>の独自の実装と同期させます。<code class="literal">InnoDB</code> は従来、<code class="literal">InnoDB</code> 相互排他ロックを使用して読み取り/書き込みロックの内部状態を保護してきました。Unix および Linux プラットフォームでは、IEEE Std 1003.1c (POSIX.1c) にあるように、<code class="literal">InnoDB</code> 相互排他ロックの内部状態は <a class="link" href="glossary.html#glos_pthreads" title="Pthreads">Pthreads</a> 相互排他ロックによって保護されます。
    </p><p>
      多くのプラットフォームには、相互排他ロックと読み取り/書き込みロックを実装するためのより効率的な方法が存在します。<a class="link" href="glossary.html#glos_atomic" title="原子的">アトミック</a>操作を使用すると、多くの場合、Pthreads より効率的に複数のスレッドのアクションを同期させることができます。ロックを取得または解放する各操作をより少ない CPU 命令で実行できるため、共有データ構造へのアクセスのためにスレッドが競合している場合の浪費時間が少なくなります。マルチコアプラットフォーム上では、これがさらにスケーラビリティーを向上させます。
    </p><p>
      <code class="literal">InnoDB</code> は、以前に使用されていた Pthreads のアプローチを使用する代わりに、<a class="ulink" href="http://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Atomic-Builtins.html" target="_top">アトミックメモリーアクセスのための GNU コンパイラコレクション (GCC) によって提供される組み込み関数</a>を使用して相互排他ロックと読み取り/書き込みロックを実装します。より具体的には、GCC バージョン 4.1.2 以降でコンパイルされた <code class="literal">InnoDB</code> は、<code class="literal">pthread_mutex_t</code> の代わりにアトミックビルトインを使用して <code class="literal">InnoDB</code> 相互排他ロックおよび読み取り/書き込みロックを実装します。
    </p><p>
      32 ビットの Microsoft Windows では、<code class="literal">InnoDB</code> は、手で書かれたアセンブラ命令を使用して (読み取り/書き込みロックではなく) 相互排他ロックを実装していました。Microsoft Windows 2000 からは、GCC によって提供される組み込み関数と同様の、<a class="ulink" href="http://msdn.microsoft.com/en-us/library/ms684122(VS.85).aspx" target="_top">インターロックされた変数アクセス</a>のための関数が使用できます。Windows 2000 以降では、<code class="literal">InnoDB</code> はインターロックされた関数を使用します。手で書かれた古いアセンブラコードとは異なり、新しい実装では、読み取り/書き込みロックと 64 ビットプラットフォームがサポートされます。
    </p><p>
      Solaris 10 ではアトミック操作のためのライブラリ関数が導入され、InnoDB は、デフォルトでこれらの関数を使用します。<a class="ulink" href="http://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Atomic-Builtins.html" target="_top">アトミックメモリーアクセスのための GNU コンパイラコレクション (GCC) によって提供される組み込み関数</a>をサポートしていないコンパイラを備えた Solaris 10 上で MySQL がコンパイルされた場合、<code class="literal">InnoDB</code> はライブラリ関数を使用します。
    </p><p>
      この変更によって、マルチコアシステム上の <code class="literal">InnoDB</code> のスケーラビリティーが向上します。この機能は、それがサポートされているプラットフォーム上で標準で有効になります。パフォーマンスの向上を利用するためにパラメータやオプションを設定する必要はありません。アトミックメモリーアクセスのための GCC、Windows、または Solaris 関数が使用できないプラットフォームでは、<code class="literal">InnoDB</code> は、相互排他ロックと読み取り/書き込みロックを実装するための従来の Pthreads の方法を使用します。
    </p><p>
      MySQL が起動すると、<code class="literal">InnoDB</code> は、アトミックメモリーアクセスが相互排他ロックに使用されるか、相互排他ロックと読み取り/書き込みロックに使用されるか、またはどちらにも使用されないかを示すメッセージをログファイルに書き込みます。適切なツールを使用して <code class="literal">InnoDB</code> が構築されており、かつターゲット CPU が必要なアトミック操作をサポートしている場合、<code class="literal">InnoDB</code> は、相互排他ロックに組み込み関数を使用します。さらに、スレッド識別子 (<code class="literal">pthread_t</code>) で比較およびスワップ操作を使用できる場合、<code class="literal">InnoDB</code> は、読み取り/書き込みロックのための命令も使用します。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        ソースからビルドしている場合は、そのビルドプロセスがプラットフォームの機能を正しく利用していることを確認してください。
      </p></div><p>
      ロックのパフォーマンスへの影響の詳細は、<a class="xref" href="optimization.html#locking-issues" title="8.10 ロック操作の最適化">セクション8.10「ロック操作の最適化」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-performance-use_sys_malloc"></a>14.13.3 InnoDB のためのメモリーアロケータの構成</h3></div></div></div><a class="indexterm" name="idm139979064604704"></a><a class="indexterm" name="idm139979064603184"></a><a class="indexterm" name="idm139979064601232"></a><a class="indexterm" name="idm139979064599056"></a><a class="indexterm" name="idm139979064597088"></a><a class="indexterm" name="idm139979064594784"></a><p>
      <code class="literal">InnoDB</code> が開発されたとき、オペレーティングシステムに付属のメモリーアロケータや実行時ライブラリは多くの場合、パフォーマンスとスケーラビリティーに欠けていました。その時点では、マルチコア CPU 用にチューニングされたメモリーアロケータライブラリは存在しませんでした。そのため、<code class="literal">InnoDB</code> は、<code class="literal">mem</code> サブシステム内に独自のメモリーアロケータを実装しました。このアロケータは単一の相互排他ロックによって保護されており、これが<a class="link" href="glossary.html#glos_bottleneck" title="ボトルネック">ボトルネック</a>になる可能性があります。<code class="literal">InnoDB</code> はまた、システムアロケータ (<code class="literal">malloc</code> および <code class="literal">free</code>) の周りに、同様に単一の相互排他ロックによって保護されているラッパーインタフェースも実装しています。
    </p><p>
      今日、マルチコアシステムがより広範囲に使用可能になるにつれ、またオペレーティングシステムが成熟するにつれ、オペレーティングシステムに付属のメモリーアロケータに対して大幅な機能強化が行われてきました。新しいメモリーアロケータは以前のものより性能が向上し、またよりスケーラブルになりました。主要な高性能メモリーアロケータには、<code class="literal">Hoard</code>、<code class="literal">libumem</code>、<code class="literal">mtmalloc</code>、<code class="literal">ptmalloc</code>、<code class="literal">tbbmalloc</code>、および <code class="literal">TCMalloc</code> が含まれます。ほとんどのワークロードは、特にメモリーの割り当てと解放が頻繁に行われる (マルチテーブル結合などの) 場合、内部の <code class="literal">InnoDB</code> 固有のメモリーアロケータではなく、より高度にチューニングされたメモリーアロケータを使用するとメリットがあります。
    </p><p>
      <code class="literal">InnoDB</code> が独自のメモリーアロケータまたはオペレーティングシステムのアロケータのどちらを使用するかは、MySQL オプションファイル (<code class="literal">my.cnf</code> または <code class="literal">my.ini</code>) 内のシステム構成パラメータ <code class="literal">innodb_use_sys_malloc</code> の値を設定することによって制御できます。<code class="literal">ON</code> または <code class="literal">1</code> (デフォルト) に設定されている場合、<code class="literal">InnoDB</code> はメモリープールを自ら管理するのではなく、ベースとなるシステムの <code class="literal">malloc</code> および <code class="literal">free</code> 関数を使用します。このパラメータは動的ではなく、システムが起動された場合にのみ有効になります。<code class="literal">InnoDB</code> メモリーアロケータを引き続き使用するには、<code class="literal">innodb_use_sys_malloc</code> を <code class="literal">0</code> に設定します。
    </p><p>
      <code class="literal">InnoDB</code> メモリーアロケータが無効になっている場合、<code class="literal">InnoDB</code> は、パラメータ <code class="literal">innodb_additional_mem_pool_size</code> の値を無視します。<code class="literal">InnoDB</code> メモリーアロケータは、システムメモリーアロケータにフォールバックしなくても割り当て要求を満たせるように、追加のメモリープールを使用します。<code class="literal">InnoDB</code> メモリーアロケータが無効になっている場合、このような割り当て要求はすべて、システムメモリーアロケータによって満たされます。
    </p><p>
      動的リンクを使用する Unix ライクなシステムでは、メモリーアロケータの置き換えは、環境変数 <code class="literal">LD_PRELOAD</code> または <code class="literal">LD_LIBRARY_PATH</code> がそのアロケータを実装している動的ライブラリを指すようにするだけの簡単な操作で済むことがあります。ほかのシステムでは、ある程度の再リンクが必要になる可能性があります。選択したメモリーアロケータライブラリのドキュメントを参照してください。
    </p><p>
      システムメモリーアロケータが使用されている (<code class="literal">innodb_use_sys_malloc</code> が <code class="literal">ON</code> である) 場合、<code class="literal">InnoDB</code> はすべてのメモリー使用を追跡することができないため、<code class="literal">SHOW ENGINE INNODB STATUS</code> コマンドの出力内のセクション<span class="quote">「<span class="quote">BUFFER POOL AND MEMORY</span>」</span>の<span class="quote">「<span class="quote">Total memory allocated</span>」</span>にはバッファープールの統計のみが含まれます。<code class="literal">mem</code> サブシステムまたは <code class="literal">ut_malloc</code> を使用して割り当てられたメモリーはすべて除外されます。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">innodb_use_sys_malloc</code> と <code class="literal">innodb_additional_mem_pool_size</code> は MySQL 5.6.3 では非推奨であり、将来のリリースで削除される予定です。
      </p></div><p>
      <code class="literal">InnoDB</code> のメモリー使用のパフォーマンスへの影響の詳細は、<a class="xref" href="optimization.html#buffering-caching" title="8.9 バッファリングとキャッシュ">セクション8.9「バッファリングとキャッシュ」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-performance-change_buffering"></a>14.13.4 InnoDB 変更バッファリングの構成</h3></div></div></div><a class="indexterm" name="idm139979064547792"></a><a class="indexterm" name="idm139979064546512"></a><a class="indexterm" name="idm139979064544400"></a><a class="indexterm" name="idm139979064542224"></a><p>
      テーブルに対して <code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、および <code class="literal">DELETE</code> 操作が実行されると、インデックス付きカラムの値 (特に副キーの値) は多くの場合、ソートされた順番にならないため、セカンダリインデックスを最新の状態にするために大量の I/O が必要になります。<code class="literal">InnoDB</code> は、<a class="link" href="glossary.html#glos_insert_buffer" title="挿入バッファー">挿入バッファー</a>を備えています。これは、関連する<a class="link" href="glossary.html#glos_page" title="ページ">ページ</a>が<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>内にない場合にセカンダリインデックスエントリへの変更をキャッシュすることにより、そのページをディスクから読み取らないことで I/O 操作を回避するものです。バッファリングされた変更は、そのページがバッファープールにロードされたときにマージされ、更新されたページはあとで通常のメカニズムを使用してディスクにフラッシュされます。<code class="literal">InnoDB</code> のメインスレッドは、それらのバッファリングされた変更を、サーバーがほぼアイドル状態にあるときと<a class="link" href="glossary.html#glos_slow_shutdown" title="低速シャットダウン">低速シャットダウン</a>中にマージします。
    </p><p>
      これにより、ディスクの読み取りや書き込みが少なくなる場合があるため、この機能は、I/O に依存するワークロード (たとえば、一括挿入などの大量の DML 操作を含むアプリケーション) にとってもっとも価値があります。
    </p><p>
      ただし、挿入バッファーはバッファープールの一部を占有するため、データページをキャッシュするために使用できるメモリーが減少します。ワーキングセットがバッファープールにほぼ収まる場合や、テーブルのセカンダリインデックスが比較的少ない場合は、挿入バッファリングを無効にすると役立つことがあります。ワーキングセットがバッファープールに完全に収まる場合は、挿入バッファリングはバッファープール内にないページにしか適用されないため、追加で課せられるオーバーヘッドはありません。
    </p><p>
      <code class="literal">InnoDB</code> がどの程度挿入バッファリングを実行するかは、システム構成パラメータ <code class="literal">innodb_change_buffering</code> を使用して制御できます。挿入操作、削除操作 (インデックスレコードが最初に削除対象としてマークされるとき)、およびパージ操作 (インデックスレコードが物理的に削除されるとき) でのバッファリングを有効または無効にすることができます。更新操作は、挿入と削除の組み合わせとして表されます。MySQL 5.5 以降では、デフォルト値が <code class="literal">inserts</code> から <code class="literal">all</code> に変更されました。
    </p><p>
      <code class="literal">innodb_change_buffering</code> の許可される値は次のとおりです。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <span class="bold"><strong><code class="literal">all</code></strong></span>
        </p><p>
          デフォルト値: バッファーの挿入、削除のマーキング操作、およびパージ。
        </p></li><li class="listitem"><p>
          <span class="bold"><strong><code class="literal">none</code></strong></span>
        </p><p>
          どの操作もバッファリングしません。
        </p></li><li class="listitem"><p>
          <span class="bold"><strong><code class="literal">inserts</code></strong></span>
        </p><p>
          挿入操作をバッファリングします。
        </p></li><li class="listitem"><p>
          <span class="bold"><strong><code class="literal">deletes</code></strong></span>
        </p><p>
          削除のマーキング操作をバッファリングします。
        </p></li><li class="listitem"><p>
          <span class="bold"><strong><code class="literal">changes</code></strong></span>
        </p><p>
          挿入と削除のマーキングの両方をバッファリングします。
        </p></li><li class="listitem"><p>
          <span class="bold"><strong><code class="literal">purges</code></strong></span>
        </p><p>
          バックグラウンドで実行される物理的な削除操作をバッファリングします。
        </p></li></ul></div><p>
      このパラメータの値は MySQL オプションファイル (<code class="literal">my.cnf</code> または <code class="literal">my.ini</code>) で設定するか、あるいは <code class="literal">SET GLOBAL</code> コマンド (これには <code class="literal">SUPER</code> 権限が必要です) で動的に変更できます。この設定を変更すると、新しい操作のバッファリングに影響を与えます。すでにバッファリングされたエントリのマージは影響を受けません。
    </p><p>
      <code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、および <code class="literal">DELETE</code> ステートメントの高速化の詳細は、<a class="xref" href="optimization.html#non-select-optimization" title="8.2.2 DML ステートメントの最適化">セクション8.2.2「DML ステートメントの最適化」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-performance-thread_concurrency"></a>14.13.5 InnoDB のスレッド並列性の構成</h3></div></div></div><a class="indexterm" name="idm139979064498496"></a><a class="indexterm" name="idm139979064497200"></a><a class="indexterm" name="idm139979064495824"></a><a class="indexterm" name="idm139979064494448"></a><a class="indexterm" name="idm139979064492256"></a><p>
      <code class="literal">InnoDB</code> は、オペレーティングシステム<a class="link" href="glossary.html#glos_thread" title="スレッド">スレッド</a>を使用して、ユーザートランザクションからの要求を処理します。(トランザクションは、コミットまたはロールバックする前に、<code class="literal">InnoDB</code> に多数の要求を発行する可能性があります。)コンテキストスイッチングが効率的な、マルチコアプロセッサを備えた最新のオペレーティングシステムおよびサーバーでは、並列スレッドの数を制限することなく、ほとんどのワークロードが適切に動作します。MySQL 5.5 以降でのスケーラビリティーの向上によって、<code class="literal">InnoDB</code> の内部の並列実行中のスレッドの数を制限する必要性は低下します。
    </p><p>
      スレッド間のコンテキストスイッチングを最小限に抑えることが役立つ状況では、<code class="literal">InnoDB</code> はいくつかの手法を使用して、並列実行中のオペレーティングシステムスレッドの数 (したがって、一度に処理される要求の数) を制限できます。<code class="literal">InnoDB</code> がユーザーセッションからの新しい要求を受信したとき、並列実行中のスレッドの数が事前に定義された制限に達している場合、その新しい要求は再試行の前に短時間だけスリープします。スリープのあとに再スケジュールできない要求は先入れ先出しキューに入れられ、最終的に処理されます。ロックを待機しているスレッドは、並列実行中のスレッドの数にカウントされません。
    </p><p>
      並列スレッドの数は、構成パラメータ <code class="literal">innodb_thread_concurrency</code> を設定することによって制限できます。実行中のスレッドの数がこの制限に達すると、追加のスレッドはキューに入れられる前に、構成パラメータ <code class="literal">innodb_thread_sleep_delay</code> で設定されたマイクロ秒数だけスリープします。
    </p><p>
      以前は、<code class="literal">innodb_thread_sleep_delay</code> の最適な値を見つけるには実験が必要であり、その最適な値もワークロードによって変化する可能性がありました。MySQL 5.6.3 以降では、構成オプション <code class="literal">innodb_adaptive_max_sleep_delay</code> を <code class="literal">innodb_thread_sleep_delay</code> に許可するもっとも大きな値に設定することができ、<code class="literal">InnoDB</code> が、現在のスレッドスケジューリングアクティビティーに応じて <code class="literal">innodb_thread_sleep_delay</code> を上または下に自動的に調整します。この動的な調整は、システムにかかる負荷が軽い期間や、システムがほぼ容量いっぱいで動作している期間に、スレッドスケジューリングメカニズムがスムーズに機能するのに役立ちます。
    </p><p>
      <code class="literal">innodb_thread_concurrency</code> のデフォルト値や、並列スレッドの数に対する暗黙的なデフォルトの制限は、MySQL および <code class="literal">InnoDB</code> のさまざまなリリースで変更されてきました。現在、デフォルトでは並列実行中のスレッドの数に対して制限がないように、<code class="literal">innodb_thread_concurrency</code> のデフォルト値は <code class="literal">0</code> です。
    </p><p>
      <code class="literal">InnoDB</code> がスレッドをスリープさせるのは、並列スレッドの数が制限されている場合だけであることに注意してください。スレッドの数に対して制限がない場合は、すべてが均等に競合してスケジュールされます。つまり、<code class="literal">innodb_thread_concurrency</code> が <code class="literal">0</code> である場合は、<code class="literal">innodb_thread_sleep_delay</code> の値は無視されます。
    </p><p>
      スレッドの数に対して制限がある (<code class="literal">innodb_thread_concurrency</code> &gt; 0 である) 場合、<code class="literal">InnoDB</code> は、<span class="emphasis"><em>1 つの SQL ステートメント</em></span>の実行中に発行された複数の要求が <code class="literal">innodb_thread_concurrency</code> で設定された制限に従うことなく <code class="literal">InnoDB</code> に入ることを許可することによって、コンテキストスイッチングのオーバーヘッドを削減します。SQL ステートメント (結合など) は <code class="literal">InnoDB</code> 内の複数の行操作で構成されている可能性があるため、<code class="literal">InnoDB</code> は、スレッドが最小限のオーバーヘッドで繰り返しスケジュールされることを許可する指定された数の<span class="quote">「<span class="quote">チケット</span>」</span>を割り当てます。
    </p><p>
      新しい SQL ステートメントが開始されたとき、スレッドにはチケットがないため、<code class="literal">innodb_thread_concurrency</code> に従う必要があります。スレッドが <code class="literal">InnoDB</code> に入ることを許可されると、そのスレッドには、行操作を実行するためにあとで <code class="literal">InnoDB</code> に入るときに使用できる複数のチケットが割り当てられます。それらのチケットが使い果たされた場合、スレッドは削除され、ふたたび <code class="literal">innodb_thread_concurrency</code> に従います。それにより、そのスレッドが、待機中のスレッドの先入れ先出しキューに戻される可能性があります。スレッドがふたたび <code class="literal">InnoDB</code> に入ることを許可されると、チケットが再度割り当てられます。割り当てられるチケットの数は、グローバルオプション <code class="literal">innodb_concurrency_tickets</code> (デフォルトでは 5000、5.6.6 より前は 500) で指定されます。ロックを待機しているスレッドには、そのロックが使用可能になるとチケットが 1 つ与えられます。
    </p><p>
      これらの変数の正しい値は、環境やワークロードによって異なります。アプリケーションでどのような値が機能するかを確認するには、さまざまな値を試してください。並列実行中のスレッドの数を制限する前に、マルチコアおよびマルチプロセッサコンピュータ上の <code class="literal">InnoDB</code> のパフォーマンスを向上させる可能性のある構成オプション (<code class="literal">innodb_adaptive_hash_index</code> など) を確認してください。
    </p><p>
      MySQL のスレッド処理に関する一般的なパフォーマンス情報については、<a class="xref" href="optimization.html#connection-threads" title="8.11.5.1 MySQL のクライアント接続のためのスレッドの使用方法">セクション8.11.5.1「MySQL のクライアント接続のためのスレッドの使用方法」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-performance-multiple_io_threads"></a>14.13.6 InnoDB バックグラウンド I/O スレッドの数の構成</h3></div></div></div><a class="indexterm" name="idm139979064443952"></a><a class="indexterm" name="idm139979064442672"></a><a class="indexterm" name="idm139979064440560"></a><a class="indexterm" name="idm139979064439200"></a><a class="indexterm" name="idm139979064437088"></a><a class="indexterm" name="idm139979064434912"></a><p>
      InnoDB は、さまざまなタイプの I/O 要求を処理するためにバックグラウンド<a class="link" href="glossary.html#glos_thread" title="スレッド">スレッド</a>を使用します。構成パラメータ <code class="literal">innodb_read_io_threads</code> および <code class="literal">innodb_write_io_threads</code> を使用して、データページに対する読み取りおよび書き込み I/O を処理するバックグラウンドスレッドの数を構成できます。これらのパラメータはそれぞれ、読み取りおよび書き込み要求に使用されるバックグラウンドスレッドの数を示します。これらは、サポートされるすべてのプラットフォームで有効です。これらのパラメータの値は、MySQL オプションファイル (<code class="literal">my.cnf</code> または <code class="literal">my.ini</code>) で設定できます。動的に変更することはできません。これらのパラメータのデフォルト値は <code class="literal">4</code> であり、許可される値の範囲は <code class="literal">1-64</code> です。
    </p><p>
      この変更の目的は、InnoDB をハイエンドのシステム上でよりスケーラブルにすることです。各バックグラウンドスレッドは、保留中の I/O 要求を最大 256 個処理できます。バックグラウンド I/O の主なソースは、<a class="link" href="glossary.html#glos_read_ahead" title="先読み">先読み</a>要求です。InnoDB は、バックグラウンドスレッドのほとんどが均等に作業を共有するような方法で、受信要求の負荷のバランスをとろうとします。InnoDB はまた、要求を 1 つに合体できる可能性を増やすために、読み取り要求を同じエクステントから同じスレッドに割り当てようとします。ハイエンドの I/O サブシステムを使用しており、<code class="literal">SHOW ENGINE INNODB STATUS</code> で 64 × <code class="literal">innodb_read_io_threads</code> 個を超える保留中の読み取り要求が表示される場合は、<code class="literal">innodb_read_io_threads</code> の値を増やすと役立つことがあります。
    </p><p>
      InnoDB の I/O パフォーマンスの詳細は、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.7 InnoDB ディスク I/O の最適化">セクション8.5.7「InnoDB ディスク I/O の最適化」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-performance-group_commit"></a>14.13.7 グループコミット</h3></div></div></div><a class="indexterm" name="idm139979064417504"></a><p>
      InnoDB では、<a class="link" href="glossary.html#glos_acid" title="ACID">ACID</a> 準拠のほかのデータベースエンジンと同様に、トランザクションの <a class="link" href="glossary.html#glos_redo_log" title="Redo ログ">Redo ログ</a>をそれがコミットされる前にフラッシュします。従来より、InnoDB は<a class="link" href="glossary.html#glos_group_commit" title="グループコミット">グループコミット</a>機能を使用してこのような複数のフラッシュ要求を 1 つにグループ化し、コミットごとに 1 つのフラッシュを回避してきました。グループコミットでは、ほぼ同じ時間にコミットする複数のユーザートランザクションのコミットアクションを実行するために InnoDB がログファイルに 1 つの書き込みを発行するため、スループットが大幅に向上します。
    </p><p>
      InnoDB でのグループコミットは MySQL 4.x まで機能し、InnoDB Plugin を含む MySQL 5.1、および MySQL 5.5 以降でふたたび機能しています。MySQL 5.0 での分散トランザクションおよび 2 フェーズコミット (2PC) に対するサポートの導入は、InnoDB のグループコミット機能に混乱をもたらしました。現在、この問題は解決されています。
    </p><p>
      InnoDB 内部のグループコミット機能は、MySQL の 2 フェーズコミットプロトコルとともに機能します。グループコミット機能の再有効化によって、MySQL バイナリログおよび InnoDB ログファイル内のコミットの順序が以前と同じであることが完全に保証されます。これは、<span class="strong"><strong>InnoDB 1.0.4 (つまり、MySQL 5.1 の InnoDB Plugin) 以降で MySQL Enterprise Backup 製品を使用することが完全に安全である</strong></span>ことを示しています。
    </p><p>
      グループコミットは透過的です。この大幅なパフォーマンス向上を利用するために何もする必要はありません。
    </p><p>
      <code class="literal">COMMIT</code> やその他のトランザクション操作のパフォーマンスの詳細は、<a class="xref" href="optimization.html#optimizing-innodb-transaction-management" title="8.5.2 InnoDB トランザクション管理の最適化">セクション8.5.2「InnoDB トランザクション管理の最適化」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-performance-thread_io_rate"></a>14.13.8 InnoDB マスタースレッドの I/O レートの構成</h3></div></div></div><a class="indexterm" name="idm139979064404464"></a><a class="indexterm" name="idm139979064403120"></a><a class="indexterm" name="idm139979064401072"></a><p>
      InnoDB での<a class="link" href="glossary.html#glos_master_thread" title="マスタースレッド">マスタースレッド</a>は、さまざまなタスクをバックグラウンドで実行するスレッドです。これらのタスクは、そのほとんどがダーティーページのバッファープールからのフラッシュや、変更の挿入バッファーから適切なセカンダリインデックスへの書き込みなどの I/O 関連のタスクです。マスタースレッドは、これらのタスクを、サーバーの通常の動作に悪影響を与えない方法で実行しようとします。つまり、使用可能な空き I/O 帯域幅を推定し、自身のアクティビティーをチューニングしてこの空き容量を利用しようとします。従来より、InnoDB は、サーバーの合計 I/O 容量として 100 IOPs (1 秒あたりの入力/出力操作数) のハードコードされた値を使用してきました。
    </p><p>
      パラメータ <code class="literal">innodb_io_capacity</code> は、InnoDB で使用できる全体的な I/O 容量を示します。このパラメータはほぼ、システムが 1 秒あたりに実行できる I/O 操作の数に設定するようにしてください。この値は、システム構成によって異なります。<code class="literal">innodb_io_capacity</code> が設定されている場合、マスタースレッドは設定済みの値に基づいて、バックグラウンドタスクに使用できる I/O 帯域幅を推定します。この値を <code class="literal">100</code> に設定すると、従来の動作に戻ります。
    </p><p>
      <code class="literal">innodb_io_capacity</code> の値は、100 以上の任意の数値に設定できます。デフォルト値は <code class="literal">200</code> であり、標準的な最新の I/O デバイスのパフォーマンスが MySQL の初期のころより向上していることを反映しています。通常、消費者レベルのストレージデバイス (最大 7200 RPM のハードドライブなど) には、以前のデフォルトである 100 近辺の値が適しています。より高速なハードドライブ、RAID 構成、および SSD は、値を大きくするとメリットがあります。
    </p><p>
      <code class="literal">innodb_io_capacity</code> 設定は、すべてのバッファープールインスタンスに対する合計の制限です。ダーティーページがフラッシュされるとき、<code class="literal">innodb_io_capacity</code> 制限は、バッファープールインスタンス間で均等に分割されます。詳細は、<code class="literal">innodb_io_capacity</code> システム変数の説明を参照してください。
    </p><p>
      このパラメータの値は MySQL オプションファイル (<code class="literal">my.cnf</code> または <code class="literal">my.ini</code>) で設定するか、あるいは <code class="literal">SET GLOBAL</code> コマンド (これには <code class="literal">SUPER</code> 権限が必要です) で動的に変更できます。
    </p><p>
      以前、<code class="literal">InnoDB</code> マスタースレッドは、必要な<a class="link" href="glossary.html#glos_purge" title="パージ">パージ</a>操作もすべて実行していました。MySQL 5.6.5 以降では、これらの I/O 操作はほかのバックグラウンドスレッドに移行され、そのスレッドの数は <code class="literal">innodb_purge_threads</code> 構成オプションによって制御されます。
    </p><p>
      InnoDB の I/O パフォーマンスの詳細は、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.7 InnoDB ディスク I/O の最適化">セクション8.5.7「InnoDB ディスク I/O の最適化」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-performance-pause_instruction"></a>14.13.9 InnoDB スピンループでの PAUSE 命令の使用</h3></div></div></div><p>
      InnoDB 内部の同期には、<a class="link" href="glossary.html#glos_spin" title="スピン">スピン</a>ループがよく使用されます。InnoDB は待機中に、InnoDB <a class="link" href="glossary.html#glos_process" title="プロセス">プロセス</a>や<a class="link" href="glossary.html#glos_thread" title="スレッド">スレッド</a>がオペレーティングシステムによって再スケジュールされないように、命令の緊密なループを繰り返し実行します。スピンループの実行が速すぎると、システムリソースが浪費され、それによってトランザクションスループットのパフォーマンスが低下します。最新のプロセッサは、スピンループで使用する <code class="literal">PAUSE</code> 命令を実装しているため、プロセッサをより効率的にすることができます。
    </p><p>
      InnoDB は、このような命令が使用可能なすべてのプラットフォーム上のスピンループで <code class="literal">PAUSE</code> 命令を使用します。この手法により、CPU に依存するワークロードの全体的なパフォーマンスが向上するだけでなく、スピンループの実行中の消費電力が最小限に抑えられるという利点も追加されます。
    </p><p>
      このパフォーマンス向上を利用するために何もする必要はありません。
    </p><p>
      InnoDB のロック操作に関するパフォーマンスの考慮事項については、<a class="xref" href="optimization.html#locking-issues" title="8.10 ロック操作の最適化">セクション8.10「ロック操作の最適化」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-performance-spin_lock_polling"></a>14.13.10 スピンロックのポーリングの構成</h3></div></div></div><a class="indexterm" name="idm139979064365136"></a><a class="indexterm" name="idm139979064363856"></a><p>
      InnoDB の多くの<a class="link" href="glossary.html#glos_mutex" title="相互排他ロック">相互排他ロック</a>や<a class="link" href="glossary.html#glos_rw_lock" title="rw ロック (読み書きロック)">読み書きロック</a>は短時間だけ予約されます。マルチコアシステムでは、スレッドがスリープの前に相互排他ロックまたは読み書きロックをしばらくの間取得できるかどうかを連続して確認すると、より効率的になる場合があります。このポーリング期間中に相互排他ロックまたは読み書きロックが使用可能になった場合、そのスレッドは同じタイムスライス内でただちに続行できます。ただし、共有オブジェクトの複数のスレッドが頻繁にポーリングしすぎると、<span class="quote">「<span class="quote">キャッシュのピンポン</span>」</span>が発生し、各プロセッサが互いのキャッシュの一部を無効にする場合があります。InnoDB は、以降の各ポーリング間にランダムな時間待つことによってこの問題を最小限に抑えます。この遅延は、ビジーループとして実装されます。
    </p><p>
      相互排他ロックまたは読み書きロックのテスト間の最大の遅延は、パラメータ <code class="literal">innodb_spin_wait_delay</code> を使用して制御できます。遅延ループの期間は、C コンパイラやターゲットプロセッサによって異なります。(100MHz Pentium の時代、この遅延の単位は 1 マイクロ秒でした。)すべてのプロセッサコアが高速なキャッシュメモリーを共有するシステムでは、この最大の遅延を短くするか、または <code class="literal">innodb_spin_wait_delay=0</code> を設定してビジーループを完全に無効にすることができます。複数のプロセッサチップを備えたシステムでは、キャッシュを無効にすると重大な影響を与える場合があるため、最大の遅延を増やすことができます。
    </p><p>
      <code class="literal">innodb_spin_wait_delay</code> のデフォルト値は <code class="literal">6</code> です。スピン待ちの遅延は、MySQL オプションファイル (<code class="literal">my.cnf</code> または <code class="literal">my.ini</code>) で指定したり、コマンド <code class="literal">SET GLOBAL innodb_spin_wait_delay=<em class="replaceable"><code>delay</code></em></code> を使用して実行時に変更したりできる動的なグローバルパラメータです。ここで、<code class="literal"><em class="replaceable"><code>delay</code></em></code> は望ましい最大の遅延です。この設定を変更するには、<code class="literal">SUPER</code> 権限が必要です。
    </p><p>
      InnoDB のロック操作に関するパフォーマンスの考慮事項については、<a class="xref" href="optimization.html#locking-issues" title="8.10 ロック操作の最適化">セクション8.10「ロック操作の最適化」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-performance-schema"></a>14.13.11 InnoDB の MySQL パフォーマンススキーマとの統合</h3></div></div></div><a class="indexterm" name="idm139979064343664"></a><p>
      MySQL 5.5 を含む InnoDB 1.1 から、MySQL <a class="link" href="performance-schema.html" title="第 22 章 MySQL パフォーマンススキーマ">パフォーマンススキーマ機能</a>を使用して InnoDB の特定の内部操作をプロファイルできます。このタイプのチューニングは主に、MySQL のパフォーマンスの制限をプッシュしたり、MySQL のソースコードを読んだり、パフォーマンスのボトルネックを克服するための最適化方法を評価したりする上級ユーザー向けです。DBA はまた、この機能を容量計画に使用することにより、標準的なワークロードのときに CPU、RAM、およびディスクストレージの特定の組み合わせでパフォーマンスのボトルネックが発生するかどうかを確認し、発生する場合は、システムの一部の容量を増やすことでパフォーマンスを向上させることができるかどうかを判断することもできます。
    </p><p>
      この機能を使用して InnoDB のパフォーマンスを検査するには:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="xref" href="performance-schema.html#performance-schema-configuration" title="22.2 パフォーマンススキーマ構成">セクション22.2「パフォーマンススキーマ構成」</a>で説明されているように、パフォーマンススキーマ機能が使用可能で、かつ有効になっている状態で MySQL 5.5 以降を実行している必要があります。パフォーマンススキーマ機能によってある程度のパフォーマンスオーバーヘッドが導入されるため、この機能は本番システムではなく、テストまたは開発システムで使用するようにしてください。
        </p></li><li class="listitem"><p>
          たとえば、<code class="literal">performance_schema</code> データベース内のテーブルをクエリーする方法など、<a class="link" href="performance-schema.html" title="第 22 章 MySQL パフォーマンススキーマ">パフォーマンススキーマ機能</a>の使用方法に全般的に精通している必要があります。
        </p></li><li class="listitem"><p>
          次の種類の InnoDB オブジェクトは、対応する <code class="literal">performance_schema</code> テーブルをクエリーすることによって検査します。InnoDB に関連した項目はすべて、<code class="literal">EVENT_NAME</code> カラム内に部分文字列 <code class="literal">innodb</code> を含んでいます。
        </p><p>
          <code class="literal">*_instances</code> テーブルの定義については、<a class="xref" href="performance-schema.html#performance-schema-instance-tables" title="22.9.3 パフォーマンススキーマインスタンステーブル">セクション22.9.3「パフォーマンススキーマインスタンステーブル」</a>を参照してください。<code class="literal">*_summary_*</code> テーブルの定義については、<a class="xref" href="performance-schema.html#performance-schema-summary-tables" title="22.9.9 パフォーマンススキーマサマリーテーブル">セクション22.9.9「パフォーマンススキーマサマリーテーブル」</a>を参照してください。<code class="literal">thread</code> テーブルの定義については、<a class="xref" href="performance-schema.html#performance-schema-miscellaneous-tables" title="22.9.10 パフォーマンススキーマのその他のテーブル">セクション22.9.10「パフォーマンススキーマのその他のテーブル」</a>を参照してください。<code class="literal">*_current_*</code> および <code class="literal">*_history_*</code> テーブルの定義については、<a class="xref" href="performance-schema.html#performance-schema-wait-tables" title="22.9.4 パフォーマンススキーマ待機イベントテーブル">セクション22.9.4「パフォーマンススキーマ待機イベントテーブル」</a>を参照してください。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">mutex_instances</code> テーブル内の<a class="link" href="glossary.html#glos_mutex" title="相互排他ロック">相互排他ロック</a>。(ここには、<code class="literal">InnoDB</code> バッファープールに関連した相互排他ロックと読み書きロックは含まれていません。同じことが、<code class="literal">SHOW ENGINE INNODB MUTEX</code> コマンドの出力にも適用されます。)
            </p></li><li class="listitem"><p>
              <code class="literal">rwlock_instances</code> テーブル内の<a class="link" href="glossary.html#glos_rw_lock" title="rw ロック (読み書きロック)">読み書きロック</a>。
            </p></li><li class="listitem"><p>
              <code class="literal">file_instances</code>、<code class="literal">file_summary_by_event_name</code>、および <code class="literal">file_summary_by_instance</code> テーブル内のファイル I/O 操作。
            </p></li><li class="listitem"><p>
              <code class="literal">PROCESSLIST</code> テーブル内の<a class="link" href="glossary.html#glos_thread" title="スレッド">スレッド</a>。
            </p></li></ul></div></li><li class="listitem"><p>
          パフォーマンステスト中に、<code class="literal">events_waits_current</code> および <code class="literal">events_waits_history_long</code> テーブル内のパフォーマンスデータを検査します。InnoDB 関連のオブジェクトに特に関心がある場合は、句 <code class="literal">WHERE EVENT_NAME LIKE '%innodb%'</code> を使用してそれらのエントリだけを確認します。それ以外の場合は、MySQL サーバー全体のパフォーマンス統計を検査します。
        </p></li></ul></div><p>
      MySQL パフォーマンススキーマの詳細は、<a class="xref" href="performance-schema.html" title="第 22 章 MySQL パフォーマンススキーマ">第22章「<i>MySQL パフォーマンススキーマ</i>」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-multiple-rollback-segments"></a>14.13.12 複数のロールバックセグメントによるスケーラビリティーの向上</h3></div></div></div><a class="indexterm" name="idm139979064304272"></a><p>
      MySQL 5.5 を含む InnoDB 1.1 から、並列<a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a>の制限が大幅に拡張されたため、大容量システムに影響を与えていた InnoDB の<a class="link" href="glossary.html#glos_rollback_segment" title="ロールバックセグメント">ロールバックセグメント</a>でのボトルネックが解消されました。この制限は、何らかのデータを変更する並列トランザクションに適用されます。読み取り専用トランザクションは、その最大数に対してカウントされません。
    </p><p>
      1 つのロールバックセグメントが現在 128 個のセグメントに分割され、そのそれぞれで、書き込みを実行するトランザクションを最大 1023 個サポートできるため、合計で約 128K 個の並列トランザクションがサポートされます。元のトランザクション制限は 1023 でした。
    </p><p>
      各トランザクションはいずれかのロールバックセグメントに割り当てられ、存続期間中は、そのロールバックセグメントに結び付けられたままになります。この拡張により、スケーラビリティー (並列トランザクションの数の増加) とパフォーマンス (各種のトランザクションがロールバックセグメントにアクセスした場合の競合の減少) の両方が向上します。
    </p><p>
      この機能を利用するために新しいデータベースまたはテーブルを作成したり、何かを再構成したりする必要はありません。MySQL 5.1 以前からのアップグレードの前、またはその後しばらくして<a class="link" href="glossary.html#glos_slow_shutdown" title="低速シャットダウン">低速シャットダウン</a>を実行する必要があります。低速シャットダウンを実行したあとにはじめて再起動すると、<a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">システムテーブルスペース</a>内の必要な変更が InnoDB によって自動的に行われます。
    </p><p>
      ワークロードが 1023 個の並列トランザクションの元の制限によって制約されなかった場合は、構成オプション <code class="literal">innodb_rollback_segments</code> を設定することによって、MySQL インスタンスまたはセッション内で使用されるロールバックセグメントの数を減らすことができます。
    </p><p>
      高いトランザクション負荷の下での InnoDB のパフォーマンスの詳細は、<a class="xref" href="optimization.html#optimizing-innodb-transaction-management" title="8.5.2 InnoDB トランザクション管理の最適化">セクション8.5.2「InnoDB トランザクション管理の最適化」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-improved-purge-scheduling"></a>14.13.13 InnoDB のパージスケジューリングの構成</h3></div></div></div><a class="indexterm" name="idm139979064290704"></a><p>
      InnoDB が自動的に実行する<a class="link" href="glossary.html#glos_purge" title="パージ">パージ</a>操作 (ガベージコレクションの一種) は現在、<a class="link" href="glossary.html#glos_master_thread" title="マスタースレッド">マスタースレッド</a>ではなく、1 つ以上の個別のスレッドで実行されます。この変更により、メインのデータベース操作がバックグラウンドで実行される保守作業とは独立に実行されるため、スケーラビリティーが向上します。
    </p><p>
      この機能を制御するには、構成オプション <code class="literal">innodb_purge_threads</code> の値を増やします。DML アクションが 1 つのテーブルまたは少数のテーブルに集中している場合は、ビジーテーブルにアクセスするためにスレッドが互いに競合することのないように、この設定を低い値に維持します。DML 操作が多数のテーブルに分散している場合は、この設定を増やします。その最大値は 32 です。
    </p><p>
      関連する別の構成オプションとして、デフォルト値が 20 で、最大値が 5000 である <code class="literal">innodb_purge_batch_size</code> があります。このオプションは主に、パージ操作の実験やチューニングを対象にしており、標準的なユーザーにとって魅力的なものではありません。
    </p><p>
      InnoDB の I/O パフォーマンスの詳細は、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.7 InnoDB ディスク I/O の最適化">セクション8.5.7「InnoDB ディスク I/O の最適化」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-performance-ro-txn"></a>14.13.14 InnoDB の読み取り専用トランザクションの最適化</h3></div></div></div><p>
      MySQL 5.6.4 の時点では、<code class="literal">InnoDB</code> は、読み取り専用であることがわかっているトランザクションの<a class="link" href="glossary.html#glos_transaction_id" title="トランザクション ID">トランザクション ID</a> (<code class="literal">TRX_ID</code> フィールド) の設定に関連したオーバーヘッドを回避できます。トランザクション ID は、書き込み操作または<a class="link" href="glossary.html#glos_locking_read" title="ロック読み取り">ロック読み取り</a> (<code class="literal">SELECT ... FOR UPDATE</code> など) を実行する可能性のある<a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a>にのみ必要です。不必要なトランザクション ID を削除すると、クエリーや DML ステートメントによって<a class="link" href="glossary.html#glos_read_view" title="読み取りビュー">読み取りビュー</a>が構築されるたびに参照される内部データ構造のサイズが削減されます。
    </p><p>
      現在、<code class="literal">InnoDB</code> は、次の場合に読み取り専用トランザクションを検出します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          トランザクションが <code class="literal">START TRANSACTION READ ONLY</code> ステートメントで開始された場合。この場合は、データベース (<code class="literal">InnoDB</code>、<code class="literal">MyISAM</code>、またはその他のタイプのテーブル) に対して変更を行おうとするとエラーが発生し、そのトランザクションは読み取り専用状態のままになります。
        </p><pre class="programlisting">
ERROR 1792 (25006): Cannot execute statement in a READ ONLY transaction.
</pre><p>
          ただし、読み取り専用トランザクションでのセッション固有の一時テーブルの変更や、それらのテーブルに対するロッククエリーの発行は、その変更やロックがほかのどのトランザクションにも表示されないため引き続き可能です。
        </p></li><li class="listitem"><p>
          <a class="link" href="glossary.html#glos_autocommit" title="自動コミット">autocommit</a> 設定がオンになっているため、トランザクションが 1 つのステートメントであることが保証され、そのトランザクションを構成している 1 つのステートメントが<span class="quote">「<span class="quote">非ロック</span>」</span>の <code class="literal">SELECT</code> ステートメントである場合。つまり、<code class="literal">FOR UPDATE</code> または <code class="literal">LOCK IN SHARED MODE</code> 句を使用しない <code class="literal">SELECT</code> です。
        </p></li></ul></div><p>
      そのため、レポートジェネレータなどの読み取りの多いアプリケーションの場合は、<code class="literal">InnoDB</code> のクエリーを <code class="literal">START TRANSACTION READ ONLY</code> および <code class="literal">COMMIT</code> の内部にグループ化するか、<code class="literal">SELECT</code> ステートメントを実行する前に <code class="literal">autocommit</code> 設定をオンにするか、または単純にどの <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> ステートメントにもクエリーが組み込まれないようにすることにより、それらのクエリーのシーケンスをチューニングできます。
    </p><p>
      <code class="literal">START TRANSACTION</code> および <code class="literal">autocommit</code> については、<a class="xref" href="sql-syntax.html#commit" title="13.3.1 START TRANSACTION、COMMIT、および ROLLBACK 構文">セクション13.3.1「START TRANSACTION、COMMIT、および ROLLBACK 構文」</a>を参照してください。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        自動コミット、非ロック、および読み取り専用 (AC-NL-RO) として承認されたトランザクションは、<code class="literal">InnoDB</code> の特定の内部データ構造から除外されるため、<code class="literal">SHOW ENGINE INNODB STATUS</code> の出力には表示されません。これらのトランザクションは、情報スキーマでのみ表示されます。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-crc32-checksum"></a>14.13.15 チェックサムの高速化のための CRC32 チェックサムアルゴリズムの使用</h3></div></div></div><p>
      MySQL 5.6.3 で導入された CRC32 チェックサムアルゴリズムは、ブロックを 1 回につき 32 ビットスキャンします。これは、ブロックを 1 回につき 8 ビットスキャンする <code class="literal">InnoDB</code> のチェックサムアルゴリズムに対する改善です。CRC32 チェックサムアルゴリズムは、<code class="literal">innodb_checksum_algorithm=crc32</code> を設定することによって有効にすることができます。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        同様に MySQL 5.6.3 で導入された <code class="literal">innodb_checksum_algorithm</code> 構成パラメータによって、<code class="literal">innodb_checksums</code> 構成パラメータが置き換えられます。詳細は、<code class="literal">innodb_checksum_algorithm</code> のドキュメントを参照してください。
      </p></div><p>
      CRC32 アルゴリズムが有効になっている場合、<code class="literal">InnoDB</code> によってディスクに書き込まれるデータブロックのチェックサムフィールドには、以前とは異なる値が含まれています。テーブルスペース内のブロックが CRC32 チェックサムアルゴリズムを使用するように変更されたあと、関連付けられたテーブルを以前のバージョンの MySQL で読み取ることはできません。
    </p><p>
      新しい MySQL インスタンスを設定するときに、すべての <code class="literal">InnoDB</code> データが CRC32 チェックサムアルゴリズムを使用して作成されている場合は、<code class="literal">innodb_checksum_algorithm=strict_crc32</code> 設定を使用できます。これは、古い値と新しい値の両方をサポートするための余分なチェックサム計算を実行しないため、<code class="literal">crc32</code> 設定より高速である可能性があります。
    </p><p>
      <code class="literal">innodb_checksum_algorithm</code> のデフォルト値は MySQL 5.6.6 で <code class="literal">innodb</code> から <code class="literal">crc32</code> に変更されましたが、以前の MySQL バージョンへのダウングレード中の <code class="literal">InnoDB</code> データファイルの互換性向上のため、および <a class="link" href="mysql-enterprise.html#mysql-enterprise-backup" title="25.2 MySQL Enterprise Backup">MySQL Enterprise Backup</a> で使用するために 5.6.7 で <code class="literal">innodb</code> に戻されました。検出された制限には、次のものが含まれます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          CRC32 チェックサムを含む <code class="literal">.ibd</code> ファイルは、5.6.3 より前の MySQL バージョンへのダウングレード中に問題が発生する可能性があります。MySQL 5.6.3 以降では、ディスクからブロックを読み取るとき、そのブロックの新しいチェックサム値と古いチェックサム値のどちらも正しいとして認識します。それにより、アルゴリズムの設定には関係なく、アップグレードおよびダウングレード中にそのデータブロックの互換性を保証します。新しいチェックサム値で書き込まれたデータが 5.6.3 より前のレベルの MySQL によって処理された場合は、破損しているとしてレポートされる可能性があります。
        </p></li><li class="listitem"><p>
          3.8.0 までのバージョンの <a class="link" href="mysql-enterprise.html#mysql-enterprise-backup" title="25.2 MySQL Enterprise Backup">MySQL Enterprise Backup</a> は、CRC32 チェックサムを使用するテーブルスペースのバックアップをサポートしていません。<a class="link" href="mysql-enterprise.html#mysql-enterprise-backup" title="25.2 MySQL Enterprise Backup">MySQL Enterprise Backup</a> は、CRC32 チェックサムのサポートを 3.8.1 で (いくつかの制限付きで) 追加しています。詳細は、<a class="link" href="mysql-enterprise.html#mysql-enterprise-backup" title="25.2 MySQL Enterprise Backup">MySQL Enterprise Backup</a> 3.8.1 の変更履歴を参照してください。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-performance-optimizer-statistics"></a>14.13.16 オプティマイザ統計</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-persistent-stats">14.13.16.1 永続的オプティマイザ統計のパラメータの構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-statistics-estimation">14.13.16.2 非永続的オプティマイザ統計のパラメータの構成</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-persistent-stats"></a>14.13.16.1 永続的オプティマイザ統計のパラメータの構成</h4></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-persistent-stats-pages-sampled">14.13.16.1.1 InnoDB オプティマイザ統計でサンプリングされるページの数の構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-persistent-stats-tables">14.13.16.1.2 InnoDB 永続的統計テーブル</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-persistent-stats-tables-example">14.13.16.1.3 InnoDB 永続的統計テーブルの例</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-persistent-stats-tables-index-size">14.13.16.1.4 innodb_index_stats テーブルを使用したインデックスサイズの取得</a></span></dt></dl></div><a class="indexterm" name="idm139979064217328"></a><a class="indexterm" name="idm139979064215840"></a><a class="indexterm" name="idm139979064214432"></a><p>
        <a class="link" href="glossary.html#glos_plan_stability" title="計画安定性">計画安定性</a>は、もっとも大きく、かつもっとも重要なクエリーの望ましい目標です。<code class="literal">InnoDB</code> は、オプティマイザがもっとも効率的な<a class="link" href="glossary.html#glos_query_execution_plan" title="クエリー実行計画">クエリー実行計画</a>を容易に見つけることができるように、常に <code class="literal">InnoDB</code> テーブルごとの統計を計算してきました。これらの統計を永続的なものにすることが可能になったため、特定のクエリーのインデックス使用状況や結合順序が変更される可能性は低くなります。
      </p><p>
        この機能はデフォルトでオンになっており、構成オプション <code class="literal">innodb_stats_persistent</code> で有効になります。
      </p><p>
        <code class="literal">innodb_stats_persistent_sample_pages</code> 構成オプションを設定することによって、統計を収集するために実行されるサンプリングの量を制御します。
      </p><p>
        構成オプション <code class="literal">innodb_stats_auto_recalc</code> は、テーブルに (行の 10% を超える) 大幅な変更が加えられた場合は常に統計を自動的に計算するかどうかを決定します。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          統計の自動再計算 (これは、バックグラウンドで実行されます) には非同期の性質があるため、<code class="literal">innodb_stats_auto_recalc</code> が有効になっていたとしても、テーブルの 10% を超える部分に影響を与える DML 操作を実行した直後に統計が再計算されるとは限りません。場合によっては、統計の再計算が数秒遅れる可能性があります。テーブルの大きな部分を変更した直後に最新の統計が必要な場合は、統計の同期的な (フォアグラウンド) 再計算を開始するために <code class="literal">ANALYZE TABLE</code> を実行してください。
        </p></div><p>
        <code class="literal">innodb_stats_auto_recalc</code> が無効になっている場合は、インデックス付きカラムへの大幅な変更を行なったあと、該当する各テーブルに対して <code class="literal">ANALYZE TABLE</code> ステートメントを発行することによってオプティマイザ統計の精度を確保してください。このステートメントは、代表的なデータがテーブルにロードされたあとにセットアップスクリプトで実行したり、インデックス付きカラムの内容が DML 操作によって大幅に変更されたあとに定期的に、または低アクティビティーの時間帯にスケジュールに従って実行したりすることができます。既存のテーブルに新しいインデックスが追加された場合は、<code class="literal">innodb_stats_auto_recalc</code> の値には関係なく、インデックス統計が計算されて <code class="literal">innodb_index_stats</code> テーブルに追加されます。
      </p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注意</div><p>
          新しいインデックスが作成されたときに統計が確実に収集されるように、<code class="literal">innodb_stats_auto_recalc</code> オプションを有効にするか、または永続的統計モードが有効になっているときに新しいインデックスを作成するたびに <code class="literal">ANALYZE TABLE</code> を実行してください。
        </p></div><p>
        テーブルを作成する前にグローバルレベルで <code class="literal">innodb_stats_persistent</code>、<code class="literal">innodb_stats_auto_recalc</code> オプションを設定するか、または <code class="literal">CREATE TABLE</code> および <code class="literal">ALTER TABLE</code> ステートメントで <code class="literal">STATS_PERSISTENT</code>、<code class="literal">STATS_AUTO_RECALC</code>、および <code class="literal">STATS_SAMPLE_PAGES</code> 句を使用して、システム全体の設定をオーバーライドし、個々のテーブルの永続的統計を構成することができます。
      </p><p>
        以前は、これらの統計は各サーバーの再起動やその他の一部の操作のあとにクリアされ、テーブルが次回アクセスされたときに再計算されていました。これらの統計は、次回には異なる推定値が生成される可能性のあるランダムなサンプリング手法を使用して計算されるため、実行計画において異なる選択が行われ、そのためにクエリーパフォーマンスが変動します。
      </p><p>
        定期的に消去される以前の統計収集方法に戻すには、コマンド <code class="literal">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> STATS_PERSISTENT=0</code> を実行します。関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-statistics-estimation" title="14.13.16.2 非永続的オプティマイザ統計のパラメータの構成">セクション14.13.16.2「非永続的オプティマイザ統計のパラメータの構成」</a>を参照してください。
      </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-persistent-stats-pages-sampled"></a>14.13.16.1.1 InnoDB オプティマイザ統計でサンプリングされるページの数の構成</h5></div></div></div><p>
          MySQL クエリーオプティマイザは、インデックスの相対的な<a class="link" href="glossary.html#glos_selectivity" title="選択性">選択性</a>に基づいて、キー分布に関する推定された<a class="link" href="glossary.html#glos_statistics" title="統計">統計</a>を使用して実行計画のためのインデックスを選択します。<code class="literal">ANALYZE TABLE</code> などの操作を行うと、<code class="literal">InnoDB</code> は、インデックスの<a class="link" href="glossary.html#glos_cardinality" title="カーディナリティー">カーディナリティー</a>を推定するためにテーブル上の各インデックスからランダムなページをサンプリングします。(この手法は、<a class="link" href="glossary.html#glos_random_dive" title="ランダムダイブ">ランダムダイブ</a>と呼ばれます。)
        </p><p>
          統計の推定値の品質を制御する (それにより、クエリーオプティマイザへの情報を改善する) ために、実行時に設定できるパラメータ <code class="literal">innodb_stats_persistent_sample_pages</code> を使用して、サンプリングされるページの数を変更できます。
        </p><p>
          <code class="literal">innodb_stats_persistent_sample_pages</code> のデフォルト値は 20 です。一般的なガイドラインとして、次の問題が発生した場合は、このパラメータを変更することを考慮してください。
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              <code class="literal">EXPLAIN</code> の出力で示されているように、<span class="emphasis"><em>統計の精度が十分でないため、オプティマイザが次善の計画を選択する</em></span>。統計の精度は、インデックスの実際のカーディナリティー (インデックスカラムに対して <code class="literal">SELECT DISTINCT</code> を実行することにより返されます) を、<code class="literal">mysql.innodb_index_stats</code> 永続的統計テーブルに示されている推定値と比較することによってチェックできます。
            </p><p>
              統計の精度が十分でないことが確認された場合は、統計の推定値が十分な精度になるまで <code class="literal">innodb_stats_persistent_sample_pages</code> の値を増やすようにしてください。ただし、<code class="literal">innodb_stats_persistent_sample_pages</code> を大きくしすぎると、<code class="literal">ANALYZE TABLE</code> の実行が遅くなる可能性があります。
            </p></li><li class="listitem"><p>
              <span class="emphasis"><em><code class="literal">ANALYZE TABLE</code> が遅すぎる</em></span>。この場合は、<code class="literal">ANALYZE TABLE</code> の実行時間が許容可能になるまで <code class="literal">innodb_stats_persistent_sample_pages</code> を減らすようにしてください。ただし、この値を小さくしすぎると、精度の低い統計および次善のクエリー実行計画という最初の問題につながる可能性があります。
            </p><p>
              統計の精度と <code class="literal">ANALYZE TABLE</code> の実行時間のバランスをとることができない場合は、<code class="literal">ANALYZE TABLE</code> の複雑さを減らすためにテーブル内のインデックス付きカラムの数を減らすか、またはパーティションの数を制限することを考慮してください。また、主キーカラムは一意でない各インデックスに付加されるため、テーブルの主キー内のカラム数について考慮することも重要です。
            </p><p>
              関連情報については、<a class="xref" href="innodb-storage-engine.html#innodb-analyze-table-complexity" title="14.13.17 InnoDB テーブルに対する ANALYZE TABLE の複雑さの推定">セクション14.13.17「InnoDB テーブルに対する ANALYZE TABLE の複雑さの推定」</a>を参照してください。
            </p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-persistent-stats-tables"></a>14.13.16.1.2 InnoDB 永続的統計テーブル</h5></div></div></div><p>
          永続的統計機能は、<code class="literal">innodb_table_stats</code> および <code class="literal">innodb_index_stats</code> という名前の、<code class="literal">mysql</code> データベース内の内部的に管理されているテーブルに依存します。これらのテーブルは、すべてのインストール、アップグレード、およびソースからのビルド手順で自動的に設定されます。
        </p><div class="table"><a name="innodb-table-stats-table"></a><p class="title"><b>表 14.8 innodb_table_stats のカラム</b></p><div class="table-contents"><table summary="innodb_table_stats のカラム" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">カラム名</th><th scope="col">説明</th></tr></thead><tbody><tr><td scope="row"><code class="literal">database_name</code></td><td>データベース名</td></tr><tr><td scope="row"><code class="literal">table_name</code></td><td>テーブル名、パーティション名、またはサブパーティション名</td></tr><tr><td scope="row"><code class="literal">last_update</code></td><td><code class="literal">InnoDB</code> が最後にこの行を更新した時間を示すタイムスタンプ</td></tr><tr><td scope="row"><code class="literal">n_rows</code></td><td>テーブル内の行数</td></tr><tr><td scope="row"><code class="literal">clustered_index_size</code></td><td>プライマリインデックスのサイズ (ページ数)</td></tr><tr><td scope="row"><code class="literal">sum_of_other_index_sizes</code></td><td>その他の (プライマリ以外の) インデックスの合計サイズ (ページ数)</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="innodb-index-stats-table"></a><p class="title"><b>表 14.9 innodb_index_stats のカラム</b></p><div class="table-contents"><table summary="innodb_index_stats のカラム" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">カラム名</th><th scope="col">説明</th></tr></thead><tbody><tr><td scope="row"><code class="literal">database_name</code></td><td>データベース名</td></tr><tr><td scope="row"><code class="literal">table_name</code></td><td>テーブル名、パーティション名、またはサブパーティション名</td></tr><tr><td scope="row"><code class="literal">index_name</code></td><td>インデックス名</td></tr><tr><td scope="row"><code class="literal">last_update</code></td><td><code class="literal">InnoDB</code> が最後にこの行を更新した時間を示すタイムスタンプ</td></tr><tr><td scope="row"><code class="literal">stat_name</code></td><td><code class="literal">stat_value</code> カラムに値がレポートされている統計の名前</td></tr><tr><td scope="row"><code class="literal">stat_value</code></td><td><code class="literal">stat_name</code> カラムで名前が指定されている統計の値</td></tr><tr><td scope="row"><code class="literal">sample_size</code></td><td><code class="literal">stat_value</code> カラムに示されている推定値のサンプリングされるページの数</td></tr><tr><td scope="row"><code class="literal">stat_description</code></td><td><code class="literal">stat_name</code> カラムで名前が指定されている統計の説明</td></tr></tbody></table></div></div><br class="table-break"><p>
          次の例に示すように、<code class="literal">innodb_table_stats</code> テーブルと <code class="literal">innodb_index_stats</code> テーブルのどちらにも、<code class="literal">InnoDB</code> が最後にインデックス統計を更新した時間を示す <code class="literal">last_update</code> カラムが含まれています。
        </p><pre class="programlisting">mysql&gt; select * from innodb_table_stats \G
*************************** 1. row ***************************
           database_name: sakila
              table_name: actor
             last_update: 2014-05-28 16:16:44
                  n_rows: 200
    clustered_index_size: 1
sum_of_other_index_sizes: 1
...</pre><pre class="programlisting">mysql&gt; select * from innodb_index_stats \G
*************************** 1. row ***************************
   database_name: sakila
      table_name: actor
      index_name: PRIMARY
     last_update: 2014-05-28 16:16:44
       stat_name: n_diff_pfx01
      stat_value: 200
     sample_size: 1
     ...</pre><p>
          <code class="literal">innodb_table_stats</code> および <code class="literal">innodb_index_stats</code> テーブルは通常のテーブルであるため、手動で更新できます。統計を手動で更新する機能により、データベースを変更することなく、特定のクエリー最適化計画やテスト代替計画を強制的に実行することが可能になります。統計を手動で更新した場合は、更新された統計が MySQL でリロードされるように、<code class="literal">FLUSH TABLE <em class="replaceable"><code>tbl_name</code></em></code> コマンドを発行します。
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-persistent-stats-tables-example"></a>14.13.16.1.3 InnoDB 永続的統計テーブルの例</h5></div></div></div><p>
          <code class="literal">innodb_table_stats</code> テーブルには、テーブルごとに 1 行が含まれています。収集されるデータを次の例に示します。
        </p><p>
          テーブル <code class="literal">t1</code> には、プライマリインデックス (カラム <code class="literal">a</code>、<code class="literal">b</code>)、セカンダリインデックス (カラム <code class="literal">c</code>、<code class="literal">d</code>)、および一意のインデックス (カラム <code class="literal">e</code>、<code class="literal">f</code>) が含まれています。
        </p><pre class="programlisting">CREATE TABLE t1 (
a INT, b INT, c INT, d INT, e INT, f INT,
PRIMARY KEY (a, b), KEY i1 (c, d), UNIQUE KEY i2uniq (e, f)
) ENGINE=INNODB;</pre><p>
          5 行のサンプルデータを挿入したあと、テーブルは次のようになります。
        </p><pre class="programlisting">mysql&gt; SELECT * FROM t1;
+---+---+------+------+------+------+
| a | b | c    | d    | e    | f    |
+---+---+------+------+------+------+
| 1 | 1 |   10 |   11 |  100 |  101 |
| 1 | 2 |   10 |   11 |  200 |  102 |
| 1 | 3 |   10 |   11 |  100 |  103 |
| 1 | 4 |   10 |   12 |  200 |  104 |
| 1 | 5 |   10 |   12 |  100 |  105 |
+---+---+------+------+------+------+
5 rows in set (0.00 sec)</pre><p>
          統計をただちに更新するには、<code class="literal">ANALYZE TABLE</code> を実行します (<code class="literal">innodb_stats_auto_recalc</code> が有効になっている場合、変更されるテーブル行の 10% のしきい値に達したと仮定すると、統計は数秒以内に自動的に更新されます)。
        </p><pre class="programlisting">mysql&gt; ANALYZE TABLE t1;
+---------+---------+----------+----------+
| Table   | Op      | Msg_type | Msg_text |
+---------+---------+----------+----------+
| test.t1 | analyze | status   | OK       |
+---------+---------+----------+----------+
1 row in set (0.02 sec)    </pre><p>
          テーブル <code class="literal">t1</code> のテーブル統計には、<code class="literal">InnoDB</code> が最後にテーブル統計を更新した時間 (<code class="literal">2014-03-14 14:36:34</code>)、テーブル内の行数 (<code class="literal">5</code>)、クラスタ化されたインデックスのサイズ (<code class="literal">1</code> ページ)、およびほかのインデックスの合計サイズ (<code class="literal">2</code> ページ) が示されます。
        </p><pre class="programlisting">mysql&gt; SELECT * FROM mysql.innodb_table_stats WHERE table_name like 't1'\G
*************************** 1. row ***************************
           database_name: test
              table_name: t1
             last_update: 2014-03-14 14:36:34
                  n_rows: 5
    clustered_index_size: 1
sum_of_other_index_sizes: 2
1 row in set (0.00 sec)      </pre><p>
          <code class="literal">innodb_index_stats</code> テーブルには、インデックスごとに複数の行が含まれています。<code class="literal">innodb_index_stats</code> テーブル内の各行は、<code class="literal">stat_name</code> カラムで名前が指定され、<code class="literal">stat_description</code> カラムで説明されている特定のインデックス統計に関連したデータを示します。例:
        </p><pre class="programlisting">mysql&gt; SELECT index_name, stat_name, stat_value, stat_description
    -&gt; FROM mysql.innodb_index_stats WHERE table_name like 't1';
+------------+--------------+------------+-----------------------------------+
| index_name | stat_name    | stat_value | stat_description                  |
+------------+--------------+------------+-----------------------------------+
| PRIMARY    | n_diff_pfx01 |          1 | a                                 |
| PRIMARY    | n_diff_pfx02 |          5 | a,b                               |
| PRIMARY    | n_leaf_pages |          1 | Number of leaf pages in the index |
| PRIMARY    | size         |          1 | Number of pages in the index      |
| i1         | n_diff_pfx01 |          1 | c                                 |
| i1         | n_diff_pfx02 |          2 | c,d                               |
| i1         | n_diff_pfx03 |          2 | c,d,a                             |
| i1         | n_diff_pfx04 |          5 | c,d,a,b                           |
| i1         | n_leaf_pages |          1 | Number of leaf pages in the index |
| i1         | size         |          1 | Number of pages in the index      |
| i2uniq     | n_diff_pfx01 |          2 | e                                 |
| i2uniq     | n_diff_pfx02 |          5 | e,f                               |
| i2uniq     | n_leaf_pages |          1 | Number of leaf pages in the index |
| i2uniq     | size         |          1 | Number of pages in the index      |
+------------+--------------+------------+-----------------------------------+
14 rows in set (0.00 sec)    </pre><p>
          <code class="literal">stat_name</code> カラムには、次のタイプの統計が示されます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">size</code>: <code class="literal">stat_name</code>=<code class="literal">size</code> である場合、<code class="literal">stat_value</code> カラムには、インデックス内のページの総数が表示されます。
            </p></li><li class="listitem"><p>
              <code class="literal">n_leaf_pages</code>: <code class="literal">stat_name</code>=<code class="literal">n_leaf_pages</code> である場合、<code class="literal">stat_value</code> カラムには、インデックス内のリーフページの数が表示されます。
            </p></li><li class="listitem"><p>
              <code class="literal">n_diff_pfx<em class="replaceable"><code>NN</code></em></code>: <code class="literal">stat_name</code>=<code class="literal">n_diff_pfx01</code> である場合、<code class="literal">stat_value</code> カラムには、インデックスの最初のカラム内の固有の値の数が表示されます。<code class="literal">stat_name</code>=<code class="literal">n_diff_pfx02</code> である場合、<code class="literal">stat_value</code> カラムには、インデックスの最初の 2 つのカラム内の固有の値の数が表示されます。以下も同様です。さらに、<code class="literal">stat_name</code>=<code class="literal">n_diff_pfx<em class="replaceable"><code>NN</code></em></code> である場合、<code class="literal">stat_description</code> カラムには、カウントされるインデックスカラムのカンマ区切りリストが示されます。
            </p></li></ul></div><p>
          カーディナリティーデータを提供する <code class="literal">n_diff_pfx<em class="replaceable"><code>NN</code></em></code> の統計をさらに詳細に示すために、<code class="literal">t1</code> テーブルの例を考えてみます。次に示すように、<code class="literal">t1</code> テーブルは、プライマリインデックス (カラム <code class="literal">a</code>、<code class="literal">b</code>)、セカンダリインデックス (カラム <code class="literal">c</code>、<code class="literal">d</code>)、および一意のインデックス (カラム <code class="literal">e</code>、<code class="literal">f</code>) で作成されます。
        </p><pre class="programlisting">CREATE TABLE t1 (
  a INT, b INT, c INT, d INT, e INT, f INT,
  PRIMARY KEY (a, b), KEY i1 (c, d), UNIQUE KEY i2uniq (e, f)
) ENGINE=INNODB;</pre><p>
          5 行のサンプルデータを挿入したあと、テーブルは次のようになります。
        </p><pre class="programlisting">mysql&gt; SELECT * FROM t1;
+---+---+------+------+------+------+
| a | b | c    | d    | e    | f    |
+---+---+------+------+------+------+
| 1 | 1 |   10 |   11 |  100 |  101 |
| 1 | 2 |   10 |   11 |  200 |  102 |
| 1 | 3 |   10 |   11 |  100 |  103 |
| 1 | 4 |   10 |   12 |  200 |  104 |
| 1 | 5 |   10 |   12 |  100 |  105 |
+---+---+------+------+------+------+
5 rows in set (0.00 sec)</pre><p>
          <code class="literal">stat_name LIKE 'n_diff%'</code> である <code class="literal">index_name</code>、<code class="literal">stat_name</code>、<code class="literal">stat_value</code>、および <code class="literal">stat_description</code> をクエリーすると、次の結果セットが返されます。
        </p><pre class="programlisting">mysql&gt; SELECT index_name, stat_name, stat_value, stat_description 
    -&gt; FROM mysql.innodb_index_stats
    -&gt; WHERE table_name like 't1' AND stat_name LIKE 'n_diff%';
+------------+--------------+------------+------------------+
| index_name | stat_name    | stat_value | stat_description |
+------------+--------------+------------+------------------+
| PRIMARY    | n_diff_pfx01 |          1 | a                |
| PRIMARY    | n_diff_pfx02 |          5 | a,b              |
| i1         | n_diff_pfx01 |          1 | c                |
| i1         | n_diff_pfx02 |          2 | c,d              |
| i1         | n_diff_pfx03 |          2 | c,d,a            |
| i1         | n_diff_pfx04 |          5 | c,d,a,b          |
| i2uniq     | n_diff_pfx01 |          2 | e                |
| i2uniq     | n_diff_pfx02 |          5 | e,f              |
+------------+--------------+------------+------------------+
8 rows in set (0.00 sec)</pre><p>
          <code class="literal">PRIMARY</code> インデックスの場合は、2 つの <code class="literal">n_diff%</code> 行があります。行数は、インデックス内のカラム数に等しくなります。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            一意でないインデックスの場合は、<code class="literal">InnoDB</code> によって主キーのカラムが付加されます。
          </p></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">index_name</code>=<code class="literal">PRIMARY</code> および <code class="literal">stat_name</code>=<code class="literal">n_diff_pfx01</code> である場合、<code class="literal">stat_value</code> は <code class="literal">1</code> です。これは、インデックスの最初のカラム (カラム <code class="literal">a</code>) 内に固有の値が 1 つ存在することを示します。カラム <code class="literal">a</code> 内の固有の値の数は、テーブル <code class="literal">t1</code> 内のカラム <code class="literal">a</code> のデータを表示することによって確認されます。ここには、固有の値が 1 つ存在します (<code class="literal">1</code>)。カウントされるカラム (<code class="literal">a</code>) は、結果セットの <code class="literal">stat_description</code> カラムに示されています。
            </p></li><li class="listitem"><p>
              <code class="literal">index_name</code>=<code class="literal">PRIMARY</code> および <code class="literal">stat_name</code>=<code class="literal">n_diff_pfx02</code> である場合、<code class="literal">stat_value</code> は <code class="literal">5</code> です。これは、インデックスの 2 つのカラム (<code class="literal">a,b</code>) 内に固有の値が 5 つ存在することを示します。カラム <code class="literal">a</code> および <code class="literal">b</code> 内の固有の値の数は、テーブル <code class="literal">t1</code> 内のカラム <code class="literal">a</code> および <code class="literal">b</code> のデータを表示することによって確認されます。ここには、固有の値が 5 つ存在します: (<code class="literal">1,1</code>)、(<code class="literal">1,2</code>)、(<code class="literal">1,3</code>)、(<code class="literal">1,4</code>)、および (<code class="literal">1,5</code>)。カウントされるカラム (<code class="literal">a,b</code>) は、結果セットの <code class="literal">stat_description</code> カラムに示されています。
            </p></li></ul></div><p>
          セカンダリインデックス (<code class="literal">i1</code>) の場合は、4 つの <code class="literal">n_diff%</code> 行があります。セカンダリインデックスとして定義されているカラムは 2 つ (<code class="literal">c,d</code>) しかありませんが、セカンダリインデックスの <code class="literal">n_diff%</code> 行は 4 つあります。これは、一意でないインデックスにはすべて <code class="literal">InnoDB</code> サフィクスによって主キーが付加されるためです。その結果、セカンダリインデックスカラム (<code class="literal">c,d</code>) と主キーカラム (<code class="literal">a,b</code>) の両方を反映して、2 つではなく 4 つの <code class="literal">n_diff%</code> 行があります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">index_name</code>=<code class="literal">i1</code> および <code class="literal">stat_name</code>=<code class="literal">n_diff_pfx01</code> である場合、<code class="literal">stat_value</code> は <code class="literal">1</code> です。これは、インデックスの最初のカラム (カラム <code class="literal">c</code>) 内に固有の値が 1 つ存在することを示します。カラム <code class="literal">c</code> 内の固有の値の数は、テーブル <code class="literal">t1</code> 内のカラム <code class="literal">c</code> のデータを表示することによって確認されます。ここには、固有の値が 1 つ存在します: (<code class="literal">10</code>)。カウントされるカラム (<code class="literal">c</code>) は、結果セットの <code class="literal">stat_description</code> カラムに示されています。
            </p></li><li class="listitem"><p>
              <code class="literal">index_name</code>=<code class="literal">i1</code> および <code class="literal">stat_name</code>=<code class="literal">n_diff_pfx02</code> である場合、<code class="literal">stat_value</code> は <code class="literal">2</code> です。これは、インデックスの最初の 2 つのカラム (<code class="literal">c,d</code>) 内に固有の値が 2 つ存在することを示します。カラム <code class="literal">c</code> および <code class="literal">d</code> 内の固有の値の数は、テーブル <code class="literal">t1</code> 内のカラム <code class="literal">c</code> および <code class="literal">d</code> のデータを表示することによって確認されます。ここには、固有の値が 2 つ存在します: (<code class="literal">10,11</code>) および (<code class="literal">10,12</code>)。カウントされるカラム (<code class="literal">c,d</code>) は、結果セットの <code class="literal">stat_description</code> カラムに示されています。
            </p></li><li class="listitem"><p>
              <code class="literal">index_name</code>=<code class="literal">i1</code> および <code class="literal">stat_name</code>=<code class="literal">n_diff_pfx03</code> である場合、<code class="literal">stat_value</code> は <code class="literal">2</code> です。これは、インデックスの最初の 3 つのカラム (<code class="literal">c,d,a</code>) 内に固有の値が 2 つ存在することを示します。カラム <code class="literal">c</code>、<code class="literal">d</code>、および <code class="literal">a</code> 内の固有の値の数は、テーブル <code class="literal">t1</code> 内のカラム <code class="literal">c</code>、<code class="literal">d</code>、および <code class="literal">a</code> のデータを表示することによって確認されます。ここには、固有の値が 2 つ存在します: (<code class="literal">10,11,1</code>) および (<code class="literal">10,12,1</code>)。カウントされるカラム (<code class="literal">c,d,a</code>) は、結果セットの <code class="literal">stat_description</code> カラムに示されています。
            </p></li><li class="listitem"><p>
              <code class="literal">index_name</code>=<code class="literal">i1</code> および <code class="literal">stat_name</code>=<code class="literal">n_diff_pfx04</code> である場合、<code class="literal">stat_value</code> は <code class="literal">5</code> です。これは、インデックスの 4 つのカラム (<code class="literal">c,d,a,b</code>) 内に固有の値が 5 つ存在することを示します。カラム <code class="literal">c</code>、<code class="literal">d</code>、<code class="literal">a</code>、および <code class="literal">b</code> 内の固有の値の数は、テーブル <code class="literal">t1</code> 内のカラム <code class="literal">c</code>、<code class="literal">d</code>、<code class="literal">a</code>、および <code class="literal">b</code> のデータを表示することによって確認されます。ここには、固有の値が 5 つ存在します: (<code class="literal">10,11,1,1</code>)、(<code class="literal">10,11,1,2</code>)、(<code class="literal">10,11,1,3</code>)、(<code class="literal">10,12,1,4</code>)、および (<code class="literal">10,12,1,5</code>)。カウントされるカラム (<code class="literal">c,d,a,b</code>) は、結果セットの <code class="literal">stat_description</code> カラムに示されています。
            </p></li></ul></div><p>
          一意のインデックス (<code class="literal">i2uniq</code>) の場合は、2 つの <code class="literal">n_diff%</code> 行があります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">index_name</code>=<code class="literal">i2uniq</code> および <code class="literal">stat_name</code>=<code class="literal">n_diff_pfx01</code> である場合、<code class="literal">stat_value</code> は <code class="literal">2</code> です。これは、インデックスの最初のカラム (カラム <code class="literal">e</code>) 内に固有の値が 2 つ存在することを示します。カラム <code class="literal">e</code> 内の固有の値の数は、テーブル <code class="literal">t1</code> 内のカラム <code class="literal">e</code> のデータを表示することによって確認されます。ここには、固有の値が 2 つ存在します: (<code class="literal">100</code>) および (<code class="literal">200</code>)。カウントされるカラム (<code class="literal">e</code>) は、結果セットの <code class="literal">stat_description</code> カラムに示されています。
            </p></li><li class="listitem"><p>
              <code class="literal">index_name</code>=<code class="literal">i2uniq</code> および <code class="literal">stat_name</code>=<code class="literal">n_diff_pfx02</code> である場合、<code class="literal">stat_value</code> は <code class="literal">5</code> です。これは、インデックスの 2 つのカラム (<code class="literal">e,f</code>) 内に固有の値が 5 つ存在することを示します。カラム <code class="literal">e</code> および <code class="literal">f</code> 内の固有の値の数は、テーブル <code class="literal">t1</code> 内のカラム <code class="literal">e</code> および <code class="literal">f</code> のデータを表示することによって確認されます。ここには、固有の値が 5 つ存在します: (<code class="literal">100,101</code>)、(<code class="literal">200,102</code>)、(<code class="literal">100,103</code>)、(<code class="literal">200,104</code>)、および (<code class="literal">100,105</code>)。カウントされるカラム (<code class="literal">e,f</code>) は、結果セットの <code class="literal">stat_description</code> カラムに示されています。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-persistent-stats-tables-index-size"></a>14.13.16.1.4 innodb_index_stats テーブルを使用したインデックスサイズの取得</h5></div></div></div><p>
          テーブル、パーティション、またはサブパーティションのインデックスのサイズは、<code class="literal">innodb_index_stats</code> テーブルを使用して取得できます。次の例では、テーブル <code class="literal">t1</code> のインデックスサイズが取得されています。テーブル <code class="literal">t1</code> の定義および対応するインデックス統計については、<a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats-tables-example" title="14.13.16.1.3 InnoDB 永続的統計テーブルの例">セクション14.13.16.1.3「InnoDB 永続的統計テーブルの例」</a>を参照してください。
        </p><pre class="programlisting">mysql&gt; SELECT SUM(stat_value) pages, index_name,
    -&gt; SUM(stat_value)*@@innodb_page_size size
    -&gt; FROM mysql.innodb_index_stats WHERE table_name='t1'
    -&gt; AND stat_name = 'size' GROUP BY index_name;
+-------+------------+-------+
| pages | index_name | size  |
+-------+------------+-------+
|     1 | PRIMARY    | 16384 |
|     1 | i1         | 16384 |
|     1 | i2uniq     | 16384 |
+-------+------------+-------+
3 rows in set (0.00 sec)    </pre><p>
          パーティションまたはサブパーティションの場合は、変更された <code class="literal">WHERE</code> 句を含む同じクエリーを使用してインデックスサイズを取得できます。たとえば、次のクエリーは、テーブル <code class="literal">t1</code> のパーティションのインデックスサイズを取得します。
        </p><pre class="programlisting">mysql&gt; SELECT SUM(stat_value) pages, index_name,
    -&gt; SUM(stat_value)*@@innodb_page_size size
    -&gt; FROM mysql.innodb_index_stats WHERE table_name like 't1#P%'
    -&gt; AND stat_name = 'size' GROUP BY index_name;     </pre></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-statistics-estimation"></a>14.13.16.2 非永続的オプティマイザ統計のパラメータの構成</h4></div></div></div><a class="indexterm" name="idm139979063899632"></a><a class="indexterm" name="idm139979063898192"></a><a class="indexterm" name="idm139979063896912"></a><a class="indexterm" name="idm139979063894768"></a><p>
        MySQL 5.6.6 の時点では、オプティマイザ統計はデフォルトで永続的であり、<code class="literal">innodb_stats_persistent</code> 構成オプションで有効になります。このセクションでは、<code class="literal">innodb_stats_persistent=OFF</code> であるとき、または <code class="literal">STATS_PERSISTENT=0</code> で個々のテーブルが作成または変更されるときに適用される非永続的オプティマイザ統計の構成について説明します。永続的オプティマイザ統計については、<a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="14.13.16.1 永続的オプティマイザ統計のパラメータの構成">セクション14.13.16.1「永続的オプティマイザ統計のパラメータの構成」</a>を参照してください。
      </p><p>
        MySQL クエリーオプティマイザは、インデックスの相対的な<a class="link" href="glossary.html#glos_selectivity" title="選択性">選択性</a>に基づいて、キー分布に関する推定された<a class="link" href="glossary.html#glos_statistics" title="統計">統計</a>を使用して実行計画のためのインデックスを選択します。特定の操作を行うと、<code class="literal">InnoDB</code> は、インデックスの<a class="link" href="glossary.html#glos_cardinality" title="カーディナリティー">カーディナリティー</a>を推定するためにテーブル上の各インデックスからランダムなページをサンプリングします。(この手法は、<a class="link" href="glossary.html#glos_random_dive" title="ランダムダイブ">ランダムダイブ</a>と呼ばれます。)これらの操作には、<code class="literal">ANALYZE TABLE</code> ステートメント、<code class="literal">SHOW TABLE STATUS</code> ステートメント、および再起動後のテーブルへのはじめてのアクセスが含まれます。
      </p><p>
        統計の推定値の品質を制御する (それにより、クエリーオプティマイザへの情報を改善する) ために、パラメータ <code class="literal">innodb_stats_transient_sample_pages</code> を使用して、サンプリングされるページの数を変更できます。サンプリングされるページのデフォルト数は 8 です。これは、正確な推定値を生成するには十分ではなく、クエリーオプティマイザによる不適切なインデックス選択につながる可能性があります。この手法は、大きなテーブルや、<a class="link" href="glossary.html#glos_join" title="結合">結合</a>で使用されるテーブルの場合に特に重要です。このようなテーブルに対する不必要な<a class="link" href="glossary.html#glos_full_table_scan" title="テーブルの完全スキャン">フルテーブルスキャン</a>が、パフォーマンスの重大な問題になる場合があります。このようなクエリーのチューニングに関するヒントについては、<a class="xref" href="optimization.html#how-to-avoid-table-scan" title="8.2.1.20 フルテーブルスキャンを回避する方法">セクション8.2.1.20「フルテーブルスキャンを回避する方法」</a>を参照してください。
      </p><p>
        グローバルパラメータ <code class="literal">innodb_stats_transient_sample_pages</code> は、実行時に設定できます。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">innodb_stats_persistent=0</code> である場合は、<code class="literal">innodb_stats_transient_sample_pages</code> の値がすべての <code class="literal">InnoDB</code> テーブルおよびインデックスのインデックスサンプリングに影響を与えます。インデックスのサンプルサイズを変更すると、次の潜在的に重大な影響が発生します。

          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                1 や 2 などの小さな値では、カーディナリティーの不正確な推定値が生成される可能性があります。
              </p></li><li class="listitem"><p>
                <code class="literal">innodb_stats_transient_sample_pages</code> 値を大きくすると、必要なディスク読み取りが増える可能性があります。8 よりはるかに大きい値 (たとえば、100) では、テーブルを開いたり、<code class="literal">SHOW TABLE STATUS</code> を実行したりするための速度が大幅に遅くなる可能性があります。
              </p></li><li class="listitem"><p>
                オプティマイザが、インデックスの選択性の異なる推定値に基づいて、非常に異なるクエリー計画を選択する可能性があります。
              </p></li></ul></div><p>
        </p></div><p>
        <code class="literal">SHOW TABLE STATUS</code> や <code class="literal">SHOW INDEX</code> などのメタデータステートメントの実行時や、<code class="literal">INFORMATION_SCHEMA.TABLES</code> または <code class="literal">INFORMATION_SCHEMA.STATISTICS</code> テーブルへのアクセス時に統計が更新されるようにするには、ステートメント <code class="literal">SET GLOBAL innodb_stats_on_metadata=ON</code> (または <code class="literal">0</code>) を実行します。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          永続的オプティマイザ統計が MySQL 5.6.6 でデフォルトで有効になったとき、<code class="literal">innodb_stats_on_metadata</code> のデフォルト設定は <code class="literal">OFF</code> に変更されました。この変数を有効にすると、多数のテーブルまたはインデックスを含むスキーマへのアクセス速度が低下したり、<code class="literal">InnoDB</code> テーブルに関するクエリーの実行計画の安定性が低下したりする可能性があります。
        </p></div><p>
        <code class="option">--auto-rehash</code> 設定がオン (デフォルト) の状態で <span class="command"><strong>mysql</strong></span> クライアントが起動されると、すべての <code class="literal">InnoDB</code> テーブルが開かれ、関連付けられたすべてのインデックスの統計がふたたび推定されます。<span class="command"><strong>mysql</strong></span> クライアントの起動時間を改善するために、<code class="option">--disable-auto-rehash</code> オプションを使用して auto-rehash をオフにすることができます。<code class="literal">auto-rehash</code> 機能は、対話ユーザーのためのデータベース、テーブル、およびカラム名の自動名前補完を有効にします。
      </p><p>
        あるシステムで <code class="literal">innodb_stats_transient_sample_pages</code> のどのような値が最適に機能したとしても、このオプションを設定し、その値のままにします。過剰な I/O を必要とせずに、データベース内のすべてのテーブルに対して適度に正確な推定値を生成する値を選択してください。統計は <code class="literal">ANALYZE TABLE</code> の実行時以外のさまざまな時間に自動的に再計算されるため、インデックスのサンプルサイズを増やし、<code class="literal">ANALYZE TABLE</code> を実行してから、サンプルサイズをふたたび減らしても意味がありません。<code class="literal">innodb_stats_transient_sample_pages</code> の大きな値で実行されている <code class="literal">ANALYZE</code> によって計算されたより正確な統計があとで消去される可能性があります。
      </p><p>
        小さなテーブルは一般に、大きなテーブルに比べて、必要なインデックスサンプルが少なくなります。データベースに多数の大きなテーブルが含まれている場合は、ほとんどが小さなテーブルである場合より大きな <code class="literal">innodb_stats_transient_sample_pages</code> 値を使用することを考慮してください。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-analyze-table-complexity"></a>14.13.17 InnoDB テーブルに対する ANALYZE TABLE の複雑さの推定</h3></div></div></div><p>
      <code class="literal">InnoDB</code> テーブルに対する <code class="literal">ANALYZE TABLE</code> の複雑さは、次のものに依存します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">innodb_stats_persistent_sample_pages</code> で定義される、サンプリングされるページの数。
        </p></li><li class="listitem"><p>
          テーブル内のインデックス付きカラムの数
        </p></li><li class="listitem"><p>
          パーティションの数。テーブルにパーティションが存在しない場合、パーティションの数は 1 であるとみなされます。
        </p></li></ul></div><p>
      これらのパラメータを使用すると、<code class="literal">ANALYZE TABLE</code> の複雑さを推定するための概略の計算式は次のようになります。
    </p><p>
      <code class="literal">innodb_stats_persistent_sample_pages</code> の値 * テーブル内のインデックス付きカラムの数 * パーティションの数
    </p><p>
      通常は、この結果の値が大きいほど、<code class="literal">ANALYZE TABLE</code> の実行時間も大きくなります。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">innodb_stats_persistent_sample_pages</code> は、グローバルレベルでサンプリングされるページの数を定義します。個々のテーブルのサンプリングされるページの数を設定するには、<code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> で <code class="literal">STATS_SAMPLE_PAGES</code> オプションを使用します。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="14.13.16.1 永続的オプティマイザ統計のパラメータの構成">セクション14.13.16.1「永続的オプティマイザ統計のパラメータの構成」</a>を参照してください。
      </p><p>
        <code class="literal">innodb_stats_persistent=OFF</code> である場合、サンプリングされるページの数は <code class="literal">innodb_stats_transient_sample_pages</code> で定義されます。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-statistics-estimation" title="14.13.16.2 非永続的オプティマイザ統計のパラメータの構成">セクション14.13.16.2「非永続的オプティマイザ統計のパラメータの構成」</a>を参照してください。
      </p></div><p>
      <code class="literal">ANALYZE TABLE</code> の複雑さを推定するためのより詳細なアプローチを示すために、次の例を考えてみます。
    </p><p>
      <a class="ulink" href="http://en.wikipedia.org/wiki/Big_O_notation" target="_top">ビッグオー表記</a>では、<code class="literal">ANALYZE TABLE</code> の複雑さは次のように記述されます。
    </p><pre class="programlisting"> O(n_sample
  * (n_cols_in_uniq_i
     + n_cols_in_non_uniq_i
     + n_cols_in_pk * (1 + n_non_uniq_i))
  * n_part)          </pre><p>
      ここでは:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">n_sample</code> は、サンプリングされるページの数 (<code class="literal">innodb_stats_persistent_sample_pages</code> で定義されます)
        </p></li><li class="listitem"><p>
          <code class="literal">n_cols_in_uniq_i</code> は、すべての一意のインデックス内のすべてのカラムの総数 (主キーカラムはカウントしない)
        </p></li><li class="listitem"><p>
          <code class="literal">n_cols_in_non_uniq_i</code> は、すべての一意でないインデックス内のすべてのカラムの総数
        </p></li><li class="listitem"><p>
          <code class="literal">n_cols_in_pk</code> は、主キー内のカラム数 (主キーが定義されていない場合、<code class="literal">InnoDB</code> は単一カラムの主キーを内部的に作成します)
        </p></li><li class="listitem"><p>
          <code class="literal">n_non_uniq_i</code> は、テーブル内の一意でないインデックスの数
        </p></li><li class="listitem"><p>
          <code class="literal">n_part</code> は、パーティションの数。パーティションが定義されていない場合、そのテーブルは単一パーティションであるとみなされます。
        </p></li></ul></div><p>
      ここで、主キー (2 つのカラム)、一意のインデックス (2 つのカラム)、および 2 つの一意でないインデックス (それぞれ 2 つのカラム) を持つ次のテーブル (テーブル <code class="literal">t</code>) を考えてみます。
    </p><pre class="programlisting"> CREATE TABLE t (
  a INT,
  b INT,
  c INT,
  d INT,
  e INT,
  f INT,
  g INT,
  h INT,
  PRIMARY KEY (a, b),
  UNIQUE KEY i1uniq (c, d),
  KEY i2nonuniq (e, f),
  KEY i3nonuniq (g, h)
);    </pre><p>
      上で説明したアルゴリズムに必要なカラムとインデックスデータについて、テーブル <code class="literal">t</code> の <code class="literal">mysql.innodb_index_stats</code> 永続的インデックス統計テーブルにクエリーします。<code class="literal">n_diff_pfx%</code> の統計には、各インデックスに対してカウントされるカラムが示されます。たとえば、カラム <code class="literal">a</code> および <code class="literal">b</code> は、主キーのインデックスに対してカウントされます。一意でないインデックスの場合は、ユーザー定義のカラムに加えて、主キーカラム (a,b) がカウントされます。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">InnoDB</code> 永続的統計テーブルの詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="14.13.16.1 永続的オプティマイザ統計のパラメータの構成">セクション14.13.16.1「永続的オプティマイザ統計のパラメータの構成」</a>を参照してください。
      </p></div><pre class="programlisting">  SELECT index_name, stat_name, stat_description
  FROM mysql.innodb_index_stats
  WHERE
  database_name='test' AND
  table_name='t' AND
  stat_name like 'n_diff_pfx%';

  +------------+--------------+------------------+
  | index_name | stat_name    | stat_description |
  +------------+--------------+------------------+
  | PRIMARY    | n_diff_pfx01 | a                |
  | PRIMARY    | n_diff_pfx02 | a,b              |
  | i1uniq     | n_diff_pfx01 | c                |
  | i1uniq     | n_diff_pfx02 | c,d              |
  | i2nonuniq  | n_diff_pfx01 | e                |
  | i2nonuniq  | n_diff_pfx02 | e,f              |
  | i2nonuniq  | n_diff_pfx03 | e,f,a            | 
  | i2nonuniq  | n_diff_pfx04 | e,f,a,b          |
  | i3nonuniq  | n_diff_pfx01 | g                |
  | i3nonuniq  | n_diff_pfx02 | g,h              |
  | i3nonuniq  | n_diff_pfx03 | g,h,a            |
  | i3nonuniq  | n_diff_pfx04 | g,h,a,b          |
  +------------+--------------+------------------+   </pre><p>
      上に示したインデックス統計データとテーブル定義に基づいて、次の値を確認できます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">n_cols_in_uniq_i</code> (すべての一意のインデックス内のすべてのカラムの総数、主キーカラムはカウントしない) は 2 (<code class="literal">c</code> および <code class="literal">d</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">n_cols_in_non_uniq_i</code> (すべての一意でないインデックス内のすべてのカラムの総数) は 4 (<code class="literal">e</code>、<code class="literal">f</code>、<code class="literal">g</code>、および <code class="literal">h</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">n_cols_in_pk</code> (主キー内のカラム数) は 2 (<code class="literal">a</code> および <code class="literal">b</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">n_non_uniq_i</code> (テーブル内の一意でないインデックスの数) は 2 (<code class="literal">i2nonuniq</code> および <code class="literal">i3nonuniq</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">n_part</code> (パーティションの数) は 1。
        </p></li></ul></div><p>
      これで、スキャンされるリーフページの数を決定するために <code class="literal">innodb_stats_persistent_sample_pages</code> * (2 + 4 + 2 * (1 + 2)) * 1 を計算できます。<code class="literal">innodb_stats_persistent_sample_pages</code> が <code class="literal">20</code> のデフォルト値に設定されており、かつページサイズがデフォルトの 16 <code class="literal">KiB</code> (<code class="literal">innodb_page_size</code>=16384) である場合は、テーブル <code class="literal">t</code> に対して 20 * 12 * 16384 <code class="literal">バイト</code>、つまり約 4 <code class="literal">MiB</code> が読み取られると推定できます。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        一部のリーフページはすでにバッファープール内にキャッシュされている可能性があるため、4 <code class="literal">MiB</code> のすべてがディスクから読み取られるとは限りません。
      </p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-information-schema"></a>14.14 InnoDB INFORMATION_SCHEMA テーブル</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-compression-tables">14.14.1 圧縮に関する InnoDB INFORMATION_SCHEMA テーブル</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-transactions">14.14.2 InnoDB INFORMATION_SCHEMA トランザクションおよびロックテーブル</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-system-tables">14.14.3 InnoDB INFORMATION_SCHEMA システムテーブル</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-fulltext_index-tables">14.14.4 InnoDB INFORMATION_SCHEMA FULLTEXT インデックステーブル</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-buffer-pool-tables">14.14.5 InnoDB INFORMATION_SCHEMA バッファープールテーブル</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-metrics-table">14.14.6 InnoDB INFORMATION_SCHEMA メトリックテーブル</a></span></dt></dl></div><a class="indexterm" name="idm139979063761552"></a><p>
    このセクションでは、<code class="literal">InnoDB</code> <a class="link" href="information-schema.html" title="第 21 章 INFORMATION_SCHEMA テーブル"><code class="literal">INFORMATION_SCHEMA</code></a> テーブルについて、その使用例とともに説明します。
  </p><p>
    <code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code> テーブルは、<code class="literal">InnoDB</code> ストレージエンジンのさまざまな側面に関するメタデータ、ステータス情報、および統計を提供します。<code class="literal">INFORMATION_SCHEMA</code> データベースで <code class="literal">SHOW TABLES</code> ステートメントを発行することによって、<code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code> テーブルのリストを表示できます。
  </p><pre class="programlisting">mysql&gt; SHOW TABLES FROM INFORMATION_SCHEMA LIKE 'INNODB%';</pre><p>
    テーブル定義については、<a class="xref" href="information-schema.html#innodb-i_s-tables" title="21.29 InnoDB の INFORMATION_SCHEMA テーブル">セクション21.29「InnoDB の INFORMATION_SCHEMA テーブル」</a>を参照してください。<code class="literal">MySQL</code> <code class="literal">INFORMATION_SCHEMA</code> データベースに関連した一般的な情報については、<a class="xref" href="information-schema.html" title="第 21 章 INFORMATION_SCHEMA テーブル">第21章「<i>INFORMATION_SCHEMA テーブル</i>」</a>を参照してください。
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-information-schema-compression-tables"></a>14.14.1 圧縮に関する InnoDB INFORMATION_SCHEMA テーブル</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-innodb_cmp">14.14.1.1 INNODB_CMP および INNODB_CMP_RESET</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-innodb_cmpmem">14.14.1.2 INNODB_CMPMEM および INNODB_CMPMEM_RESET</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-examples-compression-sect">14.14.1.3 圧縮情報スキーマテーブルの使用</a></span></dt></dl></div><a class="indexterm" name="idm139979063745312"></a><p>
      圧縮が全体としてどれだけ適切に機能しているかを把握するための、圧縮に関する <code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code> テーブルのペアとして、次の 2 つがあります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">INNODB_CMP</code> および <code class="literal">INNODB_CMP_RESET</code> には、圧縮操作の数および圧縮の実行に費やされた時間に関する情報が含まれています。
        </p></li><li class="listitem"><p>
          <code class="literal">INNODB_CMPMEM</code> および <code class="literal">INNODB_CMP_RESET</code> には、圧縮のためにメモリーが割り当てられる方法に関する情報が含まれています。
        </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-information-schema-innodb_cmp"></a>14.14.1.1 INNODB_CMP および INNODB_CMP_RESET</h4></div></div></div><a class="indexterm" name="idm139979063733168"></a><a class="indexterm" name="idm139979063731024"></a><p>
        <code class="literal">INNODB_CMP</code> および <code class="literal">INNODB_CMP_RESET</code> テーブルには、<a class="xref" href="innodb-storage-engine.html#innodb-compression" title="14.7 InnoDB 圧縮テーブル">セクション14.7「InnoDB 圧縮テーブル」</a>で説明されている圧縮テーブルに関連した操作に関するステータス情報が含まれています。<code class="literal">PAGE_SIZE</code> カラムは、圧縮された<a class="link" href="glossary.html#glos_page_size" title="page size">ページサイズ</a>をレポートします。
      </p><p>
        これらの 2 つのテーブルの内容は同じですが、<code class="literal">INNODB_CMP_RESET</code> から読み取ると、圧縮および圧縮解除操作に関する統計がリセットされます。たとえば、<code class="literal">INNODB_CMP_RESET</code> の出力を 60 分に 1 回アーカイブした場合は、1 時間ごとの統計が表示されます。<code class="literal">INNODB_CMP</code> の出力を (<code class="literal">INNODB_CMP_RESET</code> を読み取らないように注意して) モニターした場合は、InnoDB が起動されてからの累積された統計が表示されます。
      </p><p>
        テーブル定義については、<a class="xref" href="information-schema.html#innodb-cmp-table" title="21.29.1 INFORMATION_SCHEMA INNODB_CMP および INNODB_CMP_RESET テーブル">セクション21.29.1「INFORMATION_SCHEMA INNODB_CMP および INNODB_CMP_RESET テーブル」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-information-schema-innodb_cmpmem"></a>14.14.1.2 INNODB_CMPMEM および INNODB_CMPMEM_RESET</h4></div></div></div><a class="indexterm" name="idm139979063715264"></a><a class="indexterm" name="idm139979063713152"></a><a class="indexterm" name="idm139979063711056"></a><p>
        <code class="literal">INNODB_CMPMEM</code> および <code class="literal">INNODB_CMPMEM_RESET</code> テーブルには、バッファープール内に存在する圧縮ページに関するステータス情報が含まれています。圧縮テーブルおよびバッファープールの使用の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-compression" title="14.7 InnoDB 圧縮テーブル">セクション14.7「InnoDB 圧縮テーブル」</a>を参照してください。<code class="literal">INNODB_CMP</code> および <code class="literal">INNODB_CMP_RESET</code> テーブルでは、圧縮に関するより役立つ統計が提供されます。
      </p><h5><a name="idm139979063703632"></a>内部の詳細</h5><p>
        <code class="literal">InnoDB</code> は、<a class="link" href="glossary.html#glos_buddy_allocator" title="バディーアロケータ">バディーアロケータ</a>システムを使用して、1K バイトから 16K バイトまでの<a class="link" href="glossary.html#glos_page_size" title="page size">さまざまなサイズのページ</a>に割り当てられたメモリーを管理します。ここで説明されている 2 つのテーブルの各行は、1 つのページサイズに対応します。
      </p><p>
        <code class="literal">INNODB_CMPMEM</code> および <code class="literal">INNODB_CMPMEM_RESET</code> テーブルの内容は同じですが、<code class="literal">INNODB_CMPMEM_RESET</code> から読み取ると、再配置操作に関する統計がリセットされます。たとえば、<code class="literal">INNODB_CMPMEM_RESET</code> の出力を 60 分に 1 回アーカイブした場合は、1 時間ごとの統計が表示されます。<code class="literal">INNODB_CMPMEM_RESET</code> を読み取らないように注意して、代わりに <code class="literal">INNODB_CMPMEM</code> の出力をモニターした場合は、<code class="literal">InnoDB</code> が起動されてからの累積された統計が表示されます。
      </p><p>
        テーブル定義については、<a class="xref" href="information-schema.html#innodb-cmpmem-table" title="21.29.3 INFORMATION_SCHEMA INNODB_CMPMEM および INNODB_CMPMEM_RESET テーブル">セクション21.29.3「INFORMATION_SCHEMA INNODB_CMPMEM および INNODB_CMPMEM_RESET テーブル」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-information-schema-examples-compression-sect"></a>14.14.1.3 圧縮情報スキーマテーブルの使用</h4></div></div></div><div class="example"><a name="innodb-information-schema-examples-compression"></a><p class="title"><b>例 14.10 圧縮情報スキーマテーブルの使用</b></p><div class="example-contents"><p>
          圧縮テーブルを含むデータベースからのサンプル出力を次に示します (<a class="xref" href="innodb-storage-engine.html#innodb-compression" title="14.7 InnoDB 圧縮テーブル">セクション14.7「InnoDB 圧縮テーブル」</a>、<code class="literal">INNODB_CMP</code>、<code class="literal">INNODB_CMP_PER_INDEX</code>、および <code class="literal">INNODB_CMPMEM</code> を参照してください)。
        </p><p>
          次の表は、軽い<a class="link" href="glossary.html#glos_workload" title="ワークロード">ワークロード</a>下にある <code class="literal">INFORMATION_SCHEMA.INNODB_CMP</code> の内容を示しています。バッファープールに含まれている唯一の圧縮ページサイズは 8K です。カラム <code class="literal">COMPRESS_TIME</code> および <code class="literal">UNCOMPRESS_TIME</code> が 0 であるため、ページの圧縮または圧縮解除で消費された時間は統計がリセットされてから 1 秒未満でした。
        </p><div class="informaltable"><a name="innodb-information-schema-sample-innodb_cmp"></a><table summary=" 軽いワークロード下での InnoDB テーブル圧縮の内部動作を示す、INFORMATION_SCHEMA.INNODB_CMP テーブルからのサンプルデータ。" border="1"><colgroup><col><col><col><col><col><col></colgroup><thead><tr><th scope="col">page size</th><th scope="col">compress ops</th><th scope="col">compress ops ok</th><th scope="col">compress time</th><th scope="col">uncompress ops</th><th scope="col">uncompress time</th></tr></thead><tbody><tr><td scope="row">1024</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td scope="row">2048</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td scope="row">4096</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td scope="row">8192</td><td>1048</td><td>921</td><td>0</td><td>61</td><td>0</td></tr><tr><td scope="row">16384</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table></div><p>
          <code class="literal">INNODB_CMPMEM</code> によると、<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>内には 6169 個の圧縮された 8K バイトページが存在します。割り当てられているほかのブロックサイズは 64 バイトだけです。<code class="literal">INNODB_CMPMEM</code> 内のもっとも小さい <code class="literal">PAGE_SIZE</code> は、対応する圧縮解除されたページがバッファープール内に存在しない圧縮ページのブロックディスクリプタとして使用されます。このようなページが 5910 個存在することがわかります。また、間接的には、259 (6169-5910) 個の圧縮ページもバッファープール内に圧縮解除された形式で存在することがわかります。
        </p><p>
          次の表は、軽い<a class="link" href="glossary.html#glos_workload" title="ワークロード">ワークロード</a>下にある <code class="literal">INFORMATION_SCHEMA.INNODB_CMPMEM</code> の内容を示しています。圧縮ページのためのメモリーアロケータの断片化のために、一部のメモリー <code class="literal">SUM(PAGE_SIZE*PAGES_FREE)=6784</code> は使用できません。これは、小さなメモリー割り当て要求が、バディーアロケーションシステムを使用して (メインのバッファープールから割り当てられる 16K ブロックから始めて) より大きなブロックを分割することによって満たされるためです。断片化がこのように少ないのは、より大きな隣接した空きブロックを形成するために、割り当てられた一部のブロックが再配置 (コピー) されたためです。この <code class="literal">SUM(PAGE_SIZE*RELOCATION_OPS)</code> バイトのコピーで消費された時間は 1 秒未満でした (<code class="literal">(SUM(RELOCATION_TIME)=0)</code>)。
        </p><div class="informaltable"><a name="innodb-information-schema-sample-innodb_cmpmem"></a><table summary=" 軽いワークロード下での InnoDB テーブル圧縮に対するバッファープールのメモリー操作を示す、INFORMATION_SCHEMA.INNODB_CMPMEM テーブルからのサンプルデータ。" border="1"><colgroup><col><col><col><col><col></colgroup><thead><tr><th scope="col">page size</th><th scope="col">pages used</th><th scope="col">pages free</th><th scope="col">relocation ops</th><th scope="col">relocation time</th></tr></thead><tbody><tr><td scope="row">64</td><td>5910</td><td>0</td><td>2436</td><td>0</td></tr><tr><td scope="row">128</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td scope="row">256</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td scope="row">512</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td scope="row">1024</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td scope="row">2048</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td scope="row">4096</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td scope="row">8192</td><td>6169</td><td>0</td><td>5</td><td>0</td></tr><tr><td scope="row">16384</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table></div></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-information-schema-transactions"></a>14.14.2 InnoDB INFORMATION_SCHEMA トランザクションおよびロックテーブル</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-examples">14.14.2.1 InnoDB トランザクションおよびロックテーブルの使用例</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-understanding_innodb_locking">14.14.2.2 INNODB_LOCKS と INNODB_LOCK_WAITS のデータ</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-rapidly_changing_internal_data">14.14.2.3 InnoDB トランザクションおよびロックテーブルのデータ永続性および一貫性</a></span></dt></dl></div><a class="indexterm" name="idm139979063611056"></a><p>
      3 つの <code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code> テーブルを使用すると、トランザクションのモニタリングや、可能性のあるロックの問題の診断が容易になります。これらの 3 つのテーブルは、<code class="literal">INNODB_TRX</code>、<code class="literal">INNODB_LOCKS</code>、および <code class="literal">INNODB_LOCK_WAITS</code> です。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="indexterm" name="idm139979063603168"></a> <code class="literal">INNODB_TRX</code>: 現在 <code class="literal">InnoDB</code> の内部で実行中のすべてのトランザクションに関する情報が含まれています。これには、そのトランザクションがロックを待機しているかどうか、そのトランザクションがいつ開始されたか、そのトランザクションが実行している特定の SQL ステートメントなどが含まれます。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979063598048"></a> <code class="literal">INNODB_LOCKS</code>: 別のトランザクションがロックを解放するのを待機している InnoDB 内の各トランザクション (<code class="literal">INNODB_TRX.TRX_STATE='LOCK WAIT'</code>) は、ただ 1 つの<span class="quote">「<span class="quote">ブロックしているロック要求</span>」</span>によってブロックされます。そのブロックしているロック要求は、互換性がないモードにある別のトランザクションによって保持されている行ロックまたはテーブルロックに対するものです。待機しているトランザクションまたはブロックされているトランザクションは、ほかのトランザクションがコミットまたはロールバックして、要求されたロックを解放するまで処理を続行できません。<code class="literal">INNODB_LOCKS</code> には、ブロックされているトランザクションごとに、そのトランザクションが要求し、かつ待機している各ロックを記述した 1 行が含まれています。<code class="literal">INNODB_LOCKS</code> にはまた、ロックを保持しているトランザクションの状態 (<code class="literal">'RUNNING'</code>、<code class="literal">'LOCK WAIT'</code>、<code class="literal">'ROLLING BACK'</code>、または <code class="literal">'COMMITTING'</code>) にかかわらず、別のトランザクションをブロックしているロックごとの 1 行も含まれています。トランザクションをブロックしているロックは常に、要求されたロックのモードとは互換性のないモード (読み取りと書き込み、共有と排他的など) に保持されています。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979063585776"></a> <code class="literal">INNODB_LOCK_WAITS</code>: このテーブルを使用すると、特定のロックをどのトランザクションが待機しているか、または特定のトランザクションがどのロックを待機しているかがわかります。このテーブルには、<span class="emphasis"><em>ブロックされている</em></span>トランザクションごとに、そのトランザクションが要求したロックと、その要求をブロックしているロックを示す 1 つ以上の行が含まれています。<code class="literal">REQUESTED_LOCK_ID</code> はトランザクションが要求しているロックを示し、<code class="literal">BLOCKING_LOCK_ID</code> は、最初のトランザクションの続行を妨げている (別のトランザクションによって保持されている) ロックを示します。ブロックされている特定のどのトランザクションでも、<code class="literal">INNODB_LOCK_WAITS</code> 内のすべての行が <code class="literal">REQUESTED_LOCK_ID</code> については同じ値を、また <code class="literal">BLOCKING_LOCK_ID</code> については異なる値を持っています。
        </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-information-schema-examples"></a>14.14.2.1 InnoDB トランザクションおよびロックテーブルの使用例</h4></div></div></div><div class="example"><a name="innodb-information-schema-examples-simple-blocking"></a><p class="title"><b>例 14.11 ブロックしているトランザクションの識別</b></p><div class="example-contents"><p>
          別のトランザクションをどのトランザクションがブロックしているかを識別できると役立つ場合があります。<code class="literal">INFORMATION_SCHEMA</code> テーブルを使用すると、別のトランザクションをどのトランザクションが待機しているかや、どのリソースが要求されているかを見つけることができます。
        </p><p>
          3 人のユーザーが同時に実行している次のシナリオがあるとします。各ユーザー (またはセッション) は MySQL スレッドに対応し、あるトランザクションを別のトランザクションのあとに実行します。これらのユーザーが次のコマンドを発行したが、まだだれも自分のトランザクションをコミットしていないときのシステムの状態を考えてみてください。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">ユーザー A: </code>
            </p><pre class="programlisting">
BEGIN;
SELECT a FROM t FOR UPDATE;
SELECT SLEEP(100);
</pre></li><li class="listitem"><p>
              <code class="literal">ユーザー B: </code>
            </p><pre class="programlisting">
SELECT b FROM t FOR UPDATE;
</pre></li><li class="listitem"><p>
              <code class="literal">ユーザー C: </code>
            </p><pre class="programlisting">
SELECT c FROM t FOR UPDATE;
</pre></li></ul></div><p>
          このシナリオでは、次のクエリーを使用して、だれがだれを待機しているかを確認できます。
        </p><pre class="programlisting">
SELECT r.trx_id waiting_trx_id,  
       r.trx_mysql_thread_id waiting_thread,
       r.trx_query waiting_query,
       b.trx_id blocking_trx_id, 
       b.trx_mysql_thread_id blocking_thread,
       b.trx_query blocking_query
   FROM       information_schema.innodb_lock_waits w
   INNER JOIN information_schema.innodb_trx b  ON  
    b.trx_id = w.blocking_trx_id
  INNER JOIN information_schema.innodb_trx r  ON  
    r.trx_id = w.requesting_trx_id;
</pre><div class="informaltable"><table summary=" この表は、前の文章に示されている INFORMATION_SCHEMA.INNODB_LOCK_WAITS および INFORMATION_SCHEMA.INNODB_TRX テーブルに対するクエリーの結果セットを表しています。ここには、どの InnoDB スレッドがほかのどのスレッドを待機しているかが示されています。" border="1"><colgroup><col><col><col><col><col><col></colgroup><thead><tr><th scope="col">waiting trx id</th><th scope="col">waiting thread</th><th scope="col">waiting query</th><th scope="col">blocking trx id</th><th scope="col">blocking thread</th><th scope="col">blocking query</th></tr></thead><tbody><tr><td scope="row"><code class="literal">A4</code></td><td><code class="literal">6</code></td><td><code class="literal">SELECT b FROM t FOR UPDATE</code></td><td><code class="literal">A3</code></td><td><code class="literal">5</code></td><td><code class="literal">SELECT SLEEP(100)</code></td></tr><tr><td scope="row"><code class="literal">A5</code></td><td><code class="literal">7</code></td><td><code class="literal">SELECT c FROM t FOR UPDATE</code></td><td><code class="literal">A3</code></td><td><code class="literal">5</code></td><td><code class="literal">SELECT SLEEP(100)</code></td></tr><tr><td scope="row"><code class="literal">A5</code></td><td><code class="literal">7</code></td><td><code class="literal">SELECT c FROM t FOR UPDATE</code></td><td><code class="literal">A4</code></td><td><code class="literal">6</code></td><td><code class="literal">SELECT b FROM t FOR UPDATE</code></td></tr></tbody></table></div><p>
          上の結果では、<span class="quote">「<span class="quote">waiting query</span>」</span>または<span class="quote">「<span class="quote">blocking query</span>」</span>でユーザーを識別できます。次のことがわかります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              ユーザー B (trx id <code class="literal">'A4'</code>、スレッド <code class="literal">6</code>) とユーザー C (trx id <code class="literal">'A5'</code>、スレッド <code class="literal">7</code>) はどちらも、ユーザー A (trx id <code class="literal">'A3'</code>、スレッド <code class="literal">5</code>) を待機しています。
            </p></li><li class="listitem"><p>
              ユーザー C は、ユーザー A のほかにユーザー B を待機しています。
            </p></li></ul></div><p>
          テーブル <a class="link" href="innodb-storage-engine.html#innodb-information-schema-examples-simple-blocking-trx"><code class="literal">INNODB_TRX</code></a>、<a class="link" href="innodb-storage-engine.html#innodb-information-schema-examples-simple-blocking-locks"><code class="literal">INNODB_LOCKS</code></a>、および <a class="link" href="innodb-storage-engine.html#innodb-information-schema-examples-simple-blocking-waits"><code class="literal">INNODB_LOCK_WAITS</code></a> 内のベースとなるデータを確認できます。
        </p><p>
          次の表は、<code class="literal">INFORMATION_SCHEMA.INNODB_TRX</code> の内容のいくつかのサンプルを示しています。
        </p><div class="informaltable"><a name="innodb-information-schema-examples-simple-blocking-trx"></a><table summary=" カラムごとの標準的なエントリのタイプを示す、INFORMATION_SCHEMA.INNODB_TRX テーブルからのサンプルデータ。" border="1"><colgroup><col><col><col><col><col><col><col><col></colgroup><thead><tr><th scope="col">trx id</th><th scope="col">trx state</th><th scope="col">trx started</th><th scope="col">trx requested lock id</th><th scope="col">trx wait started</th><th scope="col">trx weight</th><th scope="col">trx mysql thread id</th><th scope="col">trx query</th></tr></thead><tbody><tr><td scope="row"><code class="literal">A3</code></td><td><code class="literal">RUN­NING</code></td><td><code class="literal">2008-01-15 16:44:54</code></td><td><code class="literal">NULL</code></td><td><code class="literal">NULL</code></td><td><code class="literal">2</code></td><td><code class="literal">5</code></td><td><code class="literal">SELECT SLEEP(100)</code></td></tr><tr><td scope="row"><code class="literal">A4</code></td><td><code class="literal">LOCK WAIT</code></td><td><code class="literal">2008-01-15 16:45:09</code></td><td><code class="literal">A4:1:3:2</code></td><td><code class="literal">2008-01-15 16:45:09</code></td><td><code class="literal">2</code></td><td><code class="literal">6</code></td><td><code class="literal">SELECT b FROM t FOR UPDATE</code></td></tr><tr><td scope="row"><code class="literal">A5</code></td><td><code class="literal">LOCK WAIT</code></td><td><code class="literal">2008-01-15 16:45:14</code></td><td><code class="literal">A5:1:3:2</code></td><td><code class="literal">2008-01-15 16:45:14</code></td><td><code class="literal">2</code></td><td><code class="literal">7</code></td><td><code class="literal">SELECT c FROM t FOR UPDATE</code></td></tr></tbody></table></div><p>
          次の表は、<code class="literal">INFORMATION_SCHEMA.INNODB_LOCKS</code> の内容のいくつかのサンプルを示しています。
        </p><div class="informaltable"><a name="innodb-information-schema-examples-simple-blocking-locks"></a><table summary=" カラムごとの標準的なエントリのタイプを示す、INFORMATION_SCHEMA.INNODB_LOCKS テーブルからのサンプルデータ。" border="1"><colgroup><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th scope="col">lock id</th><th scope="col">lock trx id</th><th scope="col">lock mode</th><th scope="col">lock type</th><th scope="col">lock table</th><th scope="col">lock index</th><th scope="col">lock space</th><th scope="col">lock page</th><th scope="col">lock rec</th><th scope="col">lock data</th></tr></thead><tbody><tr><td scope="row"><code class="literal">A3:1:3:2</code></td><td><code class="literal">A3</code></td><td><code class="literal">X</code></td><td><code class="literal">RECORD</code></td><td><code class="literal">`test`.`t`</code></td><td><code class="literal">`PRIMARY`</code></td><td><code class="literal">1</code></td><td><code class="literal">3</code></td><td><code class="literal">2</code></td><td><code class="literal">0x0200</code></td></tr><tr><td scope="row"><code class="literal">A4:1:3:2</code></td><td><code class="literal">A4</code></td><td><code class="literal">X</code></td><td><code class="literal">RECORD</code></td><td><code class="literal">`test`.`t`</code></td><td><code class="literal">`PRIMARY`</code></td><td><code class="literal">1</code></td><td><code class="literal">3</code></td><td><code class="literal">2</code></td><td><code class="literal">0x0200</code></td></tr><tr><td scope="row"><code class="literal">A5:1:3:2</code></td><td><code class="literal">A5</code></td><td><code class="literal">X</code></td><td><code class="literal">RECORD</code></td><td><code class="literal">`test`.`t`</code></td><td><code class="literal">`PRIMARY`</code></td><td><code class="literal">1</code></td><td><code class="literal">3</code></td><td><code class="literal">2</code></td><td><code class="literal">0x0200</code></td></tr></tbody></table></div><p>
          次の表は、<code class="literal">INFORMATION_SCHEMA.INNODB_LOCK_WAITS</code> の内容のいくつかのサンプルを示しています。
        </p><div class="informaltable"><a name="innodb-information-schema-examples-simple-blocking-waits"></a><table summary=" カラムごとの標準的なエントリのタイプを示す、INFORMATION_SCHEMA.INNODB_LOCK_WAITS テーブルからのサンプルデータ。" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th scope="col">requesting trx id</th><th scope="col">requested lock id</th><th scope="col">blocking trx id</th><th scope="col">blocking lock id</th></tr></thead><tbody><tr><td scope="row"><code class="literal">A4</code></td><td><code class="literal">A4:1:3:2</code></td><td><code class="literal">A3</code></td><td><code class="literal">A3:1:3:2</code></td></tr><tr><td scope="row"><code class="literal">A5</code></td><td><code class="literal">A5:1:3:2</code></td><td><code class="literal">A3</code></td><td><code class="literal">A3:1:3:2</code></td></tr><tr><td scope="row"><code class="literal">A5</code></td><td><code class="literal">A5:1:3:2</code></td><td><code class="literal">A4</code></td><td><code class="literal">A4:1:3:2</code></td></tr></tbody></table></div></div></div><br class="example-break"><div class="example"><a name="innodb-information-schema-sample-locks"></a><p class="title"><b>例 14.12 情報スキーマテーブル内のトランザクションデータのより複雑な例</b></p><div class="example-contents"><p>
          場合によっては、内部の <code class="literal">InnoDB</code> ロック情報を MySQL で保持されているセッションレベルの情報と関連付けたいことがあります。たとえば、特定の <code class="literal">InnoDB</code> トランザクション ID について、ロックを保持しているために別のトランザクションをブロックしている可能性があるユーザーの対応する MySQL セッション ID と名前を知りたいことがあります。
        </p><p>
          <code class="literal">INFORMATION_SCHEMA</code> テーブルからの次の出力は、ある程度負荷の高いシステムから取得されました。
        </p><p>
          次の表からわかるように、実行中のトランザクションが複数存在します。
        </p><p>
          次の <code class="literal">INNODB_LOCKS</code> および <code class="literal">INNODB_LOCK_WAITS</code> テーブルは、次のことを示しています。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              トランザクション <span class="color0"><code class="literal">77F</code></span> (<code class="literal">INSERT</code> を実行中) は、トランザクション <span class="color1"><code class="literal">77E</code></span>、<span class="color2"><code class="literal">77D</code></span>、および <span class="color3"><code class="literal">77B</code></span> がコミットするのを待機しています。
            </p></li><li class="listitem"><p>
              トランザクション <span class="color1"><code class="literal">77E</code></span> (INSERT を実行中) は、トランザクション <span class="color2"><code class="literal">77D</code></span> および <span class="color3"><code class="literal">77B</code></span> がコミットするのを待機しています。
            </p></li><li class="listitem"><p>
              トランザクション <span class="color2"><code class="literal">77D</code></span> (INSERT を実行中) は、トランザクション <span class="color3"><code class="literal">77B</code></span> がコミットするのを待機しています。
            </p></li><li class="listitem"><p>
              トランザクション <span class="color3"><code class="literal">77B</code></span> (INSERT を実行中) は、トランザクション <span class="color4"><code class="literal">77A</code></span> がコミットするのを待機しています。
            </p></li><li class="listitem"><p>
              トランザクション <span class="color4"><code class="literal">77A</code></span> は実行中であり、現在 <code class="literal">SELECT</code> を実行しています。
            </p></li><li class="listitem"><p>
              トランザクション <span class="color5"><code class="literal">E56</code></span> (<code class="literal">INSERT</code> を実行中) は、トランザクション <span class="color6"><code class="literal">E55</code></span> がコミットするのを待機しています。
            </p></li><li class="listitem"><p>
              トランザクション <span class="color6"><code class="literal">E55</code></span> (<code class="literal">INSERT</code> を実行中) は、トランザクション <span class="color7"><code class="literal">19C</code></span> がコミットするのを待機しています。
            </p></li><li class="listitem"><p>
              トランザクション <span class="color7"><code class="literal">19C</code></span> は実行中であり、現在 <code class="literal">INSERT</code> を実行しています。
            </p></li></ul></div><p>
          2 つのテーブル <code class="literal">INNODB_TRX.TRX_QUERY</code> と <code class="literal">PROCESSLIST.INFO</code> に示されているクエリー間に不整合が存在する可能性があることに注意してください。いずれかの特定のスレッドについて、そのスレッドの現在のトランザクション ID や、そのトランザクションで実行されているクエリーがこれらの 2 つのテーブルで異なる可能性があります。説明については、<a class="xref" href="innodb-storage-engine.html#innodb-information-schema-note_inconsistency" title="14.14.2.3.1 PROCESSLIST データとの不整合の可能性">セクション14.14.2.3.1「PROCESSLIST データとの不整合の可能性」</a>を参照してください。
        </p><p>
          次の表は、重い<a class="link" href="glossary.html#glos_workload" title="ワークロード">ワークロード</a>を実行しているシステム内の <code class="literal">INFORMATION_SCHEMA.PROCESSLIST</code> の内容を示しています。
        </p><div class="informaltable"><a name="innodb-information-schema-sample-processlist"></a><table summary=" 重いワークロード下での MySQL プロセスの内部動作を示す、INFORMATION_SCHEMA.PROCESSLIST テーブルからのサンプルデータ。" border="1"><colgroup><col><col><col><col><col><col><col><col></colgroup><thead><tr><th scope="col">ID</th><th scope="col">USER</th><th scope="col">HOST</th><th scope="col">DB</th><th scope="col">COMMAND</th><th scope="col">TIME</th><th scope="col">STATE</th><th scope="col">INFO</th></tr></thead><tbody><tr><td scope="row"><code class="literal">384</code></td><td><code class="literal">root</code></td><td><code class="literal">localhost</code></td><td><code class="literal">test</code></td><td><code class="literal">Query</code></td><td><code class="literal">10</code></td><td><code class="literal">update</code></td><td><code class="literal">insert into t2 values …</code></td></tr><tr><td scope="row"><code class="literal">257</code></td><td><code class="literal">root</code></td><td><code class="literal">localhost</code></td><td><code class="literal">test</code></td><td><code class="literal">Query</code></td><td><code class="literal">3</code></td><td><code class="literal">update</code></td><td><code class="literal">insert into t2 values …</code></td></tr><tr><td scope="row"><code class="literal">130</code></td><td><code class="literal">root</code></td><td><code class="literal">localhost</code></td><td><code class="literal">test</code></td><td><code class="literal">Query</code></td><td><code class="literal">0</code></td><td><code class="literal">update</code></td><td><code class="literal">insert into t2 values …</code></td></tr><tr><td scope="row"><code class="literal">61</code></td><td><code class="literal">root</code></td><td><code class="literal">localhost</code></td><td><code class="literal">test</code></td><td><code class="literal">Query</code></td><td><code class="literal">1</code></td><td><code class="literal">update</code></td><td><code class="literal">insert into t2 values …</code></td></tr><tr><td scope="row"><code class="literal">8</code></td><td><code class="literal">root</code></td><td><code class="literal">localhost</code></td><td><code class="literal">test</code></td><td><code class="literal">Query</code></td><td><code class="literal">1</code></td><td><code class="literal">update</code></td><td><code class="literal">insert into t2 values …</code></td></tr><tr><td scope="row"><code class="literal">4</code></td><td><code class="literal">root</code></td><td><code class="literal">localhost</code></td><td><code class="literal">test</code></td><td><code class="literal">Query</code></td><td><code class="literal">0</code></td><td><code class="literal">preparing</code></td><td><code class="literal">SELECT * FROM processlist</code></td></tr><tr><td scope="row"><code class="literal">2</code></td><td><code class="literal">root</code></td><td><code class="literal">localhost</code></td><td><code class="literal">test</code></td><td><code class="literal">Sleep</code></td><td><code class="literal">566</code></td><td><code class="literal"></code></td><td><code class="literal">NULL</code></td></tr></tbody></table></div><p>
          次の表は、重い<a class="link" href="glossary.html#glos_workload" title="ワークロード">ワークロード</a>を実行しているシステム内の <code class="literal">INFORMATION_SCHEMA.INNODB_TRX</code> の内容を示しています。
        </p><div class="informaltable"><a name="innodb-information-schema-sample-innodb_trx"></a><table summary=" 重いワークロード下での InnoDB トランザクションの内部動作を示す、INFORMATION_SCHEMA.INNODB_TRX テーブルからのサンプルデータ。" border="1"><colgroup><col><col><col><col><col><col><col><col></colgroup><thead><tr><th scope="col">trx id</th><th scope="col">trx state</th><th scope="col">trx started</th><th scope="col">trx requested lock id</th><th scope="col">trx wait started</th><th scope="col">trx weight</th><th scope="col">trx mysql thread id</th><th scope="col">trx query</th></tr></thead><tbody><tr><td scope="row"><span class="color0"><code class="literal">77F</code></span></td><td><code class="literal">LOCK WAIT</code></td><td><code class="literal">2008-01-15 13:10:16</code></td><td><span class="color0"><code class="literal">77F</code></span>:806</td><td><code class="literal">2008-01-15 13:10:16</code></td><td><code class="literal">1</code></td><td><code class="literal">876</code></td><td><code class="literal">insert into t09 (D, B, C) values …</code></td></tr><tr><td scope="row"><span class="color1"><code class="literal">77E</code></span></td><td><code class="literal">LOCK WAIT</code></td><td><code class="literal">2008-01-15 13:10:16</code></td><td><span class="color1"><code class="literal">77E</code></span>:806</td><td><code class="literal">2008-01-15 13:10:16</code></td><td><code class="literal">1</code></td><td><code class="literal">875</code></td><td><code class="literal">insert into t09 (D, B, C) values …</code></td></tr><tr><td scope="row"><span class="color2"><code class="literal">77D</code></span></td><td><code class="literal">LOCK WAIT</code></td><td><code class="literal">2008-01-15 13:10:16</code></td><td><span class="color2"><code class="literal">77D</code></span>:806</td><td><code class="literal">2008-01-15 13:10:16</code></td><td><code class="literal">1</code></td><td><code class="literal">874</code></td><td><code class="literal">insert into t09 (D, B, C) values …</code></td></tr><tr><td scope="row"><span class="color3"><code class="literal">77B</code></span></td><td><code class="literal">LOCK WAIT</code></td><td><code class="literal">2008-01-15 13:10:16</code></td><td><span class="color3"><code class="literal">77B</code></span>:733​:12:1</td><td><code class="literal">2008-01-15 13:10:16</code></td><td><code class="literal">4</code></td><td><code class="literal">873</code></td><td><code class="literal">insert into t09 (D, B, C) values …</code></td></tr><tr><td scope="row"><span class="color4"><code class="literal">77A</code></span></td><td><code class="literal">RUN­NING</code></td><td><code class="literal">2008-01-15 13:10:16</code></td><td><code class="literal">NULL</code></td><td><code class="literal">NULL</code></td><td><code class="literal">4</code></td><td><code class="literal">872</code></td><td><code class="literal">select b, c from t09 where …</code></td></tr><tr><td scope="row"><span class="color5"><code class="literal">E56</code></span></td><td><code class="literal">LOCK WAIT</code></td><td><code class="literal">2008-01-15 13:10:06</code></td><td><span class="color5"><code class="literal">E56</code></span>:743​:6:2</td><td><code class="literal">2008-01-15 13:10:06</code></td><td><code class="literal">5</code></td><td><code class="literal">384</code></td><td><code class="literal">insert into t2 values …</code></td></tr><tr><td scope="row"><span class="color6"><code class="literal">E55</code></span></td><td><code class="literal">LOCK WAIT</code></td><td><code class="literal">2008-01-15 13:10:06</code></td><td><span class="color6"><code class="literal">E55</code></span>:743​:38:2</td><td><code class="literal">2008-01-15 13:10:13</code></td><td><code class="literal">965</code></td><td><code class="literal">257</code></td><td><code class="literal">insert into t2 values …</code></td></tr><tr><td scope="row"><span class="color7"><code class="literal">19C</code></span></td><td><code class="literal">RUN­NING</code></td><td><code class="literal">2008-01-15 13:09:10</code></td><td><code class="literal">NULL</code></td><td><code class="literal">NULL</code></td><td><code class="literal">2900</code></td><td><code class="literal">130</code></td><td><code class="literal">insert into t2 values …</code></td></tr><tr><td scope="row"><span class="color8"><code class="literal">E15</code></span></td><td><code class="literal">RUN­NING</code></td><td><code class="literal">2008-01-15 13:08:59</code></td><td><code class="literal">NULL</code></td><td><code class="literal">NULL</code></td><td><code class="literal">5395</code></td><td><code class="literal">61</code></td><td><code class="literal">insert into t2 values …</code></td></tr><tr><td scope="row"><span class="color9"><code class="literal">51D</code></span></td><td><code class="literal">RUN­NING</code></td><td><code class="literal">2008-01-15 13:08:47</code></td><td><code class="literal">NULL</code></td><td><code class="literal">NULL</code></td><td><code class="literal">9807</code></td><td><code class="literal">8</code></td><td><code class="literal">insert into t2 values …</code></td></tr></tbody></table></div><p>
          次の表は、重い<a class="link" href="glossary.html#glos_workload" title="ワークロード">ワークロード</a>を実行しているシステム内の <code class="literal">INFORMATION_SCHEMA.INNODB_LOCK_WAITS</code> の内容を示しています。

          
        </p><div class="informaltable"><a name="innodb-information-schema-sample-innodb_lock_waits"></a><table summary=" 重いワークロード下での InnoDB ロックの内部動作を示す、INFORMATION_SCHEMA.INNODB_LOCK_WAITS テーブルからのサンプルデータ。" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th scope="col">requesting trx id</th><th scope="col">requested lock id</th><th scope="col">blocking trx id</th><th scope="col">blocking lock id</th></tr></thead><tbody><tr><td scope="row"><span class="color0"><code class="literal">77F</code></span></td><td><span class="color0"><code class="literal">77F</code></span>:806</td><td><span class="color1"><code class="literal">77E</code></span></td><td><span class="color1"><code class="literal">77E</code></span>:806</td></tr><tr><td scope="row"><span class="color0"><code class="literal">77F</code></span></td><td><span class="color0"><code class="literal">77F</code></span>:806</td><td><span class="color2"><code class="literal">77D</code></span></td><td><span class="color2"><code class="literal">77D</code></span>:806</td></tr><tr><td scope="row"><span class="color0"><code class="literal">77F</code></span></td><td><span class="color0"><code class="literal">77F</code></span>:806</td><td><span class="color3"><code class="literal">77B</code></span></td><td><span class="color3"><code class="literal">77B</code></span>:806</td></tr><tr><td scope="row"><span class="color1"><code class="literal">77E</code></span></td><td><span class="color1"><code class="literal">77E</code></span>:806</td><td><span class="color2"><code class="literal">77D</code></span></td><td><span class="color2"><code class="literal">77D</code></span>:806</td></tr><tr><td scope="row"><span class="color1"><code class="literal">77E</code></span></td><td><span class="color1"><code class="literal">77E</code></span>:806</td><td><span class="color3"><code class="literal">77B</code></span></td><td><span class="color3"><code class="literal">77B</code></span>:806</td></tr><tr><td scope="row"><span class="color2"><code class="literal">77D</code></span></td><td><span class="color2"><code class="literal">77D</code></span>:806</td><td><span class="color3"><code class="literal">77B</code></span></td><td><span class="color3"><code class="literal">77B</code></span>:806</td></tr><tr><td scope="row"><span class="color3"><code class="literal">77B</code></span></td><td><span class="color3"><code class="literal">77B</code></span>:733:12:1</td><td><span class="color4"><code class="literal">77A</code></span></td><td><span class="color4"><code class="literal">77A</code></span>:733:12:1</td></tr><tr><td scope="row"><span class="color5"><code class="literal">E56</code></span></td><td><span class="color5"><code class="literal">E56</code></span>:743:6:2</td><td><span class="color6"><code class="literal">E55</code></span></td><td><span class="color6"><code class="literal">E55</code></span>:743:6:2</td></tr><tr><td scope="row"><span class="color6"><code class="literal">E55</code></span></td><td><span class="color6"><code class="literal">E55</code></span>:743:38:2</td><td><span class="color7"><code class="literal">19C</code></span></td><td><span class="color7"><code class="literal">19C</code></span>:743:38:2</td></tr></tbody></table></div><p>
          次の表は、重い<a class="link" href="glossary.html#glos_workload" title="ワークロード">ワークロード</a>を実行しているシステム内の <code class="literal">INFORMATION_SCHEMA.INNODB_LOCKS</code> の内容を示しています。
        </p><div class="informaltable"><a name="innodb-information-schema-sample-innodb_locks"></a><table summary=" 重いワークロード下での InnoDB ロックの内部動作を示す、INFORMATION_SCHEMA.INNODB_LOCKS テーブルからのサンプルデータ。" border="1"><colgroup><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th scope="col">lock id</th><th scope="col">lock trx id</th><th scope="col">lock mode</th><th scope="col">lock type</th><th scope="col">lock table</th><th scope="col">lock index</th><th scope="col">lock space</th><th scope="col">lock page</th><th scope="col">lock rec</th><th scope="col">lock data</th></tr></thead><tbody><tr><td scope="row"><span class="color0"><code class="literal">77F</code></span>:806</td><td><span class="color0"><code class="literal">77F</code></span></td><td><code class="literal">AUTO​_INC</code></td><td><code class="literal">TABLE</code></td><td><code class="literal">`test`​.`t09`</code></td><td><code class="literal">NULL</code></td><td><code class="literal">NULL</code></td><td><code class="literal">NULL</code></td><td><code class="literal">NULL</code></td><td><code class="literal">NULL</code></td></tr><tr><td scope="row"><span class="color1"><code class="literal">77E</code></span>:806</td><td><span class="color1"><code class="literal">77E</code></span></td><td><code class="literal">AUTO​_INC</code></td><td><code class="literal">TABLE</code></td><td><code class="literal">`test`​.`t09`</code></td><td><code class="literal">NULL</code></td><td><code class="literal">NULL</code></td><td><code class="literal">NULL</code></td><td><code class="literal">NULL</code></td><td><code class="literal">NULL</code></td></tr><tr><td scope="row"><span class="color2"><code class="literal">77D</code></span>:806</td><td><span class="color2"><code class="literal">77D</code></span></td><td><code class="literal">AUTO​_INC</code></td><td><code class="literal">TABLE</code></td><td><code class="literal">`test`​.`t09`</code></td><td><code class="literal">NULL</code></td><td><code class="literal">NULL</code></td><td><code class="literal">NULL</code></td><td><code class="literal">NULL</code></td><td><code class="literal">NULL</code></td></tr><tr><td scope="row"><span class="color3"><code class="literal">77B</code></span>:806</td><td><span class="color3"><code class="literal">77B</code></span></td><td><code class="literal">AUTO​_INC</code></td><td><code class="literal">TABLE</code></td><td><code class="literal">`test`​.`t09`</code></td><td><code class="literal">NULL</code></td><td><code class="literal">NULL</code></td><td><code class="literal">NULL</code></td><td><code class="literal">NULL</code></td><td><code class="literal">NULL</code></td></tr><tr><td scope="row"><span class="color3"><code class="literal">77B</code></span>:733​:12:1</td><td><span class="color3"><code class="literal">77B</code></span></td><td><code class="literal">X</code></td><td><code class="literal">RECORD</code></td><td><code class="literal">`test`​.`t09`</code></td><td><code class="literal">`PRIMARY`</code></td><td><code class="literal">733</code></td><td><code class="literal">12</code></td><td><code class="literal">1</code></td><td><code class="literal">supremum pseudo-record</code></td></tr><tr><td scope="row"><span class="color4"><code class="literal">77A</code></span>:733​:12:1</td><td><span class="color4"><code class="literal">77A</code></span></td><td><code class="literal">X</code></td><td><code class="literal">RECORD</code></td><td><code class="literal">`test`​.`t09`</code></td><td><code class="literal">`PRIMARY`</code></td><td><code class="literal">733</code></td><td><code class="literal">12</code></td><td><code class="literal">1</code></td><td><code class="literal">supremum pseudo-record</code></td></tr><tr><td scope="row"><span class="color5"><code class="literal">E56</code></span>:743​:6:2</td><td><span class="color5"><code class="literal">E56</code></span></td><td><code class="literal">S</code></td><td><code class="literal">RECORD</code></td><td><code class="literal">`test`​.`t2`</code></td><td><code class="literal">`PRIMARY`</code></td><td><code class="literal">743</code></td><td><code class="literal">6</code></td><td><code class="literal">2</code></td><td><code class="literal">0, 0</code></td></tr><tr><td scope="row"><span class="color6"><code class="literal">E55</code></span>:743​:6:2</td><td><span class="color6"><code class="literal">E55</code></span></td><td><code class="literal">X</code></td><td><code class="literal">RECORD</code></td><td><code class="literal">`test`​.`t2`</code></td><td><code class="literal">`PRIMARY`</code></td><td><code class="literal">743</code></td><td><code class="literal">6</code></td><td><code class="literal">2</code></td><td><code class="literal">0, 0</code></td></tr><tr><td scope="row"><span class="color6"><code class="literal">E55</code></span>:743​:38:2</td><td><span class="color6"><code class="literal">E55</code></span></td><td><code class="literal">S</code></td><td><code class="literal">RECORD</code></td><td><code class="literal">`test`​.`t2`</code></td><td><code class="literal">`PRIMARY`</code></td><td><code class="literal">743</code></td><td><code class="literal">38</code></td><td><code class="literal">2</code></td><td><code class="literal">1922, 1922</code></td></tr><tr><td scope="row"><span class="color7"><code class="literal">19C</code></span>:743​:38:2</td><td><span class="color7"><code class="literal">19C</code></span></td><td><code class="literal">X</code></td><td><code class="literal">RECORD</code></td><td><code class="literal">`test`​.`t2`</code></td><td><code class="literal">`PRIMARY`</code></td><td><code class="literal">743</code></td><td><code class="literal">38</code></td><td><code class="literal">2</code></td><td><code class="literal">1922, 1922</code></td></tr></tbody></table></div></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-information-schema-understanding_innodb_locking"></a>14.14.2.2 INNODB_LOCKS と INNODB_LOCK_WAITS のデータ</h4></div></div></div><p>
        トランザクションがテーブル内の行を更新するか、または <code class="literal">SELECT FOR UPDATE</code> でロックする場合、<code class="literal">InnoDB</code> はその行に関するロックのリストまたはキューを確立します。同様に、テーブルレベルのロックの場合、<code class="literal">InnoDB</code> はテーブルに関するロックのリストを保持します。2 番目のトランザクションが、互換性がないモードにある以前のトランザクションによってすでにロックされている行の更新またはテーブルのロックを行おうとした場合、<code class="literal">InnoDB</code> はその行に対するロック要求を対応するキューに追加します。トランザクションによって取得されるロックの場合は、その行またはテーブルのロックキューに以前に入力された互換性のないロック要求をすべて削除する (これらのロックを保持または要求しているトランザクションがコミットまたはロールバックする) 必要があります。
      </p><p>
        トランザクションは、異なる行またはテーブルに対する任意の数のロック要求を保持できます。トランザクションはいつでも、別のトランザクションによって保持されているロックを要求できますが、そのロックは、その別のトランザクションによってブロックされます。要求しているトランザクションは、ブロックしているロックを保持するトランザクションがコミットまたはロールバックするのを待機する必要があります。ロックを待機していないトランザクションは、<code class="literal">'RUNNING'</code> 状態にあります。ロックを待機しているトランザクションは、<code class="literal">'LOCK WAIT'</code> 状態にあります。
      </p><p>
        <code class="literal">INNODB_LOCKS</code> テーブルは、<code class="literal">'LOCK WAIT'</code> トランザクションごとに、その続行を妨げているすべてのロック要求を示す 1 つ以上の行を保持しています。このテーブルにはまた、特定の行またはテーブルに対して保留されているロックのキュー内の各ロックを記述した 1 行も含まれています。<code class="literal">INNODB_LOCK_WAITS</code> テーブルは、ほかのトランザクションによって要求されたロックを、あるトランザクションによってすでに保持されているどのロックがブロックしているかを示します。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-information-schema-rapidly_changing_internal_data"></a>14.14.2.3 InnoDB トランザクションおよびロックテーブルのデータ永続性および一貫性</h4></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-information-schema-note_inconsistency">14.14.2.3.1 PROCESSLIST データとの不整合の可能性</a></span></dt></dl></div><p>
        トランザクションおよびロックテーブル (<code class="literal">INNODB_TRX</code>、<code class="literal">INNODB_LOCKS</code>、および <code class="literal">INNODB_LOCK_WAITS</code>) によって公開されるデータは、すばやく変更されるデータへの参照を表します。これは、アプリケーションで開始された更新が発生した場合にのみデータが変更されるほかの (ユーザー) テーブルとは異なります。ベースとなるデータはシステムで管理される内部データであり、非常にすばやく変更されることがあります。
      </p><p>
        パフォーマンス上の理由から、また <code class="literal">InnoDB</code> トランザクションとロック中の <code class="literal">INFORMATION_SCHEMA</code> テーブルの間の <code class="literal">JOIN</code> が誤って解釈される可能性を最小限に抑えるために、いずれかのテーブルに対して <code class="literal">SELECT</code> が発行されると常に、<code class="literal">InnoDB</code> は必要なトランザクションおよびロック情報を中間バッファーに収集します。このバッファーは、最後に読み取られてから 0.1 秒を超える時間が経過した場合にのみリフレッシュされます。3 つのテーブルを満たすために必要なデータは原子的に、かつ整合性を保ってフェッチされ、このグローバルな内部バッファー内に保存されて、ポイントインタイム<span class="quote">「<span class="quote">スナップショット</span>」</span>を形成します。複数のテーブルアクセスが 0.1 秒以内に発生した場合は (MySQL がこれらのテーブル間の結合を処理する場合は、ほぼ間違いなく発生します)、クエリーを満たすために同じスナップショットが使用されます。
      </p><p>
        これらのいずれかのテーブルを 1 つのクエリーにまとめる <code class="literal">JOIN</code> を実行した場合は、3 つのテーブルのデータが同じスナップショットから取得されるため、正しい結果が返されます。バッファーはこれらのテーブルのクエリーごとにはリフレッシュされないため、これらのテーブルに対して 10 分の 1 秒以内に個別のクエリーを発行した場合は、クエリーごとの結果が同じになります。これに対して、10 分の 1 秒を超える時間離れて発行された同じテーブルまたは異なるテーブルの 2 つの個別のクエリーでは、データが異なるスナップショットから取得されるため、異なる結果が表示される可能性があります。
      </p><p>
        トランザクションおよびロックデータが収集されている間 <code class="literal">InnoDB</code> は一時的に停止する必要があるため、これらのテーブルのクエリーを頻繁に実行しすぎると、ほかのユーザーから見たパフォーマンスに悪影響を与える場合があります。
      </p><p>
        これらのテーブルには機密情報 (少なくとも <code class="literal">INNODB_LOCKS.LOCK_DATA</code> および <code class="literal">INNODB_TRX.TRX_QUERY</code>) が含まれているため、セキュリティー上の理由から、そこからの <code class="literal">SELECT</code> を許可されるのは <code class="literal">PROCESS</code> 権限を持つユーザーだけです。
      </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="innodb-information-schema-note_inconsistency"></a>14.14.2.3.1 PROCESSLIST データとの不整合の可能性</h5></div></div></div><a class="indexterm" name="idm139979063020352"></a><p>
          <a class="xref" href="innodb-storage-engine.html#innodb-information-schema-rapidly_changing_internal_data" title="14.14.2.3 InnoDB トランザクションおよびロックテーブルのデータ永続性および一貫性">セクション14.14.2.3「InnoDB トランザクションおよびロックテーブルのデータ永続性および一貫性」</a>で説明されているように、<code class="literal">InnoDB</code> トランザクションおよびロックテーブル (<code class="literal">INNODB_TRX</code>、<code class="literal">INNODB_LOCKS</code>、および <code class="literal">INNODB_LOCK_WAITS</code>) を満たすデータは自動的にフェッチされ、<span class="quote">「<span class="quote">ポイントインタイム</span>」</span>スナップショットを提供する中間バッファーに保存されます。同じスナップショットからクエリーされた場合、データは 3 つのすべてのテーブルにわたって整合性があります。ただし、ベースとなるデータが非常にすばやく変更されるため、同様にすばやく変更されるほかのデータへの同様の参照が同期していない可能性があります。そのため、<code class="literal">InnoDB</code> トランザクションおよびロックテーブル内のデータを <code class="literal">PROCESSLIST</code> テーブル内のデータと比較する場合は注意してください。<code class="literal">PROCESSLIST</code> テーブルからのデータは、ロックおよびトランザクションに関するデータと同じスナップショットからは取得されません。1 つの <code class="literal">SELECT</code> (たとえば、<code class="literal">INNODB_TRX</code> と <code class="literal">PROCESSLIST</code> の結合) を発行した場合でも、一般に、これらのテーブルの内容には整合性がありません。<code class="literal">INNODB_TRX</code> が <code class="literal">PROCESSLIST</code> 内には存在しない行を参照したり、<code class="literal">INNODB_TRX.TRX_QUERY</code> に示されている、トランザクションの現在実行中の SQL クエリーが <code class="literal">PROCESSLIST.INFO</code> 内のものとは異なっていたりする可能性があります。
        </p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-information-schema-system-tables"></a>14.14.3 InnoDB INFORMATION_SCHEMA システムテーブル</h3></div></div></div><p>
      MySQL 5.6 の時点では、<code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code> システムテーブルを使用して、<code class="literal">InnoDB</code> によって管理されているスキーマオブジェクトに関するメタデータを抽出できます。この情報は、通常の <code class="literal">InnoDB</code> テーブルとは異なり直接クエリーできない <code class="literal">InnoDB</code> 内部システムテーブル (<code class="literal">InnoDB</code> データディクショナリとも呼ばれます) から取得されます。従来より、このタイプの情報は、<a class="xref" href="innodb-storage-engine.html#innodb-monitors" title="14.15 InnoDB モニター">セクション14.15「InnoDB モニター」</a>の手法を使用して、<code class="literal">InnoDB</code> モニターを設定し、<code class="literal">SHOW ENGINE INNODB STATUS</code> コマンドからの出力を解析することによって取得します。<code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code> テーブルのインタフェースを使用すると、SQL を使用してこのデータをクエリーできます。
    </p><p>
      対応する内部システムテーブルが存在しない <code class="literal">INNODB_SYS_TABLESTATS</code> を除き、<code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code> システムテーブルは、メモリー内にキャッシュされているメタデータからではなく、内部の <code class="literal">InnoDB</code> システムテーブルから直接読み取られたデータで移入されます。
    </p><p>
      <code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code> システムテーブルには、下に一覧表示されているテーブルが含まれます。<code class="literal">INNODB_SYS_DATAFILES</code> と <code class="literal">INNODB_SYS_TABLESPACES</code> は、<code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> テーブルスペース (<code class="literal">.ibd</code> ファイル) を MySQL データディレクトリ以外の場所に作成できるようにする、<code class="literal">CREATE TABLE</code> ステートメントの <code class="literal">DATA DIRECTORY='<em class="replaceable"><code>directory</code></em>'</code> 句に対するサポートの導入とともに MySQL 5.6.6 で追加されました。
    </p><pre class="programlisting">mysql&gt; SHOW TABLES FROM INFORMATION_SCHEMA LIKE 'INNODB_SYS%';
+--------------------------------------------+
| Tables_in_information_schema (INNODB_SYS%) |
+--------------------------------------------+
| INNODB_SYS_DATAFILES                       |
| INNODB_SYS_TABLESTATS                      |
| INNODB_SYS_FOREIGN                         |
| INNODB_SYS_COLUMNS                         |
| INNODB_SYS_INDEXES                         |
| INNODB_SYS_FIELDS                          |
| INNODB_SYS_TABLESPACES                     |
| INNODB_SYS_FOREIGN_COLS                    |
| INNODB_SYS_TABLES                          |
+--------------------------------------------+
9 rows in set (0.00 sec)</pre><p>
      これらのテーブル名は、提供されるデータのタイプを示しています。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">INNODB_SYS_TABLES</code> は、<code class="literal">InnoDB</code> データディクショナリの <code class="literal">SYS_TABLES</code> テーブル内の情報と同等の、<code class="literal">InnoDB</code> テーブルに関するメタデータを提供します。
        </p></li><li class="listitem"><p>
          <code class="literal">INNODB_SYS_COLUMNS</code> は、<code class="literal">InnoDB</code> データディクショナリの <code class="literal">SYS_COLUMNS</code> テーブル内の情報と同等の、<code class="literal">InnoDB</code> テーブルカラムに関するメタデータを提供します。
        </p></li><li class="listitem"><p>
          <code class="literal">INNODB_SYS_INDEXES</code> は、<code class="literal">InnoDB</code> データディクショナリの <code class="literal">SYS_INDEXES</code> テーブル内の情報と同等の、<code class="literal">InnoDB</code> インデックスに関するメタデータを提供します。
        </p></li><li class="listitem"><p>
          <code class="literal">INNODB_SYS_FIELDS</code> は、<code class="literal">InnoDB</code> データディクショナリの <code class="literal">SYS_FIELDS</code> テーブル内の情報と同等の、<code class="literal">InnoDB</code> インデックスのキーカラム (フィールド) に関するメタデータを提供します。
        </p></li><li class="listitem"><p>
          <code class="literal">INNODB_SYS_TABLESTATS</code> は、インメモリーデータ構造から取得された <code class="literal">InnoDB</code> テーブルに関する低レベルのステータス情報のビューを提供します。対応する内部 <code class="literal">InnoDB</code> システムテーブルはありません。
        </p></li><li class="listitem"><p>
          <code class="literal">INNODB_SYS_DATAFILES</code> は、<code class="literal">InnoDB</code> データディクショナリの <code class="literal">SYS_DATAFILES</code> テーブル内の情報と同等の、<code class="literal">InnoDB</code> テーブルスペースのデータファイルパス情報を提供します。
        </p></li><li class="listitem"><p>
          <code class="literal">INNODB_SYS_TABLESPACES</code> は、<code class="literal">InnoDB</code> データディクショナリの <code class="literal">SYS_TABLESPACES</code> テーブル内の情報と同等の、<code class="literal">InnoDB</code> テーブルスペースに関するメタデータを提供します。
        </p></li><li class="listitem"><p>
          <code class="literal">INNODB_SYS_FOREIGN</code> は、<code class="literal">InnoDB</code> データディクショナリの <code class="literal">SYS_FOREIGN</code> テーブル内の情報と同等の、<code class="literal">InnoDB</code> テーブルで定義された外部キーに関するメタデータを提供します。
        </p></li><li class="listitem"><p>
          <code class="literal">INNODB_SYS_FOREIGN_COLS</code> は、<code class="literal">InnoDB</code> データディクショナリの <code class="literal">SYS_FOREIGN_COLS</code> テーブル内の情報と同等の、<code class="literal">InnoDB</code> テーブルで定義された外部キーのカラムに関するメタデータを提供します。
        </p></li></ul></div><p>
      <code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code> システムテーブルを <code class="literal">TABLE_ID</code>、<code class="literal">INDEX_ID</code>、<code class="literal">SPACE</code> などのフィールドを通して結合することにより、調査またはモニターしたいオブジェクトの使用可能なすべてのデータを容易に取得できます。
    </p><p>
      各テーブルのカラムについては、<code class="literal">InnoDB</code> <a class="link" href="information-schema.html#innodb-i_s-tables" title="21.29 InnoDB の INFORMATION_SCHEMA テーブル">INFORMATION_SCHEMA</a> のドキュメントを参照してください。
    </p><div class="example"><a name="innodb-information-schema-system-tables-example"></a><p class="title"><b>例 14.13 InnoDB INFORMATION_SCHEMA システムテーブル</b></p><div class="example-contents"><p>
        この例では、単純なテーブル (<code class="literal">t1</code>) を 1 つのインデックス (<code class="literal">i1</code>) で使用して、<code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code> システムテーブル内に見つかったメタデータのタイプを示します。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            テストデータベースとテーブル <code class="literal">t1</code> を作成します。
          </p><pre class="programlisting">mysql&gt; CREATE DATABASE test;

mysql&gt; USE test;

mysql&gt; CREATE TABLE t1 (
col1 INT, 
col2 CHAR(10), 
col3 VARCHAR(10))
ENGINE = InnoDB;

mysql&gt; CREATE INDEX i1 ON t1(col1);</pre></li><li class="listitem"><p>
            テーブル <code class="literal">t1</code> を作成したあと、<code class="literal">INNODB_SYS_TABLES</code> をクエリーして <code class="literal">test/t1</code> のメタデータを見つけます。
          </p><pre class="programlisting">mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_TABLES WHERE NAME='test/t1' \G

*************************** 1. row ***************************
     TABLE_ID: 71
         NAME: test/t1
         FLAG: 1
       N_COLS: 6
        SPACE: 57
  FILE_FORMAT: Antelope
   ROW_FORMAT: Compact
ZIP_PAGE_SIZE: 0
10 rows in set (0.00 sec)</pre><p>
            テーブル <code class="literal">t1</code> の <code class="literal">TABLE_ID</code> は 71 です。<code class="literal">FLAG</code> フィールドは、テーブルの形式とストレージの特性に関するビットレベルの情報を提供します。6 つのカラムがあり、そのうちの 3 つが <code class="literal">InnoDB</code> によって作成された非表示のカラム (<code class="literal">DB_ROW_ID</code>、<code class="literal">DB_TRX_ID</code>、および <code class="literal">DB_ROLL_PTR</code>) です。このテーブルの <code class="literal">SPACE</code> の ID は 57 です (0 の値は、テーブルがシステムテーブルスペース内に存在することを示します)。<code class="literal">FILE_FORMAT</code> は Antelope であり、<code class="literal">ROW_FORMAT</code> は Compact です。<code class="literal">ZIP_PAGE_SIZE</code> は、<code class="literal">Compressed</code> 行フォーマットのテーブルにのみ適用されます。
          </p></li><li class="listitem"><p>
            <code class="literal">INNODB_SYS_TABLES</code> からの <code class="literal">TABLE_ID</code> 情報を使用して、このテーブルのカラムに関する情報を取得するために <code class="literal">INNODB_SYS_COLUMNS</code> テーブルをクエリーします。
          </p><pre class="programlisting">mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_COLUMNS where TABLE_ID = 71 \G 
*************************** 1. row ***************************
TABLE_ID: 71
    NAME: col1
     POS: 0
   MTYPE: 6
  PRTYPE: 1027
     LEN: 4
*************************** 2. row ***************************
TABLE_ID: 71
    NAME: col2
     POS: 1
   MTYPE: 2
  PRTYPE: 524542
     LEN: 10
*************************** 3. row ***************************
TABLE_ID: 71
    NAME: col3
     POS: 2
   MTYPE: 1
  PRTYPE: 524303
     LEN: 10
3 rows in set (0.00 sec)</pre><p>
            <code class="literal">INNODB_SYS_COLUMNS</code> は、<code class="literal">TABLE_ID</code> とカラム <code class="literal">NAME</code> に加えて、各カラムの序数位置 (<code class="literal">POS</code>) (0 から始まり順次に増分します)、カラム <code class="literal">MTYPE</code> または<span class="quote">「<span class="quote">メインの型</span>」</span> (6 = INT、2 = CHAR、1 = VARCHAR)、<code class="literal">PRTYPE</code> または<span class="quote">「<span class="quote">正確な型</span>」</span> (MySQL のデータ型、文字セットコード、および NULL 可能性を表すビットを含むバイナリ値)、およびカラムの長さ (<code class="literal">LEN</code>) を提供します。
          </p></li><li class="listitem"><p>
            ふたたび <code class="literal">INNODB_SYS_TABLES</code> からの <code class="literal">TABLE_ID</code> 情報を使用して、テーブル <code class="literal">t1</code> に関連付けられたインデックスに関する情報を取得するために <code class="literal">INNODB_SYS_INDEXES</code> をクエリーします。
          </p><pre class="programlisting">mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_INDEXES WHERE TABLE_ID = 71 \G
*************************** 1. row ***************************
INDEX_ID: 111
    NAME: GEN_CLUST_INDEX
TABLE_ID: 71
    TYPE: 1
N_FIELDS: 0
 PAGE_NO: 3
   SPACE: 57
*************************** 2. row ***************************
INDEX_ID: 112
    NAME: i1
TABLE_ID: 71
    TYPE: 0
N_FIELDS: 1
 PAGE_NO: 4
   SPACE: 57
2 rows in set (0.00 sec)</pre><p>
            <code class="literal">INNODB_SYS_INDEXES</code> は、2 つのインデックスのデータを返します。最初のインデックスは <code class="literal">GEN_CLUST_INDEX</code> です。これは、テーブルにユーザー定義のクラスタ化されたインデックスが存在しない場合に <code class="literal">InnoDB</code> によって作成されたクラスタ化されたインデックスです。2 番目のインデックス (<code class="literal">i1</code>) は、ユーザー定義のセカンダリインデックスです。
          </p><p>
            <code class="literal">INDEX_ID</code> は、インスタンス内のすべてのデータベースにわたって一意であるインデックスの識別子です。<code class="literal">TABLE_ID</code> は、そのインデックスが関連付けられているテーブルを識別します。インデックスの <code class="literal">TYPE</code> 値は、インデックスのタイプ (1 = クラスタ化されたインデックス、0 = セカンダリインデックス) を示します。<code class="literal">N_FILEDS</code> 値は、このインデックスを構成するフィールドの数です。<code class="literal">PAGE_NO</code> はインデックスの B ツリーのルートページ番号であり、<code class="literal">SPACE</code> はインデックスが存在するテーブルスペースの ID です。0 以外の値は、そのインデックスがシステムテーブルスペース内に存在しないことを示します。
          </p></li><li class="listitem"><p>
            <code class="literal">INNODB_SYS_INDEXES</code> からの <code class="literal">INDEX_ID</code> 情報を使用して、インデックス <code class="literal">i1</code> のフィールドに関する情報を取得するために <code class="literal">INNODB_SYS_FIELDS</code> をクエリーします。
          </p><pre class="programlisting">mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_FIELDS where INDEX_ID = 112 \G
*************************** 1. row ***************************
INDEX_ID: 112
    NAME: col1
     POS: 0
1 row in set (0.00 sec)</pre><p>
            <code class="literal">INNODB_SYS_FIELDS</code> は、インデックス付きフィールドの <code class="literal">NAME</code> と、インデックス内のその序数位置を提供します。インデックス (i1) が複数のフィールドで定義されている場合、<code class="literal">INNODB_SYS_FIELDS</code> は、各インデックス付きフィールドのメタデータを提供します。
          </p></li><li class="listitem"><p>
            <code class="literal">INNODB_SYS_TABLES</code> からの <code class="literal">SPACE</code> 情報を使用して、このテーブルのテーブルスペースに関する情報を取得するために <code class="literal">INNODB_SYS_TABLESPACES</code> テーブルをクエリーします。
          </p><pre class="programlisting">mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_TABLESPACES WHERE SPACE = 57 \G
*************************** 1. row ***************************
        SPACE: 57
         NAME: test/t1
         FLAG: 0
  FILE_FORMAT: Antelope
   ROW_FORMAT: Compact or Redundant
    PAGE_SIZE: 16384
ZIP_PAGE_SIZE: 0
1 row in set (0.00 sec)</pre><p>
            <code class="literal">INNODB_SYS_TABLESPACES</code> は、テーブルスペースの <code class="literal">SPACE</code> ID および関連付けられたテーブルの <code class="literal">NAME</code> に加えて、テーブルスペースの形式とストレージの特性に関するビットレベルの情報であるテーブルスペースの <code class="literal">FLAG</code> データを提供します。また、テーブルスペースの <code class="literal">FILE_FORMAT</code>、<code class="literal">ROW_FORMAT</code>、<code class="literal">PAGE_SIZE</code>、および <code class="literal">ZIP_PAGE_SIZE</code> データも提供されます (<code class="literal">ZIP_PAGE_SIZE</code> は、<code class="literal">Compressed</code> 行フォーマットのテーブルスペースに適用されます)。
          </p></li><li class="listitem"><p>
            ふたたび <code class="literal">INNODB_SYS_TABLES</code> からの <code class="literal">SPACE</code> 情報を使用して、このテーブルスペースのデータファイルの場所を取得するために <code class="literal">INNODB_SYS_DATAFILES</code> をクエリーします。
          </p><pre class="programlisting">mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_DATAFILES WHERE SPACE = 57 \G 
*************************** 1. row ***************************
SPACE: 57
 PATH: ./test/t1.ibd
1 row in set (0.01 sec)</pre><p>
            データファイルは、MySQL の <code class="literal">data</code> ディレクトリの下の <code class="literal">test</code> ディレクトリにあります。<a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> テーブルスペースが <code class="literal">CREATE TABLE</code> ステートメントの <code class="literal">DATA DIRECTORY</code> 句を使用して MySQL データディレクトリ以外の場所に作成された場合、テーブルスペースの <code class="literal">PATH</code> は完全修飾のディレクトリパスになります。
          </p></li><li class="listitem"><p>
            最後の手順として、テーブル <code class="literal">t1</code> (<code class="literal">TABLE_ID = 71</code>) に行を挿入し、<code class="literal">INNODB_SYS_TABLESTATS</code> テーブル内のデータを表示します。このテーブル内のデータは、<code class="literal">InnoDB</code> テーブルのクエリー時に使用するインデックスを決定するために MySQL オプティマイザによって使用されます。この情報は、インメモリーデータ構造から取得されます。対応する内部 <code class="literal">InnoDB</code> システムテーブルはありません。
          </p><pre class="programlisting">mysql&gt; INSERT INTO t1 VALUES(5, 'abc', 'def');
Query OK, 1 row affected (0.06 sec)

mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_TABLESTATS where TABLE_ID = 71 \G
*************************** 1. row ***************************
         TABLE_ID: 71
             NAME: test/t1
STATS_INITIALIZED: Initialized
         NUM_ROWS: 1
 CLUST_INDEX_SIZE: 1
 OTHER_INDEX_SIZE: 0
 MODIFIED_COUNTER: 1
          AUTOINC: 0
        REF_COUNT: 1
1 row in set (0.00 sec)</pre><p>
            <code class="literal">STATS_INITIALIZED</code> フィールドは、このテーブルの統計が収集されているかどうかを示します。<code class="literal">NUM_ROWS</code> は、現在の推定されるテーブル内の行数です。<code class="literal">CLUST_INDEX_SIZE</code> および <code class="literal">OTHER_INDEX_SIZE</code> フィールドはそれぞれ、テーブルのクラスタ化されたインデックスとセカンダリインデックスを格納するディスク上のページの数をレポートします。<code class="literal">MODIFIED_COUNTER</code> 値は、外部キーからの DML 操作およびカスケード操作によって変更された行数を示します。<code class="literal">AUTOINC</code> 値は、自動インクリメントベースの操作に対して発行される次の番号です。テーブル <code class="literal">t1</code> では自動インクリメントカラムが定義されていないため、この値は 0 です。<code class="literal">REF_COUNT</code> 値はカウンタです。このカウンタが 0 に達すると、テーブルキャッシュからテーブルメタデータを削除できることを示します。
          </p></li></ol></div></div></div><br class="example-break"><div class="example"><a name="innodb-information-schema-fk-system-tables-example"></a><p class="title"><b>例 14.14 外部キーの INFORMATION_SCHEMA システムテーブル</b></p><div class="example-contents"><p>
        <code class="literal">INNODB_SYS_FOREIGN</code> および <code class="literal">INNODB_SYS_FOREIGN_COLS</code> テーブルは、外部キー関係に関するデータを提供します。この例では、外部キー関係を持つ親テーブルと子テーブルを使用して、<code class="literal">INNODB_SYS_FOREIGN</code> および <code class="literal">INNODB_SYS_FOREIGN_COLS</code> テーブル内に見つかったデータを示します。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            テストデータベースおよび親テーブルと子テーブルを作成します。
          </p><pre class="programlisting">mysql&gt; CREATE DATABASE test;

mysql&gt; USE test;

mysql&gt; CREATE TABLE parent (id INT NOT NULL,
    -&gt; PRIMARY KEY (id)) ENGINE=INNODB;

mysql&gt; CREATE TABLE child (id INT, parent_id INT,
    -&gt; INDEX par_ind (parent_id),
    -&gt; CONSTRAINT fk1
    -&gt; FOREIGN KEY (parent_id) REFERENCES parent(id)
    -&gt; ON DELETE CASCADE) ENGINE=INNODB;</pre></li><li class="listitem"><p>
            親テーブルと子テーブルが作成されたら、<code class="literal">INNODB_SYS_FOREIGN</code> をクエリーして、<code class="literal">test/child</code> と <code class="literal">test/parent</code> の外部キー関係の外部キーデータを見つけます。
          </p><pre class="programlisting">mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_FOREIGN \G
*************************** 1. row ***************************
      ID: test/fk1
FOR_NAME: test/child
REF_NAME: test/parent
  N_COLS: 1
    TYPE: 1
1 row in set (0.00 sec)</pre><p>
            メタデータには、子テーブルで定義された <code class="literal">CONSTRAINT</code> として指定されている外部キー <code class="literal">ID</code> (<code class="literal">fk1</code>) が含まれています。<code class="literal">FOR_NAME</code> は、外部キーが定義されている子テーブルの名前です。<code class="literal">REF_NAME</code> は、親テーブル (<span class="quote">「<span class="quote">参照される</span>」</span>テーブル) の名前です。<code class="literal">N_COLS</code> は、外部キーのインデックス内のカラム数です。<code class="literal">TYPE</code> は、外部キーカラムに関する追加情報を提供するビットフラグを表す数値です。この場合、<code class="literal">TYPE</code> 値は 1 です。これは、外部キーに対して <code class="literal">ON DELETE CASCADE</code> オプションが指定されたことを示します。<code class="literal">TYPE</code> 値の詳細は、<code class="literal">INNODB_SYS_FOREIGN</code> テーブルの定義を参照してください。
          </p></li><li class="listitem"><p>
            外部キー <code class="literal">ID</code> を使用して、この外部キーのカラムに関するデータを表示するために <code class="literal">INNODB_SYS_FOREIGN_COLS</code> をクエリーします。
          </p><pre class="programlisting">mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_FOREIGN_COLS WHERE ID = 'test/fk1' \G
*************************** 1. row ***************************
          ID: test/fk1
FOR_COL_NAME: parent_id
REF_COL_NAME: id
         POS: 0
1 row in set (0.00 sec)</pre><p>
            <code class="literal">FOR_COL_NAME</code> は子テーブル内の外部キーカラムの名前であり、<code class="literal">REF_COL_NAME</code> は親テーブル内の参照されるカラムの名前です。<code class="literal">POS</code> 値は、外部キーのインデックス内のキーフィールドの序数位置です (0 から始まります)。
          </p></li></ol></div></div></div><br class="example-break"><div class="example"><a name="innodb-information-schema-system-tables-join-example"></a><p class="title"><b>例 14.15 InnoDB INFORMATION_SCHEMA システムテーブルの結合</b></p><div class="example-contents"><p>
        この例では、employees サンプルデータベース内のテーブルに関するファイル形式、行フォーマット、ページサイズ、およびインデックスサイズ情報を収集するために 3 つの <code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code> システムテーブル (<code class="literal">INNODB_SYS_TABLES</code>、<code class="literal">INNODB_SYS_TABLESPACES</code>、および <code class="literal">INNODB_SYS_TABLESTATS</code>) を結合する方法を示します。
      </p><p>
        クエリー文字列を短くするために、次のテーブル名のエイリアスが使用されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">INFORMATION_SCHEMA.INNODB_SYS_TABLES</code>: a
          </p></li><li class="listitem"><p>
            <code class="literal">INFORMATION_SCHEMA.INNODB_SYS_TABLESPACES</code>: b
          </p></li><li class="listitem"><p>
            <code class="literal">INFORMATION_SCHEMA.INNODB_SYS_TABLESTATS</code>: c
          </p></li></ul></div><p>
        圧縮テーブルに対応するために、<code class="literal">IF()</code> 制御フロー関数が使用されています。テーブルが圧縮されている場合、インデックスサイズは <code class="literal">PAGE_SIZE</code> ではなく、<code class="literal">ZIP_PAGE_SIZE</code> を使用して計算されます。バイト単位でレポートされる <code class="literal">CLUST_INDEX_SIZE</code> および <code class="literal">OTHER_INDEX_SIZE</code> を <code class="literal">1024*1024</code> で割ると、M バイト (MB) 単位のインデックスサイズが得られます。MB 値は、<code class="literal">ROUND()</code> 関数を使用して小数点以下 0 桁に丸められます。
      </p><pre class="programlisting">mysql&gt; SELECT a.NAME, a.FILE_FORMAT, a.ROW_FORMAT,
 @page_size :=
  IF(a.ROW_FORMAT='Compressed',
   b.ZIP_PAGE_SIZE, b.PAGE_SIZE)
   AS page_size,
  ROUND((@page_size * c.CLUST_INDEX_SIZE)
   /(1024*1024)) AS pk_mb,
  ROUND((@page_size * c.OTHER_INDEX_SIZE)
   /(1024*1024)) AS secidx_mb
FROM INFORMATION_SCHEMA.INNODB_SYS_TABLES a
INNER JOIN INFORMATION_SCHEMA.INNODB_SYS_TABLESPACES b on a.NAME = b.NAME
INNER JOIN INFORMATION_SCHEMA.INNODB_SYS_TABLESTATS c on b.NAME = c.NAME 
WHERE a.NAME LIKE 'employees/%'
ORDER BY a.NAME DESC;
+------------------------+-------------+------------+-----------+-------+-----------+
| NAME                   | FILE_FORMAT | ROW_FORMAT | page_size | pk_mb | secidx_mb |
+------------------------+-------------+------------+-----------+-------+-----------+
| employees/titles       | Antelope    | Compact    |     16384 |    20 |        11 |
| employees/salaries     | Antelope    | Compact    |     16384 |    91 |        33 |
| employees/employees    | Antelope    | Compact    |     16384 |    15 |         0 |
| employees/dept_manager | Antelope    | Compact    |     16384 |     0 |         0 |
| employees/dept_emp     | Antelope    | Compact    |     16384 |    12 |        10 |
| employees/departments  | Antelope    | Compact    |     16384 |     0 |         0 |
+------------------------+-------------+------------+-----------+-------+-----------+
6 rows in set (0.01 sec)</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-information-schema-fulltext_index-tables"></a>14.14.4 InnoDB INFORMATION_SCHEMA FULLTEXT インデックステーブル</h3></div></div></div><p>
      MySQL 5.6.4 での <code class="literal">InnoDB</code> テーブルに対する <code class="literal">FULLTEXT</code> インデックスサポートの導入により、<code class="literal">INFORMATION_SCHEMA</code> データベースに次のテーブルが追加されました。
    </p><pre class="programlisting">mysql&gt; SHOW TABLES FROM INFORMATION_SCHEMA LIKE 'INNODB_FT%';
+-------------------------------------------+
| Tables_in_INFORMATION_SCHEMA (INNODB_FT%) |
+-------------------------------------------+
| INNODB_FT_CONFIG                          |
| INNODB_FT_BEING_DELETED                   |
| INNODB_FT_DELETED                         |
| INNODB_FT_DEFAULT_STOPWORD                |
| INNODB_FT_INDEX_TABLE                     |
| INNODB_FT_INDEX_CACHE                     |
+-------------------------------------------+
6 rows in set (0.00 sec)</pre><h4><a name="idm139979062770112"></a>テーブルの概要</h4><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">INNODB_FT_CONFIG</code>: <code class="literal">FULLTEXT</code> インデックスに関するメタデータと、<code class="literal">InnoDB</code> テーブルに対するそれに関連する処理を表示します。
        </p></li><li class="listitem"><p>
          <code class="literal">INNODB_FT_BEING_DELETED</code>: <code class="literal">OPTIMIZE TABLE</code> の保守操作中にのみ使用される <code class="literal">INNODB_FT_DELETED</code> テーブルのスナップショットを提供します。<code class="literal">OPTIMIZE TABLE</code> が実行されると、<code class="literal">INNODB_FT_BEING_DELETED</code> テーブルは空になり、<code class="literal">INNODB_FT_DELETED</code> テーブルから DOC_ID が削除されます。<code class="literal">INNODB_FT_BEING_DELETED</code> の内容は一般に有効期間が短いため、モニタリングやデバッグでのこのテーブルの有用性は限られます。<code class="literal">FULLTEXT</code> インデックスを持つテーブルでの <code class="literal">OPTIMIZE TABLE</code> の実行の詳細は、<a class="xref" href="functions.html#fulltext-fine-tuning" title="12.9.6 MySQL の全文検索の微調整">セクション12.9.6「MySQL の全文検索の微調整」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">INNODB_FT_DELETED</code>: <code class="literal">InnoDB</code> テーブルの <code class="literal">FULLTEXT</code> インデックスから削除された行を記録します。<code class="literal">InnoDB</code> <code class="literal">FULLTEXT</code> インデックスに対する DML 操作中にコストの高いインデックス再編成が行われないようにするために、新しく削除された単語に関する情報は個別に格納され、テキスト検索を実行すると検索結果からフィルタで除外され、<code class="literal">OPTIMIZE TABLE</code> テーブルを実行したときにのみメインの検索インデックスから削除されます。
        </p></li><li class="listitem"><p>
          <code class="literal">INNODB_FT_DEFAULT_STOPWORD</code>: <code class="literal">FULLTEXT</code> インデックスを作成するときにデフォルトで使用される<a class="link" href="glossary.html#glos_stopword" title="ストップワード">ストップワード</a>のリストを保持します。
        </p><p>
          <code class="literal">INNODB_FT_DEFAULT_STOPWORD</code> テーブルについては、<a class="xref" href="functions.html#fulltext-stopwords" title="12.9.4 全文ストップワード">セクション12.9.4「全文ストップワード」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">INNODB_FT_INDEX_TABLE</code>: <code class="literal">FULLTEXT</code> インデックスに対するテキスト検索を処理するために使用される逆インデックスに関するデータが含まれています。
        </p></li><li class="listitem"><p>
          <code class="literal">INNODB_FT_INDEX_CACHE</code>: <code class="literal">FULLTEXT</code> インデックス内の新しく挿入された行に関するトークン情報が含まれています。DML 操作中の負荷の大きなインデックスの再編成を避けるために、新しくインデックスが付けられた単語に関する情報は個別に格納され、<code class="literal">OPTIMIZE TABLE</code> の実行時、サーバーのシャットダウン時、またはキャッシュサイズが <code class="literal">innodb_ft_cache_size</code> や <code class="literal">innodb_ft_total_cache_size</code> で定義された制限を超えたときにのみ、メインの検索インデックスと組み合わされます。
        </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">INNODB_FT_DEFAULT_STOPWORD</code> テーブルを除き、<code class="literal">innodb_ft_aux_table</code> 構成変数を <code class="literal">FULLTEXT</code> インデックスを含むテーブルの名前 (<em class="replaceable"><code>database_name</code></em>/<em class="replaceable"><code>table_name</code></em>) に設定する必要があります。そうしないと、<code class="literal">InnoDB</code> <code class="literal">FULLTEXT</code> インデックスの <code class="literal">INFORMATION_SCHEMA</code> テーブルが空で表示されます。
      </p></div><div class="example"><a name="innodb-information-schema-fulltext-tables-example"></a><p class="title"><b>例 14.16 InnoDB FULLTEXT インデックスの INFORMATION_SCHEMA テーブル</b></p><div class="example-contents"><p>
        この例では、<code class="literal">FULLTEXT</code> インデックスを含むテーブルを使用して、<code class="literal">FULLTEXT</code> インデックスの <code class="literal">INFORMATION_SCHEMA</code> テーブルに含まれているデータを示します。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            <code class="literal">FULLTEXT</code> インデックスを含むテーブルを作成し、一部のデータを挿入します。
          </p><pre class="programlisting">mysql&gt; CREATE TABLE articles (
      id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,
      title VARCHAR(200),
      body TEXT,
      FULLTEXT (title,body)
     ) ENGINE=InnoDB;

INSERT INTO articles (title,body) VALUES
    ('MySQL Tutorial','DBMS stands for DataBase ...'),
    ('How To Use MySQL Well','After you went through a ...'),
    ('Optimizing MySQL','In this tutorial we will show ...'),
    ('1001 MySQL Tricks','1. Never run mysqld as root. 2. ...'),
    ('MySQL vs. YourSQL','In the following database comparison ...'),
    ('MySQL Security','When configured properly, MySQL ...');</pre></li><li class="listitem"><p>
            <code class="literal">innodb_ft_aux_table</code> 変数を <code class="literal">FULLTEXT</code> インデックスを含むテーブルの名前に設定します。<code class="literal">INNODB_FT_DEFAULT_STOPWORD</code> テーブルを除き、この変数が設定されていないと <code class="literal">InnoDB</code> <code class="literal">FULLTEXT</code> <code class="literal">INFORMATION_SCHEMA</code> テーブルが空で表示されます。
          </p><pre class="programlisting">SET GLOBAL innodb_ft_aux_table = 'test/articles';</pre></li><li class="listitem"><p>
            <code class="literal">INNODB_FT_INDEX_CACHE</code> テーブルをクエリーします。これにより、<code class="literal">FULLTEXT</code> インデックス内の新しく挿入された行に関する情報が示されます。DML 操作中にコストの高いインデックス再編成が行われないようにするために、新しく挿入された行のデータは、<code class="literal">OPTIMIZE TABLE</code> が実行されるまで (あるいは、サーバーがシャットダウンされるか、またはキャッシュの制限を超えるまで) <code class="literal">FULLTEXT</code> インデックスキャッシュ内に残ります。
          </p><pre class="programlisting">mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_FT_INDEX_CACHE LIMIT 5;
+------------+--------------+-------------+-----------+--------+----------+
| WORD       | FIRST_DOC_ID | LAST_DOC_ID | DOC_COUNT | DOC_ID | POSITION |
+------------+--------------+-------------+-----------+--------+----------+
| 1001       |            5 |           5 |         1 |      5 |        0 |
| after      |            3 |           3 |         1 |      3 |       22 |
| comparison |            6 |           6 |         1 |      6 |       44 |
| configured |            7 |           7 |         1 |      7 |       20 |
| database   |            2 |           6 |         2 |      2 |       31 |
+------------+--------------+-------------+-----------+--------+----------+
5 rows in set (0.00 sec)
</pre></li><li class="listitem"><p>
            <code class="literal">innodb_optimize_fulltext_only</code> を有効にし、<code class="literal">FULLTEXT</code> インデックスを含むテーブルに対して <code class="literal">OPTIMIZE TABLE</code> を実行します。この操作により、<code class="literal">FULLTEXT</code> インデックスキャッシュの内容がメインの <code class="literal">FULLTEXT</code> インデックスにフラッシュされます。<code class="literal">innodb_optimize_fulltext_only</code> は、<code class="literal">InnoDB</code> テーブルでの <code class="literal">OPTIMIZE TABLE</code> ステートメントの動作方法を変更するものであり、<code class="literal">FULLTEXT</code> インデックスを含む <code class="literal">InnoDB</code> テーブルでの保守操作中に一時的に有効にすることを目的にしています。
          </p><pre class="programlisting">mysql&gt; SET GLOBAL innodb_optimize_fulltext_only=ON;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; OPTIMIZE TABLE articles;
+---------------+----------+----------+----------+
| Table         | Op       | Msg_type | Msg_text |
+---------------+----------+----------+----------+
| test.articles | optimize | status   | OK       |
+---------------+----------+----------+----------+
1 row in set (0.03 sec)</pre></li><li class="listitem"><p>
            <code class="literal">INNODB_FT_INDEX_TABLE</code> テーブルにクエリーして、メインの <code class="literal">FULLTEXT</code> インデックス内のデータに関する情報 (<code class="literal">FULLTEXT</code> インデックスキャッシュからフラッシュされたばかりのデータに関する情報を含む) を表示します。
          </p><pre class="programlisting">mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_FT_INDEX_TABLE LIMIT 5;
+------------+--------------+-------------+-----------+--------+----------+
| WORD       | FIRST_DOC_ID | LAST_DOC_ID | DOC_COUNT | DOC_ID | POSITION |
+------------+--------------+-------------+-----------+--------+----------+
| 1001       |            5 |           5 |         1 |      5 |        0 |
| after      |            3 |           3 |         1 |      3 |       22 |
| comparison |            6 |           6 |         1 |      6 |       44 |
| configured |            7 |           7 |         1 |      7 |       20 |
| database   |            2 |           6 |         2 |      2 |       31 |
+------------+--------------+-------------+-----------+--------+----------+
5 rows in set (0.00 sec)</pre><p>
            <code class="literal">OPTIMIZE TABLE</code> 操作によって <code class="literal">FULLTEXT</code> インデックスキャッシュがフラッシュされたため、<code class="literal">INNODB_FT_INDEX_CACHE</code> テーブルは空になっています。
          </p><pre class="programlisting">mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_FT_INDEX_CACHE LIMIT 5;
Empty set (0.00 sec)</pre></li><li class="listitem"><p>
            <code class="literal">test/articles</code> テーブルからいくつかのレコードを削除します。
          </p><pre class="programlisting">mysql&gt; DELETE FROM test.articles WHERE id &lt; 4;
Query OK, 3 rows affected (0.11 sec)</pre></li><li class="listitem"><p>
            <code class="literal">INNODB_FT_DELETED</code> テーブルをクエリーします。このテーブルには、<code class="literal">FULLTEXT</code> インデックスから削除された行が記録されます。DML 操作中にコストの高いインデックス再編成が行われないようにするために、新しく削除されたレコードに関する情報は個別に格納され、テキスト検索を実行すると検索結果からフィルタで除外され、<code class="literal">OPTIMIZE TABLE</code> を実行するとメインの検索インデックスから削除されます。
          </p><pre class="programlisting">mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_FT_DELETED;
+--------+
| DOC_ID |
+--------+
|      2 |
|      3 |
|      4 |
+--------+
3 rows in set (0.00 sec)</pre></li><li class="listitem"><p>
            <code class="literal">OPTIMIZE TABLE</code> を実行して、削除されたレコードを消去します。
          </p><pre class="programlisting">mysql&gt; OPTIMIZE TABLE articles;
+---------------+----------+----------+----------+
| Table         | Op       | Msg_type | Msg_text |
+---------------+----------+----------+----------+
| test.articles | optimize | status   | OK       |
+---------------+----------+----------+----------+
1 row in set (0.10 sec)</pre><p>
            <code class="literal">INNODB_FT_DELETED</code> テーブルが空で表示されるようになります。
          </p><pre class="programlisting">mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_FT_DELETED;
Empty set (0.00 sec)</pre></li><li class="listitem"><p>
            <code class="literal">INNODB_FT_CONFIG</code> テーブルをクエリーします。このテーブルには、<code class="literal">FULLTEXT</code> インデックスに関するメタデータとそれに関連する処理が含まれています。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <code class="literal">optimize_checkpoint_limit</code> は、<code class="literal">OPTIMIZE TABLE</code> の実行が停止するまでの秒数です。
              </p></li><li class="listitem"><p>
                <code class="literal">synced_doc_id</code> は、発行される次の <code class="literal">DOC_ID</code> です。
              </p></li><li class="listitem"><p>
                <code class="literal">stopword_table_name</code> は、ユーザー定義のストップワードテーブルに対する <em class="replaceable"><code>database/table</code></em> の名前です。ユーザー定義のストップワードテーブルがない場合、このフィールドは空です。
              </p></li><li class="listitem"><p>
                <code class="literal">use_stopword</code> は、ストップワードテーブルを使用するかどうかを示します。これは、<code class="literal">FULLTEXT</code> インデックスの作成時に定義されます。
              </p></li></ul></div><pre class="programlisting">mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_FT_CONFIG;
+---------------------------+-------+
| KEY                       | VALUE |
+---------------------------+-------+
| optimize_checkpoint_limit | 180   |
| synced_doc_id             | 8     |
| stopword_table_name       |       |
| use_stopword              | 1     |
+---------------------------+-------+
4 rows in set (0.00 sec)</pre></li></ol></div></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-information-schema-buffer-pool-tables"></a>14.14.5 InnoDB INFORMATION_SCHEMA バッファープールテーブル</h3></div></div></div><p>
      <code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code> バッファープールテーブルは、バッファープールのステータス情報、および <code class="literal">InnoDB</code> バッファープール内のページに関するメタデータを提供します。これらのテーブルは MySQL 5.6.2、で導入され、あとで MySQL 5.5 (MySQL 5.5.28) および MySQL 5.1 (MySQL 5.1.66) にバックポートされました。
    </p><p>
      <code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code> バッファープールテーブルには、下に一覧表示されているものが含まれます。
    </p><pre class="programlisting">mysql&gt; SHOW TABLES FROM INFORMATION_SCHEMA LIKE 'INNODB_BUFFER%';
+-----------------------------------------------+
| Tables_in_INFORMATION_SCHEMA (INNODB_BUFFER%) |
+-----------------------------------------------+
| INNODB_BUFFER_PAGE_LRU                        |
| INNODB_BUFFER_PAGE                            |
| INNODB_BUFFER_POOL_STATS                      |
+-----------------------------------------------+
3 rows in set (0.00 sec)</pre><h4><a name="idm139979062646864"></a>テーブルの概要</h4><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">INNODB_BUFFER_PAGE</code>: <code class="literal">InnoDB</code> バッファープール内の各ページに関する情報を保持します。
        </p></li><li class="listitem"><p>
          <code class="literal">INNODB_BUFFER_PAGE_LRU</code>: <code class="literal">InnoDB</code> バッファープール内のページに関する情報、特に、いっぱいになったときにバッファープールからどのページを削除するかを決定する LRU リスト内の各ページの順序を保持します。<code class="literal">INNODB_BUFFER_PAGE_LRU</code> テーブルには、<code class="literal">INNODB_BUFFER_PAGE</code> テーブルと同じカラムがありますが、<code class="literal">INNODB_BUFFER_PAGE_LRU</code> テーブルには <code class="literal">BLOCK_ID</code> カラムではなく <code class="literal">LRU_POSITION</code> カラムがある点が異なります。
        </p></li><li class="listitem"><p>
          <code class="literal">INNODB_BUFFER_POOL_STATS</code>: バッファープールのステータス情報を提供します。同じ情報のほとんどは、<code class="literal">SHOW ENGINE INNODB STATUS</code> の出力で提供されるか、または <code class="literal">InnoDB</code> バッファープールのサーバーステータス変数を使用して取得できます。
        </p></li></ul></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
        <code class="literal">INNODB_BUFFER_PAGE</code> テーブルまたは <code class="literal">INNODB_BUFFER_PAGE_LRU</code> テーブルのクエリーによって、大幅なパフォーマンスオーバーヘッドが導入される場合があります。クエリーによって発生する可能性のあるパフォーマンスへの影響を認識し、かつそれが許容可能であると判断していないかぎり、これらのテーブルを本番システムではクエリーしないでください。パフォーマンスへの影響を回避するために、調査しようとしている問題をテストインスタンスで再現し、テストインスタンスでクエリーを実行してください。
      </p></div><div class="example"><a name="innodb-information-schema-buffer-pool-system-data-example"></a><p class="title"><b>例 14.17 INNODB_BUFFER_PAGE テーブル内のシステムデータのクエリー</b></p><div class="example-contents"><p>
        このクエリーは、<code class="literal">TABLE_NAME</code> 値が <code class="literal">NULL</code> であるか、あるいはそのテーブル名にスラッシュ<span class="quote">「<span class="quote"><code class="literal">/</code></span>」</span>またはピリオド<span class="quote">「<span class="quote"><code class="literal">.</code></span>」</span>を含む (これはユーザー定義のテーブルを示します) ページを除外することによって、システムデータを含むページの概数を提供します。
      </p><pre class="programlisting">SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE 
WHERE TABLE_NAME IS NULL OR (INSTR(TABLE_NAME, '/') = 0 AND INSTR(TABLE_NAME, '.') = 0);
+----------+
| COUNT(*) |
+----------+
|     1320 |
+----------+
1 row in set (0.12 sec)</pre><p>
        このクエリーは、システムデータを含むページの概数、バッファープールページの総数、およびシステムデータを含むページの概略の割合 (%) を返します。
      </p><pre class="programlisting">SELECT  
(SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE 
WHERE TABLE_NAME IS NULL OR (INSTR(TABLE_NAME, '/') = 0 AND INSTR(TABLE_NAME, '.') = 0)
) AS system_pages,
(
SELECT COUNT(*)
FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE
) AS total_pages,
(
SELECT ROUND((system_pages/total_pages) * 100)
) AS system_page_percentage;
+--------------+-------------+------------------------+
| system_pages | total_pages | system_page_percentage |
+--------------+-------------+------------------------+
|         1320 |        8192 |                     16 |
+--------------+-------------+------------------------+
1 row in set (0.15 sec)</pre><p>
        バッファープール内のシステムデータのタイプは、<code class="literal">PAGE_TYPE</code> 値をクエリーすることによって確認できます。たとえば、次のクエリーは、システムデータを含むページ間の 8 つの個別の <code class="literal">PAGE_TYPE</code> 値を返します。
      </p><pre class="programlisting">mysql&gt; SELECT DISTINCT PAGE_TYPE FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE 
WHERE TABLE_NAME IS NULL OR (INSTR(TABLE_NAME, '/') = 0 AND INSTR(TABLE_NAME, '.') = 0);
+-------------------+
| PAGE_TYPE         |
+-------------------+
| SYSTEM            |
| IBUF_BITMAP       |
| UNDO_LOG          |
| UNKNOWN           |
| FILE_SPACE_HEADER |
| INODE             |
| ALLOCATED         |
| TRX_SYSTEM        |
+-------------------+
8 rows in set (0.05 sec)</pre></div></div><br class="example-break"><div class="example"><a name="innodb-information-schema-buffer-pool-user-data-example"></a><p class="title"><b>例 14.18 INNODB_BUFFER_PAGE テーブル内のユーザーデータのクエリー</b></p><div class="example-contents"><p>
        このクエリーは、<code class="literal">TABLE_NAME</code> 値が <code class="literal">NOT NULL</code> および <code class="literal">NOT LIKE '%INNODB_SYS_TABLES%'</code> であるページをカウントすることによって、ユーザーデータを含むページの概数を提供します。
      </p><pre class="programlisting">mysql&gt; SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE 
WHERE TABLE_NAME IS NOT NULL AND TABLE_NAME NOT LIKE '%INNODB_SYS_TABLES%';
+----------+
| COUNT(*) |
+----------+
|     6872 |
+----------+
1 row in set (0.06 sec)</pre><p>
        このクエリーは、ユーザーデータを含むページの概数、バッファープールページの総数、およびユーザーデータを含むページの概略の割合 (%) を返します。
      </p><pre class="programlisting">mysql&gt; SELECT  
(SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE 
WHERE TABLE_NAME IS NOT NULL AND (INSTR(TABLE_NAME, '/') &gt; 0 OR INSTR(TABLE_NAME, '.') &gt; 0)
) AS user_pages,
(
SELECT COUNT(*)
FROM information_schema.INNODB_BUFFER_PAGE
) AS total_pages,
(
SELECT ROUND((user_pages/total_pages) * 100)
) AS user_page_percentage;
+------------+-------------+----------------------+
| user_pages | total_pages | user_page_percentage |
+------------+-------------+----------------------+
|       6872 |        8192 |                   84 |
+------------+-------------+----------------------+
1 row in set (0.08 sec)</pre><p>
        このクエリーは、バッファープール内のページを含むユーザー定義のテーブルを識別します。
      </p><pre class="programlisting">mysql&gt; SELECT DISTINCT TABLE_NAME FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE 
WHERE TABLE_NAME IS NOT NULL AND (INSTR(TABLE_NAME, '/') &gt; 0 OR INSTR(TABLE_NAME, '.') &gt; 0) 
AND TABLE_NAME NOT LIKE '`mysql`.`innodb_%';
+-------------------------+
| TABLE_NAME              |
+-------------------------+
| `employees`.`salaries`  |
| `employees`.`employees` |
+-------------------------+
2 rows in set (0.09 sec)</pre></div></div><br class="example-break"><div class="example"><a name="innodb-information-schema-buffer-pool-index-data-example"></a><p class="title"><b>例 14.19 INNODB_BUFFER_PAGE テーブル内のインデックスデータのクエリー</b></p><div class="example-contents"><p>
        インデックスページに関する情報を取得するには、そのインデックスの名前を使用して <code class="literal">INDEX_NAME</code> カラムをクエリーします。たとえば、次のクエリーは、<code class="literal">employees.salaries</code> テーブルで定義されている <code class="literal">emp_no</code> インデックスのページの数とページの合計データサイズを返します。
      </p><pre class="programlisting">mysql&gt; SELECT INDEX_NAME, COUNT(*) AS Pages, 
ROUND(SUM(IF(COMPRESSED_SIZE = 0, @@global.innodb_page_size, COMPRESSED_SIZE))/1024/1024) 
AS 'Total Data (MB)' 
FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE 
WHERE INDEX_NAME='emp_no' AND TABLE_NAME = '`employees`.`salaries`';
+------------+-------+-----------------+
| INDEX_NAME | Pages | Total Data (MB) |
+------------+-------+-----------------+
| emp_no     |  1756 |              27 |
+------------+-------+-----------------+
1 row in set (0.07 sec)</pre><p>
        このクエリーは、<code class="literal">employees.salaries</code> テーブルで定義されているすべてのインデックスのページの数とページの合計データサイズを返します。
      </p><pre class="programlisting">mysql&gt; SELECT INDEX_NAME, COUNT(*) AS Pages,
ROUND(SUM(IF(COMPRESSED_SIZE = 0, @@global.innodb_page_size, COMPRESSED_SIZE))/1024/1024) 
AS 'Total Data (MB)'
FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE
WHERE TABLE_NAME = '`employees`.`salaries`'
GROUP BY INDEX_NAME;
+------------+-------+-----------------+
| INDEX_NAME | Pages | Total Data (MB) |
+------------+-------+-----------------+
| emp_no     |  1756 |              27 |
| PRIMARY    |  4838 |              76 |
+------------+-------+-----------------+
2 rows in set (0.12 sec)</pre></div></div><br class="example-break"><div class="example"><a name="innodb-information-schema-buffer-pool-lru-position-example"></a><p class="title"><b>例 14.20 INNODB_BUFFER_PAGE_LRU テーブル内の LRU_POSITION データのクエリー</b></p><div class="example-contents"><p>
        <code class="literal">INNODB_BUFFER_PAGE_LRU</code> テーブルは、<code class="literal">InnoDB</code> バッファープール内のページに関する情報、特に、いっぱいになったときにバッファープールからどのページを削除するかを決定する各ページの順序を保持しています。このページの定義は、このテーブルには <code class="literal">BLOCK_ID</code> カラムの代わりに <code class="literal">LRU_POSITION</code> カラムがある点を除き、<code class="literal">INNODB_BUFFER_PAGE</code> の場合と同じです。
      </p><p>
        このクエリーは、<code class="literal">employees.employees</code> テーブルの各ページによって占有されている LRU リスト内の特定の場所にある位置の数をカウントします。
      </p><pre class="programlisting">mysql&gt; SELECT COUNT(LRU_POSITION) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE_LRU 
WHERE TABLE_NAME='`employees`.`employees`' AND LRU_POSITION &lt; 3072;
+---------------------+
| COUNT(LRU_POSITION) |
+---------------------+
|                 275 |
+---------------------+
1 row in set (0.04 sec)</pre></div></div><br class="example-break"><div class="example"><a name="innodb-information-schema-buffer-pool-stats-example"></a><p class="title"><b>例 14.21 INNODB_BUFFER_POOL_STATS テーブルのクエリー</b></p><div class="example-contents"><p>
        <code class="literal">INNODB_BUFFER_POOL_STATS</code> テーブルは、<code class="literal">SHOW ENGINE INNODB STATUS</code> および <code class="literal">InnoDB</code> バッファープールのステータス変数と同様の情報を提供します。
      </p><pre class="programlisting">mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_BUFFER_POOL_STATS \G
*************************** 1. row ***************************
                         POOL_ID: 0
                       POOL_SIZE: 8192
                    FREE_BUFFERS: 1024
                  DATABASE_PAGES: 7029
              OLD_DATABASE_PAGES: 2574
         MODIFIED_DATABASE_PAGES: 0
              PENDING_DECOMPRESS: 0
                   PENDING_READS: 0
               PENDING_FLUSH_LRU: 0
              PENDING_FLUSH_LIST: 0
                PAGES_MADE_YOUNG: 173
            PAGES_NOT_MADE_YOUNG: 3721891
           PAGES_MADE_YOUNG_RATE: 0
       PAGES_MADE_NOT_YOUNG_RATE: 0
               NUMBER_PAGES_READ: 1075
            NUMBER_PAGES_CREATED: 12594
            NUMBER_PAGES_WRITTEN: 13525
                 PAGES_READ_RATE: 0
               PAGES_CREATE_RATE: 0
              PAGES_WRITTEN_RATE: 0
                NUMBER_PAGES_GET: 27873240
                        HIT_RATE: 0
    YOUNG_MAKE_PER_THOUSAND_GETS: 0
NOT_YOUNG_MAKE_PER_THOUSAND_GETS: 0
         NUMBER_PAGES_READ_AHEAD: 576
       NUMBER_READ_AHEAD_EVICTED: 0
                 READ_AHEAD_RATE: 0
         READ_AHEAD_EVICTED_RATE: 0
                    LRU_IO_TOTAL: 0
                  LRU_IO_CURRENT: 0
                UNCOMPRESS_TOTAL: 0
              UNCOMPRESS_CURRENT: 0
1 row in set (0.00 sec)</pre><p>
        比較のために、同じデータセットに基づいた <code class="literal">SHOW ENGINE INNODB STATUS</code> の出力および <code class="literal">InnoDB</code> バッファープールのステータス変数の出力を次に示します。
      </p><p>
        <code class="literal">SHOW ENGINE INNODB STATUS</code> の出力の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-standard-monitor" title="14.15.3 InnoDB 標準モニターおよびロックモニターの出力">セクション14.15.3「InnoDB 標準モニターおよびロックモニターの出力」</a>を参照してください。
      </p><pre class="programlisting">mysql&gt; SHOW ENGINE INNODB STATUS \G
...
----------------------
BUFFER POOL AND MEMORY
----------------------
Total memory allocated 137363456; in additional pool allocated 0
Dictionary memory allocated 99725
Buffer pool size   8192
Free buffers       1024
Database pages     7029
Old database pages 2574
Modified db pages  0
Pending reads 0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 173, not young 3721891
0.00 youngs/s, 0.00 non-youngs/s
Pages read 1075, created 12594, written 13525
0.00 reads/s, 0.00 creates/s, 0.00 writes/s
No buffer pool page gets since the last printout
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s
LRU len: 7029, unzip_LRU len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
...</pre><p>
        ステータス変数の説明については、<a class="xref" href="server-administration.html#server-status-variables" title="5.1.6 サーバーステータス変数">セクション5.1.6「サーバーステータス変数」</a>を参照してください。
      </p><pre class="programlisting">mysql&gt; SHOW STATUS LIKE 'Innodb_buffer%';
+---------------------------------------+-------------+
| Variable_name                         | Value       |
+---------------------------------------+-------------+
| Innodb_buffer_pool_dump_status        | not started |
| Innodb_buffer_pool_load_status        | not started |
| Innodb_buffer_pool_pages_data         | 7029        |
| Innodb_buffer_pool_bytes_data         | 115163136   |
| Innodb_buffer_pool_pages_dirty        | 0           |
| Innodb_buffer_pool_bytes_dirty        | 0           |
| Innodb_buffer_pool_pages_flushed      | 13525       |
| Innodb_buffer_pool_pages_free         | 1024        |
| Innodb_buffer_pool_pages_misc         | 139         |
| Innodb_buffer_pool_pages_total        | 8192        |
| Innodb_buffer_pool_read_ahead_rnd     | 0           |
| Innodb_buffer_pool_read_ahead         | 576         |
| Innodb_buffer_pool_read_ahead_evicted | 0           |
| Innodb_buffer_pool_read_requests      | 27873240    |
| Innodb_buffer_pool_reads              | 500         |
| Innodb_buffer_pool_wait_free          | 0           |
| Innodb_buffer_pool_write_requests     | 11966441    |
+---------------------------------------+-------------+
17 rows in set (0.00 sec)</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-information-schema-metrics-table"></a>14.14.6 InnoDB INFORMATION_SCHEMA メトリックテーブル</h3></div></div></div><p>
      MySQL 5.6.2 で導入された <code class="literal">INNODB_METRICS</code> テーブルは、<code class="literal">InnoDB</code> のパフォーマンスおよびリソース関連のすべてのカウンタを 1 つの <code class="literal">INFORMATION_SCHEMA</code> テーブルに統合します。
    </p><p>
      <code class="literal">INNODB_METRICS</code> テーブルのカラムを次の例に示します。各カラムについては、<a class="xref" href="information-schema.html#innodb-metrics-table" title="21.29.19 INFORMATION_SCHEMA INNODB_METRICS テーブル">セクション21.29.19「INFORMATION_SCHEMA INNODB_METRICS テーブル」</a>を参照してください。
    </p><pre class="programlisting">mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_METRICS WHERE NAME="dml_inserts" \G
*************************** 1. row ***************************
           NAME: dml_inserts
      SUBSYSTEM: dml
          COUNT: 46273
      MAX_COUNT: 46273
      MIN_COUNT: NULL
      AVG_COUNT: 492.2659574468085
    COUNT_RESET: 46273
MAX_COUNT_RESET: 46273
MIN_COUNT_RESET: NULL
AVG_COUNT_RESET: NULL
   TIME_ENABLED: 2014-11-28 16:07:53
  TIME_DISABLED: NULL
   TIME_ELAPSED: 94
     TIME_RESET: NULL
         STATUS: enabled
           TYPE: status_counter
        COMMENT: Number of rows inserted
1 row in set (0.00 sec)</pre><h4><a name="idm139979062558080"></a>カウンタの有効化、無効化、およびリセット</h4><p>
      次の構成オプションを使用して、カウンタを有効または無効にしたり、リセットしたりすることができます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">innodb_monitor_enable</code>: 1 つ以上のカウンタを有効にします。
        </p><pre class="programlisting">SET GLOBAL innodb_monitor_enable = [counter-name|module_name|pattern|all];</pre></li><li class="listitem"><p>
          <code class="literal">innodb_monitor_disable</code>: 1 つ以上のカウンタを無効にします。
        </p><pre class="programlisting">SET GLOBAL innodb_monitor_disable = [counter-name|module_name|pattern|all];</pre></li><li class="listitem"><p>
          <code class="literal">innodb_monitor_reset</code>: 1 つ以上のカウンタのカウント値を 0 にリセットします。
        </p><pre class="programlisting">SET GLOBAL innodb_monitor_reset = [counter-name|module_name|pattern|all];</pre></li><li class="listitem"><p>
          <code class="literal">innodb_monitor_reset_all</code>: 1 つ以上のカウンタのすべての値をリセットします。<code class="literal">innodb_monitor_reset_all</code> を使用する前にカウンタを無効にする必要があります。
        </p><pre class="programlisting">SET GLOBAL innodb_monitor_reset_all = [counter-name|module_name|pattern|all];</pre></li></ul></div><p>
      MySQL サーバーの構成ファイルを使用して、起動時にカウンタおよびカウンタモジュールを有効にすることもできます。たとえば、<code class="literal">log</code> モジュール、<code class="literal">metadata_table_handles_opened</code> および <code class="literal">metadata_table_handles_closed</code> カウンタを有効にするには、<code class="filename">my.cnf</code> 構成ファイルの <code class="literal">[mysqld]</code> セクション内に次の行を入力します。
    </p><pre class="programlisting">[mysqld]
innodb_monitor_enable = module_recovery,metadata_table_handles_opened,metadata_table_handles_closed</pre><p>
      構成ファイルで複数のカウンタまたはモジュールを有効にする場合は、上の例に示すように、<code class="literal">innodb_monitor_enable</code> 構成オプションに続けて、カウンタおよびモジュール名をカンマで区切って指定する必要があります。構成ファイルで使用できるのは、<code class="literal">innodb_monitor_enable</code> オプションだけです。無効化とリセットの構成オプションは、コマンド行でのみサポートされます。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        各カウンタによってサーバーにはある程度の実行時オーバーヘッドが発生するため、通常は、実験やベンチマーク中にテストおよび開発サーバー上で多くのカウンタを有効にし、本番サーバー上でカウンタを有効にするのは、既知の問題を診断するか、または特定のサーバーやワークロードのボトルネックになる可能性のある側面をモニターする場合だけにしてください。
      </p></div><h4><a name="idm139979062534480"></a>カウンタ</h4><p>
      <code class="literal">INNODB_METRICS</code> テーブルで表されるカウンタは変更される可能性があるため、最新のリストを取得するには、実行中の MySQL サーバーをクエリーします。下のリストは、MySQL 5.6.23 の時点で使用可能なカウンタを示しています。
    </p><p>
      デフォルトで有効になっているカウンタは、<code class="literal">SHOW ENGINE INNODB STATUS</code> によって使用されるカウンタに対応しています。<code class="literal">SHOW ENGINE INNODB STATUS</code> によって使用されるカウンタは常にシステムレベルで<span class="quote">「<span class="quote">オン</span>」</span>の状態ですが、<code class="literal">INNODB_METRICS</code> テーブルのこれらのカウンタは必要に応じて無効にすることができます。また、カウンタのステータスも永続的ではありません。特に指定されていないかぎり、カウンタは、サーバーが再起動されるとデフォルトの有効または無効のステータスに戻ります。
    </p><p>
      <code class="literal">INNODB_METRICS</code> テーブルへの追加または変更によって影響を受けるプログラムを実行する場合は、アップグレードの前にリリースノートを確認し、新しいリリースの <code class="literal">INNODB_METRICS</code> テーブルをクエリーすることをお勧めします。
    </p><pre class="programlisting">mysql&gt; SELECT name, subsystem, status FROM INFORMATION_SCHEMA.INNODB_METRICS ORDER BY NAME;
+------------------------------------------+---------------------+----------+
| name                                     | subsystem           | status   |
+------------------------------------------+---------------------+----------+
| adaptive_hash_pages_added                | adaptive_hash_index | disabled |
| adaptive_hash_pages_removed              | adaptive_hash_index | disabled |
| adaptive_hash_rows_added                 | adaptive_hash_index | disabled |
| adaptive_hash_rows_deleted_no_hash_entry | adaptive_hash_index | disabled |
| adaptive_hash_rows_removed               | adaptive_hash_index | disabled |
| adaptive_hash_rows_updated               | adaptive_hash_index | disabled |
| adaptive_hash_searches                   | adaptive_hash_index | enabled  |
| adaptive_hash_searches_btree             | adaptive_hash_index | disabled |
| buffer_data_reads                        | buffer              | enabled  |
| buffer_data_written                      | buffer              | enabled  |
| buffer_flush_adaptive                    | buffer              | disabled |
| buffer_flush_adaptive_pages              | buffer              | disabled |
| buffer_flush_adaptive_total_pages        | buffer              | disabled |
| buffer_flush_avg_page_rate               | buffer              | disabled |
| buffer_flush_background                  | buffer              | disabled |
| buffer_flush_background_pages            | buffer              | disabled |
| buffer_flush_background_total_pages      | buffer              | disabled |
| buffer_flush_batches                     | buffer              | disabled |
| buffer_flush_batch_num_scan              | buffer              | disabled |
| buffer_flush_batch_pages                 | buffer              | disabled |
| buffer_flush_batch_rescan                | buffer              | disabled |
| buffer_flush_batch_scanned               | buffer              | disabled |
| buffer_flush_batch_scanned_per_call      | buffer              | disabled |
| buffer_flush_batch_total_pages           | buffer              | disabled |
| buffer_flush_lsn_avg_rate                | buffer              | disabled |
| buffer_flush_neighbor                    | buffer              | disabled |
| buffer_flush_neighbor_pages              | buffer              | disabled |
| buffer_flush_neighbor_total_pages        | buffer              | disabled |
| buffer_flush_n_to_flush_requested        | buffer              | disabled |
| buffer_flush_pct_for_dirty               | buffer              | disabled |
| buffer_flush_pct_for_lsn                 | buffer              | disabled |
| buffer_flush_sync                        | buffer              | disabled |
| buffer_flush_sync_pages                  | buffer              | disabled |
| buffer_flush_sync_total_pages            | buffer              | disabled |
| buffer_flush_sync_waits                  | buffer              | disabled |
| buffer_LRU_batches                       | buffer              | disabled |
| buffer_LRU_batch_num_scan                | buffer              | disabled |
| buffer_LRU_batch_pages                   | buffer              | disabled |
| buffer_LRU_batch_scanned                 | buffer              | disabled |
| buffer_LRU_batch_scanned_per_call        | buffer              | disabled |
| buffer_LRU_batch_total_pages             | buffer              | disabled |
| buffer_LRU_get_free_search               | Buffer              | disabled |
| buffer_LRU_search_num_scan               | buffer              | disabled |
| buffer_LRU_search_scanned                | buffer              | disabled |
| buffer_LRU_search_scanned_per_call       | buffer              | disabled |
| buffer_LRU_single_flush_failure_count    | Buffer              | disabled |
| buffer_LRU_single_flush_num_scan         | buffer              | disabled |
| buffer_LRU_single_flush_scanned          | buffer              | disabled |
| buffer_LRU_single_flush_scanned_per_call | buffer              | disabled |
| buffer_LRU_unzip_search_num_scan         | buffer              | disabled |
| buffer_LRU_unzip_search_scanned          | buffer              | disabled |
| buffer_LRU_unzip_search_scanned_per_call | buffer              | disabled |
| buffer_pages_created                     | buffer              | enabled  |
| buffer_pages_read                        | buffer              | enabled  |
| buffer_pages_written                     | buffer              | enabled  |
| buffer_page_read_blob                    | buffer_page_io      | disabled |
| buffer_page_read_fsp_hdr                 | buffer_page_io      | disabled |
| buffer_page_read_ibuf_bitmap             | buffer_page_io      | disabled |
| buffer_page_read_ibuf_free_list          | buffer_page_io      | disabled |
| buffer_page_read_index_ibuf_leaf         | buffer_page_io      | disabled |
| buffer_page_read_index_ibuf_non_leaf     | buffer_page_io      | disabled |
| buffer_page_read_index_inode             | buffer_page_io      | disabled |
| buffer_page_read_index_leaf              | buffer_page_io      | disabled |
| buffer_page_read_index_non_leaf          | buffer_page_io      | disabled |
| buffer_page_read_other                   | buffer_page_io      | disabled |
| buffer_page_read_system_page             | buffer_page_io      | disabled |
| buffer_page_read_trx_system              | buffer_page_io      | disabled |
| buffer_page_read_undo_log                | buffer_page_io      | disabled |
| buffer_page_read_xdes                    | buffer_page_io      | disabled |
| buffer_page_read_zblob                   | buffer_page_io      | disabled |
| buffer_page_read_zblob2                  | buffer_page_io      | disabled |
| buffer_page_written_blob                 | buffer_page_io      | disabled |
| buffer_page_written_fsp_hdr              | buffer_page_io      | disabled |
| buffer_page_written_ibuf_bitmap          | buffer_page_io      | disabled |
| buffer_page_written_ibuf_free_list       | buffer_page_io      | disabled |
| buffer_page_written_index_ibuf_leaf      | buffer_page_io      | disabled |
| buffer_page_written_index_ibuf_non_leaf  | buffer_page_io      | disabled |
| buffer_page_written_index_inode          | buffer_page_io      | disabled |
| buffer_page_written_index_leaf           | buffer_page_io      | disabled |
| buffer_page_written_index_non_leaf       | buffer_page_io      | disabled |
| buffer_page_written_other                | buffer_page_io      | disabled |
| buffer_page_written_system_page          | buffer_page_io      | disabled |
| buffer_page_written_trx_system           | buffer_page_io      | disabled |
| buffer_page_written_undo_log             | buffer_page_io      | disabled |
| buffer_page_written_xdes                 | buffer_page_io      | disabled |
| buffer_page_written_zblob                | buffer_page_io      | disabled |
| buffer_page_written_zblob2               | buffer_page_io      | disabled |
| buffer_pool_bytes_data                   | buffer              | enabled  |
| buffer_pool_bytes_dirty                  | buffer              | enabled  |
| buffer_pool_pages_data                   | buffer              | enabled  |
| buffer_pool_pages_dirty                  | buffer              | enabled  |
| buffer_pool_pages_free                   | buffer              | enabled  |
| buffer_pool_pages_misc                   | buffer              | enabled  |
| buffer_pool_pages_total                  | buffer              | enabled  |
| buffer_pool_reads                        | buffer              | enabled  |
| buffer_pool_read_ahead                   | buffer              | enabled  |
| buffer_pool_read_ahead_evicted           | buffer              | enabled  |
| buffer_pool_read_requests                | buffer              | enabled  |
| buffer_pool_size                         | server              | enabled  |
| buffer_pool_wait_free                    | buffer              | enabled  |
| buffer_pool_write_requests               | buffer              | enabled  |
| compression_pad_decrements               | compression         | disabled |
| compression_pad_increments               | compression         | disabled |
| compress_pages_compressed                | compression         | disabled |
| compress_pages_decompressed              | compression         | disabled |
| ddl_background_drop_indexes              | ddl                 | disabled |
| ddl_background_drop_tables               | ddl                 | disabled |
| ddl_online_create_index                  | ddl                 | disabled |
| ddl_pending_alter_table                  | ddl                 | disabled |
| dml_deletes                              | dml                 | enabled  |
| dml_inserts                              | dml                 | enabled  |
| dml_reads                                | dml                 | enabled  |
| dml_updates                              | dml                 | enabled  |
| file_num_open_files                      | file_system         | enabled  |
| ibuf_merges                              | change_buffer       | enabled  |
| ibuf_merges_delete                       | change_buffer       | enabled  |
| ibuf_merges_delete_mark                  | change_buffer       | enabled  |
| ibuf_merges_discard_delete               | change_buffer       | enabled  |
| ibuf_merges_discard_delete_mark          | change_buffer       | enabled  |
| ibuf_merges_discard_insert               | change_buffer       | enabled  |
| ibuf_merges_insert                       | change_buffer       | enabled  |
| ibuf_size                                | change_buffer       | enabled  |
| icp_attempts                             | icp                 | disabled |
| icp_match                                | icp                 | disabled |
| icp_no_match                             | icp                 | disabled |
| icp_out_of_range                         | icp                 | disabled |
| index_page_discards                      | index               | disabled |
| index_page_merge_attempts                | index               | disabled |
| index_page_merge_successful              | index               | disabled |
| index_page_reorg_attempts                | index               | disabled |
| index_page_reorg_successful              | index               | disabled |
| index_page_splits                        | index               | disabled |
| innodb_activity_count                    | server              | enabled  |
| innodb_background_drop_table_usec        | server              | disabled |
| innodb_checkpoint_usec                   | server              | disabled |
| innodb_dblwr_pages_written               | server              | enabled  |
| innodb_dblwr_writes                      | server              | enabled  |
| innodb_dict_lru_usec                     | server              | disabled |
| innodb_ibuf_merge_usec                   | server              | disabled |
| innodb_log_flush_usec                    | server              | disabled |
| innodb_master_active_loops               | server              | disabled |
| innodb_master_idle_loops                 | server              | disabled |
| innodb_master_purge_usec                 | server              | disabled |
| innodb_master_thread_sleeps              | server              | disabled |
| innodb_mem_validate_usec                 | server              | disabled |
| innodb_page_size                         | server              | enabled  |
| innodb_rwlock_s_os_waits                 | server              | enabled  |
| innodb_rwlock_s_spin_rounds              | server              | enabled  |
| innodb_rwlock_s_spin_waits               | server              | enabled  |
| innodb_rwlock_x_os_waits                 | server              | enabled  |
| innodb_rwlock_x_spin_rounds              | server              | enabled  |
| innodb_rwlock_x_spin_waits               | server              | enabled  |
| lock_deadlocks                           | lock                | enabled  |
| lock_rec_locks                           | lock                | disabled |
| lock_rec_lock_created                    | lock                | disabled |
| lock_rec_lock_removed                    | lock                | disabled |
| lock_rec_lock_requests                   | lock                | disabled |
| lock_rec_lock_waits                      | lock                | disabled |
| lock_row_lock_current_waits              | lock                | enabled  |
| lock_row_lock_time                       | lock                | enabled  |
| lock_row_lock_time_avg                   | lock                | enabled  |
| lock_row_lock_time_max                   | lock                | enabled  |
| lock_row_lock_waits                      | lock                | enabled  |
| lock_table_locks                         | lock                | disabled |
| lock_table_lock_created                  | lock                | disabled |
| lock_table_lock_removed                  | lock                | disabled |
| lock_table_lock_waits                    | lock                | disabled |
| lock_timeouts                            | lock                | enabled  |
| log_checkpoints                          | recovery            | disabled |
| log_lsn_buf_pool_oldest                  | recovery            | disabled |
| log_lsn_checkpoint_age                   | recovery            | disabled |
| log_lsn_current                          | recovery            | disabled |
| log_lsn_last_checkpoint                  | recovery            | disabled |
| log_lsn_last_flush                       | recovery            | disabled |
| log_max_modified_age_async               | recovery            | disabled |
| log_max_modified_age_sync                | recovery            | disabled |
| log_num_log_io                           | recovery            | disabled |
| log_pending_checkpoint_writes            | recovery            | disabled |
| log_pending_log_writes                   | recovery            | disabled |
| log_waits                                | recovery            | enabled  |
| log_writes                               | recovery            | enabled  |
| log_write_requests                       | recovery            | enabled  |
| metadata_mem_pool_size                   | metadata            | enabled  |
| metadata_table_handles_closed            | metadata            | disabled |
| metadata_table_handles_opened            | metadata            | disabled |
| metadata_table_reference_count           | metadata            | disabled |
| os_data_fsyncs                           | os                  | enabled  |
| os_data_reads                            | os                  | enabled  |
| os_data_writes                           | os                  | enabled  |
| os_log_bytes_written                     | os                  | enabled  |
| os_log_fsyncs                            | os                  | enabled  |
| os_log_pending_fsyncs                    | os                  | enabled  |
| os_log_pending_writes                    | os                  | enabled  |
| os_pending_reads                         | os                  | disabled |
| os_pending_writes                        | os                  | disabled |
| purge_del_mark_records                   | purge               | disabled |
| purge_dml_delay_usec                     | purge               | disabled |
| purge_invoked                            | purge               | disabled |
| purge_resume_count                       | purge               | disabled |
| purge_stop_count                         | purge               | disabled |
| purge_undo_log_pages                     | purge               | disabled |
| purge_upd_exist_or_extern_records        | purge               | disabled |
| trx_active_transactions                  | transaction         | disabled |
| trx_commits_insert_update                | transaction         | disabled |
| trx_nl_ro_commits                        | transaction         | disabled |
| trx_rollbacks                            | transaction         | disabled |
| trx_rollbacks_savepoint                  | transaction         | disabled |
| trx_rollback_active                      | transaction         | disabled |
| trx_ro_commits                           | transaction         | disabled |
| trx_rseg_current_size                    | transaction         | disabled |
| trx_rseg_history_len                     | transaction         | enabled  |
| trx_rw_commits                           | transaction         | disabled |
| trx_undo_slots_cached                    | transaction         | disabled |
| trx_undo_slots_used                      | transaction         | disabled |
+------------------------------------------+---------------------+----------+
214 rows in set (0.00 sec)</pre><h4><a name="idm139979062487232"></a>カウンタモジュール</h4><p>
      モジュール名は <code class="literal">INNODB_METRICS</code> テーブルの <code class="literal">SUBSYSTEM</code> カラムの値に対応しますが、まったく同じではありません。カウンタの個別の有効化、無効化、またはリセットではなく、モジュール名を使用すると、特定のサブシステムのすべてのカウンタをすばやく有効または無効にしたり、リセットしたりすることができます。たとえば、<code class="literal">dml</code> サブシステムに関連付けられたすべてのカウンタを有効にするには、<code class="literal">module_dml</code> を使用します。
    </p><pre class="programlisting">mysql&gt; SET GLOBAL innodb_monitor_enable = module_dml;
      
mysql&gt; SELECT name, subsystem, status FROM INFORMATION_SCHEMA.INNODB_METRICS 
WHERE subsystem ='dml';
+-------------+-----------+---------+
| name        | subsystem | status  |
+-------------+-----------+---------+
| dml_reads   | dml       | enabled |
| dml_inserts | dml       | enabled |
| dml_deletes | dml       | enabled |
| dml_updates | dml       | enabled |
+-------------+-----------+---------+
4 rows in set (0.01 sec)</pre><p>
      <code class="literal">innodb_monitor_enable</code> および関連する構成オプションで <em class="replaceable"><code>module_name</code></em> に使用できる値を、対応する <code class="literal">SUBSYSTEM</code> の名前とともに次に示します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">module_metadata</code> (サブシステム = <code class="literal">metadata</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">module_lock</code> (サブシステム = <code class="literal">lock</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">module_buffer</code> (サブシステム = <code class="literal">buffer</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">module_buf_page</code> (サブシステム = <code class="literal">buffer_page_io</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">module_os</code> (サブシステム = <code class="literal">os</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">module_trx</code> (サブシステム = <code class="literal">transaction</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">module_purge</code> (サブシステム = <code class="literal">purge</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">module_compress</code> (サブシステム = <code class="literal">compression</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">module_file</code> (サブシステム = <code class="literal">file_system</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">module_index</code> (サブシステム = <code class="literal">index</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">module_adaptive_hash</code> (サブシステム = <code class="literal">adaptive_hash_index</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">module_ibuf_system</code> (サブシステム = <code class="literal">change_buffer</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">module_srv</code> (サブシステム = <code class="literal">server</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">module_ddl</code> (サブシステム = <code class="literal">ddl</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">module_dml</code> (サブシステム = <code class="literal">dml</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">module_log</code> (サブシステム = <code class="literal">recovery</code>)
        </p></li><li class="listitem"><p>
          <code class="literal">module_icp</code> (サブシステム = <code class="literal">icp</code>)
        </p></li></ul></div><div class="example"><a name="innodb-information-schema-metrics-table-example"></a><p class="title"><b>例 14.22 INNODB_METRICS テーブルのカウンタの操作</b></p><div class="example-contents"><p>
        この例では、カウンタの有効化、無効化、およびリセットと、<code class="literal">INNODB_METRICS</code> テーブル内のカウンタデータのクエリーを示します。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            単純な <code class="literal">InnoDB</code> テーブルを作成します。
          </p><pre class="programlisting">mysql&gt; USE test;
Database changed

mysql&gt; CREATE TABLE t1 (c1 INT) ENGINE=INNODB;
Query OK, 0 rows affected (0.02 sec)</pre></li><li class="listitem"><p>
            <code class="literal">dml_inserts</code> カウンタを有効にします。
          </p><pre class="programlisting">mysql&gt; SET GLOBAL innodb_monitor_enable = dml_inserts;
Query OK, 0 rows affected (0.01 sec)</pre><p>
            <code class="literal">dml_inserts</code> カウンタの説明は、<code class="literal">INNODB_METRICS</code> テーブルの <code class="literal">COMMENT</code> カラムで見つけることができます。
          </p><pre class="programlisting">mysql&gt; SELECT NAME, COMMENT FROM INFORMATION_SCHEMA.INNODB_METRICS WHERE NAME="dml_inserts";
+-------------+-------------------------+
| NAME        | COMMENT                 |
+-------------+-------------------------+
| dml_inserts | Number of rows inserted |
+-------------+-------------------------+
1 row in set (0.00 sec)</pre></li><li class="listitem"><p>
            <code class="literal">dml_inserts</code> カウンタデータを取得するために <code class="literal">INNODB_METRICS</code> テーブルをクエリーします。DML 操作が実行されていないため、カウンタ値は 0 または NULL です。<code class="literal">TIME_ENABLED</code> および <code class="literal">TIME_ELAPSED</code> 値は、このカウンタが最後に有効になった時間と、この時間から経過した秒数を示します。
          </p><pre class="programlisting">mysql&gt;  SELECT * FROM INFORMATION_SCHEMA.INNODB_METRICS WHERE NAME="dml_inserts" \G
*************************** 1. row ***************************
           NAME: dml_inserts
      SUBSYSTEM: dml
          COUNT: 0
      MAX_COUNT: 0
      MIN_COUNT: NULL
      AVG_COUNT: 0
    COUNT_RESET: 0
MAX_COUNT_RESET: 0
MIN_COUNT_RESET: NULL
AVG_COUNT_RESET: NULL
   TIME_ENABLED: 2014-12-04 14:18:28
  TIME_DISABLED: NULL
   TIME_ELAPSED: 28
     TIME_RESET: NULL
         STATUS: enabled
           TYPE: status_counter
        COMMENT: Number of rows inserted
1 row in set (0.01 sec)</pre></li><li class="listitem"><p>
            テーブルに 3 行のデータを挿入します。
          </p><pre class="programlisting">mysql&gt; INSERT INTO t1 values(1);
Query OK, 1 row affected (0.00 sec)

mysql&gt; INSERT INTO t1 values(2);
Query OK, 1 row affected (0.00 sec)

mysql&gt; INSERT INTO t1 values(3);
Query OK, 1 row affected (0.00 sec)</pre></li><li class="listitem"><p>
            <code class="literal">dml_inserts</code> カウンタデータを取得するために再度 <code class="literal">INNODB_METRICS</code> テーブルをクエリーします。<code class="literal">COUNT</code>、<code class="literal">MAX_COUNT</code>、<code class="literal">AVG_COUNT</code>、<code class="literal">COUNT_RESET</code> など、いくつかのカウンタ値が増分されています。これらの値の説明については、<code class="literal">INNODB_METRICS</code> テーブルの定義を参照してください。
          </p><pre class="programlisting">mysql&gt;  SELECT * FROM INFORMATION_SCHEMA.INNODB_METRICS WHERE NAME="dml_inserts"\G
*************************** 1. row ***************************
           NAME: dml_inserts
      SUBSYSTEM: dml
          COUNT: 3
      MAX_COUNT: 3
      MIN_COUNT: NULL
      AVG_COUNT: 0.046153846153846156
    COUNT_RESET: 3
MAX_COUNT_RESET: 3
MIN_COUNT_RESET: NULL
AVG_COUNT_RESET: NULL
   TIME_ENABLED: 2014-12-04 14:18:28
  TIME_DISABLED: NULL
   TIME_ELAPSED: 65
     TIME_RESET: NULL
         STATUS: enabled
           TYPE: status_counter
        COMMENT: Number of rows inserted
1 row in set (0.00 sec)</pre></li><li class="listitem"><p>
            <code class="literal">dml_inserts</code> カウンタをリセットし、<code class="literal">dml_inserts</code> カウンタデータを取得するために再度 <code class="literal">INNODB_METRICS</code> テーブルをクエリーします。<code class="literal">COUNT_RESET</code> や <code class="literal">MAX_RESET</code> などの、前にレポートされた<span class="quote">「<span class="quote"><code class="literal">%_RESET</code></span>」</span>値が 0 に戻っています。カウンタが有効になった時点から累積してデータを収集する <code class="literal">COUNT</code>、<code class="literal">MAX_COUNT</code>、<code class="literal">AVG_COUNT</code> などの値はリセットの影響を受けません。
          </p><pre class="programlisting">mysql&gt; SET GLOBAL innodb_monitor_reset = dml_inserts;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_METRICS WHERE NAME="dml_inserts"\G
*************************** 1. row ***************************
           NAME: dml_inserts
      SUBSYSTEM: dml
          COUNT: 3
      MAX_COUNT: 3
      MIN_COUNT: NULL
      AVG_COUNT: 0.03529411764705882
    COUNT_RESET: 0
MAX_COUNT_RESET: 0
MIN_COUNT_RESET: NULL
AVG_COUNT_RESET: 0
   TIME_ENABLED: 2014-12-04 14:18:28
  TIME_DISABLED: NULL
   TIME_ELAPSED: 85
     TIME_RESET: 2014-12-04 14:19:44
         STATUS: enabled
           TYPE: status_counter
        COMMENT: Number of rows inserted
1 row in set (0.00 sec)</pre></li><li class="listitem"><p>
            すべてのカウンタ値をリセットするには、まずそのカウンタを無効にする必要があります。カウンタを無効にすると、<code class="literal">STATUS</code> 値が <code class="literal">disbaled</code> に設定されます。
          </p><pre class="programlisting">mysql&gt; SET GLOBAL innodb_monitor_disable = dml_inserts;
Query OK, 0 rows affected (0.00 sec)
          
mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_METRICS WHERE NAME="dml_inserts"\G
*************************** 1. row ***************************
           NAME: dml_inserts
      SUBSYSTEM: dml
          COUNT: 3
      MAX_COUNT: 3
      MIN_COUNT: NULL
      AVG_COUNT: 0.030612244897959183
    COUNT_RESET: 0
MAX_COUNT_RESET: 0
MIN_COUNT_RESET: NULL
AVG_COUNT_RESET: 0
   TIME_ENABLED: 2014-12-04 14:18:28
  TIME_DISABLED: 2014-12-04 14:20:06
   TIME_ELAPSED: 98
     TIME_RESET: NULL
         STATUS: disabled
           TYPE: status_counter
        COMMENT: Number of rows inserted
1 row in set (0.00 sec)</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              カウンタおよびモジュール名にはワイルドカードマッチングがサポートされています。たとえば、<code class="literal">dml_inserts</code> カウンタの完全な名前を指定する代わりに、<span class="quote">「<span class="quote"><code class="literal">dml_i%</code></span>」</span>を指定できます。また、ワイルドカードマッチングを使用して、複数のカウンタまたはモジュールを一度に有効または無効にしたり、リセットしたりすることもできます。たとえば、<span class="quote">「<span class="quote"><code class="literal">dml_%</code></span>」</span>で始まるすべてのカウンタを有効または無効にしたり、リセットしたりするには、<span class="quote">「<span class="quote"><code class="literal">dml_%</code></span>」</span>を指定します。
            </p></div></li><li class="listitem"><p>
            カウンタが無効になったら、<code class="literal">innodb_monitor_reset_all</code> オプションを使用して、すべてのカウンタ値をリセットできます。すべての値が 0 または NULL に設定されます。
          </p><pre class="programlisting">mysql&gt; SET GLOBAL innodb_monitor_reset_all = dml_inserts;
Query OK, 0 rows affected (0.00 sec)
          
mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_METRICS WHERE NAME="dml_inserts"\G
*************************** 1. row ***************************
           NAME: dml_inserts
      SUBSYSTEM: dml
          COUNT: 0
      MAX_COUNT: NULL
      MIN_COUNT: NULL
      AVG_COUNT: NULL
    COUNT_RESET: 0
MAX_COUNT_RESET: NULL
MIN_COUNT_RESET: NULL
AVG_COUNT_RESET: NULL
   TIME_ENABLED: NULL
  TIME_DISABLED: NULL
   TIME_ELAPSED: NULL
     TIME_RESET: NULL
         STATUS: disabled
           TYPE: status_counter
        COMMENT: Number of rows inserted
1 row in set (0.01 sec)</pre></li></ol></div></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-monitors"></a>14.15 InnoDB モニター</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-monitor-types">14.15.1 InnoDB モニターのタイプ</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-enabling-monitors">14.15.2 InnoDB モニターの有効化</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-standard-monitor">14.15.3 InnoDB 標準モニターおよびロックモニターの出力</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-tablespace-monitor">14.15.4 InnoDB テーブルスペースモニターの出力</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-table-monitor">14.15.5 InnoDB テーブルモニターの出力</a></span></dt></dl></div><a class="indexterm" name="idm139979062383120"></a><a class="indexterm" name="idm139979062381008"></a><a class="indexterm" name="idm139979062379088"></a><a class="indexterm" name="idm139979062377040"></a><a class="indexterm" name="idm139979062375008"></a><a class="indexterm" name="idm139979062372944"></a><p>
    <code class="literal">InnoDB</code> モニターは、<code class="literal">InnoDB</code> の内部状態に関する情報を提供します。この情報は、パフォーマンスチューニングに役立ちます。
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-monitor-types"></a>14.15.1 InnoDB モニターのタイプ</h3></div></div></div><p>
      <code class="literal">InnoDB</code> モニターには、次の 4 つのタイプがあります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">InnoDB</code> 標準モニターは、次のタイプの情報を表示します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              アクティブな各トランザクションによって保持されているテーブルおよびレコードロック。
            </p></li><li class="listitem"><p>
              トランザクションのロック待機。
            </p></li><li class="listitem"><p>
              スレッドのセマフォー待機。
            </p></li><li class="listitem"><p>
              保留中のファイル I/O 要求。
            </p></li><li class="listitem"><p>
              バッファープールの統計。
            </p></li><li class="listitem"><p>
              メインの <code class="literal">InnoDB</code> スレッドのパージおよび挿入バッファーマージアクティビティー。
            </p></li></ul></div></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> ロックモニターは <code class="literal">InnoDB</code> 標準モニターに似ていますが、広範囲にわたるロック情報も提供します。
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> テーブルスペースモニターは、共有テーブルスペース内のファイルセグメントのリストを出力したり、テーブルスペースの割り当てデータ構造を検証したりします。
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> テーブルモニターは、<code class="literal">InnoDB</code> 内部データディクショナリの内容を出力します。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            テーブルスペースモニターとテーブルモニターは非推奨であり、将来の MySQL リリースで削除される予定です。テーブルモニターと同様の情報は、<code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code> テーブルから取得できます。<a class="xref" href="information-schema.html#innodb-i_s-tables" title="21.29 InnoDB の INFORMATION_SCHEMA テーブル">セクション21.29「InnoDB の INFORMATION_SCHEMA テーブル」</a>を参照してください。
          </p></div></li></ul></div><p>
      <code class="literal">InnoDB</code> モニターの詳細は、次を参照してください。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          Mark Leith: <a class="ulink" href="http://www.markleith.co.uk/?p=25" target="_top">InnoDB テーブルおよびテーブルスペースモニター</a>に関する記事
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-enabling-monitors"></a>14.15.2 InnoDB モニターの有効化</h3></div></div></div><p>
      <code class="literal">InnoDB</code> モニターでの定期的な出力を有効にすると、<code class="literal">InnoDB</code> は、その出力を <span class="command"><strong>mysqld</strong></span> サーバーの標準エラー出力 (<code class="literal">stderr</code>) に書き込みます。この場合、クライアントには出力が送信されません。オンに切り替えられると、<code class="literal">InnoDB</code> モニターは約 15 秒に 1 回データを出力します。サーバーの出力は通常、エラーログに送信されます (<a class="xref" href="server-administration.html#error-log" title="5.2.2 エラーログ">セクション5.2.2「エラーログ」</a>を参照してください)。このデータは、パフォーマンスチューニングに役立ちます。Windows では、出力をエラーログにではなくウィンドウに送信したい場合は、コンソールウィンドウのコマンドプロンプトから <code class="option">--console</code> オプションを使用してサーバーを起動します。
    </p><p>
      <code class="literal">InnoDB</code> は、バッファーオーバーフローの可能性を回避するために、診断の出力を <code class="literal">stdout</code> または固定サイズのメモリーバッファーにではなく、<code class="literal">stderr</code> またはファイルに送信します。副作用として、<code class="literal">SHOW ENGINE INNODB STATUS</code> の出力が MySQL データディレクトリ内のステータスファイルに 15 秒に 1 回書き込まれます。このファイルの名前は <code class="filename">innodb_status.<em class="replaceable"><code>pid</code></em></code> です。ここで、<em class="replaceable"><code>pid</code></em> はサーバープロセス ID です。<code class="literal">InnoDB</code> は、正常なシャットダウンのときにこのファイルを削除します。異常なシャットダウンが発生した場合は、これらのステータスファイルのインスタンスが存在する可能性があるため、手動で削除する必要があります。削除する前に、これらのファイルを検査して、異常なシャットダウンの原因に関する有効な情報が含まれているかどうかを確認することをお勧めします。<code class="filename">innodb_status.<em class="replaceable"><code>pid</code></em></code> ファイルは、構成オプション <code class="option">innodb-status-file=1</code> が設定されている場合にのみ作成されます。
    </p><p>
      出力の生成によってパフォーマンスはある程度低下するため、<code class="literal">InnoDB</code> モニターは、実際にモニター情報の確認が必要な場合にのみ有効にするようにしてください。また、関連付けられたテーブルを作成することによってモニターの出力を有効にした場合は、あとでテーブルを削除することを忘れると、エラーログがきわめて大きくなることがあります。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        トラブルシューティングを支援するために、<code class="literal">InnoDB</code> は、特定の状況で <code class="literal">InnoDB</code> 標準モニターの出力を一時的に有効にします。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-troubleshooting" title="14.19 InnoDB のトラブルシューティング">セクション14.19「InnoDB のトラブルシューティング」</a>を参照してください。
      </p></div><p>
      各モニターは、タイムスタンプとモニター名が含まれたヘッダーで始まります。例:
    </p><pre class="programlisting">
=====================================
2014-10-16 16:28:15 7feee43c5700 INNODB MONITOR OUTPUT
=====================================
</pre><p>
      ロックモニターでは、追加のロック情報が付加された同じ出力が生成されるため、<code class="literal">InnoDB</code> 標準モニターのヘッダー (<code class="literal">INNODB MONITOR OUTPUT</code>) はロックモニターにも使用されます。
    </p><p>
      <code class="literal">InnoDB</code> モニターでの定期的な出力を有効にするには、<code class="literal">CREATE TABLE</code> ステートメントを使用して、そのモニターに関連付けられた特別な名前の付いた <code class="literal">InnoDB</code> テーブルを作成します。たとえば、<code class="literal">InnoDB</code> 標準モニターを有効にするには、<code class="literal">innodb_monitor</code> という名前の <code class="literal">InnoDB</code> テーブルを作成します。
    </p><p>
      <code class="literal">CREATE TABLE</code> 構文の使用は、MySQL の SQL パーサーを経由して <code class="literal">InnoDB</code> エンジンにコマンドを渡すための方法にすぎません。重要なのは、テーブル名と、それが <code class="literal">InnoDB</code> テーブルであるということだけです。テーブルの構造は関係ありません。サーバーをシャットダウンした場合は、サーバーを再起動しても、モニターは自動的に再開されません。モニターテーブルを削除し、新しい <code class="literal">CREATE TABLE</code> ステートメントを発行してモニターを開始します。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">InnoDB</code> モニターを有効にするための <code class="literal">CREATE TABLE</code> の方法は非推奨であり、将来のリリースで削除される可能性があります。MySQL 5.6.16 の時点では、<code class="literal">innodb_status_output</code> および <code class="literal">innodb_status_output_locks</code> システム変数を使用して <code class="literal">InnoDB</code> 標準モニターおよび <code class="literal">InnoDB</code> ロックモニターを有効にすることができます。
      </p></div><p>
      <code class="literal">InnoDB</code> モニターを無効および有効にするには、<code class="literal">PROCESS</code> 権限が必要です。
    </p><h4><a name="idm139979062298304"></a>InnoDB 標準モニターの有効化</h4><p>
      InnoDB 標準モニターでの定期的な出力を有効にするには、<code class="literal">innodb_monitor</code> テーブルを作成します。
    </p><pre class="programlisting">
CREATE TABLE innodb_monitor (a INT) ENGINE=INNODB;
</pre><p>
      <code class="literal">InnoDB</code> 標準モニターを無効にするには、そのテーブルを削除します。
    </p><pre class="programlisting">
DROP TABLE innodb_monitor;
</pre><p>
      MySQL 5.6.16 の時点では、<code class="literal">innodb_status_output</code> システム変数を <code class="literal">ON</code> に設定することによって <code class="literal">InnoDB</code> 標準モニターを有効にすることもできます。
    </p><pre class="programlisting">
set GLOBAL innodb_status_output=ON;
</pre><p>
      <code class="literal">InnoDB</code> 標準モニターを無効にするには、<code class="literal">innodb_status_output</code> を <code class="literal">OFF</code> に設定します。
    </p><p>
      サーバーをシャットダウンすると、<code class="literal">innodb_status_output</code> 変数がデフォルトの <code class="literal">OFF</code> 値に設定されます。
    </p><h4><a name="idm139979062284544"></a>オンデマンドでの InnoDB 標準モニターの出力の取得</h4><p>
      <code class="literal">InnoDB</code> 標準モニターでの定期的な出力を有効にする代わりに、出力をクライアントプログラムにフェッチする <code class="literal">SHOW ENGINE INNODB STATUS</code> SQL ステートメントを使用して、オンデマンドで <code class="literal">InnoDB</code> 標準モニターの出力を取得できます。<span class="command"><strong>mysql</strong></span> 対話型クライアントを使用している場合は、通常のセミコロンのステートメントターミネータを <code class="literal">\G</code> に置き換えると、出力が読み取りやすくなります。
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW ENGINE INNODB STATUS\G</code></strong>
</pre><h4><a name="idm139979062277008"></a>InnoDB ロックモニターの有効化</h4><p>
      <code class="literal">InnoDB</code> ロックモニターでの定期的な出力を有効にするには、<code class="literal">innodb_lock_monitor</code> テーブルを作成します。
    </p><pre class="programlisting">
CREATE TABLE innodb_lock_monitor (a INT) ENGINE=INNODB;
</pre><p>
      <code class="literal">InnoDB</code> ロックモニターを無効にするには、そのテーブルを削除します。
    </p><pre class="programlisting">
DROP TABLE innodb_lock_monitor;
</pre><p>
      MySQL 5.6.16 の時点では、<code class="literal">innodb_status_output</code> および <code class="literal">innodb_status_output_locks</code> システム変数の両方を <code class="literal">ON</code> に設定することによって <code class="literal">InnoDB</code> ロックモニターを有効にすることもできます。ロックモニターの出力は <code class="literal">InnoDB</code> 標準モニターの出力とともに出力されるため、ロックモニターの出力を有効にするには、両方のモニターを有効にする必要があります。
    </p><pre class="programlisting">
set GLOBAL innodb_status_output=ON;
set GLOBAL innodb_status_output_locks=ON;
</pre><p>
      サーバーをシャットダウンすると、<code class="literal">innodb_status_output</code> および <code class="literal">innodb_status_output_locks</code> 変数がデフォルトの <code class="literal">OFF</code> 値に設定されます。
    </p><p>
      <code class="literal">InnoDB</code> ロックモニターを無効にするには、<code class="literal">innodb_status_output_locks</code> を <code class="literal">OFF</code> に設定します。<code class="literal">InnoDB</code> 標準モニターも無効にするには、<code class="literal">innodb_status_output</code> を OFF に設定します。
    </p><h4><a name="idm139979062257440"></a>InnoDB テーブルスペースモニターの有効化</h4><p>
      <code class="literal">InnoDB</code> テーブルスペースモニターでの定期的な出力を有効にするには、<code class="literal">innodb_tablespace_monitor</code> テーブルを作成します。
    </p><pre class="programlisting">
CREATE TABLE innodb_tablespace_monitor (a INT) ENGINE=INNODB;
</pre><p>
      標準の <code class="literal">InnoDB</code> テーブルスペースモニターを無効にするには、そのテーブルを削除します。
    </p><pre class="programlisting">
DROP TABLE innodb_tablespace_monitor;
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        テーブルスペースモニターは非推奨であり、将来の MySQL リリースで削除される予定です。
      </p></div><h4><a name="idm139979062250704"></a>InnoDB テーブルモニターの有効化</h4><p>
      <code class="literal">InnoDB</code> テーブルモニターでの定期的な出力を有効にするには、<code class="literal">innodb_table_monitor</code> テーブルを作成します。
    </p><pre class="programlisting">
CREATE TABLE innodb_table_monitor (a INT) ENGINE=INNODB;
</pre><p>
      <code class="literal">InnoDB</code> テーブルモニターを無効にするには、そのテーブルを削除します。
    </p><pre class="programlisting">
DROP TABLE innodb_table_monitor;
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        テーブルスペースモニターは非推奨であり、将来の MySQL リリースで削除される予定です。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-standard-monitor"></a>14.15.3 InnoDB 標準モニターおよびロックモニターの出力</h3></div></div></div><p>
      ロックモニターは、追加のロック情報を含んでいる点を除き、標準モニターと同じです。どちらのモニターの定期的な出力を有効にしても、同じ出力ストリームが有効になりますが、ロックモニターが有効になっている場合は、そのストリームに追加の情報が含まれます。たとえば、<code class="literal">InnoDB</code> 標準モニターおよび <code class="literal">InnoDB</code> ロックモニターを有効にすると、1 つの出力ストリームが有効になります。ロックモニターを無効にするまで、そのストリームには追加のロック情報が含まれます。
    </p><p>
      InnoDB モニターの出力例 (MySQL 5.6.22 の時点):
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW ENGINE INNODB STATUS\G</code></strong>
*************************** 1. row ***************************
  Type: InnoDB
  Name: 
Status: 
=====================================
2014-10-17 10:33:50 7f47bcd64700 INNODB MONITOR OUTPUT
=====================================
Per second averages calculated from the last 6 seconds
-----------------
BACKGROUND THREAD
-----------------
srv_master_thread loops: 167 srv_active, 0 srv_shutdown, 3023 srv_idle
srv_master_thread log flush and writes: 3190
----------
SEMAPHORES
----------
OS WAIT ARRAY INFO: reservation count 1040
OS WAIT ARRAY INFO: signal count 959
Mutex spin waits 677, rounds 20336, OS waits 644
RW-shared spins 180, rounds 5400, OS waits 180
RW-excl spins 0, rounds 6420, OS waits 214
Spin rounds per wait: 30.04 mutex, 30.00 RW-shared, 6420.00 RW-excl
------------------------
LATEST FOREIGN KEY ERROR
------------------------
2014-10-17 09:51:31 7f47bcde6700 Transaction:
TRANSACTION 436786, ACTIVE 0 sec inserting
mysql tables in use 1, locked 1
4 lock struct(s), heap size 1184, 3 row lock(s), undo log entries 3
MySQL thread id 1, OS thread handle 0x7f47bcde6700, query id 96 localhost 
root update
INSERT INTO child VALUES
    (NULL, 1)
    , (NULL, 2)
    , (NULL, 3)
    , (NULL, 4)
    , (NULL, 5)
    , (NULL, 6)
Foreign key constraint fails for table `mysql`.`child`:
,
  CONSTRAINT `child_ibfk_1` FOREIGN KEY (`parent_id`) REFERENCES `parent` 
  (`id`)
 ON DELETE CASCADE ON UPDATE CASCADE
Trying to add in child table, in index `par_ind` tuple:
DATA TUPLE: 2 fields;
 0: len 4; hex 80000003; asc     ;;
 1: len 4; hex 80000003; asc     ;;

But in parent table `mysql`.`parent`, in index `PRIMARY`,
the closest match we can find is record:
PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 80000004; asc     ;;
 1: len 6; hex 00000006aa26; asc      &amp;;;
 2: len 7; hex 9d000001610137; asc     a 7;;
------------------------
LATEST DETECTED DEADLOCK
------------------------
2014-10-17 09:52:38 7f47bcde6700
*** (1) TRANSACTION:
TRANSACTION 436801, ACTIVE 12 sec starting index read
mysql tables in use 1, locked 1
LOCK WAIT 2 lock struct(s), heap size 360, 1 row lock(s)
MySQL thread id 2, OS thread handle 0x7f47bcda5700, query id 102 localhost 
root updating
DELETE FROM t WHERE i = 1
*** (1) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 3693 page no 3 n bits 72 index `GEN_CLUST_INDEX` of 
table `mysql`.`t` trx id 436801 lock_mode X waiting
Record lock, heap no 2 PHYSICAL RECORD: n_fields 4; compact format; info 
bits 0
 0: len 6; hex 000000003a00; asc     : ;;
 1: len 6; hex 00000006aa3f; asc      ?;;
 2: len 7; hex ad0000021d0110; asc        ;;
 3: len 4; hex 80000001; asc     ;;

*** (2) TRANSACTION:
TRANSACTION 436800, ACTIVE 34 sec starting index read
mysql tables in use 1, locked 1
4 lock struct(s), heap size 1184, 3 row lock(s)
MySQL thread id 1, OS thread handle 0x7f47bcde6700, query id 103 localhost 
root updating
DELETE FROM t WHERE i = 1
*** (2) HOLDS THE LOCK(S):
RECORD LOCKS space id 3693 page no 3 n bits 72 index `GEN_CLUST_INDEX` of 
table `mysql`.`t` trx id 436800 lock mode S
Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info 
bits 0 0: len 8; hex 73757072656d756d; asc supremum;;

Record lock, heap no 2 PHYSICAL RECORD: n_fields 4; compact format; info 
bits 0
 0: len 6; hex 000000003a00; asc     : ;;
 1: len 6; hex 00000006aa3f; asc      ?;;
 2: len 7; hex ad0000021d0110; asc        ;;
 3: len 4; hex 80000001; asc     ;;

*** (2) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 3693 page no 3 n bits 72 index `GEN_CLUST_INDEX` of 
table `mysql`.`t` trx id 436800 lock_mode X waiting
Record lock, heap no 2 PHYSICAL RECORD: n_fields 4; compact format; info 
bits 0
 0: len 6; hex 000000003a00; asc     : ;;
 1: len 6; hex 00000006aa3f; asc      ?;;
 2: len 7; hex ad0000021d0110; asc        ;;
 3: len 4; hex 80000001; asc     ;;

*** WE ROLL BACK TRANSACTION (1)
------------
TRANSACTIONS
------------
Trx id counter 437661
Purge done for trx's n:o &lt; 437657 undo n:o &lt; 0 state: running but 
idle History list length 371
LIST OF TRANSACTIONS FOR EACH SESSION:
---TRANSACTION 0, not started
MySQL thread id 10, OS thread handle 0x7f47bcd64700, query id 1001 localhost
root init
SHOW ENGINE INNODB STATUS
---TRANSACTION 436801, not started
MySQL thread id 2, OS thread handle 0x7f47bcda5700, query id 102 localhost 
root ceaning up
---TRANSACTION 437660, ACTIVE 0 sec inserting
mysql tables in use 1, locked 1
43 lock struct(s), heap size 6544, 6474 row lock(s), undo log entries 7124
MySQL thread id 14, OS thread handle 0x7f47bcde6700, query id 1000 localhost 
root update
INSERT INTO `dept_emp` VALUES (100258,'d002','1994-03-21','9999-01-01'),
(100259, 'd005','1998-11-04','9999-01-01'),(100259,'d008','1988-02-03',
'1998-11-04'),(100 260,'d005','1998-09-18','9999-01-01'),(100261,'d004',
'1989-03-11','9999-01-01'), (100262,'d008','1996-08-12','9999-01-01'),
(100263,'d002','1998-06-24','1998-10-0 5'),(100264,'d005','1989-11-09',
'9999-01-01'),(100265,'d001','1992-06-27','9999- 01-01'),(100266,'d009',
'1990-09-10','9999-01-01'),(100267,'d009','1992-04-14','9 999-01-01'),
(100268,'d005','1998-05-01','2000-04-07'),(100269,'d007','1994-01-02',
'1999-09-18'),(100269,'d009','1999-09-
--------
FILE I/O
--------
I/O thread 0 state: waiting for completed aio requests (insert buffer thread)
I/O thread 1 state: waiting for completed aio requests (log thread)
I/O thread 2 state: waiting for completed aio requests (read thread)
I/O thread 3 state: waiting for completed aio requests (read thread)
I/O thread 4 state: waiting for completed aio requests (read thread)
I/O thread 5 state: waiting for completed aio requests (read thread)
I/O thread 6 state: waiting for completed aio requests (write thread)
I/O thread 7 state: waiting for completed aio requests (write thread)
I/O thread 8 state: waiting for completed aio requests (write thread)
I/O thread 9 state: waiting for completed aio requests (write thread)
Pending normal aio reads: 0 [0, 0, 0, 0] , aio writes: 0 [0, 0, 0, 0] ,
 ibuf aio reads: 0, log i/o's: 0, sync i/o's: 0
Pending flushes (fsync) log: 0; buffer pool: 0
344 OS file reads, 45666 OS file writes, 4030 OS fsyncs
0.00 reads/s, 0 avg bytes/read, 202.80 writes/s, 48.33 fsyncs/s
-------------------------------------
INSERT BUFFER AND ADAPTIVE HASH INDEX
-------------------------------------
Ibuf: size 1, free list len 0, seg size 2, 0 merges
merged operations:
 insert 0, delete mark 0, delete 0
discarded operations:
 insert 0, delete mark 0, delete 0
Hash table size 4425293, node heap has 143 buffer(s)
137083.82 hash searches/s, 2495.92 non-hash searches/s
---
LOG
---
Log sequence number 3091027710
Log flushed up to   3090240098
Pages flushed up to 3074432960
Last checkpoint at  3050856266
0 pending log writes, 0 pending chkp writes
1187 log i/o's done, 14.67 log i/o's/second
----------------------
BUFFER POOL AND MEMORY
----------------------
Total memory allocated 2197815296; in additional pool allocated 0
Dictionary memory allocated 155455
Buffer pool size   131071
Free buffers       92158
Database pages     38770
Old database pages 14271
Modified db pages  619
Pending reads 0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 4, not young 0
0.00 youngs/s, 0.00 non-youngs/s
Pages read 322, created 38448, written 42083
0.00 reads/s, 222.30 creates/s, 159.47 writes/s
Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 
0.00/s
LRU len: 38770, unzip_LRU len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
----------------------
INDIVIDUAL BUFFER POOL INFO
----------------------
---BUFFER POOL 0
Buffer pool size   65536
Free buffers       46120
Database pages     19345
Old database pages 7121
Modified db pages  291
Pending reads 0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 3, not young 0
0.00 youngs/s, 0.00 non-youngs/s
Pages read 163, created 19182, written 21149
0.00 reads/s, 103.48 creates/s, 83.15 writes/s
Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 
0.00/s
LRU len: 19345, unzip_LRU len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
---BUFFER POOL 1
Buffer pool size   65535
Free buffers       46038
Database pages     19425
Old database pages 7150
Modified db pages  328
Pending reads 0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 1, not young 0
0.00 youngs/s, 0.00 non-youngs/s
Pages read 159, created 19266, written 20934
0.00 reads/s, 118.81 creates/s, 76.32 writes/s
Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 
0.00/s
LRU len: 19425, unzip_LRU len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
--------------
ROW OPERATIONS
--------------
0 queries inside InnoDB, 0 queries in queue
0 read views open inside InnoDB
Main thread process no. 54607, id 139946075744000, state: sleeping
Number of rows inserted 12163964, updated 0, deleted 3, read 4
67807.03 inserts/s, 0.00 updates/s, 0.00 deletes/s, 0.00 reads/s
----------------------------
END OF INNODB MONITOR OUTPUT
============================
</pre><p>
      <code class="literal">SHOW ENGINE INNODB STATUS</code> ステートメントを使用して生成された場合、<code class="literal">InnoDB</code> 標準モニターの出力は 1M バイトに制限されます。この制限は、サーバーのエラー出力に書き込まれる出力には適用されません。
    </p><p>
      出力のセクションに関するいくつかの注意点:
    </p><p>
      <span class="bold"><strong><code class="literal">Status</code></strong></span>
    </p><p>
      このセクションは、タイムスタンプ、モニター名、および 1 秒あたりの平均の基になる秒数を示します。この秒数は、現在の時間と <code class="literal">InnoDB</code> モニターの出力が最後に出力された時間の間の経過時間です。
    </p><p>
      <span class="bold"><strong><code class="literal">BACKGROUND THREAD</code></strong></span>
    </p><p>
      <code class="literal">srv_master_thread</code> 行は、メインのバックグラウンドスレッドによって実行された作業を示します。
    </p><p>
      <span class="bold"><strong><code class="literal">SEMAPHORES</code></strong></span>
    </p><p>
      このセクションは、セマフォーを待機しているスレッド、およびスレッドが相互排他ロックまたは読み書きロックセマフォーでスピンまたは待機を必要とした回数に関する統計をレポートします。多数のスレッドがセマフォーを待機している場合は、ディスク I/O または <code class="literal">InnoDB</code> 内部の競合の問題の結果である可能性があります。競合は、クエリーの高い並列性、またはオペレーティングシステムのスレッドスケジューリングでの問題が原因である場合があります。このような状況では、<code class="literal">innodb_thread_concurrency</code> システム変数をデフォルト値より小さい値に設定すると役立つことがあります。<code class="literal">Spin rounds per wait</code> 行は、相互排他ロックでの OS ウェイトあたりのスピンロックラウンドの数を示します。
    </p><p>
      <span class="bold"><strong><code class="literal">LATEST FOREIGN KEY ERROR</code></strong></span>
    </p><p>
      このセクションは、最新の外部キー制約エラーに関する情報を提供します。このようなエラーが発生していない場合は存在しません。その内容には、失敗したステートメントのほか、失敗した制約や、参照されるテーブルと参照するテーブルに関する情報が含まれます。
    </p><p>
      <span class="bold"><strong><code class="literal">LATEST DETECTED DEADLOCK</code></strong></span>
    </p><p>
      このセクションは、最新のデッドロックに関する情報を提供します。デッドロックが発生していない場合は存在しません。その内容には、関連しているトランザクション、各トランザクションが実行しようとしていたステートメント、それぞれが保持しているロックと必要なロック、およびデッドロックを解消するために <code class="literal">InnoDB</code> がロールバックすることを決定したトランザクションが示されます。このセクションでレポートされるロックモードについては、<a class="xref" href="innodb-storage-engine.html#innodb-lock-modes" title="14.2.3 InnoDB のロックモード">セクション14.2.3「InnoDB のロックモード」</a>で説明されています。
    </p><p>
      <span class="bold"><strong><code class="literal">TRANSACTIONS</code></strong></span>
    </p><p>
      このセクションでロック待機がレポートされている場合は、アプリケーションでロック競合が発生している可能性があります。この出力はまた、トランザクションデッドロックの原因の追跡にも役立つことがあります。
    </p><p>
      <span class="bold"><strong><code class="literal">FILE I/O</code></strong></span>
    </p><p>
      このセクションは、<code class="literal">InnoDB</code> がさまざまなタイプの I/O を実行するために使用するスレッドに関する情報を提供します。このうちの最初の数行は、<code class="literal">InnoDB</code> の一般的な処理に専用に使用されます。この内容には、保留中の I/O 操作や I/O パフォーマンスの統計に関する情報も表示されます。
    </p><p>
      これらのスレッドの数は、<code class="literal">innodb_read_io_threads</code> および <code class="literal">innodb_write_io_threads</code> パラメータによって制御されます。<a class="xref" href="innodb-storage-engine.html#innodb-parameters" title="14.12 InnoDB の起動オプションおよびシステム変数">セクション14.12「InnoDB の起動オプションおよびシステム変数」</a>を参照してください。
    </p><p>
      <span class="bold"><strong><code class="literal">INSERT BUFFER AND ADAPTIVE HASH INDEX</code></strong></span>
    </p><p>
      このセクションは、<code class="literal">InnoDB</code> 挿入バッファーおよびアダプティブハッシュインデックスのステータスを示します。(<a class="xref" href="innodb-storage-engine.html#innodb-insert-buffering" title="14.2.13.5 挿入バッファー">セクション14.2.13.5「挿入バッファー」</a>および<a class="xref" href="innodb-storage-engine.html#innodb-adaptive-hash" title="14.2.13.6 適応型ハッシュインデックス">セクション14.2.13.6「適応型ハッシュインデックス」</a>を参照してください。)その内容には、それぞれに対して実行された操作の数のほか、ハッシュインデックスのパフォーマンスの統計が含まれます。
    </p><p>
      <span class="bold"><strong><code class="literal">LOG</code></strong></span>
    </p><p>
      このセクションには、<code class="literal">InnoDB</code> のログに関する情報が表示されます。その内容には、現在のログシーケンス番号、ログがディスクにフラッシュされた範囲、および <code class="literal">InnoDB</code> が最後にチェックポイントを取得した位置が含まれます。(<a class="xref" href="innodb-storage-engine.html#innodb-checkpoints" title="14.10.3 InnoDB チェックポイント">セクション14.10.3「InnoDB チェックポイント」</a>を参照してください。)このセクションには、保留中の書き込みや書き込みパフォーマンスの統計に関する情報も表示されます。
    </p><p>
      <span class="bold"><strong><code class="literal">BUFFER POOL AND MEMORY</code></strong></span>
    </p><p>
      このセクションは、読み取られたページと書き込まれたページに関する統計を提供します。これらの数値から、現在クエリーが実行しているデータファイル I/O 操作の数を計算できます。
    </p><p>
      バッファープールの操作の詳細は、<a class="xref" href="optimization.html#innodb-buffer-pool" title="8.9.1 InnoDB バッファープール">セクション8.9.1「InnoDB バッファープール」</a>を参照してください。
    </p><p>
      <span class="bold"><strong><code class="literal">ROW OPERATIONS</code></strong></span>
    </p><p>
      このセクションは、メインスレッドが実行している内容 (各タイプの行操作の数とパフォーマンスレートを含む) を示します。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-tablespace-monitor"></a>14.15.4 InnoDB テーブルスペースモニターの出力</h3></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">InnoDB</code> テーブルスペースモニターは非推奨であり、将来のリリースで削除される可能性があります。
      </p></div><p>
      <code class="literal">InnoDB</code> テーブルスペースモニターは、共有テーブルスペース内のファイルセグメントに関する情報を出力したり、テーブルスペースの割り当てデータ構造を検証したりします。テーブルスペースモニターでは、<code class="literal">innodb_file_per_table</code> オプションで作成された file-per-table テーブルスペースは記載されません。
    </p><p>
      <code class="literal">InnoDB</code> テーブルスペースモニターの出力例:
    </p><pre class="programlisting">
================================================
090408 21:28:09 INNODB TABLESPACE MONITOR OUTPUT
================================================
FILE SPACE INFO: id 0
size 13440, free limit 3136, free extents 28
not full frag extents 2: used pages 78, full frag extents 3
first seg id not used 0 23845
SEGMENT id 0 1 space 0; page 2; res 96 used 46; full ext 0
fragm pages 32; free extents 0; not full extents 1: pages 14
SEGMENT id 0 2 space 0; page 2; res 1 used 1; full ext 0
fragm pages 1; free extents 0; not full extents 0: pages 0
SEGMENT id 0 3 space 0; page 2; res 1 used 1; full ext 0
fragm pages 1; free extents 0; not full extents 0: pages 0
...
SEGMENT id 0 15 space 0; page 2; res 160 used 160; full ext 2
fragm pages 32; free extents 0; not full extents 0: pages 0
SEGMENT id 0 488 space 0; page 2; res 1 used 1; full ext 0
fragm pages 1; free extents 0; not full extents 0: pages 0
SEGMENT id 0 17 space 0; page 2; res 1 used 1; full ext 0
fragm pages 1; free extents 0; not full extents 0: pages 0
...
SEGMENT id 0 171 space 0; page 2; res 592 used 481; full ext 7
fragm pages 16; free extents 0; not full extents 2: pages 17
SEGMENT id 0 172 space 0; page 2; res 1 used 1; full ext 0
fragm pages 1; free extents 0; not full extents 0: pages 0
SEGMENT id 0 173 space 0; page 2; res 96 used 44; full ext 0
fragm pages 32; free extents 0; not full extents 1: pages 12
...
SEGMENT id 0 601 space 0; page 2; res 1 used 1; full ext 0
fragm pages 1; free extents 0; not full extents 0: pages 0
NUMBER of file segments: 73
Validating tablespace
Validation ok
---------------------------------------
END OF INNODB TABLESPACE MONITOR OUTPUT
=======================================
</pre><p>
      テーブルスペースモニターの出力には、共有テーブルスペースに関する全体的な情報のあとに、テーブルスペース内のセグメントごとの内訳を含むリストが含まれます。
    </p><p>
      デフォルトの<a class="link" href="glossary.html#glos_page_size" title="page size">ページサイズ</a>を使用したこの例では、テーブルスペースが、それぞれ 16K バイトであるデータベースページで構成されています。これらのページは、サイズが 1M バイト (64 個の連続したページ) の<a class="link" href="glossary.html#glos_extent" title="エクステント">エクステント</a>にグループ化されています。
    </p><p>
      全体的なテーブルスペース情報を表示する出力の最初の部分の形式は次のとおりです。
    </p><pre class="programlisting">
FILE SPACE INFO: id 0
size 13440, free limit 3136, free extents 28
not full frag extents 2: used pages 78, full frag extents 3
first seg id not used 0 23845
</pre><p>
      全体的なテーブルスペース情報には、次の値が含まれます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">id</code>: テーブルスペース ID。0 の値は、共有テーブルスペースを示します。
        </p></li><li class="listitem"><p>
          <code class="literal">size</code>: 現在のテーブルスペースサイズ (ページ数)。
        </p></li><li class="listitem"><p>
          <code class="literal">free limit</code>: 空きリストが初期化されていない最小のページ番号。この制限の位置にあるページ、またはそれより上のページは空いています。
        </p></li><li class="listitem"><p>
          <code class="literal">free extents</code>: 空きエクステントの数。
        </p></li><li class="listitem"><p>
          <code class="literal">not full frag extents</code>、<code class="literal">used pages</code>: 完全にはいっぱいになっていないフラグメントエクステントの数、およびこれらのエクステント内の割り当てられたページの数。
        </p></li><li class="listitem"><p>
          <code class="literal">full frag extents</code>: 完全にいっぱいになっているフラグメントエクステントの数。
        </p></li><li class="listitem"><p>
          <code class="literal">first seg id not used</code>: 使用されていない最初のセグメント ID。
        </p></li></ul></div><p>
      個々のセグメント情報の形式は次のとおりです。
    </p><pre class="programlisting">
SEGMENT id 0 15 space 0; page 2; res 160 used 160; full ext 2
fragm pages 32; free extents 0; not full extents 0: pages 0
</pre><p>
      セグメント情報には、次の値が含まれます。
    </p><p>
      <code class="literal">id</code>: セグメント ID。
    </p><p>
      <code class="literal">space</code>、<code class="literal">page</code>: テーブルスペース番号、およびこのセグメントの<span class="quote">「<span class="quote">i ノード</span>」</span>が格納されているテーブルスペース内のページ。0 のテーブルスペース番号は、共有テーブルスペースを示します。<code class="literal">InnoDB</code> は、i ノードを使用してテーブルスペース内のセグメントを追跡します。セグメントに関して表示されるその他のフィールド (<code class="literal">id</code> や <code class="literal">res</code> など) は、i ノード内の情報から取得されます。
    </p><p>
      <code class="literal">res</code>: このセグメントに割り当てられている (予約されている) ページの数。
    </p><p>
      <code class="literal">used</code>: このセグメントで使用されている割り当てられたページの数。
    </p><p>
      <code class="literal">full ext</code>: このセグメントに割り当てられたエクステントのうち、完全に使用されているものの数。
    </p><p>
      <code class="literal">fragm pages</code>: このセグメントに割り当てられた最初のページの数。
    </p><p>
      <code class="literal">free extents</code>: このセグメントに割り当てられたエクステントのうち、完全に未使用であるものの数。
    </p><p>
      <code class="literal">not full extents</code>: このセグメントに割り当てられたエクステントのうち、部分的に使用されているものの数。
    </p><p>
      <code class="literal">pages</code>: いっぱいになっていないエクステント内で使用されているページの数。
    </p><p>
      セグメントが拡張される場合、そのセグメントは 1 ページとして開始されますが、<code class="literal">InnoDB</code> は最初の数ページ (最大 32 ページ、これは <code class="literal">fragm pages</code> 値です) を一度に割り当てます。そのあと、<code class="literal">InnoDB</code> は完全なエクステントを割り当てます。<code class="literal">InnoDB</code> は、データの良好な連続性を保証するために、大きなセグメントには 1 回につき最大 4 つのエクステントを追加できます。
    </p><p>
      前に示されたセグメントの例では、32 個のフラグメントページに加え、いっぱいになったエクステントが 2 つあり (それぞれ 64 ページ)、割り当てられた 160 ページのうち合計 160 ページが使用されています。次のセグメントには、32 個のフラグメントページと、14 ページを使用している部分的にいっぱいになったエクステントが 1 つあり、割り当てられた 96 ページのうち合計 46 ページが使用されています。
    </p><pre class="programlisting">
SEGMENT id 0 1 space 0; page 2; res 96 used 46; full ext 0
fragm pages 32; free extents 0; not full extents 1: pages 14
</pre><p>
      エクステントの割り当てのあとに個々のページのいくつかが解放された場合は、エクステントが割り当てられているセグメントの <code class="literal">fragm pages</code> 値が 32 より小さい可能性があります。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-table-monitor"></a>14.15.5 InnoDB テーブルモニターの出力</h3></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <code class="literal">InnoDB</code> テーブルモニターは非推奨であり、将来のリリースで削除される可能性があります。同様の情報は、<code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code> テーブルから取得できます。<a class="xref" href="information-schema.html#innodb-i_s-tables" title="21.29 InnoDB の INFORMATION_SCHEMA テーブル">セクション21.29「InnoDB の INFORMATION_SCHEMA テーブル」</a>を参照してください。
      </p></div><p>
      <code class="literal">InnoDB</code> テーブルモニターは、<code class="literal">InnoDB</code> 内部データディクショナリの内容を出力します。
    </p><p>
      この出力には、テーブルごとに 1 つのセクションが含まれます。<code class="literal">SYS_FOREIGN</code> および <code class="literal">SYS_FOREIGN_COLS</code> セクションは、外部キーに関する情報を保持する内部データディクショナリテーブルのためのものです。また、テーブルモニターのテーブルや、ユーザーが作成した各 <code class="literal">InnoDB</code> テーブルのためのセクションもあります。<code class="literal">test</code> データベース内に次の 2 つのテーブルが作成されたとします。
    </p><pre class="programlisting">
CREATE TABLE parent
(
  par_id    INT NOT NULL,
  fname      CHAR(20),
  lname      CHAR(20),
  PRIMARY KEY (par_id),
  UNIQUE INDEX (lname, fname)
) ENGINE = INNODB;

CREATE TABLE child
(
  par_id      INT NOT NULL,
  child_id    INT NOT NULL,
  name        VARCHAR(40),
  birth       DATE,
  weight      DECIMAL(10,2),
  misc_info   VARCHAR(255),
  last_update TIMESTAMP,
  PRIMARY KEY (par_id, child_id),
  INDEX (name),
  FOREIGN KEY (par_id) REFERENCES parent (par_id)
    ON DELETE CASCADE
    ON UPDATE CASCADE
) ENGINE = INNODB;
</pre><p>
      この場合、テーブルモニターの出力は次のようになります (形式を少し変更しました)。
    </p><pre class="programlisting">
===========================================
090420 12:09:32 INNODB TABLE MONITOR OUTPUT
===========================================
--------------------------------------
TABLE: name SYS_FOREIGN, id 0 11, columns 7, indexes 3, appr.rows 1
  COLUMNS: ID: DATA_VARCHAR DATA_ENGLISH len 0;
           FOR_NAME: DATA_VARCHAR DATA_ENGLISH len 0;
           REF_NAME: DATA_VARCHAR DATA_ENGLISH len 0;
           N_COLS: DATA_INT len 4;
           DB_ROW_ID: DATA_SYS prtype 256 len 6;
           DB_TRX_ID: DATA_SYS prtype 257 len 6;
  INDEX: name ID_IND, id 0 11, fields 1/6, uniq 1, type 3
   root page 46, appr.key vals 1, leaf pages 1, size pages 1
   FIELDS:  ID DB_TRX_ID DB_ROLL_PTR FOR_NAME REF_NAME N_COLS
  INDEX: name FOR_IND, id 0 12, fields 1/2, uniq 2, type 0
   root page 47, appr.key vals 1, leaf pages 1, size pages 1
   FIELDS:  FOR_NAME ID
  INDEX: name REF_IND, id 0 13, fields 1/2, uniq 2, type 0
   root page 48, appr.key vals 1, leaf pages 1, size pages 1
   FIELDS:  REF_NAME ID
--------------------------------------
TABLE: name SYS_FOREIGN_COLS, id 0 12, columns 7, indexes 1, appr.rows 1
  COLUMNS: ID: DATA_VARCHAR DATA_ENGLISH len 0;
           POS: DATA_INT len 4;
           FOR_COL_NAME: DATA_VARCHAR DATA_ENGLISH len 0;
           REF_COL_NAME: DATA_VARCHAR DATA_ENGLISH len 0;
           DB_ROW_ID: DATA_SYS prtype 256 len 6;
           DB_TRX_ID: DATA_SYS prtype 257 len 6;
  INDEX: name ID_IND, id 0 14, fields 2/6, uniq 2, type 3
   root page 49, appr.key vals 1, leaf pages 1, size pages 1
   FIELDS:  ID POS DB_TRX_ID DB_ROLL_PTR FOR_COL_NAME REF_COL_NAME
--------------------------------------
TABLE: name test/child, id 0 14, columns 10, indexes 2, appr.rows 201
  COLUMNS: par_id: DATA_INT DATA_BINARY_TYPE DATA_NOT_NULL len 4;
           child_id: DATA_INT DATA_BINARY_TYPE DATA_NOT_NULL len 4;
           name: DATA_VARCHAR prtype 524303 len 40;
           birth: DATA_INT DATA_BINARY_TYPE len 3;
           weight: DATA_FIXBINARY DATA_BINARY_TYPE len 5;
           misc_info: DATA_VARCHAR prtype 524303 len 255;
           last_update: DATA_INT DATA_UNSIGNED DATA_BINARY_TYPE DATA_NOT_NULL len 4;
           DB_ROW_ID: DATA_SYS prtype 256 len 6;
           DB_TRX_ID: DATA_SYS prtype 257 len 6;
  INDEX: name PRIMARY, id 0 17, fields 2/9, uniq 2, type 3
   root page 52, appr.key vals 201, leaf pages 5, size pages 6
   FIELDS:  par_id child_id DB_TRX_ID DB_ROLL_PTR name birth weight misc_info last_update
  INDEX: name name, id 0 18, fields 1/3, uniq 3, type 0
   root page 53, appr.key vals 210, leaf pages 1, size pages 1
   FIELDS:  name par_id child_id
  FOREIGN KEY CONSTRAINT test/child_ibfk_1: test/child ( par_id )
             REFERENCES test/parent ( par_id )
--------------------------------------
TABLE: name test/innodb_table_monitor, id 0 15, columns 4, indexes 1, appr.rows 0
  COLUMNS: i: DATA_INT DATA_BINARY_TYPE len 4;
           DB_ROW_ID: DATA_SYS prtype 256 len 6;
           DB_TRX_ID: DATA_SYS prtype 257 len 6;
  INDEX: name GEN_CLUST_INDEX, id 0 19, fields 0/4, uniq 1, type 1
   root page 193, appr.key vals 0, leaf pages 1, size pages 1
   FIELDS:  DB_ROW_ID DB_TRX_ID DB_ROLL_PTR i
--------------------------------------
TABLE: name test/parent, id 0 13, columns 6, indexes 2, appr.rows 299
  COLUMNS: par_id: DATA_INT DATA_BINARY_TYPE DATA_NOT_NULL len 4;
           fname: DATA_CHAR prtype 524542 len 20;
           lname: DATA_CHAR prtype 524542 len 20;
           DB_ROW_ID: DATA_SYS prtype 256 len 6;
           DB_TRX_ID: DATA_SYS prtype 257 len 6;
  INDEX: name PRIMARY, id 0 15, fields 1/5, uniq 1, type 3
   root page 50, appr.key vals 299, leaf pages 2, size pages 3
   FIELDS:  par_id DB_TRX_ID DB_ROLL_PTR fname lname
  INDEX: name lname, id 0 16, fields 2/3, uniq 2, type 2
   root page 51, appr.key vals 300, leaf pages 1, size pages 1
   FIELDS:  lname fname par_id
  FOREIGN KEY CONSTRAINT test/child_ibfk_1: test/child ( par_id )
             REFERENCES test/parent ( par_id )
-----------------------------------
END OF INNODB TABLE MONITOR OUTPUT
==================================
</pre><p>
      テーブルモニターの出力には、テーブルごとに、そのテーブルに関する一般的な情報と、そのカラム、インデックス、および外部キーに関する固有の情報を表示するセクションが含まれます。
    </p><p>
      テーブルごとの一般的な情報には、テーブル名 (内部テーブルを除き、<code class="literal"><em class="replaceable"><code>db_name</code></em>/<em class="replaceable"><code>tbl_name</code></em></code> の形式)、その ID、カラムとインデックスの数、および概略の行数が含まれます。
    </p><p>
      テーブルセクションの <code class="literal">COLUMNS</code> の部分には、テーブル内の各カラムが一覧表示されます。カラムごとの情報には、その名前とデータ型の特性が示されます。<code class="literal">InnoDB</code> によって、<code class="literal">DB_ROW_ID</code> (行 ID)、<code class="literal">DB_TRX_ID</code> (トランザクション ID)、<code class="literal">DB_ROLL_PTR</code> (ロールバック/Undo データへのポインタ) などのいくつかの内部カラムが追加されます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">DATA_<em class="replaceable"><code>xxx</code></em></code>: これらのシンボルはデータ型を示します。特定のカラムについて、複数の <code class="literal">DATA_<em class="replaceable"><code>xxx</code></em></code> シンボルが存在する可能性があります。
        </p></li><li class="listitem"><p>
          <code class="literal">prtype</code>: そのカラムの<span class="quote">「<span class="quote">正確な</span>」</span>型。このフィールドには、そのカラムのデータ型、文字セットコード、NULL 可能性、符号の有無、それがバイナリ文字列であるかどうかなどの情報が含まれます。このフィールドについては、<code class="filename">innobase/include/data0type.h</code> ソースファイルで説明されています。
        </p></li><li class="listitem"><p>
          <code class="literal">len</code>: カラムの長さ (バイト単位)。
        </p></li></ul></div><p>
      テーブルセクションの各 <code class="literal">INDEX</code> の部分は、1 つのテーブルインデックスの名前と特性を提供します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">name</code>: インデックス名。この名前が <code class="literal">PRIMARY</code> である場合、そのインデックスは主キーです。この名前が <code class="literal">GEN_CLUST_INDEX</code> である場合、そのインデックスは、テーブル定義に主キーや <code class="literal">NULL</code> 以外の一意のインデックスが含まれていないときに自動的に作成されるクラスタ化されたインデックスです。<a class="xref" href="innodb-storage-engine.html#innodb-index-types" title="14.2.13.2 クラスタインデックスとセカンダリインデックス">セクション14.2.13.2「クラスタインデックスとセカンダリインデックス」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">id</code>: インデックス ID。
        </p></li><li class="listitem"><p>
          <code class="literal">fields</code>: インデックス内のフィールドの数。<code class="literal"><em class="replaceable"><code>m</code></em>/<em class="replaceable"><code>n</code></em></code> という形式の値です。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <em class="replaceable"><code>m</code></em> はユーザー定義のカラムの数です。つまり、<code class="literal">CREATE TABLE</code> ステートメントのインデックス定義に表示されるカラム数です。
            </p></li><li class="listitem"><p>
              <em class="replaceable"><code>n</code></em> は、内部的に追加されたものを含むインデックスカラムの総数です。クラスタ化されたインデックスの場合、この総数には、テーブル定義内のほかのカラムに加えて、内部的に追加されたすべてのカラムが含まれます。セカンダリインデックスの場合、この総数には、セカンダリインデックスには含まれていない主キーのカラムが含まれます。
            </p></li></ul></div></li><li class="listitem"><p>
          <code class="literal">uniq</code>: インデックス値を一意に特定するために十分な先頭フィールドの数。
        </p></li><li class="listitem"><p>
          <code class="literal">type</code>: インデックスタイプ。これはビットフィールドです。たとえば、1 はクラスタ化されたインデックスを示し、2 は一意のインデックスを示すため、クラスタ化されたインデックス (常に一意の値を含みます) の <code class="literal">type</code> 値は 3 になります。<code class="literal">type</code> 値が 0 であるインデックスは、クラスタ化されたインデックスでも一意のインデックスでもありません。これらのフラグ値は、<code class="filename">innobase/include/dict0mem.h</code> ソースファイルで定義されています。
        </p></li><li class="listitem"><p>
          <code class="literal">root page</code>: インデックスのルートページ番号。
        </p></li><li class="listitem"><p>
          <code class="literal">appr. key vals</code>: 概略のインデックスカーディナリティー。
        </p></li><li class="listitem"><p>
          <code class="literal">leaf pages</code>: インデックス内のリーフページの概数。
        </p></li><li class="listitem"><p>
          <code class="literal">size pages</code>: インデックス内の概略のページの総数。
        </p></li><li class="listitem"><p>
          <code class="literal">FIELDS</code>: インデックス内のフィールドの名前。自動的に生成されたクラスタ化されたインデックスの場合、このフィールドリストは、内部の <code class="literal">DB_ROW_ID</code> (行 ID) フィールドで始まります。クラスタ化されたインデックスには、主キーを構成するフィールドに続けて、常に <code class="literal">DB_TRX_ID</code> と <code class="literal">DB_ROLL_PTR</code> が内部的に追加されます。セカンダリインデックスの場合、最後の数フィールドは、セカンダリインデックスには含まれていない主キーのフィールドです。
        </p></li></ul></div><p>
      テーブルセクションの最後には、そのテーブルに適用される <code class="literal">FOREIGN KEY</code> 定義が一覧表示されます。この情報は、そのテーブルが、参照するテーブルまたは参照されるテーブルのどちらであっても表示されます。
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-backup"></a>14.16 InnoDB のバックアップとリカバリ</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-recovery">14.16.1 InnoDB のリカバリプロセス</a></span></dt></dl></div><a class="indexterm" name="idm139979062052176"></a><a class="indexterm" name="idm139979062050064"></a><p>
    

    安全なデータベース管理の鍵は、定期的なバックアップを作成することです。データボリューム、MySQL サーバーの数、およびデータベースワークロードに応じて、次の手法を単独で、または組み合わせて使用できます。すなわち、MySQL Enterprise Backup を使用した<a class="link" href="glossary.html#glos_hot_backup" title="ホットバックアップ">ホットバックアップ</a>、MySQL サーバーのシャットダウン中にファイルをコピーすることによる<a class="link" href="glossary.html#glos_cold_backup" title="コールドバックアップ">コールドバックアップ</a>、迅速な操作 (特にリストア) のための<a class="link" href="glossary.html#glos_physical_backup" title="物理バックアップ">物理バックアップ</a>、小さなデータボリュームのため、またはスキーマオブジェクトの構造を記録するための <span class="command"><strong>mysqldump</strong></span> を使用した<a class="link" href="glossary.html#glos_logical_backup" title="論理バックアップ">論理バックアップ</a>です。
  </p><h3><a name="idm139979062041728"></a>ホットバックアップ</h3><p>
    MySQL Enterprise Backup コンポーネントの一部である <span class="command"><strong>mysqlbackup</strong></span> コマンドを使用すると、実行中の MySQL インスタンス (<code class="literal">InnoDB</code> および <code class="literal">MyISAM</code> テーブルを含む) を、データベースの整合性のあるスナップショットを生成しながら、操作の中断を最小限に抑えてバックアップできます。<span class="command"><strong>mysqlbackup</strong></span> が <code class="literal">InnoDB</code> テーブルをコピーしている間、<code class="literal">InnoDB</code> テーブルと <code class="literal">MyISAM</code> テーブルの両方に対する読み取りと書き込みは続行できます。<code class="literal">MyISAM</code> テーブルのコピー中は、これらのテーブルに対する (書き込みではなく) 読み取りが許可されます。MySQL Enterprise Backup はまた、圧縮バックアップファイルを作成したり、テーブルやデータベースのサブセットをバックアップしたりすることもできます。MySQL のバイナリログと組み合わせると、ユーザーはポイントインタイムリカバリを実行できます。MySQL Enterprise Backup は、MySQL Enterprise サブスクリプションの一部です。詳細は、<a class="xref" href="mysql-enterprise.html#mysql-enterprise-backup" title="25.2 MySQL Enterprise Backup">セクション25.2「MySQL Enterprise Backup」</a>を参照してください。
  </p><h3><a name="idm139979062032416"></a>コールドバックアップ</h3><p>
    MySQL サーバーをシャットダウンできる場合は、<code class="literal">InnoDB</code> がそのテーブルを管理するために使用するすべてのファイルで構成されるバイナリバックアップを作成できます。次の手順を使用します。
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
        MySQL サーバーの<a class="link" href="glossary.html#glos_slow_shutdown" title="低速シャットダウン">低速シャットダウン</a>を実行し、そのサーバーがエラーなく停止したことを確認します。
      </p></li><li class="listitem"><p>
        すべての <code class="literal">InnoDB</code> データファイル (<code class="filename">ibdata</code> ファイルおよび <code class="filename">.ibd</code> ファイル) を安全な場所にコピーします。
      </p></li><li class="listitem"><p>
        <code class="literal">InnoDB</code> テーブルのすべての <code class="filename">.frm</code> ファイルを安全な場所にコピーします。
      </p></li><li class="listitem"><p>
        すべての <code class="literal">InnoDB</code> ログファイル (<code class="filename">ib_logfile</code> ファイル) を安全な場所にコピーします。
      </p></li><li class="listitem"><p>
        1 つまたは複数の <code class="filename">my.cnf</code> 構成ファイルを安全な場所にコピーします。
      </p></li></ol></div><h3><a name="idm139979062017744"></a>代替バックアップの種類</h3><p>
    今説明したバイナリバックアップの作成に加えて、<span class="command"><strong>mysqldump</strong></span> を使用してテーブルのダンプを定期的に作成します。バイナリファイルは、気付かないうちに破損することがあります。ダンプされたテーブルは人間が読むことのできるテキストファイルに格納されるため、テーブルの破損を見つけることが容易になります。また、形式が単純であるため、重大なデータ破損につながる可能性も少なくなります。<span class="command"><strong>mysqldump</strong></span> には、ほかのクライアントをロックすることなく、整合性のあるスナップショットを作成するための <code class="option">--single-transaction</code> オプションも用意されています。<a class="xref" href="backup-and-recovery.html#backup-policy" title="7.3.1 バックアップポリシーの確立">セクション7.3.1「バックアップポリシーの確立」</a>を参照してください。
  </p><p>
    レプリケーションは <code class="literal">InnoDB</code> テーブルと連携して動作するため、MySQL のレプリケーション機能を使用して、データベースのコピーを高可用性が必要なデータベースサイトに保持できます。
  </p><h3><a name="idm139979062010864"></a>リカバリの実行</h3><p>
    <code class="literal">InnoDB</code> データベースをバイナリバックアップが作成された時点から現時点にリカバリするには、バックアップを作成する前であっても、バイナリロギングをオンにして MySQL サーバーを実行する必要があります。バックアップをリストアしたあとにポイントインタイムリカバリを実現するには、バックアップが作成されたあとに発生した変更をバイナリログから適用できます。<a class="xref" href="backup-and-recovery.html#point-in-time-recovery" title="7.5 バイナリログを使用したポイントインタイム (増分) リカバリ">セクション7.5「バイナリログを使用したポイントインタイム (増分) リカバリ」</a>を参照してください。
  </p><p>
    MySQL サーバーのクラッシュからリカバリするための唯一の要件は、そのサーバーの再起動です。<code class="literal">InnoDB</code> はログを自動的にチェックし、データベースの現時点へのロールフォワードを実行します。<code class="literal">InnoDB</code> は、クラッシュの時点で存在していたコミットされていないトランザクションを自動的にロールバックします。リカバリ中に、<span class="command"><strong>mysqld</strong></span> は次のような出力を表示します。
  </p><pre class="programlisting">
InnoDB: Database was not shut down normally.
InnoDB: Starting recovery from log files...
InnoDB: Starting log scan based on checkpoint at
InnoDB: log sequence number 0 13674004
InnoDB: Doing recovery: scanned up to log sequence number 0 13739520
InnoDB: Doing recovery: scanned up to log sequence number 0 13805056
InnoDB: Doing recovery: scanned up to log sequence number 0 13870592
InnoDB: Doing recovery: scanned up to log sequence number 0 13936128
...
InnoDB: Doing recovery: scanned up to log sequence number 0 20555264
InnoDB: Doing recovery: scanned up to log sequence number 0 20620800
InnoDB: Doing recovery: scanned up to log sequence number 0 20664692
InnoDB: 1 uncommitted transaction(s) which must be rolled back
InnoDB: Starting rollback of uncommitted transactions
InnoDB: Rolling back trx no 16745
InnoDB: Rolling back of trx no 16745 completed
InnoDB: Rollback of uncommitted transactions completed
InnoDB: Starting an apply batch of log records to the database...
InnoDB: Apply batch completed
InnoDB: Started
mysqld: ready for connections
</pre><p>
    データベースが破損するか、またはディスク障害が発生した場合は、バックアップを使用してリカバリを実行する必要があります。破損の場合は、まず、破損していないバックアップを見つけます。ベースバックアップをリストアしたあと、<span class="command"><strong>mysqlbinlog</strong></span> および <span class="command"><strong>mysql</strong></span> を使用してバイナリログファイルからポイントインタイムリカバリを実行することにより、バックアップが作成されたあとに発生した変更をリストアします。
  </p><a class="indexterm" name="idm139979061999824"></a><a class="indexterm" name="idm139979061997680"></a><a class="indexterm" name="idm139979061995760"></a><p>
    データベースの破損の程度によっては、1 つまたは複数の破損したテーブルをダンプして削除し、再作成するだけで十分である場合があります。テーブルが破損しているかどうかは、<code class="literal">CHECK TABLE</code> SQL ステートメントを使用してチェックできます。ただし、当然ながら、<code class="literal">CHECK TABLE</code> が可能性のあるすべての種類の破損を検出することはできません。テーブルスペースモニターを使用すると、テーブルスペースファイル内部のファイル領域管理の整合性をチェックできます。
  </p><p>
    場合によっては、見た目はデータベースページの破損だが、実際にはオペレーティングシステムによる独自のファイルキャッシュの破損であり、ディスク上のデータは正常であることがあります。まず、コンピュータを再起動してみることが最善です。それにより、データベースページの破損に見えたエラーが解消される可能性があります。<code class="literal">InnoDB</code> の一貫性の問題のために MySQL を引き続き起動できない場合は、<a class="xref" href="innodb-storage-engine.html#forcing-innodb-recovery" title="14.19.2 InnoDB のリカバリの強制的な実行">セクション14.19.2「InnoDB のリカバリの強制的な実行」</a>を参照して、データをダンプできる診断モードでインスタンスを起動する手順を調べてください。
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-recovery"></a>14.16.1 InnoDB のリカバリプロセス</h3></div></div></div><a class="indexterm" name="idm139979061986272"></a><p>
      <code class="literal">InnoDB</code> の<a class="link" href="glossary.html#glos_crash_recovery" title="クラッシュリカバリ">クラッシュリカバリ</a>は、次のいくつかのステップで構成されます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="link" href="glossary.html#glos_redo_log" title="Redo ログ">Redo ログ</a>の適用: Redo ログの適用は最初のステップであり、初期化中の、まだどの接続も受け入れていないときに実行されます。シャットダウンまたはクラッシュの時点で、<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>から<a class="link" href="glossary.html#glos_tablespace" title="テーブルスペース">テーブルスペース</a> (<code class="filename">ibdata*</code> および <code class="filename">*.ibd</code> ファイル) にすべての変更がフラッシュされた場合は、Redo ログの適用をスキップできます。起動時に Redo ログファイルが見つからない場合、<code class="literal">InnoDB</code> は Redo ログの適用をスキップします。
        </p><p>
          ある程度のデータ損失が許容可能な場合でも、リカバリプロセスを高速化するために Redo ログを削除することはお勧めできません。Redo ログの削除は、<code class="literal">innodb_fast_shutdown</code> が <code class="literal">0</code> または <code class="literal">1</code> に設定された状態でクリーンシャットダウンが実行されたあとのオプションにすぎないと考えてください。
        </p></li><li class="listitem"><p>
          未完了の<a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a>の<a class="link" href="glossary.html#glos_rollback" title="ロールバック">ロールバック</a>: クラッシュまたは<a class="link" href="glossary.html#glos_fast_shutdown" title="高速シャットダウン">高速シャットダウン</a>の時点でアクティブであったすべてのトランザクションが対象です。未完了のトランザクションをロールバックするためにかかる時間は、サーバーの負荷に応じて、そのトランザクションが中断される前にアクティブであった期間の 3 または 4 倍になる場合があります。
        </p><p>
          ロールバックされている最中のトランザクションを取り消すことはできません。極端なケースとして、トランザクションのロールバックに膨大な時間がかかると予測される場合は、<code class="literal">innodb_force_recovery</code> の設定を <code class="literal">3</code> 以上にして <code class="literal">InnoDB</code> を起動した方が速いことがあります。詳細は、<a class="xref" href="innodb-storage-engine.html#forcing-innodb-recovery" title="14.19.2 InnoDB のリカバリの強制的な実行">セクション14.19.2「InnoDB のリカバリの強制的な実行」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <a class="link" href="glossary.html#glos_insert_buffer" title="挿入バッファー">挿入バッファー</a>のマージ: インデックスページがバッファープールに読み取られたときに、挿入バッファー (<a class="link" href="glossary.html#glos_system_tablespace" title="システムテーブルスペース">システムテーブルスペース</a>の一部) からセカンダリインデックスのリーフページに変更を適用します。
        </p></li><li class="listitem"><p>
          <a class="link" href="glossary.html#glos_purge" title="パージ">パージ</a>: どのアクティブなトランザクションにも表示されなくなった、削除のマークが付いたレコードを削除します。
        </p></li></ul></div><p>
      Redo ログの適用に続く各ステップは (書き込みのロギングを除き) Redo ログには依存しないため、通常の処理では並列に実行されます。これらのうち、クラッシュリカバリに固有なのは未完了のトランザクションのロールバックだけです。挿入バッファーのマージとパージは、通常の処理中に実行されます。
    </p><p>
      Redo ログの適用のあと、<code class="literal">InnoDB</code> は、ダウンタイムを短縮するために接続をできるだけ早く受け入れようとします。クラッシュリカバリの一部として、<code class="literal">InnoDB</code> は、サーバーのクラッシュ時にコミットされていなかったか、または <code class="literal">XA PREPARE</code> 状態にあったすべてのトランザクションをロールバックします。このロールバックは、新しい接続からのトランザクションと並列に実行されているバックグラウンドスレッドによって実行されます。新しい接続では、ロールバック操作が完了するまで、リカバリされるトランザクションとのロック競合が発生する可能性があります。
    </p><p>
      ほとんどの状況では、負荷の高いアクティビティーの最中に MySQL サーバーが予期せず強制終了された場合でも、リカバリプロセスが自動的に実行されるため、DBA からのアクションは必要ありません。ハードウェア障害や重大なシステムエラーのために <code class="literal">InnoDB</code> データが破損した場合は、MySQL が起動を拒否する可能性があります。その場合は、このような問題をトラブルシューティングする手順について、<a class="xref" href="innodb-storage-engine.html#forcing-innodb-recovery" title="14.19.2 InnoDB のリカバリの強制的な実行">セクション14.19.2「InnoDB のリカバリの強制的な実行」</a>を参照してください。
    </p><p>
      バイナリログおよび <code class="literal">InnoDB</code> のクラッシュリカバリについては、<a class="xref" href="server-administration.html#binary-log" title="5.2.4 バイナリログ">セクション5.2.4「バイナリログ」</a>を参照してください。
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-and-mysql-replication"></a>14.17 InnoDB と MySQL レプリケーション</h2></div></div></div><a class="indexterm" name="idm139979061948336"></a><p>
    MySQL レプリケーションは、<code class="literal">MyISAM</code> テーブルに対して機能するのと同じように、<code class="literal">InnoDB</code> テーブルに対して機能します。また、スレーブ上のストレージエンジンがマスター上の元のストレージエンジンと同じではない状況でレプリケーションを使用することもできます。たとえば、マスター上の <code class="literal">InnoDB</code> テーブルへの変更をスレーブ上の <code class="literal">MyISAM</code> テーブルにレプリケートできます。
  </p><p>
    マスターに対して新しいスレーブを設定するには、<code class="literal">InnoDB</code> テーブルスペースとログファイルに加えて <code class="literal">InnoDB</code> テーブルの <code class="filename">.frm</code> ファイルのコピーを作成し、それらのコピーをスレーブに移動します。<code class="literal">innodb_file_per_table</code> オプションが有効になっている場合は、<code class="filename">.ibd</code> ファイルもコピーします。これを行うための正しい手順については、<a class="xref" href="innodb-storage-engine.html#innodb-backup" title="14.16 InnoDB のバックアップとリカバリ">セクション14.16「InnoDB のバックアップとリカバリ」</a>を参照してください。
  </p><p>
    マスターまたは既存のスレーブを停止することなく新しいスレーブを作成するには、<a class="link" href="mysql-enterprise.html#mysql-enterprise-backup" title="25.2 MySQL Enterprise Backup">MySQL Enterprise Backup</a> 製品を使用します。マスターまたは既存のスレーブをシャットダウンできる場合は、<code class="literal">InnoDB</code> テーブルスペースとログファイルの<a class="link" href="glossary.html#glos_cold_backup" title="コールドバックアップ">コールドバックアップ</a>を作成し、それを使用してスレーブを設定します。
  </p><p>
    マスター上で失敗したトランザクションがレプリケーションに影響を与えることはありません。MySQL レプリケーションは、データを変更する SQL ステートメントが MySQL によって書き込まれたバイナリログに基づいています。失敗したトランザクション (たとえば、外部キーの違反のため、またはロールバックされているため) はバイナリログに書き込まれないため、スレーブには送信されません。<a class="xref" href="sql-syntax.html#commit" title="13.3.1 START TRANSACTION、COMMIT、および ROLLBACK 構文">セクション13.3.1「START TRANSACTION、COMMIT、および ROLLBACK 構文」</a>を参照してください。
  </p><p><b>レプリケーションと CASCADE </b>
      マスター上の <code class="literal">InnoDB</code> テーブルに関するカスケードアクションは、外部キー関係を共有しているテーブルがマスターとスレーブの両方で <code class="literal">InnoDB</code> を使用している場合に<span class="emphasis"><em>のみ</em></span>スレーブにレプリケートされます。これは、ステートメントベースのレプリケーションと行ベースのレプリケーションのどちらを使用している場合にも当てはまります。レプリケーションを開始したあと、次の <code class="literal">CREATE TABLE</code> ステートメントを使用してマスター上に 2 つのテーブルを作成したとします。
    </p><pre class="programlisting">
CREATE TABLE fc1 (
    i INT PRIMARY KEY,
    j INT
) ENGINE = InnoDB;

CREATE TABLE fc2 (
    m INT PRIMARY KEY,
    n INT,
    FOREIGN KEY ni (n) REFERENCES fc1 (i)
        ON DELETE CASCADE
) ENGINE = InnoDB;
</pre><p>
    このスレーブでは <code class="literal">InnoDB</code> のサポートが有効になっていないと仮定します。この場合、スレーブ上にテーブルは作成されますが、それらのテーブルは <code class="literal">MyISAM</code> ストレージエンジンを使用し、<code class="literal">FOREIGN KEY</code> オプションは無視されます。次に、マスター上のテーブルに何行か挿入します。
  </p><pre class="programlisting">
master&gt; <strong class="userinput"><code>INSERT INTO fc1 VALUES (1, 1), (2, 2);</code></strong>
Query OK, 2 rows affected (0.09 sec)
Records: 2  Duplicates: 0  Warnings: 0

master&gt; <strong class="userinput"><code>INSERT INTO fc2 VALUES (1, 1), (2, 2), (3, 1);</code></strong>
Query OK, 3 rows affected (0.19 sec)
Records: 3  Duplicates: 0  Warnings: 0
</pre><p>
    この時点では、次に示すように、マスターとスレーブの両方で、テーブル <code class="literal">fc1</code> には 2 行が含まれ、テーブル <code class="literal">fc2</code> には 3 行が含まれています。
  </p><pre class="programlisting">
master&gt; <strong class="userinput"><code>SELECT * FROM fc1;</code></strong>
+---+------+
| i | j    |
+---+------+
| 1 |    1 |
| 2 |    2 |
+---+------+
2 rows in set (0.00 sec)

master&gt; <strong class="userinput"><code>SELECT * FROM fc2;</code></strong>
+---+------+
| m | n    |
+---+------+
| 1 |    1 |
| 2 |    2 |
| 3 |    1 |
+---+------+
3 rows in set (0.00 sec)

slave&gt; <strong class="userinput"><code>SELECT * FROM fc1;</code></strong>
+---+------+
| i | j    |
+---+------+
| 1 |    1 |
| 2 |    2 |
+---+------+
2 rows in set (0.00 sec)

slave&gt; <strong class="userinput"><code>SELECT * FROM fc2;</code></strong>
+---+------+
| m | n    |
+---+------+
| 1 |    1 |
| 2 |    2 |
| 3 |    1 |
+---+------+
3 rows in set (0.00 sec)
</pre><p>
    ここで、マスター上で次の <code class="literal">DELETE</code> ステートメントを実行したとします。
  </p><pre class="programlisting">
master&gt; <strong class="userinput"><code>DELETE FROM fc1 WHERE i=1;</code></strong>
Query OK, 1 row affected (0.09 sec)
</pre><p>
    カスケードのために、マスター上のテーブル <code class="literal">fc2</code> には 1 行しか含まれなくなりました。
  </p><pre class="programlisting">
master&gt; <strong class="userinput"><code>SELECT * FROM fc2;</code></strong>
+---+---+
| m | n |
+---+---+
| 2 | 2 |
+---+---+
1 row in set (0.00 sec)
</pre><p>
    ただし、スレーブでは <code class="literal">fc1</code> に対する <code class="literal">DELETE</code> によって <code class="literal">fc2</code> から行が削除されないため、カスケードはスレーブに伝播されません。スレーブの <code class="literal">fc2</code> のコピーには引き続き、最初に挿入されたすべての行が含まれています。
  </p><pre class="programlisting">
slave&gt; <strong class="userinput"><code>SELECT * FROM fc2;</code></strong>
+---+---+
| m | n |
+---+---+
| 1 | 1 |
| 3 | 1 |
| 2 | 2 |
+---+---+
3 rows in set (0.00 sec)
</pre><p>
    この違いは、カスケード削除が、実際には <code class="literal">InnoDB</code> ストレージエンジンによって内部的に処理されることから来ています。つまり、どの変更もログに記録されません。
  </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-memcached"></a>14.18 InnoDB と memcached の統合</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-benefits">14.18.1 InnoDB と memcached の組み合わせの利点</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-intro">14.18.2 InnoDB および memcached の統合のアーキテクチャー</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-setup">14.18.3 InnoDB Memcached プラグインの概要</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-security">14.18.4 InnoDB memcached プラグインのセキュリティーに関する考慮事項</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-developing">14.18.5 InnoDB memcached インタフェース用のアプリケーションの作成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-replication">14.18.6 レプリケーションでの InnoDB memcached プラグインの使用</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-internals">14.18.7 InnoDB memcached プラグインの内部構造</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-troubleshoot">14.18.8 InnoDB memcached プラグインのトラブルシューティング</a></span></dt></dl></div><a class="indexterm" name="idm139979061899408"></a><p>
    <span class="command"><strong>memcached</strong></span> デーモンは、MySQL データベースサーバーの前面のインメモリーキャッシュレイヤーとして頻繁に使用されます。<code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインの導入により、MySQL は <span class="command"><strong>memcached</strong></span> プロトコルおよびクライアントライブラリを使用して、<code class="literal">InnoDB</code> テーブルに直接アクセスできるようになりました。
  </p><p>
    <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインは、<code class="literal">InnoDB</code> テーブルへのデータの自動保管およびテーブルからのデータの自動取得が可能な組み込み型の <span class="command"><strong>memcached</strong></span> デーモンを提供し、MySQL Server を高速な<span class="quote">「<span class="quote">キー/値ストア</span>」</span>に変換させます。クエリーを SQL で作成する代わりに、SQL 構文解析およびクエリー最適化プランの作成のパフォーマンスオーバーヘッドを回避する、単純な get、set、および increment 操作を実行できます。また、簡便性、複雑なクエリー、一括操作、アプリケーション互換性、および従来のデータベースソフトウェアが持つその他の強みを活かすために、SQL を使用して同じ <code class="literal">InnoDB</code> テーブルにアクセスすることもできます。
  </p><p>
    この <span class="quote">「<span class="quote">NoSQL スタイルの</span>」</span>インタフェースは、<span class="command"><strong>memcached</strong></span> API を使用してデータベース操作を高速化し、<code class="literal">InnoDB</code> がその<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>メカニズムを使用してメモリーキャッシュを処理します。<code class="literal">ADD</code>、<code class="literal">SET</code>、<code class="literal">INCR</code> などの <span class="command"><strong>memcached</strong></span> 操作によって変更されたデータは、<a class="link" href="glossary.html#glos_change_buffering" title="変更バッファリング">変更バッファリング</a>、<a class="link" href="glossary.html#glos_doublewrite_buffer" title="二重書き込みバッファー">二重書き込みバッファー</a>、<a class="link" href="glossary.html#glos_crash_recovery" title="クラッシュリカバリ">クラッシュリカバリ</a>などの <code class="literal">InnoDB</code> メカニズムを使用してディスクに格納されます。<span class="command"><strong>memcached</strong></span> の簡便性と <code class="literal">InnoDB</code> の信頼性および一貫性の組み合わせにより、<a class="xref" href="innodb-storage-engine.html#innodb-memcached-benefits" title="14.18.1 InnoDB と memcached の組み合わせの利点">セクション14.18.1「InnoDB と memcached の組み合わせの利点」</a>で説明されている両方の優れた点がユーザーに提供されます。コンポーネントを互いに組み合わせる方法に関する詳細なアーキテクチャーについては、<a class="xref" href="innodb-storage-engine.html#innodb-memcached-intro" title="14.18.2 InnoDB および memcached の統合のアーキテクチャー">セクション14.18.2「InnoDB および memcached の統合のアーキテクチャー」</a>を参照してください。
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-memcached-benefits"></a>14.18.1 InnoDB と memcached の組み合わせの利点</h3></div></div></div><p>
      このセクションでは、<a class="xref" href="innodb-storage-engine.html#innodb-memcached" title="14.18 InnoDB と memcached の統合">セクション14.18「InnoDB と memcached の統合」</a>で導入された <code class="literal">InnoDB</code> テーブルへの <span class="command"><strong>memcached</strong></span> インタフェースの利点について説明します。<code class="literal">InnoDB</code> テーブルと <span class="command"><strong>memcached</strong></span> を組み合わせることで、いずれかを単独で使用した場合を上回る利点が得られます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">InnoDB</code> ストレージエンジンに直接アクセスすることによって、SQL の構文解析およびプランニングのオーバーヘッドを回避できます。
        </p></li><li class="listitem"><p>
          <span class="command"><strong>memcached</strong></span> を MySQL Server と同じプロセス空間で実行することにより、リクエストを受け渡すことによるネットワークオーバーヘッドが回避されます。
        </p></li><li class="listitem"><p>
          <span class="command"><strong>memcached</strong></span> プロトコルを使用して書き込まれるデータは透過的に <code class="literal">InnoDB</code> テーブルに書き込まれ、MySQL SQL レイヤーを経由しません。書き込みの頻度を制御することで、重要ではないデータを更新するときに本来のパフォーマンスを高めることができます。
        </p></li><li class="listitem"><p>
          <span class="command"><strong>memcached</strong></span> プロトコルを介してリクエストされるデータは透過的に <code class="literal">InnoDB</code> テーブルから照会され、MySQL SQL レイヤーを経由しません。
        </p></li><li class="listitem"><p>
          同じデータに対する後続のリクエストは <code class="literal">InnoDB</code> バッファープールから提供されます。バッファープールはインメモリーキャッシュを処理します。使い慣れた <code class="literal">InnoDB</code> 構成オプションを使用して、大量のデータを処理する操作のパフォーマンスをチューニングできます。
        </p></li><li class="listitem"><p>
          アプリケーションのタイプに応じて、非構造化データまたは構造化データを使用できます。データ用にまったく新しいテーブルを作るか、1 つ以上の既存のテーブルに NoSQL スタイルの処理をマップできます。
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> は複数カラムの値を単一の <span class="command"><strong>memcached</strong></span> 項目値に連結したり分解したりできるため、アプリケーションで必要な文字列の構文解釈および連結の量が削減されます。たとえば、文字列値 <code class="literal">2|4|6|8</code> が <span class="command"><strong>memcached</strong></span> キャッシュに格納されている場合、<code class="literal">InnoDB</code> はその値を区切り文字に基づいて分割し、結果を 4 つの数値カラムに格納します。
        </p></li><li class="listitem"><p>
          メモリーとディスク間の転送は自動的に処理されるため、アプリケーションロジックが簡素化されます。
        </p></li><li class="listitem"><p>
          データは MySQL データベースに格納されることで、クラッシュ、機能停止、および破損から保護されます。
        </p></li><li class="listitem"><p>
          レポート作成、分析、アドホッククエリー、一括ロード、マルチステップのトランザクション計算、論理和や論理積などの set 操作、および SQL の表現性と柔軟性に適したその他の操作のために、引き続き SQL を介して基礎テーブルにアクセスできます。
        </p></li><li class="listitem"><p>
          この機能を MySQL レプリケーションと組み合わせて<a class="link" href="glossary.html#glos_master_server" title="マスターサーバー">マスターサーバー</a>上で使用すると、NoSQL データの高可用性を保証できます。
        </p></li></ul></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <span class="command"><strong>memcached</strong></span> と MySQL を統合することにより、手間をかけずにインメモリーデータを永続的なものにでき、これを非常に多くの種類のデータに使用できます。データがすぐに消去される心配がなく、より多くの <code class="literal">add</code>、<code class="literal">incr</code>、および類似の書き込み操作をアプリケーションに配置できます。キャッシュされたデータへの更新を失わずに <span class="command"><strong>memcached</strong></span> サーバーを停止および起動できます。予期しない機能停止を防ぐために、<code class="literal">InnoDB</code> のクラッシュリカバリ手順、レプリケーション手順、およびバックアップ手順を利用できます。
        </p></li><li class="listitem"><p>
          <code class="literal">InnoDB</code> が高速な<a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a>検索を実行する方法では、通常 <span class="command"><strong>memcached</strong></span> の単一項目クエリーに適合します。<span class="command"><strong>memcached</strong></span> プラグインによって使用される、低レベルの直接的なデータベースアクセスパスは、キー/値の検索では同等の SQL クエリーよりもはるかに効率的です。
        </p></li><li class="listitem"><p>
          複雑なデータ構造、バイナリファイル、またはコードブロックも格納可能な文字列に変換できる <span class="command"><strong>memcached</strong></span> のシリアライズ機能によって、このようなオブジェクトをデータベースに格納する簡単な方法が提供されます。
        </p></li><li class="listitem"><p>
          基礎データに SQL 経由でアクセスできるため、<span class="command"><strong>memcached</strong></span> データについてレポートを生成したり、複数のキーで検索または更新したり、<code class="literal">AVG()</code> や <code class="literal">MAX()</code> などの関数を呼び出したりできます。これらすべての操作は、スタンドアロンの <span class="command"><strong>memcached</strong></span> ではコストがかかったり複雑になったりします。
        </p></li><li class="listitem"><p>
          起動時に <span class="command"><strong>memcached</strong></span> にデータを手動でロードする必要はありません。アプリケーションによって特定のキーがリクエストされると、値はデータベースから自動的に取得され、<code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>を使用してメモリーにキャッシュされます。
        </p></li><li class="listitem"><p>
          <span class="command"><strong>memcached</strong></span> は CPU の消費が比較的少なく、メモリーフットプリントを管理しやすいため、同じシステム上で MySQL インスタンスとともに快適に実行できます。
        </p></li><li class="listitem"><p>
          通常の <code class="literal">InnoDB</code> テーブルで使用されるメカニズムによってデータ完全性が強制されるため、古くなった <span class="command"><strong>memcached</strong></span> データや、キーが見つからない場合にデータベースにクエリーを実行するフォールバックロジックについて懸念する必要はありません。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-memcached-intro"></a>14.18.2 InnoDB および memcached の統合のアーキテクチャー</h3></div></div></div><a class="indexterm" name="idm139979061818208"></a><p>
      このセクションでは <span class="command"><strong>memcached</strong></span> デーモンが MySQL Server にどのように統合されるかについて説明します。これは、このアプローチと NoSQL コンポーネントまたはインタフェースを MySQL バックエンドに結合するほかの技法とを比べてその優劣を理解するのに役立ちます。
    </p><p>
      <span class="command"><strong>memcached</strong></span> は MySQL Server と統合すると、MySQL プラグインデーモンとして実装され、<code class="literal">InnoDB</code> ストレージエンジンに直接アクセスして SQL レイヤーをバイパスします。
    </p><div class="mediaobject"><img src="images/innodb_memcached2.jpg" width="554" height="414" alt="memcached サーバーが統合された MySQL Server のアーキテクチャー図"></div><p>
      現在のリリースで提供される機能:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <span class="command"><strong>mysqld</strong></span> のデーモンプラグインとしての <span class="command"><strong>memcached</strong></span>: <span class="command"><strong>mysqld</strong></span> および <span class="command"><strong>memcached</strong></span> は両方とも同じプロセス空間で実行し、非常に短い待機時間でデータにアクセスします。
        </p></li><li class="listitem"><p>
          SQL パーサー、オプティマイザ、さらにハンドラ API レイヤーもバイパスして、<code class="literal">InnoDB</code> テーブルに直接アクセスします。
        </p></li><li class="listitem"><p>
          テキストベースプロトコルとバイナリプロトコルの両方からなる標準の <span class="command"><strong>memcached</strong></span> プロトコル。<code class="literal">InnoDB</code> + <span class="command"><strong>memcached</strong></span> の組み合わせは、<span class="command"><strong>memcapable</strong></span> コマンドの 55 個すべての互換性テストに合格しています。
        </p></li><li class="listitem"><p>
          複数カラムのサポート: 複数のカラムをキー/値ストアの<span class="quote">「<span class="quote">値</span>」</span>部分にマップでき、カラム値はユーザー指定の区切り文字によって区切られます。
        </p></li><li class="listitem"><p>
          デフォルトでは、<span class="command"><strong>memcached</strong></span> プロトコルを使用して、<code class="literal">InnoDB</code> からデータを直接読み取ったり書き込んだりし、MySQL で <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>を介してインメモリーキャッシュを管理します。デフォルト設定は、データベースアプリケーションに対する予想外の動作を最小限に抑えた信頼性の高い組み合わせになっています。たとえばデフォルト設定では、データベース側でデータがコミットされなかったり、<span class="command"><strong>memcached</strong></span> <code class="literal">get</code> リクエストに対して古くなったデータが返されたりすることがないようになっています。

          
        </p></li><li class="listitem"><p>
          上級ユーザーは、従来の <span class="command"><strong>memcached</strong></span> サーバーとしてシステムを構成し、すべてのデータを <span class="command"><strong>memcached</strong></span> デフォルトエンジン (メモリー) にのみキャッシュするか、<span class="quote">「<span class="quote"><span class="command"><strong>memcached</strong></span> デフォルトエンジン</span>」</span> (メモリーキャッシュ) と <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> エンジン (バックエンド永続ストレージとしての <code class="literal">InnoDB</code>) の組み合わせを使用できます。
        </p></li></ul></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">innodb_api_bk_commit_interval</code>、<code class="literal">daemon_memcached_r_batch_size</code>、および <code class="literal">daemon_memcached_w_batch_size</code> 構成オプションを使用して、<code class="literal">InnoDB</code> と memcached の操作間のデータがやり取りされる頻度を制御できます。最大限の信頼性を得るには、両方のバッチサイズオプションのデフォルト値を 1 にします。
        </p></li><li class="listitem"><p>
          MySQL 構成変数 <code class="literal">daemon_memcached_option</code> から <span class="command"><strong>memcached</strong></span> 構成オプションを指定できます。たとえば、<span class="command"><strong>memcached</strong></span> が待機するポートを変更したり、同時接続の最大数を削減したり、鍵と値のペアの最大メモリーサイズを変更したり、エラーログに関するメッセージのデバッグを有効にしたりします。
        </p></li><li class="listitem"><p>
          構成オプション <code class="literal">innodb_api_trx_level</code> を使用すると、ユーザーは <span class="command"><strong>memcached</strong></span> インタフェースによって処理されるクエリーのトランザクション<a class="link" href="glossary.html#glos_isolation_level" title="分離レベル">分離レベル</a>を制御できます。<span class="command"><strong>memcached</strong></span> には<a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a>の概念がありませんが、このプロパティーを使用すると、<span class="command"><strong>memcached</strong></span> がインタフェースするテーブルと同じテーブル上で <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> ステートメントを発行した場合、SQL ステートメントによって発生した変更が <span class="command"><strong>memcached</strong></span> で表示されるまでの速さを制御できます。デフォルトでは、これは <code class="literal">READ UNCOMMITTED</code> に設定されています。
        </p></li><li class="listitem"><p>
          別の構成オプションは <code class="literal">innodb_api_enable_mdl</code> です。<span class="quote">「<span class="quote">MDL</span>」</span>は<span class="quote">「<span class="quote">メタデータロック</span>」</span>を表します。これは基本的に MySQL レベルでテーブルをロックするため、マップされたテーブルを、SQL インタフェース経由で <a class="link" href="glossary.html#glos_ddl" title="DDL">DDL</a> によってドロップしたり変更したりできません。ロックがなければテーブルを MySQL レイヤーからドロップできますが、<span class="command"><strong>memcached</strong></span> またはほかのユーザーがテーブルの使用を停止するまで InnoDB ストレージ内に保持されます。
        </p></li></ul></div><h4><a name="innodb-memcached-compare-contrast"></a>memcached のスタンドアロンでの使用と InnoDB との併用の違い</h4><p>
      <a class="xref" href="ha-overview.html#ha-memcached" title="16.6 MySQL と memcached の併用">セクション16.6「MySQL と <span class="command"><strong>memcached</strong></span> の併用」</a>に記載されているように、MySQL ユーザーは、<span class="command"><strong>memcached</strong></span> を MySQL とともに使用することをすでに熟知している場合があります。このセクションでは、セクション内の情報の類似点および相違点と、MySQL に組み込まれている <span class="command"><strong>memcached</strong></span> の <code class="literal">InnoDB</code> 統合機能を使用する場合について説明します。各項目の最初のリンクから、従来の <span class="command"><strong>memcached</strong></span> サーバーに関する関連情報にアクセスできます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="link" href="ha-overview.html#ha-memcached-install" title="16.6.1 memcached のインストール">インストール</a>: <span class="command"><strong>memcached</strong></span> ライブラリは MySQL Server に付属しているため、インストールおよびセットアップは簡単明瞭です。使用する <span class="command"><strong>memcached</strong></span> 用のテーブルをセットアップするための SQL スクリプトを実行し、1 回かぎりの <code class="literal">install plugin</code> ステートメントを発行して <span class="command"><strong>memcached</strong></span> を使用可能にし、MySQL 構成ファイルまたは起動オプションに、別のポートを使用するなどの必要な <span class="command"><strong>memcached</strong></span> オプションを追加します。通常の <span class="command"><strong>memcached</strong></span> 配布をインストールして、<span class="command"><strong>memcp</strong></span>、<span class="command"><strong>memcat</strong></span>、<span class="command"><strong>memcapable</strong></span> などの追加のユーティリティーを取得する場合もあります。
        </p></li><li class="listitem"><p>
          <a class="link" href="ha-overview.html#ha-memcached-using-deployment" title="16.6.2.1 memcached の配備">配備</a>: 通常は、能力の低い多数の <span class="command"><strong>memcached</strong></span> サーバーを実行します。<code class="literal">InnoDB</code> + <span class="command"><strong>memcached</strong></span> の組み合わせでは、データベースと <span class="command"><strong>memcached</strong></span> サーバーの比率が 1:1 になるため、通常の配備では、MySQL をすでに実行している中程度あるいは高い能力を持つ少数のサーバーマシンが含まれます。このサーバー構成の利点は、多数のサーバーにわたって未使用メモリーを活用したり、検索を分散させたりすることよりも、個々のデータベースサーバーそれぞれの効率を高めることの方が上回ります。デフォルト構成では、<span class="command"><strong>memcached</strong></span> にはメモリーがほとんど使用されず、インメモリー検索は <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>から提供され、このバッファープールは、最近使用されたデータと頻繁に使用されるデータを自動的にキャッシュします。従来の MySQL Server インスタンスと同じように、<code class="literal">innodb_buffer_pool_size</code> 構成オプションの値を (OS レベルでのページングを発生させない) 実用的なできるだけ高い値に維持し、これによりできるだけ多くのワークロードがメモリー内で実行されるようにします。
        </p></li><li class="listitem"><p>
          <a class="link" href="ha-overview.html#ha-memcached-using-expiry" title="16.6.2.3 データ失効">期限切れ</a>: デフォルトでは (キャッシュポリシー <code class="literal">innodb_only</code> を使用)、<code class="literal">InnoDB</code> テーブルから最新データが常に返されるため、期限切れオプションは事実上影響ありません。キャッシュポリシーを <code class="literal">caching</code> または <code class="literal">cache-only</code> に変更した場合、期限切れオプションは通常どおり機能しますが、リクエストされたデータが、メモリーキャッシュ内で期限切れになる前に基礎テーブル内で更新された場合、データが古くなっている可能性があります。
        </p></li><li class="listitem"><p>
          <a class="link" href="ha-overview.html#ha-memcached-using-namespaces" title="16.6.2.2 名前空間の使用">ネームスペース</a>: <span class="command"><strong>memcached</strong></span> は 1 つの巨大なディレクトリに似ており、ここではファイルが互いに矛盾しないように、プリフィクスとサフィクスを使用した複雑な名前を指定する場合があります。<code class="literal">InnoDB</code> と <span class="command"><strong>memcached</strong></span> による統合サーバーでは、キーに同じ命名規則を使用できますが、追加の規則が 1 つあります。<code class="literal">@@<em class="replaceable"><code>table_id</code></em>.<em class="replaceable"><code>key</code></em></code>.<em class="replaceable"><code>table_id</code></em> という形式のキー名は、<code class="literal">innodb_memcache.containers</code> テーブルからのマッピングデータを使用して、特定のテーブルを参照するようにデコードされます。<em class="replaceable"><code>key</code></em> は指定されたテーブル内で参照されるか、このテーブルに書き込まれます。
        </p><p>
          <code class="literal">@@</code> 表記は、<code class="literal">get</code>、<code class="literal">add</code>、および <code class="literal">set</code> 関数に対する個別の呼び出しにのみ機能し、<code class="literal">incr</code> や <code class="literal">delete</code> などのほかの関数には機能しません。セッション内の後続の <span class="command"><strong>memcached</strong></span> 操作に対してデフォルトテーブルを指定するには、<code class="literal">@@</code> 表記とテーブル ID を使用し、キーの部分は指定せずに <code class="literal">get</code> リクエストを実行します。例:
        </p><pre class="programlisting">

get @@table_x

</pre><p>
          後続の <code class="literal">get</code>、<code class="literal">set</code>、<code class="literal">incr</code>、<code class="literal">delete</code> およびその他の操作は、<code class="literal">innodb_memcache.containers.name</code> カラム内で <code class="literal">table_x</code> によって指定されたテーブルを使用します。
        </p></li><li class="listitem"><p>
          <a class="link" href="ha-overview.html#ha-memcached-using-hashtypes" title="16.6.2.4 memcached のハッシュ化/分布タイプ">ハッシュおよび配布</a>: キャッシュポリシー <code class="literal">innodb_only</code> を使用したデフォルト構成は、レプリケーションスレーブサーバーのセットなど、サーバー上ですべてのデータが使用できる従来の配備構成に適しています。
        </p><p>
          データをシャード構成のように物理的に分割する場合、<code class="literal">InnoDB</code> および <span class="command"><strong>memcached</strong></span> を組み合わせたサーバーを実行するいくつかのマシンでデータを分割でき、従来の <span class="command"><strong>memcached</strong></span> ハッシュメカニズムを使用するとリクエストを特定のマシンに送信できます。MySQL 側では、通常、<span class="command"><strong>memcached</strong></span> への <code class="literal">add</code> リクエストによってすべてのデータを挿入するため、適切なサーバー上のデータベース内に適切な値が保管されます。
        </p><p>
          これらのタイプの配備のベストプラクティスが、引き続き体系化されています。
        </p></li><li class="listitem"><p>
          <a class="link" href="ha-overview.html#ha-memcached-using-memory" title="16.6.2.6 memcached 内でのメモリー割り当て">メモリーの使用</a>: デフォルトでは (キャッシュポリシー <code class="literal">innodb_only</code> を使用)、<span class="command"><strong>memcached</strong></span> プロトコルは <code class="literal">InnoDB</code> テーブル間で情報をやり取りし、<span class="command"><strong>memcached</strong></span> のメモリー使用量を増加および減少させるのではなく、固定サイズの <code class="literal">InnoDB</code> バッファープールでインメモリー検索を処理します。相対的には、<span class="command"><strong>memcached</strong></span> 側ではメモリーをほとんど使用しません。
        </p><p>
          キャッシュポリシーを <code class="literal">caching</code> または <code class="literal">cache-only</code> に切り換えた場合、<span class="command"><strong>memcached</strong></span> メモリー使用量の通常のルールが適用されます。<span class="command"><strong>memcached</strong></span> データ値のメモリーは、<span class="quote">「<span class="quote">スラブ</span>」</span>を利用して割り当てられます。<span class="command"><strong>memcached</strong></span> で使用されるスラブサイズおよび最大メモリーを制御できます。
        </p><p>
          いずれの場合も、たとえば <span class="command"><strong>telnet</strong></span> セッションを介した標準プロトコル経由でアクセスされる、使い慣れた<a class="link" href="ha-overview.html#ha-memcached-stats" title="16.6.4 memcached の統計の取得">統計</a>システムを使用して、統合された <span class="command"><strong>memcached</strong></span> デーモンをモニターおよびトラブルシューティングできます。統合型デーモンとともに追加のユーティリティーが含まれているわけではないため、<a class="link" href="ha-overview.html#ha-memcached-stats-memcached-tool" title="16.6.4.6 memcached-tool の使用"><code class="literal">memcached-tool</code> スクリプト</a>を使用するには、完全な <span class="command"><strong>memcached</strong></span> 配布をインストールします。
        </p></li><li class="listitem"><p>
          <a class="link" href="ha-overview.html#ha-memcached-using-threads" title="16.6.2.7 memcached のスレッドサポート">スレッドの使用</a>: MySQL スレッドおよび <span class="command"><strong>memcached</strong></span> スレッドは同一サーバー上に共存する必要があるため、オペレーティングシステムでスレッドに課されるすべての制限は、この合計の数値に適用されます。
        </p></li><li class="listitem"><p>
          <a class="link" href="ha-overview.html#ha-memcached-using-logs" title="16.6.2.8 memcached ログ">ログの使用</a>: <span class="command"><strong>memcached</strong></span> デーモンは MySQL Server とともに実行し、<code class="literal">stderr</code> に書き込むため、ロギングのための <code class="literal">-v</code>、<code class="literal">-vv</code>、および <code class="literal">-vvv</code> オプションによって、これらの出力が MySQL <a class="link" href="glossary.html#glos_error_log" title="エラーログ">エラーログ</a>に書き込まれます。
        </p></li><li class="listitem"><p>
          <a class="link" href="ha-overview.html#ha-memcached-operations" title="16.6.3.1 memcached の基本操作"><span class="command"><strong>memcached</strong></span> 操作</a>: <code class="literal">get</code>、<code class="literal">set</code>、<code class="literal">add</code>、<code class="literal">delete</code> などのよく使用される操作を使用できます。シリアライズ (複雑なデータ構造を表す正確な文字列書式) は言語インタフェースによって異なります。

          

        </p></li><li class="listitem"><p>
          <a class="link" href="ha-overview.html#ha-memcached-mysql-frontend" title="16.6.3.2 MySQL キャッシュレイヤーとしての memcached の使用">MySQL フロントエンドとしての <span class="command"><strong>memcached</strong></span> の使用</a>: <code class="literal">InnoDB</code> を <span class="command"><strong>memcached</strong></span> と統合させるということは、まさにこのことです。これらのコンポーネントを一緒に配置することで、アプリケーションのパフォーマンスが改善されます。<code class="literal">InnoDB</code> によってメモリーとディスク間のデータ転送が処理されるため、アプリケーションのロジックが簡素化されます。
        </p></li><li class="listitem"><p>
          <a class="link" href="ha-overview.html#ha-memcached-interfaces-libmemcached-utilities" title="16.6.3.3.6 libmemcached のコマンド行ユーティリティー">ユーティリティー</a>: MySQL Server は <code class="literal">libmemcached</code> ライブラリを含んでいますが、追加のコマンド行ユーティリティーを含んでいません。<span class="command"><strong>memcp</strong></span>、<span class="command"><strong>memcat</strong></span>、<span class="command"><strong>memcapable</strong></span> コマンドなどのコマンドを取得するには、完全な <span class="command"><strong>memcached</strong></span> 配布をインストールします。<span class="command"><strong>memrm</strong></span> および <span class="command"><strong>memflush</strong></span> がキャッシュから項目を削除すると、項目はベースとなる <code class="literal">InnoDB</code> テーブルからも削除されます。
        </p></li><li class="listitem"><p>
          <a class="link" href="ha-overview.html#ha-memcached-interfaces" title="16.6.3 memcached アプリケーションの開発">プログラミングインタフェース</a>: いつも使用している言語と同じ言語である、<a class="link" href="ha-overview.html#ha-memcached-interfaces-libmemcached" title="16.6.3.3 C および C++ での libmemcached の使用">C および C++</a>、<a class="link" href="ha-overview.html#ha-memcached-interfaces-java" title="16.6.3.8 Java での MySQL と memcached の使用">Java</a>、<a class="link" href="ha-overview.html#ha-memcached-interfaces-perl" title="16.6.3.4 Perl での MySQL と memcached の使用">Perl</a>、<a class="link" href="ha-overview.html#ha-memcached-interfaces-python" title="16.6.3.5 Python での MySQL と memcached の使用">Python</a>、<a class="link" href="ha-overview.html#ha-memcached-interfaces-php" title="16.6.3.6 PHP での MySQL と memcached の使用">PHP</a>、および <a class="link" href="ha-overview.html#ha-memcached-interfaces-ruby" title="16.6.3.7 Ruby での MySQL と memcached の使用">Ruby</a> を使用して、<code class="literal">InnoDB</code> および <span class="command"><strong>memcached</strong></span> の組み合わせから MySQL Server にアクセスできます。ほかの <span class="command"><strong>memcached</strong></span> サーバーと同じように、サーバーホスト名およびポートを指定します。デフォルトでは、統合化された <span class="command"><strong>memcached</strong></span> サーバーは、通常と同じポートである <code class="literal">11211</code> をリッスンします。<a class="link" href="ha-overview.html#ha-memcached-interfaces-protocol" title="16.6.3.9 memcached の TCP テキストプロトコルの使用">テキストプロトコルとバイナリプロトコル</a>の両方を使用できます。<span class="command"><strong>memcached</strong></span> 関数の<a class="link" href="ha-overview.html#ha-memcached-interfaces-libmemcached-behaviors" title="16.6.3.3.5 libmemcached の動作の制御">動作</a>を実行時にカスタマイズできます。シリアライズ (複雑なデータ構造を表す正確な文字列書式) は言語インタフェースによって異なります。
        </p></li><li class="listitem"><p>
          <a class="link" href="ha-overview.html#ha-memcached-faq" title="16.6.5 memcached の FAQ">よくある質問</a>: MySQL では、複数のリリースで、広範囲にわたる <span class="command"><strong>memcached</strong></span> FAQ が用意されています。MySQL 5.6 でも回答はおおむね変わっていませんが、<code class="literal">InnoDB</code> テーブルを <span class="command"><strong>memcached</strong></span> データのストレージメディアとして使用することで、この組み合わせを読み取り専用キャッシュとしてではなく、書き込み処理が多いアプリケーションに使用できるようになっています。
        </p></li></ul></div><p>
      この機能のしくみについて詳しくは、<a class="xref" href="innodb-storage-engine.html#innodb-memcached-internals" title="14.18.7 InnoDB memcached プラグインの内部構造">セクション14.18.7「InnoDB memcached プラグインの内部構造」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-memcached-setup"></a>14.18.3 InnoDB Memcached プラグインの概要</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-prereqs">14.18.3.1 InnoDB memcached プラグインの前提条件</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-installing">14.18.3.2 InnoDB memcached プラグインのインストールおよび構成</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-snifftest">14.18.3.3 InnoDB および memcached 設定の検証</a></span></dt></dl></div><p>
      このセクションでは、MySQL Server 上で <code class="literal">InnoDB</code> と <span class="command"><strong>memcached</strong></span> の統合をアクティブ化するステップについて説明します。<span class="command"><strong>memcached</strong></span> デーモンは、ネットワークトラフィックを回避して待機時間を最小限に抑えるよう MySQL Server と強固に統合されているため、この機能を使用する個々の MySQL インスタンス上でこのプロセスを実行します。
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        <span class="command"><strong>memcached</strong></span> インタフェースをすべてのデータ用にセットアップする前に、<a class="xref" href="innodb-storage-engine.html#innodb-memcached-security" title="14.18.4 InnoDB memcached プラグインのセキュリティーに関する考慮事項">セクション14.18.4「InnoDB memcached プラグインのセキュリティーに関する考慮事項」</a>を調べて、不正アクセスを防ぐために必要なセキュリティー手順を理解します。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-memcached-prereqs"></a>14.18.3.1 InnoDB memcached プラグインの前提条件</h4></div></div></div><p>
        プラグインと内部テーブルをセットアップする前に、必要な前提条件ソフトウェアをサーバーが持っていることを確認します。
      </p><h5><a name="idm139979061611568"></a>プラットフォームサポート</h5><p>
        <span class="command"><strong>memcached</strong></span> デーモンプラグインは、現在、Linux、Solaris、および OS X プラットフォームでのみサポートされています。
      </p><h5><a name="idm139979061609504"></a>ソフトウェアの前提条件</h5><p>
        <span class="command"><strong>memcached</strong></span> で必要なため、<code class="literal">libevent</code> がインストールされている必要があります。このライブラリを取得する方法は、MySQL インストールプログラムを使用するか、ソースから構築するかによって異なります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            MySQL インストールプログラムを使用してインストールする場合、<code class="literal">libevent</code> ライブラリはインストールに含まれません。オペレーティングシステムのインストール方法を使用して、<code class="literal">libevent</code> 1.4.3 以降をインストールします。たとえば、オペレーティングシステムによっては、<code class="literal">apt-get</code>、<code class="literal">yum</code>、または <code class="literal">port install</code> コマンドを使用する場合もあります。たとえば、Ubuntu Linux で次のようにします。
          </p><pre class="programlisting">sudo apt-get install libevent-dev</pre></li><li class="listitem"><p>
            ソースコードリリースからインストールする場合、<code class="literal">libevent</code> 1.4.3 がパッケージにバンドルされており、MySQL ソースコードディレクトリの最上位レベルに配置されています。バンドルされたバージョンの <code class="literal">libevent</code> を使用する場合、アクションは不要です。ローカルシステムバージョンの <code class="literal">libevent</code> を使用する場合、<code class="option">-DWITH_LIBEVENT</code> ビルドオプションを <code class="literal">system</code> または <code class="literal">yes</code> に設定して MySQL をビルドする必要があります。
          </p></li></ul></div><h5><a name="idm139979061594096"></a>MySQL をソースからビルドするときの前提条件</h5><p>
        MySQL Server をビルドする場合、<code class="option">-DWITH_INNODB_MEMCACHED=ON</code> を指定してビルドする必要があります。このビルドオプションでは、MySQL プラグインディレクトリ (<code class="literal">plugin_dir</code>) 内に、<code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> を実行するために必要な 2 つの共有ライブラリを生成します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="filename">libmemcached.so</code>: MySQL に対する <span class="command"><strong>memcached</strong></span> デーモンプラグイン。
          </p></li><li class="listitem"><p>
            <code class="filename">innodb_engine.so</code>: <span class="command"><strong>memcached</strong></span> に対する <code class="literal">InnoDB</code> API プラグイン。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-memcached-installing"></a>14.18.3.2 InnoDB memcached プラグインのインストールおよび構成</h4></div></div></div><h5><a name="idm139979061582048"></a>必須テーブルのセットアップ</h5><a class="indexterm" name="idm139979061581376"></a><a class="indexterm" name="idm139979061579968"></a><a class="indexterm" name="idm139979061578592"></a><p>
        <code class="literal">InnoDB</code> テーブルと対話できるように <span class="command"><strong>memcached</strong></span> プラグインを構成するには、<code class="filename">innodb_memcached_config.sql</code> 構成スクリプトを実行して、バックグラウンドで使用される必要なテーブルをインストールします。
      </p><pre class="programlisting">
mysql&gt; source <em class="replaceable"><code>MYSQL_HOME</code></em>/share/innodb_memcached_config.sql
</pre><p>
        これは 1 回かぎりの操作です。あとで <span class="command"><strong>memcached</strong></span> サポートを無効化してから再度有効化した場合、テーブルはそのまま残ります。これらのテーブルのレイアウトと目的については、<a class="xref" href="innodb-storage-engine.html#innodb-memcached-internals" title="14.18.7 InnoDB memcached プラグインの内部構造">セクション14.18.7「InnoDB memcached プラグインの内部構造」</a>を参照してください。
      </p><h5><a name="idm139979061570736"></a>デーモンプラグインのインストール</h5><p>
        デーモンプラグインをアクティブ化するには、ほかの MySQL プラグインをインストールする場合と同様に、<code class="literal">install plugin</code> ステートメントを使用します。
      </p><pre class="programlisting">

mysql&gt; install plugin daemon_memcached soname "libmemcached.so";

</pre><p>
        プラグインがこのようにインストールされると、プラグインは MySQL Server がブートまたは再起動されるたびに自動的にアクティブ化されます。
      </p><h5><a name="idm139979061566832"></a>デーモンプラグインの無効化</h5><p>
        プラグイン構成に大きな変更を行う場合、プラグインをオフにすることが必要な場合があります。これを実行するには、次のステートメントを発行します。
      </p><pre class="programlisting">

mysql&gt; uninstall plugin daemon_memcached;

</pre><p>
        これをふたたび有効にするには、前述の <code class="literal">install plugin</code> ステートメントを発行します。プラグインがこの方法で再起動される場合、以前のすべての構成設定、内部テーブル、およびデータが保持されます。
      </p><p>
        プラグインの有効化および無効化についてのその他の情報は、<a class="xref" href="server-administration.html#server-plugin-loading" title="5.1.8.1 プラグインのインストールおよびアンインストール">セクション5.1.8.1「プラグインのインストールおよびアンインストール」</a>を参照してください。
      </p><h5><a name="idm139979061561520"></a>memcached 構成オプションの指定</h5><p>
        <span class="command"><strong>memcached</strong></span> に固有の構成パラメータがある場合、それらを <span class="command"><strong>mysqld</strong></span> コマンド行に指定するか、MySQL 構成ファイルに入力し、<code class="literal">daemon_memcached_option</code> MySQL 構成オプションに対する引数としてエンコードします。<span class="command"><strong>memcached</strong></span> 構成オプションは、MySQL Server が開始されるたびに実行されるプラグインのインストール時に有効になります。
      </p><p>
        たとえば、<span class="command"><strong>memcached</strong></span> がデフォルトポート 11211 ではなくポート 11222 をリッスンするするようにする場合、MySQL 構成オプション <code class="literal">daemon_memcached_option</code> に <code class="literal">-p11222</code> を追加します。
      </p><pre class="programlisting">
mysqld .... --daemon_memcached_option="-p11222"
</pre><p>
        <code class="literal">daemon_memcached_option</code> 文字列に、ほかの memcached コマンド行オプションを追加できます。ほかの構成オプションは次のとおりです。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">daemon_memcached_engine_lib_name</code> (デフォルトは <code class="filename">innodb_engine.so</code>)
          </p></li><li class="listitem"><p>
            <code class="literal">daemon_memcached_engine_lib_path</code> (デフォルトは NULL、プラグインディレクトリを表す)。
          </p></li><li class="listitem"><p>
            <code class="literal">daemon_memcached_r_batch_size</code>、読み取り操作 (<code class="literal">get</code>) のバッチコミットサイズ。これは <span class="command"><strong>memcached</strong></span> の読み取り操作を何回実行したあとにシステムが自動的に<a class="link" href="glossary.html#glos_commit" title="コミット">コミット</a>を実行するかを指定します。デフォルトでは、これは 1 に設定されるため、<span class="command"><strong>memcached</strong></span> または SQL によってデータが更新されたかどうかに関係なく、すべての <code class="literal">get</code> リクエストは <code class="literal">InnoDB</code> テーブル内のコミット済みの最新データにアクセスできます。この値が 1 より大きい場合、読み取り操作のカウンタは <code class="literal">get</code> 呼び出しのたびに増分されます。<code class="literal">flush_all</code> 呼び出しは、読み取りおよび書き込みカウンタを両方ともリセットします。
          </p></li><li class="listitem"><p>
            <code class="literal">daemon_memcached_w_batch_size</code>、すべての書き込み操作 (<code class="literal">set</code>、<code class="literal">replace</code>、<code class="literal">append</code>、<code class="literal">prepend</code>、<code class="literal">incr</code>、<code class="literal">decr</code> など) のバッチコミット。デフォルトでは、これは 1 に設定されるため、機能停止時にコミット済みでないデータは失われず、基礎テーブルへのすべての SQL クエリーは最新のデータにアクセスできます。この値が 1 より大きいとき、書き込み操作のカウンタは、すべての <code class="literal">add</code>、<code class="literal">set</code>、<code class="literal">incr</code>、<code class="literal">decr</code>、および <code class="literal">delete</code> 呼び出しのたびに 1 回増分されます。<code class="literal">flush_all</code> 呼び出しは、読み取りおよび書き込みカウンタを両方ともリセットします。
          </p></li></ul></div><p>
        デフォルトでは、最初の 2 つの構成オプションを変更する必要はありません。これらのオプションによって、<span class="command"><strong>memcached</strong></span> のために別のストレージエンジン (NDB <span class="command"><strong>memcached</strong></span> エンジンなど) をロードできます。
      </p><p>
        繰り返しになりますが、これらの構成パラメータは、MySQL 構成ファイルまたは MySQL ブートコマンド行で指定します。これらは、<span class="command"><strong>memcached</strong></span> プラグインをロードしたときに有効になります。
      </p><h5><a name="idm139979061521360"></a>サマリー</h5><p>
        これで、すべてセットアップできました。<span class="command"><strong>memcached</strong></span> インタフェースを介して InnoDB テーブルと直接対話できます。この機能が正常に動作していることを検証するには、<a class="xref" href="innodb-storage-engine.html#innodb-memcached-snifftest" title="14.18.3.3 InnoDB および memcached 設定の検証">セクション14.18.3.3「InnoDB および memcached 設定の検証」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-memcached-snifftest"></a>14.18.3.3 InnoDB および memcached 設定の検証</h4></div></div></div><p>
        すべてのセットアップが完了したので、InnoDB と <span class="command"><strong>memcached</strong></span> の組み合わせについて実験できます。
      </p><p>
        Unix、Linux、または OS X コマンドシェル使用した例を示します。
      </p><pre class="programlisting">
# Point memcached-related commands at the memcached attached to the mysqld process.
export MEMCACHED_SERVERS=127.0.0.1:11211
# Store the contents of a modestly sized text file in memcached, with the data passed
# to MySQL and stored in a table. The key is the basename of the file, 'mime.types'.
memcp /etc/apache2/mime.types
# Retrieve the data we just stored, from the memory cache.
memcat mime.types
</pre><p>
        <span class="command"><strong>telnet</strong></span> を使用して <span class="command"><strong>memcached</strong></span> コマンドを送信し、ASCII プロトコルを介して結果を受け取る例を示します。
      </p><pre class="programlisting">
<strong class="userinput"><code>telnet 127.0.0.1 11211</code></strong>
<strong class="userinput"><code>set a11 10 0 9</code></strong>
<strong class="userinput"><code>123456789</code></strong>
STORED
<strong class="userinput"><code>get a11</code></strong>
VALUE a11 0 9
123456789
END
<strong class="userinput"><code>quit</code></strong>
</pre><p>
        すべての同じデータが MySQL に格納されたことを確認するには、MySQL Server に接続して次のコマンドを発行します。
      </p><pre class="programlisting">

mysql&gt; select * from test.demo_test;

</pre><p>
        ここで MySQL Server をシャットダウンすると、統合済みの <span class="command"><strong>memcached</strong></span> サーバーも停止します。さらに <span class="command"><strong>memcached</strong></span> データにアクセスしようとすると、今度は接続エラーで失敗します。通常であれば、<span class="command"><strong>memcached</strong></span> データはこの時点で消失し、<span class="command"><strong>memcached</strong></span> の再起動時にデータをメモリーにロードするようアプリケーションロジックを記述します。ただし、MySQL と <span class="command"><strong>memcached</strong></span> の統合により、このプロセスが自動化されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            MySQL Server を再起動します。
          </p></li><li class="listitem"><p>
            <code class="literal">install plugin</code> ステートメントを実行して InnoDB <code class="literal">memcached</code> プラグインを再起動します。
          </p></li><li class="listitem"><p>
            ここで、すべての <span class="command"><strong>memcat</strong></span> コマンドまたは <code class="literal">get</code> 操作により、以前の <span class="command"><strong>memcached</strong></span> セッションで格納されていたキー/値のペアがふたたび戻されます。キーのリクエスト時、関連付けられた値がメモリーキャッシュにまだ存在しない場合、MySQL テーブル (デフォルトでは <code class="literal">test.demo_test</code>) から自動的にクエリーされます。
          </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-memcached-security"></a>14.18.4 InnoDB memcached プラグインのセキュリティーに関する考慮事項</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-sasl">14.18.4.1 SASL による memcached インタフェースのパスワード保護</a></span></dt></dl></div><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注意</div><p>
        <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインを本番サーバーに配備する前に (MySQL インスタンスに機密情報が格納されている場合はテストサーバーも含む)、このセクションを参照してください。
      </p></div><p>
      <span class="command"><strong>memcached</strong></span> はデフォルトで認証メカニズムを使用せず、オプションの SASL 認証が従来の DBMS セキュリティー対策ほど強くないため、<code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインを使用する MySQL インスタンスには機密情報以外のデータのみを保持するようにし、この構成を使用するサーバーへの潜在的な侵入を防止します。このようなサーバーへの <span class="command"><strong>memcached</strong></span> アクセスはインターネットからは許可せず、ファイアウォールで保護されたイントラネット内部からのみとし、ユーザーがメンバーシップを制限できるサブネットからのアクセスが適しています。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-memcached-sasl"></a>14.18.4.1 SASL による memcached インタフェースのパスワード保護</h4></div></div></div><a class="indexterm" name="idm139979061481776"></a><a class="indexterm" name="idm139979061480464"></a><a class="indexterm" name="idm139979061478928"></a><a class="indexterm" name="idm139979061476800"></a><a class="indexterm" name="idm139979061474672"></a><p>
        SASL サポートにより、<span class="command"><strong>memcached</strong></span> クライアントを介した未認証アクセスから MySQL データベースを保護する機能を使用できます。このセクションでは、このオプションを使用可能にするステップを説明します。このようなサポートを可能にするステップは、従来の <span class="command"><strong>memcached</strong></span> サーバーで SASL を使用可能にするためのステップとほとんど同じです。
      </p><h5><a name="idm139979061469840"></a>バックグラウンド情報</h5><p>
        SASL とは<span class="quote">「<span class="quote">Simple Authentication and Security Layer</span>」</span>を意味し、接続ベースのプロトコルに対して認証サポートを追加するための規格です。<span class="command"><strong>memcached</strong></span> には 1.4.3 リリースから SASL サポートが追加されました。
      </p><p>
        SASL 認証はバイナリプロトコルでのみサポートされます。
      </p><p>
        InnoDB + <span class="command"><strong>memcached</strong></span> の組み合わせの場合、<span class="command"><strong>memcached</strong></span> データを格納するテーブルは、<code class="literal">container</code> システムテーブルに登録する必要があります。また、<span class="command"><strong>memcached</strong></span> クライアントはこのような登録済みのテーブルにのみアクセスできます。 <span class="command"><strong>memcached</strong></span> プラグインに登録されたテーブルに、DBA のアクセス制限を追加できますが、<span class="command"><strong>memcached</strong></span> アプリケーション経由でのアクセス可能なユーザーの制御はできません。このため、<span class="command"><strong>memcached</strong></span> に関連付けられた <code class="literal">InnoDB</code> テーブルにアクセス可能なユーザーを制御するための (SASL 経由の) 手段が提供されています。
      </p><p>
        次のセクションでは、SASL 対応の <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインをビルド、有効化、およびテストする方法を示しています。
      </p><h5><a name="idm139979061457104"></a>InnoDB Memcached プラグインの SASL をビルドおよび使用可能にするためのステップ</h5><p>
        デフォルトでは、SASL 対応の <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> は、SASL ライブラリを使用した <span class="command"><strong>memcached</strong></span> のビルドに依存しているため、リリースパッケージに含まれていません。この機能を有効にするには、MySQL ソースをダウンロードし、SASL ライブラリをダウンロードしたあとに <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインを再ビルドします。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            最初に、SASL 開発ライブラリおよびユーティリティーライブラリを取得します。たとえば、Ubuntu では、次のようにしてこれらのライブラリを取得できます。
          </p><pre class="programlisting">
sudo apt-get -f install libsasl2-2 sasl2-bin libsasl2-2 libsasl2-dev libsasl2-modules
</pre></li><li class="listitem"><p>
            次に、<code class="literal">ENABLE_MEMCACHED_SASL=1</code> を <span class="command"><strong>cmake</strong></span> オプションに追加することによって、SASL 機能を有する <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグイン (共有ライブラリ) をビルドします。さらに、<span class="command"><strong>memcached</strong></span> はテストに簡単に使用できる単純な平文パスワードサポートを提供しています。これを有効にするには、オプション <code class="literal">ENABLE_MEMCACHED_SASL_PWDB=1</code> を設定します。
          </p><p>
            全体として、次の 3 つのオプションを <span class="command"><strong>cmake</strong></span> に追加します。
          </p><pre class="programlisting">
cmake ... -DWITH_INNODB_MEMCACHED=1
  -DENABLE_MEMCACHED_SASL=1 -DENABLE_MEMCACHED_SASL_PWDB=1
</pre></li><li class="listitem"><p>
            3 番目のステップでは、<a class="xref" href="innodb-storage-engine.html#innodb-memcached-setup" title="14.18.3 InnoDB Memcached プラグインの概要">セクション14.18.3「InnoDB Memcached プラグインの概要」</a>で説明したように、<code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインを以前のようにインストールします。
          </p></li><li class="listitem"><p>
            以前説明したように、<span class="command"><strong>memcached</strong></span> には SASL による単純な平文パスワードサポートが提供されており、このデモで使用します。
          </p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>
                <code class="literal">testname</code> という名前のユーザーと、そのパスワード <code class="literal">testpasswd</code> をファイル内に作成します。
              </p><pre class="programlisting">

echo "testname:testpasswd:::::::" &gt;/home/jy/memcached-sasl-db

</pre></li><li class="listitem"><p>
                環境変数 <code class="literal">MEMCACHED_SASL_PWDB</code> を設定することによって <span class="command"><strong>memcached</strong></span> にこの情報を通知します。
              </p><pre class="programlisting">
export MEMCACHED_SASL_PWDB=/home/jy/memcached-sasl-db
</pre></li><li class="listitem"><p>
                さらに、これが平文パスワードであることも <span class="command"><strong>memcached</strong></span> に通知します。
              </p><pre class="programlisting">

echo "mech_list: plain" &gt; /home/jy/work2/msasl/clients/memcached.conf
export SASL_CONF_PATH=/home/jy/work2/msasl/clients/memcached.conf

</pre></li></ol></div></li><li class="listitem"><p>
            次に、サーバーをリブートし、<code class="literal">daemon_memcached_option</code> オプション <code class="literal">-S</code> を追加して SASL を有効にします。
          </p><pre class="programlisting">
mysqld ... --daemon_memcached_option="-S"
</pre></li><li class="listitem"><p>
            これでセットアップは完了しました。これをテストするには、この <a class="ulink" href="https://code.launchpad.net/~trond-norbye/libmemcached/sasl" target="_top">SASL 対応 libmemcached</a> のような SASL 対応クライアントが必要な場合もあります。
          </p><pre class="programlisting">
memcp --servers=localhost:11211 --binary  --username=testname
  --password=testpasswd myfile.txt

memcat --servers=localhost:11211 --binary --username=testname
  --password=testpasswd myfile.txt
</pre><p>
            適切なユーザー名またはパスワードがないと、前述の操作はエラーメッセージ <code class="literal">memcache error AUTHENTICATION FAILURE</code> で拒否されます。それ以外の場合、操作は成功です。また、<code class="filename">memcached-sasl-db</code> ファイルに設定された平文パスワードを調査して、これを検証することもできます。
          </p></li></ol></div><p>
        <span class="command"><strong>memcached</strong></span> での SASL 認証を検査する方法はほかにもあります。ただし、上に記載されたものがもっとも簡単です。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-memcached-developing"></a>14.18.5 InnoDB memcached インタフェース用のアプリケーションの作成</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-porting-mysql">14.18.5.1 memcached アプリケーションに対する既存の MySQL スキーマの改変</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-porting-memcached">14.18.5.2 統合型の memcached デーモンのための既存の memcached アプリケーションの改変</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-tuning">14.18.5.3 InnoDB memcached プラグインのパフォーマンスのチューニング</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-txn">14.18.5.4 InnoDB memcached プラグインのトランザクション動作の制御</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-dml">14.18.5.5 memcached 操作に合わせた DML ステートメントの改変</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-memcached-ddl">14.18.5.6 ベースとなる InnoDB テーブルでの DML および DDL ステートメントの実行</a></span></dt></dl></div><p>
      一般的に、<code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> インタフェース用のアプリケーションの作成には、MySQL または <span class="command"><strong>memcached</strong></span> API を使用する既存コードの再作成または改変が含まれます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          多くの <span class="command"><strong>memcached</strong></span> サーバーを低性能のマシン上で実行させる代わりに、MySQL Server と同数の <span class="command"><strong>memcached</strong></span> サーバーを用意し、十分な量のディスクストレージおよびメモリーを持つ比較的高性能のマシン上で実行させます。<span class="command"><strong>memcached</strong></span> API とともに動作する既存のコードを一部再利用する場合もありますが、サーバー構成が異なるため、一部の改変が必要になる場合があります。
        </p></li><li class="listitem"><p>
          このインタフェースから格納されたデータはすべて、<code class="literal">VARCHAR</code>、<code class="literal">TEXT</code>、または <code class="literal">BLOB</code> カラムに入るため、数値的な操作を行うために変換する必要があります。この変換は、アプリケーション側で行うことも、クエリー内で <code class="literal">CAST()</code> 関数を使用して行うこともできます。
        </p></li><li class="listitem"><p>
          データベースバックグラウンドから使用する場合、多くのカラムを備えた汎用の SQL テーブルを使用する場合があります。<span class="command"><strong>memcached</strong></span> コードによってアクセスするテーブルは、データ値を保持するカラムが 2 つか 3 つ、または 1 つのみの場合もあります。
        </p></li><li class="listitem"><p>
          コードの重要なセクションからパフォーマンスを引き出すために、単一行のクエリー、挿入、更新、または削除を実行するアプリケーションの一部を改変することがあります。<a class="link" href="glossary.html#glos_query" title="クエリー">クエリー</a> (読み取り) および <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> (書き込み) の両方の操作は、<span class="command"><strong>memcached</strong></span> インタフェースを介して実行すると大幅に高速化できます。書き込み速度の向上は読み取り速度の向上より大きいため、ロギングを行なったり、Web サイトでの対話を記録したりするコードの改変に的を絞るのがよい場合もあります。
        </p></li></ul></div><p>
      次のセクションでは、これらの側面をより詳細に見ていきます。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-memcached-porting-mysql"></a>14.18.5.1 memcached アプリケーションに対する既存の MySQL スキーマの改変</h4></div></div></div><p>
        <span class="command"><strong>memcached</strong></span> インタフェースを使用するために既存の MySQL スキーマまたはアプリケーションを改変する場合、<span class="command"><strong>memcached</strong></span> アプリケーションの次の点を検討してください。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            スペースまたは改行文字は ASCII プロトコルで区切り文字として使用されるため、<span class="command"><strong>memcached</strong></span> のキーにこれらの文字を含めることはできません。スペースを含む検索値を使用する場合は、<code class="literal">add()</code>、<code class="literal">set()</code>、<code class="literal">get()</code> などの呼び出しでこれらをキーとして使用する前に、スペースのない値に変換またはハッシュします。これらの文字は、理論上、バイナリプロトコルを使用するプログラム内でキーとして許可されますが、さまざまなクライアントとの互換性を確保するために、キーに使用される文字を常に制限します。
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> テーブルに短い数値の<a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a>カラムがある場合、整数を文字列値に変換すると、<span class="command"><strong>memcached</strong></span> の一意の検索キーとして使用できます。<span class="command"><strong>memcached</strong></span> サーバーが複数のアプリケーションで使用される場合、または複数の <code class="literal">InnoDB</code> テーブルとともに使用される場合、一意性を保つために名前の変更を検討してください。たとえば、数値の前にテーブル名やデータベース名とテーブル名を付けます。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              MySQL 5.6.14 以降では、<code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインは、主キーとして <code class="literal">INTEGER</code> が定義されたマップ済み <code class="literal">InnoDB</code> テーブル上での挿入および読み取りをサポートします。
            </p></div></li><li class="listitem"><p>
            <span class="command"><strong>memcached</strong></span> インタフェースからクエリーを実行したり格納したりしたデータについて、パーティション化されたテーブルは使用できません。
          </p></li><li class="listitem"><p>
            <span class="command"><strong>memcached</strong></span> プロトコルは数値を文字列として渡します。ベースとなる <code class="literal">InnoDB</code> テーブルに数値を格納する場合、たとえば、<code class="literal">SUM()</code> や <code class="literal">AVG()</code> などの SQL 関数に使用できるカウンタを実装するには、次のようにします。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                予想される最大数のすべての桁 (さらに該当する場合はマイナス符号、小数点またはその両方に対する追加の文字) を保持するために十分な文字がある <code class="literal">VARCHAR</code> カラムを使用します。
              </p></li><li class="listitem"><p>
                カラム値を使用して計算を実行するすべてのクエリー内で、<code class="literal">CAST()</code> 関数を使用して、文字列から整数またはその他の数値型に変換します。例:
              </p><pre class="programlisting">
-- Alphabetic entries are returned as zero.
select cast(c2 as unsigned integer) from demo_test;
-- Since there could be numeric values of 0, can't disqualify them.
-- Test the string values to find the ones that are integers, and average only those.
select avg(cast(c2 as unsigned integer)) from demo_test
  where c2 between '0' and '9999999999';
-- Views let you hide the complexity of queries. The results are already converted;
-- no need to repeat conversion functions and WHERE clauses each time.
create view numbers as select c1 key, cast(c2 as unsigned integer) val
  from demo_test where c2 between '0' and '9999999999';
select sum(val) from numbers;
</pre><p>
                結果セット内のアルファベットの値は、<code class="literal">CAST()</code> の呼び出しによって 0 に変換されます。結果セット内の行数に依存する <code class="literal">AVG()</code> などの関数を使用する場合、数値以外の値を取り除くための <code class="literal">WHERE</code> 句を含めるようにします。
              </p></li></ul></div></li><li class="listitem"><p>
            キーとして使用する <code class="literal">InnoDB</code> カラムが 250 バイトよりも長くなる可能性がある場合、250 バイト未満の値になるようにハッシュします。
          </p></li><li class="listitem"><p>
            <span class="command"><strong>memcached</strong></span> インタフェースで既存のテーブルを使用するには、そのテーブルのためのエントリを <code class="literal">innodb_memcache.containers</code> テーブル内に定義します。<span class="command"><strong>memcached</strong></span> を介して中継されるリクエストでテーブルをデフォルトに指定する場合、<code class="literal">name</code> カラムに値 <code class="literal">default</code> を指定し、その後 MySQL Server を再起動して変更を有効にします。異なる種類の <span class="command"><strong>memcached</strong></span> データに対して複数のテーブルを使用している場合、ユーザーの選択した <code class="literal">name</code> 値を使用して <code class="literal">innodb_memcache.containers</code> テーブル内に複数のエントリをセットアップし、次にアプリケーション内で <code class="literal">get @@<em class="replaceable"><code>name</code></em></code> または <code class="literal">set @@<em class="replaceable"><code>name</code></em></code> の形式で <span class="command"><strong>memcached</strong></span> リクエストを発行し、<span class="command"><strong>memcached</strong></span> API を経由する後続のリクエストについて使用されるテーブルを切り換えます。
          </p><p>
            事前定義された <code class="literal">test.demo_test</code> テーブル以外のテーブルを使用する例については、<a class="xref" href="innodb-storage-engine.html#innodb-memcached-tutorial-python" title="例 14.23 InnoDB + memcached アプリケーションのためのテーブルおよびカラムマッピングの指定">例14.23「InnoDB + memcached アプリケーションのためのテーブルおよびカラムマッピングの指定」</a>を参照してください。そのようなテーブルの必要なレイアウトとカラムの意味については、<a class="xref" href="innodb-storage-engine.html#innodb-memcached-internals" title="14.18.7 InnoDB memcached プラグインの内部構造">セクション14.18.7「InnoDB memcached プラグインの内部構造」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <span class="command"><strong>memcached</strong></span> のキー/値のペアによって複数の MySQL カラム値を使用するには、MySQL テーブルに関連付けられた <code class="literal">innodb_memcache.containers</code> エントリ内で、<code class="literal">value_columns</code> フィールドに、カンマ、セミコロン、スペース、またはパイプ文字で区切られた複数のカラム名を指定します。たとえば、<code class="literal">col1,col2,col3</code> または <code class="literal">col1|col2|col3</code> のようになります。
          </p><p>
            カラム値を、パイプ文字を区切り文字として使用した単一文字列になるように連結したあとで、その文字列を <span class="command"><strong>memcached</strong></span> の <code class="literal">add</code> または <code class="literal">set</code> 呼び出しに渡します。文字列はさまざまなカラムに自動的にアンパックされます。個々の <code class="literal">get</code> 呼び出しは、やはりパイプ区切り文字によって区切られている複数のカラム値を含む単一文字列を返します。アプリケーション言語に応じた適切な構文を使用して、これらの値をアンパックします。
          </p></li></ul></div><div class="example"><a name="innodb-memcached-tutorial-python"></a><p class="title"><b>例 14.23 InnoDB + memcached アプリケーションのためのテーブルおよびカラムマッピングの指定</b></p><div class="example-contents"><p>
          ここで、データ操作のために <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインを使用する MySQL アプリケーションのためにユーザー独自のデータを使用する方法の例を示します。
        </p><p>
          最初に、一部の国別データを保持するテーブルをセットアップします。データは、人口、メートル法で示した面積、右または左のどちら側を運転するかを示す <code class="literal">'R'</code> または <code class="literal">'L'</code> です。
        </p><pre class="programlisting">
use test;

CREATE TABLE `multicol` (
  `country` varchar(128) NOT NULL DEFAULT '',
  `population` varchar(10) DEFAULT NULL,
  `area_sq_km` varchar(9) DEFAULT NULL,
  `drive_side` varchar(1) DEFAULT NULL,
  `c3` int(11) DEFAULT NULL,
  `c4` bigint(20) unsigned DEFAULT NULL,
  `c5` int(11) DEFAULT NULL,
  PRIMARY KEY (`country`),
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
</pre><p>
          ここで、<code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインがこのテーブルにアクセスする方法を認識するように、このテーブルのディスクリプタを作成します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">CONTAINERS</code> テーブル内のサンプルエントリは、<code class="literal">name</code> カラムが <code class="literal">'aaa'</code> で、別の識別子 <code class="literal">'bbb'</code> をセットアップします。使用するすべての <span class="command"><strong>memcached</strong></span> アプリケーションに対して単一のマスターテーブルを作成した場合、ID を <code class="literal">'default'</code> にして、テーブルを切り換えるための <code class="literal">@@</code> リクエストをスキップします。
            </p></li><li class="listitem"><p>
              <code class="literal">test.multicol</code> テーブルを指定します。スキーマ名は 1 つのカラムに格納され、テーブル名は別のカラムに格納されます。
            </p></li><li class="listitem"><p>
              キーカラムは一意の <code class="literal">country</code> 値です。このカラムは上記のテーブルを作成するときに主キーに指定されたため、ここでインデックス名 <code class="literal">'PRIMARY'</code> も指定します。
            </p></li><li class="listitem"><p>
              1 つの複合データを単一カラムに保持する代わりにデータを 3 つのテーブルカラムに分割するため、値を格納または取得するときに使用されるカラムのカンマ区切りリストを指定します。
            </p></li><li class="listitem"><p>
              さらに、フラグ、期限切れ、および CAS 値については、サンプルテーブル <code class="literal">demo.test</code> の設定に基づく対応するカラムを指定します。これらの値は、<code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインを使用するアプリケーションでは通常はあまり重要ではありません。MySQL がデータの同期を保持するため、データが期限切れになったり古くなったりすることを心配する必要がないためです。
            </p></li></ul></div><pre class="programlisting">
insert into innodb_memcache.containers
  (name,db_schema,db_table,key_columns,value_columns,flags,cas_column,
  expire_time_column,unique_idx_name_on_key)
values
  ('bbb','test','multicol','country','population,area_sq_km,drive_side',
  'c3','c4','c5','PRIMARY');

commit;
</pre><p>
          ここで、プログラムからこのテーブルにアクセスする方法を示すサンプル Python プログラムを示します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              すべてのデータ操作は <span class="command"><strong>memcached</strong></span> インタフェースを介して実行されるため、データベース許可は不要です。知る必要があるのは、<span class="command"><strong>memcached</strong></span> デーモンがローカルシステム上でリスニングするポート番号のみです。
            </p></li><li class="listitem"><p>
              任意のいくつかの国のサンプル値をロードします。(ウィキペディアからの面積および人口の数値。)
            </p></li><li class="listitem"><p>
              プログラムで <code class="literal">multicol</code> テーブルを使用するために、<code class="literal">@@</code> 表記を使用してダミーの <code class="literal">GET</code> または <code class="literal">SET</code> リクエストを行う <code class="literal">switch_table()</code> 関数を呼び出します。リクエスト内の名前は <code class="literal">bbb</code> で、これは <code class="literal">innodb_memcache.containers.name</code> に格納されている値です。(実際のアプリケーションでは、さらに記述的な名前を使用します。この例では、<code class="literal">GET @@...</code> リクエストでテーブル名でなくテーブル識別子を指定することを示しています。
            </p></li><li class="listitem"><p>
              データを挿入してクエリーを実行するためのユーティリティー関数は、<code class="literal">ADD</code> または <code class="literal">SET</code> リクエストによって MySQL に送信するために Python データ構造をパイプ区切り値に変換し、<code class="literal">GET</code> リクエストによって返されるパイプ区切り値をアンパックするための方法を示します。この特別な処理は、単一の <span class="command"><strong>memcached</strong></span> 値を複数の MySQL テーブルカラムにマッピングする場合にのみ必要です。
            </p></li></ul></div><pre class="programlisting">
import sys, os
import memcache

def connect_to_memcached():
  memc = memcache.Client(['127.0.0.1:11211'], debug=0);
  print "Connected to memcached."
  return memc

def banner(message):
  print
  print "=" * len(message)
  print message
  print "=" * len(message)

country_data = [
("Canada","34820000","9984670","R"),
("USA","314242000","9826675","R"),
("Ireland","6399152","84421","L"),
("UK","62262000","243610","L"),
("Mexico","113910608","1972550","R"),
("Denmark","5543453","43094","R"),
("Norway","5002942","385252","R"),
("UAE","8264070","83600","R"),
("India","1210193422","3287263","L"),
("China","1347350000","9640821","R"),
]

def switch_table(memc,table):
  key = "@@" + table
  print "Switching default table to '" + table + "' by issuing GET for '" + key + "'."
  result = memc.get(key)

def insert_country_data(memc):
  banner("Inserting initial data via memcached interface")
  for item in country_data:
    country = item[0]
    population = item[1]
    area = item[2]
    drive_side = item[3]

    key = country
    value = "|".join([population,area,drive_side])
    print "Key = " + key
    print "Value = " + value

    if memc.add(key,value):
      print "Added new key, value pair."
    else:
      print "Updating value for existing key."
      memc.set(key,value)

def query_country_data(memc):
  banner("Retrieving data for all keys (country names)")
  for item in country_data:
    key = item[0]
    result = memc.get(key)
    print "Here is the result retrieved from the database for key " + key + ":"
    print result
    (m_population, m_area, m_drive_side) = result.split("|")
    print "Unpacked population value: " + m_population
    print "Unpacked area value      : " + m_area
    print "Unpacked drive side value: " + m_drive_side

if __name__ == '__main__':

  memc = connect_to_memcached()
  switch_table(memc,"bbb")
  insert_country_data(memc)
  query_country_data(memc)

  sys.exit(0)
</pre><p>
          ここに示すいくつかの SQL クエリーは、スクリプトが実行されたあとの MySQL データの状態を示し、SQL を介して同じデータに直接アクセスしたり、適切な <a class="link" href="connectors-apis.html" title="第 23 章 Connector および API">MySQL コネクタまたは API</a> を使用する任意の言語で記述されたアプリケーションからアクセスしたりする方法を示します。
        </p><p>
          テーブルディスクリプタ <code class="literal">'bbb'</code> があるため、<span class="command"><strong>memcached</strong></span> リクエスト <code class="literal">GET @bbb</code> を発行すると、<code class="literal">multicol</code> テーブルに切り換えることができます。
        </p><pre class="programlisting">
mysql: use innodb_memcache;
Database changed

mysql: select * from containers;
+------+-----------+-----------+-------------+----------------------------------+-------+------------+--------------------+------------------------+
| name | db_schema | db_table  | key_columns | value_columns                    | flags | cas_column | expire_time_column | unique_idx_name_on_key |
+------+-----------+-----------+-------------+----------------------------------+-------+------------+--------------------+------------------------+
| aaa  | test      | demo_test | c1          | c2                               | c3    | c4         | c5                 | PRIMARY                |
| bbb  | test      | multicol  | country     | population,area_sq_km,drive_side | c3    | c4         | c5                 | PRIMARY                |
+------+-----------+-----------+-------------+----------------------------------+-------+------------+--------------------+------------------------+
2 rows in set (0.01 sec)
</pre><p>
          スクリプトを実行したあと、データは <code class="literal">multicol</code> テーブル内にあり、従来の MySQL <a class="link" href="glossary.html#glos_query" title="クエリー">クエリー</a>または <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> ステートメントから入手できます。
        </p><pre class="programlisting">
mysql: use test;
Database changed

mysql: select * from multicol;
+---------+------------+------------+------------+------+------+------+
| country | population | area_sq_km | drive_side | c3   | c4   | c5   |
+---------+------------+------------+------------+------+------+------+
| Canada  | 34820000   | 9984670    | R          |    0 |   11 |    0 |
| China   | 1347350000 | 9640821    | R          |    0 |   20 |    0 |
| Denmark | 5543453    | 43094      | R          |    0 |   16 |    0 |
| India   | 1210193422 | 3287263    | L          |    0 |   19 |    0 |
| Ireland | 6399152    | 84421      | L          |    0 |   13 |    0 |
| Mexico  | 113910608  | 1972550    | R          |    0 |   15 |    0 |
| Norway  | 5002942    | 385252     | R          |    0 |   17 |    0 |
| UAE     | 8264070    | 83600      | R          |    0 |   18 |    0 |
| UK      | 62262000   | 243610     | L          |    0 |   14 |    0 |
| USA     | 314242000  | 9826675    | R          |    0 |   12 |    0 |
+---------+------------+------------+------------+------+------+------+
10 rows in set (0.00 sec)

mysql: desc multicol;
+------------+---------------------+------+-----+---------+-------+
| Field      | Type                | Null | Key | Default | Extra |
+------------+---------------------+------+-----+---------+-------+
| country    | varchar(128)        | NO   | PRI |         |       |
| population | varchar(10)         | YES  |     | NULL    |       |
| area_sq_km | varchar(9)          | YES  |     | NULL    |       |
| drive_side | varchar(1)          | YES  |     | NULL    |       |
| c3         | int(11)             | YES  |     | NULL    |       |
| c4         | bigint(20) unsigned | YES  |     | NULL    |       |
| c5         | int(11)             | YES  |     | NULL    |       |
+------------+---------------------+------+-----+---------+-------+
7 rows in set (0.01 sec)
</pre><p>
          数値として扱われるカラムの長さを定義する場合、必要な桁、小数点、符号文字、先行ゼロなどを保持する十分なサイズを考慮します。<code class="literal">VARCHAR</code> などの文字列カラム内で値が長すぎると、その値は一部の文字を削除して切り捨てられ、不適切な数値が生成されることがあります。
        </p><p>
          SQL クエリーを使用して、<code class="literal">country</code> キーカラムだけでなく任意のカラムを使用して計算およびテストを行うと、レポートを作成できます。(これらの例では少数の国のデータのみが使用されているため、数値は例示のみを目的としています。)ここで、右側を運転する国の平均人口と、名前が<span class="quote">「<span class="quote">U</span>」</span>で始まる国の平均面積を求めます。
        </p><pre class="programlisting">
mysql: select avg(population) from multicol where drive_side = 'R';
+-------------------+
| avg(population)   |
+-------------------+
| 261304724.7142857 |
+-------------------+
1 row in set (0.00 sec)

mysql: select sum(area_sq_km) from multicol where country like 'U%';
+-----------------+
| sum(area_sq_km) |
+-----------------+
|        10153885 |
+-----------------+
1 row in set (0.00 sec)
</pre><p>
          <code class="literal">population</code> および <code class="literal">area_sq_km</code> カラムは厳密に型指定された数値データでなく文字データを格納するため、<code class="literal">avg()</code> や <code class="literal">sum()</code> などの関数は、最初にそれぞれの値を数値に変換します。この手法は <code class="literal">&lt;</code> や <code class="literal">&gt;</code> などの演算子では<span class="emphasis"><em>機能せず</em></span>、 たとえば、文字ベースの値を比較するとき、<code class="literal">9 &gt; 1000</code> となり、これは <code class="literal">ORDER BY population DESC</code> などの句で予期される結果ではありません。もっとも正確な型処理を行うには、数値カラムを適切な型にキャストするビューに対してクエリーを実行します。この技法では、非常に単純な <code class="literal">SELECT *</code> クエリーをデータベースアプリケーションから発行でき、キャスト、フィルタ、および並べ替えがすべて正しくなります。ここで、人口の上位 3 か国を降順で求めるためにクエリーを実行するビューを作成します。結果は常に <code class="literal">multicol</code> テーブルからの最新データを反映し、人口と面積は常に数値として扱われます。
        </p><pre class="programlisting">
mysql: create view populous_countries as
  select
    country,
    cast(population as unsigned integer) population,
    cast(area_sq_km as unsigned integer) area_sq_km,
    drive_side from multicol
  order by cast(population as unsigned integer) desc
  limit 3;
Query OK, 0 rows affected (0.01 sec)

mysql: select * from populous_countries;
+---------+------------+------------+------------+
| country | population | area_sq_km | drive_side |
+---------+------------+------------+------------+
| China   | 1347350000 |    9640821 | R          |
| India   | 1210193422 |    3287263 | L          |
| USA     |  314242000 |    9826675 | R          |
+---------+------------+------------+------------+
3 rows in set (0.00 sec)

mysql: desc populous_countries;
+------------+---------------------+------+-----+---------+-------+
| Field      | Type                | Null | Key | Default | Extra |
+------------+---------------------+------+-----+---------+-------+
| country    | varchar(128)        | NO   |     |         |       |
| population | bigint(10) unsigned | YES  |     | NULL    |       |
| area_sq_km | int(9) unsigned     | YES  |     | NULL    |       |
| drive_side | varchar(1)          | YES  |     | NULL    |       |
+------------+---------------------+------+-----+---------+-------+
4 rows in set (0.02 sec)
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-memcached-porting-memcached"></a>14.18.5.2 統合型の memcached デーモンのための既存の memcached アプリケーションの改変</h4></div></div></div><p>
        MySQL 統合を使用するために既存の <span class="command"><strong>memcached</strong></span> アプリケーションを改変するときは、MySQL および <code class="literal">InnoDB</code> テーブルの次の側面について検討してください。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            数バイトよりも長いキー値を持つ場合、<code class="literal">InnoDB</code> テーブルの<a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a>に対して自動インクリメントする数値カラムを使用し、<span class="command"><strong>memcached</strong></span> のキー値を保持するカラムに一意の<a class="link" href="glossary.html#glos_secondary_index" title="セカンダリインデックス">セカンダリインデックス</a>を作成する方が効率的な場合もあります。これは、主キー値が (自動インクリメント値を使用したときのように) ソートされた順に追加される場合、大規模な挿入で <code class="literal">InnoDB</code> のパフォーマンスが最大になり、主キー値が各セカンダリインデックスに複製され、主キーが長い文字列値の場合に不要なスペースを占有する可能性があるためです。
          </p></li><li class="listitem"><p>
            いくつかの異なる種類の情報を <span class="command"><strong>memcached</strong></span> に格納するとき、データの種類ごとに別個の <code class="literal">InnoDB</code> テーブルをセットアップすることがあります。<code class="literal">innodb_memcache.containers</code> テーブル内に追加のテーブル識別子を定義し、<code class="literal">@@<em class="replaceable"><code>table_id</code></em>.<em class="replaceable"><code>key</code></em></code> の表記を使用して、項目を異なるテーブルに格納したり取得したりします。項目を物理的に分割することで、各テーブルの特性を調整すると、最適なスペース使用率、パフォーマンス、および信頼性を得ることができます。たとえば、ブログ投稿を保持するテーブルに対して<a class="link" href="glossary.html#glos_compression" title="圧縮">圧縮</a>を有効にし、サムネイル画像を保持するテーブルを有効にしない場合があります。非常に重要なデータが保持されているテーブルは、別のテーブルよりも頻繁にバックアップする場合もあります。SQL を介してレポートを生成するために頻繁に使用されるテーブルで、追加の<a class="link" href="glossary.html#glos_secondary_index" title="セカンダリインデックス">セカンダリインデックス</a>を作成する場合もあります。
          </p></li><li class="listitem"><p>
            できれば、<span class="command"><strong>memcached</strong></span> インタフェースで使用する安定したテーブル定義セットをセットアップし、永続的に保存します。<code class="literal">containers</code> テーブルへの変更は、テーブルに対してクエリーが次回実行されたときに有効になります。そのテーブル内のエントリは起動時に処理され、認識されていないテーブル ID が <code class="literal">@@</code> 表記によってリクエストされるたびに参照されます。そのため、新しいエントリは、関連付けられたテーブル ID を使用しようとするとただちに表示されますが、既存のエントリではエントリが有効になる前にサーバーの再起動が必要です。
          </p></li><li class="listitem"><p>
            デフォルトのキャッシュポリシー <code class="literal">innodb_only</code> を使用するとき、<code class="literal">add()</code>、<code class="literal">set()</code>、<code class="literal">incr()</code> などの呼び出しは成功しますが、<code class="literal">while expecting 'STORED', got unexpected response 'NOT_STORED</code> などのデバッグメッセージが発生します。これは、<code class="literal">innodb_only</code> 構成では、新しい値と更新された値が、メモリーキャッシュに保存されることなく <code class="literal">InnoDB</code> テーブルに直接送信されるためです。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-memcached-tuning"></a>14.18.5.3 InnoDB memcached プラグインのパフォーマンスのチューニング</h4></div></div></div><p>
        <code class="literal">InnoDB</code> と <span class="command"><strong>memcached</strong></span> を組み合わせて使用すると、すべてのデータを即座にまたはしばらくしてからディスクに書き込むため、パフォーマンスが、<span class="command"><strong>memcached</strong></span> のみを使用する場合よりも若干低くなります。<code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインのチューニングでは、同等の SQL 操作よりも高いパフォーマンスを達成するよう設定してください。
      </p><p>
        ベンチマークでは、クエリーおよび <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> 操作 (挿入、更新、および削除) は両方とも、従来の SQL よりも <span class="command"><strong>memcached</strong></span> インタフェースを経由した方が高速になります。通常は DML 操作の方が速度が大きく向上します。したがって、<span class="command"><strong>memcached</strong></span> インタフェースを使用するために最初に改変した方がよいアプリケーションのタイプは、書き込み処理の多いアプリケーションです。また、以前信頼性が優先されていなかった場合、高速かつ軽量なメカニズムを使用した書き込み処理の多いアプリケーションタイプでは、MySQL をデータストアとして使用する場合もあります。
      </p><h5><a name="idm139979061212816"></a>SQL クエリーの改変</h5><p>
        単純な <code class="literal">GET</code> リクエストスタイルのもっとも適合するクエリーのタイプは、単一句または <code class="literal">AND</code> 条件のセットを <code class="literal">WHERE</code> 句に指定したものです。
      </p><pre class="programlisting">
SQL:
select col from tbl where key = 'key_value';

memcached:
GET key_value

SQL:
select col from tbl where col1 = val1 and col2 = val2 and col3 = val3;

memcached:
# Since you must always know these 3 values to look up the key,
# combine them into a unique string and use that as the key
# for all ADD, SET, and GET operations.
key_value = val1 + ":" + val2 + ":" + val3
GET key_value

SQL:
select 'key exists!' from tbl
  where exists (select col1 from tbl where key = 'key_value') limit 1;

memcached:
# Test for existence of key by asking for its value and checking if the call succeeds,
# ignoring the value itself. For existence checking, you typically only store a very
# short value such as "1".
GET key_value

</pre><h5><a name="idm139979061207872"></a>システムメモリーの利用</h5><p>
        最適なパフォーマンスを得るには、<code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインを、典型的なデータベースサーバーのように構成されたマシン上に配備し、特に、<code class="literal">innodb_buffer_pool_size</code> 構成オプションを使用して、大部分のシステム RAM を <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>に割り振ったデータベースサーバー上に配備します。複数ギガバイトのバッファープールを備えたシステムで、ほとんどの操作がメモリーにキャッシュされているデータを使用する場合、スループットが最大になるように <code class="literal">innodb_buffer_pool_instances</code> 構成オプションの値を高くします。
      </p><h5><a name="idm139979061200944"></a>冗長 I/O の削減</h5><p>
        <code class="literal">InnoDB</code> には、クラッシュ時の高い信頼性と、高書き込みワークロード時の I/O オーバーヘッドの量とのバランスを選択できる設定があります。たとえば、構成オプション <code class="literal">innodb_doublewrite=0</code> および <code class="literal">innodb_flush_log_at_trx_commit=2</code> を設定します。<code class="literal">innodb_flush_method</code> オプションの設定を変えて、パフォーマンスを測定します。サーバーの<a class="link" href="glossary.html#glos_binary_log" title="バイナリログ">バイナリログ</a>がチューニングされていない場合、<code class="literal">innodb_support_xa=0</code> の設定を使用します。
      </p><p>
        テーブル操作の I/O を削減したりチューニングしたりするその他の方法については、<a class="xref" href="optimization.html#optimizing-innodb-diskio" title="8.5.7 InnoDB ディスク I/O の最適化">セクション8.5.7「InnoDB ディスク I/O の最適化」</a>を参照してください。
      </p><h5><a name="idm139979061192240"></a>トランザクションオーバーヘッドの削減</h5><p>
        構成オプション <code class="literal">daemon_memcached_r_batch_size</code> および <code class="literal">daemon_memcached_w_batch_size</code> に対するデフォルト値 1 では、結果に対する最大限の信頼性と、保管または更新されるデータの安全性を確保します。
      </p><p>
        アプリケーションのタイプによっては、これらの設定の 1 つまたは両方を増やすと、頻繁な<a class="link" href="glossary.html#glos_commit" title="コミット">コミット</a>操作によるオーバーヘッドを削減できる場合もあります。データ処理の多いシステムでは、SQL を介して行なったデータへの変更が <span class="command"><strong>memcached</strong></span> に即座に (つまり、<code class="literal">get</code> 操作があと <em class="replaceable"><code>N</code></em> 回処理されるまで) 表示されなくなることを確認し、<code class="literal">daemon_memcached_r_batch_size</code> を増やすこともできます。すべての書き込み操作を確実に保管する必要があるデータ処理の場合、<code class="literal">daemon_memcached_w_batch_size</code> の設定は 1 のままにします。統計分析にのみ使用する大量の更新を処理する場合は、クラッシュ時に最後の <em class="replaceable"><code>N</code></em> 回の更新が失われても大きな問題はないため、この設定を増やすこともできます。
      </p><p>
        たとえば、通行量の多い橋を渡る交通量をモニターし、1 日に約 100,000 台の車両を記録するシステムについて考えてみます。交通パターンを分析するために、単に異なるタイプの車両を数えるだけのアプリケーションの場合、<code class="literal">daemon_memcached_w_batch_size</code> を <code class="literal">1</code> から <code class="literal">100</code> に変更すると、コミット操作の I/O オーバーヘッドを 99% 削減できます。予想外の機能停止の場合、最大 100 件のレコードが失われても、許容誤差の可能性があります。一方、各車両に対する自動料金徴収をアプリケーションで実行している場合、<code class="literal">daemon_memcached_w_batch_size</code> の設定を <code class="literal">1</code> のままにし、料金徴収の記録を即座にディスクに保存する方がよい場合もあります。
      </p><p>
        <code class="literal">InnoDB</code> がディスク上で <span class="command"><strong>memcached</strong></span> キー値を編成する方法が原因で、大量のキーが作成される場合、データ項目をアプリケーション内でキー値でソートし、ソートした順序で<code class="literal">追加</code>した方が、任意の順序でキーを作成するよりも高速になります。
      </p><p>
        <span class="command"><strong>memslap</strong></span> コマンドは、さまざまな構成のベンチマークで便利です。これは通常の <span class="command"><strong>memcached</strong></span> 配布の一部ですが MySQL Server に含まれていません。また、独自のベンチマークで使用できるサンプルのキー/値のペアの生成に使用できます。詳細は、<a class="xref" href="ha-overview.html#ha-memcached-interfaces-libmemcached-utilities" title="16.6.3.3.6 libmemcached のコマンド行ユーティリティー">セクション16.6.3.3.6「<span class="command"><strong>libmemcached</strong></span> のコマンド行ユーティリティー」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-memcached-txn"></a>14.18.5.4 InnoDB memcached プラグインのトランザクション動作の制御</h4></div></div></div><p>
        従来の <span class="command"><strong>memcached</strong></span> とは異なり、<code class="literal">InnoDB</code> + <span class="command"><strong>memcached</strong></span> の組み合わせを使用すると、<code class="literal">add</code>、<code class="literal">set</code>、<code class="literal">incr</code> などの呼び出しを使用して生成されたデータ値の<span class="quote">「<span class="quote">永続性</span>」</span>を制御できます。MySQL はデータの永続性と一貫性に高い優先順位を置いているため、デフォルトでは、<span class="command"><strong>memcached</strong></span> インタフェース経由で書き込まれるすべてのデータは常にディスクに格納され、<code class="literal">get</code> の呼び出しは、ディスクの最新の値を常に返します。このデフォルト設定では、本来のパフォーマンスを可能なかぎり高めることはできませんが、<code class="literal">InnoDB</code> テーブルの従来の SQL インタフェースと比べると、非常に高速です。
      </p><p>
        この機能を使用していくことで、機能が停止した場合に一部の更新済みの値を失ったり、古くなったデータを返したりするリスクを認識し、重要ではないデータの永続性の設定を緩和できるようになります。
      </p><h5><a name="idm139979061155760"></a>コミットの頻度</h5><p>
        永続性と本来のパフォーマンスを両立させる 1 つの条件は、新しいデータや変更されたデータが<a class="link" href="glossary.html#glos_commit" title="コミット">コミット</a>される頻度です。重要なデータの場合、データをただちにコミットして、クラッシュまたは機能停止の発生時にデータを保護する必要があります。クラッシュ後にリセットされるカウンタや、数秒分損失しても支障がないロギングデータなどのあまり重要ではないデータの場合、コミットの頻度を下げて本来のスループットを高めた方がよいこともあります。
      </p><p>
        <span class="command"><strong>memcached</strong></span> 操作によって、ベースとなる <code class="literal">InnoDB</code> テーブル内で挿入、更新、または削除を行う場合、その変更は即座に (<code class="literal">daemon_memcached_w_batch_size=1</code> の場合) またはしばらくしてから (この構成オプション値が 1 より大きいとき) 基礎テーブルにコミットされます。いずれの場合も、変更はロールバックできません。混雑時の高 I/O オーバーヘッドを回避するために <code class="literal">daemon_memcached_w_batch_size=1</code> の値を増やすと、ワークロードの減少時にコミットの頻度が非常に低下する可能性があります。安全策として、バックグラウンドスレッドで、<span class="command"><strong>memcached</strong></span> API 経由で行なった変更を一定の間隔で自動的にコミットします。間隔は <code class="literal">innodb_api_bk_commit_interval</code> 構成オプションで制御され、デフォルトは 5 秒です。
      </p><p>
        <span class="command"><strong>memcached</strong></span> 操作によって、ベースとなる <code class="literal">InnoDB</code> テーブルに挿入または更新が発生した場合、変更されたデータはほかの <span class="command"><strong>memcached</strong></span> リクエストによってすぐに表示されます。これは、新しい値は MySQL 側でまだコミットされていなくてもメモリーキャッシュ内に残っているためです。
      </p><h5><a name="idm139979061142368"></a>トランザクションの分離</h5><p>
        <code class="literal">get</code> や <code class="literal">incr</code> などの <span class="command"><strong>memcached</strong></span> 操作によって、ベースとなる <code class="literal">InnoDB</code> テーブルでクエリーまたは DML 操作を実行する場合、テーブルに書き込まれた最新データの表示、コミットされたデータのみの表示、ほかのトランザクション<a class="link" href="glossary.html#glos_isolation_level" title="分離レベル">分離レベル</a>の表示を制御できます。この機能は <code class="literal">innodb_api_trx_level</code> 構成オプションを使用して制御します。このオプションで指定される数値は、<code class="literal">REPEATABLE READ</code> のようなわかりやすい分離レベル名に対応します。全リストについては、<code class="literal">innodb_api_trx_level</code> オプションの説明を参照してください。
      </p><p>
        分離レベルの厳密性が高くなると、取得したデータが突然ロールバックしたり変更したりして後続のクエリーで異なる値が表示されることがなくなります。ただし、厳密性が高いと <a class="link" href="glossary.html#glos_locking" title="ロック">ロック</a>によるオーバーヘッドが大きくなり待機が発生します。長期間にわたるトランザクションを使用しない NoSQL スタイルのアプリケーションでは、通常はデフォルトの分離レベルのままにするか、低い厳密性に切り換えることができます。
      </p><h5><a name="idm139979061131232"></a>memcached DML 操作の行ロックの無効化</h5><p>
        <code class="literal">innodb_api_disable_rowlock</code> オプションでは、<code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> が DML 操作を実行するときに行ロックを無効化できます。デフォルトでは、<code class="literal">innodb_api_disable_rowlock</code> は <code class="literal">OFF</code> に設定されており、<span class="command"><strong>memcached</strong></span> が get および set 操作の行ロックをリクエストします。<code class="literal">innodb_api_disable_rowlock</code> を <code class="literal">ON</code> に設定すると、<span class="command"><strong>memcached</strong></span> は行ロックの代わりに、テーブルロックをリクエストします。
      </p><p>
        <code class="literal">innodb_api_disable_rowlock</code> オプションは動的ではありません。<span class="command"><strong>mysqld</strong></span> コマンド行で起動時に指定するか、MySQL 構成ファイルに入力する必要があります。
      </p><h5><a name="idm139979061120592"></a>DDL の許可または禁止</h5><p>
        デフォルトでは、<code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインによって使用されるテーブル上で <code class="literal">ALTER TABLE</code> などの <a class="link" href="glossary.html#glos_ddl" title="DDL">DDL</a> 操作を実行できます。スループットの高いアプリケーションでのテーブル使用時の潜在的な速度低下を回避するには、<code class="literal">innodb_api_enable_mdl</code> 構成オプションを起動時にオンにすると、テーブル上の DDL 操作を無効にできます。このオプションは、<span class="command"><strong>memcached</strong></span> インタフェースおよび SQL の両方で同じ基礎テーブルにアクセスする場合はあまり適切ではありません。このオプションでは、レポート作成クエリーを実行するシステムの構成で重要になる、テーブルの <code class="literal">CREATE INDEX</code> ステートメントをブロックするためです。
      </p><h5><a name="idm139979061111328"></a>ディスク、メモリー、または両方へのデータの格納</h5><p>
        テーブル <code class="literal">innodb_memcache.cache_policies</code> は、<span class="command"><strong>memcached</strong></span> から書き込まれるデータが、ディスク上に格納されるか (デフォルト、<code class="literal">innodb_only</code>)、従来の <span class="command"><strong>memcached</strong></span> のようにメモリーのみに格納されるか (<code class="literal">cache-only</code>)、または両方に格納されるか (<code class="literal">caching</code>) を指定します。
      </p><p>
        <code class="literal">caching</code> 設定では、<span class="command"><strong>memcached</strong></span> がメモリー内からキーを検出できない場合、<code class="literal">InnoDB</code> テーブル内から値を検索します。<code class="literal">caching</code> 設定で <code class="literal">get</code> 呼び出しから返された値は、ディスク上の <code class="literal">InnoDB</code> テーブルで更新され、メモリーキャッシュでまだ期限切れとなっていない場合、値が最新でないことがあります。
      </p><p>
        キャッシュポリシーは、<code class="literal">get</code>、<code class="literal">set</code> (<code class="literal">incr</code> および <code class="literal">decr</code> を含む)、<code class="literal">delete</code>、および <code class="literal">flush</code> 操作で個々に設定できます。例:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">get</code> および <code class="literal">set</code> 操作では、(<code class="literal">caching</code> 設定を使用して) テーブルおよび <span class="command"><strong>memcached</strong></span> メモリーキャッシュへのクエリー実行または更新を同時に実行しながら、<code class="literal">delete</code>、<code class="literal">flush</code>、またはこれらの両方を (<code class="literal">cache_only</code> 設定を使用して) インメモリーコピー上でのみ動作できます。こうすることで、項目を削除またはフラッシュすると単にキャッシュで期限切れになり、項目が次回要求されたときに最新の値が <code class="literal">InnoDB</code> テーブルから返されます。
          </p></li></ul></div><pre class="programlisting">

mysql&gt; desc innodb_memcache.cache_policies;
+---------------+-------------------------------------------------------+------+-----+---------+-------+
| Field         | Type                                                  | Null | Key | Default | Extra |
+---------------+-------------------------------------------------------+------+-----+---------+-------+
| policy_name   | varchar(40)                                           | NO   | PRI | NULL    |       |
| get_policy    | enum('innodb_only','cache_only','caching','disabled') | NO   |     | NULL    |       |
| set_policy    | enum('innodb_only','cache_only','caching','disabled') | NO   |     | NULL    |       |
| delete_policy | enum('innodb_only','cache_only','caching','disabled') | NO   |     | NULL    |       |
| flush_policy  | enum('innodb_only','cache_only','caching','disabled') | NO   |     | NULL    |       |
+---------------+-------------------------------------------------------+------+-----+---------+-------+

mysql&gt; select * from innodb_memcache.cache_policies;
+--------------+-------------+-------------+---------------+--------------+
| policy_name  | get_policy  | set_policy  | delete_policy | flush_policy |
+--------------+-------------+-------------+---------------+--------------+
| cache_policy | innodb_only | innodb_only | innodb_only   | innodb_only  |
+--------------+-------------+-------------+---------------+--------------+

mysql&gt; update innodb_memcache.cache_policies set set_policy = 'caching'
    -&gt; where policy_name = 'cache_policy';

</pre><p>
        <code class="literal">cache_policies</code> 値は起動時にのみ読み取られ、<span class="command"><strong>memcached</strong></span> プラグインの動作と強固に統合されています。このテーブル中の値を変更したあと、プラグインをアンインストールし再インストールします。
      </p><pre class="programlisting">

mysql&gt; uninstall plugin daemon_memcached;
Query OK, 0 rows affected (2.00 sec)
mysql&gt; install plugin daemon_memcached soname "libmemcached.so";
Query OK, 0 rows affected (0.00 sec)

</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-memcached-dml"></a>14.18.5.5 memcached 操作に合わせた DML ステートメントの改変</h4></div></div></div><p>
        ベンチマークでは、<code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインは、クエリーを高速化するだけではなく <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> 操作 (挿入、更新、および削除) を高速化することが示唆されています。初期の開発作業では、書き込み処理の多い I/O バウンドのアプリケーションに集中し、書き込み処理の多い新しい種類のアプリケーションで MySQL を使用する機会を検討する方がよい場合もあります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><pre class="programlisting">
INSERT INTO t1 (key,val) VALUES (<em class="replaceable"><code>some_key</code></em>,<em class="replaceable"><code>some_value</code></em>);
SELECT val FROM t1 WHERE key = <em class="replaceable"><code>some_key</code></em>;
UPDATE t1 SET val = <em class="replaceable"><code>new_value</code></em> WHERE key = <em class="replaceable"><code>some_key</code></em>;
UPDATE t1 SET val = val + x WHERE key = <em class="replaceable"><code>some_key</code></em>;
DELETE FROM t1 WHERE key = <em class="replaceable"><code>some_key</code></em>;
</pre><p>
            単一行の DML ステートメントは <code class="literal">memcached</code> 操作に変換するもっとも単純な種類のステートメントで、<code class="literal">INSERT</code> は <code class="literal">add</code> に、<code class="literal">UPDATE</code> は <code class="literal">set</code>、<code class="literal">incr</code>、または <code class="literal">decr</code> に、<code class="literal">DELETE</code> は <code class="literal">delete</code> になります。<span class="command"><strong>memcached</strong></span> インタフェースを介して発行すると、テーブル内で<em class="replaceable"><code>キー</code></em>は一意であるため、これらの操作は 1 行のみに影響を与えることができます。
          </p><p>
            前述の SQL の例で、<code class="literal">t1</code> は <code class="literal">innodb_memcache.containers</code> テーブルの構成設定に基づき <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインによって現在使用されているテーブルを参照し、<code class="literal">key</code> は <code class="literal">key_columns</code> の下にリストされているカラムを参照し、<code class="literal">val</code> は <code class="literal">value_columns</code> の下にリストされているカラムを参照します。
          </p></li><li class="listitem"><pre class="programlisting">
TRUNCATE TABLE t1;
DELETE FROM t1;
</pre><p>
            前のステップのように、<code class="literal">t1</code> が <span class="command"><strong>memcached</strong></span> 操作についてのテーブルとして構成されている場合に、<code class="literal">flush_all</code> 操作に相当します。テーブル中のすべての行を削除します。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="innodb-memcached-ddl"></a>14.18.5.6 ベースとなる InnoDB テーブルでの DML および DDL ステートメントの実行</h4></div></div></div><p>
        標準の SQL インタフェースを介して InnoDB テーブル (デフォルトは <code class="literal">test.demo_test</code>) にアクセスできます。ただし、いくつかの制約があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <span class="command"><strong>memcached</strong></span> インタフェース経由でもアクセスしているテーブルで SQL 経由でクエリーを実行する場合、<span class="command"><strong>memcached</strong></span> 操作は、すべての書き込み操作のあとではなく定期的にコミットするよう構成できます。この動作は、<code class="literal">daemon_memcached_w_batch_size</code> オプションによって制御されます。このオプションが 1 より大きい値に設定されている場合、挿入されたばかりの行を検出するには <code class="literal">READ UNCOMMITTED</code> クエリーを使用します。
          </p><pre class="programlisting">

mysql&gt; set session TRANSACTION ISOLATION LEVEL read uncommitted;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select * from demo_test;
+------+------+------+------+-----------+------+------+------+------+------+------+
| cx   | cy   | c1   | cz   | c2        | ca   | CB   | c3   | cu   | c4   | C5   |
+------+------+------+------+-----------+------+------+------+------+------+------+
| NULL | NULL | a11  | NULL | 123456789 | NULL | NULL |   10 | NULL |    3 | NULL |
+------+------+------+------+-----------+------+------+------+------+------+------+
1 row in set (0.00 sec)

</pre></li><li class="listitem"><p>
            <span class="command"><strong>memcached</strong></span> インタフェース経由でもアクセスしているテーブルを SQL 経由で変更する場合、<span class="command"><strong>memcached</strong></span> 操作を、すべての読み取り操作のあとではなく定期的に新しいトランザクションを開始するよう構成できます。この動作は、<code class="literal">daemon_memcached_r_batch_size</code> オプションによって制御されます。このオプションが 1 より大きい値に設定されている場合、...
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> テーブルは、トランザクション内のすべての操作で IS (共有インテンション) または IX (排他インテンション) でロックされます。<code class="literal">daemon_memcached_r_batch_size</code> および <code class="literal">daemon_memcached_w_batch_size</code> をデフォルト値の 1 よりも著しく増加させた場合、テーブルはほとんどの場合、各操作間で意図的にロックされ、ユーザーはテーブル上で <a class="link" href="glossary.html#glos_ddl" title="DDL">DDL</a> ステートメントを実行できなくなります。
          </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-memcached-replication"></a>14.18.6 レプリケーションでの InnoDB memcached プラグインの使用</h3></div></div></div><p>
      <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> デーモンプラグインは MySQL <a class="link" href="glossary.html#glos_binary_log" title="バイナリログ">バイナリログ</a>をサポートしているため、<span class="command"><strong>memcached</strong></span> インタフェース経由で<a class="link" href="glossary.html#glos_master_server" title="マスターサーバー">マスターサーバー</a>に実行した更新は、バックアップ、読み取り処理の多いワークロードのバランスの確保、および高可用性のためにレプリケーションできます。すべての <span class="command"><strong>memcached</strong></span> コマンドは、バイナリロギング用にサポートされています。
    </p><p>
      <a class="link" href="glossary.html#glos_slave_server" title="スレーブサーバー">スレーブサーバー</a>上で <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインをセットアップする必要はありません。この構成の主な利点は、マスター上での書き込みスループットの増加です。レプリケーションメカニズムの速度は影響を受けません。
    </p><p>
      次のセクションでは、バイナリログ機能を使用して、<code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインを MySQL レプリケーションと一緒に使用する方法を示します。<a class="xref" href="innodb-storage-engine.html#innodb-memcached-setup" title="14.18.3 InnoDB Memcached プラグインの概要">セクション14.18.3「InnoDB Memcached プラグインの概要」</a>に記載されている基本設定がすでに実行されていることを前提としています。
    </p><h4><a name="idm139979061015200"></a>innodb_api_enable_binlog による InnoDB Memcached バイナリログの有効化:</h4><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインを MySQL <a class="link" href="glossary.html#glos_binary_log" title="バイナリログ">バイナリログ</a>と一緒に使用するには、<a class="link" href="glossary.html#glos_master_server" title="マスターサーバー">マスターサーバー</a>上で <code class="literal">innodb_api_enable_binlog</code> 構成オプションを有効にします。このオプションはサーバーのブート時にのみ設定できます。また、<code class="literal">--log-bin</code> オプションを使用して、マスターサーバー上で MySQL バイナリログを有効にする必要もあります。これらのオプションを、<code class="filename">my.cnf</code> などのサーバー構成ファイルに追加したり、<span class="command"><strong>mysqld</strong></span> コマンド行に追加したりできます。
        </p><pre class="programlisting">
mysqld ... --log-bin -–innodb_api_enable_binlog=1
</pre></li><li class="listitem"><p>
          次に、<a class="xref" href="replication.html#replication-howto" title="17.1.1 レプリケーションのセットアップ方法">セクション17.1.1「レプリケーションのセットアップ方法」</a>に記載されているようにマスターサーバーおよびスレーブサーバーを構成します。
        </p></li><li class="listitem"><p>
          <span class="command"><strong>mysqldump</strong></span> を使用してマスターデータスナップショットを作成し、これをスレーブサーバーに同期します。
        </p><pre class="programlisting">

master shell: mysqldump --all-databases --lock-all-tables &gt; dbdump.db
slave shell: mysql &lt; dbdump.db

</pre></li><li class="listitem"><p>
          マスターサーバー上で、<code class="literal">show master status</code> を発行してマスターバイナリログ座標を取得します。
        </p><pre class="programlisting">
mysql&gt; show master status;
</pre></li><li class="listitem"><p>
          スレーブサーバー上で、<code class="literal">change master to</code> ステートメントを使用して、上記の座標でスレーブサーバーをセットアップします。
        </p><pre class="programlisting">

mysql&gt; CHANGE MASTER TO
       MASTER_HOST='localhost',
       MASTER_USER='root',
       MASTER_PASSWORD='',
       MASTER_PORT = 13000,
       MASTER_LOG_FILE='0.000001,
       MASTER_LOG_POS=114;

</pre></li><li class="listitem"><p>
          次に、スレーブを開始します。
        </p><pre class="programlisting">

mysql&gt; start slave;

</pre><p>
          次のような出力がエラーログから出力される場合、スレーブはレプリケーションの準備ができています。
        </p><pre class="programlisting">
111002 18:47:15 [Note] Slave I/O thread: connected to master 'root@localhost:13000',
replication started in log '0.000001' at position 114
</pre></li></ul></div><h4><a name="idm139979060991360"></a>memcached telnet インタフェースによるテスト</h4><p>
      上記のレプリケーション設定を備えたサーバーをテストするには、<span class="command"><strong>memcached</strong></span> telnet インタフェースを使用し、さらに SQL を使用してマスターサーバーおよびスレーブサーバーにクエリーを実行して、結果を検証します。
    </p><p>
      ここでの構成設定 SQL で、<span class="command"><strong>memcached</strong></span> によって使用される <code class="literal">test</code> データベース内に 1 つのサンプルテーブル <code class="literal">demo_test</code> が作成されます。このデフォルトテーブルをデモ用に使用します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">set</code> を使用して、キー <code class="literal">test1</code>、値 <code class="literal">t1</code>、およびフラグ <code class="literal">10</code> を持つレコードを挿入します。
        </p><pre class="programlisting">
telnet 127.0.0.1 11211
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
set test1 10 0 2
t1
STORED
</pre></li></ul></div><p>
      マスターサーバーで、行が挿入されたことを確認できます。<code class="literal">c1</code> はキーにマップされ、<code class="literal">c2</code> は値にマップされ、<code class="literal">c3</code> はフラグ、<code class="literal">c4</code> は <code class="literal">cas</code> 値、および <code class="literal">c5</code> は期限です。
    </p><pre class="programlisting">

mysql&gt; select * from test.demo_test;

</pre><div class="informaltable"><table summary=" memcached API 呼び出しを介して挿入されたデータを示す、マスターサーバー上でのクエリー「select * from test.demo_test」の結果。 " border="1"><colgroup><col><col><col><col><col></colgroup><thead><tr><th scope="col">c1</th><th scope="col">c2</th><th scope="col">c3</th><th scope="col">c4</th><th scope="col">c5</th></tr></thead><tbody><tr><td scope="row">test1</td><td>t1</td><td>10</td><td>2</td><td>0</td></tr></tbody></table></div><pre class="programlisting">
1 row in set (0.00 sec)
</pre><p>
      スレーブサーバーでは、レプリケーションによって同じレコードが挿入されたことがわかります。
    </p><pre class="programlisting">

mysql&gt; select * from test.demo_test;

</pre><div class="informaltable"><table summary=" memcached API 呼び出しを介して挿入されたデータがマスターサーバーからスレーブサーバーに伝播したことを例示する、クエリー「select * from test.demo_test」の結果。 " border="1"><colgroup><col><col><col><col><col></colgroup><thead><tr><th scope="col">c1</th><th scope="col">c2</th><th scope="col">c3</th><th scope="col">c4</th><th scope="col">c5</th></tr></thead><tbody><tr><td scope="row">test1</td><td>t1</td><td>10</td><td>2</td><td>0</td></tr></tbody></table></div><pre class="programlisting">
1 row in set (0.00 sec)
</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">set</code> コマンドを使用して、キー <code class="literal">test1</code> を新しい値 <code class="literal">new</code> に更新します。
        </p></li></ul></div><pre class="programlisting">
Connected to 127.0.0.1.
Escape character is '^]'.
set test1 10 0 3
new
STORED
</pre><p>
      スレーブサーバーで、更新がレプリケーションされます (<code class="literal">cas</code> 値も更新されます)。
    </p><pre class="programlisting">

mysql&gt; select * from test.demo_test;

</pre><div class="informaltable"><table summary=" memcached API 呼び出しを介して更新されたデータがマスターサーバーからスレーブサーバーに伝播したことを例示する、クエリー「select * from test.demo_test」の結果。 " border="1"><colgroup><col><col><col><col><col></colgroup><thead><tr><th scope="col">c1</th><th scope="col">c2</th><th scope="col">c3</th><th scope="col">c4</th><th scope="col">c5</th></tr></thead><tbody><tr><td scope="row">test1</td><td>new</td><td>10</td><td>3</td><td>0</td></tr></tbody></table></div><pre class="programlisting">
1 row in set (0.00 sec)
</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">delete</code> コマンドでレコードを削除します。
        </p></li></ul></div><pre class="programlisting">
Connected to 127.0.0.1.
Escape character is '^]'.
delete test1
DELETED
</pre><p>
      削除がスレーブにレプリケーションされると、スレーブ上のレコードも削除されます。
    </p><pre class="programlisting">

mysql&gt; select * from test.demo_test;
Empty set (0.00 sec)

</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">flush_all</code> コマンドでテーブルを削除します。
        </p></li></ul></div><p>
      最初に、telnet でマスターサーバーに接続して 2 つのレコードを挿入します。
    </p><pre class="programlisting">
Connected to 127.0.0.1.
Escape character is '^]'
set test2 10 0 5
again
STORED
set test3 10 0 6
again1
STORED
</pre><p>
      スレーブサーバーで、これらの 2 つのレコードがレプリケーションされることを確認します。
    </p><pre class="programlisting">

mysql&gt; select * from test.demo_test;

</pre><div class="informaltable"><table summary=" マスターサーバー上での FLUSH_ALL memcached 呼び出しよりも前のスレーブサーバー上のデータを示す、クエリー「select * from test.demo_test」の結果。 " border="1"><colgroup><col><col><col><col><col></colgroup><thead><tr><th scope="col">c1</th><th scope="col">c2</th><th scope="col">c3</th><th scope="col">c4</th><th scope="col">c5</th></tr></thead><tbody><tr><td scope="row">test2</td><td>again</td><td>10</td><td>5</td><td>0</td></tr><tr><td scope="row">test3</td><td>again1</td><td>10</td><td>6</td><td>0</td></tr></tbody></table></div><pre class="programlisting">
2 rows in set (0.00 sec)
</pre><p>
      telnet インタフェースで <code class="literal">flush_all</code> を呼び出してテーブルを削除します。
    </p><pre class="programlisting">
Connected to 127.0.0.1.
Escape character is '^]'.
flush_all
OK
</pre><p>
      次に、削除操作がスレーブサーバーにレプリケーションされたことを確認します。
    </p><pre class="programlisting">

mysql&gt; select * from test.demo_test;
Empty set (0.00 sec)

</pre><p>
      すべての <code class="literal">memcached</code> コマンドは、レプリケーションでサポートされます。
    </p><h4><a name="idm139979060908304"></a>InnoDB Memcached Binlog に関する注意点</h4><p>
      Binlog 形式:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ほとんどの <span class="command"><strong>memcached</strong></span> 操作は (挿入、削除、更新に類似した) <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> ステートメントにマップされます。MySQL Server によって実際に処理される SQL ステートメントがないため、<span class="command"><strong>memcached</strong></span> コマンド (<code class="literal">flush_all</code> 以外) は行ベースのレプリケーション (RBR) ロギングを使用します。これはサーバーのすべての <code class="literal">binlog_format</code> 設定とは無関係です。
        </p></li><li class="listitem"><p>
          <span class="command"><strong>memcached</strong></span> <code class="literal">flush_all</code> コマンドは <code class="literal">TRUNCATE TABLE</code> コマンドにマップされます。<a class="link" href="glossary.html#glos_ddl" title="DDL">DDL</a> コマンドはステートメントベースのロギングのみ使用できるため、この <code class="literal">flush_all</code> コマンドは <code class="literal">TRUNCATE TABLE</code> ステートメントを送信することでレプリケーションされます。
        </p></li></ul></div><p>
      トランザクション:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a>の概念は、これまで通常は <span class="command"><strong>memcached</strong></span> アプリケーションの一部をなすものではありませんでした。ここでは <code class="literal">daemon_memcached_r_batch_size</code> および <code class="literal">daemon_memcached_w_batch_size</code> を使用して、パフォーマンスを考慮した読み取りおよび書き込みトランザクションのバッチサイズを制御します。これらの設定はレプリケーションに影響せず、基礎テーブル上でのすべての SQL 操作は実行完了後すぐにレプリケーションされます。
        </p></li><li class="listitem"><p>
          <code class="literal">daemon_memcached_w_batch_size</code> のデフォルト値は 1 であるため、<span class="command"><strong>memcached</strong></span> の書き込み操作は即時にコミットされます。このデフォルト設定は、マスターサーバーとスレーブサーバーに表示されるデータの不整合を回避するために、ある程度のパフォーマンスオーバーヘッドを発生させます。レプリケートされたレコードは、常にスレーブサーバー上でただちに使用可能になります。<code class="literal">daemon_memcached_w_batch_size</code> を 1 より大きく設定した場合、<span class="command"><strong>memcached</strong></span> インタフェースを介して挿入または更新されたレコードは、マスターサーバー上にすぐには表示されません。これらのレコードがコミットされる前にレコードをマスターサーバー上に表示するには、<code class="literal">set transaction isolation level read uncommitted</code> を発行します。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-memcached-internals"></a>14.18.7 InnoDB memcached プラグインの内部構造</h3></div></div></div><h4><a name="idm139979060881664"></a>InnoDB memcached プラグイン用の InnoDB API</h4><p>
      <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> エンジンは <code class="literal">InnoDB</code> API を介して <code class="literal">InnoDB</code> にアクセスします。ほとんどの API は、組み込まれた <code class="literal">InnoDB</code> から直接採用されます。<code class="literal">InnoDB</code> API 関数は、<span class="quote">「<span class="quote">コールバック関数</span>」</span>として <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> に渡されます。<code class="literal">InnoDB</code> API 関数は <code class="literal">InnoDB</code> テーブルに直接アクセスし、<code class="literal">TRUNCATE TABLE</code> 操作を除いてほとんどが DML 操作です。
    </p><p>
      次にリストされたすべての <span class="command"><strong>memcached</strong></span> コマンドは、 <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> API によって実装されます。次の表は、それぞれの <span class="command"><strong>memcached</strong></span> コマンドが DML 操作にどのようにマップされるかの概要を示しています。
    </p><div class="table"><a name="idm139979060867920"></a><p class="title"><b>表 14.10 memcached コマンドおよび関連付けられた DML 操作</b></p><div class="table-contents"><table summary="memcached コマンドおよび関連付けられた DML 操作" border="1"><colgroup><col class="c1"><col class="c2"></colgroup><thead><tr><th scope="col">memcached コマンド</th><th scope="col">DML 操作</th></tr></thead><tbody><tr><td scope="row"><code class="literal">get</code></td><td>読み取り/フェッチコマンド</td></tr><tr><td scope="row"><code class="literal">set</code></td><td>検索後に挿入または更新を実行する (キーが存在するかどうかに依存する)</td></tr><tr><td scope="row"><code class="literal">add</code></td><td>検索後に挿入または更新を実行する</td></tr><tr><td scope="row"><code class="literal">replace</code></td><td>検索後に更新を実行する</td></tr><tr><td scope="row"><code class="literal">append</code></td><td>検索後に更新を実行する (更新前に結果の後ろにデータを付加する)</td></tr><tr><td scope="row"><code class="literal">prepend</code></td><td>検索後に更新を実行する (更新前に結果の前にデータを付加する)</td></tr><tr><td scope="row"><code class="literal">incr</code></td><td>検索後に更新を実行する</td></tr><tr><td scope="row"><code class="literal">decr</code></td><td>検索後に更新を実行する</td></tr><tr><td scope="row"><code class="literal">delete</code></td><td>検索後に削除を実行する</td></tr><tr><td scope="row"><code class="literal">flush_all</code></td><td>テーブルを削除する</td></tr></tbody></table></div></div><br class="table-break"><h4><a name="idm139979060845616"></a>InnoDB memcached プラグインで使用される基礎テーブル</h4><a class="indexterm" name="idm139979060844752"></a><a class="indexterm" name="idm139979060843344"></a><a class="indexterm" name="idm139979060841952"></a><a class="indexterm" name="idm139979060840560"></a><p>
      このセクションでは、<code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインによって使用される基礎テーブルについて説明します。
    </p><p>
      <code class="filename">innodb_memcached_config.sql</code> 構成スクリプトは <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインによって必要となる 3 つのテーブルをインストールします。テーブルは専用の <code class="literal">innodb_memcache</code> データベースに作成されます。
    </p><pre class="programlisting">mysql&gt; USE innodb_memcache;
Database changed
mysql&gt; SHOW TABLES;
+---------------------------+
| Tables_in_innodb_memcache |
+---------------------------+
| cache_policies            |
| config_options            |
| containers                |
+---------------------------+
3 rows in set (0.01 sec)</pre><h4><a name="idm139979060832144"></a>containers テーブル</h4><p>
      <code class="literal">containers</code> テーブルは 3 つのテーブルの中でもっとも重要です。このテーブル内のエントリは、<span class="command"><strong>memcached</strong></span> 値を格納するために使用される <code class="literal">InnoDB</code> テーブル用の<span class="quote">「<span class="quote">コンテナ</span>」</span>です。コンテナは、<code class="literal">InnoDB</code> テーブルのカラムを下記の表で示す値にマップします。このマッピングは <code class="literal">memcached</code> が <code class="literal">InnoDB</code> テーブルと一緒に機能するために必要です。
    </p><p>
      <code class="literal">containers</code> テーブルには <code class="literal">test.demo_test</code> テーブル用のデフォルトエントリがあります。<code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインを独自の <code class="literal">InnoDB</code> テーブルと一緒に使用するには、使用するテーブルのエントリを <code class="literal">containers</code> テーブルに追加する必要があります。
    </p><div class="table"><a name="idm139979060820640"></a><p class="title"><b>表 14.11 containers のカラム</b></p><div class="table-contents"><table summary="containers のカラム" border="1"><colgroup><col class="c1"><col class="c2"></colgroup><thead><tr><th scope="col">カラム</th><th scope="col">説明</th></tr></thead><tbody><tr><td scope="row"><code class="literal">name</code></td><td>コンテナに付与された名前。</td></tr><tr><td scope="row"><code class="literal">db_schema</code></td><td><code class="literal">InnoDB</code> テーブルが存在するデータベースの名前。これは必須の値です。</td></tr><tr><td scope="row"><code class="literal">db_table</code></td><td><span class="command"><strong>memcached</strong></span> 値を格納する <code class="literal">InnoDB</code> テーブルの名前。これは必須の値です。</td></tr><tr><td scope="row"><code class="literal">key_columns</code></td><td><span class="command"><strong>memcached</strong></span> 操作のための検索キー値を格納する <code class="literal">InnoDB</code> テーブルのカラム。これは必須の値です。</td></tr><tr><td scope="row"><code class="literal">value_columns</code></td><td><code class="literal">memcached</code> データを格納する <code class="literal">InnoDB</code> テーブル内のカラム (1 つ以上)。<code class="literal">innodb_memcached.config_options</code> テーブルで指定された区切り文字を使用して複数のカラムを指定できます。デフォルトでは、区切り文字はパイプ文字 (<span class="quote">「<span class="quote">|</span>」</span>) です。複数カラムを指定するには、定義された区切り文字でカラムを区切ります。たとえば、<code class="literal">col1|col2|col3</code> となります。これは必須の値です。</td></tr><tr><td scope="row"><code class="literal">flags</code></td><td><span class="command"><strong>memcached</strong></span> のフラグ (メインの値と一緒に格納および取得されるユーザー定義の数値) として使用される <code class="literal">InnoDB</code> テーブル内のカラムを指定します。<span class="command"><strong>memcached</strong></span> 値が複数カラムにマップされる場合、フラグ値はいくつかの操作 (<code class="literal">incr</code> や <code class="literal">prepend</code> など) のカラム指定子として使用でき、その結果、指定されたカラムで操作が実行されます。たとえば、3 つのカラムに値をマップしていて、これらのカラムのうちの 1 つでインクリメント操作が実行する場合に、これらの操作に使用するカラムを指定するには <code class="literal">flags</code> を使用できます。<code class="literal">flags</code> カラムを使用しない場合は、未使用であることを示すためにその値を <code class="literal">0</code> に設定します。</td></tr><tr><td scope="row"><code class="literal">cas_column</code></td><td>比較およびスワップ (cas) 値を格納する <code class="literal">InnoDB</code> テーブル内のカラム。<code class="literal">cas_column</code> 値と <code class="literal">expire_time_column</code> 値は、<span class="command"><strong>memcached</strong></span> が別のサーバーへのリクエストをハッシュし、データをメモリーにキャッシュする方法に関係します。<code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインは単一の <span class="command"><strong>memcached</strong></span> デーモンに強固に統合され、インメモリーキャッシュメカニズムは MySQL および<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>によって処理されるため、このタイプの配備でこれらのカラムはほとんど必要ありません。これらのカラムを使用しない場合、値を <code class="literal">0</code> に設定してカラムが未使用であることを示します。</td></tr><tr><td scope="row"><code class="literal">expire_time_column</code></td><td>有効期限の値を格納する <code class="literal">InnoDB</code> テーブル内のカラム。<code class="literal">cas_column</code> 値と <code class="literal">expire_time_column</code> 値は、<span class="command"><strong>memcached</strong></span> が別のサーバーへのリクエストをハッシュし、データをメモリーにキャッシュする方法に関係します。<code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインは単一の <span class="command"><strong>memcached</strong></span> デーモンに強固に統合され、インメモリーキャッシュメカニズムは MySQL および<a class="link" href="glossary.html#glos_buffer_pool" title="バッファープール">バッファープール</a>によって処理されるため、このタイプの配備でこれらのカラムはほとんど必要ありません。これらのカラムを使用しない場合、値を <code class="literal">0</code> に設定してカラムが未使用であることを示します。</td></tr><tr><td scope="row"><code class="literal">unique_idx_name_on_key</code></td><td>キーカラムのインデックスの名前。これは一意のインデックスである必要があります。これは<a class="link" href="glossary.html#glos_primary_key" title="主キー">主キー</a>または<a class="link" href="glossary.html#glos_secondary_index" title="セカンダリインデックス">セカンダリインデックス</a>にできます。できれば、キーカラムを <code class="literal">InnoDB</code> テーブルの主キーにしてください。こうすることで、このカラムに対してセカンダリインデックスを使用するための検索ステップが省かれます。<span class="command"><strong>memcached</strong></span> 参照のための<a class="link" href="glossary.html#glos_covering_index" title="カバリングインデックス">カバリングインデックス</a>は作成できません。キーカラムおよび値カラムの両方に複合セカンダリインデックスを定義しようとすると、<code class="literal">InnoDB</code> はエラーを返します。</td></tr></tbody></table></div></div><br class="table-break"><h4><a name="idm139979060765744"></a>containers テーブルカラムの制約</h4><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">db_schema</code>、<code class="literal">db_name</code>、<code class="literal">key_columns</code>、<code class="literal">value_columns</code>、および <code class="literal">unique_idx_name_on_key</code> の値を指定する必要があります。そうしない場合、セットアップは失敗します。<code class="literal">flags</code>、<code class="literal">cas_column</code>、および <code class="literal">expire_time_column</code> が使用されない場合、これらに <code class="literal">0</code> を指定します。そうしないと、セットアップが失敗する場合があります。
        </p></li><li class="listitem"><p>
          <code class="literal">key_columns</code>: <span class="command"><strong>memcached</strong></span> で強制される、<span class="command"><strong>memcached</strong></span> キーの最大長は 250 文字です。最大長を超えるマップ済みのキーが使用された場合、操作は失敗します。マップ済みのキーは、Null 以外の <code class="literal">CHAR</code> または <code class="literal">VARCHAR</code> タイプである必要があります。
        </p></li><li class="listitem"><p>
          <code class="literal">value_columns</code>: <code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、または <code class="literal">BLOB</code> カラムにマップされる必要があります。長さに制約はなく、値を NULL に指定できます。
        </p></li><li class="listitem"><p>
          <code class="literal">cas_column</code>: <code class="literal">cas</code> 値は 64 ビットの整数です。これは少なくとも 8 バイトの <code class="literal">BIGINT</code> にマップされる必要があります。このカラムを使用しない場合は、未使用であることを示すためにその値を <code class="literal">0</code> に設定します。
        </p></li><li class="listitem"><p>
          <code class="literal">expiration_time_column</code>: 少なくとも 4 バイトの <code class="literal">INTEGER</code> にマップされる必要があります。有効期限は、Unix 時間の 32 ビット整数 (1970 年 1 月 1 日からの秒数の 32 ビット値) として、または現在時間から開始する秒数として定義されます。後者の場合、秒数は 60*60*24*30 (30 日間の秒数) を超えないようにしてください。クライアントによって送信された数値の方が大きい場合、サーバーは現在時間からのオフセットではなく実際の Unix 時間の値とみなします。このカラムを使用しない場合は、未使用であることを示すためにその値を <code class="literal">0</code> に設定します。
        </p></li><li class="listitem"><p>
          <code class="literal">flags</code>: 少なくとも 32 ビットの <code class="literal">INTEGER</code> にマップする必要があり、NULL に指定できます。このカラムを使用しない場合は、未使用であることを示すためにその値を <code class="literal">0</code> に設定します。
        </p></li></ul></div><p>
      カラム制約を強制するために、プラグインのロード時に事前検査が行われます。不一致が見つかった場合、プラグインはロードされません。
    </p><h4><a name="idm139979060733632"></a>cache_policies テーブル</h4><p>
      <code class="literal">cache_policies</code> テーブルは、<code class="literal">InnoDB</code> <code class="literal">memcached</code> セットアップ用のキャッシュポリシーを定義します。単一のキャッシュポリシー内で、<span class="command"><strong>get</strong></span>、<span class="command"><strong>set</strong></span>、<span class="command"><strong>delete</strong></span>、および <span class="command"><strong>flush</strong></span> 操作に対する個々のポリシーを指定できます。すべての操作のデフォルト設定は <code class="literal">innodb_only</code> です。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">innodb_only</code>: <code class="literal">InnoDB</code> を <span class="command"><strong>memcached</strong></span> のデータストアとして使用します。
        </p></li><li class="listitem"><p>
          <code class="literal">cache-only</code>: 従来の <span class="command"><strong>memcached</strong></span> エンジンをデータストアとして使用します。
        </p></li><li class="listitem"><p>
          <code class="literal">innodb_only</code>: <code class="literal">InnoDB</code> と従来の <span class="command"><strong>memcached</strong></span> エンジンの両方をデータストアとして使用します。この状況で、<span class="command"><strong>memcached</strong></span> がメモリー内からキーを検出できない場合、<code class="literal">InnoDB</code> テーブル内から値を検索します。
        </p></li><li class="listitem"><p>
          <code class="literal">disable</code>: キャッシュを無効にします。
        </p></li></ul></div><div class="table"><a name="idm139979060714480"></a><p class="title"><b>表 14.12 cache_policies カラム</b></p><div class="table-contents"><table summary="cache_policies カラム" border="1"><colgroup><col class="c1"><col class="c2"></colgroup><thead><tr><th scope="col">カラム</th><th scope="col">説明</th></tr></thead><tbody><tr><td scope="row"><code class="literal">policy_name</code></td><td>キャッシュポリシーの名前。デフォルトのキャッシュポリシー名は <code class="literal">cache_policy</code> です。</td></tr><tr><td scope="row"><code class="literal">get_policy</code></td><td>get 操作のキャッシュポリシー。有効な値は、<code class="literal">innodb_only</code>、<code class="literal">cache-only</code>、<code class="literal">caching</code>、または <code class="literal">disabled</code> です。デフォルト設定は <code class="literal">innodb_only</code> です。</td></tr><tr><td scope="row"><code class="literal">set_policy</code></td><td>set 操作のキャッシュポリシー。有効な値は、<code class="literal">innodb_only</code>、<code class="literal">cache-only</code>、<code class="literal">caching</code>、または <code class="literal">disabled</code> です。デフォルト設定は <code class="literal">innodb_only</code> です。</td></tr><tr><td scope="row"><code class="literal">delete_policy</code></td><td>delete 操作のキャッシュポリシー。有効な値は、<code class="literal">innodb_only</code>、<code class="literal">cache-only</code>、<code class="literal">caching</code>、または <code class="literal">disabled</code> です。デフォルト設定は <code class="literal">innodb_only</code> です。</td></tr><tr><td scope="row"><code class="literal">flush_policy</code></td><td>flush 操作のキャッシュポリシー。有効な値は、<code class="literal">innodb_only</code>、<code class="literal">cache-only</code>、<code class="literal">caching</code>、または <code class="literal">disabled</code> です。デフォルト設定は <code class="literal">innodb_only</code> です。</td></tr></tbody></table></div></div><br class="table-break"><h4><a name="idm139979060684752"></a>config_options テーブル</h4><p>
      <code class="literal">config_options</code> テーブルは、SQL を使用して実行時に変更できる <span class="command"><strong>memcached</strong></span> 関連の設定を格納します。現時点でサポートされる構成オプションは、<code class="literal">separator</code> および <code class="literal">table_map_delimiter</code> です。

      </p><div class="table"><a name="idm139979060680688"></a><p class="title"><b>表 14.13 config_options カラム</b></p><div class="table-contents"><table summary="config_options カラム" border="1"><colgroup><col class="c1"><col class="c2"></colgroup><thead><tr><th scope="col">カラム</th><th scope="col">説明</th></tr></thead><tbody><tr><td scope="row"><code class="literal">Name</code></td><td><span class="command"><strong>memcached</strong></span> 関連の構成オプションの名前。現時点では、次の構成オプションが <code class="literal">config_options</code> テーブル経由でサポートされます。

                <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                      <code class="literal">separator</code>: 複数の <code class="literal">value_columns</code> が定義されている場合に、1 つの長い文字列の値を別々の値に分離するために使用します。デフォルトでは、<code class="literal">separator</code> は <code class="literal">|</code> 文字です。たとえば、値カラムとして <code class="literal">col1, col2</code> を定義し、区切り文字として <code class="literal">|</code> を定義した場合、<span class="command"><strong>memcached</strong></span> で次のコマンドを発行すると、値を <code class="literal">col1</code> および <code class="literal">col2</code> にそれぞれ挿入できます。
                    </p><pre class="programlisting">set keyx 10 0 19
valuecolx|valuecoly</pre><p>
                      <code class="literal">valuecol1x</code> は <code class="literal">col1</code> に格納され、<code class="literal">valuecoly</code> は <code class="literal">col2</code> に格納されます。
                    </p></li><li class="listitem"><p>
                      <code class="literal">table_map_delimiter</code>: 特定のテーブル内のキーにアクセスするために、キー名に <code class="literal">@@</code> 表記を使用するときの、スキーマ名とテーブル名を区切る文字。たとえば、<code class="literal">@@t1.some_key</code> と <code class="literal">@@t2.some_key</code> は同じキー値を持っていますが、異なるテーブルに格納されます。
                    </p></li></ul></div></td></tr><tr><td scope="row"><code class="literal">Value</code></td><td><span class="command"><strong>memcached</strong></span> 関連の構成オプションに割り当てられた値。</td></tr></tbody></table></div></div><p><br class="table-break">
    </p><h4><a name="idm139979060652960"></a>複数カラムのマッピング</h4><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          プラグインの初期化中に、<code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> が、<code class="literal">containers</code> テーブル内に定義されている情報を使用して構成されるとき、<code class="literal">value_columns</code> から構文解析されるマップされた各カラムは、マップされたテーブルに照らして検証されます。複数カラムがマップされる場合、カラムがそれぞれ存在し、正しいタイプであるかどうかを確認するための検査があります。
        </p></li><li class="listitem"><p>
          実行時に、<code class="literal">memcached</code> 挿入操作で、マップされたカラムの数よりも多くの区切り文字が値に存在する場合、マップされた値の数のみが取得されます。たとえば、マップされたカラムが 6 つで、区切られた値が 7 つ提供された場合、最初の 6 つの区切られた値のみが取得されます。7 番目の区切られた値は無視されます。
        </p></li><li class="listitem"><p>
          マップされたカラムより区切られた値の方が少ない場合、入力値のないカラムは NULL に設定されます。未記入カラムを NULL に指定できない場合、挿入は失敗します。
        </p></li><li class="listitem"><p>
          マップされた値より多くのカラムがテーブルにある場合、余分なカラムは出力結果に影響を及ぼしません。
        </p></li></ul></div><h4><a name="idm139979060642848"></a>テーブルの例</h4><p>
      <code class="filename">innodb_memcached_config.sql</code> 構成スクリプトは、例として <code class="literal">test</code> データベース内にテーブル <code class="literal">demo_test</code> を作成します。また、追加のテーブルを作成することなく <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインをただちに動作させることもできます。
    </p><p>
      <code class="literal">container</code> テーブルのエントリは、上記のいずれの目的で、どのカラムが使用されるかを定義します。
    </p><pre class="programlisting">

mysql&gt; select * from innodb_memcache.containers;
+------+-----------+-----------+-------------+---------------+-------+------------+--------------------+------------------------+
| name | db_schema | db_table  | key_columns | value_columns | flags | cas_column | expire_time_column | unique_idx_name_on_key |
+------+-----------+-----------+-------------+---------------+-------+------------+--------------------+------------------------+
| aaa  | test      | demo_test | c1          | c2            | c3    | c4         | c5                 | PRIMARY                |
+------+-----------+-----------+-------------+---------------+-------+------------+--------------------+------------------------+
1 row in set (0.00 sec)

mysql&gt; desc test.demo_test;
+-------+---------------------+------+-----+---------+-------+
| Field | Type                | Null | Key | Default | Extra |
+-------+---------------------+------+-----+---------+-------+
| c1    | varchar(32)         | NO   | PRI |         |       |
| c2    | varchar(1024)       | YES  |     | NULL    |       |
| c3    | int(11)             | YES  |     | NULL    |       |
| c4    | bigint(20) unsigned | YES  |     | NULL    |       |
| c5    | int(11)             | YES  |     | NULL    |       |
+-------+---------------------+------+-----+---------+-------+
5 rows in set (0.01 sec)

</pre><p>
      テーブル ID がキー名の <code class="literal">@@</code> 表記によってリクエストされない場合は、次のようになります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ある行の <code class="literal">name</code> 値が <code class="literal">default</code> の場合、対応するテーブルが <span class="command"><strong>memcached</strong></span> プラグインによって使用されます。したがって、<code class="literal">innodb_memcache.containers</code> の最初のエントリを <code class="literal">demo_test</code> テーブルより後ろに移動させた場合、<code class="literal">name</code> 値に <code class="literal">default</code> を使用します。
        </p></li><li class="listitem"><p>
          <code class="literal">default</code> の <code class="literal">innodb_memcache.containers.name</code> 値が存在しない場合、アルファベット順で先頭の <code class="literal">name</code> 値を持つ行が使用されます。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-memcached-troubleshoot"></a>14.18.8 InnoDB memcached プラグインのトラブルシューティング</h3></div></div></div><p>
      次のリストは、<code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグイン使用時に発生する潜在的な問題と、解決策または回避策があればそれを示しています。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          MySQL エラーログにこのエラーが表示された場合、サーバーが起動に失敗することがあります。
        </p><pre class="programlisting">
failed to set rlimit for open files. Try running as root or requesting
smaller maxconns value.
</pre><p>
          エラーメッセージは実際には <span class="command"><strong>memcached</strong></span> デーモンから出されたものです。1 つの解決策は、開くファイルの数について OS での制限を引き上げることです。コマンドはオペレーティングシステムによって異なります。たとえば、いくつかのオペレーティングシステム上で制限を確認して増加させるコマンドを、次に示します。
        </p><pre class="programlisting">

# Linux
$ ulimit -n
1024
ulimit -n 4096
$ ulimit -n
4096

# OS X Lion (10.6)
$ ulimit -n
256
ulimit -n 4096
$ ulimit -n
4096

</pre><p>
          別の解決策は、<code class="literal">-c</code> オプションを使用して、<span class="command"><strong>memcached</strong></span> デーモンで使用可能な同時接続数を削減することで、デフォルトは 1024 です。MySQL 構成ファイル内の MySQL オプション <code class="literal">daemon_memcached_option</code> を使用して、この <span class="command"><strong>memcached</strong></span> オプションをエンコードします。
        </p><pre class="programlisting">

[mysqld]
...
loose-daemon_memcached_option='-c 64'

</pre></li><li class="listitem"><p>
          <span class="command"><strong>memcached</strong></span> デーモンが <code class="literal">InnoDB</code> テーブルにデータを格納したり、またはデータを取得したりできない場合に問題をトラブルシューティングするには、MySQL 構成オプション <code class="literal">daemon_memcached_option</code> を使用して、<span class="command"><strong>memcached</strong></span> オプション <code class="literal">-vvv</code> を指定します。MySQL エラーログを調べて、<span class="command"><strong>memcached</strong></span> 操作に関係するデバッグ出力がないか検査します。
        </p></li><li class="listitem"><p>
          <span class="command"><strong>memcached</strong></span> 項目値を保持するように指定されたカラムのデータ型が間違っている場合 (たとえば文字列型の代わりに数値型を指定するなど)、キー/値のペアを格納しようとすると、特定のエラーコードまたはメッセージを出さずに失敗します。
        </p></li><li class="listitem"><p>
          <code class="literal">daemon_memcached</code> プラグインで、MySQL Server の開始に関して何らかの問題が発生する場合、MySQL 構成ファイル内の <code class="literal">[mysqld]</code> グループの下に次の行を追加して、トラブルシューティング中にプラグインを無効にします。
        </p><pre class="programlisting">
daemon_memcached=OFF
</pre><p>
          たとえば、必要なデータベースおよびテーブルをセットアップするための <code class="filename">innodb_memcached_config.sql</code> 構成スクリプトを実行する前に <code class="literal">install plugin</code> コマンドを実行した場合、サーバーがクラッシュして開始できないことがあります。または、<code class="literal">innodb_memcache.containers</code> テーブルに正しくないエントリをセットアップした場合、サーバーは開始できないことがあります。
        </p><p>
          MySQL インスタンス用の <span class="command"><strong>memcached</strong></span> プラグインを永続的にオフにするには、次のコマンドを発行します。
        </p><pre class="programlisting">

mysql&gt; uninstall plugin daemon_memcached;

</pre></li><li class="listitem"><p>
          同じマシン上で MySQL の複数インスタンスを実行し、それぞれの <span class="command"><strong>memcached</strong></span> デーモンプラグインを有効にした場合、<code class="literal">daemon_memcached_option</code> 構成オプションを使用して、一意の <span class="command"><strong>memcached</strong></span> ポートを指定してください。
        </p></li><li class="listitem"><p>
          期待するテーブルを SQL ステートメントで検出できなかったり、テーブル内にデータがなかったりする場合でも、<span class="command"><strong>memcached</strong></span> API 呼び出しが引き続き動作し、期待するデータを取得できる場合もあります。これが発生するのは、<code class="literal">innodb_memcache.containers</code> テーブル内にエントリをセットアップしなかったか、<code class="literal">GET</code> または <code class="literal">SET</code> リクエストにキー <code class="literal">@@<em class="replaceable"><code>table_id</code></em></code> を指定して発行することによってそのテーブルに切り換えなかったか、<code class="literal">innodb_memcache.containers</code> 内の既存のエントリに変更を加えたあとで MySQL Server を再起動しなかった場合です。すべてのデータを単一カラム内に格納する <code class="literal">test.demo_test</code> テーブルをデーモンが使用中であっても、自由形式のストレージメカニズムが柔軟なため、<code class="literal">col1|col2|col3</code> のようなマルチカラム値を格納または取得するためのリクエストは、通常は引き続き機能します。
        </p></li><li class="listitem"><p>
          ユーザー独自の <code class="literal">InnoDB</code> テーブルを <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> と一緒に使用するように定義し、テーブル内のカラムが NOT NULL に定義されている場合、<code class="literal">InnoDB</code> テーブル用のディスクリプタを <span class="command"><strong>memcached</strong></span> containers テーブル (<code class="literal">innodb_memcached.containers</code>) に挿入するとき、NOT NULL カラムに値を指定します。マップされたカラムよりも、ディスクリプタの <code class="literal">INSERT</code> ステートメントに含まれる区切られた値の方が少ない場合、入力値のないカラムは NULL に設定されます。NULL 値を NOT NULL カラムに挿入しようとすると、<code class="literal">INSERT</code> は失敗しますが、このことは <code class="literal">InnoDB</code> <span class="command"><strong>memcached</strong></span> プラグインを再初期化して変更内容を containers テーブルに適用したあとではじめて明らかになります。
        </p></li><li class="listitem"><p>
          <code class="literal">innodb_memcached.containers</code> テーブルの <code class="literal">cas_column</code> および <code class="literal">expire_time_column</code> を NULL に設定した場合、<span class="command"><strong>memcached</strong></span> プラグインをロードしようとすると次のエラーが返されます。
        </p><pre class="programlisting">
InnoDB_Memcached: column 6 in the entry for config table 'containers' in
database 'innodb_memcache' has an invalid NULL value.
       </pre><p>
          プラグイン <span class="command"><strong>memcached</strong></span> は <code class="literal">cas_column</code> および <code class="literal">expire_time_column</code> カラムでの NULL の使用を拒否します。これらのカラムを使用しない場合は、カラムの値を <code class="literal">0</code> に設定してください。
        </p></li><li class="listitem"><p>
          <span class="command"><strong>memcached</strong></span> キーと値の長さが増加するにつれ、異なるポイントでサイズと長さの制限が発生します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              キーのサイズが 250 バイトを超える場合、<span class="command"><strong>memcached</strong></span> 操作はエラーを返します。これは <span class="command"><strong>memcached</strong></span> 内での現在の固定制限値です。
            </p></li><li class="listitem"><p>
              値のサイズが 768 バイトを超えるか、3072 バイトを超えるか、<code class="literal">innodb_page_size</code> で指定されたサイズの 1/2 を超えた場合、<code class="literal">InnoDB</code> に関する制限が発生することがあります。これらの制限は、値カラムにインデックスを作成し、そのカラムで SQL からレポート生成クエリーを実行しようとするときに主に適用されます。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-restrictions" title="14.6.7 InnoDB テーブル上の制限">セクション14.6.7「InnoDB テーブル上の制限」</a>を参照してください。
            </p></li><li class="listitem"><p>
              キーと値を組み合わせた最大サイズは 1M バイトです。
            </p></li></ul></div></li><li class="listitem"><p>
          異なるバージョンを持つ MySQL Server 間で構成ファイルを共有している場合、<span class="command"><strong>memcached</strong></span> プラグインの最新の構成オプションを使用すると、古い MySQL バージョンで起動エラーが発生する可能性があります。互換性の問題を回避するには、これらのオプション名の <code class="literal">loose</code> 形式を使用し、たとえば <code class="literal">daemon_memcached_option='-c 64'</code> でなく <code class="literal">loose-daemon_memcached_option='-c 64'</code> と指定します。
        </p></li><li class="listitem"><p>
          文字セットの設定を検証するための制約もチェックもありません。<span class="command"><strong>memcached</strong></span> は、キーおよび値をバイト形式で格納および取得するため、文字セットの違いは区別されません。ただし、<span class="command"><strong>memcached</strong></span> クライアントと MySQL テーブルで、同じ文字セットを使用する必要があります。
        </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="innodb-troubleshooting"></a>14.19 InnoDB のトラブルシューティング</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="innodb-storage-engine.html#error-creating-innodb">14.19.1 InnoDB の I/O に関する問題のトラブルシューティング</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#forcing-innodb-recovery">14.19.2 InnoDB のリカバリの強制的な実行</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-troubleshooting-datadict">14.19.3 InnoDB データディクショナリの操作のトラブルシューティング</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-error-handling">14.19.4 InnoDB のエラー処理</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#innodb-error-codes">14.19.5 InnoDB のエラーコード</a></span></dt><dt><span class="section"><a href="innodb-storage-engine.html#operating-system-error-codes">14.19.6 オペレーティングシステムのエラーコード</a></span></dt></dl></div><a class="indexterm" name="idm139979060540112"></a><p>
    <code class="literal">InnoDB</code> の問題のトラブルシューティングには、次の一般的なガイドラインが適用されます。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        操作が失敗したか、またはバグが疑われる場合は、MySQL サーバーのエラーログを調べてください (<a class="xref" href="server-administration.html#error-log" title="5.2.2 エラーログ">セクション5.2.2「エラーログ」</a>を参照してください)。
      </p></li><li class="listitem"><p>
        その失敗が<a class="link" href="glossary.html#glos_deadlock" title="デッドロック">デッドロック</a>に関連している場合は、<code class="literal">InnoDB</code> の各デッドロックに関する詳細が MySQL サーバーのエラーログに出力されるように、<code class="literal">innodb_print_all_deadlocks</code> オプションが有効になった状態で実行します。
      </p></li><li class="listitem"><p>
        <code class="literal">InnoDB</code> データディクショナリに関する問題には、<code class="literal">CREATE TABLE</code> ステートメントの失敗 (孤立したテーブルファイル)、<code class="filename">.InnoDB</code> ファイルを開くことができない、および <span class="errortext">「指定されたパスを見つけられませんでした」</span> エラーがあります。これらの種類の問題やエラーについては、<a class="xref" href="innodb-storage-engine.html#innodb-troubleshooting-datadict" title="14.19.3 InnoDB データディクショナリの操作のトラブルシューティング">セクション14.19.3「InnoDB データディクショナリの操作のトラブルシューティング」</a>を参照してください。
      </p></li><li class="listitem"><p>
        トラブルシューティング時は通常、<span class="command"><strong>mysqld_safe</strong></span> 経由、または Windows サービスとしてではなく、コマンドプロンプトから MySQL サーバーを実行することが最善です。それにより、<span class="command"><strong>mysqld</strong></span> がコンソールに出力する内容を確認できるため、何が発生しているかをより的確に把握できます。Windows では、出力先がコンソールウィンドウになるように、<code class="option">--console</code> オプションを付けて <span class="command"><strong>mysqld</strong></span> を起動します。
      </p></li><li class="listitem"><p>
        <a class="indexterm" name="idm139979060520784"></a> <a class="indexterm" name="idm139979060518640"></a>

        

        問題に関する情報を取得するには、<code class="literal">InnoDB</code> モニターを有効にします (<a class="xref" href="innodb-storage-engine.html#innodb-monitors" title="14.15 InnoDB モニター">セクション14.15「InnoDB モニター」</a>を参照してください)。その問題がパフォーマンスに関するものか、またはサーバーがハングアップしているように見える場合は、<code class="literal">InnoDB</code> の内部状態に関する情報を出力するために、標準モニターを有効にするようにしてください。問題がロックに関するものである場合は、ロックモニターを有効にします。問題がテーブルの作成中、またはその他のデータディクショナリの操作中のものである場合は、<code class="literal">InnoDB</code> 内部データディクショナリの内容を出力するために、テーブルモニターを有効にします。テーブルスペース情報を表示するには、テーブルスペースモニターを有効にします。
      </p><p>
        <code class="literal">InnoDB</code> は、次の条件の下で <code class="literal">InnoDB</code> 標準モニターの出力を一時的に有効にします。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
            長いセマフォー待機
          </p></li><li class="listitem"><p>
            <code class="literal">InnoDB</code> がバッファープール内に空きブロックを見つけることができない
          </p></li><li class="listitem"><p>
            ロックヒープまたはアダプティブハッシュインデックスによってバッファープールの 67% を超える領域が占有されている
          </p></li></ul></div></li><li class="listitem"><p>
        テーブルが破損していると思われる場合は、そのテーブルに対して <code class="literal">CHECK TABLE</code> を実行します。
      </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="error-creating-innodb"></a>14.19.1 InnoDB の I/O に関する問題のトラブルシューティング</h3></div></div></div><a class="indexterm" name="idm139979060501152"></a><p>
      <code class="literal">InnoDB</code> の I/O に関する問題のトラブルシューティング手順は、その問題がいつ、つまり MySQL サーバーの起動中か、あるいは通常の動作中にファイルシステムレベルの問題で DML または DDL ステートメントが失敗したときのどちらで発生したかによって異なります。
    </p><h4><a name="idm139979060496544"></a>初期化の問題</h4><p>
      <code class="literal">InnoDB</code> がそのテーブルスペースまたはログファイルを初期化しようとしたときに問題が発生した場合は、<code class="literal">InnoDB</code> によって作成されたすべてのファイル、つまりすべての <code class="filename">ibdata</code> ファイルおよびすべての <code class="filename">ib_logfile</code> ファイルを削除します。すでにいくつかの <code class="literal">InnoDB</code> テーブルを作成している場合は、これらのテーブルの対応する <code class="filename">.frm</code> ファイルと、複数のテーブルスペースを使用している場合はすべての <code class="filename">.ibd</code> ファイルも MySQL データベースディレクトリから削除します。次に、再度 <code class="literal">InnoDB</code> データベースを作成してみてください。もっとも簡単なトラブルシューティングとして、何が発生しているかがわかるように、コマンドプロンプトから MySQL サーバーを起動してください。
    </p><h4><a name="idm139979060488160"></a>実行時の問題</h4><p>
      <code class="literal">InnoDB</code> がファイル操作中にオペレーティングシステムのエラーを出力する場合、通常、この問題には次のいずれかの解決方法があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">InnoDB</code> データファイルディレクトリと <code class="literal">InnoDB</code> ログディレクトリが存在することを確認します。
        </p></li><li class="listitem"><p>
          <span class="command"><strong>mysqld</strong></span> に、これらのディレクトリ内にファイルを作成するためのアクセス権があることを確認します。
        </p></li><li class="listitem"><p>
          指定したオプションで起動できるように、<span class="command"><strong>mysqld</strong></span> が正しい <code class="filename">my.cnf</code> または <code class="filename">my.ini</code> オプションファイルを読み取れることを確認します。
        </p></li><li class="listitem"><p>
          ディスクがいっぱいでなく、かつどのディスク割り当て制限も超えていないことを確認します。
        </p></li><li class="listitem"><p>
          サブディレクトリとデータファイルに指定した名前が衝突していないことを確認します。
        </p></li><li class="listitem"><p>
          <code class="literal">innodb_data_home_dir</code> および <code class="literal">innodb_data_file_path</code> 値の構文を再確認します。特に、<code class="literal">innodb_data_file_path</code> オプション内の <code class="literal">MAX</code> 値はすべて強い制限値であるため、その制限を超えると致命的エラーが発生します。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="forcing-innodb-recovery"></a>14.19.2 InnoDB のリカバリの強制的な実行</h3></div></div></div><a class="indexterm" name="idm139979060470048"></a><a class="indexterm" name="idm139979060467184"></a><a class="indexterm" name="idm139979060465024"></a><p>
      データベースページの破損を調査するために、<code class="literal">SELECT ... INTO OUTFILE</code> を使用して、データベースからテーブルをダンプできます。通常は、この方法で取得されたデータのほとんどが完全な状態にあります。重大な破損では、<code class="literal">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em></code> ステートメントまたは <code class="literal">InnoDB</code> のバックグラウンド操作がクラッシュまたは表明したり、場合によっては <code class="literal">InnoDB</code> のロールフォワードリカバリがクラッシュしたりすることもあります。このような場合は、テーブルをダンプできるように、<code class="literal">innodb_force_recovery</code> オプションを使用して、バックグラウンド操作が実行されないようにして <code class="literal">InnoDB</code> ストレージエンジンを強制的に起動させることができます。たとえば、サーバーを再起動する前に、オプションファイルの <code class="literal">[mysqld]</code> セクションに次の行を追加できます。
    </p><pre class="programlisting">
[mysqld]
innodb_force_recovery = 1
</pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
        <code class="literal">innodb_force_recovery</code> を 0 を超える値に設定するのは、緊急の状況で <code class="literal">InnoDB</code> を起動し、テーブルをダンプできるようにする場合だけにしてください。それを行う前に、データベースの再作成が必要になった場合に備えて、データベースのバックアップコピーがあることを確認してください。4 以上の値を指定すると、データファイルが永続的に破損する場合があります。本番サーバーインスタンス上で 4 以上の <code class="literal">innodb_force_recovery</code> 設定を使用するのは、使用するデータベースの個別の物理コピーでその設定を正常にテストしたあとだけにしてください。<code class="literal">InnoDB</code> のリカバリを強制的に実行する場合は、常に <code class="literal">innodb_force_recovery=1</code> から始め、必要がある場合にのみこの値を 1 ずつ増やすようにしてください。
      </p></div><p>
      <code class="literal">innodb_force_recovery</code> は、デフォルトでは 0 です (リカバリが強制的に実行されない通常の起動)。<code class="literal">innodb_force_recovery</code> の許可される 0 以外の値は 1 から 6 までです。大きい方の値には、小さい方の値の機能が含まれています。たとえば、3 の値には、値 1 と 2 のすべての機能が含まれています。
    </p><p>
      3 以下の <code class="literal">innodb_force_recovery</code> 値を使用してテーブルをダンプできる場合は、破損した個々のページ上の一部のデータしか失われないため、比較的安全です。4 以上の値は、データファイルが永続的に破損する場合があるため、危険であるとみなされます。6 の値は、データベースページが廃止された状態のままになり、それによって B ツリーやその他のデータベース構造にさらに多くの破損が導入される可能性があるため、きわめて危険であるとみなされます。
    </p><p>
      安全策として、<code class="literal">innodb_force_recovery</code> が 0 より大きい場合、<code class="literal">InnoDB</code> は <code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、または <code class="literal">DELETE</code> 操作を回避します。MySQL 5.6.15 の時点では、4 以上の <code class="literal">innodb_force_recovery</code> 設定は <code class="literal">InnoDB</code> を読み取り専用モードにします。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">1</code> (<code class="literal">SRV_FORCE_IGNORE_CORRUPT</code>)
        </p><p>
          破損した<a class="link" href="glossary.html#glos_page" title="ページ">ページ</a>を検出した場合でも、サーバーが動作できるようにします。<code class="literal">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em></code> での破損したインデックスレコードおよびページの飛び越しを試行します。これが、テーブルのダンプに役立ちます。
        </p></li><li class="listitem"><p>
          <code class="literal">2</code> (<code class="literal">SRV_FORCE_NO_BACKGROUND</code>)
        </p><p>
          <a class="link" href="glossary.html#glos_master_thread" title="マスタースレッド">マスタースレッド</a>や、すべての<a class="link" href="glossary.html#glos_purge_thread" title="パージスレッド">パージスレッド</a>が実行されないようにします。<a class="link" href="glossary.html#glos_purge" title="パージ">パージ</a>操作中にクラッシュが発生しそうになった場合は、このリカバリの値によって回避されます。
        </p></li><li class="listitem"><p>
          <code class="literal">3</code> (<code class="literal">SRV_FORCE_NO_TRX_UNDO</code>)
        </p><p>
          <a class="link" href="glossary.html#glos_crash_recovery" title="クラッシュリカバリ">クラッシュリカバリ</a>のあとにトランザクション<a class="link" href="glossary.html#glos_rollback" title="ロールバック">ロールバック</a>を実行しません。
        </p></li><li class="listitem"><p>
          <code class="literal">4</code> (<code class="literal">SRV_FORCE_NO_IBUF_MERGE</code>)
        </p><p>
          <a class="link" href="glossary.html#glos_insert_buffer" title="挿入バッファー">挿入バッファー</a>のマージ操作を回避します。その操作によってクラッシュが発生しそうになった場合は、それが回避されます。テーブル<a class="link" href="glossary.html#glos_statistics" title="統計">統計</a>を計算しません。この値を指定すると、データファイルが永続的に破損する場合があります。この値を使用したあと、すべてのセカンダリインデックスを削除して再作成するように準備してください。MySQL 5.6.15 の時点では、<code class="literal">InnoDB</code> を読み取り専用に設定します。
        </p></li><li class="listitem"><p>
          <code class="literal">5</code> (<code class="literal">SRV_FORCE_NO_UNDO_LOG_SCAN</code>)
        </p><p>
          データベースを起動するときに、<a class="link" href="glossary.html#glos_undo_log" title="Undo ログ">Undo ログ</a>を参照しません。<code class="literal">InnoDB</code> は、未完了のトランザクションでさえコミット済みとして処理します。この値を指定すると、データファイルが永続的に破損する場合があります。MySQL 5.6.15 の時点では、<code class="literal">InnoDB</code> を読み取り専用に設定します。
        </p></li><li class="listitem"><p>
          <code class="literal">6</code> (<code class="literal">SRV_FORCE_NO_LOG_REDO</code>)
        </p><p>
          リカバリに関連した <a class="link" href="glossary.html#glos_redo_log" title="Redo ログ">Redo ログ</a>のロールフォワードを実行しません。この値を指定すると、データファイルが永続的に破損する場合があります。データベースページを廃止された状態のままにし、それによって B ツリーやその他のデータベース構造にさらに多くの破損が発生する可能性があります。MySQL 5.6.15 の時点では、<code class="literal">InnoDB</code> を読み取り専用に設定します。
        </p></li></ul></div><p>
      テーブルからの <code class="literal">SELECT</code> を実行してテーブルをダンプしたり、3 以下の <code class="literal">innodb_force_recovery</code> 値を使用してテーブルの <code class="literal">DROP</code> または <code class="literal">CREATE</code> を実行したりすることができます。ロールバック時に特定のテーブルでクラッシュが発生することがわかっている場合は、そのテーブルを削除できます。失敗した大量のインポートまたは <code class="literal">ALTER TABLE</code> によってロールバックの暴走が発生する場合は、<span class="command"><strong>mysqld</strong></span> プロセスを強制終了し、<code class="literal">innodb_force_recovery</code> を <code class="literal">3</code> に設定してロールバックなしでデータベースを起動したあと、ロールバックの暴走の原因になっているテーブルの <code class="literal">DROP</code> を実行することができます。
    </p><p>
      テーブルデータ内の破損のためにテーブルの内容全体をダンプできない場合は、<code class="literal">ORDER BY <em class="replaceable"><code>primary_key</code></em> DESC</code> 句を含むクエリーで、破損した部分のあとにあるテーブルの部分をダンプできる可能性があります。
    </p><p>
      <code class="literal">InnoDB</code> を起動するために <code class="literal">innodb_force_recovery</code> を大きな値にする必要がある場合は、複雑なクエリー (<code class="literal">WHERE</code>、<code class="literal">ORDER BY</code>、またはその他の句を含むクエリー) を失敗させることがある破損したデータ構造が存在する可能性があります。この場合は、基本的な <code class="literal">SELECT * FROM t</code> クエリーしか実行できない可能性があります。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-troubleshooting-datadict"></a>14.19.3 InnoDB データディクショナリの操作のトラブルシューティング</h3></div></div></div><a class="indexterm" name="idm139979060388112"></a><p>
      テーブル定義に関する情報は、<code class="literal">.frm</code> ファイルと InnoDB <a class="link" href="glossary.html#glos_data_dictionary" title="データディクショナリ">データディクショナリ</a>の両方に格納されます。<code class="filename">.frm</code> ファイルをあちこちに移動したり、データディクショナリの操作の最中にサーバーがクラッシュしたりすると、これらの情報のソースに整合性がなくなることがあります。
    </p><p>
      データディクショナリの破損や一貫性の問題によって <code class="literal">InnoDB</code> を起動できない場合は、手動のリカバリに関する情報について、<a class="xref" href="innodb-storage-engine.html#forcing-innodb-recovery" title="14.19.2 InnoDB のリカバリの強制的な実行">セクション14.19.2「InnoDB のリカバリの強制的な実行」</a>を参照してください。
    </p><h4><a name="idm139979060379760"></a>CREATE TABLE での問題</h4><p>
      同期がとれていないデータディクショナリの 1 つの現象として、<code class="literal">CREATE TABLE</code> ステートメントが失敗することが挙げられます。これが発生した場合は、サーバーのエラーログを調べてください。そのログに、<code class="literal">InnoDB</code> 内部データディクショナリの内部にテーブルがすでに存在することが示されている場合は、<code class="literal">InnoDB</code> テーブルスペースファイルの内部に、対応する <code class="filename">.frm</code> ファイルのない孤立したテーブルがあります。そのエラーメッセージは次のようになります。
    </p><pre class="programlisting">
InnoDB: Error: table test/parent already exists in InnoDB internal
InnoDB: data dictionary. Have you deleted the .frm file
InnoDB: and not used DROP TABLE? Have you used DROP DATABASE
InnoDB: for InnoDB tables in MySQL version &lt;= 3.23.43?
InnoDB: See the Restrictions section of the InnoDB manual.
InnoDB: You can drop the orphaned table inside InnoDB by
InnoDB: creating an InnoDB table with the same name in another
InnoDB: database and moving the .frm file to the current database.
InnoDB: Then MySQL thinks the table exists, and DROP TABLE will
InnoDB: succeed.
</pre><p>
      この孤立したテーブルは、エラーメッセージに示されている手順に従うことによって削除できます。それでも <code class="literal">DROP TABLE</code> を正常に使用できない場合、その問題の原因は <span class="command"><strong>mysql</strong></span> クライアントでの名前補完である可能性があります。この問題を回避するには、<code class="option">--skip-auto-rehash</code> オプションを使用して <span class="command"><strong>mysql</strong></span> クライアントを起動し、<code class="literal">DROP TABLE</code> を再試行します。(名前補完がオンになっていると、<span class="command"><strong>mysql</strong></span> はテーブル名のリストを構築しようとしますが、今説明したような問題が存在した場合は失敗します。)
    </p><h4><a name="idm139979060365440"></a>テーブルを開くときの問題</h4><p>
      同期がとれていないデータディクショナリの別の現象として、MySQL から <code class="filename">.InnoDB</code> ファイルを開くことができないというエラーが出力されます。
    </p><pre class="programlisting">
ERROR 1016: Can't open file: 'child2.InnoDB'. (errno: 1)
</pre><p>
      エラーログに、次のようなメッセージが見つかります。
    </p><pre class="programlisting">
InnoDB: Cannot find table test/child2 from the internal data dictionary
InnoDB: of InnoDB though the .frm file for the table exists. Maybe you
InnoDB: have deleted and recreated InnoDB data files but have forgotten
InnoDB: to delete the corresponding .frm files of InnoDB tables?
</pre><p>
      これは、<code class="literal">InnoDB</code> の内部に対応するテーブルのない孤立した <code class="filename">.frm</code> ファイルが存在することを示します。この孤立した <code class="filename">.frm</code> ファイルは、手動で削除することによって削除できます。
    </p><a class="indexterm" name="idm139979060358096"></a><a class="indexterm" name="idm139979060355952"></a><a class="indexterm" name="idm139979060354032"></a><h4><a name="idm139979060351856"></a>孤立した中間テーブル</h4><p>
      <code class="literal">ALTER TABLE</code> 操作の最中に MySQL がクラッシュした場合は、孤立した中間テーブルが残ったままになることがあります。中間テーブル名は <span class="quote">「<span class="quote">#sql-</span>」</span> で始まります。データディレクトリ内には <code class="filename">#sql-*.ibd</code> ファイルが見つかるほか、付随する <code class="filename">#sql-*.frm</code> ファイルも存在する可能性があります。中間テーブルはまた、<a class="link" href="innodb-storage-engine.html#innodb-monitors" title="14.15 InnoDB モニター">テーブルモニター</a>の出力にも表示され、<code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code> テーブルでも参照されます。
    </p><p>
      孤立した中間テーブルを削除するには、<code class="filename">#sql-*.ibd</code> ファイルで定義されているテーブルスキーマに一致するテーブル形式ファイル (<code class="literal">.frm</code> ファイル) が必要です (カラムとインデックスが同じである必要があります)。クラッシュが <code class="literal">ALTER TABLE</code> 操作中のいつ発生したかに応じて、孤立した <code class="filename">#sql-*.ibd</code> ファイルには <code class="literal">ALTER</code> の前または <code class="literal">ALTER</code> のあとのスキーマ定義が存在する可能性があり、付随する <code class="filename">#sql-*.frm</code> ファイル (存在する場合) 内のデータも一致する場合と一致しない場合があります。
    </p><p>
      孤立した中間テーブルを削除するには、次の手順を実行します。
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          <code class="filename">#sql-*.ibd</code> ファイルに <code class="literal">ALTER</code> の前または <code class="literal">ALTER</code> のあとのどちらのスキーマ定義が存在するかを判定します。中間テーブルのカラムとインデックスは、<a class="link" href="innodb-storage-engine.html#innodb-monitors" title="14.15 InnoDB モニター">テーブルモニター</a>を使用して、または <code class="literal">InnoDB</code> <code class="literal">INFORMATION_SCHEMA</code> テーブルをクエリーすることによって表示できます。<code class="literal">INNODB_SYS_TABLES</code> は、中間テーブルの <code class="literal">TABLE_ID</code> を提供します。これを使用すると、<code class="literal">INNODB_SYS_COLUMNS</code> および <code class="literal">INNODB_SYS_INDEXES</code> からカラムとインデックスの情報を取得できます。
        </p></li><li class="listitem"><p>
          <code class="filename">#sql-*.ibd</code> ファイルに <code class="literal">ALTER</code> の前または <code class="literal">ALTER</code> のあとのどちらのスキーマ定義が存在するかを判定したら、一致する <code class="filename">#sql-*.frm</code> ファイルを別のデータベースディレクトリ内に作成します。たとえば、中間テーブルに <code class="literal">ALTER</code> のあとのスキーマ定義が存在する場合は、変更されたスキーマ定義に一致する <code class="literal">.frm</code> ファイルを作成します。
        </p><pre class="programlisting">mysql&gt; CREATE TABLE tmp LIKE employees.salaries; ALTER TABLE tmp DROP COLUMN to_date;
Query OK, 0 rows affected (0.02 sec)
      
Query OK, 0 rows affected (0.06 sec)
Records: 0  Duplicates: 0  Warnings: 0    </pre></li><li class="listitem"><p>
          <code class="literal">.frm</code> ファイルを孤立したテーブルが存在するデータベースディレクトリにコピーし、その名前を <code class="filename">#sql-*.ibd</code> ファイルの名前に一致するように変更します。
        </p><pre class="programlisting">shell&gt; cp tmp.frm employees/#sql-ib87.frm</pre></li><li class="listitem"><p>
          テーブルの名前にプリフィクス <code class="literal">#mysql50#</code> を付け、テーブル名を逆引用符で囲んだ <code class="literal">DROP TABLE</code> ステートメントを発行することによって、中間テーブルを削除します。例:
        </p><pre class="programlisting">mysql&gt; DROP TABLE `#mysql50##sql-ib87`;
Query OK, 0 rows affected (0.01 sec)</pre><p>
          <code class="literal">#mysql50#</code> のプリフィクスは、MySQL 5.1 で導入された <code class="literal">file name safe encoding</code> を無視するよう MySQL に指示します。テーブル名を逆引用符で囲むことは、<span class="quote">「<span class="quote">#</span>」</span>などの特殊文字を含むテーブル名に対して SQL ステートメントを実行するために必要です。
        </p></li><li class="listitem"><p>
          残りの <code class="filename">#sql-*.frm</code> ファイルが存在する場合は、それを削除します。MySQL が<span class="quote">「<span class="quote">不明なテーブル</span>」</span>エラーをレポートしますが、これは無視できます。
        </p><pre class="programlisting">mysql&gt; DROP TABLE `#mysql50##sql-36ab_2`;
ERROR 1051 (42S02): Unknown table 'employees.#mysql50##sql-36ab_2'</pre></li></ol></div><h4><a name="idm139979060307872"></a>テーブルスペースが見つからない問題</h4><p>
      <code class="literal">innodb_file_per_table</code> が有効になっていると、<code class="literal">.frm</code> または <code class="literal">.ibd</code> ファイル (あるいはその両方) が見つからない場合に、次のメッセージが生成されることがあります。
    </p><pre class="programlisting">
InnoDB: in InnoDB data dictionary has tablespace id <em class="replaceable"><code>N</code></em>,
InnoDB: but tablespace with that id or name does not exist. Have
InnoDB: you deleted or moved .ibd files?
InnoDB: This may also be a table created with CREATE TEMPORARY TABLE
InnoDB: whose .ibd and .frm files MySQL automatically removed, but the
InnoDB: table still exists in the InnoDB internal data dictionary.
</pre><p>
      これが発生した場合は、問題を解決するために次の手順を試してください。
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          一致する <code class="filename">.frm</code> ファイルをどこかほかのデータベースディレクトリ内に作成し、それを孤立したテーブルが存在するデータベースディレクトリにコピーします。
        </p></li><li class="listitem"><p>
          元のテーブルに対して <code class="literal">DROP TABLE</code> を発行します。それにより、テーブルが正常に削除され、<code class="literal">InnoDB</code> によって、<code class="filename">.ibd</code> ファイルが見つからなかったことを示す警告がエラーログに出力されるはずです。
        </p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-error-handling"></a>14.19.4 InnoDB のエラー処理</h3></div></div></div><a class="indexterm" name="idm139979060293360"></a><a class="indexterm" name="idm139979060290480"></a><p>
      <code class="literal">InnoDB</code> でのエラー処理は、SQL 標準で指定されているものと必ずしも同じではありません。この標準によると、SQL ステートメント中にエラーが発生した場合は必ず、そのステートメントのロールバックを実行するべきです。<code class="literal">InnoDB</code> は場合によって、ステートメントの一部のみ、またはトランザクション全体をロールバックします。次の各項目は、<code class="literal">InnoDB</code> がエラー処理をどのように実行するかについて説明しています。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="link" href="glossary.html#glos_tablespace" title="テーブルスペース">テーブルスペース</a>内のファイル領域が不足した場合は、MySQL の <code class="literal">Table is full</code> エラーが発生し、<code class="literal">InnoDB</code> は SQL ステートメントをロールバックします。
        </p></li><li class="listitem"><p>
          トランザクション<a class="link" href="glossary.html#glos_deadlock" title="デッドロック">デッドロック</a>が発生すると、<code class="literal">InnoDB</code> は<a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a>全体を<a class="link" href="glossary.html#glos_rollback" title="ロールバック">ロールバック</a>します。これが発生した場合は、トランザクション全体を再試行します。
        </p><p>
          ロック待機のタイムアウトが発生すると、<code class="literal">InnoDB</code> は、ロックの待機中にタイムアウトが発生した 1 つのステートメントのみをロールバックします。(トランザクション全体がロールバックされるようにするには、<code class="option">--innodb_rollback_on_timeout</code> オプションを使用してサーバーを起動します。)現在の動作を使用している場合はそのステートメントを、<code class="option">--innodb_rollback_on_timeout</code> を使用している場合はトランザクション全体を再試行します。
        </p><p>
          デッドロックとロック待機のタイムアウトはどちらもビジー状態のサーバーでは通常のことであり、アプリケーションはそれらが発生する可能性を認識し、発生した場合は再試行によって処理する必要があります。トランザクション中の最初のデータ変更からコミットまでの間に行う作業をできるだけ少なくして、ロックが可能性のある最短の時間、可能性のある最少の行数に対して保持されるようにすることにより、それらが発生する可能性を少なくすることができます。場合によっては、異なるトランザクション間での作業の分割が実際的で、かつ役立つことがあります。
        </p><p>
          デッドロックまたはロック待機のタイムアウトのためにトランザクションロールバックが発生すると、そのトランザクション内のステートメントの効果が取り消されます。ただし、トランザクション開始ステートメントが <code class="literal">START TRANSACTION</code> または <code class="literal">BEGIN</code> ステートメントであった場合、そのステートメントはロールバックによって取り消されません。それ以上の SQL ステートメントは、<code class="literal">COMMIT</code>、<code class="literal">ROLLBACK</code>、または暗黙的なコミットを発生させる何らかの SQL ステートメントが現れるまで、そのトランザクションの一部になります。
        </p></li><li class="listitem"><p>
          ステートメントで <code class="literal">IGNORE</code> オプションを指定していない場合、重複キーエラーは SQL ステートメントをロールバックします。
        </p></li><li class="listitem"><p>
          <code class="literal">row too long error</code> は、SQL ステートメントをロールバックします。
        </p></li><li class="listitem"><p>
          その他のエラーはほとんど (<code class="literal">InnoDB</code> ストレージエンジンレベルの上にある) コードの MySQL レイヤーによって検出され、対応する SQL ステートメントをロールバックします。1 つの SQL ステートメントのロールバックでは、ロックは解放されません。
        </p></li></ul></div><p>
      暗黙的なロールバック中や、明示的な <code class="literal">ROLLBACK</code> SQL ステートメントの実行中に、<code class="literal">SHOW PROCESSLIST</code> は、関連する接続の <code class="literal">State</code> カラムに <code class="literal">Rolling back</code> を表示します。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="innodb-error-codes"></a>14.19.5 InnoDB のエラーコード</h3></div></div></div><a class="indexterm" name="idm139979060253072"></a><p>
      次に示すのは、発生する可能性のある <code class="literal">InnoDB</code> 固有の一般的なエラーのリスト (ただし、すべてが含まれているわけではありません)、および各エラーが発生する理由と問題の解決方法に関する情報です。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">1005 (ER_CANT_CREATE_TABLE)</code>
        </p><p>
          テーブルを作成できません。エラーメッセージがエラー 150 を示している場合は、<a class="link" href="glossary.html#glos_foreign_key_constraint" title="FOREIGN KEY 制約">外部キー制約</a>が正しく形成されていなかったためにテーブルの作成が失敗しました。エラーメッセージがエラー -1 を示している場合は、テーブルに内部の <code class="literal">InnoDB</code> テーブルの名前に一致したカラム名が含まれているためにテーブルの作成が失敗した可能性があります。
        </p></li><li class="listitem"><p>
          <code class="literal">1016 (ER_CANT_OPEN_FILE)</code>
        </p><p>
          <code class="literal">InnoDB</code> テーブルの <code class="filename">.frm</code> ファイルが存在するにもかかわらず、このテーブルが <code class="literal">InnoDB</code> <a class="link" href="glossary.html#glos_data_files" title="データファイル">データファイル</a>に見つかりません。<a class="xref" href="innodb-storage-engine.html#innodb-troubleshooting-datadict" title="14.19.3 InnoDB データディクショナリの操作のトラブルシューティング">セクション14.19.3「InnoDB データディクショナリの操作のトラブルシューティング」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">1114 (ER_RECORD_FILE_FULL)</code>
        </p><p>
          

          <code class="literal">InnoDB</code> でテーブルスペース内の空き領域が不足しています。新しいデータファイルを追加するために、テーブルスペースを再構成してください。
        </p></li><li class="listitem"><p>
          <code class="literal">1205 (ER_LOCK_WAIT_TIMEOUT)</code>
        </p><p>
          ロック待機のタイムアウトの期限が切れました。<a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a>全体ではなく、待機時間の長すぎたステートメントが<a class="link" href="glossary.html#glos_rollback" title="ロールバック">ロールバック</a>されました。<code class="literal">innodb_lock_wait_timeout</code> 構成オプションの値は、SQL ステートメントがほかのトランザクションの完了をより長い時間待機するようにする場合は増やし、また長時間実行されるトランザクションが多すぎるために<a class="link" href="glossary.html#glos_locking" title="ロック">ロック</a>の問題が発生し、さらにビジー状態のシステム上の<a class="link" href="glossary.html#glos_concurrency" title="並列性">並列性</a>が低下している場合は減らすことができます。
        </p></li><li class="listitem"><p>
          <code class="literal">1206 (ER_LOCK_TABLE_FULL)</code>
        </p><p>
          ロックの総数が、<code class="literal">InnoDB</code> でロックの管理専用に使用されているメモリーの量を超えています。このエラーを回避するには、<code class="literal">innodb_buffer_pool_size</code> の値を増やします。個々のアプリケーション内では、大きな操作をより小さな操作に分割することが回避方法になる場合があります。たとえば、このエラーが大きな <code class="literal">INSERT</code> で発生する場合は、複数のより小さな <code class="literal">INSERT</code> 操作を実行します。
        </p></li><li class="listitem"><p>
          <code class="literal">1213 (ER_LOCK_DEADLOCK)</code>
        </p><p>
          <a class="link" href="glossary.html#glos_transaction" title="トランザクション">トランザクション</a>で<a class="link" href="glossary.html#glos_deadlock" title="デッドロック">デッドロック</a>が発生し、アプリケーションで修正措置をとることができるように自動的に<a class="link" href="glossary.html#glos_rollback" title="ロールバック">ロールバック</a>されました。このエラーからリカバリするには、このトランザクション内のすべての操作を再度実行します。デッドロックは、ロックに対する要求がトランザクション間で整合性のない順序で到着した場合に発生します。ロールバックされたトランザクションがそのすべてのロックを解放したため、ほかのトランザクションは要求したすべてのロックを取得できるようになりました。そのため、ロールバックされたトランザクションを再実行すると、そのトランザクションがほかのトランザクションの完了を待機しなければならないことがありますが、通常デッドロックは再発しません。デッドロックが頻繁に発生する場合は、ロック操作のシーケンス (<code class="literal">LOCK TABLES</code>、<code class="literal">SELECT ... FOR UPDATE</code> など) を、問題が発生する異なるトランザクションまたはアプリケーション間で整合性があるようにしてください。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-deadlocks" title="14.2.11 デッドロックの対処方法">セクション14.2.11「デッドロックの対処方法」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">1216 (ER_NO_REFERENCED_ROW)</code>
        </p><p>
          

          行を追加しようとしていますが、親の行がないため、<a class="link" href="glossary.html#glos_foreign_key_constraint" title="FOREIGN KEY 制約">外部キー制約</a>に違反します。最初に親の行を追加してください。
        </p></li><li class="listitem"><p>
          <code class="literal">1217 (ER_ROW_IS_REFERENCED)</code>
        </p><p>
          子を持つ親の行を削除しようとしているため、<a class="link" href="glossary.html#glos_foreign_key_constraint" title="FOREIGN KEY 制約">外部キー制約</a>に違反します。最初に子を削除してください。
        </p></li><li class="listitem"><p>
          <code class="literal">ERROR 1553 (HY000): インデックス '<em class="replaceable"><code>fooIdx</code></em>' をドロップできません。外部キー制約で必要とされています</code>
        </p><p>
          このエラーメッセージは、特定の参照制約を適用できる最後のインデックスを削除しようとしたときにレポートされます。
        </p><p>
          DML ステートメントの最適なパフォーマンスを得るために、<code class="literal">InnoDB</code> では、<a class="link" href="glossary.html#glos_parent_table" title="親テーブル">親テーブル</a>での <code class="literal">UPDATE</code> および <code class="literal">DELETE</code> 操作で、対応する行が<a class="link" href="glossary.html#glos_child_table" title="子テーブル">子テーブル</a>内に存在するかどうかを容易にチェックできるように、インデックスは<a class="link" href="glossary.html#glos_foreign_key" title="外部キー">外部キー</a>カラムに存在する必要があります。<code class="literal">CREATE TABLE</code>、<code class="literal">CREATE INDEX</code>、および <code class="literal">ALTER TABLE</code> ステートメントの副作用として、MySQL は、このようなインデックスを必要に応じて自動的に作成または削除します。
        </p><p>
          インデックスを削除すると、<code class="literal">InnoDB</code> は、そのインデックスが外部キー制約のチェックに使用されていないかどうかをチェックします。同じ制約を適用するために使用できる別のインデックスが存在する場合は、引き続きインデックスを削除できます。<code class="literal">InnoDB</code> は、特定の参照制約を適用できる最後のインデックスを削除できないようにしています。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="operating-system-error-codes"></a>14.19.6 オペレーティングシステムのエラーコード</h3></div></div></div><a class="indexterm" name="idm139979060188688"></a><a class="indexterm" name="idm139979060185840"></a><p>
      オペレーティングシステムのエラー番号に対するエラーメッセージを出力するには、次のいずれかのオプションを使用できます。<span class="command"><strong>perror</strong></span> プログラムは、MySQL 配布に付属しています。
    </p><pre class="programlisting">
$ perror 123
$ perl -MPOSIX -le 'print strerror 123'
$ python -c 'import os; print os.strerror(123)'
        </pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="operating-system-error-codes-linux"></a>
          <span class="bold"><strong>Linux システムのエラーコード</strong></span>
        </p><p>
          次の表は、Linux システムのエラーコードの部分的なリストを示しています。
        </p><div class="informaltable"><table summary=" InnoDB のファイル操作およびその他のシステムコールに関連付けられた Linux のエラーコード。" border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">番号</th><th scope="col">マクロ</th><th scope="col">説明</th></tr></thead><tbody><tr><td scope="row">1</td><td><code class="literal">EPERM</code></td><td>操作が許可されていません</td></tr><tr><td scope="row">2</td><td><code class="literal">ENOENT</code></td><td>そのようなファイルまたはディレクトリはありません</td></tr><tr><td scope="row">3</td><td><code class="literal">ESRCH</code></td><td>そのようなプロセスはありません</td></tr><tr><td scope="row">4</td><td><code class="literal">EINTR</code></td><td>システムコールが中断されました</td></tr><tr><td scope="row">5</td><td><code class="literal">EIO</code></td><td>I/O エラーです</td></tr><tr><td scope="row">6</td><td><code class="literal">ENXIO</code></td><td>そのようなデバイスまたはアドレスはありません</td></tr><tr><td scope="row">7</td><td><code class="literal">E2BIG</code></td><td>引数リストが長すぎます</td></tr><tr><td scope="row">8</td><td><code class="literal">ENOEXEC</code></td><td>exec フォーマットエラー</td></tr><tr><td scope="row">9</td><td><code class="literal">EBADF</code></td><td>不正なファイル番号です</td></tr><tr><td scope="row">10</td><td><code class="literal">ECHILD</code></td><td>子プロセスがありません</td></tr><tr><td scope="row">11</td><td><code class="literal">EAGAIN</code></td><td>再試行してください</td></tr><tr><td scope="row">12</td><td><code class="literal">ENOMEM</code></td><td>メモリー不足です</td></tr><tr><td scope="row">13</td><td><code class="literal">EACCES</code></td><td>アクセス権が拒否されました</td></tr><tr><td scope="row">14</td><td><code class="literal">EFAULT</code></td><td>不正なアドレスです</td></tr><tr><td scope="row">15</td><td><code class="literal">ENOTBLK</code></td><td>ブロック型デバイスが必要です</td></tr><tr><td scope="row">16</td><td><code class="literal">EBUSY</code></td><td>デバイスまたはリソースがビジー状態です</td></tr><tr><td scope="row">17</td><td><code class="literal">EEXIST</code></td><td>ファイルが存在します</td></tr><tr><td scope="row">18</td><td><code class="literal">EXDEV</code></td><td>デバイスにまたがるリンクです</td></tr><tr><td scope="row">19</td><td><code class="literal">ENODEV</code></td><td>そのようなデバイスはありません</td></tr><tr><td scope="row">20</td><td><code class="literal">ENOTDIR</code></td><td>ディレクトリではありません</td></tr><tr><td scope="row">21</td><td><code class="literal">EISDIR</code></td><td>ディレクトリです</td></tr><tr><td scope="row">22</td><td><code class="literal">EINVAL</code></td><td>無効な引数です</td></tr><tr><td scope="row">23</td><td><code class="literal">ENFILE</code></td><td>ファイルテーブルがオーバーフローしました</td></tr><tr><td scope="row">24</td><td><code class="literal">EMFILE</code></td><td>開かれたファイルが多すぎます</td></tr><tr><td scope="row">25</td><td><code class="literal">ENOTTY</code></td><td>デバイスへの ioctl が正しくありません</td></tr><tr><td scope="row">26</td><td><code class="literal">ETXTBSY</code></td><td>テキストファイルがビジー状態です</td></tr><tr><td scope="row">27</td><td><code class="literal">EFBIG</code></td><td>ファイルが大きすぎます</td></tr><tr><td scope="row">28</td><td><code class="literal">ENOSPC</code></td><td>デバイスに領域が残されていません</td></tr><tr><td scope="row">29</td><td><code class="literal">ESPIPE</code></td><td>ファイルディスクリプタでシークが許可されていません</td></tr><tr><td scope="row">30</td><td><code class="literal">EROFS</code></td><td>読み取り専用ファイルシステムです</td></tr><tr><td scope="row">31</td><td><code class="literal">EMLINK</code></td><td>リンクが多すぎます</td></tr></tbody></table></div></li><li class="listitem"><p><a name="operating-system-error-codes-windows"></a>
          <span class="bold"><strong>Windows システムのエラーコード</strong></span>
        </p><p>
          次の表は、Windows システムのいくつかの一般的なエラーコードのリストを示しています。完全なリストについては、<a class="ulink" href="http://msdn.microsoft.com/en-us/library/ms681381.aspx" target="_top">Microsoft の Web サイト</a>を参照してください。
        </p><div class="informaltable"><table summary=" InnoDB のファイル操作およびその他のシステムコールに関連付けられた Windows のエラーコード。" border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">番号</th><th scope="col">マクロ</th><th scope="col">説明</th></tr></thead><tbody><tr><td scope="row">1</td><td><code class="literal">ERROR_INVALID_FUNCTION</code></td><td>ファンクションが間違っています。</td></tr><tr><td scope="row">2</td><td><code class="literal">ERROR_FILE_NOT_FOUND</code></td><td>指定されたファイルが見つかりません。</td></tr><tr><td scope="row">3</td><td><code class="literal">ERROR_PATH_NOT_FOUND</code></td><td>指定されたパスを見つけられませんでした。</td></tr><tr><td scope="row">4</td><td><code class="literal">ERROR_TOO_MANY_OPEN_FILES</code></td><td>ファイルを開くことができません。</td></tr><tr><td scope="row">5</td><td><code class="literal">ERROR_ACCESS_DENIED</code></td><td>アクセスは拒否されました。</td></tr><tr><td scope="row">6</td><td><code class="literal">ERROR_INVALID_HANDLE</code></td><td>ハンドルが無効です。</td></tr><tr><td scope="row">7</td><td><code class="literal">ERROR_ARENA_TRASHED</code></td><td>記憶域制御ブロックが壊れています。</td></tr><tr><td scope="row">8</td><td><code class="literal">ERROR_NOT_ENOUGH_MEMORY</code></td><td>このコマンドを実行するための十分な記憶域がありません。</td></tr><tr><td scope="row">9</td><td><code class="literal">ERROR_INVALID_BLOCK</code></td><td>記憶域制御ブロックのアドレスが無効です。</td></tr><tr><td scope="row">10</td><td><code class="literal">ERROR_BAD_ENVIRONMENT</code></td><td>環境が間違っています。</td></tr><tr><td scope="row">11</td><td><code class="literal">ERROR_BAD_FORMAT</code></td><td>間違ったフォーマットのプログラムを読み込もうとしました。</td></tr><tr><td scope="row">12</td><td><code class="literal">ERROR_INVALID_ACCESS</code></td><td>アクセス コードが無効です。</td></tr><tr><td scope="row">13</td><td><code class="literal">ERROR_INVALID_DATA</code></td><td>データが無効です。</td></tr><tr><td scope="row">14</td><td><code class="literal">ERROR_OUTOFMEMORY</code></td><td>この操作を完了するための十分な記憶域がありません。</td></tr><tr><td scope="row">15</td><td><code class="literal">ERROR_INVALID_DRIVE</code></td><td>指定されたドライブが見つかりません。</td></tr><tr><td scope="row">16</td><td><code class="literal">ERROR_CURRENT_DIRECTORY</code></td><td>ディレクトリを削除できません。</td></tr><tr><td scope="row">17</td><td><code class="literal">ERROR_NOT_SAME_DEVICE</code></td><td>ファイルを別のディスク ドライブに移動できません。</td></tr><tr><td scope="row">18</td><td><code class="literal">ERROR_NO_MORE_FILES</code></td><td>これ以上ファイルはありません。</td></tr><tr><td scope="row">19</td><td><code class="literal">ERROR_WRITE_PROTECT</code></td><td>このメディアは書き込み禁止になっています。</td></tr><tr><td scope="row">20</td><td><code class="literal">ERROR_BAD_UNIT</code></td><td>指定されたデバイスが見つかりません。</td></tr><tr><td scope="row">21</td><td><code class="literal">ERROR_NOT_READY</code></td><td>デバイスの準備ができていません。</td></tr><tr><td scope="row">22</td><td><code class="literal">ERROR_BAD_COMMAND</code></td><td>デバイスがコマンドを認識できません。</td></tr><tr><td scope="row">23</td><td><code class="literal">ERROR_CRC</code></td><td>データ エラー (巡回冗長検査 (CRC) エラー) です。</td></tr><tr><td scope="row">24</td><td><code class="literal">ERROR_BAD_LENGTH</code></td><td>プログラムはコマンドを発行しましたが、コマンドの長さが間違っています。</td></tr><tr><td scope="row">25</td><td><code class="literal">ERROR_SEEK</code></td><td>指定されたディスクの領域またはトラックが見つかりません。</td></tr><tr><td scope="row">26</td><td><code class="literal">ERROR_NOT_DOS_DISK</code></td><td>指定されたディスクまたはフロッピー ディスクにアクセスできません。</td></tr><tr><td scope="row">27</td><td><code class="literal">ERROR_SECTOR_NOT_FOUND</code></td><td>要求されたセクターが見つかりません。</td></tr><tr><td scope="row">28</td><td><code class="literal">ERROR_OUT_OF_PAPER</code></td><td>プリンターが用紙切れです。</td></tr><tr><td scope="row">29</td><td><code class="literal">ERROR_WRITE_FAULT</code></td><td>指定されたデバイスに書き込めません。</td></tr><tr><td scope="row">30</td><td><code class="literal">ERROR_READ_FAULT</code></td><td>指定されたデバイスから読み取れません。</td></tr><tr><td scope="row">31</td><td><code class="literal">ERROR_GEN_FAILURE</code></td><td>システムに接続されたデバイスが機能していません。</td></tr><tr><td scope="row">32</td><td><code class="literal">ERROR_SHARING_VIOLATION</code></td><td>プロセスはファイルにアクセスできません。別のプロセスが使用中です。</td></tr><tr><td scope="row">33</td><td><code class="literal">ERROR_LOCK_VIOLATION</code></td><td>プロセスはファイルにアクセスできません。別のプロセスがファイルの一部をロックしています。</td></tr><tr><td scope="row">34</td><td><code class="literal">ERROR_WRONG_DISK</code></td><td>間違ったフロッピー ディスクがドライブに挿入されています。%2 (ボリューム シリアル番号: %3) をドライブ %1 に挿入してください。</td></tr><tr><td scope="row">36</td><td><code class="literal">ERROR_SHARING_BUFFER_EXCEEDED</code></td><td>開かれている共有ファイルが多すぎます。</td></tr><tr><td scope="row">38</td><td><code class="literal">ERROR_HANDLE_EOF</code></td><td>ファイルの終わりに達しました。</td></tr><tr><td scope="row">39</td><td><code class="literal">ERROR_HANDLE_DISK_FULL</code></td><td>ディスクがいっぱいです。</td></tr><tr><td scope="row">87</td><td><code class="literal">ERROR_INVALID_PARAMETER</code></td><td>パラメーターが正しくありません。</td></tr><tr><td scope="row">112</td><td><code class="literal">ERROR_DISK_FULL</code></td><td>ディスクがいっぱいです。</td></tr><tr><td scope="row">123</td><td><code class="literal">ERROR_INVALID_NAME</code></td><td>ファイル名、ディレクトリ名、またはボリューム ラベルの構文が正しくありません。</td></tr><tr><td scope="row">1450</td><td><code class="literal">ERROR_NO_SYSTEM_RESOURCES</code></td><td>システム リソースが不足しているため、要求されたサービスを完了できません。</td></tr></tbody></table></div></li></ul></div></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-syntax.html">前</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="storage-engines.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第 13 章 SQL ステートメントの構文 </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 第 15 章 代替ストレージエンジン</td></tr></table></div><div class="copyright-footer"></div></body></html>
