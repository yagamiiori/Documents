<html lang="ja"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>MySQL 用語集</title><link rel="stylesheet" type="text/css" href="mvl.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="MySQL 5.6 リファレンスマニュアル"><link rel="up" href="index.html" title="MySQL 5.6 リファレンスマニュアル"><link rel="prev" href="restrictions.html" title="付録 D 制約と制限"><link rel="next" href="licenses-third-party.html" title="付録 E サードパーティーコンポーネントライセンス">
<script language="javascript" type="text/javascript">
  function addOnload(theFunc)
  {
    var previous = window.onload;
    if (typeof window.onload != 'function')
    {
      window.onload = theFunc;
    }
    else
    {
      window.onload = function()
      {
        previous();
        theFunc();
      }
    }
  }

  addOnload(function()
  {
    var base = new Date(1442918127*1000);
    var now = new Date();
    var diff = ((now-base)/1000)/(24*3600);

    if (diff > 90) {
      var nodes = document.getElementsByClassName('titlepage');
      nodes[0].innerHTML = '<p style="border: 5px #ff0000 solid; padding: 5px; margin 5px">' +
        'This copy of the manual is more than 90 days old. We encourage you to download a ' +
        'new version from <a href="http://dev.mysql.com">dev.mysql.com/doc</a>.</p>' + nodes[0].innerHTML;
    }
  });
</script>
<noscript></noscript>
</head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">MySQL 用語集</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="restrictions.html">前</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="licenses-third-party.html">次へ</a></td></tr></table><hr></div><div class="glossary"><div class="titlepage"><div><div><h1 class="title"><a name="glossary"></a>MySQL 用語集</h1></div></div></div><p>
    これらの用語は、MySQL データベースサーバーに関する情報で一般的に使用されます。この用語集は、InnoDB ストレージエンジンに関する用語のリファレンスとして作成され、大部分の定義は InnoDB 関連です。
  </p><div class="glossdiv"><h3 class="title">.</h3><dl><dt><a name="glos_arm_file"></a><span class="glossterm">.ARM ファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987849344"></a>
        ARCHIVE テーブルのメタデータ。<span class="bold"><strong>.ARZ ファイル</strong></span>と対比してください。この拡張子を持つファイルは常に、<span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品の <code class="literal">mysqlbackup</code> コマンドで生成されるバックアップに含められます。
      </p><p><a class="glossseealso" href="glossary.html#glos_arz_file">.ARZ ファイル</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_mysqlbackup_command">mysqlbackup コマンド</a>も参照</p></dd><dt><a name="glos_arz_file"></a><span class="glossterm">.ARZ ファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987842736"></a>
        ARCHIVE テーブルのデータ。<span class="bold"><strong>.ARM ファイル</strong></span>と対比してください。この拡張子を持つファイルは常に、<span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品の <code class="literal">mysqlbackup</code> コマンドで生成されるバックアップに含められます。
      </p><p><a class="glossseealso" href="glossary.html#glos_arm_file">.ARM ファイル</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_mysqlbackup_command">mysqlbackup コマンド</a>も参照</p></dd><dt><a name="glos_cfg_file"></a><span class="glossterm">.cfg ファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987836176"></a>
        <code class="literal">InnoDB</code> <span class="bold"><strong>トランスポータブルテーブルスペース</strong></span>機能で使用するメタデータファイル。これは、コマンド <code class="literal">FLUSH TABLES ... FOR EXPORT</code> で生成され、1 つまたは複数のテーブルを、別のサーバーにコピーできる一貫した状態にします。<code class="literal">.cfg</code> ファイルは、対応する <span class="bold"><strong>.ibd ファイル</strong></span>とともにコピーされ、<code class="literal">ALTER TABLE ... IMPORT TABLESPACE</code> ステップ中に <span class="bold"><strong>space ID</strong></span> などの <code class="literal">.ibd</code> ファイルの内部値を調整するために使用されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_ibd_file">.ibd ファイル</a>, <a class="glossseealso" href="glossary.html#glos_space_id">スペース ID</a>, <a class="glossseealso" href="glossary.html#glos_transportable_tablespace">トランスポータブルテーブルスペース</a>も参照</p></dd><dt><a name="glos_frm_file"></a><span class="glossterm">.frm ファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987825952"></a>
        MySQL テーブルのメタデータ (テーブル定義など) を含むファイル。
      </p><p>
        バックアップの場合、バックアップ後に変更または削除されたテーブルをリストアできるように、バックアップデータとともに <code class="literal">.frm</code> ファイルの完全セットを常に保持する必要があります。
      </p><p>
        それぞれの InnoDB テーブルには <code class="literal">.frm</code> ファイルがありますが、InnoDB は独自のテーブルメタデータをシステムテーブルスペースに保持しています。InnoDB が InnoDB テーブルを処理する場合、<code class="literal">.frm</code> ファイルは不要です。
      </p><p>
        これらのファイルは、<span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品によってバックアップされます。バックアップが行われている間にこれらのファイルを <code class="literal">ALTER TABLE</code> 操作で変更してはいけないため、InnoDB でないテーブルを含むバックアップは <code class="literal">.frm</code> ファイルのバックアップ中に、<code class="literal">FLUSH TABLES WITH READ LOCK</code> 操作を実行してこのようなアクティビティーをフリーズします。バックアップをリストアするときに、バックアップ時点のデータベースの状態に一致するように、<code class="literal">.frm</code> ファイルが作成、変更、または削除される場合があります。
      </p><p><a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>も参照</p></dd><dt><a name="glos_ibd_file"></a><span class="glossterm">.ibd ファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987813696"></a>
        <span class="bold"><strong>file-per-table</strong></span> モードを使用して作成された各 InnoDB <span class="bold"><strong>テーブル</strong></span>は、<span class="bold"><strong>データベース</strong></span>ディレクトリ内で、<code class="literal">.ibd</code> 拡張子の専用の<span class="bold"><strong>テーブルスペース</strong></span>ファイルに書き込まれます。このファイルにはテーブルデータと、テーブルの<span class="bold"><strong>インデックス</strong></span>が含まれます。<span class="bold"><strong>innodb_file_per_table</strong></span> オプションで制御される file-per-table モードは、InnoDB ストレージの使用法およびパフォーマンスの多くの側面に影響し、MySQL 5.6.7 以降でデフォルトで有効になっています。
      </p><p>
        この拡張子は、<span class="bold"><strong>ibdata ファイル</strong></span>から構成される<span class="bold"><strong>システムテーブルスペース</strong></span>には適用されません。
      </p><p>
        <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品によって <code class="literal">.ibd</code> ファイルが圧縮バックアップに含まれるとき、圧縮版は <code class="literal">.ibz</code> ファイルです。
      </p><p>
        MySQL 5.6 以降で <code class="literal">DATA DIRECTORY =</code> 句を使用してテーブルが作成された場合、<code class="literal">.ibd</code> ファイルは、通常のデータベースディレクトリの外部に置かれ、<span class="bold"><strong>.isl ファイル</strong></span>によってポイントされます。
      </p><p><a class="glossseealso" href="glossary.html#glos_database">データベース</a>, <a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_ibdata_file">ibdata ファイル</a>, <a class="glossseealso" href="glossary.html#glos_ibz_file">.ibz ファイル</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_innodb_file_per_table">innodb_file_per_table</a>, <a class="glossseealso" href="glossary.html#glos_isl_file">.isl ファイル</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>, <a class="glossseealso" href="glossary.html#glos_tablespace">テーブルスペース</a>も参照</p></dd><dt><a name="glos_ibz_file"></a><span class="glossterm">.ibz ファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987791856"></a>
        <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品が<span class="bold"><strong>圧縮バックアップ</strong></span>を実行するときに、これは、<span class="bold"><strong>file-per-table</strong></span> 設定を使用して作成される各<span class="bold"><strong>テーブルスペース</strong></span>ファイルを、<code class="literal">.ibd</code> 拡張子から <code class="literal">.ibz</code> 拡張子に変換します。
      </p><p>
        バックアップ中に適用される圧縮は、通常操作中にテーブルデータを圧縮されたままにする<span class="bold"><strong>圧縮行フォーマット</strong></span>とは異なります。圧縮バックアップ操作では、すでに圧縮行フォーマットであるテーブルスペースについては圧縮ステップをスキップします。2 回目の圧縮では、バックアップ速度を低下させるだけで、ほとんどまたはまったく領域を節約しないためです。
      </p><p><a class="glossseealso" href="glossary.html#glos_compressed_backup">圧縮バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_compressed_row_format">圧縮行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_ibd_file">.ibd ファイル</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_tablespace">テーブルスペース</a>も参照</p></dd><dt><a name="glos_isl_file"></a><span class="glossterm">.isl ファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987779824"></a>
        MySQL 5.6 以降の <code class="literal">DATA DIRECTORY =</code> 句で作成された InnoDB テーブルの、<span class="bold"><strong>.ibd ファイル</strong></span>の場所を指定するファイル。これは、実際のシンボリックリンクメカニズムのプラットフォーム制限なしで、シンボリックリンクのように機能します。<span class="bold"><strong>データベース</strong></span>ディレクトリ外部 (たとえば、テーブルの使用状況に応じて特別に大きなまたは高速なストレージデバイス) に InnoDB <span class="bold"><strong>テーブルスペース</strong></span>を格納できます。詳細は、<a class="xref" href="innodb-storage-engine.html#tablespace-placing" title="14.5.4 テーブルスペースの位置の指定">セクション14.5.4「テーブルスペースの位置の指定」</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_database">データベース</a>, <a class="glossseealso" href="glossary.html#glos_ibd_file">.ibd ファイル</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>, <a class="glossseealso" href="glossary.html#glos_tablespace">テーブルスペース</a>も参照</p></dd><dt><a name="glos_mrg_file"></a><span class="glossterm">.MRG ファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987771264"></a>
        <code class="literal">MERGE</code> ストレージエンジンで使用される、ほかのテーブルへの参照を含むファイル。この拡張子を持つファイルは常に、<span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品の <code class="literal">mysqlbackup</code> コマンドで生成されるバックアップに含められます。
      </p><p><a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_mysqlbackup_command">mysqlbackup コマンド</a>も参照</p></dd><dt><a name="glos_myd_file"></a><span class="glossterm">.MYD ファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987765184"></a>
        MyISAM テーブルのデータを格納するために MySQL が使用するファイル。
      </p><p><a class="glossseealso" href="glossary.html#glos_myi_file">.MYI ファイル</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_mysqlbackup_command">mysqlbackup コマンド</a>も参照</p></dd><dt><a name="glos_myi_file"></a><span class="glossterm">.MYI ファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987760880"></a>
        MyISAM テーブルのインデックスを格納するために MySQL が使用するファイル。
      </p><p><a class="glossseealso" href="glossary.html#glos_myd_file">.MYD ファイル</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_mysqlbackup_command">mysqlbackup コマンド</a>も参照</p></dd><dt><a name="glos_opt_file"></a><span class="glossterm">.OPT ファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987756560"></a>
        データベース構成情報を含むファイル。この拡張子を持つファイルは常に、<span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品の <code class="literal">mysqlbackup</code> コマンドで生成されるバックアップに含められます。
      </p><p><a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_mysqlbackup_command">mysqlbackup コマンド</a>も参照</p></dd><dt><a name="glos_par_file"></a><span class="glossterm">.PAR ファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987751248"></a>
        パーティション定義を含むファイル。この拡張子を持つファイルは常に、<span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品の <code class="literal">mysqlbackup</code> コマンドで生成されるバックアップに含められます。
      </p><p><a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_mysqlbackup_command">mysqlbackup コマンド</a>も参照</p></dd><dt><a name="glos_trg_file"></a><span class="glossterm">.TRG ファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987746000"></a>
        <span class="bold"><strong>トリガー</strong></span>パラメータを含むファイル。この拡張子を持つファイルは常に、<span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品の <code class="literal">mysqlbackup</code> コマンドで生成されるバックアップに含められます。
      </p><p><a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_mysqlbackup_command">mysqlbackup コマンド</a>, <a class="glossseealso" href="glossary.html#glos_trn_file">.TRN ファイル</a>も参照</p></dd><dt><a name="glos_trn_file"></a><span class="glossterm">.TRN ファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987739616"></a>
        トリガー名前空間情報を含むファイル。この拡張子を持つファイルは常に、<span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品の <code class="literal">mysqlbackup</code> コマンドで生成されるバックアップに含められます。
      </p><p><a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_mysqlbackup_command">mysqlbackup コマンド</a>, <a class="glossseealso" href="glossary.html#glos_trg_file">.TRG ファイル</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">2</h3><dl><dt><a name="glos_two_phase_commit"></a><span class="glossterm">2 フェーズコミット</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987733200"></a>
        <span class="bold"><strong>XA</strong></span> 仕様に基づく分散型<span class="bold"><strong>トランザクション</strong></span>の一部である操作。(2PC と略記されることがあります。)複数のデータベースがトランザクションに参加する場合、すべてのデータベースが変更を<span class="bold"><strong>コミット</strong></span>するか、すべてのデータベースが変更を<span class="bold"><strong>ロールバック</strong></span>します。
      </p><p><a class="glossseealso" href="glossary.html#glos_commit">コミット</a>, <a class="glossseealso" href="glossary.html#glos_rollback">ロールバック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>, <a class="glossseealso" href="glossary.html#glos_xa">XA</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">A</h3><dl><dt><a name="glos_acid"></a><span class="glossterm">ACID</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987725248"></a>
        原子性 (atomicity)、一貫性 (consistency)、分離性 (isolation)、持続性 (durability) を表す頭字語。これらの特性はすべてデータベースシステムで望ましく、すべて<span class="bold"><strong>トランザクション</strong></span>の概念に密接に結び付けられています。InnoDB のトランザクション機能は、ACID の原則に準拠しています。
      </p><p>
        トランザクションは、<span class="bold"><strong>コミット</strong></span>または<span class="bold"><strong>ロールバック</strong></span>できる<span class="bold"><strong>原子的</strong></span>な作業単位です。トランザクションによってデータベースに複数の変更が行われた場合、トランザクションがコミットされるとすべての変更が完了し、トランザクションがロールバックされるとすべての変更が元に戻されます。
      </p><p>
        データベースは、それぞれのコミットまたはロールバックのあとでも、トランザクションの進行中でも、常に一貫した状態を保ちます。関連データが複数のテーブルにわたって更新されている場合、クエリーは、古い値と新しい値の混合ではなく、すべて古い値か、すべて新しい値のどちらかを見ます。
      </p><p>
        トランザクションは進行中、互いから保護 (分離) されます。それらは互いに干渉できず、互いのコミットされていないデータを見ることはできません。この分離性は、<span class="bold"><strong>ロック</strong></span>メカニズムを通じて実現します。経験豊富なユーザーは、実際にトランザクションが互いに干渉しないと確信できれば、パフォーマンスと<span class="bold"><strong>並列性</strong></span>の向上の代わりに保護の低下をトレードオフするように<span class="bold"><strong>分離レベル</strong></span>を調整できます。
      </p><p>
        トランザクションの結果は持続的です。コミット操作が成功すると、そのトランザクションによって行われた変更は、データベース以外の多くのアプリケーションが脆弱である停電、システムのクラッシュ、競合状況、またはほかの潜在的な危険から保護されます。持続性には通常、ディスクストレージへの書き込みがかかわっており、書き込み操作中の停電またはソフトウェアクラッシュに対して保護するために一定の冗長性を備えています。(InnoDB では、<span class="bold"><strong>二重書き込みバッファー</strong></span>が持続性をサポートします。)
      </p><p><a class="glossseealso" href="glossary.html#glos_atomic">原子的</a>, <a class="glossseealso" href="glossary.html#glos_commit">コミット</a>, <a class="glossseealso" href="glossary.html#glos_concurrency">並列性</a>, <a class="glossseealso" href="glossary.html#glos_doublewrite_buffer">二重書き込みバッファー</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_rollback">ロールバック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_ahi"></a><span class="glossterm">AHI</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987707760"></a>
        <span class="bold"><strong>適応型ハッシュインデックス (Adaptive Hash Index)</strong></span> の頭字語。
      </p><p><a class="glossseealso" href="glossary.html#glos_adaptive_hash_index">適応型ハッシュインデックス</a>も参照</p></dd><dt><a name="glos_aio"></a><span class="glossterm">AIO</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987704400"></a>
        <span class="bold"><strong>非同期 I/O (Asynchronous I/O)</strong></span> の頭字語。この頭字語は InnoDB メッセージやキーワードで見られます。
      </p><p><a class="glossseealso" href="glossary.html#glos_asynchronous_io">非同期 I/O</a>も参照</p></dd><dt><a name="glos_antelope"></a><span class="glossterm">Antelope</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987700976"></a>
        元の InnoDB <span class="bold"><strong>ファイル形式</strong></span>のコード名。これは、<span class="bold"><strong>冗長</strong></span>および<span class="bold"><strong>簡易</strong></span>行フォーマットをサポートしますが、<span class="bold"><strong>Barracuda</strong></span> ファイル形式で利用できるより新しい<span class="bold"><strong>動的</strong></span>および<span class="bold"><strong>圧縮</strong></span>行フォーマットはサポートしません。
      </p><p>
        アプリケーションが、InnoDB テーブル<span class="bold"><strong>圧縮</strong></span>からメリットを受けられるか、動的行フォーマットからメリットを受けられる BLOB またはラージテキストカラムを使用する場合、一部のテーブルを Barracuda 形式に切り替えることができます。テーブルの作成前に <code class="literal">innodb_file_format</code> オプションを設定することによって、使用するファイル形式を選択します。
      </p><p><a class="glossseealso" href="glossary.html#glos_barracuda">Barracuda</a>, <a class="glossseealso" href="glossary.html#glos_compact_row_format">コンパクト行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_compressed_row_format">圧縮行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_dynamic_row_format">動的行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_file_format">ファイル形式</a>, <a class="glossseealso" href="glossary.html#glos_innodb_file_format">innodb_file_format</a>, <a class="glossseealso" href="glossary.html#glos_redundant_row_format">冗長行フォーマット</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">B</h3><dl><dt><a name="glos_b_tree"></a><span class="glossterm">B ツリー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987668560"></a>
        データベースインデックスに一般的に使用されるツリーデータ構造。この構造は、常にソートされ続け、正確な一致 (等号演算子) および範囲 (大なり、小なり、<code class="literal">BETWEEN</code> 演算子など) の高速ルックアップを可能にします。このタイプのインデックスは、InnoDB や MyISAM などのほとんどのストレージエンジンで利用できます。
      </p><p>
        B ツリーノードには多くの子を含むことができるので、B ツリーは、ノードごとに 2 つの子に限られているバイナリツリーと同じではありません。
      </p><p>
        <span class="bold"><strong>ハッシュインデックス</strong></span>と対比してください。こちらは MEMORY ストレージエンジンでのみ使用できます。MEMORY ストレージエンジンは、B ツリーインデックスも使用でき、一部のクエリーで範囲演算子を使用する場合は、MEMORY テーブルには B ツリーインデックスを選択してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_hash_index">ハッシュインデックス</a>も参照</p></dd><dt><a name="glos_barracuda"></a><span class="glossterm">Barracuda</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987687392"></a>
        テーブルデータの圧縮をサポートする InnoDB <span class="bold"><strong>ファイル形式</strong></span>のコード名。このファイル形式は、最初に InnoDB Plugin に導入されました。これは、InnoDB テーブル圧縮に対応した<span class="bold"><strong>圧縮</strong></span>行フォーマットと、BLOB およびラージテキストカラムのストレージレイアウトを改善する<span class="bold"><strong>動的</strong></span>行フォーマットをサポートします。これは <code class="literal">innodb_file_format</code> オプションで選択できます。
      </p><p>
        InnoDB <span class="bold"><strong>システムテーブルスペース</strong></span>は元の <span class="bold"><strong>Antelope</strong></span> ファイル形式で格納されるため、Barracuda ファイル形式を使用するには、システムテーブルスペースとは別の独自のテーブルスペースに新しく作成したテーブルを格納する <span class="bold"><strong>file-per-table</strong></span> 設定も有効にする必要があります。
      </p><p>
        <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品バージョン 3.5 以降では、Barracuda ファイル形式を使用するテーブルスペースのバックアップをサポートします。
      </p><p><a class="glossseealso" href="glossary.html#glos_antelope">Antelope</a>, <a class="glossseealso" href="glossary.html#glos_compact_row_format">コンパクト行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_compressed_row_format">圧縮行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_dynamic_row_format">動的行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_file_format">ファイル形式</a>, <a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_innodb_file_format">innodb_file_format</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_row_format">行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>も参照</p></dd><dt><a name="glos_binlog"></a><span class="glossterm">binlog</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987671936"></a>
        <span class="bold"><strong>バイナリログ</strong></span>ファイルの非公式名。たとえば、電子メールメッセージやフォーラムディスカッションでこの略語を見ることがあります。
      </p><p><a class="glossseealso" href="glossary.html#glos_binary_log">バイナリログ</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">C</h3><dl><dt><a name="glos_cpu_bound"></a><span class="glossterm">CPU バウンド</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987661008"></a>
        <span class="bold"><strong>ワークロード</strong></span>の種類の 1つ。主な<span class="bold"><strong>ボトルネック</strong></span>がメモリー内の CPU 操作であるもの。通常、<span class="bold"><strong>バッファープール</strong></span>内にすべての結果をキャッシュできる、読み取り中心の操作を含みます。
      </p><p><a class="glossseealso" href="glossary.html#glos_bottleneck">ボトルネック</a>, <a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_cpu_bound">CPU バウンド</a>, <a class="glossseealso" href="glossary.html#glos_workload">ワークロード</a>も参照</p></dd><dt><a name="glos_crud"></a><span class="glossterm">CRUD</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987654336"></a>
        データベースアプリケーションの一般的な操作シーケンスである「作成 (create)、読み取り (read)、更新 (update)、削除 (delete)」の頭字語。多くの場合、どの言語でもすばやく実装でき、比較的単純にデータベースを使用するタイプのアプリケーション (基本的な <span class="bold"><strong>DDL</strong></span>、<span class="bold"><strong>DML</strong></span>、および <span class="bold"><strong>SQL</strong></span> の<span class="bold"><strong>クエリー</strong></span>ステートメント) を示します。
      </p><p><a class="glossseealso" href="glossary.html#glos_ddl">DDL</a>, <a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_query">クエリー</a>, <a class="glossseealso" href="glossary.html#glos_sql">SQL</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">D</h3><dl><dt><a name="glos_dcl"></a><span class="glossterm">DCL</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987646336"></a>
        データ制御言語 (Data Control Language)。権限を管理するための <span class="bold"><strong>SQL</strong></span> ステートメントのセット。MySQL では、<code class="literal">GRANT</code> および <code class="literal">REVOKE</code> ステートメントから構成されます。<span class="bold"><strong>DDL</strong></span> および <span class="bold"><strong>DML</strong></span> と対比してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_ddl">DDL</a>, <a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_sql">SQL</a>も参照</p></dd><dt><a name="glos_ddl"></a><span class="glossterm">DDL</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987638400"></a>
        データ定義言語 (Data Definition Language)。個々のテーブル行ではなくデータベース自体を操作するための <span class="bold"><strong>SQL</strong></span> ステートメントのセット。<code class="literal">CREATE</code>、<code class="literal">ALTER</code>、および <code class="literal">DROP</code> ステートメントのすべての形式を含みます。<code class="literal">TRUNCATE</code> ステートメントも含まれます。<code class="literal">DELETE FROM <em class="replaceable"><code>table_name</code></em></code> ステートメントと動作が異なるためです (最終的な効果は似ていますが) 。
      </p><p>
        DDL ステートメントは自動的に現在の<span class="bold"><strong>トランザクション</strong></span>を<span class="bold"><strong>コミット</strong></span>します。それらを<span class="bold"><strong>ロールバック</strong></span>することはできません。
      </p><p>
        InnoDB の<a class="link" href="glossary.html#glos_online_ddl" title="オンライン DDL">オンライン DDL</a> 機能は、<code class="literal">CREATE INDEX</code>、<code class="literal">DROP INDEX</code>、および多くのタイプの <code class="literal">ALTER TABLE</code> 操作のパフォーマンスを向上させます。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-online-ddl" title="14.11 InnoDB とオンライン DDL">セクション14.11「InnoDB とオンライン DDL」</a>を参照してください。InnoDB の <a class="link" href="glossary.html#glos_file_per_table" title="file-per-table">file-per-table</a> 設定も、<code class="literal">DROP TABLE</code> および <code class="literal">TRUNCATE TABLE</code> 操作の動作に影響を与える場合があります。
      </p><p>
        <span class="bold"><strong>DML</strong></span> および <span class="bold"><strong>DCL</strong></span> と対比してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_commit">コミット</a>, <a class="glossseealso" href="glossary.html#glos_dcl">DCL</a>, <a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_rollback">ロールバック</a>, <a class="glossseealso" href="glossary.html#glos_sql">SQL</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_dml"></a><span class="glossterm">DML</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987614960"></a>
        データ操作言語 (Data Manipulation Language)。挿入、更新、および削除操作を実行するための <span class="bold"><strong>SQL</strong></span> ステートメントのセット。<code class="literal">SELECT</code> ステートメントが DML ステートメントと見なされる場合があります。<code class="literal">SELECT ... FOR UPDATE</code> 形式が、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、および <code class="literal">DELETE</code> と同じ、<span class="bold"><strong>ロック</strong></span>に関する考慮事項に従うためです。
      </p><p>
        InnoDB テーブルの DML ステートメントは<span class="bold"><strong>トランザクション</strong></span>のコンテキストで動作するため、その効果は単一の単位として<span class="bold"><strong>コミット</strong></span>または<span class="bold"><strong>ロールバック</strong></span>できます。
      </p><p>
        <span class="bold"><strong>DDL</strong></span> および <span class="bold"><strong>DCL</strong></span> と対比してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_commit">コミット</a>, <a class="glossseealso" href="glossary.html#glos_dcl">DCL</a>, <a class="glossseealso" href="glossary.html#glos_ddl">DDL</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_rollback">ロールバック</a>, <a class="glossseealso" href="glossary.html#glos_sql">SQL</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">F</h3><dl><dt><a name="glos_file_per_table"></a><span class="glossterm">file-per-table</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987597680"></a>
        <code class="literal">innodb_file_per_table</code> オプションで制御される設定に対する一般名。これは、InnoDB ファイルストレージの多くの側面、機能の利用可能性、および I/O 特性に影響する、非常に重要な構成オプションです。MySQL 5.6.7 以降ではデフォルトで有効になっています。MySQL 5.6.7 より前では、デフォルトで無効になっています。
      </p><p>
        この設定が有効である間に作成されたテーブルごとに、データは、<span class="bold"><strong>システムテーブルスペース</strong></span>の <span class="bold"><strong>ibdata ファイル</strong></span>ではなく、個別の <span class="bold"><strong>.ibd ファイル</strong></span>に格納されます。テーブルデータが個々のファイルに格納されている場合、データ<span class="bold"><strong>圧縮</strong></span>などの機能に必要な、デフォルト以外の<span class="bold"><strong>ファイル形式</strong></span>と<span class="bold"><strong>行フォーマット</strong></span>を選択できる柔軟性が得られます。<code class="literal">TRUNCATE TABLE</code> 操作も高速化され、解放された領域は、InnoDB に予約されたままではなく、オペレーティングシステムで使用できます。
      </p><p>
        <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品は、テーブルがその独自のファイルに格納されるので柔軟性が高くなります。たとえば、テーブルをバックアップから排除できますが、これは個別のファイルに格納されている場合に限られます。したがって、この設定は、あまり頻繁にはバックアップされない、または異なるスケジュールでバックアップされるテーブルに適しています。
      </p><p><a class="glossseealso" href="glossary.html#glos_compressed_row_format">圧縮行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_compression">圧縮</a>, <a class="glossseealso" href="glossary.html#glos_file_format">ファイル形式</a>, <a class="glossseealso" href="glossary.html#glos_ibd_file">.ibd ファイル</a>, <a class="glossseealso" href="glossary.html#glos_ibdata_file">ibdata ファイル</a>, <a class="glossseealso" href="glossary.html#glos_innodb_file_per_table">innodb_file_per_table</a>, <a class="glossseealso" href="glossary.html#glos_row_format">行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>も参照</p></dd><dt><a name="glos_foreign_key_constraint"></a><span class="glossterm">FOREIGN KEY 制約</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987581728"></a>
        <span class="bold"><strong>外部キー</strong></span>関係を通じてデータベース一貫性を維持するタイプの<span class="bold"><strong>制約</strong></span>。ほかの種類の制約と同様に、データが一貫性を失った場合にデータが挿入または更新されるのを防止できます。ここでは、複数のテーブル内のデータ間の一貫性が失われることが防止されます。または、<span class="bold"><strong>DML</strong></span> 操作が実行されるときに <code class="literal">FOREIGN KEY</code> 制約によって、外部キー作成時に指定された <code class="literal">ON CASCADE</code> オプションに基づいて、<span class="bold"><strong>子行</strong></span>内のデータが削除されたり、別の値に変更されたり、<span class="bold"><strong>NULL</strong></span> に設定されたりします。
      </p><p><a class="glossseealso" href="glossary.html#glos_child_table">子テーブル</a>, <a class="glossseealso" href="glossary.html#glos_constraint">制約</a>, <a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_foreign_key">外部キー</a>, <a class="glossseealso" href="glossary.html#glos_null">NULL</a>も参照</p></dd><dt><a name="glos_fts"></a><span class="glossterm">FTS</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987570816"></a>
        ほとんどのコンテキストで、<span class="bold"><strong>全文検索 (Full-Text Search)</strong></span> の頭字語。パフォーマンスディスカッションでは、<span class="bold"><strong>フルテーブルスキャン (Full Table Scan)</strong></span> の頭字語の場合があります。
      </p><p><a class="glossseealso" href="glossary.html#glos_full_table_scan">テーブルの完全スキャン</a>, <a class="glossseealso" href="glossary.html#glos_full_text_search">全文検索</a>も参照</p></dd><dt><a name="glos_fulltext_index"></a><span class="glossterm">FULLTEXT インデックス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987565840"></a>
        MySQL <span class="bold"><strong>全文検索</strong></span>メカニズムでの<span class="bold"><strong>検索インデックス</strong></span>を保持する、特殊な<span class="bold"><strong>インデックス</strong></span>。<span class="bold"><strong>ストップワード</strong></span>として指定されたものを飛ばして、カラムの値からの単語を表します。もともとは、利用できるのは <code class="literal">MyISAM</code> テーブルだけでした。MySQL 5.6.4 以降では、<span class="bold"><strong>InnoDB</strong></span> テーブルでも利用できます。
      </p><p><a class="glossseealso" href="glossary.html#glos_full_text_search">全文検索</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>, <a class="glossseealso" href="glossary.html#glos_search_index">検索インデックス</a>, <a class="glossseealso" href="glossary.html#glos_stopword">ストップワード</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">G</h3><dl><dt><a name="glos_ga"></a><span class="glossterm">GA</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987555648"></a>
        「一般提供 (Generally Available)」。ソフトウェア製品がベータを終え、販売、公式サポート、および本番使用に利用できるようになった段階。
      </p><p><a class="glossseealso" href="glossary.html#glos_beta">ベータ</a>, <a class="glossseealso" href="glossary.html#glos_early_adopter">アーリーアダプタ</a>も参照</p></dd><dt><a name="glos_global_transaction"></a><span class="glossterm">global_transaction</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987551952"></a>
        <span class="bold"><strong>XA</strong></span> 操作に含まれるタイプの<span class="bold"><strong>トランザクション</strong></span>。これは、それ自体はトランザクションであるけれども、すべてがグループとして正しく完了する必要があるか、グループとしてロールバックされる必要がある、いくつかのアクションから構成されます。基本的に、これは <span class="bold"><strong>ACID</strong></span> 特性を 1 レベル上に拡張することにより、複数の ACID トランザクションを、同じく ACID 特性を持つグローバル操作のコンポーネントとして連携して実行できるようにします。この種の分散トランザクションの場合、<span class="bold"><strong>SERIALIZABLE</strong></span> 分離レベルを使用して ACID 特性を実現する必要があります。
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_serializable">SERIALIZABLE</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>, <a class="glossseealso" href="glossary.html#glos_xa">XA</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">H</h3><dl><dt><a name="glos_hdd"></a><span class="glossterm">HDD</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987542688"></a>
        「ハードディスクドライブ (Hard Disk Drive)」の頭字語。<span class="bold"><strong>SSD</strong></span> と対比されることが多く、スピニングプラッターを使用するストレージメディアを指します。そのパフォーマンス特性は<span class="bold"><strong>ディスクベース</strong></span>ワークロードのスループットに影響を与えることがあります。
      </p><p><a class="glossseealso" href="glossary.html#glos_disk_based">ディスクベース</a>, <a class="glossseealso" href="glossary.html#glos_ssd">SSD</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">I</h3><dl><dt><a name="glos_io_bound"></a><span class="glossterm">I/O バウンド</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_disk_bound">ディスクバウンド</a>も参照</p></dd><dt><a name="glos_ib_file_set"></a><span class="glossterm">ib-file セット</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987535616"></a>
        MySQL データベース内で InnoDB によって管理されるファイルのセット (<span class="bold"><strong>システムテーブルスペース</strong></span>、<span class="bold"><strong>file-per-table</strong></span> テーブルスペース、(通常は 2 つの) <span class="bold"><strong>Redo ログ</strong></span>ファイル)。InnoDB ファイル構造および形式の詳細なディスカッションで、さまざまな DBMS 製品間での<span class="bold"><strong>データベース</strong></span>の意味と、MySQL データベースに含まれている可能性がある非 InnoDB ファイルとの間のあいまいさを避けるために使用されることがあります。
      </p><p><a class="glossseealso" href="glossary.html#glos_database">データベース</a>, <a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_redo_log">Redo ログ</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>も参照</p></dd><dt><a name="glos_ibbackup_logfile"></a><span class="glossterm">ibbackup_logfile</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987518784"></a>
        <span class="bold"><strong>ホットバックアップ</strong></span>操作中に <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品により作成される補助的なバックアップファイル。ここには、バックアップの実行中に行われたデータ変更に関する情報が含まれます。<code class="literal">ibbackup_logfile</code> などの初期バックアップファイルは、バックアップ操作中に行われた変更がまだ組み込まれていないので、<span class="bold"><strong>raw バックアップ</strong></span>と呼ばれます。raw バックアップファイルへの<span class="bold"><strong>適用</strong></span>ステップを実行したあと、結果として得られるファイルは、最終データ変更を含んでおり、<span class="bold"><strong>準備されたバックアップ</strong></span>と呼ばれます。この段階で、<code class="literal">ibbackup_logfile</code> ファイルは必要なくなります。
      </p><p><a class="glossseealso" href="glossary.html#glos_apply">適用</a>, <a class="glossseealso" href="glossary.html#glos_hot_backup">ホットバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_prepared_backup">準備されたバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_raw_backup">raw バックアップ</a>も参照</p></dd><dt><a name="glos_ibdata_file"></a><span class="glossterm">ibdata ファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987507488"></a>
        InnoDB <span class="bold"><strong>システムテーブルスペース</strong></span>を構成する、<code class="literal">ibdata1</code> や <code class="literal">ibdata2</code> などの名前を持つファイルのセット。これらのファイルには、InnoDB テーブルに関するメタデータ (<span class="bold"><strong>データディクショナリ</strong></span>) と、<span class="bold"><strong>Undo ログ</strong></span>、<span class="bold"><strong>変更バッファー</strong></span>、<span class="bold"><strong>二重書き込みバッファー</strong></span>のストレージ領域が含まれます。(各テーブルの作成時に <span class="bold"><strong>file-per-table</strong></span> モードが有効であるかどうかによって) テーブルデータの一部またはすべてを含めることもできます。<span class="bold"><strong>innodb_file_per_table</strong></span> オプションが有効であるときに、新しく作成されたテーブルのデータおよびインデックスは、システムテーブルスペースではなく個別の <span class="bold"><strong>.ibd ファイル</strong></span>に格納されます。
      </p><p>
        <code class="literal">ibdata</code> ファイルが増大するときは、<code class="literal">innodb_autoextend_increment</code> 構成オプションの影響を受けます。
      </p><p><a class="glossseealso" href="glossary.html#glos_change_buffer">変更バッファー</a>, <a class="glossseealso" href="glossary.html#glos_data_dictionary">データディクショナリ</a>, <a class="glossseealso" href="glossary.html#glos_doublewrite_buffer">二重書き込みバッファー</a>, <a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_ibd_file">.ibd ファイル</a>, <a class="glossseealso" href="glossary.html#glos_innodb_file_per_table">innodb_file_per_table</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_undo_log">Undo ログ</a>も参照</p></dd><dt><a name="glos_ibtmp_file"></a><span class="glossterm">ibtmp ファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987490512"></a>
        非圧縮 <code class="literal">InnoDB</code> 一時テーブルと関連オブジェクト用の InnoDB 一時テーブルスペースデータファイル。構成ファイルオプション <code class="literal">innodb_temp_data_file_path</code> は、ユーザーが一時データファイルの相対パスを定義することを許可します。<code class="literal">innodb_temp_data_file_path</code> が指定されない場合のデフォルト動作は、データディレクトリ内に <code class="filename">ibdata1</code> と一緒に、<code class="filename">ibtmp1</code> という名前の単一自動拡張 12M バイトデータファイルを作成することです。
      </p><p><a class="glossseealso" href="glossary.html#glos_temporary_tablespace">一時テーブルスペース</a>も参照</p></dd><dt><a name="glos_ib_logfile"></a><span class="glossterm">ib_logfile</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987527728"></a>
        通常は <code class="literal">ib_logfile0</code> および <code class="literal">ib_logfile1</code> という名前が付けられ、<span class="bold"><strong>Redo ログ</strong></span>を形成するファイルのセット。<span class="bold"><strong>ロググループ</strong></span>と呼ばれることもあります。これらのファイルは、InnoDB テーブル内のデータを変更しようとするステートメントを記録します。これらのステートメントは、クラッシュ後の起動時に、未完了のトランザクションで書き込まれたデータを修正するために自動的に再現されます。
      </p><p>
        このデータは手動リカバリには使用できません。このタイプの操作には、<span class="bold"><strong>バイナリログ</strong></span>を使用してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_binary_log">バイナリログ</a>, <a class="glossseealso" href="glossary.html#glos_log_group">ロググループ</a>, <a class="glossseealso" href="glossary.html#glos_redo_log">Redo ログ</a>も参照</p></dd><dt><a name="glos_ilist"></a><span class="glossterm">ilist</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987482464"></a>
        InnoDB <span class="bold"><strong>FULLTEXT インデックス</strong></span>内で、ドキュメント ID とトークン (つまり特定の語) の位置情報から構成されるデータ構造。
      </p><p><a class="glossseealso" href="glossary.html#glos_fulltext_index">FULLTEXT インデックス</a>も参照</p></dd><dt><a name="glos_information_schema"></a><span class="glossterm">INFORMATION_SCHEMA</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987478944"></a>
        MySQL <span class="bold"><strong>データディクショナリ</strong></span>へのクエリーインタフェースを提供する<span class="bold"><strong>データベース</strong></span>の名前。(この名前は ANSI SQL 標準で定義されています。)データベースに関する情報 (メタデータ) を調べるには、構造化されていない出力を返す <code class="literal">SHOW</code> コマンドを使用する代わりに、<code class="literal">INFORMATION_SCHEMA.TABLES</code> や <code class="literal">INFORMATION_SCHEMA.COLUMNS</code> などのテーブルを照会できます。
      </p><p>
        情報スキーマには、<code class="literal">INNODB_LOCKS</code> や <code class="literal">INNODB_TRX</code> など、<span class="bold"><strong>InnoDB</strong></span> に固有のいくつかのテーブルが含まれます。これらのテーブルは、データベースがどのように構造化されているかを確認するためではなく、InnoDB テーブルの動作に関するリアルタイム情報を得るために使用してください (パフォーマンスモニタリング、チューニング、トラブルシューティングに役立ちます)。これらのテーブルは特に、<span class="bold"><strong>圧縮</strong></span>、<span class="bold"><strong>トランザクション</strong></span>、およびそれらに関連付けられた<span class="bold"><strong>ロック</strong></span>に関連する MySQL 機能についての情報を提供します。
      </p><p><a class="glossseealso" href="glossary.html#glos_compression">圧縮</a>, <a class="glossseealso" href="glossary.html#glos_data_dictionary">データディクショナリ</a>, <a class="glossseealso" href="glossary.html#glos_database">データベース</a>, <a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_innodb"></a><span class="glossterm">InnoDB</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987463472"></a>
        高いパフォーマンスと、信頼性、堅牢性、および同時アクセスのための<span class="bold"><strong>トランザクション</strong></span>機能とを結合する MySQL コンポーネント。これは <span class="bold"><strong>ACID</strong></span> 設計概念を具体化したものです。<span class="bold"><strong>ストレージエンジン</strong></span>として表現され、<code class="literal">ENGINE=INNODB</code> 句で作成または変更されたテーブルを処理します。アーキテクチャーの詳細および管理手順については<a class="xref" href="innodb-storage-engine.html" title="第 14 章 InnoDB ストレージエンジン">第14章「<i>InnoDB ストレージエンジン</i>」</a>、パフォーマンスのアドバイスについては<a class="xref" href="optimization.html#optimizing-innodb" title="8.5 InnoDB テーブルの最適化">セクション8.5「InnoDB テーブルの最適化」</a>を参照してください。
      </p><p>
        MySQL 5.5 以降では、InnoDB が新しいテーブルのデフォルトストレージエンジンなので、<code class="literal">ENGINE=INNODB</code> 句は必要ありません。MySQL 5.1 でのみ、高度な InnoDB 機能の多くで InnoDB Plugin と呼ばれるコンポーネントを有効にする必要があります。InnoDB テーブルがデフォルトである最近のリリースへの移行に関する考慮事項については、<a class="xref" href="innodb-storage-engine.html#innodb-default-se" title="14.1.1 デフォルトの MySQL ストレージエンジンとしての InnoDB">セクション14.1.1「デフォルトの MySQL ストレージエンジンとしての InnoDB」</a>を参照してください。
      </p><p>
        InnoDB テーブルは理論的には、<span class="bold"><strong>ホットバックアップ</strong></span>に適しています。通常の処理を妨げることなく MySQL Server をバックアップできる <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品の詳細は、<a class="xref" href="mysql-enterprise.html#mysql-enterprise-backup" title="25.2 MySQL Enterprise Backup">セクション25.2「MySQL Enterprise Backup」</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_hot_backup">ホットバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_storage_engine">ストレージエンジン</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_innodb_autoinc_lock_mode"></a><span class="glossterm">innodb_autoinc_lock_mode</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987448960"></a>
        <code class="literal">innodb_autoinc_lock_mode</code> オプションは、<span class="bold"><strong>自動インクリメントロック</strong></span>に使用されるアルゴリズムを制御します。自動インクリメントする<span class="bold"><strong>主キー</strong></span>がある場合は、<code class="literal">innodb_autoinc_lock_mode=1</code> 設定でのみステートメントベースレプリケーションを使用できます。この設定は、トランザクション内の複数行挿入が連続自動インクリメント値を受け取るため、<span class="bold"><strong>連続</strong></span>ロックモードと呼ばれます。<code class="literal">innodb_autoinc_lock_mode=2</code> の場合は (挿入操作で並列性が向上)、ステートメントベースレプリケーションではなく行ベースレプリケーションを使用してください。この設定は、同時に実行される複数の複数行挿入ステートメントが自動インクリメント値を交互に受け取ることができるため、<span class="bold"><strong>インターリーブ</strong></span>ロックモードと呼ばれます。<code class="literal">innodb_autoinc_lock_mode=0</code> の設定は、以前 (従来) のデフォルト設定であり、互換性の目的以外では使用しないでください。
      </p><p><a class="glossseealso" href="glossary.html#glos_auto_increment_locking">自動インクリメントロック</a>, <a class="glossseealso" href="glossary.html#glos_mixed_mode_insert">混在モード挿入</a>, <a class="glossseealso" href="glossary.html#glos_primary_key">主キー</a>も参照</p></dd><dt><a name="glos_innodb_file_format"></a><span class="glossterm">innodb_file_format</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987437040"></a>
        <code class="literal">innodb_file_format</code> オプションは、このオプションの値を指定したあとに作成されるすべての InnoDB <span class="bold"><strong>テーブルスペース</strong></span>の<span class="bold"><strong>ファイル形式</strong></span>を決定します。<span class="bold"><strong>システムテーブルスペース</strong></span>以外のテーブルスペースを作成するには、<span class="bold"><strong>file-per-table</strong></span> オプションも使用する必要があります。現在のところ、<span class="bold"><strong>Antelope</strong></span> および <span class="bold"><strong>Barracuda</strong></span> ファイル形式を指定できます。
      </p><p><a class="glossseealso" href="glossary.html#glos_antelope">Antelope</a>, <a class="glossseealso" href="glossary.html#glos_barracuda">Barracuda</a>, <a class="glossseealso" href="glossary.html#glos_file_format">ファイル形式</a>, <a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_innodb_file_per_table">innodb_file_per_table</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_tablespace">テーブルスペース</a>も参照</p></dd><dt><a name="glos_innodb_file_per_table"></a><span class="glossterm">innodb_file_per_table</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987425200"></a>
        InnoDB ファイルストレージ、機能の利用可能性、および I/O 特性の多くの側面に影響する、非常に重要な構成オプション。MySQL 5.6.7 以降ではデフォルトで有効になっています。MySQL 5.6.7 より前では、デフォルトで無効になっています。<code class="literal">innodb_file_per_table</code> オプションは <span class="bold"><strong>file-per-table</strong></span> モードをオンにし、新しく作成された InnoDB テーブルおよびそれに関連付けられたインデックスを<span class="bold"><strong>システムテーブルスペース</strong></span>外部のそれぞれ独自の <span class="bold"><strong>.ibd ファイル</strong></span>に格納します。
      </p><p>
        このオプションは、<code class="literal">DROP TABLE</code> や <code class="literal">TRUNCATE TABLE</code> など、いくつかの SQL ステートメントのパフォーマンスおよびストレージに関する考慮事項に影響します。
      </p><p>
        このオプションは、テーブル<span class="bold"><strong>圧縮</strong></span>などの多くのほかの InnoDB 機能や、<span class="bold"><strong>MySQL Enterprise Backup</strong></span> での特定のテーブルのバックアップを十分に活用するために必要です。
      </p><p>
        このオプションは以前は静的でしたが、<code class="literal">SET GLOBAL</code> コマンドを使用して設定できるようになりました。
      </p><p>
        参照情報については、<code class="literal">innodb_file_per_table</code> を参照してください。使用法情報については、<a class="xref" href="innodb-storage-engine.html#innodb-multiple-tablespaces" title="14.5.2 InnoDB File-Per-Table モード">セクション14.5.2「InnoDB File-Per-Table モード」</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_compression">圧縮</a>, <a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_ibd_file">.ibd ファイル</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>も参照</p></dd><dt><a name="glos_innodb_lock_wait_timeout"></a><span class="glossterm">innodb_lock_wait_timeout</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987406880"></a>
        <code class="literal">innodb_lock_wait_timeout</code> オプションは、共有リソースが利用できるようになるまで<span class="bold"><strong>待機</strong></span>するか、または放棄してエラーを処理したり、再試行したり、アプリケーションで代替処理を行ったりするかのバランスを設定します。InnoDB トランザクションが<span class="bold"><strong>ロック</strong></span>を獲得するための指定待機時間を超えた場合は、ロールバックします。特に、異なるストレージエンジンで制御される複数のテーブルへの更新によって<span class="bold"><strong>デッドロック</strong></span>が発生した場合に役立ちます。このようなデッドロックは自動的には<span class="bold"><strong>検出</strong></span>されません。
      </p><p><a class="glossseealso" href="glossary.html#glos_deadlock">デッドロック</a>, <a class="glossseealso" href="glossary.html#glos_deadlock_detection">デッドロック検出</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_wait">待機</a>も参照</p></dd><dt><a name="glos_innodb_strict_mode"></a><span class="glossterm">innodb_strict_mode</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987398000"></a>
        <code class="literal">innodb_strict_mode</code> オプションは、InnoDB が <span class="bold"><strong>厳密モード</strong></span> (通常は警告として扱われる条件でエラーを発生させる (そして基礎となるステートメントが失敗する)) で動作するかどうかを制御します。
      </p><p>
        このモードは MySQL 5.5.5 以降のデフォルト設定です。
      </p><p><a class="glossseealso" href="glossary.html#glos_strict_mode">厳密モード</a>も参照</p></dd><dt><a name="glos_iops"></a><span class="glossterm">IOPS</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987392464"></a>
        <span class="bold"><strong>1 秒あたりの I/O 操作 (I/O Operations Per Second) </strong></span>の頭字語。ビジーシステム、特に <span class="bold"><strong>OLTP</strong></span> アプリケーションの一般的な測定基準。ストレージデバイスが処理できる最大値にこの値が近い場合、アプリケーションは<span class="bold"><strong>ディスクバウンド</strong></span>になり、<span class="bold"><strong>スケーラビリティー</strong></span>を制限する場合があります。
      </p><p><a class="glossseealso" href="glossary.html#glos_disk_bound">ディスクバウンド</a>, <a class="glossseealso" href="glossary.html#glos_oltp">OLTP</a>, <a class="glossseealso" href="glossary.html#glos_scalability">スケーラビリティー</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">K</h3><dl><dt><a name="glos_key_block_size"></a><span class="glossterm">KEY_BLOCK_SIZE</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987384928"></a>
        <span class="bold"><strong>圧縮行フォーマット</strong></span>を使用する InnoDB テーブル内で、データページのサイズを指定するオプション。デフォルトは 8K バイトです。値を小さくすると、行サイズと圧縮比率の組み合わせによって内部制限に達する恐れがあります。
      </p><p><a class="glossseealso" href="glossary.html#glos_compressed_row_format">圧縮行フォーマット</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">L</h3><dl><dt><a name="glos_lock_mode"></a><span class="glossterm">lock mode</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987380560"></a>
        共有ロックでは、トランザクションは行を読み取ることができます。複数のトランザクションが同時にその同じ行で S ロックを獲得できます。
      </p><p>
        排他 (X) ロックでは、トランザクションは行を更新または削除できます。ほかのトランザクションは、同時にその同じ行でどのようなロックも獲得できません。
      </p><p>
        <span class="bold"><strong>インテンションロック</strong></span>は、テーブルレベルに適用され、トランザクションがテーブル内の行で獲得したいロックの種類を示すために使用されます。トランザクションごとに異なる種類のインテンションロックを同じテーブルで獲得できますが、最初のトランザクションがあるテーブルでインテンション排他 (IX) ロックを獲得すると、ほかのトランザクションはそのテーブルで S または X ロックを獲得できません。反対に、最初のトランザクションがあるテーブルでインテンション共有 (IS) ロックを獲得すると、ほかのトランザクションはそのテーブルで X ロックを獲得できません。2 フェーズプロセスは、ロックおよび互換性のある対応操作をブロックせずに、ロックリクエストを順番に解決できます。
      </p><p><a class="glossseealso" href="glossary.html#glos_intention_lock">インテンションロック</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>も参照</p></dd><dt><a name="glos_loose_"></a><span class="glossterm">loose_</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987373440"></a>
        MySQL 5.1 で、サーバーの起動後に InnoDB <span class="bold"><strong>Plugin</strong></span> をインストールするときに、InnoDB 構成オプションに追加されるプリフィクス。したがって、現在のレベルの MySQL で認識されない新しい構成オプションは起動エラーを引き起こしません。MySQL は、このプリフィクスで始まる構成オプションを処理しますが、プリフィクスに続く部分が認識されるオプションでない場合、エラーではなく警告を返します。

      </p><p><a class="glossseealso" href="glossary.html#glos_plugin">プラグイン</a>も参照</p></dd><dt><a name="glos_lru"></a><span class="glossterm">LRU</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987369040"></a>
        「Least Recently Used」の頭字語。ストレージ領域を管理するための一般的な方法。より新しい項目をキャッシュするための領域が必要なときは、最近使用されていない項目は<span class="bold"><strong>削除</strong></span>されます。InnoDB は、<span class="bold"><strong>バッファープール</strong></span>内の<span class="bold"><strong>ページ</strong></span>を管理するためにデフォルトで LRU メカニズムを使用しますが、ページが 1 回だけ読み取られる場合 (<span class="bold"><strong>フルテーブルスキャン</strong></span>中など) を例外扱いします。LRU アルゴリズムのこのバリエーションは<span class="bold"><strong>ミッドポイント挿入戦略</strong></span>と呼ばれます。バッファープール管理が従来の LRU アルゴリズムと異なる点は、オプション <code class="literal">innodb_old_blocks_pct</code>、<code class="literal">innodb_old_blocks_time</code> と、新しい MySQL 5.6 オプション <code class="literal">innodb_lru_scan_depth</code> および <code class="literal">innodb_flush_neighbors</code> により微調整されることです。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_eviction">エビクション</a>, <a class="glossseealso" href="glossary.html#glos_full_table_scan">テーブルの完全スキャン</a>, <a class="glossseealso" href="glossary.html#glos_midpoint_insertion_strategy">ミッドポイント挿入戦略</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>も参照</p></dd><dt><a name="glos_lsn"></a><span class="glossterm">LSN</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987355824"></a>
        「ログシーケンス番号 (Log Sequence Number)」の頭字語。この任意の増加し続ける値は、<span class="bold"><strong>Redo ログ</strong></span>に記録される操作に対応する時点を表します。(この時点は、<span class="bold"><strong>トランザクション</strong></span>境界を意識しません。1 つ以上のトランザクションの中間になることがあります。)<span class="bold"><strong>クラッシュリカバリ</strong></span>中に InnoDB によって内部的に、バッファープールを管理するために使用されます。
      </p><p>
        MySQL 5.6.3 より前では、LSN は 4 バイト符号なし整数でした。LSN は、MySQL 5.6.3 で 8 バイト符号なし整数になりました。追加サイズ情報を格納するために追加バイトが必要だったので、Redo ログファイルサイズ限度が 4G バイトから 512G バイトに増加したためです。MySQL 5.6.3 以降でビルドされたアプリケーションのうち LSN 値を使用するものは、32 ビット変数ではなく 64 ビット変数を使用して LSN 値を格納および比較することをお勧めします。
      </p><p>
        <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品では、<span class="bold"><strong>増分バックアップ</strong></span>を取得する時点を表す LSN を指定できます。該当する LSN は、<code class="literal">mysqlbackup</code> コマンドの出力で表示されます。完全バックアップの時点に対応する LSN がわかれば、後続の増分バックアップを取得するためにその値を指定でき、その出力には次の増分バックアップのもう 1 つの LSN が含まれます。
      </p><p><a class="glossseealso" href="glossary.html#glos_crash_recovery">クラッシュリカバリ</a>, <a class="glossseealso" href="glossary.html#glos_incremental_backup">増分バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_redo_log">Redo ログ</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">M</h3><dl><dt><a name="glos_mdl"></a><span class="glossterm">MDL</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987343712"></a>
        「メタデータロック (MetaData Lock)」の頭字語。
      </p><p><a class="glossseealso" href="glossary.html#glos_metadata_lock">メタデータロック</a>も参照</p></dd><dt><a name="glos_memcached"></a><span class="glossterm">memcached</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987340944"></a>
        多くの MySQL および <span class="bold"><strong>NoSQL</strong></span> ソフトウェアスタックで広く使用されているコンポーネント。単一値を高速で読み書きでき、結果全体をメモリーにキャッシュします。アプリケーションは従来、永続的ストレージに同じデータを MySQL データベースに書き込むため、またはまだメモリーにキャッシュされていない場合は MySQL データベースからデータを読み取るために、特別なロジックを必要としていました。現在は、アプリケーションは多くの言語のクライアントライブラリでサポートされる単純な <span class="command"><strong>memcached</strong></span> プロトコルを使用して、<span class="bold"><strong>InnoDB</strong></span> または MySQL Cluster テーブルを使用する MySQL Server と直接通信できます。アプリケーションは、これらの NoSQL から MySQL テーブルへのインタフェースを利用することで、SQL コマンドを直接発行するよりも高い読み取り/書き込みパフォーマンスを実現でき、すでにインメモリーキャッシュ用に <span class="command"><strong>memcached</strong></span> が組み込まれているシステムのアプリケーションロジックと配備構成を簡略化できます。
      </p><p>
        InnoDB テーブルへの <span class="command"><strong>memcached</strong></span> インタフェースは、MySQL 5.6 以降で利用できます。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-memcached" title="14.18 InnoDB と memcached の統合">セクション14.18「InnoDB と memcached の統合」</a>を参照してください。MySQL Cluster テーブルへの <span class="command"><strong>memcached</strong></span> インタフェースは、MySQL Cluster 7.2 で使用できます。詳細は、<a class="ulink" href="http://dev.mysql.com/doc/ndbapi/en/ndbmemcache.html" target="_top">http://dev.mysql.com/doc/ndbapi/en/ndbmemcache.html</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>, <a class="glossseealso" href="glossary.html#glos_nosql">NoSQL</a>も参照</p></dd><dt><a name="glos_mtr"></a><span class="glossterm">mtr</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_mini_transaction">ミニトランザクション</a>も参照</p></dd><dt><a name="glos_mvcc"></a><span class="glossterm">MVCC</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987327744"></a>
        「マルチバージョン並列性制御 (MultiVersion Concurrency Control)」の略語。この方法を使用すれば、特定の<span class="bold"><strong>分離レベル</strong></span>を持つ InnoDB <span class="bold"><strong>トランザクション</strong></span>が、<span class="bold"><strong>一貫性読み取り</strong></span>操作を実行できます。つまり、ほかのトランザクションが更新している行を照会して、これらの更新が行われる前に値を確認できます。これは、ほかのトランザクションが保持している<span class="bold"><strong>ロック</strong></span>のために待機することなく、クエリーが進行できるようにすることによって、<span class="bold"><strong>並列性</strong></span>を高める強力な方法です。
      </p><p>
        この方法は、データベース世界で共通のものではありません。ほかのデータベース製品やほかの MySQL ストレージエンジンの中には、これをサポートしないものがあります。
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_concurrency">並列性</a>, <a class="glossseealso" href="glossary.html#glos_consistent_read">一貫性読み取り</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_my_cnf"></a><span class="glossterm">my.cnf</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987317456"></a>
        UNIX または Linux システムでの MySQL オプションファイルの名前。
      </p><p><a class="glossseealso" href="glossary.html#glos_my_ini">my.ini</a>, <a class="glossseealso" href="glossary.html#glos_option_file">オプションファイル</a>も参照</p></dd><dt><a name="glos_my_ini"></a><span class="glossterm">my.ini</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987313728"></a>
        Windows システムでの MySQL オプションファイルの名前。
      </p><p><a class="glossseealso" href="glossary.html#glos_my_cnf">my.cnf</a>, <a class="glossseealso" href="glossary.html#glos_option_file">オプションファイル</a>も参照</p></dd><dt><a name="glos_mysql"></a><span class="glossterm">mysql</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987310080"></a>
        <code class="literal">mysql</code> プログラムは MySQL データベース用のコマンド行インタープリターです。<span class="bold"><strong>SQL</strong></span> ステートメントを処理し、<span class="bold"><strong><code class="literal">mysqld</code></strong></span> デーモンにリクエストを渡すことによって <code class="literal">SHOW TABLES</code> などの MySQL 固有コマンドも処理します。
      </p><p><a class="glossseealso" href="glossary.html#glos_mysqld">mysqld</a>, <a class="glossseealso" href="glossary.html#glos_sql">SQL</a>も参照</p></dd><dt><a name="glos_mysql_enterprise_backup"></a><span class="glossterm">MySQL Enterprise Backup</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987303120"></a>
        MySQL データベースの<span class="bold"><strong>ホットバックアップ</strong></span>を実行するライセンス製品。<span class="bold"><strong>InnoDB</strong></span> テーブルをバックアップするときに効率性と柔軟性がもっとも高くなりますが、MyISAM とほかの種類のテーブルもバックアップできます。
      </p><p><a class="glossseealso" href="glossary.html#glos_hot_backup">ホットバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>も参照</p></dd><dt><a name="glos_mysqlbackup_command"></a><span class="glossterm">mysqlbackup コマンド</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987298016"></a>
        <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品のコマンド行ツール。InnoDB テーブルには<span class="bold"><strong>ホットバックアップ</strong></span>操作を、MyISAM とほかの種類のテーブルには<a class="link" href="glossary.html#glos_warm_backup" title="ウォームバックアップ">ウォームバックアップ</a>操作を実行します。このコマンドの詳細は、<a class="xref" href="mysql-enterprise.html#mysql-enterprise-backup" title="25.2 MySQL Enterprise Backup">セクション25.2「MySQL Enterprise Backup」</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_hot_backup">ホットバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_warm_backup">ウォームバックアップ</a>も参照</p></dd><dt><a name="glos_mysqld"></a><span class="glossterm">mysqld</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987290976"></a>
        <code class="literal">mysqld</code> プログラムは、MySQL データベース用のデータベースエンジンです。UNIX デーモンまたは Windows サービスとして動作し、常にリクエストを待機し、バックグラウンドで保守作業を実行します。
      </p><p><a class="glossseealso" href="glossary.html#glos_mysql">mysql</a>も参照</p></dd><dt><a name="glos_mysqldump"></a><span class="glossterm">mysqldump</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987287008"></a>
        データベース、テーブル、およびテーブルデータの組み合わせの<span class="bold"><strong>論理バックアップ</strong></span>を実行するコマンド。結果は、元のスキーマオブジェクトまたはデータ、あるいはその両方を再現する SQL ステートメントです。相当な量のデータの場合、<span class="bold"><strong>MySQL Enterprise Backup</strong></span> などの<span class="bold"><strong>物理バックアップ</strong></span>ソリューションが高速です (特に<span class="bold"><strong>リストア</strong></span>操作で)。
      </p><p><a class="glossseealso" href="glossary.html#glos_logical_backup">論理バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_physical_backup">物理バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_restore">リストア</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">N</h3><dl><dt><a name="glos_nosql"></a><span class="glossterm">NoSQL</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987278912"></a>
        データ読み書きの主要なメカニズムとして <span class="bold"><strong>SQL</strong></span> 言語を使用しない、一連のデータアクセステクノロジの一般的な用語。NoSQL テクノロジの中には、単一値の読み取りと買い込みだけを受け入れるキー値ストアとして機能するものがあります。<span class="bold"><strong>ACID</strong></span> 原理の制限を緩和するものや、事前に計画された<span class="bold"><strong>スキーマ</strong></span>が不要なものもあります。MySQL ユーザーは、<span class="bold"><strong>memcached</strong></span> API を使用して何らかの MySQL テーブルに直接アクセスすることにより、速度と簡略化のための NoSQL スタイル処理と、柔軟性と利便性のための SQL 操作を組み合わせることができます。InnoDB テーブルへの <span class="command"><strong>memcached</strong></span> インタフェースは、MySQL 5.6 以降で利用できます。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-memcached" title="14.18 InnoDB と memcached の統合">セクション14.18「InnoDB と memcached の統合」</a>を参照してください。MySQL Cluster テーブルへの <span class="command"><strong>memcached</strong></span> インタフェースは、MySQL Cluster 7.2 で使用できます。詳細は、<a class="ulink" href="http://dev.mysql.com/doc/ndbapi/en/ndbmemcache.html" target="_top">http://dev.mysql.com/doc/ndbapi/en/ndbmemcache.html</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>, <a class="glossseealso" href="glossary.html#glos_memcached">memcached</a>, <a class="glossseealso" href="glossary.html#glos_schema">スキーマ</a>, <a class="glossseealso" href="glossary.html#glos_sql">SQL</a>も参照</p></dd><dt><a name="glos_not_null_constraint"></a><span class="glossterm">NOT NULL 制約</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987266704"></a>
        <span class="bold"><strong>カラム</strong></span>が <span class="bold"><strong>NULL</strong></span> 値を含むことができないと規定するタイプの<span class="bold"><strong>制約</strong></span>。これは、データベースサーバーが誤って値が失われているデータを識別できるので、<span class="bold"><strong>参照整合性</strong></span>の維持に役立ちます。また、オプティマイザはそのカラムのインデックス内のエントリ数を予測できるので、クエリー最適化に関係する演算でも役立ちます。
      </p><p><a class="glossseealso" href="glossary.html#glos_column">カラム</a>, <a class="glossseealso" href="glossary.html#glos_constraint">制約</a>, <a class="glossseealso" href="glossary.html#glos_null">NULL</a>, <a class="glossseealso" href="glossary.html#glos_primary_key">主キー</a>, <a class="glossseealso" href="glossary.html#glos_referential_integrity">参照整合性</a>も参照</p></dd><dt><a name="glos_null"></a><span class="glossterm">NULL</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987258352"></a>
        データが存在しないことを示す、<span class="bold"><strong>SQL</strong></span> での特殊な値。算術演算や等価性テストに <code class="literal">NULL</code> 値が含まれる場合は、それらは <code class="literal">NULL</code> 結果を返します。(したがってこれは、IEEE 浮動小数点の NaN (not a number) 概念に似ています。)<code class="literal">AVG()</code> などの集計計算は、除算の分母となる行数を決定するときに、<code class="literal">NULL</code> 値を含む行を無視します。<code class="literal">NULL</code> 値を扱う唯一のテストは、SQL イディオム <code class="literal">IS NULL</code> または <code class="literal">IS NOT NULL</code> を使用します。
      </p><p>
        <code class="literal">NULL</code> 値はインデックス操作で役割を果たします。パフォーマンスのため、データベースは失われたデータ値を追跡するオーバーヘッドを最小限に抑える必要があるためです。<code class="literal">NULL</code> 値は通常、インデックスに格納されません。標準比較演算子を使用してインデックスカラムをテストするクエリーは、そのカラムの行を <code class="literal">NULL</code> 値に照合することはできないためです。同じ理由で、一意のインデックスは <code class="literal">NULL</code> 値を防止しません。これらの値は単純にインデックスに表示されません。カラムで <code class="literal">NOT NULL</code> 制約を宣言することで、インデックスから外れる行がないことが再保証され、クエリー最適化が向上します (行数カウントおよびインデックスを使用するかどうかの評価の精度)。
      </p><p>
        <span class="bold"><strong>主キー</strong></span>はテーブル内のすべての行を一意に識別できる必要があるので、単一カラム主キーには <code class="literal">NULL</code> 値を含めることはできず、複数カラム主キーにはすべてのカラムで <code class="literal">NULL</code> 値を持つ行を含めることはできません。
      </p><p>
        Oracle データベースでは <code class="literal">NULL</code> 値を文字列と連結できますが、InnoDB はこのような操作の結果を <code class="literal">NULL</code> として扱います。
      </p><p><a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_primary_key">主キー</a>, <a class="glossseealso" href="glossary.html#glos_sql">SQL</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">O</h3><dl><dt><a name="glos_oltp"></a><span class="glossterm">OLTP</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987237008"></a>
        「オンライントランザクション処理 (Online Transaction Processing)」の頭字語。データベースシステムまたはデータベースアプリケーションの 1 つ。多数の<span class="bold"><strong>トランザクション</strong></span>、頻繁な書き込みと読み取りのワークロードを実行し、通常は一度に少量のデータに影響します。たとえば、航空便予約システムや銀行預金を処理するアプリケーションがあります。<span class="bold"><strong>DML</strong></span> (挿入/更新/削除) 効率性と<span class="bold"><strong>クエリー</strong></span>効率性とのバランスを取るために、データは<span class="bold"><strong>正規化</strong></span>形式で編成される場合があります。<span class="bold"><strong>データウェアハウス</strong></span>と対比してください。
      </p><p>
        <span class="bold"><strong>InnoDB</strong></span> は、<span class="bold"><strong>行レベルロック</strong></span>と<span class="bold"><strong>トランザクション</strong></span>機能を備え、OLT アプリケーションで使用される MySQL テーブルに理想的なストレージエンジンです。
      </p><p><a class="glossseealso" href="glossary.html#glos_data_warehouse">データウェアハウス</a>, <a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>, <a class="glossseealso" href="glossary.html#glos_query">クエリー</a>, <a class="glossseealso" href="glossary.html#glos_row_lock">行ロック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">P</h3><dl><dt><a name="glos_page_size"></a><span class="glossterm">page size</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987224336"></a>
        MySQL 5.5 以前のリリースでは、各 InnoDB <span class="bold"><strong>ページ</strong></span>のサイズは 16K バイトに固定されています。この値は、ほとんどの行のデータを保持できる大きさと、不要なデータをメモリーに転送するパフォーマンスオーバーヘッドを最小化できる小ささとを、調和させたものです。ほかの値は未テストで、サポートされません。
      </p><p>
        MySQL 5.6 以降、InnoDB <span class="bold"><strong>インスタンス</strong></span>のページサイズは 4K バイト、8K バイト、または 16K バイトに設定でき、<code class="literal">innodb_page_size</code> 構成オプションで制御できます。MySQL 5.7.6 以降の InnoDB は、32K バイトおよび 64K バイトページサイズのサポートも提供します。どちらのページサイズでも、<code class="literal">ROW_FORMAT=COMPRESSED</code> はサポートされず、最大レコードサイズは 16K バイトです。
      </p><p>
        サイズは MySQL インスタンス作成時に設定し、その後は不変です。同じページサイズが、すべての InnoDB <span class="bold"><strong>テーブルスペース</strong></span> (<span class="bold"><strong>システムテーブルスペース</strong></span>と、<span class="bold"><strong>file-per-table</strong></span> モードで別個に作成されるテーブルスペース) に適用されます。
      </p><p>
        ページサイズが小さいほど、小さなブロックサイズを使用するストレージデバイス (特に、<span class="bold"><strong>OLTP</strong></span> アプリケーションなどの<span class="bold"><strong>ディスクバウンド</strong></span>ワークロードでの <span class="bold"><strong>SSD</strong></span> デバイス) のパフォーマンスに役立ちます。個々の行が更新されるときに、メモリーにコピーされたり、ディスクに書き込まれたり、再編成されたり、ロックされたりするときのデータ量が少なくなります。
      </p><p><a class="glossseealso" href="glossary.html#glos_disk_bound">ディスクバウンド</a>, <a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_instance">インスタンス</a>, <a class="glossseealso" href="glossary.html#glos_oltp">OLTP</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>, <a class="glossseealso" href="glossary.html#glos_ssd">SSD</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_tablespace">テーブルスペース</a>も参照</p></dd><dt><a name="glos_pitr"></a><span class="glossterm">PITR</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987206640"></a>
        <span class="bold"><strong>ポイントインタイムリカバリ (Point-In-Time Recovery)</strong></span> の頭字語。
      </p><p><a class="glossseealso" href="glossary.html#glos_point_in_time_recovery">ポイントインタイムリカバリ</a>も参照</p></dd><dt><a name="glos_pthreads"></a><span class="glossterm">Pthreads</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987203152"></a>
        POSIX スレッド標準。UNIX および Linux システムでのスレッドおよびロック操作の API を定義します。UNIX および Linux システムでは、InnoDB はこの<span class="bold"><strong>相互排他ロック</strong></span>実装を使用します。
      </p><p><a class="glossseealso" href="glossary.html#glos_mutex">相互排他ロック</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">R</h3><dl><dt><a name="glos_raid"></a><span class="glossterm">RAID</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987198992"></a>
        「Redundant Array of Inexpensive Drives」の頭字語。複数のドライブに I/O 操作を分散することにより、ハードウェアレベルで<span class="bold"><strong>並列性</strong></span>が向上し、低レベル書き込み操作の効率性が改善します (そうしない場合は順番に実行されます)。
      </p><p><a class="glossseealso" href="glossary.html#glos_concurrency">並列性</a>も参照</p></dd><dt><a name="glos_raw_backup"></a><span class="glossterm">raw バックアップ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987195168"></a>
        <span class="bold"><strong>バイナリログ</strong></span>と<span class="bold"><strong>増分バックアップ</strong></span>に反映される変更が適用される前の、<span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品によって生成されるバックアップファイルの初期セット。この段階では、ファイルは<span class="bold"><strong>リストア</strong></span>する準備ができていません。これらの変更が適用されたあと、ファイルは<span class="bold"><strong>準備されたバックアップ</strong></span>と呼ばれます。
      </p><p><a class="glossseealso" href="glossary.html#glos_binary_log">バイナリログ</a>, <a class="glossseealso" href="glossary.html#glos_hot_backup">ホットバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_ibbackup_logfile">ibbackup_logfile</a>, <a class="glossseealso" href="glossary.html#glos_incremental_backup">増分バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_prepared_backup">準備されたバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_restore">リストア</a>も参照</p></dd><dt><a name="glos_read_committed"></a><span class="glossterm">READ COMMITTED</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987185136"></a>
        <span class="bold"><strong>分離レベル</strong></span>の 1 つ。パフォーマンスを向上させるために、<span class="bold"><strong>トランザクション</strong></span>間の保護を一部緩和する<span class="bold"><strong>ロック</strong></span>戦略を使用します。トランザクションは、ほかのトランザクションからのコミットされていないデータを見ることはできませんが、現在のトランザクションが開始したあとに別のトランザクションによってコミットされるデータを見ることはできます。したがって、トランザクションは不良データを見ることはありませんが、見るデータはある程度ほかのトランザクションのタイミングに依存する場合があります。
      </p><p>
        この分離レベルのトランザクションが <code class="literal">UPDATE ... WHERE</code> または <code class="literal">DELETE ... WHERE</code> 操作を実行するときに、ほかのトランザクションは待機が必要な場合があります。このトランザクションは、ほかのトランザクションを待機させずに <code class="literal">SELECT ... FOR UPDATE</code> および <code class="literal">LOCK IN SHARE MODE</code> 操作を実行できます。
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_repeatable_read">REPEATABLE READ</a>, <a class="glossseealso" href="glossary.html#glos_serializable">SERIALIZABLE</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_read_uncommitted"></a><span class="glossterm">READ UNCOMMITTED</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987172704"></a>
        トランザクション間にもっとも少ない量の保護を提供する<span class="bold"><strong>分離レベル</strong></span>。クエリーは、通常は別のトランザクションを待機する状況で進行することを許可される<span class="bold"><strong>ロック</strong></span>戦略を採用します。ただし、この追加パフォーマンスには、ほかのトランザクションによって変更されたけれどもまだコミットされていないデータ (<span class="bold"><strong>ダーティー読み取り</strong></span>と呼ばれます) など、結果の信頼性の低いという犠牲が伴います。この分離レベルを使用するときは十分な注意が必要で、ほかのトランザクションが同時に何を実行しているかによって結果が一貫しなかったり再現性がなくなったりすることを認識してください。この分離レベルのトランザクションは通常、照会だけを行い、挿入、更新、削除操作は行いません。
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_dirty_read">ダーティー読み取り</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_redo"></a><span class="glossterm">Redo</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987164400"></a>
        <a class="link" href="glossary.html#glos_dml" title="DML">DML</a> ステートメントが InnoDB テーブルに変更を行うときに、<span class="bold"><strong>Redo ログ</strong></span>にレコード単位で記録されるデータ。<span class="bold"><strong>クラッシュリカバリ</strong></span>中に、不完全な<span class="bold"><strong>トランザクション</strong></span>によって書き込まれるデータを訂正するために使用されます。増加し続ける <span class="bold"><strong>LSN</strong></span> 値は、Redo ログを通過した Redo データの累積量を表します。
      </p><p><a class="glossseealso" href="glossary.html#glos_crash_recovery">クラッシュリカバリ</a>, <a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_lsn">LSN</a>, <a class="glossseealso" href="glossary.html#glos_redo_log">Redo ログ</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_redo_log"></a><span class="glossterm">Redo ログ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987155776"></a>
        <span class="bold"><strong>クラッシュリカバリ</strong></span>中に、不完全な<span class="bold"><strong>トランザクション</strong></span>によって書き込まれるデータを訂正するために使用されるディスクベースデータ構造。通常の操作中に、InnoDB テーブルデータを変更するリクエスト (SQL ステートメント、または NoSQL インタフェースからの低レベル API 呼び出しから発生) をエンコードします。予期しない<span class="bold"><strong>シャットダウン</strong></span>前に<span class="bold"><strong>データファイル</strong></span>の更新を終了していない変更は、自動的に再現されます。
      </p><p>
        Redo ログはファイルセットとして物理的に表され、通常は <code class="filename">ib_logfile0</code> および <code class="filename">ib_logfile1</code> という名前が付けられます。Redo ログ内のデータは、該当するレコードの単位でエンコードされます。このデータはまとめて <span class="bold"><strong>Redo</strong></span> と呼ばれます。Redo ログをデータが通貨したことは、増加し続ける <span class="bold"><strong>LSN</strong></span> 値で表されます。Redo ログの最大サイズは、最初は 4G バイトに制限されていましたが、MySQL 5.6.3 で 512G バイトに上げられています。
      </p><p>
        Redo ログのディスクレイアウトは、構成オプション <code class="literal">innodb_log_file_size</code>、<code class="literal">innodb_log_group_home_dir</code>、および (まれに) <code class="literal">innodb_log_files_in_group</code> に影響されます。Redo ログ操作のパフォーマンスは、<span class="bold"><strong>ログバッファー</strong></span>にも影響されます。これは <code class="literal">innodb_log_buffer_size</code> 構成オプションによって制御されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_crash_recovery">クラッシュリカバリ</a>, <a class="glossseealso" href="glossary.html#glos_data_files">データファイル</a>, <a class="glossseealso" href="glossary.html#glos_ib_logfile">ib_logfile</a>, <a class="glossseealso" href="glossary.html#glos_log_buffer">ログバッファー</a>, <a class="glossseealso" href="glossary.html#glos_lsn">LSN</a>, <a class="glossseealso" href="glossary.html#glos_redo">Redo</a>, <a class="glossseealso" href="glossary.html#glos_shutdown">シャットダウン</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_repeatable_read"></a><span class="glossterm">REPEATABLE READ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987135744"></a>
        InnoDB のデフォルト<span class="bold"><strong>分離レベル</strong></span>。照会される行がほかのトランザクションによって変更されるのを防ぎます。したがって、<span class="bold"><strong>反復不可能読み取り</strong></span>はブロックしますが、<span class="bold"><strong>ファントム</strong></span>読み取りはしません。トランザクション内のすべてのクエリーが同じスナップショットからのデータを見る、つまりトランザクションが開始した時点のデータを見るように、適度に厳密な<span class="bold"><strong>ロック</strong></span>戦略を使用します。
      </p><p>
        この分離レベルのトランザクションが <code class="literal">UPDATE ... WHERE</code>、<code class="literal">DELETE ... WHERE</code>、<code class="literal">SELECT ... FOR UPDATE</code>、および <code class="literal">LOCK IN SHARE MODE</code> 操作を実行するときに、ほかのトランザクションは待機しなければいけない場合があります。
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_consistent_read">一貫性読み取り</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_phantom">ファントム</a>, <a class="glossseealso" href="glossary.html#glos_serializable">SERIALIZABLE</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_rw_lock"></a><span class="glossterm">rw ロック (読み書きロック)</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987122944"></a>
        特定のルールに基づく内部インメモリーデータ構造への共有アクセス<span class="bold"><strong>ロック</strong></span>を表現および適用するために、InnoDB が使用する低レベルオブジェクト。<span class="bold"><strong>相互排他ロック</strong></span> (InnoDB が内部インメモリーデータ構造への排他アクセスを表現および適用するために使用) と対比してください。相互排他ロックと読み書きロックはまとめて、<span class="bold"><strong>ラッチ</strong></span>と呼ばれます。
      </p><p>
        <code class="literal">rw ロック</code>タイプには、<code class="literal">s ロック</code> (共有ロック)、<code class="literal">x ロック</code> (排他ロック)、および <code class="literal">sx ロック</code> (共有排他ロック) などがあります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">s ロック</code>は、共有リソースへの読み取りアクセスを提供します。
          </p></li><li class="listitem"><p>
            <code class="literal">x ロック</code>は、共有リソースへの書き込みアクセスを提供し、ほかのスレッドによる不整合読み取りを許可しません。
          </p></li><li class="listitem"><p>
            <code class="literal">sx ロック</code>は、共有リソースへの書き込みアクセスを提供し、ほかのスレッドによる不整合読み取りを許可します。<code class="literal">sx ロック</code>は、読み取り/書き込みワークロードの並列性を最適化し、スケーラビリティーを改善するために MySQL 5.7 で導入されました。
          </p></li></ul></div><p>
        次の表に rw ロックタイプ互換性をまとめます。
      </p><div class="informaltable"><table summary="rw ロックタイプ互換性の表。マトリクス内の各セルには、「互換」と「競合」のいずれかのマークが付いています。" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th scope="col"> </th><th scope="col"><em class="replaceable"><code>S</code></em>

              </th><th scope="col"><em class="replaceable"><code>SX</code></em>

              </th><th scope="col"><em class="replaceable"><code>X</code></em>

              </th></tr></thead><tbody><tr><td scope="row"><em class="replaceable"><code>S</code></em>

              </td><td>互換</td><td>互換</td><td>競合</td></tr><tr><td scope="row"><em class="replaceable"><code>SX</code></em>

              </td><td>互換</td><td>競合</td><td>競合</td></tr><tr><td scope="row"><em class="replaceable"><code>X</code></em>

              </td><td>競合</td><td>競合</td><td>競合</td></tr></tbody></table></div><p><a class="glossseealso" href="glossary.html#glos_latch">ラッチ</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_mutex">相互排他ロック</a>, <a class="glossseealso" href="glossary.html#glos_performance_schema">パフォーマンススキーマ</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">S</h3><dl><dt><a name="glos_serializable"></a><span class="glossterm">SERIALIZABLE</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987090544"></a>
        もっとも保守的なロック戦略を使用する<span class="bold"><strong>分離レベル</strong></span>。このトランザクションが読み取ったデータを (終了するまで) ほかのトランザクションが挿入または変更することを防ぐため。この方法では、トランザクション内で同じクエリーを何度も実行でき、そのたびに同じ結果セットを取得することを保証できます。現在のトランザクションが開始してから別のトランザクションによってコミットされたデータを変更しようとすると、現在のトランザクションは待機します。
      </p><p>
        これは、SQL 標準で指定されるデフォルト分離レベルです。実際にはこの程度の厳密さはまれにしか必要でないので、InnoDB のデフォルト分離レベルは次にもっとも厳密な<span class="bold"><strong>反復可能読み取り</strong></span>です。
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_consistent_read">一貫性読み取り</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_repeatable_read">REPEATABLE READ</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_sql"></a><span class="glossterm">SQL</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987081824"></a>
        データベース操作を実行するための標準である構造化クエリー言語。多くの場合、カテゴリ <span class="bold"><strong>DDL</strong></span>、<span class="bold"><strong>DML</strong></span>、および<span class="bold"><strong>クエリー</strong></span>に分けられます。MySQL には、<span class="bold"><strong>レプリケーション</strong></span>などのいくつかの追加ステートメントカテゴリが含まれます。SQL 構文の構成ブロックについては<a class="xref" href="language-structure.html" title="第 9 章 言語構造">第9章「<i>言語構造</i>」</a>、MySQL テーブルカラムに使用するデータ型については<a class="xref" href="data-types.html" title="第 11 章 データ型">第11章「<i>データ型</i>」</a>、SQL ステートメントとそれらに関連付けられるカテゴリの詳細は<a class="xref" href="sql-syntax.html" title="第 13 章 SQL ステートメントの構文">第13章「<i>SQL ステートメントの構文</i>」</a>、クエリーで使用する標準および MySQL 固有の関数については<a class="xref" href="functions.html" title="第 12 章 関数と演算子">第12章「<i>関数と演算子</i>」</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_ddl">DDL</a>, <a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_query">クエリー</a>, <a class="glossseealso" href="glossary.html#glos_replication">レプリケーション</a>も参照</p></dd><dt><a name="glos_ssd"></a><span class="glossterm">SSD</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987071568"></a>
        「ソリッドステートドライブ (Solid-State Drive)」の頭字語。従来のハードディスクドライブ (<span class="bold"><strong>HDD</strong></span>) とパフォーマンス特性が異なるタイプのストレージデバイス。ストレージ容量が小さく、ランダム読み取りが高速で、可動部分がなく、書き込みパフォーマンスに影響する考慮事項がいくつかあります。そのパフォーマンス特性は、<span class="bold"><strong>ディスクバウンド</strong></span>ワークロードのスループットに影響を与えることがあります。
      </p><p><a class="glossseealso" href="glossary.html#glos_disk_bound">ディスクバウンド</a>, <a class="glossseealso" href="glossary.html#glos_ssd">SSD</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">T</h3><dl><dt><a name="glos_tps"></a><span class="glossterm">TPS</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987065584"></a>
        「秒あたりのトランザクション数 (<span class="bold"><strong>Transactions</strong></span> Per Second)」の頭字語。ベンチマークでときどき使用される測定単位。その値は、特定のベンチマークテストで表される<span class="bold"><strong>ワークロード</strong></span>と、ハードウェア能力やデータベース構成などの制御要因との組み合わせに応じて異なります。
      </p><p><a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>, <a class="glossseealso" href="glossary.html#glos_workload">ワークロード</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">U</h3><dl><dt><a name="glos_undo"></a><span class="glossterm">Undo</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987060080"></a>
        <span class="bold"><strong>トランザクション</strong></span>の生存期間保持されるデータ。<span class="bold"><strong>ロールバック</strong></span>操作の場合に元に戻せるようにすべての変更を記録します。これは、<span class="bold"><strong>システムテーブルスペース</strong></span>内または別個の <span class="bold"><strong>Undo テーブルスペース</strong></span>内の <span class="bold"><strong>Undo ログ</strong></span>に格納され、<span class="bold"><strong>ロールバックセグメント</strong></span>とも呼ばれます。
      </p><p><a class="glossseealso" href="glossary.html#glos_rollback">ロールバック</a>, <a class="glossseealso" href="glossary.html#glos_rollback_segment">ロールバックセグメント</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>, <a class="glossseealso" href="glossary.html#glos_undo_log">Undo ログ</a>, <a class="glossseealso" href="glossary.html#glos_undo_tablespace">Undo テーブルスペース</a>も参照</p></dd><dt><a name="glos_undo_tablespace"></a><span class="glossterm">Undo テーブルスペース</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987050336"></a>
        <code class="literal">innodb_undo_tablespaces</code> および <code class="literal">innodb_undo_directory</code> 構成オプションによって Undo ログが<span class="bold"><strong>システムテーブルスペース</strong></span>から分離されているときに、<span class="bold"><strong>Undo ログ</strong></span>を含むファイルセットの 1 つ。MySQL 5.6 以降にのみ適用されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_undo_log">Undo ログ</a>も参照</p></dd><dt><a name="glos_undo_buffer"></a><span class="glossterm">Undo バッファー</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_undo_log">Undo ログ</a>も参照</p></dd><dt><a name="glos_undo_log"></a><span class="glossterm">Undo ログ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987041968"></a>
        アクティブ<span class="bold"><strong>トランザクション</strong></span>によって変更されたデータのコピーを保持するストレージ領域。別のトランザクションが (<span class="bold"><strong>一貫性読み取り</strong></span>操作の一部として) 元のデータを見る必要がある場合に、未変更データがこのストレージ領域から取得されます。
      </p><p>
        この領域はデフォルトで物理的に<span class="bold"><strong>システムテーブルスペース</strong></span>の一部です。MySQL 5.6 以降では、<code class="literal">innodb_undo_tablespaces</code> および <code class="literal">innodb_undo_directory</code> 構成オプションを使用して、これを 1 つまたは複数の別個の<span class="bold"><strong>テーブルスペース</strong></span>ファイル (<span class="bold"><strong>Undo テーブルスペース</strong></span>) に分割でき、オプションで <span class="bold"><strong>SSD</strong></span> などの別のストレージデバイスに格納できます。
      </p><p>
        Undo ログは、別個の部分、<span class="bold"><strong>挿入 Undo バッファー</strong></span>と<span class="bold"><strong>更新 Undo バッファー</strong></span>に分割されます。これらの部分はまとめて、Oracle DBA になじみ深い用語、<span class="bold"><strong>ロールバックセグメント</strong></span>とも呼ばれます。
      </p><p><a class="glossseealso" href="glossary.html#glos_consistent_read">一貫性読み取り</a>, <a class="glossseealso" href="glossary.html#glos_rollback_segment">ロールバックセグメント</a>, <a class="glossseealso" href="glossary.html#glos_ssd">SSD</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>, <a class="glossseealso" href="glossary.html#glos_undo_tablespace">Undo テーブルスペース</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">W</h3><dl><dt><a name="glos_windows"></a><span class="glossterm">Windows</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987025600"></a>
        組み込み <span class="bold"><strong>InnoDB</strong></span> ストレージエンジンと InnoDB <span class="bold"><strong>Plugin</strong></span> が、MySQL Server と同じすべての Microsoft Windows バージョンでサポートされます。<span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品は、<span class="bold"><strong>InnoDB Hot Backup</strong></span> 製品の後継ですが、Windows システムをより包括的にサポートします。
      </p><p><a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_plugin">プラグイン</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">X</h3><dl><dt><a name="glos_xa"></a><span class="glossterm">XA</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987018064"></a>
        分散型<span class="bold"><strong>トランザクション</strong></span>を調整するための標準インタフェース。<span class="bold"><strong>ACID</strong></span> コンプライアンスを維持しながら、複数のデータベースがトランザクションに参加できます。詳細は、<a class="xref" href="sql-syntax.html#xa" title="13.3.7 XA トランザクション">セクション13.3.7「XA トランザクション」</a>を参照してください。
      </p><p>
        XA 分散トランザクションサポートは、デフォルトでオンになっています。この機能を使用していない場合でも、<code class="literal">innodb_support_xa</code> 構成オプションを無効にすることで、トランザクションごとに追加 fsync のパフォーマンスオーバーヘッドを回避できます。
      </p><p><a class="glossseealso" href="glossary.html#glos_commit">コミット</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>, <a class="glossseealso" href="glossary.html#glos_two_phase_commit">2 フェーズコミット</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ア</h3><dl><dt><a name="glos_atomic_instruction"></a><span class="glossterm">アトミック命令</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986920592"></a>
        重要な低レベル操作を中断できないようにするために、CPU によって提供される特殊な命令。
      </p></dd><dt><a name="glos_application_programming_interface"></a><span class="glossterm">アプリケーションプログラミングインタフェース (API)</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986917760"></a>
        関数またはプロシージャーのセット。API は、関数、プロシージャー、パラメータ、および戻り値の名前と型の安定的なセットです。
      </p></dd><dt><a name="glos_early_adopter"></a><span class="glossterm">アーリーアダプタ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987009392"></a>
        ソフトウェア製品が一般的に重要度の低い設定でパフォーマンス、機能、および互換性について評価される、ベータに類似した段階。InnoDB では、<span class="bold"><strong>ベータ</strong></span>ではなく、継続的なポイントリリースを経てしだいに <span class="bold"><strong>GA</strong></span> リリースに至る、<span class="bold"><strong>アーリーアダプタ</strong></span>名称を使用します。
      </p><p><a class="glossseealso" href="glossary.html#glos_beta">ベータ</a>, <a class="glossseealso" href="glossary.html#glos_ga">GA</a>も参照</p></dd><dt><a name="glos_compression"></a><span class="glossterm">圧縮</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986993840"></a>
        使用するディスク領域の縮小、実行する I/O の減少、および使用するキャッシュ用のメモリーの軽減による幅広いメリットを伴う機能。データベース操作中、InnoDB テーブルおよびインデックスデータは圧縮形式で保持できます。
      </p><p>
        データはクエリーで必要になると圧縮解除され、<span class="bold"><strong>DML</strong></span> 操作によって変更が行われると再圧縮されます。テーブルの圧縮を有効にしたあと、この処理はユーザーとアプリケーション開発者に対して透過的です。DBA は、<span class="bold"><strong>information_schema</strong></span> テーブルを参照して、圧縮パラメータが MySQL インスタンスおよび特定の圧縮テーブルに対してどれだけ効率的に機能するかをモニターできます。
      </p><p>
        InnoDB テーブルデータが圧縮されると、圧縮は<span class="bold"><strong>テーブル</strong></span>自体、関連付けられた<span class="bold"><strong>インデックス</strong></span>データ、および<span class="bold"><strong>バッファープール</strong></span>にロードされたページに適用されます。圧縮は、<span class="bold"><strong>Undo バッファー</strong></span>内のページに適用されません。
      </p><p>
        テーブル圧縮機能では、MySQL 5.5 以降、または MySQL 5.1 以前の InnoDB Plugin を使用する必要があり、<span class="bold"><strong>innodb_file_per_table</strong></span> 設定をオンにした状態で <span class="bold"><strong>Barracuda</strong></span> ファイル形式と<span class="bold"><strong>圧縮行フォーマット</strong></span>を使用するテーブルを作成する必要があります。テーブルごとの圧縮は、<code class="literal">CREATE TABLE</code> および <code class="literal">ALTER TABLE</code> ステートメントの <code class="literal">KEY_BLOCK_SIZE</code> 句によって影響されます。MySQL 5.6 以降の圧縮は、サーバー全体の構成オプション <code class="literal">innodb_compression_failure_threshold_pct</code>、<code class="literal">innodb_compression_level</code>、および <code class="literal">innodb_compression_pad_pct_max</code> にも影響されます。使用法の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-compression" title="14.7 InnoDB 圧縮テーブル">セクション14.7「InnoDB 圧縮テーブル」</a>を参照してください。
      </p><p>
        別の種類の圧縮は、<span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品の<span class="bold"><strong>圧縮バックアップ</strong></span>機能です。
      </p><p><a class="glossseealso" href="glossary.html#glos_barracuda">Barracuda</a>, <a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_compressed_row_format">圧縮行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_hot_backup">ホットバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_information_schema">INFORMATION_SCHEMA</a>, <a class="glossseealso" href="glossary.html#glos_innodb_file_per_table">innodb_file_per_table</a>, <a class="glossseealso" href="glossary.html#glos_plugin">プラグイン</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>, <a class="glossseealso" href="glossary.html#glos_undo_buffer">Undo バッファー</a>も参照</p></dd><dt><a name="glos_compressed_table"></a><span class="glossterm">圧縮テーブル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986940512"></a>
        データが圧縮形式で格納されたテーブル。<code class="literal">InnoDB</code> の場合、これは <code class="literal">ROW_FORMAT=COMPRESSED</code> で作成されたテーブルです。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-compression" title="14.7 InnoDB 圧縮テーブル">セクション14.7「InnoDB 圧縮テーブル」</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_compressed_row_format">圧縮行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_compression">圧縮</a>も参照</p></dd><dt><a name="glos_compressed_backup"></a><span class="glossterm">圧縮バックアップ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986934736"></a>
        <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品の圧縮機能は、各テーブルスペースの圧縮コピーを作成し、<code class="literal">.ibd</code> から <code class="literal">.ibz</code> に拡張子を変更します。バックアップデータを圧縮すると、より多くのバックアップを手元に置いておくことができ、別のサーバーにバックアップを転送する時間が短縮します。データはリストア操作中に圧縮解除されます。圧縮バックアップ操作は、すでに圧縮されているテーブルを処理するときに、ふたたび圧縮してもほとんどまたはまったく領域の節約にならないので、そのテーブルの圧縮ステップをスキップします。
      </p><p>
        <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品が生成するファイルセット。ここでは、各<span class="bold"><strong>テーブルスペース</strong></span>が圧縮されます。圧縮ファイルは、<code class="literal">.ibz</code> ファイル拡張子を使用して名前が変更されます。
      </p><p>
        バックアッププロセスの開始時に<span class="bold"><strong>圧縮</strong></span>を適用すると、圧縮プロセス中のストレージオーバーヘッドを回避し、バックアップファイルを別のサーバーに転送するときのネットワークオーバーヘッドを回避するのに役立ちます。<span class="bold"><strong>バイナリログ</strong></span>を<span class="bold"><strong>適用する</strong></span>プロセスはさらに時間がかかるようになり、バックアップファイルの圧縮解除が必要になります。
      </p><p><a class="glossseealso" href="glossary.html#glos_apply">適用</a>, <a class="glossseealso" href="glossary.html#glos_binary_log">バイナリログ</a>, <a class="glossseealso" href="glossary.html#glos_compression">圧縮</a>, <a class="glossseealso" href="glossary.html#glos_hot_backup">ホットバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_tablespace">テーブルスペース</a>も参照</p></dd><dt><a name="glos_compression_failure"></a><span class="glossterm">圧縮失敗</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986953680"></a>
        実際にはエラーではなくむしろ、<span class="bold"><strong>圧縮</strong></span>を <span class="bold"><strong>DML</strong></span> 操作と組み合わせて使用するときに起きる可能性のある負荷のかかる操作です。これは、圧縮<span class="bold"><strong>ページ</strong></span>への更新が変更記録に予約されたページ上の領域からオーバーフローするとき、すべての変更がテーブルデータに適用してページが再度圧縮されたとき、再圧縮されたデータが元のページ上で適合せず、MySQL がデータを 2 つの新しいページに分割しそれぞれを個別に圧縮するように要求するときに起こります。この状況の頻度を確認するには、テーブル <code class="literal">INFORMATION_SCHEMA.INNODB_CMP</code> を照会し、<code class="literal">COMPRESS_OPS</code> カラムの値が <code class="literal">COMPRESS_OPS_OK</code> カラムの値をどれだけ超えているかをチェックしてください。理論的には、圧縮失敗はめったに起こりません。起きた場合でも、構成オプション <code class="literal">innodb_compression_level</code>、<code class="literal">innodb_compression_failure_threshold_pct</code>、および <code class="literal">innodb_compression_pad_pct_max</code> を調整できます。
      </p><p><a class="glossseealso" href="glossary.html#glos_compression">圧縮</a>, <a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>も参照</p></dd><dt><a name="glos_compressed_row_format"></a><span class="glossterm">圧縮行フォーマット</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986966992"></a>
        <code class="literal">InnoDB</code> テーブルのデータおよびインデックス<span class="bold"><strong>圧縮</strong></span>を有効にする<span class="bold"><strong>行フォーマット</strong></span>。これは、<code class="literal">InnoDB</code> Plugin で導入され、<span class="bold"><strong>Barracuda</strong></span> ファイル形式の一部として利用できます。ラージフィールドは、<span class="bold"><strong>動的行フォーマット</strong></span>と同様に、残りの行データを保持するページとは別に格納されます。インデックスページとラージフィールドの両方が圧縮され、メモリーとディスクの節約をもたらします。データの構造に応じて、メモリーおよびディスク使用量の減少は、使用時にデータを圧縮解除するときのパフォーマンスオーバーヘッドを上回る場合も、上回らない場合もあります。使用法の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-compression" title="14.7 InnoDB 圧縮テーブル">セクション14.7「InnoDB 圧縮テーブル」</a>を参照してください。
      </p><p>
        <code class="literal">InnoDB</code> <code class="literal">COMPRESSED</code> 行フォーマットの追加情報については、<a class="xref" href="innodb-storage-engine.html#innodb-row-format-dynamic" title="14.9.3 DYNAMIC および COMPRESSED 行フォーマット">セクション14.9.3「DYNAMIC および COMPRESSED 行フォーマット」</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_barracuda">Barracuda</a>, <a class="glossseealso" href="glossary.html#glos_compression">圧縮</a>, <a class="glossseealso" href="glossary.html#glos_dynamic_row_format">動的行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_row_format">行フォーマット</a>も参照</p></dd><dt><a name="glos_young"></a><span class="glossterm">新しい</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978987003312"></a>
        <code class="literal">InnoDB</code> <span class="bold"><strong>バッファープール</strong></span>内の<span class="bold"><strong>ページ</strong></span>の特性。最近アクセスされたことがあるため、バッファープールデータ構想内で移動され、<span class="bold"><strong>LRU</strong></span> アルゴリズによってすぐに<span class="bold"><strong>フラッシュ</strong></span>されないことを意味します。この用語は、バッファープールに関連するテーブルの一部の<span class="bold"><strong>情報スキーマ</strong></span>カラム名で使用されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_flush">フラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_information_schema">INFORMATION_SCHEMA</a>, <a class="glossseealso" href="glossary.html#glos_lru">LRU</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>も参照</p></dd><dt><a name="glos_implicit_row_lock"></a><span class="glossterm">暗黙の行ロック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986914928"></a>
        明確にリクエストしなくても、InnoDB が一貫性を保証するために獲得する行ロック。
      </p><p><a class="glossseealso" href="glossary.html#glos_row_lock">行ロック</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">イ</h3><dl><dt><a name="glos_instance"></a><span class="glossterm">インスタンス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986866880"></a>
        単一の <span class="bold"><strong>mysqld</strong></span> デーモン。<span class="bold"><strong>テーブル</strong></span>のセットで 1 つ以上の<span class="bold"><strong>データベース</strong></span>を表す<span class="bold"><strong>データディレクトリ</strong></span>を管理します。同じ<span class="bold"><strong>サーバー</strong></span>マシン上に複数のインスタンスを持ち、それぞれが専用のデータディレクトリを管理し、独自のポートまたはソケットで待機することは、開発、テスト、および一部の<span class="bold"><strong>レプリケーション</strong></span>シナリオにおいて一般的です。あるインスタンスが<span class="bold"><strong>ディスクバウンド</strong></span>ワークロードを実行している状態でも、サーバーは追加インスタンスを実行するために余分な CPU およびメモリー容量を持つことができます。
      </p><p><a class="glossseealso" href="glossary.html#glos_data_directory">データディレクトリ</a>, <a class="glossseealso" href="glossary.html#glos_database">データベース</a>, <a class="glossseealso" href="glossary.html#glos_disk_bound">ディスクバウンド</a>, <a class="glossseealso" href="glossary.html#glos_mysqld">mysqld</a>, <a class="glossseealso" href="glossary.html#glos_replication">レプリケーション</a>, <a class="glossseealso" href="glossary.html#glos_server">サーバー</a>も参照</p></dd><dt><a name="glos_instrumentation"></a><span class="glossterm">インストゥルメンテーション</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986855984"></a>
        ソースコードレベルでの、チューニングおよびデバッグのパフォーマンスデータを収集するための変更。MySQL では、インストゥルメンテーションによって収集されるデータは、<code class="literal">INFORMATION_SCHEMA</code> および <code class="literal">PERFORMANCE_SCHEMA</code> データベースを使用して SQL インタフェース経由で公開されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_information_schema">INFORMATION_SCHEMA</a>, <a class="glossseealso" href="glossary.html#glos_performance_schema">パフォーマンススキーマ</a>も参照</p></dd><dt><a name="glos_intention_lock"></a><span class="glossterm">インテンションロック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986798752"></a>
        テーブルレベルに適用するタイプの<span class="bold"><strong>ロック</strong></span>。トランザクションがテーブル内の行でどんなタイプのロックを獲得しようとしているかを示すために使用されます。トランザクションごとに異なる種類のインテンションロックを取得できますが、最初のトランザクションがあるテーブルで <span class="bold"><strong>インテンション排他</strong></span> (IX) ロックを獲得すると、ほかのトランザクションはそのテーブルで S または X ロックを獲得できません。反対に、最初のトランザクションがあるテーブルで<span class="bold"><strong>インテンション共有</strong></span> (IS) ロックを獲得すると、ほかのトランザクションはそのテーブルで X ロックを獲得できません。2 フェーズプロセスは、ロックおよび互換性のある対応操作をブロックせずに、ロックリクエストを順番に解決できます。このロックメカニズムの詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-lock-modes" title="14.2.3 InnoDB のロックモード">セクション14.2.3「InnoDB のロックモード」</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_lock_mode">lock mode</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>も参照</p></dd><dt><a name="glos_intention_shared_lock"></a><span class="glossterm">インテンション共有ロック</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_intention_lock">インテンションロック</a>も参照</p></dd><dt><a name="glos_intention_exclusive_lock"></a><span class="glossterm">インテンション排他ロック</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_intention_lock">インテンションロック</a>も参照</p></dd><dt><a name="glos_index"></a><span class="glossterm">インデックス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986850576"></a>
        <span class="bold"><strong>テーブル</strong></span>の<span class="bold"><strong>行</strong></span>を高速ルックアップする機能を提供するデータ構造。通常はこのために、特定の<span class="bold"><strong>カラム</strong></span>またはカラムセットのすべての値を表すツリー構造 (<span class="bold"><strong>B ツリー)</strong></span> を形成します。
      </p><p>
        InnoDB テーブルは常に、<span class="bold"><strong>主キー</strong></span>を表す<span class="bold"><strong>クラスタ化されたインデックス</strong></span>を持ちます。1 つ以上のカラムに 1 つ以上の<span class="bold"><strong>セカンダリインデックス</strong></span>を定義することもできます。セカンダリインデックスは、その構造に応じて、<span class="bold"><strong>部分</strong></span>、<span class="bold"><strong>カラム</strong></span>、または<span class="bold"><strong>複合</strong></span>インデックスとして分類できます。
      </p><p>
        インデックスは、<span class="bold"><strong>クエリー</strong></span>パフォーマンスの重要な側面です。データベースアーキテクトは、アプリケーションが必要とするデータを高速なルックアップできるように、テーブル、クエリー、およびインデックスを設計します。理想的なデータベース設計では、有用なときは<span class="bold"><strong>カバリングインデックス</strong></span>を使用します。クエリー結果は、実際のテーブルデータを読み取らずに完全にインデックスから計算されます。<span class="bold"><strong>親</strong></span>テーブルと<span class="bold"><strong>子</strong></span>テーブルの両方に値が存在するかどうかを効率的に確認するために、各<span class="bold"><strong>外部キー</strong></span>制約にもインデックスが必要です。
      </p><p>
        B ツリーインデックスがもっとも一般的ですが、<code class="literal">MEMORY</code> ストレージエンジンや InnoDB <span class="bold"><strong>適応型ハッシュインデックス</strong></span>と同様に、<span class="bold"><strong>ハッシュインデックス</strong></span>には別の種類のデータ構造が使用されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_adaptive_hash_index">適応型ハッシュインデックス</a>, <a class="glossseealso" href="glossary.html#glos_b_tree">B ツリー</a>, <a class="glossseealso" href="glossary.html#glos_child_table">子テーブル</a>, <a class="glossseealso" href="glossary.html#glos_clustered_index">クラスタ化されたインデックス</a>, <a class="glossseealso" href="glossary.html#glos_column_index">カラムインデックス</a>, <a class="glossseealso" href="glossary.html#glos_composite_index">複合インデックス</a>, <a class="glossseealso" href="glossary.html#glos_covering_index">カバリングインデックス</a>, <a class="glossseealso" href="glossary.html#glos_foreign_key">外部キー</a>, <a class="glossseealso" href="glossary.html#glos_hash_index">ハッシュインデックス</a>, <a class="glossseealso" href="glossary.html#glos_parent_table">親テーブル</a>, <a class="glossseealso" href="glossary.html#glos_partial_index">部分インデックス</a>, <a class="glossseealso" href="glossary.html#glos_primary_key">主キー</a>, <a class="glossseealso" href="glossary.html#glos_query">クエリー</a>, <a class="glossseealso" href="glossary.html#glos_row">行</a>, <a class="glossseealso" href="glossary.html#glos_secondary_index">セカンダリインデックス</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>も参照</p></dd><dt><a name="glos_index_cache"></a><span class="glossterm">インデックスキャッシュ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986823360"></a>
        InnoDB <span class="bold"><strong>全文検索</strong></span>用のトークンデータを保持するメモリー領域。<span class="bold"><strong>FULLTEXT インデックス</strong></span>の一部であるカラムでデータが挿入または更新されるときのディスク I/O を最小限に抑えるために、データをバッファリングします。インデックスキャッシュがいっぱいになると、トークンデータがディスクに書き込まれます。InnoDB <code class="literal">FULLTEXT</code> インデックスごとに独自のインデックスキャッシュが割り当てられ、そのサイズは構成オプション <code class="literal">innodb_ft_cache_size</code> で制御されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_full_text_search">全文検索</a>, <a class="glossseealso" href="glossary.html#glos_fulltext_index">FULLTEXT インデックス</a>も参照</p></dd><dt><a name="glos_index_hint"></a><span class="glossterm">インデックスヒント</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986814432"></a>
        オプティマイザが推奨する<span class="bold"><strong>インデックス</strong></span>をオーバーライドするための拡張 SQL 構文。たとえば、<code class="literal">FORCE INDEX</code>、<code class="literal">USE INDEX</code>、および <code class="literal">IGNORE INDEX</code> 句。通常は、インデックス付きカラムに値が不均等に分散されていて、<span class="bold"><strong>カーディナリティー</strong></span>を正確に見積もれないときに使用されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_cardinality">カーディナリティー</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>も参照</p></dd><dt><a name="glos_index_prefix"></a><span class="glossterm">インデックスプリフィクス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986807088"></a>
        複数のカラムに適用される<span class="bold"><strong>インデックス</strong></span> (<span class="bold"><strong>複合インデックス</strong></span>と呼ばれます) で、インデックスの先頭または末尾カラム。複合インデックスの最初の 1、2、3 などのカラムを参照するクエリーはインデックスを使用できます (クエリーがインデックス内のすべてのカラムを参照するわけではない場合でも)。
      </p><p><a class="glossseealso" href="glossary.html#glos_composite_index">複合インデックス</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>も参照</p></dd><dt><a name="glos_index_statistics"></a><span class="glossterm">インデックス統計</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_statistics">統計</a>も参照</p></dd><dt><a name="glos_in_memory_database"></a><span class="glossterm">インメモリーデータベース</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986790128"></a>
        ディスクブロックとメモリー領域間のディスク I/O および変換によるオーバーヘッドを回避するために、メモリー内にデータを保持するタイプのデータベースシステム。インメモリーデータベースの中には、持続性 (<span class="bold"><strong>ACID</strong></span> 設計概念での「D」) を犠牲にし、ハードウェア、電源、およびほかのタイプの障害に脆弱であり、そのため読み取り専用操作に適しているものがあります。ほかのインメモリーデータベースでは、変更ログをディスクに記録したり不揮発性メモリーを使用したりなどの持続性メカニズムを使用します。
      </p><p>
        同じ種類のメモリー集約的処理に対応した MySQL 機能には、InnoDB の<span class="bold"><strong>バッファープール</strong></span>、<span class="bold"><strong>アダプティブハッシュインデックス</strong></span>、および<span class="bold"><strong>読み取り専用トランザクション</strong></span>最適化、MEMORY ストレージエンジン、MyISAM キーキャッシュ、および MySQL <span class="bold"><strong>クエリーキャッシュ</strong></span>が含まれます。
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_adaptive_hash_index">適応型ハッシュインデックス</a>, <a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_disk_based">ディスクベース</a>, <a class="glossseealso" href="glossary.html#glos_read_only_transaction">読み取り専用トランザクション</a>も参照</p></dd><dt><a name="glos_temporary_table"></a><span class="glossterm">一時テーブル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986911280"></a>
        データを真に永続的にする必要がないテーブル。たとえば、一時テーブルを複雑な計算または変換の中間結果のストレージ領域として使用できます。この中間データはクラッシュ後にリカバリする必要がありません。データベース製品は、データをディスクに書き込むことや再起動をまたがってデータを保護する手段について緻密さを軽減することで、一時テーブルに対する操作パフォーマンスを手軽に改善できます。
      </p><p>
        トランザクション終了時やセッション終了時などに、データ自体が所定時に自動的に削除されることもあります。一部のデータベース製品では、テーブル自体も自動的に削除されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_table">テーブル</a>も参照</p></dd><dt><a name="glos_temporary_tablespace"></a><span class="glossterm">一時テーブルスペース</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986906864"></a>
        非圧縮 <code class="literal">InnoDB</code> 一時テーブルと関連オブジェクト用のテーブルスペース。このテーブルスペースは MySQL 5.7.1 で導入されました。構成ファイルオプション <code class="literal">innodb_temp_data_file_path</code> は、ユーザーが一時データファイルの相対パスを定義することを許可します。<code class="literal">innodb_temp_data_file_path</code> が指定されない場合のデフォルト動作は、データディレクトリ内に <code class="filename">ibdata1</code> と一緒に、<code class="filename">ibtmp1</code> という名前の単一自動拡張 12M バイトデータファイルを作成することです。一時テーブルスペースは、サーバー起動ごとに再作成され、動的に生成されるスペース ID を受け取ります。これは、既存のスペース ID との競合回避に役立ちます。一時テーブルスペースを raw デバイスに置くことはできません。一時テーブルを作成できないときまたは作成時のエラーは致命的と扱われ、サーバー起動が拒否されます。
      </p><p>
        このテーブルスペースは、通常シャットダウンまたは初期中断 (たとえば、ユーザーが間違った起動オプションを指定したときに発生する可能性がある) 時は削除されます。一時テーブルスペースはクラッシュ発生時は削除されません。この場合、データベース管理者はこのテーブルスペースを手動で削除したり、同じ構成でサーバーを再起動 (一時テーブルスペースが削除されて再作成されます) したりできます。
      </p><p><a class="glossseealso" href="glossary.html#glos_ibtmp_file">ibtmp ファイル</a>も参照</p></dd><dt><a name="glos_general_query_log"></a><span class="glossterm">一般クエリーログ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986879504"></a>
        MySQL Server によって処理された SQL ステートメントの診断およびトラブルシューティングに使用されるタイプの<span class="bold"><strong>ログ</strong></span>。ファイルまたはデータベーステーブルにも格納できます。この機能を使用するには、<code class="literal">general_log</code> 構成オプションを通じて有効にする必要があります。<code class="literal">sql_log_off</code> 構成オプションを通じて特定の接続に対してこれを無効にできます。
      </p><p>
        <span class="bold"><strong>スロークエリーログ</strong></span>よりも広い範囲のクエリーを記録します。レプリケーションに使用される<span class="bold"><strong>バイナリログ</strong></span>とは異なり、一般クエリーログは <code class="literal">SELECT</code> ステートメントを含み、厳密な順序を維持しません。詳細は、<a class="xref" href="server-administration.html#query-log" title="5.2.3 一般クエリーログ">セクション5.2.3「一般クエリーログ」</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_binary_log">バイナリログ</a>, <a class="glossseealso" href="glossary.html#glos_general_query_log">一般クエリーログ</a>, <a class="glossseealso" href="glossary.html#glos_log">ログ</a>も参照</p></dd><dt><a name="glos_general_log"></a><span class="glossterm">一般ログ</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_general_query_log">一般クエリーログ</a>も参照</p></dd><dt><a name="glos_consistent_read"></a><span class="glossterm">一貫性読み取り</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986897328"></a>
        同時に実行しているほかのトランザクションによって行われる変更にかかわらず、スナップショット情報を使用して特定の時点に基づくクエリー結果を提示する読み取り操作。照会されるデータが別のトランザクションによって変更されている場合、元のデータは <span class="bold"><strong>Undo ログ</strong></span>の内容に基づいて再構築されます。この方法は、ほかのトランザクションが終了するのを待機するようにトランザクションを強制することによって、<span class="bold"><strong>並列性</strong></span>を減少させる可能性のあるいくつかの<span class="bold"><strong>ロック</strong></span>問題を回避します。
      </p><p>
        <span class="bold"><strong>反復可能読み取り</strong></span>分離レベルでは、スナップショットは最初の読み取り操作が実行された時点に基づきます。<span class="bold"><strong>コミットされた読み取り</strong></span>分離レベルでは、スナップショットはそれぞれの一貫性読み取り操作の時点にリセットされます。
      </p><p>
        一貫性読み取りは、InnoDB が <span class="bold"><strong>READ COMMITTED</strong></span> および <span class="bold"><strong>REPEATABLE READ</strong></span> 分離レベルで <code class="literal">SELECT</code> ステートメントを処理する際のデフォルトモードです。一貫性読み取りはアクセスするテーブルでロックを設定しないので、テーブルで一貫性読み取りが実行されている間、ほかのセッションはそれらのテーブルを自由に変更できます。
      </p><p>
        適用可能な分離レベルの技術的な詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-consistent-read" title="14.2.4 一貫性非ロック読み取り">セクション14.2.4「一貫性非ロック読み取り」</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_concurrency">並列性</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_mvcc">MVCC</a>, <a class="glossseealso" href="glossary.html#glos_read_committed">READ COMMITTED</a>, <a class="glossseealso" href="glossary.html#glos_read_uncommitted">READ UNCOMMITTED</a>, <a class="glossseealso" href="glossary.html#glos_repeatable_read">REPEATABLE READ</a>, <a class="glossseealso" href="glossary.html#glos_serializable">SERIALIZABLE</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>, <a class="glossseealso" href="glossary.html#glos_undo_log">Undo ログ</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ウ</h3><dl><dt><a name="glos_warm_up"></a><span class="glossterm">ウォームアップ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986778960"></a>
        起動後の一定期間、標準的な<span class="bold"><strong>ワークロード</strong></span>でシステムを実行すること。通常の状況時のように<span class="bold"><strong>バッファープール</strong></span>とほかのメモリー領域がいっぱいになります。
      </p><p>
        このプロセスは、MySQL Server が再起動したり新しいワークロードを課せられたりしたときに、一定時間をかけて自然に発生します。MySQL 5.6 以降では、構成変数 <code class="literal">innodb_buffer_pool_dump_at_shutdown=ON</code> および <code class="literal">innodb_buffer_pool_load_at_startup=ON</code> を設定して再起動後にバッファープールの内容をメモリーに戻すことによって、ウォームアッププロセスを高速化できます。通常は、複数の実行間で一貫した結果を保証するために、一定期間ワークロードを実行してバッファープールをウォームアップしてから、パフォーマンステストを実行してください。そのようにしない場合、パフォーマンスが最初の実行中に不自然に低くなる場合があります。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_workload">ワークロード</a>も参照</p></dd><dt><a name="glos_warm_backup"></a><span class="glossterm">ウォームバックアップ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986770496"></a>
        データベースの実行中に行われるが、バックアッププロセス中に一部のデータベース操作を制限する<span class="bold"><strong>バックアップ</strong></span>。たとえば、テーブルが読み取り専用になることがあります。ビジーなアプリケーションおよび Web サイトの場合、<span class="bold"><strong>ホットバックアップ</strong></span>をお勧めします。
      </p><p><a class="glossseealso" href="glossary.html#glos_backup">バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_cold_backup">コールドバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_hot_backup">ホットバックアップ</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">エ</h3><dl><dt><a name="glos_extent"></a><span class="glossterm">エクステント</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986755360"></a>
        <span class="bold"><strong>テーブルスペース</strong></span>内の<span class="bold"><strong>ページ</strong></span>のグループ。16K バイトのデフォルト<span class="bold"><strong>ページサイズ</strong></span>では、エクステントに 64 ページが含まれます。MySQL 5.6 では、<code class="literal">InnoDB</code> インスタンスのページサイズには 4K バイト、8K バイト、16K バイトがあり、<code class="literal">innodb_page_size</code> 構成オプションで制御されます。4K バイト、8K バイト、および 16K バイトのページサイズでは、エクステントサイズは常に 1M バイト (つまり 1048576 バイト) です。
      </p><p>
        32K バイトおよび 64K バイトの <code class="literal">InnoDB</code> ページサイズのサポートが MySQL 5.7.6 で追加されました。32K バイトページサイズの場合、エクステントサイズは 2M バイトです。64K バイトページサイズの場合、エクステントサイズは 4M バイトです。
      </p><p>
        <span class="bold"><strong>セグメント</strong></span>、<span class="bold"><strong>先読み</strong></span>リクエスト、および<span class="bold"><strong>二重書き込みバッファー</strong></span>などの <code class="literal">InnoDB</code> 機能は、一度に 1 つのエクステントでデータの読み取り、書き込み、割り当て、または解放を行う I/O 操作を使用します。
      </p><p><a class="glossseealso" href="glossary.html#glos_doublewrite_buffer">二重書き込みバッファー</a>, <a class="glossseealso" href="glossary.html#glos_neighbor_page">隣接ページ</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>, <a class="glossseealso" href="glossary.html#glos_page_size">page size</a>, <a class="glossseealso" href="glossary.html#glos_read_ahead">先読み</a>, <a class="glossseealso" href="glossary.html#glos_segment">セグメント</a>, <a class="glossseealso" href="glossary.html#glos_tablespace">テーブルスペース</a>も参照</p></dd><dt><a name="glos_eviction"></a><span class="glossterm">エビクション</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986739808"></a>
        キャッシュや、InnoDB <span class="bold"><strong>バッファープール</strong></span>などのほかの一時ストレージ領域から項目を削除する処理。常にではないけれども多くの場合、<span class="bold"><strong>LRU</strong></span> アルゴリズムを使用して、削除する項目を決定します。<span class="bold"><strong>ダーティーページ</strong></span>が削除されるとき、その内容はディスクに<span class="bold"><strong>フラッシュ</strong></span>され、<span class="bold"><strong>隣接するダーティー</strong></span>ページもフラッシュされる可能性があります。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_dirty_page">ダーティーページ</a>, <a class="glossseealso" href="glossary.html#glos_flush">フラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_lru">LRU</a>も参照</p></dd><dt><a name="glos_error_log"></a><span class="glossterm">エラーログ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986731376"></a>
        MySQL 起動に関する情報と、重要な実行時エラーおよび<span class="bold"><strong>クラッシュ</strong></span>情報を示すタイプの<span class="bold"><strong>ログ</strong></span>。詳細は、<a class="xref" href="server-administration.html#error-log" title="5.2.2 エラーログ">セクション5.2.2「エラーログ」</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_crash">クラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_log">ログ</a>も参照</p></dd><dt><a name="glos_persistent_statistics"></a><span class="glossterm">永続的統計</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986764048"></a>
        MySQL 5.6 の機能の 1 つ。ディスク上の InnoDB <span class="bold"><strong>テーブル</strong></span>の<span class="bold"><strong>インデックス</strong></span>統計を格納し、<span class="bold"><strong>クエリー</strong></span>の<span class="bold"><strong>計画安定性</strong></span>が向上します。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-persistent-stats" title="14.13.16.1 永続的オプティマイザ統計のパラメータの構成">セクション14.13.16.1「永続的オプティマイザ統計のパラメータの構成」</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_optimizer">オプティマイザ</a>, <a class="glossseealso" href="glossary.html#glos_plan_stability">計画安定性</a>, <a class="glossseealso" href="glossary.html#glos_query">クエリー</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">オ</h3><dl><dt><a name="glos_off_page_column"></a><span class="glossterm">オフページカラム</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986683520"></a>
        長すぎるため <span class="bold"><strong>B ツリー</strong></span>ページに収まらない可変長データを含むカラム (<code class="literal">BLOB</code> や <code class="literal">VARCHAR</code> など)。データは<span class="bold"><strong>オーバーフローページ</strong></span>に格納されます。このようなストレージには、InnoDB <span class="bold"><strong>Barracuda</strong></span> ファイル形式の <code class="literal">DYNAMIC</code> 行フォーマットが、古い <code class="literal">COMPACT</code> 行フォーマットよりも効率的です。
      </p><p><a class="glossseealso" href="glossary.html#glos_b_tree">B ツリー</a>, <a class="glossseealso" href="glossary.html#glos_barracuda">Barracuda</a>, <a class="glossseealso" href="glossary.html#glos_overflow_page">オーバーフローページ</a>も参照</p></dd><dt><a name="glos_option"></a><span class="glossterm">オプション</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986717376"></a>
        MySQL の構成パラメータ。<span class="bold"><strong>オプションファイル</strong></span>に格納されるか、コマンド行で渡されます。
      </p><p>
        <span class="bold"><strong>InnoDB</strong></span> テーブルに適用されるオプションの場合、各オプション名はプリフィクス <code class="literal">innodb_</code> で始まります。
      </p><p><a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>, <a class="glossseealso" href="glossary.html#glos_option_file">オプションファイル</a>も参照</p></dd><dt><a name="glos_option_file"></a><span class="glossterm">オプションファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986711104"></a>
        MySQL インスタンスの構成<span class="bold"><strong>オプション</strong></span>を保持するファイル。従来より、Linux および UNIX ではこのファイルは <code class="literal">my.cnf</code> という名前で、Windows では <code class="literal">my.ini</code> という名前です。
      </p><p><a class="glossseealso" href="glossary.html#glos_configuration_file">構成ファイル</a>, <a class="glossseealso" href="glossary.html#glos_my_cnf">my.cnf</a>, <a class="glossseealso" href="glossary.html#glos_option">オプション</a>も参照</p></dd><dt><a name="glos_optimizer"></a><span class="glossterm">オプティマイザ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986704800"></a>
        該当する<span class="bold"><strong>テーブル</strong></span>の特性とデータ分布に基づいて、<span class="bold"><strong>クエリー</strong></span>に使用する最適な<span class="bold"><strong>インデックス</strong></span>および<span class="bold"><strong>結合</strong></span>順序を決定する MySQL コンポーネント。
      </p><p><a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_join">結合</a>, <a class="glossseealso" href="glossary.html#glos_query">クエリー</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>も参照</p></dd><dt><a name="glos_optimistic"></a><span class="glossterm">オプティミスティック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986697296"></a>
        リレーショナルデータベースシステムの低レベル実装決定を導く概念。リレーショナルデータベースでパフォーマンスと<span class="bold"><strong>並列性</strong></span>が必要であることは、操作を迅速に開始またはディスパッチする必要があることを意味します。一貫性と<span class="bold"><strong>参照整合性</strong></span>が必要であることは、どの操作も失敗する可能性があることを意味します。つまり、トランザクションがロールバックされ、<span class="bold"><strong>DML</strong></span> 操作が制約を違反し、ロックのリクエストがデッドロックになり、ネットワークエラーがタイムアウトになる可能性があります。オプティミスティック戦略は、ほとんどのリクエストまたは試行が成功することを想定するもので、障害ケースに備えるための作業は相対的に少量です。この想定が true のときは、データベースは不要な作業をほとんど行いません。リクエストが失敗したときは、変更をクリーンアップして元に戻すために追加作業が必要になります。
      </p><p>
        InnoDB は、<span class="bold"><strong>ロック</strong></span>や<span class="bold"><strong>コミット</strong></span>などの操作にオプティミスティック戦略を使用します。たとえば、トランザクションによって変更されたデータは、コミットが発生する前にデータファイルに書き込むことができるため、コミット自体は非常に速いですが、トランザクションがロールバックされた場合に変更を元に戻すためにより多くの作業が必要です。
      </p><p>
        オプティミスティック戦略の反対が<span class="bold"><strong>ペシミスティック</strong></span>戦略で、信頼性が低く頻繁に失敗する操作に対応するようにシステムが最適化されます。この概念はデータベースシステムではまれです。信頼性の高いハードウェア、ネットワーク、およびアルゴリズムを選択することに非常の多くの努力が注ぎ込まれるためです。
      </p><p><a class="glossseealso" href="glossary.html#glos_commit">コミット</a>, <a class="glossseealso" href="glossary.html#glos_concurrency">並列性</a>, <a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_pessimistic">ペシミスティック</a>も参照</p></dd><dt><a name="glos_online"></a><span class="glossterm">オンライン</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986666608"></a>
        データベースのダウンタイム、ブロック、または制限された操作のないタイプの操作。通常は <span class="bold"><strong>DDL</strong></span> に適用されます。<span class="bold"><strong>高速インデックス作成</strong></span>など、制限された操作の期間を短かくする操作は、MySQL 5.6 で 幅広い<span class="bold"><strong>オンライン DDL</strong></span> 操作セットに進化しました。
      </p><p>
        バックアップのコンテキストでは、<span class="bold"><strong>ホットバックアップ</strong></span>はオンライン操作、<span class="bold"><strong>ウォームバックアップ</strong></span>は部分的にオンライン操作です。
      </p><p><a class="glossseealso" href="glossary.html#glos_ddl">DDL</a>, <a class="glossseealso" href="glossary.html#glos_fast_index_creation">高速インデックス作成</a>, <a class="glossseealso" href="glossary.html#glos_hot_backup">ホットバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_online_ddl">オンライン DDL</a>, <a class="glossseealso" href="glossary.html#glos_warm_backup">ウォームバックアップ</a>も参照</p></dd><dt><a name="glos_online_ddl"></a><span class="glossterm">オンライン DDL</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986657376"></a>
        <span class="bold"><strong>DDL</strong></span> (主に <code class="literal">ALTER TABLE</code>) 操作中の InnoDB テーブルのパフォーマンス、並列性、および可用性を改善する機能。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-online-ddl" title="14.11 InnoDB とオンライン DDL">セクション14.11「InnoDB とオンライン DDL」</a>を参照してください。
      </p><p>
        詳細は、操作の種類に応じて異なります。場合によっては、<code class="literal">ALTER TABLE</code> の進行中にテーブルを同時に変更できます。この操作はテーブルコピーを行わずに、または特別に最適化されたタイプのテーブルコピーを使用せずに実行できる場合があります。領域の使用量は、<code class="literal">innodb_online_alter_log_max_size</code> 構成オプションで制御されます。
      </p><p>
        この機能は、MySQL 5.5、および MySQL 5.1 用の InnoDB Plugin の<span class="bold"><strong>高速インデックス作成</strong></span>機能の拡張です。
      </p><p><a class="glossseealso" href="glossary.html#glos_ddl">DDL</a>, <a class="glossseealso" href="glossary.html#glos_fast_index_creation">高速インデックス作成</a>, <a class="glossseealso" href="glossary.html#glos_online">オンライン</a>も参照</p></dd><dt><a name="glos_overflow_page"></a><span class="glossterm">オーバーフローページ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986725072"></a>
        可変長カラム (<code class="literal">BLOB</code> や <code class="literal">VARCHAR</code> など) が長すぎて <span class="bold"><strong>B ツリー</strong></span>ページに収まらない場合に、それらを保持するために別個に割り当てられたディスク<span class="bold"><strong>ページ</strong></span>。関連付けられたカラムは<span class="bold"><strong>オフページカラム</strong></span>と呼ばれます。
      </p><p><a class="glossseealso" href="glossary.html#glos_b_tree">B ツリー</a>, <a class="glossseealso" href="glossary.html#glos_off_page_column">オフページカラム</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>も参照</p></dd><dt><a name="glos_parent_table"></a><span class="glossterm">親テーブル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986674224"></a>
        <span class="bold"><strong>子テーブル</strong></span>に (から) ポイントされた初期カラム値を保持する、<span class="bold"><strong>外部キー</strong></span>関係のテーブル。親テーブル内の行を削除または更新したときの結果は、外部キー定義の <code class="literal">ON UPDATE</code> および <code class="literal">ON DELETE</code> 句によって異なります。子テーブル内の対応する値の行が、それに合わせて自動的に削除または更新されたり、これらのカラムが <code class="literal">NULL</code> に設定されたり、操作が妨げられたりします。
      </p><p><a class="glossseealso" href="glossary.html#glos_child_table">子テーブル</a>, <a class="glossseealso" href="glossary.html#glos_foreign_key">外部キー</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">カ</h3><dl><dt><a name="glos_counter"></a><span class="glossterm">カウンタ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986605472"></a>
        特定の種類の <code class="literal">InnoDB</code> 操作によって増分される値。サーバーがどれだけビジーかを測定する、パフォーマンス問題の原因をトラブルシューティングする、(たとえば、クエリーが使用する構成設定またはインデックスへの) 変更が目的の低レベル効果を持っているかどうかをテストする場合に役立ちます。<span class="bold"><strong>performance_schema</strong></span> テーブルと <span class="bold"><strong>information_schema</strong></span> テーブル、特に <code class="literal">information_schema.innodb_metrics</code> を通じて、さまざまなカウンタを利用できます。
      </p><p><a class="glossseealso" href="glossary.html#glos_information_schema">INFORMATION_SCHEMA</a>, <a class="glossseealso" href="glossary.html#glos_metrics_counter">メトリックカウンタ</a>, <a class="glossseealso" href="glossary.html#glos_performance_schema">パフォーマンススキーマ</a>も参照</p></dd><dt><a name="glos_covering_index"></a><span class="glossterm">カバリングインデックス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986570384"></a>
        クエリーによって取得されたすべてのカラムを含む<span class="bold"><strong>インデックス</strong></span>。完全なテーブル行を見つけるためのポインタとしてインデックス値を使用する代わりに、クエリーはインデックス構造から値を返し、ディスク I/O を節約します。InnoDB <span class="bold"><strong>セカンダリインデックス</strong></span>には主キーカラムも含まれるので、InnoDB は MyISAM よりも多くのインデックスにこの最適化方法を適用できます。InnoDB は、トランザクションが終わるまで、そのトランザクションによって変更されたテーブルに対するクエリーにこの方法を適用できません。
      </p><p>
        正しいクエリーの場合、どの<span class="bold"><strong>カラムインデックス</strong></span>または<span class="bold"><strong>複合インデックス</strong></span>でも、カバリングインデックスとして機能できます。可能な場合は必ず、この最適化方法を活用するようにインデックスおよびクエリーを設計してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_column_index">カラムインデックス</a>, <a class="glossseealso" href="glossary.html#glos_composite_index">複合インデックス</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_secondary_index">セカンダリインデックス</a>も参照</p></dd><dt><a name="glos_column"></a><span class="glossterm">カラム</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986557040"></a>
        ストレージおよびセマンティクスがデータ型によって定義される、<span class="bold"><strong>行</strong></span>内のデータ項目。それぞれの<span class="bold"><strong>テーブル</strong></span>および<span class="bold"><strong>インデックス</strong></span>は主に、そこに含まれるカラムセットによって定義されます。
      </p><p>
        それぞれのカラムには<span class="bold"><strong>カーディナリティー</strong></span>値があります。カラムは、そのテーブルの<span class="bold"><strong>主キー</strong></span>であったり、主キーの一部であったりします。カラムは、<span class="bold"><strong>一意制約</strong></span>または <span class="bold"><strong>NOT NULL 制約</strong></span>、あるいはその両方により制限される場合があります。別のカラム内の値には、異なるテーブルにまたがっている場合でも、<span class="bold"><strong>外部キー</strong></span>関係によってリンクできます。
      </p><p>
        MySQL 内部操作についてディスカッションするときに、シノニムとして<span class="bold"><strong>フィールド</strong></span>が使用されることがあります。
      </p><p><a class="glossseealso" href="glossary.html#glos_cardinality">カーディナリティー</a>, <a class="glossseealso" href="glossary.html#glos_foreign_key">外部キー</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_primary_key">主キー</a>, <a class="glossseealso" href="glossary.html#glos_row">行</a>, <a class="glossseealso" href="glossary.html#glos_sql">SQL</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>, <a class="glossseealso" href="glossary.html#glos_unique_constraint">一意制約</a>も参照</p></dd><dt><a name="glos_column_index"></a><span class="glossterm">カラムインデックス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986542672"></a>
        単一カラムの<span class="bold"><strong>インデックス</strong></span>。
      </p><p><a class="glossseealso" href="glossary.html#glos_composite_index">複合インデックス</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>も参照</p></dd><dt><a name="glos_column_prefix"></a><span class="glossterm">カラムプリフィクス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986538560"></a>
        インデックスが <code class="literal">CREATE INDEX idx ON t1 (c1(N))</code> などの長さ指定で作成された場合、カラム値の最初の N 文字がインデックスに格納されます。インデックスプリフィクスを小さいまま維持すると、インデックスがコンパクトになり、メモリーとディスク I/O の節約によりパフォーマンスが向上します。(ただし、インデックスプリフィクスを小さくし過ぎると、値の異なる行がクエリーオプティマイザには重複していると見えるようになり、クエリー最適化を妨げる可能性があります。)
      </p><p>
        バイナリ値や長いテキスト文字列を含むカラムの場合、ソートは主な考慮事項ではなく、値全体をインデックスに格納すると領域が浪費されるので、インデックスは自動的に、最初の N (通常 768) 文字を使用してルックアップおよびソートを行います。
      </p><p><a class="glossseealso" href="glossary.html#glos_index">インデックス</a>も参照</p></dd><dt><a name="glos_cursor"></a><span class="glossterm">カーソル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986646064"></a>
        <span class="bold"><strong>クエリー</strong></span>、または SQL <code class="literal">WHERE</code> 句を使用する検索を実行するほかの操作の結果セットを表すために使用される内部データ構造。これは、ほかの高級言語でのイテレータのように機能し、リクエストに応じて結果セットからそれぞれの値を生成します。
      </p><p>
        通常は SQL が自動的にカーソルの処理を扱いますが、パフォーマンスが重要なコードを処理するときは内部作業を詳しく調べることができます。
      </p><p><a class="glossseealso" href="glossary.html#glos_query">クエリー</a>も参照</p></dd><dt><a name="glos_cardinality"></a><span class="glossterm">カーディナリティー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986640336"></a>
        テーブル<span class="bold"><strong>カラム</strong></span>内の異なる値の数。<span class="bold"><strong>インデックス</strong></span>が関連付けられたカラムをクエリーが参照するときに、各カラムのカーディナリティーはどのアクセス方法がもっとも効率的かに影響します。たとえば、<span class="bold"><strong>一意制約</strong></span>が適用されるカラムの場合、異なる値の数はテーブル内の行数に等しくなります。テーブル内の行数が 100 万なのに、特定のカラムの異なる値が 10 個だけの場合は、各値は (平均) 100,000 回発生します。したがって、<code class="literal">SELECT c1 FROM t1 WHERE c1 = 50;</code> などのクエリーが 1 行を返したり非常に多数の行を返したりする可能性があり、データベースサーバーはこのクエリーを <code class="literal">c1</code> のカーディナリティーに応じてさまざまに処理できます。
      </p><p>
        カラム内の値が非常に不規則に分布している場合は、カーディナリティーが最善のクエリー計画を決定するうえで適切な方法でないことがあります。たとえば、<code class="literal">SELECT c1 FROM t1 WHERE c1 = x;</code> は <code class="literal">x=50</code> のときに 1 行を返し、<code class="literal">x=30</code> のときに 100 万行を返します。このような場合、どのルックアップ方法が特定のクエリーにより効率的かについてアドバイスを伝えるために、<span class="bold"><strong>インデックスヒント</strong></span>を使用する必要があります。
      </p><p>
        カーディナリティーは、<span class="bold"><strong>複合インデックス</strong></span>の場合と同様に、複数のカラムに存在する異なる値の数にも適用できます。
      </p><p>
        InnoDB の場合、インデックスのカーディナリティーを見積もるプロセスは、<code class="literal">innodb_stats_sample_pages</code> および <code class="literal">innodb_stats_on_metadata</code> 構成オプションの影響を受けます。<span class="bold"><strong>永続的統計</strong></span>機能が有効のときは、見積もられる値はより安定します (MySQL 5.6 以降)。
      </p><p><a class="glossseealso" href="glossary.html#glos_column">カラム</a>, <a class="glossseealso" href="glossary.html#glos_composite_index">複合インデックス</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_index_hint">インデックスヒント</a>, <a class="glossseealso" href="glossary.html#glos_persistent_statistics">永続的統計</a>, <a class="glossseealso" href="glossary.html#glos_random_dive">ランダムダイブ</a>, <a class="glossseealso" href="glossary.html#glos_selectivity">選択性</a>, <a class="glossseealso" href="glossary.html#glos_unique_constraint">一意制約</a>も参照</p></dd><dt><a name="glos_unique_index"></a><span class="glossterm">一意のインデックス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986584640"></a>
        <span class="bold"><strong>一意制約</strong></span>が適用されるカラムまたはカラムセットのインデックス。インデックスが重複値を含まないことがわかっているので、特定の種類のルックアップとカウント操作が通常の種類のインデックスよりも効率的になります。このタイプのインデックスに対するほとんどのルックアップは、単純に特定の値が存在するかどうかを判断することです。インデックス内の値の数は、テーブル内の行数と同じであるか、関連付けられたカラムが NULL 以外の値である行の数以上です。
      </p><p>
        <span class="bold"><strong>挿入バッファリング</strong></span>最適化は一意のインデックスに適用されません。回避策として、InnoDB テーブルへの一括データロード中に一時的に <code class="literal">unique_checks=0</code> を設定できます。
      </p><p><a class="glossseealso" href="glossary.html#glos_cardinality">カーディナリティー</a>, <a class="glossseealso" href="glossary.html#glos_insert_buffering">挿入バッファリング</a>, <a class="glossseealso" href="glossary.html#glos_unique_constraint">一意制約</a>, <a class="glossseealso" href="glossary.html#glos_unique_key">一意のキー</a>も参照</p></dd><dt><a name="glos_unique_key"></a><span class="glossterm">一意のキー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986576176"></a>
        <span class="bold"><strong>一意のインデックス</strong></span>を構成するカラムセット (1 つまたは複数)。正確に 1 行に一致する <code class="literal">WHERE</code> 条件を定義でき、クエリーが関連付けられた一意のインデックスを使用できるときは、ルックアップおよびエラー処理を非常に効率的に実行できます。
      </p><p><a class="glossseealso" href="glossary.html#glos_cardinality">カーディナリティー</a>, <a class="glossseealso" href="glossary.html#glos_unique_constraint">一意制約</a>, <a class="glossseealso" href="glossary.html#glos_unique_index">一意のインデックス</a>も参照</p></dd><dt><a name="glos_unique_constraint"></a><span class="glossterm">一意制約</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986591232"></a>
        重複値をカラムに含むことができないと表明するタイプの<span class="bold"><strong>制約</strong></span>。<span class="bold"><strong>リレーショナル</strong></span>代数の観点では、1 対 1 関係を指定するために使用されます。ある値を挿入できるかどうかをチェックするときの効率性のために (つまり、その値がカラムにまだ存在していない)、一意制約が基礎となる<span class="bold"><strong>一意のインデックス</strong></span>でサポートされます。
      </p><p><a class="glossseealso" href="glossary.html#glos_constraint">制約</a>, <a class="glossseealso" href="glossary.html#glos_relational">リレーショナル</a>, <a class="glossseealso" href="glossary.html#glos_unique_index">一意のインデックス</a>も参照</p></dd><dt><a name="glos_availability"></a><span class="glossterm">可用性</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986561264"></a>
        ホストでの障害 (MySQL、オペレーティングシステム、ハードウェア、メンテナンス作業での障害を含む) に対処し、必要に応じてリカバリする能力 (ない場合は、ダウンタイムが発生する可能性があります)。多くの場合、大規模開発の重要な側面として、<span class="bold"><strong>スケーラビリティー</strong></span>と組み合わされます。
      </p><p><a class="glossseealso" href="glossary.html#glos_scalability">スケーラビリティー</a>も参照</p></dd><dt><a name="glos_foreign_key"></a><span class="glossterm">外部キー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986620224"></a>
        個別の InnoDB テーブル内の行の間のポインタ関係。外部キー関係は、<span class="bold"><strong>親テーブル</strong></span>および<span class="bold"><strong>子テーブル</strong></span>の 1 つのカラムに定義されます。
      </p><p>
        外部キーは、関連情報の高速ルックアップを有効にすることに加えて、データが挿入、更新、および削除されるときにこれらのポインタが無効になるのを防ぐことによって<span class="bold"><strong>参照整合性</strong></span>を適用するのに役立ちます。この適用メカニズムは一種の<span class="bold"><strong>制約</strong></span>です。別のテーブルをポイントする行は、関連付けられた外部キー値がその別のテーブルに存在しない場合、挿入できません。行が削除されているか、その外部キー値が変化していて、別のテーブル内の行がその外部キー値をポイントしている場合は、削除を防止したり、ほかのテーブル内の対応するカラム値が <span class="bold"><strong>NULL</strong></span> になるようにしたり、ほかのテーブル内の対応する行を自動的に削除したりするように外部キーを設定できます。
      </p><p>
        <span class="bold"><strong>正規化</strong></span>データベースを設計する際の段階の 1 つは、複製されるデータを特定し、そのデータを新しいテーブルに分離し、<span class="bold"><strong>結合</strong></span>操作を使用して複数のテーブルを単一テーブルのように照会できるように外部キー関係を設定することです。
      </p><p><a class="glossseealso" href="glossary.html#glos_child_table">子テーブル</a>, <a class="glossseealso" href="glossary.html#glos_foreign_key_constraint">FOREIGN KEY 制約</a>, <a class="glossseealso" href="glossary.html#glos_join">結合</a>, <a class="glossseealso" href="glossary.html#glos_normalized">正規化</a>, <a class="glossseealso" href="glossary.html#glos_null">NULL</a>, <a class="glossseealso" href="glossary.html#glos_parent_table">親テーブル</a>, <a class="glossseealso" href="glossary.html#glos_referential_integrity">参照整合性</a>, <a class="glossseealso" href="glossary.html#glos_relational">リレーショナル</a>も参照</p></dd><dt><a name="glos_full_backup"></a><span class="glossterm">完全バックアップ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986533264"></a>
        各 MySQL <span class="bold"><strong>データベース</strong></span>内のすべての<span class="bold"><strong>テーブル</strong></span>と MySQL <span class="bold"><strong>インスタンス</strong></span>内のすべてのデータベースを含む<span class="bold"><strong>バックアップ</strong></span>。<span class="bold"><strong>部分バックアップ</strong></span>と対比してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_backup">バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_database">データベース</a>, <a class="glossseealso" href="glossary.html#glos_instance">インスタンス</a>, <a class="glossseealso" href="glossary.html#glos_partial_backup">部分バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>も参照</p></dd><dt><a name="glos_write_combining"></a><span class="glossterm">書き込み結合</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986597984"></a>
        <span class="bold"><strong>ダーティーページ</strong></span>が InnoDB <span class="bold"><strong>バッファープール</strong></span>から<span class="bold"><strong>フラッシュ</strong></span>されるときの書き込み操作を減らす最適化手法。ページ内の行が複数回更新されたり、同じページ上の複数の行が更新されたりする場合、変更ごとに一度の書き込みではなく、単一書き込み操作でこれらのすべての変更がデータファイルに格納されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_dirty_page">ダーティーページ</a>, <a class="glossseealso" href="glossary.html#glos_flush">フラッシュ</a>も参照</p></dd><dt><a name="glos_relevance"></a><span class="glossterm">関連性</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986524512"></a>
        <span class="bold"><strong>全文検索</strong></span>機能で、検索文字列と <span class="bold"><strong>FULLTEXT インデックス</strong></span>内のデータとの間の類似性を示す数字。たとえば、単一語を検索するときに、その語は通常、一度だけ現れる行よりも、テキストに複数回発生した行に高い関連性があります。
      </p><p><a class="glossseealso" href="glossary.html#glos_full_text_search">全文検索</a>, <a class="glossseealso" href="glossary.html#glos_fulltext_index">FULLTEXT インデックス</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">キ</h3><dl><dt><a name="glos_cache"></a><span class="glossterm">キャッシュ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986499504"></a>
        頻繁または高速に取り出せるようにデータのコピーを格納するメモリー領域を表す一般的な用語。InnoDB では、主要な種類のキャッシュ構造が<span class="bold"><strong>バッファープール</strong></span>です。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer">バッファー</a>, <a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>も参照</p></dd><dt><a name="glos_gap"></a><span class="glossterm">ギャップ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986494896"></a>
        InnoDB <span class="bold"><strong>インデックス</strong></span>データ構造内で、新しい値を挿入できる場所。<code class="literal">SELECT ... FOR UPDATE</code> などのステートメントを持つ行セットをロックすると、InnoDB はインデックス内の実際の値と同様に、ギャップに適用されるロックを作成できます。たとえば、更新に 10 より大きな値をすべて選択した場合、ギャップロックはほかのトランザクションが 10 を超える新しい値を挿入するのを妨げます。<span class="bold"><strong>最小上限レコード</strong></span>と<span class="bold"><strong>最大下限レコード</strong></span>は、現在のすべてのインデックス値よりも大きな値または小さな値をすべて含むギャップを表します。
      </p><p><a class="glossseealso" href="glossary.html#glos_concurrency">並列性</a>, <a class="glossseealso" href="glossary.html#glos_gap_lock">ギャップロック</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_infimum_record">最大下限レコード</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_supremum_record">最小上限レコード</a>も参照</p></dd><dt><a name="glos_gap_lock"></a><span class="glossterm">ギャップロック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986485856"></a>
        インデックスレコード間の<span class="bold"><strong>ギャップ</strong></span>の<span class="bold"><strong>ロック</strong></span>、または先頭インデックスレコードの前や末尾インデックスレコードのあとのギャップのロック。たとえば、<code class="literal">SELECT c1 FOR UPDATE FROM t WHERE c1 BETWEEN 10 and 20;</code> は、すでにカラムにこのような値があったかどうかにかかわらず、ほかのトランザクションがカラム <code class="literal">t.c1</code> に 値 15 を挿入するのを妨ぎます。範囲内にあるすでに存在するすべての値の間のギャップがロックされるためです。<span class="bold"><strong>レコードロック</strong></span>および<span class="bold"><strong>ネクストキーロック</strong></span>と対比してください。
      </p><p>
        ギャップロックは、パフォーマンスと<span class="bold"><strong>並列性</strong></span>とのトレードオフの一環であり、一部のトランザクション<span class="bold"><strong>分離レベル</strong></span>で使用され、ほかでは使用されません。
      </p><p><a class="glossseealso" href="glossary.html#glos_gap">ギャップ</a>, <a class="glossseealso" href="glossary.html#glos_infimum_record">最大下限レコード</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_next_key_lock">ネクストキーロック</a>, <a class="glossseealso" href="glossary.html#glos_record_lock">レコードロック</a>, <a class="glossseealso" href="glossary.html#glos_supremum_record">最小上限レコード</a>も参照</p></dd><dt><a name="glos_shared_tablespace"></a><span class="glossterm">共有テーブルスペース</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986472992"></a>
        <span class="bold"><strong>システムテーブルスペース</strong></span>を参照する別の方法。
      </p><p><a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>も参照</p></dd><dt><a name="glos_shared_lock"></a><span class="glossterm">共有ロック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986469408"></a>
        <span class="bold"><strong>ロック</strong></span>の一種。ほかの<span class="bold"><strong>トランザクション</strong></span>がロックされたオブジェクトを読み取ることを許可し、それに対するほかの共有ロックを獲得することも許可するけれども、それに書き込むことは許可しません。<span class="bold"><strong>排他ロック</strong></span>の反対。
      </p><p><a class="glossseealso" href="glossary.html#glos_exclusive_lock">排他ロック</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_truncate"></a><span class="glossterm">切り捨て</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986463216"></a>
        テーブルおよび関連するインデックスを残しながら、テーブルの内容全体を削除する <span class="bold"><strong>DDL</strong></span> 操作。<span class="bold"><strong>ドロップ</strong></span>と対比してください。概念的には <code class="literal">WHERE</code> 句のない <code class="literal">DELETE</code> ステートメントと同じ結果になりますが、内部での操作は異なります。InnoDB は新しい空のテーブルを作成し、古いテーブルを削除してから、新しいテーブルの名前を変更して古いテーブルと置き換えます。これは DDL 操作なので、<span class="bold"><strong>ロールバック</strong></span>できません。
      </p><p>
        切り捨てられるテーブルに別のテーブルを参照する外部キーが含まれる場合は、<code class="literal">ON DELETE CASCADE</code> 句の必要に応じて参照先テーブル内の対応する行を削除できるように、切り捨て操作はより遅い操作方法を使用して一度に 1 行を削除します。(MySQL 5.5 以降では、このより遅い形式の切り捨てを許可しない代わりに、外部キーが含まれている場合はエラーを返します。この場合は、代わりに <code class="literal">DELETE</code> ステートメントを使用してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_ddl">DDL</a>, <a class="glossseealso" href="glossary.html#glos_drop">ドロップ</a>, <a class="glossseealso" href="glossary.html#glos_foreign_key">外部キー</a>, <a class="glossseealso" href="glossary.html#glos_rollback">ロールバック</a>も参照</p></dd><dt><a name="glos_pseudo_record"></a><span class="glossterm">疑似レコード</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986518928"></a>
        現在存在しないキー値または範囲を<span class="bold"><strong>ロック</strong></span>するために使用される、インデックス内の人為レコード。
      </p><p><a class="glossseealso" href="glossary.html#glos_infimum_record">最大下限レコード</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_supremum_record">最小上限レコード</a>も参照</p></dd><dt><a name="glos_startup"></a><span class="glossterm">起動</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986513824"></a>
        MySQL Server を起動させるプロセス。通常、<a class="xref" href="programs.html#programs-server" title="4.3 MySQL サーバーとサーバー起動プログラム">セクション4.3「MySQL サーバーとサーバー起動プログラム」</a>に示すプログラムのいずれかによって行われます。<span class="bold"><strong>シャットダウン</strong></span>の反対。
      </p><p><a class="glossseealso" href="glossary.html#glos_shutdown">シャットダウン</a>も参照</p></dd><dt><a name="glos_backticks"></a><span class="glossterm">逆引用符</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986509296"></a>
        MySQL SQL ステートメント内の識別子は、特殊文字または予約語を含んでいる場合、逆引用符文字 (<code class="literal">`</code>) で囲む必要があります。たとえば、<code class="literal">FOO#BAR</code> というテーブルまたは <code class="literal">SELECT</code> というカラムを参照するには、<code class="literal">`FOO#BAR`</code> および <code class="literal">`SELECT`</code> として識別子を指定します。逆引用符は、安全性のレベルをさらに高めるので、識別子名が前もってわかっていない可能性のあるプログラム生成の SQL ステートメントで広く使用されています。
      </p><p>
        ほかのデータベースシステムの多くでは、このような特別な名前には二重引用符 (<code class="literal">"</code>) を使用します。MySQL では移植性のために、<code class="literal">ANSI_QUOTES</code> モードを有効にして、逆引用符の代わりに二重引用符を使用して識別子名を修飾できます。
      </p><p><a class="glossseealso" href="glossary.html#glos_sql">SQL</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ク</h3><dl><dt><a name="glos_query"></a><span class="glossterm">クエリー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986450992"></a>
        <span class="bold"><strong>SQL</strong></span> で、1 つ以上の<span class="bold"><strong>テーブル</strong></span>から情報を読み取る操作。データの編成とクエリーのパラメータに応じて、ルックアップは<span class="bold"><strong>インデックス</strong></span>を参照することで最適化される可能性があります。複数のテーブルが使用される場合、そのクエリーは<span class="bold"><strong>結合</strong></span>と呼ばれます。
      </p><p>
        これまでの経緯が理由で、ステートメントの内部処理のディスカッションでは (<span class="bold"><strong>DDL</strong></span> および <span class="bold"><strong>DML</strong></span> ステートメントなどのほかのタイプの MySQL ステートメントを含めて)、「クエリー」をより広い意味で使用することがあります。
      </p><p><a class="glossseealso" href="glossary.html#glos_ddl">DDL</a>, <a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_join">結合</a>, <a class="glossseealso" href="glossary.html#glos_sql">SQL</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>も参照</p></dd><dt><a name="glos_query_log"></a><span class="glossterm">クエリーログ</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_general_query_log">一般クエリーログ</a>も参照</p></dd><dt><a name="glos_query_execution_plan"></a><span class="glossterm">クエリー実行計画</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986440080"></a>
        使用する<span class="bold"><strong>インデックス</strong></span>やテーブルを<span class="bold"><strong>結合</strong></span>する順序など、<span class="bold"><strong>クエリー</strong></span>をもっとも効率的に実行する方法についてオプティマイザによって行われる決定のセット。<span class="bold"><strong>計画安定性</strong></span>には、特定のクエリーについて一貫して行われている同じ選択が含まれます。
      </p><p><a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_join">結合</a>, <a class="glossseealso" href="glossary.html#glos_plan_stability">計画安定性</a>, <a class="glossseealso" href="glossary.html#glos_query">クエリー</a>も参照</p></dd><dt><a name="glos_client"></a><span class="glossterm">クライアント</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986403120"></a>
        リクエストをサーバーに送信し、結果を解釈または処理するタイプのプログラム。クライアントソフトウェアは、一定の時間だけ実行する場合 (メールやチャットプログラムなど) や、インタラクティブに実行する場合 (<code class="literal">mysql</code> コマンドプロセッサなど) があります。
      </p><p><a class="glossseealso" href="glossary.html#glos_mysql">mysql</a>, <a class="glossseealso" href="glossary.html#glos_server">サーバー</a>も参照</p></dd><dt><a name="glos_clustered_index"></a><span class="glossterm">クラスタ化されたインデックス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986398592"></a>
        <span class="bold"><strong>主キー</strong></span>インデックスを表す InnoDB 用語。InnoDB テーブルストレージは、主キーカラムを使用するクエリーとソートの速度を上げるために、主キーカラムの値に基づいて編成されます。パフォーマンスが最適になるように、パフォーマンスがもっとも重要なクエリーに基づいて、主キーカラムを慎重に選択してください。クラスタ化されたインデックスのカラムを変更することは負荷のかかる操作なので、まれにしか、またはまったく更新されない主カラムを選択してください。
      </p><p>
        Oracle Database 製品では、この種のテーブルは<span class="bold"><strong>インデックス編成テーブル</strong></span>と呼ばれています。
      </p><p><a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_primary_key">主キー</a>, <a class="glossseealso" href="glossary.html#glos_secondary_index">セカンダリインデックス</a>も参照</p></dd><dt><a name="glos_crash"></a><span class="glossterm">クラッシュ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986391520"></a>
        MySQL では、サーバーが通常のクリーンアップを行えない予期しない<a class="link" href="glossary.html#glos_shutdown" title="シャットダウン">シャットダウン</a>操作を一般的に示すために、用語「クラッシュ」を使用します。たとえば、クラッシュは、データベースサーバーマシンまたはストレージデバイスでのハードウェア障害、電源障害、MySQL Server の停止を招く潜在的なデータ不一致、DBA で開始された<span class="bold"><strong>高速シャットダウン</strong></span>、またはその他の多くの理由によって発生することがあります。<span class="bold"><strong>InnoDB</strong></span> テーブルの堅牢で自動的な<span class="bold"><strong>クラッシュリカバリ</strong></span>は、DBA が追加作業を行うことなく、サーバーが再起動するときにデータの一貫性を保証します。
      </p><p><a class="glossseealso" href="glossary.html#glos_crash_recovery">クラッシュリカバリ</a>, <a class="glossseealso" href="glossary.html#glos_fast_shutdown">高速シャットダウン</a>, <a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>, <a class="glossseealso" href="glossary.html#glos_redo_log">Redo ログ</a>, <a class="glossseealso" href="glossary.html#glos_shutdown">シャットダウン</a>も参照</p></dd><dt><a name="glos_crash_recovery"></a><span class="glossterm">クラッシュリカバリ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986382512"></a>
        <span class="bold"><strong>クラッシュ</strong></span>後に MySQL が再度起動したときに行われるクリーンアップアクティビティー。<span class="bold"><strong>InnoDB</strong></span> テーブルの場合、不完全なトランザクションからの変更は、<span class="bold"><strong>Redo ログ</strong></span>からのデータを使用して再現されます。クラッシュ前に<span class="bold"><strong>コミット</strong></span>されたけれども、まだ<a class="link" href="glossary.html#glos_data_files" title="データファイル">データファイル</a>に書き込まれていない変更は、<span class="bold"><strong>二重書き込みバッファー</strong></span>から再構築されます。通常どおりデータベースがシャットダウンした場合、このタイプのアクティビティーは、<span class="bold"><strong>パージ</strong></span>操作によってシャットダウン中に実行されます。
      </p><p>
        通常操作中、コミットされたデータは、データファイルに書き込まれる前に、一定期間<span class="bold"><strong>変更バッファー</strong></span>に格納できます。データファイルを最新の状態に維持すること (通常の操作中にパフォーマンスオーバーヘッドをもたらす) と、データのバッファリング (シャットダウンおよびクラッシュリカバリの時間を長くする可能性がある) との間には、常にトレードオフがあります。
      </p><p><a class="glossseealso" href="glossary.html#glos_change_buffer">変更バッファー</a>, <a class="glossseealso" href="glossary.html#glos_commit">コミット</a>, <a class="glossseealso" href="glossary.html#glos_crash">クラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_data_files">データファイル</a>, <a class="glossseealso" href="glossary.html#glos_doublewrite_buffer">二重書き込みバッファー</a>, <a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>, <a class="glossseealso" href="glossary.html#glos_purge">パージ</a>, <a class="glossseealso" href="glossary.html#glos_redo_log">Redo ログ</a>も参照</p></dd><dt><a name="glos_clean_shutdown"></a><span class="glossterm">クリーンシャットダウン</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986368256"></a>
        エラーなしで完了し、終了前に InnoDB テーブルにすべての変更を適用する<span class="bold"><strong>シャットダウン</strong></span>。<span class="bold"><strong>クラッシュ</strong></span>または<span class="bold"><strong>高速シャットダウン</strong></span>とは異なります。<span class="bold"><strong>低速シャットダウン</strong></span>のシノニム。
      </p><p><a class="glossseealso" href="glossary.html#glos_crash">クラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_fast_shutdown">高速シャットダウン</a>, <a class="glossseealso" href="glossary.html#glos_shutdown">シャットダウン</a>, <a class="glossseealso" href="glossary.html#glos_slow_shutdown">低速シャットダウン</a>も参照</p></dd><dt><a name="glos_clean_page"></a><span class="glossterm">クリーンページ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986360672"></a>
        InnoDB <span class="bold"><strong>バッファープール</strong></span>内の<span class="bold"><strong>ページ</strong></span> の 1 つ。ここでは、メモリー内で行われたすべての変更が<a class="link" href="glossary.html#glos_data_files" title="データファイル">データファイル</a>にも書き込まれて (<span class="bold"><strong>フラッシュされて</strong></span>) います。<span class="bold"><strong>ダーティーページ</strong></span>の反対です。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_data_files">データファイル</a>, <a class="glossseealso" href="glossary.html#glos_dirty_page">ダーティーページ</a>, <a class="glossseealso" href="glossary.html#glos_flush">フラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>も参照</p></dd><dt><a name="glos_group_commit"></a><span class="glossterm">グループコミット</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986351760"></a>
        コミットごとに別々にフラッシュおよび同期するのではなく、一連の<span class="bold"><strong>コミット</strong></span>操作に対して一度、いくつかの低レベル I/O 操作 (<span class="bold"><strong>ログ書き込み</strong></span>) を実行する <code class="literal">InnoDB</code> 最適化。
      </p><p>
        バイナリログが有効になっているときは通常、構成オプション <code class="literal">sync_binlog=0</code> も設定してください。バイナリログのグループコミットは、これが 0 に設定されている場合にのみサポートされるためです。
      </p><p><a class="glossseealso" href="glossary.html#glos_commit">コミット</a>, <a class="glossseealso" href="glossary.html#glos_plugin">プラグイン</a>, <a class="glossseealso" href="glossary.html#glos_xa">XA</a>も参照</p></dd><dt><a name="glos_built_in"></a><span class="glossterm">組み込み</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986408832"></a>
        MySQL 内の組み込み InnoDB ストレージエンジンは、ストレージエンジンの元の配布形式です。<span class="bold"><strong>InnoDB Plugin</strong></span> と対比してください。MySQL 5.5 以降では、InnoDB Plugin は、組み込み InnoDB ストレージエンジン (InnoDB 1.1 と呼ばれます) として、MySQL コードベースに元どおりマージされます。
      </p><p>
        この区別は、主に MySQL 5.1 で重要です。ここでは、機能またはバグ修正が InnoDB Plugin に適用され、組み込み InnoDB にされない場合や、その反対の場合があります。
      </p><p><a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>, <a class="glossseealso" href="glossary.html#glos_plugin">プラグイン</a>も参照</p></dd><dt><a name="glos_row_based_replication"></a><span class="glossterm">行ベースレプリケーション</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986431088"></a>
        <span class="bold"><strong>スレーブ</strong></span>サーバーで個々の行を変更する方法を指定するイベントが、<span class="bold"><strong>マスター</strong></span>サーバーから伝播される形式の<span class="bold"><strong>レプリケーション</strong></span>。<code class="literal">innodb_autoinc_lock_mode</code> オプションのすべての設定に安全に使用できます。
      </p><p><a class="glossseealso" href="glossary.html#glos_auto_increment_locking">自動インクリメントロック</a>, <a class="glossseealso" href="glossary.html#glos_innodb_autoinc_lock_mode">innodb_autoinc_lock_mode</a>, <a class="glossseealso" href="glossary.html#glos_master_server">マスターサーバー</a>, <a class="glossseealso" href="glossary.html#glos_replication">レプリケーション</a>, <a class="glossseealso" href="glossary.html#glos_slave_server">スレーブサーバー</a>, <a class="glossseealso" href="glossary.html#glos_statement_based_replication">ステートメントベースレプリケーション</a>も参照</p></dd><dt><a name="glos_row_lock"></a><span class="glossterm">行ロック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986421936"></a>
        <span class="bold"><strong>ロック</strong></span>の 1 つ。互換性のない方法で別の<span class="bold"><strong>トランザクション</strong></span>が行にアクセスするのを防ぎます。同じテーブル内のほかの行には、ほかのトランザクションが自由に書き込むことができます。これは、<span class="bold"><strong>InnoDB</strong></span> テーブルでの <span class="bold"><strong>DML</strong></span> 操作によって行われるタイプの<span class="bold"><strong>ロック</strong></span>です。
      </p><p>
        MyISAM によって、または<span class="bold"><strong>オンライン DDL</strong></span> では行えない InnoDB テーブルでの <span class="bold"><strong>DDL</strong></span> 操作中に使用される<span class="bold"><strong>、テーブルロック</strong></span>と対比してください。これらのロックはテーブルへの同時アクセスをブロックします。
      </p><p><a class="glossseealso" href="glossary.html#glos_ddl">DDL</a>, <a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_online_ddl">オンライン DDL</a>, <a class="glossseealso" href="glossary.html#glos_table_lock">テーブルロック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ケ</h3><dl><dt><a name="glos_atomic"></a><span class="glossterm">原子的</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986321200"></a>
        SQL コンテキストでは、<span class="bold"><strong>トランザクション</strong></span>とは、完全に完了する (<span class="bold"><strong>コミット</strong></span>時)、またはまったく効果がない (<span class="bold"><strong>ロールバック</strong></span>時) 作業の単位です。トランザクションの分割できない (「原子的」) という特性は、頭字語 <span class="bold"><strong>ACID</strong></span> の「A」に当たります。
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_commit">コミット</a>, <a class="glossseealso" href="glossary.html#glos_rollback">ロールバック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_strict_mode"></a><span class="glossterm">厳密モード</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986313680"></a>
        <code class="literal">innodb_strict_mode</code> オプションで制御される設定の一般名。この設定をオンにすると、通常は警告として扱われる条件がエラーと見なされます。たとえば、<span class="bold"><strong>ファイル形式</strong></span>と<span class="bold"><strong>行フォーマット</strong></span>に関連するオプションの無効な組み合わせは、通常は警告を返してデフォルト値で継続しますが、<code class="literal">CREATE TABLE</code> 操作で失敗するようになります。
      </p><p>
        MySQL にも厳密モードと呼ばれるものがあります。
      </p><p><a class="glossseealso" href="glossary.html#glos_file_format">ファイル形式</a>, <a class="glossseealso" href="glossary.html#glos_innodb_strict_mode">innodb_strict_mode</a>, <a class="glossseealso" href="glossary.html#glos_row_format">行フォーマット</a>も参照</p></dd><dt><a name="glos_search_index"></a><span class="glossterm">検索インデックス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986329280"></a>
        MySQL の<span class="bold"><strong>全文検索</strong></span>クエリーは、特殊なインデックス、<span class="bold"><strong>FULLTEXT</strong></span> インデックスを使用します。MySQL 5.6.4 以降で、<code class="literal">InnoDB</code> および <code class="literal">MyISAM</code> テーブルの両方は <code class="literal">FULLTEXT</code> インデックスをサポートします。以前はこれらのインデックスは <code class="literal">MyISAM</code> テーブルでのみ利用可能でした。
      </p><p><a class="glossseealso" href="glossary.html#glos_full_text_search">全文検索</a>, <a class="glossseealso" href="glossary.html#glos_fulltext_index">FULLTEXT インデックス</a>も参照</p></dd><dt><a name="glos_join"></a><span class="glossterm">結合</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986338320"></a>
        同じ値を保持するテーブル内のカラムを参照することによって、複数のテーブルからデータを取得する<span class="bold"><strong>クエリー</strong></span>。理論的には、これらのカラムは InnoDB <span class="bold"><strong>外部キー</strong></span>関係の一部で、<span class="bold"><strong>参照整合性</strong></span>と、結合カラムが<span class="bold"><strong>インデックス付き</strong></span>であることを保証します。多くの場合、<span class="bold"><strong>正規化</strong></span>データ設計で、繰り返される文字列を数値 ID に置き換えることによって領域を節約してクエリーパフォーマンスを改善するために、使用されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_foreign_key">外部キー</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_normalized">正規化</a>, <a class="glossseealso" href="glossary.html#glos_query">クエリー</a>, <a class="glossseealso" href="glossary.html#glos_referential_integrity">参照整合性</a>も参照</p></dd><dt><a name="glos_plan_stability"></a><span class="glossterm">計画安定性</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986343296"></a>
        <span class="bold"><strong>クエリー実行計画</strong></span>のプロパティーの 1 つ。オプティマイザが渡された<span class="bold"><strong>クエリー</strong></span>に毎回同じ選択を行うことで、パフォーマンスが一貫して予測可能になります。
      </p><p><a class="glossseealso" href="glossary.html#glos_query">クエリー</a>, <a class="glossseealso" href="glossary.html#glos_query_execution_plan">クエリー実行計画</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">コ</h3><dl><dt><a name="glos_commit"></a><span class="glossterm">コミット</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986224448"></a>
        <span class="bold"><strong>トランザクション</strong></span>を終了させ、トランザクションによって行われた変更を永続的にする <span class="bold"><strong>SQL</strong></span> ステートメント。これは、トランザクションで行われた変更を元どおりにする<span class="bold"><strong>ロールバック</strong></span>の反対です。
      </p><p>
        InnoDB はコミットに<span class="bold"><strong>オプティミスティック</strong></span>メカニズムを使用するので、コミットが実際に行われる前に変更をデータファイルに書き込むことができます。この方法は、コミット自体をより高速にしますが、ロールバックの場合には必要な作業が増えるというトレードオフが生じます。
      </p><p>
        MySQL はデフォルトで、各 SQL ステートメントに続いてコミットを自動的に発行する<span class="bold"><strong>自動コミット</strong></span>設定を使用します。
      </p><p><a class="glossseealso" href="glossary.html#glos_autocommit">自動コミット</a>, <a class="glossseealso" href="glossary.html#glos_optimistic">オプティミスティック</a>, <a class="glossseealso" href="glossary.html#glos_rollback">ロールバック</a>, <a class="glossseealso" href="glossary.html#glos_sql">SQL</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_compact_row_format"></a><span class="glossterm">コンパクト行フォーマット</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986197184"></a>
        MySQL 5.0.3 以降のデフォルト <code class="literal">InnoDB</code> <span class="bold"><strong>行フォーマット</strong></span>。<span class="bold"><strong>Antelope</strong></span> <span class="bold"><strong>ファイル形式</strong></span>を使用するテーブルで利用できます。この Null および可変長フィールドの表現は、以前のデフォルト (<span class="bold"><strong>冗長行フォーマット</strong></span>) よりもコンパクトです。
      </p><p>
        InnoDB の <span class="bold"><strong>B ツリー</strong></span>インデックスは行ルックアップを非常に高速にするため、すべての行を同じサイズに維持することにパフォーマンス上のメリットはほとんどありません。
      </p><p>
        <code class="literal">InnoDB</code> <code class="literal">COMPACT</code> 行フォーマットの詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-row-format-antelope" title="14.9.4 COMPACT および REDUNDANT 行フォーマット">セクション14.9.4「COMPACT および REDUNDANT 行フォーマット」</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_antelope">Antelope</a>, <a class="glossseealso" href="glossary.html#glos_file_format">ファイル形式</a>, <a class="glossseealso" href="glossary.html#glos_redundant_row_format">冗長行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_row_format">行フォーマット</a>も参照</p></dd><dt><a name="glos_cold_backup"></a><span class="glossterm">コールドバックアップ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986246240"></a>
        データベースがシャットダウンしている間に行われる<span class="bold"><strong>バックアップ</strong></span>。ビジーなアプリケーションおよび Web サイトの場合は、これは実用的でない可能性があり、<span class="bold"><strong>ウォームバックアップ</strong></span>または<span class="bold"><strong>ホットバックアップ</strong></span>をお勧めします。
      </p><p><a class="glossseealso" href="glossary.html#glos_backup">バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_hot_backup">ホットバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_warm_backup">ウォームバックアップ</a>も参照</p></dd><dt><a name="glos_synthetic_key"></a><span class="glossterm">合成キー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986294352"></a>
        値が任意に割り当てられるインデックスカラム (通常は<span class="bold"><strong>主キー</strong></span>)。多くの場合、<span class="bold"><strong>自動インクリメント</strong></span>カラムを使用して行われます。完全に任意として値を扱うことによって、過度に制限されたルールと欠陥のあるアプリケーション想定を回避できます。たとえば、ある従業員が雇用を承認されたけれども、実際には入社していない場合、従業員数を表す数値シーケンスにギャップがある可能性があります。または、従業員番号 100 と従業員番号 500 が会社を退職してあとで再入社した場合、前者が後者よりもあとの雇用日になることがあります。数値も、予測可能な長さより短い値になります。たとえば、「道路」、「大通り」、「高速道路」などを意味する数値コードを格納することで、何度もこれらの文字列を繰り返すよりも領域効率が向上します。
      </p><p>
        <span class="bold"><strong>サロゲートキー</strong></span>とも呼ばれます。<span class="bold"><strong>ナチュラルキー</strong></span>と対比してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_auto_increment">自動インクリメント</a>, <a class="glossseealso" href="glossary.html#glos_natural_key">ナチュラルキー</a>, <a class="glossseealso" href="glossary.html#glos_primary_key">主キー</a>, <a class="glossseealso" href="glossary.html#glos_surrogate_key">サロゲートキー</a>も参照</p></dd><dt><a name="glos_fixed_row_format"></a><span class="glossterm">固定行フォーマット</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986239856"></a>
        この行フォーマットは、InnoDB ではなく MyISAM ストレージエンジンで使用されます。オプション <code class="literal">row_format=fixed</code> を使用して InnoDB テーブルを作成する場合、InnoDB はこのオプションの代わりに<span class="bold"><strong>コンパクト行フォーマット</strong></span>を使用するように変換します。ただし、<code class="literal">SHOW TABLE STATUS</code> レポートなどの出力には <code class="literal">fixed</code> 値が表示される場合があります。
      </p><p><a class="glossseealso" href="glossary.html#glos_compact_row_format">コンパクト行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_row_format">行フォーマット</a>も参照</p></dd><dt><a name="glos_child_table"></a><span class="glossterm">子テーブル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986232960"></a>
        <span class="bold"><strong>外部キー</strong></span>関係で子テーブルとは、その行が別のテーブル内の行を参照 (またはポイント) し、特定のカラムについて同じ値を持つもののことです。これは、<code class="literal">FOREIGN KEY ... REFERENCES</code> 句、およびオプションで <code class="literal">ON UPDATE</code> および <code class="literal">ON DELETE</code> 句を含むテーブルです。行を子テーブル内に作成するには、その前に<span class="bold"><strong>親テーブル</strong></span>内に対応する行が存在している必要があります。子テーブル内の値は、外部キーの作成時に使用される <code class="literal">ON CASCADE</code> に基づいて、親テーブルでの削除または更新操作を禁止したり、子テーブル内で自動的に削除または更新したりする場合があります。
      </p><p><a class="glossseealso" href="glossary.html#glos_foreign_key">外部キー</a>, <a class="glossseealso" href="glossary.html#glos_parent_table">親テーブル</a>も参照</p></dd><dt><a name="glos_configuration_file"></a><span class="glossterm">構成ファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986284992"></a>
        起動時に MySQL が使用する<span class="bold"><strong>オプション</strong></span>値を保持するファイル。従来より、Linux および UNIX ではこのファイルは <code class="literal">my.cnf</code> という名前で、Windows では <code class="literal">my.ini</code> という名前です。ファイルの <code class="literal">[mysqld]</code> セクションで、InnoDB に関連した多数のオプションを設定できます。
      </p><p>
        このファイルは通常、場所 <code class="filename">/etc/my.cnf</code>、<code class="filename">/etc/mysql/my.cnf</code>、<code class="filename">/usr/local/mysql/etc/my.cnf</code>、および <code class="filename">~/.my.cnf</code> で検索されます。このファイルの検索パスの詳細は、<a class="xref" href="programs.html#option-files" title="4.2.6 オプションファイルの使用">セクション4.2.6「オプションファイルの使用」</a>を参照してください。
      </p><p>
        <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品を使用するときには通常、2 つの構成ファイルを使用します。データが得られる場所と構造化される方法を指定するもの (実際のサーバー用の元の構成ファイルである場合もあります) と、バックアップデータの保存先とそれが構造化される方法を指定する小さなオプションセットを含む必要最低限のものです。<span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品で使用される構成ファイルは通常の構成ファイルには通常は含まれていないオプションを含んでいる必要があり、その場合には既存の構成ファイルに <span class="bold"><strong>MySQL Enterprise Backup</strong></span> で使用するいくつかのオプションを追加する必要がある場合があります。
      </p><p><a class="glossseealso" href="glossary.html#glos_my_cnf">my.cnf</a>, <a class="glossseealso" href="glossary.html#glos_option_file">オプションファイル</a>も参照</p></dd><dt><a name="glos_mixed_mode_insert"></a><span class="glossterm">混在モード挿入</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986213920"></a>
        <code class="literal">INSERT</code> ステートメントの 1 つ。<span class="bold"><strong>自動インクリメント</strong></span>値が新しい行のすべてではなく一部に指定されます。たとえば、複数値 <code class="literal">INSERT</code> では、一部のケースで自動インクリメントカラムの値を、ほかのケースで <code class="literal">NULL</code> を指定できます。<code class="literal">InnoDB</code> は、カラム値が <code class="literal">NULL</code> として指定された行に自動インクリメント値を生成します。別の例が、<code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> ステートメントです。ここでは、<code class="literal">INSERT</code> ではなく <code class="literal">UPDATE</code> ステートメントとして処理される重複行がある場合、それらに自動インクリメント値が生成されますが、使用されません。
      </p><p>
        <span class="bold"><strong>レプリケーション</strong></span>構成の<span class="bold"><strong>マスター</strong></span>および<span class="bold"><strong>スレーブ</strong></span>サーバー間で一貫性の問題を引き起こす可能性があります。<span class="bold"><strong>innodb_autoinc_lock_mode</strong></span> 構成オプションの値の調整が必要な場合があります。
      </p><p><a class="glossseealso" href="glossary.html#glos_auto_increment">自動インクリメント</a>, <a class="glossseealso" href="glossary.html#glos_innodb_autoinc_lock_mode">innodb_autoinc_lock_mode</a>, <a class="glossseealso" href="glossary.html#glos_master_server">マスターサーバー</a>, <a class="glossseealso" href="glossary.html#glos_replication">レプリケーション</a>, <a class="glossseealso" href="glossary.html#glos_slave_server">スレーブサーバー</a>も参照</p></dd><dt><a name="glos_descending_index"></a><span class="glossterm">降順インデックス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986300816"></a>
        一部のデータベースシステムで利用できるタイプのインデックス。ここでは <code class="literal">ORDER BY <em class="replaceable"><code>column</code></em> DESC</code> 句を処理するようにインデックスストレージが最適化されます。現在のところ、MySQL は、<code class="literal">CREATE TABLE</code> ステートメントで <code class="literal">DESC</code> キーワードを許可しますが、結果のインデックスに特殊なストレージレイアウトを使用しません。
      </p><p><a class="glossseealso" href="glossary.html#glos_index">インデックス</a>も参照</p></dd><dt><a name="glos_high_water_mark"></a><span class="glossterm">高位境界値</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986304896"></a>
        上限を表す値。実行時に超えるべきでないハード制限、または実際に到達した最大値の記録。<span class="bold"><strong>低位境界値</strong></span>と対比してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_low_water_mark">低位境界値</a>も参照</p></dd><dt><a name="glos_fast_index_creation"></a><span class="glossterm">高速インデックス作成</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986270320"></a>
        関連付けられたテーブルを完全に書き直す必要性をなくすことによって InnoDB <span class="bold"><strong>セカンダリインデックス</strong></span>の作成を高速化する、InnoDB Plugin に最初に導入されて現在 5.5 以降の MySQL Server に組み込まれている機能。高速化はセカンダリインデックスの削除にも適用されます。
      </p><p>
        インデックスを保守することで多数のデータ転送操作にパフォーマンスオーバーヘッドを増やす場合があるので、セカンダリインデックスを用意せずに <code class="literal">ALTER TABLE ... ENGINE=INNODB</code> や <code class="literal">INSERT INTO ... SELECT * FROM ...</code> などの操作を行い、あとでインデックスを作成することを検討してみてください。
      </p><p>
        MySQL 5.6 では、この機能はより一般的になっています。インデックスが作成されている間にテーブルに対する読み取りと書き込むを行うことができ、テーブルをコピーせずに、または<span class="bold"><strong>DML</strong></span> 操作をブロックせずに、あるいはその両方を行わずに、多種多様な <code class="literal">ALTER TABLE</code> 操作を実行できます。したがって、MySQL 5.6 以降では通常、この機能セットを高速インデックス作成ではなく<span class="bold"><strong>オンライン DDL</strong></span> と呼んでいます。
      </p><p>
        関連情報については、<a class="ulink" href="http://dev.mysql.com/doc/refman/5.5/en/innodb-create-index.html" target="_top">InnoDB Fast Index Creation</a>および<a class="xref" href="innodb-storage-engine.html#innodb-online-ddl" title="14.11 InnoDB とオンライン DDL">セクション14.11「InnoDB とオンライン DDL」</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_online_ddl">オンライン DDL</a>, <a class="glossseealso" href="glossary.html#glos_secondary_index">セカンダリインデックス</a>も参照</p></dd><dt><a name="glos_fast_shutdown"></a><span class="glossterm">高速シャットダウン</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986256416"></a>
        構成設定 <code class="literal">innodb_fast_shutdown=1</code> に基づいた、InnoDB のデフォルト<span class="bold"><strong>シャットダウン</strong></span>手順。時間を節約するために、特定の<span class="bold"><strong>フラッシュ</strong></span>操作がスキップされます。フラッシュ操作は次の起動中に<span class="bold"><strong>クラッシュリカバリ</strong></span>の場合と同じメカニズムを使用して実行されるので、通常の使用中にはこのタイプのシャットダウンが安全です。アップグレードまたはダウングレードのためにデータベースをシャットダウンしている場合は、代わりに<span class="bold"><strong>低速シャットダウン</strong></span>を行なって、すべての該当する変更がシャットダウン中に<span class="bold"><strong>データファイル</strong></span>に適用されることを保証してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_crash_recovery">クラッシュリカバリ</a>, <a class="glossseealso" href="glossary.html#glos_data_files">データファイル</a>, <a class="glossseealso" href="glossary.html#glos_flush">フラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_shutdown">シャットダウン</a>, <a class="glossseealso" href="glossary.html#glos_slow_shutdown">低速シャットダウン</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">サ</h3><dl><dt><a name="glos_sublist"></a><span class="glossterm">サブリスト</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986139648"></a>
        バッファープールを表すリスト構造内では、比較的古いページと比較的新しいページがリストの異なる部分で表されます。パラメータセットは、これらの部分のサイズと、新しいページと古いページ間の分割ポイントを制御します。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_eviction">エビクション</a>, <a class="glossseealso" href="glossary.html#glos_list">リスト</a>, <a class="glossseealso" href="glossary.html#glos_lru">LRU</a>も参照</p></dd><dt><a name="glos_surrogate_key"></a><span class="glossterm">サロゲートキー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986134464"></a>
        <span class="bold"><strong>合成キー</strong></span>のシノニム名。
      </p><p><a class="glossseealso" href="glossary.html#glos_synthetic_key">合成キー</a>も参照</p></dd><dt><a name="glos_server"></a><span class="glossterm">サーバー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986184368"></a>
        継続的に実行するタイプのプログラム。別のプログラム (クライアント) からリクエストを受信しそれに基づいて行動するのを待機します。多くの場合、コンピュータ全体が 1 つ以上のサーバープログラムを実行することを目的とするため (データベースサーバー、Web サーバー、アプリケーションサーバー、これらの組み合わせなど)、用語<span class="bold"><strong>サーバー</strong></span>はサーバーソフトウェアを実行するコンピュータを指す場合もあります。
      </p><p><a class="glossseealso" href="glossary.html#glos_client">クライアント</a>, <a class="glossseealso" href="glossary.html#glos_mysqld">mysqld</a>も参照</p></dd><dt><a name="glos_read_ahead"></a><span class="glossterm">先読み</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986164880"></a>
        これらのページがすぐに必要になると予想して、非同期的に<span class="bold"><strong>ページ</strong></span> (<span class="bold"><strong>エクステント</strong></span>全体) のグループを<span class="bold"><strong>バッファープール</strong></span>にプリフェッチするタイプの I/O リクエスト。線形先読み方法は、 1 エクステントのすべてのページを、先行するエクステント内のページのアクセスパターンに基づいてプリフェッチするもので、InnoDB Plugin for MySQL 5.1 で始まるすべての MySQL バージョンに組み込まれています。ランダム先読み方法は、エクステントから特定数のページがバッファープールに入ると、同じエクステントのすべてのページをプリフェッチするものです。ランダム先読みは、MySQL 5.5 には組み込まれていませんが、<code class="literal">innodb_random_read_ahead</code> 構成オプションの制御下で、MySQL 5.6 に再導入されています。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_extent">エクステント</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>も参照</p></dd><dt><a name="glos_delete"></a><span class="glossterm">削除</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986156544"></a>
        InnoDB が <code class="literal">DELETE</code> ステートメントを処理すると、行が即座に削除とマークされ、これ以降クエリーから返されなくなります。ストレージは以降の任意の時点で、別のスレッドによって実行される、<span class="bold"><strong>パージ</strong></span>操作と呼ばれる定期的ガベージコレクション中に解放されます。大量のデータを削除する場合、独自のパフォーマンス特性を持つ関連操作は、<span class="bold"><strong>切り捨て</strong></span>および<span class="bold"><strong>ドロップ</strong></span>です。
      </p><p><a class="glossseealso" href="glossary.html#glos_drop">ドロップ</a>, <a class="glossseealso" href="glossary.html#glos_purge">パージ</a>, <a class="glossseealso" href="glossary.html#glos_truncate">切り捨て</a>も参照</p></dd><dt><a name="glos_delete_buffering"></a><span class="glossterm">削除バッファリング</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986149008"></a>
        <code class="literal">DELETE</code> 操作によるインデックス変更を即座に書き込むのではなく、<span class="bold"><strong>挿入バッファー</strong></span>に格納して、物理的な書き込みを実行してランダム I/O を最小限に抑える方法。(削除操作は 2 ステッププロセスなので、この操作は、通常はインデックスレコードに削除とマークする書き込みをバッファーに入れます。)これは<span class="bold"><strong>変更バッファリング</strong></span>の一種です。ほかのタイプには<span class="bold"><strong>挿入バッファリング</strong></span>と<span class="bold"><strong>パージバッファリング</strong></span>があります。
      </p><p><a class="glossseealso" href="glossary.html#glos_change_buffer">変更バッファー</a>, <a class="glossseealso" href="glossary.html#glos_change_buffering">変更バッファリング</a>, <a class="glossseealso" href="glossary.html#glos_insert_buffer">挿入バッファー</a>, <a class="glossseealso" href="glossary.html#glos_insert_buffering">挿入バッファリング</a>, <a class="glossseealso" href="glossary.html#glos_purge_buffering">パージバッファリング</a>も参照</p></dd><dt><a name="glos_referential_integrity"></a><span class="glossterm">参照整合性</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986130752"></a>
        常に一貫する形式でデータを保守する方法。<span class="bold"><strong>ACID</strong></span> 概念の一部です。特に、異なるテーブル内のデータは<span class="bold"><strong>外部キー制約</strong></span>の使用を通じて一貫性が保持され、これによって変更が発生するのを防止したり、それらの変更をすべての関連テーブルに自動的に伝播したりできます。関連メカニズムには、重複値が間違って挿入されるのを防ぐ<span class="bold"><strong>一意制約</strong></span>と、ブランク値が間違って挿入されるのを防ぐ <span class="bold"><strong>NOT NULL 制約</strong></span>が含まれます。
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_foreign_key_constraint">FOREIGN KEY 制約</a>, <a class="glossseealso" href="glossary.html#glos_not_null_constraint">NOT NULL 制約</a>, <a class="glossseealso" href="glossary.html#glos_unique_constraint">一意制約</a>も参照</p></dd><dt><a name="glos_infimum_record"></a><span class="glossterm">最大下限レコード</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986172704"></a>
        <span class="bold"><strong>インデックス</strong></span>内の<span class="bold"><strong>疑似レコード</strong></span>で、そのインデックスの最小値を下回る<span class="bold"><strong>ギャップ</strong></span>を表します。トランザクションに <code class="literal">SELECT ... FOR UPDATE ... WHERE col &lt; 10;</code> などのステートメントがあり、カラム内の最小値が 5 である場合、これは、ほかのトランザクションが 0 や -10 などのさらに小さな値を挿入するのを防ぐ最大下限レコードでのロックです。
      </p><p><a class="glossseealso" href="glossary.html#glos_gap">ギャップ</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_pseudo_record">疑似レコード</a>, <a class="glossseealso" href="glossary.html#glos_supremum_record">最小上限レコード</a>も参照</p></dd><dt><a name="glos_supremum_record"></a><span class="glossterm">最小上限レコード</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986179520"></a>
        インデックス内の<span class="bold"><strong>疑似レコード</strong></span>で、そのインデックスの最大値を上回る<span class="bold"><strong>ギャップ</strong></span>を表します。トランザクションに <code class="literal">SELECT ... FOR UPDATE ... WHERE col &gt; 10;</code> などのステートメントが含まれ、カラム内の最大値が 20 の場合、これは、ほかのトランザクションが 50 や 100 などのさらに大きな値を挿入することを防ぐ最小上限レコードに対するロックです。
      </p><p><a class="glossseealso" href="glossary.html#glos_gap">ギャップ</a>, <a class="glossseealso" href="glossary.html#glos_infimum_record">最大下限レコード</a>, <a class="glossseealso" href="glossary.html#glos_pseudo_record">疑似レコード</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">シ</h3><dl><dt><a name="glos_system_tablespace"></a><span class="glossterm">システムテーブルスペース</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986122176"></a>
        InnoDB テーブル関連オブジェクト (<span class="bold"><strong>データディクショナリ</strong></span>) と <span class="bold"><strong>Undo ログ</strong></span>、<span class="bold"><strong>変更バッファー</strong></span>、<span class="bold"><strong>二重書き込みバッファー</strong></span>のストレージ領域のメタデータを含むデータファイル (<span class="bold"><strong>ibdata</strong></span> ファイル) の小さなセット。<code class="literal">innodb_file_per_table</code> の設定に応じて、テーブルの作成時に一部またはすべての InnoDB テーブルのテーブルとインデックスデータが含まれる場合もあります。システムテーブルスペース内のデータとメタデータは、MySQL <span class="bold"><strong>インスタンス</strong></span>内のすべての<span class="bold"><strong>データベース</strong></span>に適用されます。
      </p><p>
        MySQL 5.6.5 で導入されたリグレッションにより、<code class="literal">innodb_file_per_table</code> が有効のときに、<code class="literal">FULLTEXT</code> インデックステーブルは独自の個々のテーブルスペースではなく <code class="literal">InnoDB</code> システムテーブルスペース (スペース 0) に作成されます。このバグは、MySQL 5.6.20 および MySQL 5.7.5 で修正されました (Bug#18635485)。
      </p><p>
        MySQL 5.6.7 より前のデフォルトは、すべての InnoDB テーブルとインデックスをシステムテーブルスペース内部に保持することで、多くの場合、このファイルが非常に大きくなっていました。システムテーブルスペースは決して縮小しないので、大容量の一時データがロードされてから削除された場合、ストレージの問題が発生する可能性があります。MySQL 5.6.7 以降では、デフォルトは <span class="bold"><strong>file-per-table</strong></span> モードで、各テーブルとそれに関連付けられたインデックスが別個の <span class="bold"><strong>.ibd ファイル</strong></span>に格納されます。この新しいデフォルトによって、テーブル<span class="bold"><strong>圧縮</strong></span>や <span class="bold"><strong>DYNAMIC</strong></span> 行フォーマットなど、<span class="bold"><strong>Barracuda</strong></span> ファイル形式に依存する InnoDB 機能をより簡単に使用できるようになります。
      </p><p>
        MySQL 5.6 以降では、<code class="literal">innodb_undo_tablespaces</code> オプションの値を設定すると、<span class="bold"><strong>Undo ログ</strong></span>が 1 つ以上の別個のテーブルスペースファイルに分割されます。これらのファイルは引き続きシステムテーブルスペースの一部と見なされます。
      </p><p>
        すべてのテーブルデータをシステムテーブルスペースまたは別個の <code class="filename">.ibd</code> ファイルのどちらに保持するかは、ストレージ管理全般に影響します。<span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品は、大きなファイルの小さなセットをバックアップすることも、多数のより小さなファイルをバックアップすることもできます。数千のテーブルを持つシステムでは、数千の <code class="filename">.ibd</code> ファイルを処理するファイルシステム操作がボトルネックになることがあります。
      </p><p><a class="glossseealso" href="glossary.html#glos_barracuda">Barracuda</a>, <a class="glossseealso" href="glossary.html#glos_change_buffer">変更バッファー</a>, <a class="glossseealso" href="glossary.html#glos_compression">圧縮</a>, <a class="glossseealso" href="glossary.html#glos_data_dictionary">データディクショナリ</a>, <a class="glossseealso" href="glossary.html#glos_database">データベース</a>, <a class="glossseealso" href="glossary.html#glos_doublewrite_buffer">二重書き込みバッファー</a>, <a class="glossseealso" href="glossary.html#glos_dynamic_row_format">動的行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_ibd_file">.ibd ファイル</a>, <a class="glossseealso" href="glossary.html#glos_ibdata_file">ibdata ファイル</a>, <a class="glossseealso" href="glossary.html#glos_innodb_file_per_table">innodb_file_per_table</a>, <a class="glossseealso" href="glossary.html#glos_instance">インスタンス</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_tablespace">テーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_undo_log">Undo ログ</a>も参照</p></dd><dt><a name="glos_shutdown"></a><span class="glossterm">シャットダウン</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986050688"></a>
        MySQL Server を停止させるプロセス。このプロセスはデフォルトで <span class="bold"><strong>InnoDB</strong></span> テーブルのクリーンアップ操作を行うので、シャットダウンは<span class="bold"><strong>遅く</strong></span>なりますが、その後の起動は速くなります。クリーンアップ操作を省略した場合、シャットダウンは<span class="bold"><strong>速く</strong></span>なりますが、次の起動中にクリーンアップを行う必要があります。
      </p><p>
        シャットダウンモードは、<code class="literal">innodb_fast_shutdown</code> オプションで制御されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_fast_shutdown">高速シャットダウン</a>, <a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>, <a class="glossseealso" href="glossary.html#glos_slow_shutdown">低速シャットダウン</a>, <a class="glossseealso" href="glossary.html#glos_startup">起動</a>も参照</p></dd><dt><a name="glos_sharp_checkpoint"></a><span class="glossterm">シャープチェックポイント</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986058272"></a>
        すべての<span class="bold"><strong>ダーティー</strong></span>バッファープールページ (その Redo エントリが <span class="bold"><strong>Redo ログ</strong></span>のどこかに含まれている) をディスクに<span class="bold"><strong>フラッシュ</strong></span>するプロセス。InnoDB がログファイルの一部を再利用する前に発生します。ログファイルは循環的に使用されます。通常は、書き込みの多い<span class="bold"><strong>ワークロード</strong></span>で発生します。
      </p><p><a class="glossseealso" href="glossary.html#glos_dirty_page">ダーティーページ</a>, <a class="glossseealso" href="glossary.html#glos_flush">フラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_redo_log">Redo ログ</a>, <a class="glossseealso" href="glossary.html#glos_workload">ワークロード</a>も参照</p></dd><dt><a name="glos_primary_key"></a><span class="glossterm">主キー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986041904"></a>
        テーブル内のすべての行を一意に識別できるカラムセット (および暗黙的に、このカラムセットに基づくインデックス)。したがって、<code class="literal">NULL</code> 値を一切含まない一意インデックスである必要があります。
      </p><p>
        InnoDB は、すべてのテーブルにこのようなインデックス (<span class="bold"><strong>クラスタ化されたインデックス</strong></span>または<span class="bold"><strong>クラスタインデックス</strong></span>とも呼ばれます) があることを要求し、主キーのカラム値に基づいてテーブルストレージを編成します。
      </p><p>
        主キー値を選択するときは、ほかの何らかのソースから派生した値 (<span class="bold"><strong>ナチュラルキー</strong></span>) に依存するのではなく、任意の値 (<span class="bold"><strong>合成キー</strong></span>) を使用することを検討してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_clustered_index">クラスタ化されたインデックス</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_natural_key">ナチュラルキー</a>, <a class="glossseealso" href="glossary.html#glos_synthetic_key">合成キー</a>も参照</p></dd><dt><a name="glos_redundant_row_format"></a><span class="glossterm">冗長行フォーマット</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986022384"></a>
        もっとも古い <code class="literal">InnoDB</code> 行フォーマット。<span class="bold"><strong>Antelope</strong></span> <span class="bold"><strong>ファイル形式</strong></span>を使用するテーブルに利用できます。MySQL 5.0.3 より前は、これが <code class="literal">InnoDB</code> で利用できる唯一の行フォーマットでした。My SQL 5.0.3 以降では、デフォルトは<span class="bold"><strong>コンパクト行フォーマット</strong></span>です。古い <code class="literal">InnoDB</code> テーブルとの互換性のために、冗長行フォーマットを引き続き指定できます。
      </p><p>
        <code class="literal">InnoDB</code> <code class="literal">REDUNDANT</code> 行フォーマットの詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-row-format-antelope" title="14.9.4 COMPACT および REDUNDANT 行フォーマット">セクション14.9.4「COMPACT および REDUNDANT 行フォーマット」</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_antelope">Antelope</a>, <a class="glossseealso" href="glossary.html#glos_compact_row_format">コンパクト行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_file_format">ファイル形式</a>, <a class="glossseealso" href="glossary.html#glos_row_format">行フォーマット</a>も参照</p></dd><dt><a name="glos_prepared_backup"></a><span class="glossterm">準備されたバックアップ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986031840"></a>
        バックアップファイルセットの 1 つ。<span class="bold"><strong>バイナリログ</strong></span>および<span class="bold"><strong>増分バックアップ</strong></span>を適用するすべての段階が終了したあとに、<span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品によって生成されます。結果ファイルは、<span class="bold"><strong>リストア</strong></span>できる状態です。適用ステップより前のファイルは <span class="bold"><strong>raw バックアップ</strong></span>と呼ばれます。
      </p><p><a class="glossseealso" href="glossary.html#glos_binary_log">バイナリログ</a>, <a class="glossseealso" href="glossary.html#glos_hot_backup">ホットバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_incremental_backup">増分バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_raw_backup">raw バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_restore">リストア</a>も参照</p></dd><dt><a name="glos_auto_increment"></a><span class="glossterm">自動インクリメント</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986090544"></a>
        カラム内に昇順で値を自動的に追加する、テーブルカラムのプロパティー (<code class="literal">AUTO_INCREMENT</code> キーワードで指定します)。InnoDB は<span class="bold"><strong>主キー</strong></span>カラムについてのみ自動インクリメントをサポートします。
      </p><p>
        これにより、開発者の作業が節約され、新しい行を挿入するときに新しい一意値を生成する必要はありません。カラムには NULL でなく一意値が含まれているとわかっているので、クエリーオプティマイザに有用な情報をもたらします。このようなカラムからの値は、さまざまなコンテキストでルックアップキーとして使用でき、自動生成されるので絶えず変更する理由はありません。このため、多くの場合、主キーカラムは自動インクリメントとして指定されます。
      </p><p>
        自動インクリメントカラムは、ステートメントベースレプリケーションで問題になることがあります。スレーブでステートメントを再現しても、タイミングの問題のためにマスターと同じカラム値セットが生成されない場合があるためです。自動インクリメントする主キーがある場合は、<code class="literal">innodb_autoinc_lock_mode=1</code> の設定だけでステートメントベースレプリケーションを使用できます。挿入操作でより高い並列性を許可する <code class="literal">innodb_autoinc_lock_mode=2</code> を使用する場合は、<span class="bold"><strong>ステートメントベースレプリケーション</strong></span>ではなく<span class="bold"><strong>行ベースレプリケーション</strong></span>を使用してください。<code class="literal">innodb_autoinc_lock_mode=0</code> の設定は、以前 (従来) のデフォルト設定であり、互換性の目的以外では使用しないでください。
      </p><p><a class="glossseealso" href="glossary.html#glos_auto_increment_locking">自動インクリメントロック</a>, <a class="glossseealso" href="glossary.html#glos_innodb_autoinc_lock_mode">innodb_autoinc_lock_mode</a>, <a class="glossseealso" href="glossary.html#glos_primary_key">主キー</a>, <a class="glossseealso" href="glossary.html#glos_row_based_replication">行ベースレプリケーション</a>, <a class="glossseealso" href="glossary.html#glos_statement_based_replication">ステートメントベースレプリケーション</a>も参照</p></dd><dt><a name="glos_auto_increment_locking"></a><span class="glossterm">自動インクリメントロック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986076336"></a>
        <span class="bold"><strong>自動インクリメント</strong></span>主キーの利便性には、並列性とのトレードオフが若干伴います。もっとも単純なケースでは、あるトランザクションがテーブルに値を挿入している場合に、ほかのトランザクションはそのテーブルへのそれぞれの挿入を待機する必要があるので、最初のトランザクションによって挿入された行が、連続する主キー値を受け取ります。InnoDB は最適化と <code class="literal">innodb_autoinc_lock_mode</code> オプションを含んでいるので、挿入操作について、自動インクリメント値の予測可能なシーケンスと最大の<span class="bold"><strong>並列性</strong></span>とをトレードオフする方法を選択できます。
      </p><p><a class="glossseealso" href="glossary.html#glos_auto_increment">自動インクリメント</a>, <a class="glossseealso" href="glossary.html#glos_concurrency">並列性</a>, <a class="glossseealso" href="glossary.html#glos_innodb_autoinc_lock_mode">innodb_autoinc_lock_mode</a>も参照</p></dd><dt><a name="glos_autocommit"></a><span class="glossterm">自動コミット</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986068720"></a>
        各 <span class="bold"><strong>SQL</strong></span> ステートメントのあとに<span class="bold"><strong>コミット</strong></span>操作を実行する設定。このモードは、複数のステートメントにわたる<span class="bold"><strong>トランザクション</strong></span>で InnoDB テーブルを操作する場合には推奨されません。これは、InnoDB テーブルでの<span class="bold"><strong>読み取り専用トランザクション</strong></span>のパフォーマンスに役立つことがあります。この場合、特に MySQL 5.6.4 以降で、<span class="bold"><strong>Undo</strong></span> データの<span class="bold"><strong>ロック</strong></span>および生成のオーバーヘッドを最小限に抑えます。これは、MyISAM テーブル (トランザクションが適用されない) を操作する場合にも適切です。
      </p><p><a class="glossseealso" href="glossary.html#glos_commit">コミット</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_read_only_transaction">読み取り専用トランザクション</a>, <a class="glossseealso" href="glossary.html#glos_sql">SQL</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>, <a class="glossseealso" href="glossary.html#glos_undo">Undo</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ス</h3><dl><dt><a name="glos_schema"></a><span class="glossterm">スキーマ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978986010048"></a>
        概念的には、スキーマは、テーブル、テーブルカラム、カラムのデータ型、インデックス、外部キーなど、相互に関連するデータベースオブジェクトのセットです。カラムがテーブルを構成する、外部キーがテーブルやカラムを参照するなどの理由で、これらのオブジェクトは SQL 構文を通じて接続されます。理論的には、これらは論理的にも接続し、統合されたアプリケーションまたは柔軟なフレームワークの一部として連携します。たとえば、<span class="bold"><strong>information_schema</strong></span> および <span class="bold"><strong>performance_schema</strong></span> データベースは、テーブルとそこに含まれるカラム間の密接な関係を強調するために、その名前で「schema」を使用しています。
      </p><p>
        MySQL では、<span class="bold"><strong>スキーマ</strong></span>は物理的に<span class="bold"><strong>データベース</strong></span>と同義です。MySQL SQL 構文で、<code class="literal">DATABASE</code> の代わりにキーワード <code class="literal">SCHEMA</code> を代用できます。たとえば、<code class="literal">CREATE DATABASE</code> の代わりに <code class="literal">CREATE SCHEMA</code> を使用できます。
      </p><p>
        ほかのデータベース製品では区別しているものがあります。たとえば、Oracle Database 製品では、<span class="bold"><strong>スキーマ</strong></span>はデータベースの一部、つまり単一ユーザーが所有するテーブルおよびほかのオブジェクトだけを表します。
      </p><p><a class="glossseealso" href="glossary.html#glos_database">データベース</a>, <a class="glossseealso" href="glossary.html#glos_ib_file_set">ib-file セット</a>, <a class="glossseealso" href="glossary.html#glos_information_schema">INFORMATION_SCHEMA</a>, <a class="glossseealso" href="glossary.html#glos_performance_schema">パフォーマンススキーマ</a>も参照</p></dd><dt><a name="glos_scalability"></a><span class="glossterm">スケーラビリティー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985996704"></a>
        システム能力の限界を超えてもパフォーマンスが突然落ちることがなく、システムにより多くの作業を追加したりより多くの同時リクエストを発行したりできること。ソフトウェアアーキテクチャー、ハードウェア構成、アプリケーションコーディング、およびワークロードのタイプはすべて、スケーラビリティーで役割を担います。システムがその最大能力に達したときにスケーラビリティーを増やす一般的な方法には、<span class="bold"><strong>スケールアップ</strong></span> (既存のハードウェアまたはソフトウェアの能力を増大させる) と<span class="bold"><strong>スケールアウト</strong></span> (新しいサーバーやより多くの MySQL インスタンスを追加する) があります。多くの場合、大規模開発の重要な側面として、<span class="bold"><strong>可用性</strong></span>と組み合わされます。
      </p><p><a class="glossseealso" href="glossary.html#glos_availability">可用性</a>, <a class="glossseealso" href="glossary.html#glos_scale_out">スケールアウト</a>, <a class="glossseealso" href="glossary.html#glos_scale_up">スケールアップ</a>も参照</p></dd><dt><a name="glos_scale_out"></a><span class="glossterm">スケールアウト</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985989264"></a>
        新しいサーバーやより多くの MySQL インスタンスを追加することによって<span class="bold"><strong>スケーラビリティー</strong></span>を増大させる方法。たとえば、レプリケーション、MySQL Cluster、接続プール、またはサーバーのグループに作業を分散させるほかの機能を設定すること。<span class="bold"><strong>スケールアップ</strong></span>と対比してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_scalability">スケーラビリティー</a>, <a class="glossseealso" href="glossary.html#glos_scale_up">スケールアップ</a>も参照</p></dd><dt><a name="glos_scale_up"></a><span class="glossterm">スケールアップ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985984032"></a>
        既存のハードウェアまたはソフトウェアの能力を高めることにより<span class="bold"><strong>スケーラビリティー</strong></span>を増大させる方法。たとえば、サーバー上でメモリーを増やすこと、<code class="literal">innodb_buffer_pool_size</code> や <code class="literal">innodb_buffer_pool_instances</code> などのメモリー関連パラメータを調整すること。<span class="bold"><strong>スケールアウト</strong></span>と対比してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_scalability">スケーラビリティー</a>, <a class="glossseealso" href="glossary.html#glos_scale_out">スケールアウト</a>も参照</p></dd><dt><a name="glos_stemming"></a><span class="glossterm">ステミング</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985967008"></a>
        単数形と複数形、過去、現在、および未来時制など、共通語幹に基づいて単語のさまざまなバリエーションを検索する機能。この機能は現在、MyISAM <span class="bold"><strong>全文検索</strong></span>機能でサポートされますが、InnoDB テーブルの <span class="bold"><strong>FULLTEXT インデックス</strong></span>ではされません。
      </p><p><a class="glossseealso" href="glossary.html#glos_full_text_search">全文検索</a>, <a class="glossseealso" href="glossary.html#glos_fulltext_index">FULLTEXT インデックス</a>も参照</p></dd><dt><a name="glos_statement_based_replication"></a><span class="glossterm">ステートメントベースレプリケーション</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985976736"></a>
        SQL ステートメントが<span class="bold"><strong>マスター</strong></span>サーバーから送信され、<span class="bold"><strong>スレーブ</strong></span>サーバー上で再現される形式の<span class="bold"><strong>レプリケーション</strong></span>。<span class="bold"><strong>auto-increment locking</strong></span> の潜在的なタイミング問題を回避するために、<code class="literal">innodb_autoinc_lock_mode</code> オプションの設定には注意が必要です。
      </p><p><a class="glossseealso" href="glossary.html#glos_auto_increment_locking">自動インクリメントロック</a>, <a class="glossseealso" href="glossary.html#glos_innodb_autoinc_lock_mode">innodb_autoinc_lock_mode</a>, <a class="glossseealso" href="glossary.html#glos_master_server">マスターサーバー</a>, <a class="glossseealso" href="glossary.html#glos_replication">レプリケーション</a>, <a class="glossseealso" href="glossary.html#glos_row_based_replication">行ベースレプリケーション</a>, <a class="glossseealso" href="glossary.html#glos_slave_server">スレーブサーバー</a>も参照</p></dd><dt><a name="glos_stopword"></a><span class="glossterm">ストップワード</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985961760"></a>
        <span class="bold"><strong>FULLTEXT インデックス</strong></span>で、十分に一般的または些細なので<span class="bold"><strong>検索インデックス</strong></span>から除外し、検索クエリーで無視できると考えられている単語。<code class="literal">InnoDB</code> テーブルと <code class="literal">MyISAM</code> テーブルとでは、異なる構成設定がストップワード処理を制御します。詳細は、<a class="xref" href="functions.html#fulltext-stopwords" title="12.9.4 全文ストップワード">セクション12.9.4「全文ストップワード」</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_fulltext_index">FULLTEXT インデックス</a>, <a class="glossseealso" href="glossary.html#glos_search_index">検索インデックス</a>も参照</p></dd><dt><a name="glos_storage_engine"></a><span class="glossterm">ストレージエンジン</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985954496"></a>
        MySQL データベースのコンポーネントの 1 つ。データの格納、更新、および照会という低レベル作業を実行します。MySQL 5.5 以降では、<span class="bold"><strong>InnoDB</strong></span> が新しいテーブルのデフォルトストレージエンジンであり、MyISAM の代替となるものです。メモリー使用とディスク使用、読み取り速度と書き込み速度、速度と堅牢性など、異なる要因間トレードオフのために異なるストレージエンジンが設計されています。各ストレージエンジンが特定のテーブルを管理するので、<code class="literal">InnoDB</code> テーブル、<code class="literal">MyISAM</code> テーブルなどと呼びます。
      </p><p>
        <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品は、InnoDB テーブルのバックアップに最適化されています。MyISAM およびほかのストレージエンジンで扱われるテーブルもバックアップできます。
      </p><p><a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_table_type">テーブルタイプ</a>も参照</p></dd><dt><a name="glos_snapshot"></a><span class="glossterm">スナップショット</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985945232"></a>
        特定時点のデータの表現。ほかの<span class="bold"><strong>トランザクション</strong></span>によって変更が<span class="bold"><strong>コミット</strong></span>されても変化しません。<span class="bold"><strong>一貫性読み取り</strong></span>を許可する<span class="bold"><strong>分離レベル</strong></span>で使用されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_commit">コミット</a>, <a class="glossseealso" href="glossary.html#glos_consistent_read">一貫性読み取り</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_spin"></a><span class="glossterm">スピン</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985937808"></a>
        リソースが利用できるようになるかどうかを継続的にテストするタイプの<span class="bold"><strong>待機</strong></span>操作。この方法は、通常短期間だけ保持されるリソースに使用されます。この場合、スレッドをスリープにしてコンテキストスイッチを実行するよりも、「ビジーループ」で待機するほうが効率的です。リソースが短時間で利用できなくなると、スピンループは中止し、別の待機方法が使用されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_latch">ラッチ</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_mutex">相互排他ロック</a>, <a class="glossseealso" href="glossary.html#glos_wait">待機</a>も参照</p></dd><dt><a name="glos_space_id"></a><span class="glossterm">スペース ID</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985931728"></a>
        MySQL インスタンス内で <code class="literal">InnoDB</code> <span class="bold"><strong>テーブルスペース</strong></span>を一意に識別するために使用される識別子。<span class="bold"><strong>システムテーブルスペース</strong></span>のスペース ID は常にゼロです。この同じ ID がシステムテーブルスペース内のすべてのテーブルに適用されます。<span class="bold"><strong>file-per-table</strong></span> モードで作成される各テーブルスペースファイルには、独自のスペース ID も割り当てられます。
      </p><p>
        MySQL 5.6 より前では、このハードコードされた値によって、MySQL インスタンス間で <code class="literal">InnoDB</code> テーブルスペースファイルを移動することが困難でした。MySQL 5.6 以降では、ステートメント <code class="literal">FLUSH TABLES ... FOR EXPORT</code>、<code class="literal">ALTER TABLE ... DISCARD TABLESPACE</code>、および <code class="literal">ALTER TABLE ... IMPORT TABLESPACE</code> を含む<span class="bold"><strong>トランスポータブルテーブルスペース</strong></span>機能を使用することによって、インスタンス間でテーブルスペースファイルをコピーできます。スペース ID を調整するために必要な情報は、テーブルスペースとともにコピーする <span class="bold"><strong>.cfg ファイル</strong></span>で伝えられます。詳細は、<a class="xref" href="innodb-storage-engine.html#tablespace-copying" title="14.5.5 テーブルスペースの別のサーバーへのコピー (トランスポータブルテーブルスペース)">セクション14.5.5「テーブルスペースの別のサーバーへのコピー (トランスポータブルテーブルスペース)」</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_cfg_file">.cfg ファイル</a>, <a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_ibd_file">.ibd ファイル</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_tablespace">テーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_transportable_tablespace">トランスポータブルテーブルスペース</a>も参照</p></dd><dt><a name="glos_thread"></a><span class="glossterm">スレッド</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985905728"></a>
        通常は<span class="bold"><strong>プロセス</strong></span>より軽量で、高度な<span class="bold"><strong>並列性</strong></span>に対応できる処理単位。
      </p><p><a class="glossseealso" href="glossary.html#glos_concurrency">並列性</a>, <a class="glossseealso" href="glossary.html#glos_master_thread">マスタースレッド</a>, <a class="glossseealso" href="glossary.html#glos_process">プロセス</a>, <a class="glossseealso" href="glossary.html#glos_pthreads">Pthreads</a>も参照</p></dd><dt><a name="glos_slave_server"></a><span class="glossterm">スレーブサーバー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985916544"></a>
        多くの場合、「スレーブ」と短縮されます。<span class="bold"><strong>レプリケーション</strong></span>シナリオのデータベース<span class="bold"><strong>サーバー</strong></span>マシンの 1 つ。別のサーバー (<span class="bold"><strong>マスター</strong></span>) から変更を受け取り、これらの同じ変更を適用します。したがって、ある程度遅れる可能性がありますが、マスターと同じ内容を保持します。
      </p><p>
        MySQL のスレーブサーバーは一般に、ディザスタリカバリで使用され、障害の発生したマスターサーバーに代わります。これらはまた一般に、データベース構成変更がパフォーマンスや信頼性の問題を起こさないことを保証するために、ソフトウェアアップグレードと新しい設定をテストする場合にも使用されます。
      </p><p>
        スレーブサーバーは通常、ユーザークエリーと同様に、マスターからリレーされるすべての <span class="bold"><strong>DML</strong></span> (書き込み) 操作を処理するので、ワークロードが高くなります。スレーブサーバーがマスターからの変更を十分高速に適用できることを保証するために、それらは多くの場合、高速 I/O デバイスおよび十分な CPU とメモリーを備えて複数のデータベースインスタンスを同じスレーブサーバー上で実行します。たとえば、マスターサーバーがハードドライブストレージを使用し、スレーブサーバーが <span class="bold"><strong>SSD</strong></span> を使用する場合があります。
      </p><p><a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_replication">レプリケーション</a>, <a class="glossseealso" href="glossary.html#glos_server">サーバー</a>, <a class="glossseealso" href="glossary.html#glos_ssd">SSD</a>も参照</p></dd><dt><a name="glos_slow_query_log"></a><span class="glossterm">スロークエリーログ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985899792"></a>
        MySQL Server によって処理される SQL ステートメントのパフォーマンスチューニングに使用されるタイプの<span class="bold"><strong>ログ</strong></span>。ログ情報はファイルに格納されます。使用するにはこの機能を有効にする必要があります。どのカテゴリの「低速」 SQL ステートメントがログに記録されるかを制御してください。詳細は、<a class="xref" href="server-administration.html#slow-query-log" title="5.2.5 スロークエリーログ">セクション5.2.5「スロークエリーログ」</a>を参照してください。

      </p><p><a class="glossseealso" href="glossary.html#glos_general_query_log">一般クエリーログ</a>, <a class="glossseealso" href="glossary.html#glos_log">ログ</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">セ</h3><dl><dt><a name="glos_secondary_index"></a><span class="glossterm">セカンダリインデックス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985858512"></a>
        テーブルカラムのサブセットを表すタイプの InnoDB <span class="bold"><strong>インデックス</strong></span>。InnoDB テーブルは、ゼロ個、1 個、または複数個のセカンダリインデックスを持つことができます。(<span class="bold"><strong>クラスタ化されたインデックス</strong></span>と対比してください。こちらは各 InnoDB テーブルに必要で、すべてのテーブルカラムのデータを格納します。)
      </p><p>
        セカンダリインデックスは、インデックスカラムからの値だけを必要とするクエリーを満たすために使用できます。より複雑なクエリーの場合、テーブル内の該当行を識別するために使用でき、それらはクラスタ化されたインデックスを使用するルックアップで取得されます。
      </p><p>
        セカンダリインデックスの作成および削除には従来、InnoDB テーブル内のすべてのデータをコピーするためにかなりのオーバーヘッドが必要でした。InnoDB Plugin の<span class="bold"><strong>高速インデックス作成</strong></span>機能によって、InnoDB セカンダリインデックスの <code class="literal">CREATE INDEX</code> および <code class="literal">DROP INDEX</code> ステートメントの速度が向上します。
      </p><p><a class="glossseealso" href="glossary.html#glos_clustered_index">クラスタ化されたインデックス</a>, <a class="glossseealso" href="glossary.html#glos_fast_index_creation">高速インデックス作成</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>も参照</p></dd><dt><a name="glos_segment"></a><span class="glossterm">セグメント</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985848512"></a>
        InnoDB <span class="bold"><strong>テーブルスペース</strong></span>内の境界。テーブルスペースをディレクトリに例えると、セグメントはそのディレクトリ内のファイルに似ています。セグメントは増えることができます。新しいセグメントを作成できます。
      </p><p>
        たとえば、<span class="bold"><strong>file-per-table</strong></span> テーブルスペース内で、テーブルデータは 1 セグメント内にあり、それぞれに関連付けられたインデックスがそれが属するセグメント内にあります。<span class="bold"><strong>システムテーブルスペース</strong></span>は、多くのテーブルとそれらに関連付けられたインデックスを保持できるため、多くの異なるセグメントを含みます。システムテーブルスペースには、<span class="bold"><strong>Undo ログ</strong></span>を構成する最大 128 の<span class="bold"><strong>ロールバックセグメント</strong></span>も含まれます。
      </p><p>
        セグメントは、データの挿入と削除に応じて拡大、縮小します。セグメントがより多くの領域を必要とする場合、一度に 1 <span class="bold"><strong>エクステント</strong></span> (1M バイト) ずつ拡張されます。同様に、セグメントは、あるエクステント内のすべてのデータが不要になると、そのエクステント分の領域を解放します。
      </p><p><a class="glossseealso" href="glossary.html#glos_extent">エクステント</a>, <a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_rollback_segment">ロールバックセグメント</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_tablespace">テーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_undo_log">Undo ログ</a>も参照</p></dd><dt><a name="glos_savepoint"></a><span class="glossterm">セーブポイント</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985864464"></a>
        セーブポイントは、ネストされた<span class="bold"><strong>トランザクション</strong></span>の実装に役立ちます。それらは、lより大きなトランザクションの一部であるテーブル上での操作にスコープを提供するために使用できます。たとえば、予約システムで旅行をスケジュールするときに、いくつかの異なる航空便を予約する場合があります。希望の航空便を利用できない場合、予約に成功したそれより早い航空便をロールバックすることなく、その 1 行程の予約に関与する変更を<span class="bold"><strong>ロールバック</strong></span>できます。
      </p><p><a class="glossseealso" href="glossary.html#glos_rollback">ロールバック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_full_text_search"></a><span class="glossterm">全文検索</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985829664"></a>
        SQL <code class="literal">LIKE</code> 演算子を使用したり、アプリケーションレベル検索アルゴリズムを作成したりするよりも、より高速、より便利で、かつより柔軟な方法で単語、語句、単語のブール結合などをテーブルデータ内で検索するための MySQL 機能。これは、SQL 関数 <code class="literal">MATCH()</code> および <span class="bold"><strong>FULLTEXT インデックス</strong></span>を使用します。
      </p><p><a class="glossseealso" href="glossary.html#glos_fulltext_index">FULLTEXT インデックス</a>も参照</p></dd><dt><a name="glos_constraint"></a><span class="glossterm">制約</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985871792"></a>
        データが一貫性を失うのを防ぐために、データベース変更をブロックできる自動テスト。(コンピュータサイエンス用語では、不変条件に関連する一種のアサーション。)制約は、データ一貫性を維持するための、<span class="bold"><strong>ACID</strong></span> 概念の重要な構成要素です。MySQL によってサポートされる制約には、<span class="bold"><strong>FOREIGN KEY 制約</strong></span>と<span class="bold"><strong>一意制約</strong></span>があります。
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_foreign_key">外部キー</a>, <a class="glossseealso" href="glossary.html#glos_relational">リレーショナル</a>, <a class="glossseealso" href="glossary.html#glos_unique_constraint">一意制約</a>も参照</p></dd><dt><a name="glos_normalized"></a><span class="glossterm">正規化</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985893952"></a>
        データベース設計戦略の 1 つ。データは複数のテーブルに分割されていて、圧縮された値を ID で表された単一行に複製することで、冗長または長い値を格納、照会、および更新することを回避します。通常は <span class="bold"><strong>OLTP</strong></span> アプリケーションで使用されます。
      </p><p>
        たとえば、住所に一意 ID を与えることで、国勢調査データベースはその ID を家族の各メンバーに関連付けることによって、<span class="bold"><strong>この住所の住居人</strong></span>という関係を表現できます (<span class="bold"><strong>米国のある街のメインストリート 123</strong></span> などの複雑な値のコピーを複数格納するのではなく)。
      </p><p>
        別の例としては、単純な住所録アプリケーションでは、ある人の名前および住所と同じテーブルにそれぞれの電話番号を格納しますが、電話会社データベースでは、各電話番号に特別な ID を与えてその番号と ID を別のテーブルに格納します。この正規化表現によって、市外局番が分かれるときの大幅な更新を簡略化できます。
      </p><p>
        正規化が常に推奨されるわけではありません。主に照会されるだけで、更新されるのは全体を削除してリロードする場合だけのデータは、多くの場合、重複値の冗長コピーを持つ少数の大きなテーブルで保持されます。このデータ表現は、<span class="bold"><strong>非正規化</strong></span>と呼ばれ、データウェアハウスアプリケーションでよく見られます。
      </p><p><a class="glossseealso" href="glossary.html#glos_denormalized">非正規化</a>, <a class="glossseealso" href="glossary.html#glos_foreign_key">外部キー</a>, <a class="glossseealso" href="glossary.html#glos_oltp">OLTP</a>, <a class="glossseealso" href="glossary.html#glos_relational">リレーショナル</a>も参照</p></dd><dt><a name="glos_selectivity"></a><span class="glossterm">選択性</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985836304"></a>
        データ分布のプロパティーの 1 つ。カラム内の個別値の数 (その <span class="bold"><strong>カーディナリティー</strong></span>) をテーブル内のレコード数で割ったもの。高い選択性は、カラム値が比較的一意であり、インデックスを通じて効率的に取得できることを意味します。<code class="literal">WHERE</code> 句内のテストがテーブル内の少ない数 (または割合) の行にのみ一致すると予測できる場合 (またはクエリーオプティマイザがそう予測する場合)、<span class="bold"><strong>クエリー</strong></span>がインデックスを使用してそのテストを最初に評価すると、全体的に効率的である傾向があります。
      </p><p><a class="glossseealso" href="glossary.html#glos_cardinality">カーディナリティー</a>, <a class="glossseealso" href="glossary.html#glos_query">クエリー</a>も参照</p></dd><dt><a name="glos_quiesce"></a><span class="glossterm">静止</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985882768"></a>
        データベースアクティビティーの量を減らすこと。多くの場合、<code class="literal">ALTER TABLE</code>、<span class="bold"><strong>バックアップ</strong></span>、<span class="bold"><strong>シャットダウン</strong></span>などの操作に備えるためです。最大限の<span class="bold"><strong>フラッシュ</strong></span>の実行を伴う場合があるため (そうでない場合もありますが)、<span class="bold"><strong>InnoDB</strong></span> はバックグラウンド I/O の実行を継続しません。
      </p><p>
        MySQL 5.6 以降では、構文 <code class="literal">FLUSH TABLES ... FOR EXPORT</code> によって <code class="literal">InnoDB</code> テーブルの一部のデータがディスクに書き込まれるので、そのデータファイルをコピーすることでこれらのテーブルをより簡単にバックアップできます。
      </p><p><a class="glossseealso" href="glossary.html#glos_backup">バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_flush">フラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>, <a class="glossseealso" href="glossary.html#glos_shutdown">シャットダウン</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ソ</h3><dl><dt><a name="glos_sort_buffer"></a><span class="glossterm">ソートバッファー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985777920"></a>
        <code class="literal">InnoDB</code> インデックスの作成中にデータをソートするために使用されるバッファー。ソートバッファーサイズは、<code class="literal">innodb_sort_buffer_size</code> 構成オプションを使用して構成されます。
      </p></dd><dt><a name="glos_incremental_backup"></a><span class="glossterm">増分バックアップ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985786016"></a>
        ある時点以降に変更されたデータだけを保存する、<span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品で実行されるタイプの<span class="bold"><strong>ホットバックアップ</strong></span>。完全バックアップと一連の増分バックアップがあれば、いくつかの完全バックアップを手元においておくストレージオーバーヘッドなしで、長期間にわたるバックアップデータを再構築できます。完全バックアップをリストアしてから各増分バックアップを連続して適用したり、各増分バックアップを完全バックアップに適用することでこれを最新の状態に保った状態で単一リストア操作を実行したりできます。
      </p><p>
        変更データの粒度は<span class="bold"><strong>ページ</strong></span>レベルです。実際は 1 つのページが複数の行をカバーすることがあります。変更された各ページがバックアップに含まれます。
      </p><p><a class="glossseealso" href="glossary.html#glos_hot_backup">ホットバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>も参照</p></dd><dt><a name="glos_insert"></a><span class="glossterm">挿入</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985814544"></a>
        <span class="bold"><strong>SQL</strong></span> での主要な <span class="bold"><strong>DML</strong></span> 操作の 1 つ。挿入のパフォーマンスは、<span class="bold"><strong>データウェアハウス</strong></span>システム (数百万行をテーブルにロードする) と <span class="bold"><strong>OLTP</strong></span> システム (多数の並列接続が行を同じテーブルに任意の順序で挿入する可能性がある) で重要な要因です。挿入パフォーマンスが重要な場合は、<span class="bold"><strong>変更バッファリング</strong></span>で使用される<span class="bold"><strong>挿入バッファー</strong></span>や<span class="bold"><strong>自動インクリメント</strong></span>カラムなどの <span class="bold"><strong>InnoDB</strong></span> 機能を学習することをお勧めします。
      </p><p><a class="glossseealso" href="glossary.html#glos_auto_increment">自動インクリメント</a>, <a class="glossseealso" href="glossary.html#glos_change_buffering">変更バッファリング</a>, <a class="glossseealso" href="glossary.html#glos_data_warehouse">データウェアハウス</a>, <a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>, <a class="glossseealso" href="glossary.html#glos_insert_buffer">挿入バッファー</a>, <a class="glossseealso" href="glossary.html#glos_oltp">OLTP</a>, <a class="glossseealso" href="glossary.html#glos_sql">SQL</a>も参照</p></dd><dt><a name="glos_insert_buffering"></a><span class="glossterm">挿入バッファリング</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985796896"></a>
        <code class="literal">INSERT</code> 操作によるセカンダリインデックス変更を即座に書き込むのではなく、<span class="bold"><strong>挿入バッファー</strong></span>に格納することで、ランダム I/O を最小限に抑えるように物理書き込みを実行できる手法。これは<span class="bold"><strong>変更バッファリング</strong></span>の 1 つのタイプです。ほかに<span class="bold"><strong>削除バッファリング</strong></span>と<span class="bold"><strong>パージバッファリング</strong></span>があります。
      </p><p>
        セカンダリインデックスが<span class="bold"><strong>一意</strong></span>の場合には挿入バッファリングは使用されません。新しいエントリが書き出される前に新しい値の一意性を検証できないためです。ほかの種類の変更バッファリングは一意インデックスに有効です。
      </p><p><a class="glossseealso" href="glossary.html#glos_change_buffer">変更バッファー</a>, <a class="glossseealso" href="glossary.html#glos_change_buffering">変更バッファリング</a>, <a class="glossseealso" href="glossary.html#glos_delete_buffering">削除バッファリング</a>, <a class="glossseealso" href="glossary.html#glos_insert_buffer">挿入バッファー</a>, <a class="glossseealso" href="glossary.html#glos_purge_buffering">パージバッファリング</a>, <a class="glossseealso" href="glossary.html#glos_unique_index">一意のインデックス</a>も参照</p></dd><dt><a name="glos_insert_buffer"></a><span class="glossterm">挿入バッファー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985801824"></a>
        <span class="bold"><strong>変更バッファー</strong></span>の旧名。<span class="bold"><strong>変更バッファリング</strong></span>には、挿入だけでなく削除および更新操作が含まれるので、「変更バッファー」が望ましい用語です。
      </p><p><a class="glossseealso" href="glossary.html#glos_change_buffer">変更バッファー</a>, <a class="glossseealso" href="glossary.html#glos_change_buffering">変更バッファリング</a>も参照</p></dd><dt><a name="glos_mutex"></a><span class="glossterm">相互排他ロック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985823168"></a>
        「相互排他ロック変数」の非公式な略語。(相互排他自体は「相互的な排他」の短縮です。)内部インメモリーデータ構造への排他的アクセス<span class="bold"><strong>ロック</strong></span>を表し、適用するために、InnoDB が使用する低レベルオブジェクト。ロックが獲得されると、ほかのプロセスやスレッドなどは同じロックを獲得できなくなります。<span class="bold"><strong>読み書きロック</strong></span>と対比してください。これは、内部インメモリーデータ構造への共有アクセス<span class="bold"><strong>ロック</strong></span>を表し、適用するために、InnoDB が使用するものです。相互排他ロックと読み書きロックはまとめて、<span class="bold"><strong>ラッチ</strong></span>と呼ばれます。
      </p><p><a class="glossseealso" href="glossary.html#glos_latch">ラッチ</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_performance_schema">パフォーマンススキーマ</a>, <a class="glossseealso" href="glossary.html#glos_pthreads">Pthreads</a>, <a class="glossseealso" href="glossary.html#glos_rw_lock">rw ロック (読み書きロック)</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">タ</h3><dl><dt><a name="glos_tuple"></a><span class="glossterm">タプル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985739872"></a>
        順序付けられた要素セットを指定する技術用語。これは抽象概念で、データベース理論の公式ディスカッションで使用されます。データベースフィールドでのタプルは通常、テーブル行のカラムによって表されます。これらはクエリー (テーブルの一部のカラムだけ、または結合されたテーブルからのカラムを取得したクエリー、など) の結果セットで表される場合もあります。
      </p><p><a class="glossseealso" href="glossary.html#glos_cursor">カーソル</a>も参照</p></dd><dt><a name="glos_dirty_page"></a><span class="glossterm">ダーティーページ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985772912"></a>
        メモリー内で更新された、InnoDB <span class="bold"><strong>バッファープール</strong></span>内の<span class="bold"><strong>ページ</strong></span>。ここでは、変更はまだ<a class="link" href="glossary.html#glos_data_files" title="データファイル">データファイル</a>に書き込まれて (<span class="bold"><strong>フラッシュされて</strong></span>) いません。<span class="bold"><strong>クリーンページ</strong></span>の反対です。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_clean_page">クリーンページ</a>, <a class="glossseealso" href="glossary.html#glos_data_files">データファイル</a>, <a class="glossseealso" href="glossary.html#glos_flush">フラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>も参照</p></dd><dt><a name="glos_dirty_read"></a><span class="glossterm">ダーティー読み取り</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985764064"></a>
        信頼できないデータ、つまり別のトランザクションによって更新されたけれども、まだ<span class="bold"><strong>コミット</strong></span>されていないデータを取得する操作。これは、<span class="bold"><strong>コミットされた読み取り</strong></span>と呼ばれる<span class="bold"><strong>分離レベル</strong></span>でのみ可能です。
      </p><p>
        この種の操作は、データベース設計の <span class="bold"><strong>ACID</strong></span> 原則には準拠しません。これは非常にリスクが高いと見なされます。データを<span class="bold"><strong>ロールバック</strong></span>できたり、コミットされる前にさらに更新できたりするためです。この場合、ダーティー読み取りを行うトランザクションは、正確であると確定されていないデータを使用することになります。
      </p><p>
        この正反対が<span class="bold"><strong>一貫性読み取り</strong></span>です。InnoDB はあらゆる手を尽くして、トランザクションが別のトランザクションによって更新された情報を読み取らないことを保証します (別のトランザクションがその間にコミットした場合でも)。
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_commit">コミット</a>, <a class="glossseealso" href="glossary.html#glos_consistent_read">一貫性読み取り</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_read_committed">READ COMMITTED</a>, <a class="glossseealso" href="glossary.html#glos_read_uncommitted">READ UNCOMMITTED</a>, <a class="glossseealso" href="glossary.html#glos_rollback">ロールバック</a>も参照</p></dd><dt><a name="glos_wait"></a><span class="glossterm">待機</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985751872"></a>
        <span class="bold"><strong>ロック</strong></span>、<span class="bold"><strong>相互排他ロック</strong></span>、または<span class="bold"><strong>ラッチ</strong></span>を獲得するなどの操作を即座に完了できないとき、InnoDB は一時停止して再試行します。この一時停止のメカニズムはかなり入念に設計されているため、この操作には独自の名前、<span class="bold"><strong>待機</strong></span>が付けられています。個々のスレッドは、内部 InnoDB スケジューリング、オペレーティングシステム <code class="literal">wait()</code> 呼び出し、および短期間<span class="bold"><strong>スピン</strong></span>ループの組み合わせを使用して一時停止されます。
      </p><p>
        重い負荷と多数のトランザクションが発生するシステムでは、<code class="literal">SHOW INNODB STATUS</code> コマンドからの出力を使用して、スレッドに非常に多くの時間を待機に消費しているかどうか、該当する場合は<span class="bold"><strong>並列性</strong></span>をどのように改善できるかを判断できます。
      </p><p><a class="glossseealso" href="glossary.html#glos_concurrency">並列性</a>, <a class="glossseealso" href="glossary.html#glos_latch">ラッチ</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_mutex">相互排他ロック</a>, <a class="glossseealso" href="glossary.html#glos_spin">スピン</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">チ</h3><dl><dt><a name="glos_checksum"></a><span class="glossterm">チェックサム</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985735856"></a>
        <span class="bold"><strong>テーブルスペース</strong></span>内の<span class="bold"><strong>ページ</strong></span>がディスクから InnoDB <span class="bold"><strong>バッファープール</strong></span>に読み込まれるときに破損を検出する、<code class="literal">InnoDB</code> での検証メカニズム。<code class="literal">innodb_checksums</code> 構成オプションで、この機能のオンとオフが切り替わります。MySQL 5.6 では、構成オプション <code class="literal">innodb_checksum_algorithm=crc32</code> も指定することによって、高速なチェックサムアルゴリズムを有効にできます。
      </p><p>
        <span class="command"><strong>innochecksum</strong></span> コマンドは、MySQL Server がシャットダウンする間に、指定の<span class="bold"><strong>テーブルスペース</strong></span>ファイルのチェックサム値をテストすることによって、破損の問題の診断に役立ちます。
      </p><p>
        MySQL はレプリケーションのためにチェックサムも使用します。詳細は、構成オプション <code class="literal">binlog_checksum</code>、<code class="literal">master_verify_checksum</code>、および <code class="literal">slave_sql_verify_checksum</code> を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>, <a class="glossseealso" href="glossary.html#glos_tablespace">テーブルスペース</a>も参照</p></dd><dt><a name="glos_checkpoint"></a><span class="glossterm">チェックポイント</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985721008"></a>
        <span class="bold"><strong>バッファープール</strong></span>にキャッシュされているデータページに変更が行われると、これらの変更は少しあとから<span class="bold"><strong>データファイル</strong></span>に書き込まれます。これは<span class="bold"><strong>フラッシュ</strong></span>と呼ばれるプロセスです。チェックポイントは、データファイルに正しく書き込まれている (<span class="bold"><strong>LSN</strong></span> 値で表される) 最新の変更のレコードです。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_data_files">データファイル</a>, <a class="glossseealso" href="glossary.html#glos_flush">フラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_fuzzy_checkpointing">ファジーチェックポイント</a>, <a class="glossseealso" href="glossary.html#glos_lsn">LSN</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">テ</h3><dl><dt><a name="glos_text_collection"></a><span class="glossterm">テキストコレクション</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985515840"></a>
        <span class="bold"><strong>FULLTEXT インデックス</strong></span>に含まれるカラムセット。
      </p><p><a class="glossseealso" href="glossary.html#glos_fulltext_index">FULLTEXT インデックス</a>も参照</p></dd><dt><a name="glos_table"></a><span class="glossterm">テーブル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985636384"></a>
        各 MySQL テーブルは、特定の<span class="bold"><strong>ストレージエンジン</strong></span>に関連付けられます。<span class="bold"><strong>InnoDB</strong></span> テーブルは、パフォーマンス、<span class="bold"><strong>スケーラビリティー</strong></span>、<span class="bold"><strong>バックアップ</strong></span>、管理、およびアプリケーション開発に影響する、特定の<span class="bold"><strong>物理</strong></span>および<span class="bold"><strong>論理</strong></span>特性を持っています。
      </p><p>
        ファイルストレージの観点では、各 InnoDB テーブルは、単一の大きな InnoDB <span class="bold"><strong>システムテーブルスペース</strong></span>の一部か、またはテーブルが <span class="bold"><strong>file-per-table</strong></span> モードで作成される場合は別個の <span class="bold"><strong><code class="literal">.ibd</code></strong></span> ファイル内です。<span class="bold"><strong><code class="literal">.ibd</code></strong></span> ファイルは、テーブルとそのすべての<span class="bold"><strong>インデックス</strong></span>のデータを保持し、<span class="bold"><strong>テーブルスペース</strong></span>と呼ばれます。
      </p><p>
        file-per-table テーブルで作成される InnoDB テーブルは、<span class="bold"><strong>Barracuda</strong></span> ファイル形式を使用できます。Barracuda テーブルは、<span class="bold"><strong>DYNAMIC 行フォーマット</strong></span>または <span class="bold"><strong>COMPRESSED 行フォーマット</strong></span>を使用できます。これらの比較的新しい設定は、<span class="bold"><strong>圧縮</strong></span>、<span class="bold"><strong>高速インデックス作成</strong></span>、<span class="bold"><strong>オフページカラム</strong></span>などのいくつかの InnoDB 機能を有効にします
      </p><p>
        MySQL 5.1 以前との後方互換性のため、システムテーブルスペース内部の InnoDB テーブルは、<span class="bold"><strong>コンパクト行フォーマット</strong></span>と<span class="bold"><strong>冗長行フォーマット</strong></span>をサポートする <span class="bold"><strong>Antelope</strong></span> ファイル形式を使用する必要があります。
      </p><p>
        InnoDB テーブルの<span class="bold"><strong>行</strong></span>は、テーブルの<span class="bold"><strong>主キー</strong></span>カラムに基づいてエントリがソートされた、<span class="bold"><strong>クラスタ化されたインデックス</strong></span>と呼ばれるインデックス構造に編成されます。データアクセスは主キーカラムでフィルタおよびソートするクエリーに最適化され、各インデックスには各エントリに関連付けられた主キーカラムのコピーが含まれます。主キーカラムの値を変更することは負荷の高い操作です。したがって、InnoDB テーブル設計の重要な側面は、もっとも重要なクエリーで使用されるカラムで主キーを選択し、主キーは短くし、値はめったに変更しないことです。
      </p><p><a class="glossseealso" href="glossary.html#glos_antelope">Antelope</a>, <a class="glossseealso" href="glossary.html#glos_backup">バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_barracuda">Barracuda</a>, <a class="glossseealso" href="glossary.html#glos_clustered_index">クラスタ化されたインデックス</a>, <a class="glossseealso" href="glossary.html#glos_compact_row_format">コンパクト行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_compressed_row_format">圧縮行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_compression">圧縮</a>, <a class="glossseealso" href="glossary.html#glos_dynamic_row_format">動的行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_fast_index_creation">高速インデックス作成</a>, <a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_ibd_file">.ibd ファイル</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_off_page_column">オフページカラム</a>, <a class="glossseealso" href="glossary.html#glos_primary_key">主キー</a>, <a class="glossseealso" href="glossary.html#glos_redundant_row_format">冗長行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_row">行</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_tablespace">テーブルスペース</a>も参照</p></dd><dt><a name="glos_full_table_scan"></a><span class="glossterm">テーブルの完全スキャン</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985563392"></a>
        インデックスを使用して選択した部分だけでなく、テーブルの内容全体を読み取る必要がある操作。通常は、小さなルックアップテーブル、またはすべての利用可能なデータが集約および分析される大きなテーブルを持つデータウェアハウジング状況で実行されます。これらの操作が行われる頻度と、利用可能なメモリーに関連するテーブルのサイズは、クエリー最適化とバッファープール管理で使用されるアルゴリズムに密接な関係があります。
      </p><p>
        <span class="bold"><strong>インデックス</strong></span>の目的は、大きなテーブル内で特定の値または値の範囲をルックアップできるようにし、したがって有用なときはフルテーブルスキャンを回避することです。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_lru">LRU</a>も参照</p></dd><dt><a name="glos_table_scan"></a><span class="glossterm">テーブルスキャン</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_full_table_scan">テーブルの完全スキャン</a>も参照</p></dd><dt><a name="glos_tablespace"></a><span class="glossterm">テーブルスペース</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985600592"></a>
        1 つ以上の InnoDB <span class="bold"><strong>テーブル</strong></span>および関連付けられた<span class="bold"><strong>インデックス</strong></span>のデータを保持できるデータファイル。<span class="bold"><strong>システムテーブルスペース</strong></span>は、<span class="bold"><strong>データディクショナリ</strong></span>を構成するテーブルを含み、MySQL 5.6 以前ではデフォルトでほかの InnoDB テーブルをすべて保持します。<code class="literal">innodb_file_per_table</code> オプションをオンにすると (MySQL 5.6 以降のデフォルト)、新しく作成されるテーブルに独自のテーブルスペース、テーブルごとに別個の<span class="bold"><strong>データファイル</strong></span>が割り当てられます。
      </p><p>
        <code class="literal">innodb_file_per_table</code> オプションをオンにして複数のテーブルスペースを使用することは、テーブル圧縮やトランスポータブルテーブルスペースなどの多くの MySQL 機能を使用し、ディスク使用状況を管理することにとって非常に重要です。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-multiple-tablespaces" title="14.5.2 InnoDB File-Per-Table モード">セクション14.5.2「InnoDB File-Per-Table モード」</a>を参照してください。
      </p><p>
        組み込み InnoDB ストレージエンジンで作成されるテーブルスペースは、InnoDB Plugin と上方互換です。InnoDB Plugin で作成されるテーブルスペースは、<span class="bold"><strong>Antelope</strong></span> ファイル形式を使用する場合は、組み込み InnoDB ストレージエンジンと下方互換です。
      </p><p>
        MySQL Cluster はそのテーブルもテーブルスペースにグループ化します。詳細は、<a class="xref" href="mysql-cluster.html#mysql-cluster-disk-data-objects" title="18.5.12.1 MySQL Cluster ディスクデータオブジェクト">セクション18.5.12.1「MySQL Cluster ディスクデータオブジェクト」</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_antelope">Antelope</a>, <a class="glossseealso" href="glossary.html#glos_barracuda">Barracuda</a>, <a class="glossseealso" href="glossary.html#glos_compressed_row_format">圧縮行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_data_dictionary">データディクショナリ</a>, <a class="glossseealso" href="glossary.html#glos_data_files">データファイル</a>, <a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_innodb_file_per_table">innodb_file_per_table</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>も参照</p></dd><dt><a name="glos_tablespace_dictionary"></a><span class="glossterm">テーブルスペースディクショナリ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985581904"></a>
        InnoDB <span class="bold"><strong>テーブルスペース</strong></span>内で、テーブルの<span class="bold"><strong>データディクショナリ</strong></span>メタデータの表現。テーブルが開かれるときにこのメタデータを <span class="bold"><strong>.frm ファイル</strong></span>に対して一貫性をチェックすることで、古い <code class="literal">.frm</code> ファイルが原因のエラーを診断できます。この情報は、<span class="bold"><strong>システムテーブルスペース</strong></span>の一部である InnoDB テーブルと、<span class="bold"><strong>file-per-table</strong></span> オプションのために独自の <span class="bold"><strong>.ibd ファイル</strong></span>を持つテーブルに提示されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_data_dictionary">データディクショナリ</a>, <a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_frm_file">.frm ファイル</a>, <a class="glossseealso" href="glossary.html#glos_ibd_file">.ibd ファイル</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_tablespace">テーブルスペース</a>も参照</p></dd><dt><a name="glos_table_type"></a><span class="glossterm">テーブルタイプ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985570960"></a>
        <span class="bold"><strong>ストレージエンジン</strong></span>の古いシノニムです。<code class="literal">InnoDB</code> テーブル、<code class="literal">MyISAM</code> テーブルなどと呼びます。
      </p><p><a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>, <a class="glossseealso" href="glossary.html#glos_storage_engine">ストレージエンジン</a>も参照</p></dd><dt><a name="glos_table_lock"></a><span class="glossterm">テーブルロック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985557648"></a>
        ほかの<span class="bold"><strong>トランザクション</strong></span>がテーブルにアクセスすることを防ぐロック。InnoDB では、<span class="bold"><strong>DML</strong></span> ステートメントと<span class="bold"><strong>クエリー</strong></span>の処理に<span class="bold"><strong>オンライン DDL</strong></span>、<span class="bold"><strong>行ロック</strong></span>、<span class="bold"><strong>一貫性読み取り</strong></span>などの方法を使用することで、このようなロックを不要にするためにかなりの努力を割いています。SQL から <code class="literal">LOCK TABLE</code> ステートメントを使用してこのようなロックを作成できます。ほかのデータベースシステムまたは MySQL ストレージエンジンから移行するステップの 1 つは、可能なときはこのようなステートメントを削除することです。
      </p><p><a class="glossseealso" href="glossary.html#glos_consistent_read">一貫性読み取り</a>, <a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_online_ddl">オンライン DDL</a>, <a class="glossseealso" href="glossary.html#glos_query">クエリー</a>, <a class="glossseealso" href="glossary.html#glos_row_lock">行ロック</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_table_statistics"></a><span class="glossterm">テーブル統計</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_statistics">統計</a>も参照</p></dd><dt><a name="glos_disk_bound"></a><span class="glossterm">ディスクバウンド</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985708448"></a>
        主な<span class="bold"><strong>ボトルネック</strong></span>がディスク I/O であるタイプの<span class="bold"><strong>ワークロード</strong></span>。(<span class="bold"><strong>I/O バウンド</strong></span>とも呼ばれます。)通常は、ディスクへの頻繁な書き込みや、<span class="bold"><strong>バッファープール</strong></span>に収められるよりも多くのデータのランダム読み取りがかかわります。
      </p><p><a class="glossseealso" href="glossary.html#glos_bottleneck">ボトルネック</a>, <a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_cpu_bound">CPU バウンド</a>, <a class="glossseealso" href="glossary.html#glos_workload">ワークロード</a>も参照</p></dd><dt><a name="glos_disk_based"></a><span class="glossterm">ディスクベース</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985701008"></a>
        主にディスクストレージ (ハードドライブまたはその同等物) 上のデータを編成するタイプのデータベース。データは、ディスクとメモリー間でやり取りされて操作されます。<span class="bold"><strong>インメモリーデータベース</strong></span>の反対です。InnoDB はディスクベースですが、<span class="bold"><strong>バッファー</strong></span>プールなどの機能、複数のバッファープールインスタンス、および特定の種類のワークロードが主にメモリーから作業できるようにする<span class="bold"><strong>適応型ハッシュインデックス</strong></span>も含まれます。
      </p><p><a class="glossseealso" href="glossary.html#glos_adaptive_hash_index">適応型ハッシュインデックス</a>, <a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_in_memory_database">インメモリーデータベース</a>も参照</p></dd><dt><a name="glos_deadlock"></a><span class="glossterm">デッドロック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985500864"></a>
        さまざまな<span class="bold"><strong>トランザクション</strong></span>が進行できない状況 (それぞれが、他方が必要とする<span class="bold"><strong>ロック</strong></span>を保持しているため)。リソースが利用可能になるまで両方のトランザクションが待機しているため、どちらもそれが保持しているロックを解放しません。
      </p><p>
        (<code class="literal">UPDATE</code> や <code class="literal">SELECT ... FOR UPDATE</code> などのステートメントを通じて) トランザクションが複数のテーブル内の行を反対の順にロックすると、デッドロックが発生することがあります。デッドロックは、このようなステートメントがインデックスレコードと<span class="bold"><strong>ギャップ</strong></span>の範囲をロックし、各トランザクションが一部のロックを取得するけれども、タイミングの問題によりほかを取得しない場合にも発生することがあります。
      </p><p>
        デッドロックの可能性を減らすには、<code class="literal">LOCK TABLE</code> ステートメントではなくトランザクションを使用したり、データを挿入または更新するトランザクションを長期間開かないでいいように小さくしたり、さまざまなトランザクションが複数のテーブルまたは大きな範囲の行を更新するときに、各トランザクションで同じ操作順序を使用したり (<code class="literal">SELECT ... FOR UPDATE</code> など)、<code class="literal">SELECT ... FOR UPDATE</code> および <code class="literal">UPDATE ... WHERE</code> ステートメントで使用されるカラムにインデックスを作成したりしてください。デッドロックの可能性は、<span class="bold"><strong>分離レベル</strong></span>に影響を受けません。分離レベルは読み取り操作の動作を変更し、デッドロックは書き込み操作のために発生するからです。
      </p><p>
        デッドロックが発生した場合、InnoDB は状況を検出し、いずれかのトランザクション (<span class="bold"><strong>デッドロック対象</strong></span>) を<span class="bold"><strong>ロールバック</strong></span>します。したがって、アプリケーションロジックが完全に正しい場合でも、トランザクションを再試行する必要があるケースを扱う必要があります。InnoDB ユーザートランザクションでの最後のデッドロックを確認するには、コマンド <code class="literal">SHOW ENGINE INNODB STATUS</code> を使用してください。デッドロックが頻繁に発生して、トランザクション構造やアプリケーションエラー処理に問題があるらしいと思われる場合は、<code class="literal">mysqld</code> エラーログにすべてのデッドロックに関する情報を出力するために、<code class="literal">innodb_print_all_deadlocks</code> 設定を有効にした状態で実行してください。
      </p><p>
        自動的にデッドロックを検出して処理する方法に関する背景情報については、<a class="xref" href="innodb-storage-engine.html#innodb-deadlock-detection" title="14.2.10 デッドロックの検出とロールバック">セクション14.2.10「デッドロックの検出とロールバック」</a>を参照してください。デッドロック状況を回避しリカバリするためのヒントについては、<a class="xref" href="innodb-storage-engine.html#innodb-deadlocks" title="14.2.11 デッドロックの対処方法">セクション14.2.11「デッドロックの対処方法」</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_concurrency">並列性</a>, <a class="glossseealso" href="glossary.html#glos_gap">ギャップ</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_rollback">ロールバック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>, <a class="glossseealso" href="glossary.html#glos_victim">デッドロック対象</a>も参照</p></dd><dt><a name="glos_victim"></a><span class="glossterm">デッドロック対象</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985468688"></a>
        <span class="bold"><strong>デッドロック</strong></span>が検出されたときにロールバック対象として自動的に選択されるトランザクション。InnoDB は、更新した行数がもっとも少ないトランザクションをロールバックします。
      </p><p><a class="glossseealso" href="glossary.html#glos_deadlock">デッドロック</a>, <a class="glossseealso" href="glossary.html#glos_deadlock_detection">デッドロック検出</a>, <a class="glossseealso" href="glossary.html#glos_innodb_lock_wait_timeout">innodb_lock_wait_timeout</a>も参照</p></dd><dt><a name="glos_deadlock_detection"></a><span class="glossterm">デッドロック検出</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985476032"></a>
        <span class="bold"><strong>デッドロック</strong></span>が起きていることを自動的に検出し、関係する<span class="bold"><strong>トランザクション</strong></span>のいずれか (<span class="bold"><strong>デッドロック対象</strong></span>) を自動的に<span class="bold"><strong>ロールバック</strong></span>するメカニズム。
      </p><p><a class="glossseealso" href="glossary.html#glos_deadlock">デッドロック</a>, <a class="glossseealso" href="glossary.html#glos_rollback">ロールバック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>, <a class="glossseealso" href="glossary.html#glos_victim">デッドロック対象</a>も参照</p></dd><dt><a name="glos_data_warehouse"></a><span class="glossterm">データウェアハウス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985686352"></a>
        主に大きな<span class="bold"><strong>クエリー</strong></span>を実行するデータベースシステムまたはアプリケーション。読み取り専用または読み取りが大半のデータは、クエリーの効率を高めるために<span class="bold"><strong>非正規化された</strong></span>形式で編成できます。MySQL 5.6 以降では、<span class="bold"><strong>読み取り専用トランザクション</strong></span>の最適化からメリットを得ることができます。<span class="bold"><strong>OLTP</strong></span> と対比してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_denormalized">非正規化</a>, <a class="glossseealso" href="glossary.html#glos_oltp">OLTP</a>, <a class="glossseealso" href="glossary.html#glos_query">クエリー</a>, <a class="glossseealso" href="glossary.html#glos_read_only_transaction">読み取り専用トランザクション</a>も参照</p></dd><dt><a name="glos_data_dictionary"></a><span class="glossterm">データディクショナリ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985675792"></a>
        <span class="bold"><strong>テーブル</strong></span>、<span class="bold"><strong>インデックス</strong></span>、テーブル<span class="bold"><strong>カラム</strong></span>などの InnoDB 関連オブジェクトを追跡するメタデータ。このメタデータは、InnoDB <span class="bold"><strong>システムテーブルスペース</strong></span>に物理的に置かれています。これまでの経緯が理由で、これは <span class="bold"><strong>.frm ファイル</strong></span>に格納された情報とある程度重複します。
      </p><p>
        <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品は常にシステムテーブルスペースをバックアップするため、すべてのバックアップにデータディクショナリの内容が含まれます。
      </p><p><a class="glossseealso" href="glossary.html#glos_column">カラム</a>, <a class="glossseealso" href="glossary.html#glos_frm_file">.frm ファイル</a>, <a class="glossseealso" href="glossary.html#glos_hot_backup">ホットバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>も参照</p></dd><dt><a name="glos_data_directory"></a><span class="glossterm">データディレクトリ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985664496"></a>
        それぞれの MySQL <span class="bold"><strong>インスタンス</strong></span>が InnoDB 用の<span class="bold"><strong>データファイル</strong></span>を保持しているディレクトリと、個々のデータベースを表すディレクトリ。<code class="literal">datadir</code> 構成オプションによって制御されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_data_files">データファイル</a>, <a class="glossseealso" href="glossary.html#glos_instance">インスタンス</a>も参照</p></dd><dt><a name="glos_data_files"></a><span class="glossterm">データファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985658448"></a>
        物理的に InnoDB <span class="bold"><strong>テーブル</strong></span>および<span class="bold"><strong>インデックス</strong></span>データを含むファイル。<span class="bold"><strong>システムテーブルスペース</strong></span> (<span class="bold"><strong>データディクショナリ</strong></span>と同様に複数の InnoDB テーブルを保持できる) の場合のように、データファイルとテーブルとの間に 1 対多関係が存在することがあります。<span class="bold"><strong>file-per-table</strong></span> 設定が有効で、新しく作成する各テーブルが個別の<span class="bold"><strong>テーブルスペース</strong></span>に格納されるときのように、データファイルとテーブルとの間に 1 対 1 関係が存在することもあります。
      </p><p><a class="glossseealso" href="glossary.html#glos_data_dictionary">データディクショナリ</a>, <a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>, <a class="glossseealso" href="glossary.html#glos_tablespace">テーブルスペース</a>も参照</p></dd><dt><a name="glos_database"></a><span class="glossterm">データベース</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985648192"></a>
        MySQL <span class="bold"><strong>データディレクトリ</strong></span>内では、各データベースは個別のディレクトリで表されます。InnoDB <span class="bold"><strong>システムテーブルスペース</strong></span> (MySQL <span class="bold"><strong>インスタンス</strong></span>内で複数のデータベースからテーブルデータを保持できる) は、個々のデータベースディレクトリの外部に存在するその<span class="bold"><strong>データファイル</strong></span>に保持されます。<span class="bold"><strong>file-per-table</strong></span> モードが有効のときは、個々の InnoDB テーブルを表す <span class="bold"><strong>.ibd ファイル</strong></span>がデータベースディレクトリ内部に格納されます。
      </p><p>
        長年 MySQL を使用している人にとって、データベースはなじみ深い概念です。Oracle Database のバックグラウンドを持つユーザーは、MySQL でのデータベースの意味は Oracle Database で<span class="bold"><strong>スキーマ</strong></span>と呼ばれているものに似ています。
      </p><p><a class="glossseealso" href="glossary.html#glos_data_files">データファイル</a>, <a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_ibd_file">.ibd ファイル</a>, <a class="glossseealso" href="glossary.html#glos_instance">インスタンス</a>, <a class="glossseealso" href="glossary.html#glos_schema">スキーマ</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>も参照</p></dd><dt><a name="glos_data_definition_language"></a><span class="glossterm">データ定義言語</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_ddl">DDL</a>も参照</p></dd><dt><a name="glos_data_manipulation_language"></a><span class="glossterm">データ操作言語</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_dml">DML</a>も参照</p></dd><dt><a name="glos_low_water_mark"></a><span class="glossterm">低位境界値</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985712400"></a>
        下限を表す値。通常は、何らかの訂正アクションが始まったり、より積極的になったりするしきい値です。<span class="bold"><strong>高位境界値</strong></span>と対比してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_high_water_mark">高位境界値</a>も参照</p></dd><dt><a name="glos_slow_shutdown"></a><span class="glossterm">低速シャットダウン</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985694080"></a>
        完了前に追加 <code class="literal">InnoDB</code> フラッシュ操作を行うタイプのシャットダウン。<span class="bold"><strong>クリーンシャットダウン</strong></span>とも呼ばれます。構成パラメータ <code class="literal">innodb_fast_shutdown=0</code> またはコマンド <code class="literal">SET GLOBAL innodb_fast_shutdown=0;</code> で指定されます。シャットダウン自体は時間がかかる可能性がありますが、その時間は後続の起動で節約されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_clean_shutdown">クリーンシャットダウン</a>, <a class="glossseealso" href="glossary.html#glos_fast_shutdown">高速シャットダウン</a>, <a class="glossseealso" href="glossary.html#glos_shutdown">シャットダウン</a>も参照</p></dd><dt><a name="glos_inverted_index"></a><span class="glossterm">転置インデックス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985463760"></a>
        ドキュメント検索システムに最適化され、InnoDB <span class="bold"><strong>全文検索</strong></span>の実装で使用されるデータ構造。転置インデックスとして実装される InnoDB <span class="bold"><strong>FULLTEXT インデックス</strong></span>は、テーブル行の場所ではなく、ドキュメント内での各語の位置を記録します。単一カラム値 (テキスト文字列として格納されたドキュメント) は多くのエントリで転置インデックスで表現されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_full_text_search">全文検索</a>, <a class="glossseealso" href="glossary.html#glos_fulltext_index">FULLTEXT インデックス</a>, <a class="glossseealso" href="glossary.html#glos_ilist">ilist</a>も参照</p></dd><dt><a name="glos_adaptive_hash_index"></a><span class="glossterm">適応型ハッシュインデックス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985544752"></a>
        メモリー内に<span class="bold"><strong>ハッシュインデックス</strong></span>を構築することにより、<code class="literal">=</code> および <code class="literal">IN</code> 演算子を使用したルックアップを高速化できる、InnoDB テーブルの最適化。MySQL は、InnoDB テーブルのインデックス検索をモニターし、ハッシュインデックスによりクエリーにメリットがある場合は、頻繁にアクセスされるインデックス<span class="bold"><strong>ページ</strong></span>に対してこれを自動的に構築します。ある意味では、適応型ハッシュインデックスは、十分なメインメモリーを利用するように MySQL を実行時に構成するので、メインメモリーデータベースのアーキテクチャーに近づいています。この機能は、<code class="literal">innodb_adaptive_hash_index</code> 構成オプションで制御されます。この機能は、一部のワークロードにはメリットがあってもほかのものにはメリットがなく、ハッシュインデックスに使用されるメモリーは<span class="bold"><strong>バッファープール</strong></span>で予約されているので、通常はこの機能を有効にした状態と無効にした状態でベンチマークを行うことをお勧めします。
      </p><p>
        ハッシュインデックスは常に、<span class="bold"><strong>B ツリー</strong></span>構造として構成されている、既存の InnoDB <span class="bold"><strong>セカンダリインデックス</strong></span>に基づいて構築されます。MySQL は、インデックスに対する検索パターンに応じて、B ツリーに定義された任意の長さのキーのプリフィクスに、ハッシュインデックスを構築できます。ハッシュインデックスは部分的であってもかまいません。B ツリーインデックス全体をバッファープールにキャッシュする必要はありません。
      </p><p>
        MySQL 5.6 以降では、InnoDB テーブルで高速な単一値ルックアップを利用するには、このほかに、InnoDB との <span class="bold"><strong>memcached</strong></span> インタフェースを使用するという方法があります。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-memcached" title="14.18 InnoDB と memcached の統合">セクション14.18「InnoDB と memcached の統合」</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_b_tree">B ツリー</a>, <a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_hash_index">ハッシュインデックス</a>, <a class="glossseealso" href="glossary.html#glos_memcached">memcached</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>, <a class="glossseealso" href="glossary.html#glos_secondary_index">セカンダリインデックス</a>も参照</p></dd><dt><a name="glos_adaptive_flushing"></a><span class="glossterm">適応型フラッシュ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985527680"></a>
        <span class="bold"><strong>チェックポイント</strong></span>によって生じる I/O オーバーヘッドを軽減する <span class="bold"><strong>InnoDB</strong></span> テーブル用のアルゴリズム。MySQL は、変更されたすべての<span class="bold"><strong>ページ</strong></span>を<span class="bold"><strong>バッファープール</strong></span>から<span class="bold"><strong>データファイル</strong></span>に一度に<span class="bold"><strong>フラッシュ</strong></span>するのではなく、変更されたページの小さなセットを定期的にフラッシュします。適応型フラッシュアルゴリズムは、フラッシュの頻度と <span class="bold"><strong>Redo</strong></span> 情報の生成速度に基づいてこれらの定期フラッシュの最適な実行頻度を見積もることによって、このプロセスを拡張します。最初は MySQL 5.1 で InnoDB Plugin に導入されました。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_checkpoint">チェックポイント</a>, <a class="glossseealso" href="glossary.html#glos_data_files">データファイル</a>, <a class="glossseealso" href="glossary.html#glos_flush">フラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>, <a class="glossseealso" href="glossary.html#glos_redo_log">Redo ログ</a>も参照</p></dd><dt><a name="glos_apply"></a><span class="glossterm">適用</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985512288"></a>
        <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品で生成されたバックアップに、バックアップ進行中に行われた最新の変更が含まれない場合、これらの変更を含むようにバックアップファイルを更新するプロセスは<span class="bold"><strong>適用</strong></span>ステップと呼ばれます。これは <code class="literal">mysqlbackup</code> コマンドの <code class="literal">apply-log</code> オプションで指定されます。
      </p><p>
        変更が適用されるまでは、このファイルは <span class="bold"><strong>raw バックアップ</strong></span>と呼ばれます。変更が適用されたあとは、このファイルは<span class="bold"><strong>準備されたバックアップ</strong></span>と呼ばれます。変更は、<span class="bold"><strong>ibbackup_logfile</strong></span> ファイルに記録されます。適用ステップが終了すると、このファイルは不要になります。
      </p><p><a class="glossseealso" href="glossary.html#glos_hot_backup">ホットバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_ibbackup_logfile">ibbackup_logfile</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_prepared_backup">準備されたバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_raw_backup">raw バックアップ</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ト</h3><dl><dt><a name="glos_troubleshooting"></a><span class="glossterm">トラブルシューティング</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985413040"></a>
        InnoDB の信頼性とパフォーマンスの問題をトラブルシューティングするためのリソースには、情報スキーマテーブルが含まれます。
      </p></dd><dt><a name="glos_transaction"></a><span class="glossterm">トランザクション</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985410272"></a>
        トランザクションは、作業の原子単位で、この単位でコミットまたはロールバックできます。トランザクションによってデータベースに複数の変更が行われた場合、トランザクションがコミットされるとすべての変更が完了し、トランザクションがロールバックされるとすべての変更が元に戻されます。
      </p><p>
        InnoDB が実装するデータベーストランザクションには、原始性、一貫性、分離性、持続性を表す頭字語 <span class="bold"><strong>ACID</strong></span> で総称される特性があります。
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_commit">コミット</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_rollback">ロールバック</a>も参照</p></dd><dt><a name="glos_transaction_id"></a><span class="glossterm">トランザクション ID</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985403216"></a>
        各行に関連付けられた内部フィールド。このフィールドは、どのトランザクションがその行をロックしたかを記録するために、INSERT、UPDATE、および DELETE 操作によって物理的に変更されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_implicit_row_lock">暗黙の行ロック</a>も参照</p></dd><dt><a name="glos_transportable_tablespace"></a><span class="glossterm">トランスポータブルテーブルスペース</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985399680"></a>
        <span class="bold"><strong>テーブルスペース</strong></span>があるインスタンスから別のインスタンスに移動されることを許可する機能。従来の InnoDB テーブルスペースではこれができませんでした。すべてのテーブルデータが<span class="bold"><strong>システムテーブルスペース</strong></span>の一部であったためです。MySQL 5.6 以降では、<code class="literal">FLUSH TABLES ... FOR EXPORT</code> 構文で別のサーバーにコピーできるように InnoDB テーブルを準備してから、<code class="literal">ALTER TABLE ... DISCARD TABLESPACE</code> および <code class="literal">ALTER TABLE ... IMPORT TABLESPACE</code> をほかのサーバー上で実行すると、コピーされたデータファイルがほかのインスタンスに移動します。テーブルスペースがインポートされるときに、別個の <code class="filename">.cfg</code> ファイルが、<span class="bold"><strong>.ibd ファイル</strong></span>とともにコピーされ、テーブルメタデータ (たとえば<span class="bold"><strong>スペース ID</strong></span>) の更新に使用されます。使用に関する情報は <a class="xref" href="innodb-storage-engine.html#tablespace-copying" title="14.5.5 テーブルスペースの別のサーバーへのコピー (トランスポータブルテーブルスペース)">セクション14.5.5「テーブルスペースの別のサーバーへのコピー (トランスポータブルテーブルスペース)」</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_ibd_file">.ibd ファイル</a>, <a class="glossseealso" href="glossary.html#glos_space_id">スペース ID</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_tablespace">テーブルスペース</a>も参照</p></dd><dt><a name="glos_document_id"></a><span class="glossterm">ドキュメント ID</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985423024"></a>
        InnoDB <span class="bold"><strong>全文検索</strong></span>機能における、各 <span class="bold"><strong>ilist</strong></span> 値に関連付けられたドキュメントを一意に識別するための、<span class="bold"><strong>FULLTEXT インデックス</strong></span>を含むテーブル内の特殊カラム。その名前は <code class="literal">FTS_DOC_ID</code> (大文字必須) です。カラム自体は、<code class="literal">BIGINT UNSIGNED NOT NULL</code> 型で、<code class="literal">FTS_DOC_ID_INDEX</code> という名前の一意インデックス付きである必要があります。テーブルの作成時にこのカラムを定義することが推奨されます。InnoDB が <code class="literal">FULLTEXT</code> インデックスの作成中にカラムをテーブルに追加する必要がある場合、インデックス作成操作の負荷が大幅に増大します。
      </p><p><a class="glossseealso" href="glossary.html#glos_full_text_search">全文検索</a>, <a class="glossseealso" href="glossary.html#glos_fulltext_index">FULLTEXT インデックス</a>, <a class="glossseealso" href="glossary.html#glos_ilist">ilist</a>も参照</p></dd><dt><a name="glos_drop"></a><span class="glossterm">ドロップ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985386176"></a>
        <span class="bold"><strong>DDL</strong></span> 操作の一種。<code class="literal">DROP TABLE</code> や <code class="literal">DROP INDEX</code> などのステートメントを通じてスキーマオブジェクトを削除します。これは内部的に <code class="literal">ALTER TABLE</code> ステートメントにマッピングします。InnoDB の観点からは、このような操作のパフォーマンス考慮事項としては、相互関連オブジェクトがすべて更新されるように<span class="bold"><strong>データディクショナリ</strong></span>をロックする時点と、<span class="bold"><strong>バッファープール</strong></span>などのメモリー構造を更新する時点があります。<span class="bold"><strong>テーブル</strong></span>の場合、ドロップ操作には、<span class="bold"><strong>切り捨て</strong></span>操作 (<code class="literal">TRUNCATE TABLE</code> ステートメント) と多少異なる特性があります。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_data_dictionary">データディクショナリ</a>, <a class="glossseealso" href="glossary.html#glos_ddl">DDL</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>, <a class="glossseealso" href="glossary.html#glos_truncate">切り捨て</a>も参照</p></dd><dt><a name="glos_dynamic_row_format"></a><span class="glossterm">動的行フォーマット</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985435168"></a>
        <code class="literal">InnoDB</code> Plugin で導入された行フォーマットの 1 つ。<span class="bold"><strong>Barracuda</strong></span> <span class="bold"><strong>ファイル形式</strong></span>の一部として利用できます。行データを保持しているページの残りの外部に <code class="literal">TEXT</code> および <code class="literal">BLOB</code> フィールドが格納されるので、これはラージオブジェクトを含む行にとって非常に効率的です。ラージフィールドは通常、クエリー条件を評価するためにアクセスされることはないので、頻繁には<span class="bold"><strong>バッファープール</strong></span>に読み込まれません。その結果、I/O 操作は少なくなり、キャッシュメモリーの利用率が改善します。
      </p><p>
        <code class="literal">InnoDB</code> <code class="literal">DYNAMIC</code> 行フォーマットの追加情報については、<a class="xref" href="innodb-storage-engine.html#innodb-row-format-dynamic" title="14.9.3 DYNAMIC および COMPRESSED 行フォーマット">セクション14.9.3「DYNAMIC および COMPRESSED 行フォーマット」</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_barracuda">Barracuda</a>, <a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_file_format">ファイル形式</a>, <a class="glossseealso" href="glossary.html#glos_row_format">行フォーマット</a>も参照</p></dd><dt><a name="glos_statistics"></a><span class="glossterm">統計</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985457392"></a>
        各 <code class="literal">InnoDB</code> <span class="bold"><strong>テーブル</strong></span>および<span class="bold"><strong>インデックス</strong></span>に関連する評価値。効率的な<span class="bold"><strong>クエリー実行計画</strong></span>の構築に使用されます。メイン値は、<span class="bold"><strong>カーディナリティー</strong></span> (個別値の数) と、テーブル行またはインデックスエントリの合計数です。テーブルの統計は、その<span class="bold"><strong>主キー</strong></span>インデックス内のデータを表します。<span class="bold"><strong>セカンダリインデックス</strong></span>の統計は、このインデックスで扱われる行を表します。
      </p><p>
        値は正確なカウントではなく、見積もりです。あらゆる瞬間にさまざまな<span class="bold"><strong>トランザクション</strong></span>が同じテーブルからの行を挿入したり削除したりしている可能性があるためです。値が頻繁に再計算されないように、<span class="bold"><strong>永続的統計</strong></span>を有効にできます。この場合、値は <code class="literal">InnoDB</code> システムテーブルに格納され、<code class="literal">ANALYZE TABLE</code> ステートメントを発行するときにのみ更新されます。
      </p><p>
        <code class="literal">innodb_stats_method</code> 構成オプションで統計を計算するときに、<span class="bold"><strong>NULL</strong></span> 値がどのように扱われるかを制御できます。
      </p><p>
        <span class="bold"><strong>INFORMATION_SCHEMA</strong></span> および <span class="bold"><strong>PERFORMANCE_SCHEMA</strong></span> テーブルを通じて、ほかのタイプの統計をデータベースオブジェクトおよびデータベースアクティビティーに利用できます。
      </p><p><a class="glossseealso" href="glossary.html#glos_cardinality">カーディナリティー</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_information_schema">INFORMATION_SCHEMA</a>, <a class="glossseealso" href="glossary.html#glos_null">NULL</a>, <a class="glossseealso" href="glossary.html#glos_performance_schema">パフォーマンススキーマ</a>, <a class="glossseealso" href="glossary.html#glos_persistent_statistics">永続的統計</a>, <a class="glossseealso" href="glossary.html#glos_primary_key">主キー</a>, <a class="glossseealso" href="glossary.html#glos_query_execution_plan">クエリー実行計画</a>, <a class="glossseealso" href="glossary.html#glos_secondary_index">セカンダリインデックス</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ナ</h3><dl><dt><a name="glos_natural_key"></a><span class="glossterm">ナチュラルキー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985372320"></a>
        値が現実世界の何らかの意味を持つインデックスカラム (通常は<span class="bold"><strong>主キー</strong></span>)。通常は、次の理由のため推奨されていません。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            値が万が一変化した場合、<span class="bold"><strong>クラスタ化されたインデックス</strong></span>を再ソートし、それぞれの<span class="bold"><strong>セカンダリインデックス</strong></span>で繰り返される主キー値のコピーを更新するために、多数インデックス保守が必要になる可能性があります。
          </p></li><li class="listitem"><p>
            一見したところ安定した値でも、データベースで正しく表すことが難しい予測不可能な変化をすることがあります。たとえば、1 つの国が 2 つ以上に分かれ、元の国コードが古くなることがあります。または、一意値に関するルールに例外が発生する場合があります。たとえば、納税者 ID が単一の人物に一意であるように意図されている場合でも、データベースでは、ID 窃盗などでそのルールに違反するレコードを処理する必要があることがあります。また、納税者 ID やその他の機密 ID 番号からは、低品質の主キーが作成されます。それらはセキュリティー保護し、暗号化し、またはほかのカラムと異なる方法で扱う必要がある場合があるためです。
          </p></li></ul></div><p>
        したがって通常は、<span class="bold"><strong>自動インクリメント</strong></span>カラムを使用するなど、任意の数値を使用して<span class="bold"><strong>合成キー</strong></span>を作成することをお勧めします。
      </p><p><a class="glossseealso" href="glossary.html#glos_auto_increment">自動インクリメント</a>, <a class="glossseealso" href="glossary.html#glos_primary_key">主キー</a>, <a class="glossseealso" href="glossary.html#glos_secondary_index">セカンダリインデックス</a>, <a class="glossseealso" href="glossary.html#glos_synthetic_key">合成キー</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ニ</h3><dl><dt><a name="glos_doublewrite_buffer"></a><span class="glossterm">二重書き込みバッファー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985358816"></a>
        InnoDB は、二重書き込みと呼ばれる新しいファイルフラッシュ方法を使用します。<span class="bold"><strong>ページ</strong></span>を<span class="bold"><strong>データファイル</strong></span>に書き込む前に、InnoDB は最初に二重書き込みバッファーと呼ばれる連続領域に書き込みます。二重書き込みバッファーへの書き込みとフラッシュが完了したあとにはじめて、InnoDB はそれらのページをデータファイル内の適切な位置に書き込みます。ページ書き込みの最中にオペレーティングシステム、ストレージサブシステム、または <span class="command"><strong>mysqld</strong></span> プロセスのクラッシュが発生した場合、InnoDB は、あとで<span class="bold"><strong>クラッシュリカバリ</strong></span>中にそのページの正常なコピーを二重書き込みバッファーから見つけることができます。
      </p><p>
        データは常に 2 度書き込まれますが、二重書き込みバッファーには、2 倍の I/O オーバーヘッドも 2 倍の I/O 操作も不要です。データは、オペレーティングシステムへの単一 <code class="literal">fsync()</code> 呼び出しで、大きなシーケンシャルチャンクとしてバッファー自体に書き込まれます。
      </p><p>
        二重書き込みバッファーをオフにするには、オプション <code class="literal">innodb_doublewrite=0</code> を指定します。
      </p><p><a class="glossseealso" href="glossary.html#glos_crash_recovery">クラッシュリカバリ</a>, <a class="glossseealso" href="glossary.html#glos_data_files">データファイル</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>, <a class="glossseealso" href="glossary.html#glos_purge">パージ</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ネ</h3><dl><dt><a name="glos_next_key_lock"></a><span class="glossterm">ネクストキーロック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985346160"></a>
        インデックスレコードでの<span class="bold"><strong>レコードロック</strong></span>と、インデックスレコードの前のギャップでの<a class="link" href="glossary.html#glos_gap_lock" title="ギャップロック">ギャップロック</a>の組み合わせ。
      </p><p><a class="glossseealso" href="glossary.html#glos_gap_lock">ギャップロック</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_record_lock">レコードロック</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ハ</h3><dl><dt><a name="glos_hash_index"></a><span class="glossterm">ハッシュインデックス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985261136"></a>
        大なりや <code class="literal">BETWEEN</code> などの範囲演算子ではなく、等値演算子を使用するクエリーを対象とするタイプの<span class="bold"><strong>インデックス</strong></span>。MEMORY テーブルに利用できます。これまでの経緯が理由でハッシュインデックスは MEMORY テーブルのデフォルトですが、そのストレージエンジンは <span class="bold"><strong>B ツリー</strong></span>インデックスもサポートします。こちらのほうが汎用目的のクエリーにとって適切な選択肢であることが多いです。
      </p><p>
        MySQL には、このインデックス型のバリアントである<span class="bold"><strong>適応型ハッシュインデックス</strong></span>が含まれます。これは必要に応じて実行時の条件に基づいて InnoDB テーブル用に自動的に構築されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_adaptive_hash_index">適応型ハッシュインデックス</a>, <a class="glossseealso" href="glossary.html#glos_b_tree">B ツリー</a>, <a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>も参照</p></dd><dt><a name="glos_heartbeat"></a><span class="glossterm">ハートビート</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985313456"></a>
        システムが適切に機能していることを示すために送信される定期的メッセージ。<span class="bold"><strong>レプリケーション</strong></span>コンテキストでは、<span class="bold"><strong>マスター</strong></span>がこのようなメッセージの送信を停止した場合、<span class="bold"><strong>スレーブ</strong></span>の 1 つがそれに代わることができます。クラスタ環境内のすべてのサーバーが正しく動作していることを確認するために、それらの間で類似の方法を使用できます。
      </p><p><a class="glossseealso" href="glossary.html#glos_replication">レプリケーション</a>も参照</p></dd><dt><a name="glos_binary_log"></a><span class="glossterm">バイナリログ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985297136"></a>
        テーブルデータを変更しようとするすべてのステートメントのレコードを含むファイル。<span class="bold"><strong>レプリケーション</strong></span>シナリオでスレーブサーバーを最新にしたり、バックアップからテーブルデータをリストアしたあとでデータベースを最新にしたりするために、これらのステートメントを再現できます。バイナリロギング機能は、オンとオフを切り替えられますが、レプリケーションを使用したりバックアップを実行したりする場合は、常に有効にしておくことをお勧めします。
      </p><p>
        <span class="command"><strong>mysqlbinlog</strong></span> コマンドを使用することによって、バイナリログの内容を調べたり、レプリケーションまたはリカバリ中にこれらのステートメントを再現したりできます。バイナリログの詳細は、<a class="xref" href="server-administration.html#binary-log" title="5.2.4 バイナリログ">セクション5.2.4「バイナリログ」</a>を参照してください。バイナリログに関連した MySQL 構成オプションについては、<a class="xref" href="replication.html#replication-options-binary-log" title="17.1.4.4 バイナリログのオプションと変数">セクション17.1.4.4「バイナリログのオプションと変数」</a>を参照してください。
      </p><p>
        <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品の場合、バイナリログのファイル名とファイル内での現在の位置が重要な詳細です。レプリケーションコンテキストでバックアップを取得するときにマスターサーバーに関するこの情報を記録するために、<code class="literal">--slave-info</code> オプションを指定できます。
      </p><p>
        MySQL 5.0 より前では、更新ログと呼ばれる同様の機能を利用できました。MySQL 5.0 以上では、更新ログがバイナリログに置き換わりました。
      </p><p><a class="glossseealso" href="glossary.html#glos_binlog">binlog</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_replication">レプリケーション</a>も参照</p></dd><dt><a name="glos_bounce"></a><span class="glossterm">バウンス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985284768"></a>
        直後に再起動が行われる<span class="bold"><strong>シャットダウン</strong></span>操作。パフォーマンスとスループットが迅速に高いレベルに戻るように、<span class="bold"><strong>ウォームアップ</strong></span>期間が比較的短ければ理想的です。
      </p><p><a class="glossseealso" href="glossary.html#glos_shutdown">シャットダウン</a>も参照</p></dd><dt><a name="glos_backup"></a><span class="glossterm">バックアップ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985275280"></a>
        保護するために、MySQL インスタンスから一部またはすべてのテーブルデータおよびメタデータをコピーするプロセス。コピーされたファイルのセットを指す場合もあります。これは DBA のきわめて重要なタスクです。このプロセスの反対が<span class="bold"><strong>リストア</strong></span>操作です。
      </p><p>
        MySQL では、<span class="bold"><strong>物理バックアップ</strong></span>は <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品で実行され、<span class="bold"><strong>論理バックアップ</strong></span>は <code class="literal">mysqldump</code> コマンドで実行されます。これらの方法は、バックアップデータのサイズおよび表現と速度 (特にリストア操作の速度) の点で特性が異なります。
      </p><p>
        バックアップはさらに、通常のデータベース操作に干渉する程度に応じて、<span class="bold"><strong>ホット</strong></span>、<span class="bold"><strong>ウォーム</strong></span>、<span class="bold"><strong>コールド</strong></span>に分類されます。(干渉の程度は、ホットバックアップがもっとも少なく、コールドバックアップがもっとも多くなります。)
      </p><p><a class="glossseealso" href="glossary.html#glos_cold_backup">コールドバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_hot_backup">ホットバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_logical_backup">論理バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_mysqldump">mysqldump</a>, <a class="glossseealso" href="glossary.html#glos_physical_backup">物理バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_warm_backup">ウォームバックアップ</a>も参照</p></dd><dt><a name="glos_buffer"></a><span class="glossterm">バッファー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985252560"></a>
        一時ストレージに使用されるメモリーまたはディスク領域。多数の小さな I/O 操作ではなく少数の大きなものでディスクに効率的に書き込めるように、データはメモリーにバッファリングされます。データは、信頼性を高めるためにディスクにバッファリングされるので、考えられる最悪の場合に<span class="bold"><strong>クラッシュ</strong></span>やほかの障害が発生してもリカバリできます。InnoDB により使用されるバッファーの主なタイプは、<span class="bold"><strong>バッファープール</strong></span>、<span class="bold"><strong>二重書き込みバッファー</strong></span>、および<span class="bold"><strong>挿入バッファー</strong></span>です。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_crash">クラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_doublewrite_buffer">二重書き込みバッファー</a>, <a class="glossseealso" href="glossary.html#glos_insert_buffer">挿入バッファー</a>も参照</p></dd><dt><a name="glos_buffer_pool"></a><span class="glossterm">バッファープール</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985244480"></a>
        テーブルとインデックスの両方のキャッシュされた InnoDB データを保持するメモリー領域。大容量読み取り操作の効率を高めるため、バッファープールは複数行を保持できる<span class="bold"><strong>ページ</strong></span>に分割されます。キャッシュ管理の効率のために、バッファープールはページのリンクリストとして実装されます。まれにしか使用されないデータは、<span class="bold"><strong>LRU</strong></span> アルゴリズムのバリエーションを使用してキャッシュからエージアウトされます。大容量メモリーを備えたシステムでは、バッファープールを複数の<span class="bold"><strong>バッファープールインスタンス</strong></span>に分割することにより、並列性を改善できます。
      </p><p>
        複数の <code class="literal">InnoDB</code> ステータス変数、<code class="literal">information_schema</code> テーブル、および <code class="literal">performance_schema</code> テーブルは、バッファープールの内部動作のモニターに役立ちます。MySQL 5.6 以降では、<code class="literal">innodb_buffer_pool_dump_at_shutdown</code> や <code class="literal">innodb_buffer_pool_load_at_startup</code> などの <code class="literal">InnoDB</code> 構成変数セットを通じて、シャットダウンおよび再起動中に自動的に、または随時手動で、バッファープールの内容をダンプおよびリストアすることもできます。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool_instance">バッファープールインスタンス</a>, <a class="glossseealso" href="glossary.html#glos_lru">LRU</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>, <a class="glossseealso" href="glossary.html#glos_warm_up">ウォームアップ</a>も参照</p></dd><dt><a name="glos_buffer_pool_instance"></a><span class="glossterm">バッファープールインスタンス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985230480"></a>
        <span class="bold"><strong>バッファープール</strong></span>は複数の領域に分割できますが、そのいずれか。<code class="literal">innodb_buffer_pool_instances</code> 構成オプションで制御されます。<code class="literal">innodb_buffer_pool_size</code> で指定された総メモリーサイズは、すべてのインスタンスに配分されます。複数のバッファープールインスタンスは通常、数 G バイトを InnoDB バッファープールに、1G バイト以上を各インスタンスに割り当てるシステムに適しています。多くの並列セッションからの大容量のデータをバッファープールにロードしそこで検索するシステム上では、複数のインスタンスがあれば、バッファープールを管理するデータ構造への排他的アクセスに対する競合が軽減します。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>も参照</p></dd><dt><a name="glos_buddy_allocator"></a><span class="glossterm">バディーアロケータ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985223488"></a>
        InnoDB <span class="bold"><strong>バッファープール</strong></span>でさまざまなサイズの<span class="bold"><strong>ページ</strong></span>を管理するためのメカニズム。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>, <a class="glossseealso" href="glossary.html#glos_page_size">page size</a>も参照</p></dd><dt><a name="glos_performance_schema"></a><span class="glossterm">パフォーマンススキーマ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985218048"></a>
        <code class="literal">performance_schema</code> スキーマは (MySQL 5.5 以降)、MySQL Server の多くの内部パーツのパフォーマンス特性に関する詳細情報を取得するために照会できる、テーブルセットを提供します。
      </p><p><a class="glossseealso" href="glossary.html#glos_latch">ラッチ</a>, <a class="glossseealso" href="glossary.html#glos_mutex">相互排他ロック</a>, <a class="glossseealso" href="glossary.html#glos_rw_lock">rw ロック (読み書きロック)</a>も参照</p></dd><dt><a name="glos_purge"></a><span class="glossterm">パージ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985340096"></a>
        別個のスレッドによって実行されるタイプのガベージコレクション。定期的スケジュールで実行されます。パージにはこれらのアクションが含まれます: インデックスから古い値を削除する、以前の <code class="literal">DELETE</code> ステートメントで削除とマークされた行を物理的に削除する。
      </p><p><a class="glossseealso" href="glossary.html#glos_crash_recovery">クラッシュリカバリ</a>, <a class="glossseealso" href="glossary.html#glos_delete">削除</a>, <a class="glossseealso" href="glossary.html#glos_doublewrite_buffer">二重書き込みバッファー</a>も参照</p></dd><dt><a name="glos_purge_thread"></a><span class="glossterm">パージスレッド</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985334768"></a>
        InnoDB プロセス内の<span class="bold"><strong>スレッド</strong></span>の 1 つで、定期<span class="bold"><strong>パージ</strong></span>操作を実行するためのもの。MySQL 5.6 以降では、複数のパージスレッドが <code class="literal">innodb_purge_threads</code> 構成オプションによって有効になっています。
      </p><p><a class="glossseealso" href="glossary.html#glos_purge">パージ</a>, <a class="glossseealso" href="glossary.html#glos_thread">スレッド</a>も参照</p></dd><dt><a name="glos_purge_buffering"></a><span class="glossterm">パージバッファリング</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985322784"></a>
        <code class="literal">DELETE</code> 操作によるインデックス変更を即座に書き込むのではなく、<span class="bold"><strong>挿入バッファー</strong></span>に格納して、物理的な書き込みを実行してランダム I/O を最小限に抑える方法。(削除操作は 2 ステッププロセスなので、この操作は、通常は以前に削除とマークされたインデックスレコードをパージする書き込みをバッファリングします。)これは<span class="bold"><strong>変更バッファリング</strong></span>の一種です。ほかには<span class="bold"><strong>挿入バッファリング</strong></span>と<span class="bold"><strong>削除バッファリング</strong></span>があります。
      </p><p><a class="glossseealso" href="glossary.html#glos_change_buffer">変更バッファー</a>, <a class="glossseealso" href="glossary.html#glos_change_buffering">変更バッファリング</a>, <a class="glossseealso" href="glossary.html#glos_delete_buffering">削除バッファリング</a>, <a class="glossseealso" href="glossary.html#glos_insert_buffer">挿入バッファー</a>, <a class="glossseealso" href="glossary.html#glos_insert_buffering">挿入バッファリング</a>も参照</p></dd><dt><a name="glos_purge_lag"></a><span class="glossterm">パージ遅延</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985328720"></a>
        <code class="literal">InnoDB</code> <span class="bold"><strong>履歴リスト</strong></span>の別の名前。<code class="literal">innodb_max_purge_lag</code> 構成オプションに関連しています。
      </p><p><a class="glossseealso" href="glossary.html#glos_history_list">履歴リスト</a>, <a class="glossseealso" href="glossary.html#glos_purge">パージ</a>も参照</p></dd><dt><a name="glos_semi_consistent_read"></a><span class="glossterm">半一貫性読み取り</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985212976"></a>
        <code class="literal">UPDATE</code> ステートメントで使用されるタイプの読み取り操作。<span class="bold"><strong>コミットされた読み取り</strong></span>と<span class="bold"><strong>一貫性読み取り</strong></span>の組み合わせ。<code class="literal">UPDATE</code> ステートメントがすでにロックされている行を調べるとき、行が <code class="literal">UPDATE</code> の <code class="literal">WHERE</code> 条件に一致しているかどうかを MySQL が判断できるように、InnoDB は最後にコミットされたバージョンを MySQL に返します。行が一致する場合 (更新する必要がある場合)、MySQL は行を再度読み取り、InnoDB は今度はそれをロックするか、そのロックを待機します。このタイプの読み取り操作は、トランザクションの<span class="bold"><strong>分離レベル</strong></span>がコミットされた読み取りで場合、または <code class="literal">innodb_locks_unsafe_for_binlog</code> オプションが有効である場合にのみ発生できます。
      </p><p><a class="glossseealso" href="glossary.html#glos_consistent_read">一貫性読み取り</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_read_committed">READ COMMITTED</a>も参照</p></dd><dt><a name="glos_non_repeatable_read"></a><span class="glossterm">反復不可能読み取り</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985201856"></a>
        あるクエリーがデータを取得し、同じ<span class="bold"><strong>トランザクション</strong></span>内のその後のクエリーが同じデータであるはずのものを取得するけれども、それらのクエリーが異なる結果を返す状況 (その間にコミットしている別のトランザクションによって変更された)。
      </p><p>
        この種の操作は、データベース設計の <span class="bold"><strong>ACID</strong></span> 原則に反します。トランザクション内のデータは、予測可能で安定した関係を持ち、一貫しているべきです。
      </p><p>
        さまざまな<span class="bold"><strong>分離レベル</strong></span>の中で、反復不可能読み取りは、<span class="bold"><strong>シリアライズ可能読み取り</strong></span>と<span class="bold"><strong>反復可能読み取り</strong></span>レベルによって防止され、<span class="bold"><strong>一貫性読み取り</strong></span>と<span class="bold"><strong>コミットされていない読み取り</strong></span>レベルで許可されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_consistent_read">一貫性読み取り</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_read_uncommitted">READ UNCOMMITTED</a>, <a class="glossseealso" href="glossary.html#glos_repeatable_read">REPEATABLE READ</a>, <a class="glossseealso" href="glossary.html#glos_serializable">SERIALIZABLE</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_exclusive_lock"></a><span class="glossterm">排他ロック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985307920"></a>
        ほかの<span class="bold"><strong>トランザクション</strong></span>が同じ行をロックするのを回避するタイプの<span class="bold"><strong>ロック</strong></span>。この種のロックは、トランザクション<span class="bold"><strong>分離レベル</strong></span>に応じて、ほかのトランザクションが同じ行に書き込むのをブロックしたり、ほかのトランザクションが同じ行を読み取るのをブロックしたりできます。デフォルト InnoDB 分離レベル、<span class="bold"><strong>REPEATABLE READ</strong></span> は、排他ロックを持つ行をトランザクションが読み取ることを許可する (<span class="bold"><strong>一貫性読み取り</strong></span>と呼ばれる方法) ことによって、より高い<span class="bold"><strong>並列性</strong></span>を実現します。
      </p><p><a class="glossseealso" href="glossary.html#glos_concurrency">並列性</a>, <a class="glossseealso" href="glossary.html#glos_consistent_read">一貫性読み取り</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_repeatable_read">REPEATABLE READ</a>, <a class="glossseealso" href="glossary.html#glos_shared_lock">共有ロック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_torn_page"></a><span class="glossterm">破損ページ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985280352"></a>
        I/O デバイス構成とハードウェア障害の組み合わせが原因で発生する可能性のあるエラー状況。データが InnoDB <span class="bold"><strong>ページサイズ</strong></span> (デフォルトで 16K バイト) より小さなチャンクで書き出される場合、書き込み中のハードウェア障害によってページの一部だけがディスクに格納されることがあります。InnoDB <span class="bold"><strong>二重書き込みバッファー</strong></span>を使用することで、この可能性から保護されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_doublewrite_buffer">二重書き込みバッファー</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ヒ</h3><dl><dt><a name="glos_business_rules"></a><span class="glossterm">ビジネスルール</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985188560"></a>
        営利企業を運営するために使用される、ビジネスソフトウェアの基盤を形作るアクションの関係およびシーケンス。これらのルールは、法律によって規定されたり、企業ポリシーで規定されたります。慎重に計画することで、データベースでエンコードされ適用される関係と、アプリケーションロジックを通じて実行されるアクションが、企業の実際のポリシーを正確に反映し、現実の状況を扱うことができます。
      </p><p>
        たとえば、従業員が会社を退職すると、人事部からアクションシーケンスがトリガーされます。人事データベースには、雇用されたけれどもまだ就業していない人物に関するデータを表すために、柔軟性も必要になることがあります。オンラインサービスで口座を閉鎖すると、データがデータベースから削除されたり、口座が再度開設されたりした場合にリカバリできるようにデータが移動またはフラグ付けされたります。企業は、給与が負数でないなどの基本的なサニティーチェックに加えて、給与の最大、最小、および調整に関するポリシーを確立できます。小売データベースでは、同じシリアル番号の購入を複数回返すことを禁止したり、一定値を超えるクレジットカード購入を禁止したりしますが、詐欺の検出に使用されるデータベースでは、このようなことを許可する場合があります。
      </p><p><a class="glossseealso" href="glossary.html#glos_relational">リレーショナル</a>も参照</p></dd><dt><a name="glos_non_blocking_io"></a><span class="glossterm">非ブロック I/O</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985166528"></a>
        <span class="bold"><strong>非同期 I/O</strong></span>と同じ意味を持つ業界用語。
      </p><p><a class="glossseealso" href="glossary.html#glos_asynchronous_io">非同期 I/O</a>も参照</p></dd><dt><a name="glos_non_locking_read"></a><span class="glossterm">非ロック読み取り</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985162912"></a>
        <code class="literal">SELECT ... FOR UPDATE</code> または <code class="literal">SELECT ... LOCK IN SHARE MODE</code> 句を使用しない<span class="bold"><strong>クエリー</strong></span>。<span class="bold"><strong>読み取り専用トランザクション</strong></span>でグローバルテーブルに許可される唯一の種類のクエリー。<span class="bold"><strong>ロック読み取り</strong></span>の反対。
      </p><p><a class="glossseealso" href="glossary.html#glos_locking_read">ロック読み取り</a>, <a class="glossseealso" href="glossary.html#glos_query">クエリー</a>, <a class="glossseealso" href="glossary.html#glos_read_only_transaction">読み取り専用トランザクション</a>も参照</p></dd><dt><a name="glos_asynchronous_io"></a><span class="glossterm">非同期 I/O</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985175920"></a>
        I/O が完了するまでほかの処理の進行を許可する I/O 操作のタイプ。<span class="bold"><strong>非ブロック I/O</strong></span> とも呼ばれ、<span class="bold"><strong>AIO</strong></span> と略記されます。InnoDB は、実際にはリクエストされていないがすぐに必要になる可能性のあるページを<span class="bold"><strong>バッファープール</strong></span>に読み取るなど、データベースの信頼性に影響を与えずに並列で実行できる操作にこのタイプの I/O を使用します。
      </p><p>
        InnoDB は従来、Windows システムでのみ非同期 I/O を使用してきました。InnoDB Plugin 1.1 および MySQL 5.5 以降から、InnoDB は Linux システムで非同期 I/O を使用します。この変更により、<code class="literal">libaio</code> への依存関係がもたらされます。Linux システムでの非同期 I/O は、<code class="literal">innodb_use_native_aio</code> オプションを使用して構成されます。これはデフォルトで有効になっています。ほかの Unix 系システムでは、InnoDB は同期 I/O だけを使用します。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_non_blocking_io">非ブロック I/O</a>も参照</p></dd><dt><a name="glos_denormalized"></a><span class="glossterm">非正規化</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985182848"></a>
        <span class="bold"><strong>外部キー</strong></span>と<span class="bold"><strong>結合</strong></span>クエリーでテーブルをリンクするのではなく、複数のテーブルにわたってデータを複製するデータストレージ戦略。通常は<span class="bold"><strong>データウェアハウス</strong></span>アプリケーションで使用されます。この場合、データはロード後に更新されません。このようなアプリケーションでは、更新中にデータの一貫性を維持することを簡略化するよりも、クエリーパフォーマンスが重要になります。<span class="bold"><strong>正規化</strong></span>と対比してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_data_warehouse">データウェアハウス</a>, <a class="glossseealso" href="glossary.html#glos_normalized">正規化</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">フ</h3><dl><dt><a name="glos_file_format"></a><span class="glossterm">ファイル形式</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985154752"></a>
        InnoDB で各テーブルに使用される形式。通常は、各テーブルが個別の <span class="bold"><strong><code class="literal">.ibd</code> ファイル</strong></span>に格納されるように、<span class="bold"><strong>file-per-table</strong></span> 設定が有効にされます。現在、InnoDB で利用できるファイル形式は <span class="bold"><strong>Antelope</strong></span> および <span class="bold"><strong>Barracuda</strong></span> と呼ばれています。各ファイル形式は、1 つ以上の<span class="bold"><strong>行フォーマット</strong></span>をサポートします。Barracuda テーブルで利用できる行フォーマット、<span class="bold"><strong>COMPRESSED</strong></span> および <span class="bold"><strong>DYNAMIC</strong></span> は、InnoDB テーブルの新しい重要なストレージ機能を有効にします。
      </p><p><a class="glossseealso" href="glossary.html#glos_antelope">Antelope</a>, <a class="glossseealso" href="glossary.html#glos_barracuda">Barracuda</a>, <a class="glossseealso" href="glossary.html#glos_file_per_table">file-per-table</a>, <a class="glossseealso" href="glossary.html#glos_ibd_file">.ibd ファイル</a>, <a class="glossseealso" href="glossary.html#glos_ibdata_file">ibdata ファイル</a>, <a class="glossseealso" href="glossary.html#glos_row_format">行フォーマット</a>も参照</p></dd><dt><a name="glos_fuzzy_checkpointing"></a><span class="glossterm">ファジーチェックポイント</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985142912"></a>
        データベース処理を妨害する<span class="bold"><strong>ダーティーページ</strong></span>を一度にすべてフラッシュするのではなく、ダーティーページの小さなバッチを<span class="bold"><strong>バッファープール</strong></span>から<span class="bold"><strong>フラッシュ</strong></span>する方法。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_dirty_page">ダーティーページ</a>, <a class="glossseealso" href="glossary.html#glos_flush">フラッシュ</a>も参照</p></dd><dt><a name="glos_phantom"></a><span class="glossterm">ファントム</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985136720"></a>
        あるクエリーの結果セットに出現するけれども、以前のクエリーの結果セットにない行。たとえば、あるクエリーが<span class="bold"><strong>トランザクション</strong></span>内で 2 度実行されて、その間に別のトランザクションがそのクエリーの <code class="literal">WHERE</code> 句に一致する新しい行を挿入または行を更新したあとにコミットされた場合です。
      </p><p>
        この現象がファントム読み取りと呼ばれます。このことから保護することは、<span class="bold"><strong>反復不可能読み取り</strong></span>よりも困難です。最初のクエリー結果セットからのすべての行をロックしても、ファントムが出現する変更は防止されないためです。
      </p><p>
        さまざまな<span class="bold"><strong>分離レベル</strong></span>の中で、ファントム読み取りは、<span class="bold"><strong>シリアライズ可能読み取り</strong></span>で防止され、<span class="bold"><strong>反復可能読み取り</strong></span>、<span class="bold"><strong>一貫性読み取り</strong></span>、および<span class="bold"><strong>コミットされていない読み取り</strong></span>レベルで許可されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_consistent_read">一貫性読み取り</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_non_repeatable_read">反復不可能読み取り</a>, <a class="glossseealso" href="glossary.html#glos_read_uncommitted">READ UNCOMMITTED</a>, <a class="glossseealso" href="glossary.html#glos_repeatable_read">REPEATABLE READ</a>, <a class="glossseealso" href="glossary.html#glos_serializable">SERIALIZABLE</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_fill_factor"></a><span class="glossterm">フィルファクタ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985122960"></a>
        InnoDB <span class="bold"><strong>インデックス</strong></span>において、ページが分割される前にインデックスデータで占められる<span class="bold"><strong>ページ</strong></span>の割合。ページ間でインデックスデータが最初に分割されるときの未使用領域によって、負荷のかかるインデックス保守操作を必要とすることなく、より長い文字列値で行を更新できます。フィルファクタが低すぎた場合、インデックスは必要以上の領域を消費し、インデックスを読み取るときに余分な I/O オーバーヘッドが生じます。フィルファクタが高すぎると、カラム値の長さが増える更新で、インデックス保守の追加 I/O オーバーヘッドが生じる可能性があります。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-physical-structure" title="14.2.13.4 InnoDB インデックスの物理構造">セクション14.2.13.4「InnoDB インデックスの物理構造」</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>も参照</p></dd><dt><a name="glos_flush"></a><span class="glossterm">フラッシュ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985072992"></a>
        メモリー領域または一時ディスクストレージ領域にバッファリングされていた変更をデータベースファイルに書き込むこと。定期的にフラッシュされる InnoDB ストレージ構造には、<span class="bold"><strong>Redo ログ</strong></span>、<span class="bold"><strong>Undo ログ</strong></span>、および<span class="bold"><strong>バッファープール</strong></span>が含まれます。
      </p><p>
        フラッシュは、メモリー領域がいっぱいになってシステムが一部の領域を解放する必要があるため、<span class="bold"><strong>コミット</strong></span>操作が、トランザクションからの変更を完結できることを意味するため、または<span class="bold"><strong>低速シャットダウン</strong></span>操作が、すべての未処理作業を完結するべきであることを意味するため、行われます。バッファリングされているデータすべてを一度にフラッシュすることが重要でないときは、<code class="literal">InnoDB</code> は、<span class="bold"><strong>ファジーチェックポイント</strong></span>という方法を使用して、ページの小さなバッチをフラッシュし、I/O オーバーヘッドを分散させることができます。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_commit">コミット</a>, <a class="glossseealso" href="glossary.html#glos_fuzzy_checkpointing">ファジーチェックポイント</a>, <a class="glossseealso" href="glossary.html#glos_neighbor_page">隣接ページ</a>, <a class="glossseealso" href="glossary.html#glos_redo_log">Redo ログ</a>, <a class="glossseealso" href="glossary.html#glos_slow_shutdown">低速シャットダウン</a>, <a class="glossseealso" href="glossary.html#glos_undo_log">Undo ログ</a>も参照</p></dd><dt><a name="glos_flush_list"></a><span class="glossterm">フラッシュリスト</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985060304"></a>
        <span class="bold"><strong>バッファープール</strong></span>内の<span class="bold"><strong>ダーティーページ</strong></span> (変更されて、ディスクに書き戻す必要がある<span class="bold"><strong>ページ</strong></span>) を追跡する内部 InnoDB データ構造。このデータ構造は、InnoDB の内部<span class="bold"><strong>ミニトランザクション</strong></span>によって頻繁に更新されるため、バッファープールへの同時アクセスを許可するように独自の<span class="bold"><strong>相互排他ロック</strong></span>で保護されています。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_dirty_page">ダーティーページ</a>, <a class="glossseealso" href="glossary.html#glos_lru">LRU</a>, <a class="glossseealso" href="glossary.html#glos_mini_transaction">ミニトランザクション</a>, <a class="glossseealso" href="glossary.html#glos_mutex">相互排他ロック</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>, <a class="glossseealso" href="glossary.html#glos_page_cleaner">ページクリーナー</a>も参照</p></dd><dt><a name="glos_blind_query_expansion"></a><span class="glossterm">ブラインドクエリー拡張</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985085312"></a>
        <code class="literal">WITH QUERY EXPANSION</code> 句で有効になる<span class="bold"><strong>全文検索</strong></span>の特別なモード。これは検索を 2 度実行し、2 度目の検索には、最初の検索で検出されたドキュメントからのもっとも関連性の強い少数の単語をつなぎ合わせた、独自の検索語句を使用します。この方法は、主に短い検索語句、おそらく単一単語のみに適用されます。これは、正確な検索語句がドキュメント内で現れない場合に、関連した一致を見つけることができます。
      </p><p><a class="glossseealso" href="glossary.html#glos_full_text_search">全文検索</a>も参照</p></dd><dt><a name="glos_plugin"></a><span class="glossterm">プラグイン</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985080064"></a>
        MySQL 5.1 以前で、個別にインストールできる形式の <span class="bold"><strong>InnoDB</strong></span> ストレージエンジン。これらのリリースに<span class="bold"><strong>内蔵されている</strong></span> InnoDB に含まれない機能およびパフォーマンス拡張機能を含んでいます。
      </p><p>
        MySQL 5.5 以降の場合、MySQL 配布に InnoDB 1.1 と呼ばれる最新の InnoDB 機能およびパフォーマンス拡張機能が含まれ、個別の InnoDB Plugin は存在しません。
      </p><p>
        この区別は、主に MySQL 5.1 で重要です。ここでは、機能またはバグ修正が InnoDB Plugin に適用され、組み込み InnoDB にされない場合や、その反対の場合があります。
      </p><p><a class="glossseealso" href="glossary.html#glos_built_in">組み込み</a>, <a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>も参照</p></dd><dt><a name="glos_prefix"></a><span class="glossterm">プリフィクス</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_index_prefix">インデックスプリフィクス</a>も参照</p></dd><dt><a name="glos_process"></a><span class="glossterm">プロセス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985048880"></a>
        実行中プログラムのインスタンス。オペレーティングシステムは、複数の実行中プロセスを切り替えることで、一定程度の<span class="bold"><strong>並列性</strong></span>を実現します。ほとんどのオペレーティングシステムのプロセスには、リソースを共有する複数の実行<span class="bold"><strong>スレッド</strong></span>を含めることができます。スレッド間のコンテキスト切り替えは、プロセス間の同等切り替えより高速です。
      </p><p><a class="glossseealso" href="glossary.html#glos_concurrency">並列性</a>, <a class="glossseealso" href="glossary.html#glos_thread">スレッド</a>も参照</p></dd><dt><a name="glos_isolation_level"></a><span class="glossterm">分離レベル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985043520"></a>
        データベース処理の基礎の 1 つ。分離は、頭字語 <span class="bold"><strong>ACID</strong></span> の <span class="bold"><strong>I</strong></span> です。分離レベルは、複数の<span class="bold"><strong>トランザクション</strong></span>が同時に変更を行ったりクエリーを実行したりしているときに、パフォーマンスと信頼性のバランス、一貫性、結果の再現性を微調整する設定です。
      </p><p>
        もっとも高い一貫性および保護からもっとも低いものまで、InnoDB でサポートされる分離レベルは、<span class="bold"><strong>SERIALIZABLE</strong></span>、<span class="bold"><strong>REPEATABLE READ</strong></span>、<span class="bold"><strong>READ COMMITTED</strong></span>、および <span class="bold"><strong>READ UNCOMMITTED</strong></span> です。
      </p><p>
        InnoDB テーブルの多くのユーザーは、すべての操作にデフォルト分離レベル (<span class="bold"><strong>REPEATABLE READ</strong></span>) を保持できます。上級ユーザーは、OLTP 処理でスケーラビリティーの境界をプッシュするとき、または小さな不整合が大量のデータの集計結果に影響しないデータウェアハウス操作中に、<span class="bold"><strong>コミットされた読み取り</strong></span>レベルを選択できます。両端のレベル (<span class="bold"><strong>SERIALIZABLE</strong></span> および <span class="bold"><strong>READ UNCOMMITTED</strong></span>) は、処理動作をまれにしか使用されない程度に変更します。
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_read_committed">READ COMMITTED</a>, <a class="glossseealso" href="glossary.html#glos_read_uncommitted">READ UNCOMMITTED</a>, <a class="glossseealso" href="glossary.html#glos_repeatable_read">REPEATABLE READ</a>, <a class="glossseealso" href="glossary.html#glos_serializable">SERIALIZABLE</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_physical"></a><span class="glossterm">物理</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985111888"></a>
        ディスクブロック、メモリーページ、ファイル、ビット、ディスク読み取りなど、ハードウェア関連側面がかかわるタイプの操作。物理側面は通常、上級者レベルのパフォーマンスチューニングおよび問題診断中に重要になります。<span class="bold"><strong>論理</strong></span>と対比してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_logical">論理</a>, <a class="glossseealso" href="glossary.html#glos_physical_backup">物理バックアップ</a>も参照</p></dd><dt><a name="glos_physical_backup"></a><span class="glossterm">物理バックアップ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985106944"></a>
        実際のデータファイルをコピーする<span class="bold"><strong>バックアップ</strong></span>。たとえば、<span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品の <span class="bold"><strong><code class="literal">mysqlbackup</code></strong></span> コマンドは物理バックアップを返します。その出力に <code class="literal">mysqld</code> サーバーが直接使用できるデータファイルが含まれているためです (<span class="bold"><strong>リストア</strong></span>操作の速度が向上します)。<span class="bold"><strong>論理バックアップ</strong></span>と対比してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_backup">バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_logical_backup">論理バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_restore">リストア</a>も参照</p></dd><dt><a name="glos_composite_index"></a><span class="glossterm">複合インデックス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985115984"></a>
        複数のカラムを含む<span class="bold"><strong>インデックス</strong></span>。
      </p><p><a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_index_prefix">インデックスプリフィクス</a>も参照</p></dd><dt><a name="glos_partial_index"></a><span class="glossterm">部分インデックス</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985097360"></a>
        カラム値の一部 (通常は、長い <code class="literal">VARCHAR</code> 値の最初の N 文字 (<span class="bold"><strong>プリフィクス</strong></span>) だけを表す) <span class="bold"><strong>インデックス</strong></span>。
      </p><p><a class="glossseealso" href="glossary.html#glos_index">インデックス</a>, <a class="glossseealso" href="glossary.html#glos_index_prefix">インデックスプリフィクス</a>も参照</p></dd><dt><a name="glos_partial_backup"></a><span class="glossterm">部分バックアップ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985091648"></a>
        MySQL データベースの<span class="bold"><strong>テーブル</strong></span>の一部、または MySQL インスタンスのデータベースの一部を含む<span class="bold"><strong>バックアップ</strong></span>。<span class="bold"><strong>完全バックアップ</strong></span>と対比してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_backup">バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_full_backup">完全バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ヘ</h3><dl><dt><a name="glos_beta"></a><span class="glossterm">ベータ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984998944"></a>
        ソフトウェア製品の存続期間の初期段階。評価にのみ利用できる期間で、通常は確定したリリース番号や 1 未満の数がありません。InnoDB ではベータの名称を使用せず、複数のポイントリリースに進展し <span class="bold"><strong>GA</strong></span> リリースに至る<span class="bold"><strong>アーリーアダプタ</strong></span>フェーズを使用します。
      </p><p><a class="glossseealso" href="glossary.html#glos_early_adopter">アーリーアダプタ</a>, <a class="glossseealso" href="glossary.html#glos_ga">GA</a>も参照</p></dd><dt><a name="glos_pessimistic"></a><span class="glossterm">ペシミスティック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984993488"></a>
        パフォーマンスまたは並列性を犠牲にして、安全性を優先する概念。リクエストまたは試行が高い割合で失敗する可能性がある場合、または失敗したリクエストの結果が深刻である場合に適しています。InnoDB は、ペシミスティック<span class="bold"><strong>ロック</strong></span>戦略と呼ばれるものを使用して、<span class="bold"><strong>デッドロック</strong></span>の可能性を最小限に抑えます。アプリケーションレベルでは、トランザクションが必要とするすべてのロックを最初に獲得するペシミスティック戦略を使用することによって、デッドロックを回避できる可能性があります。
      </p><p>
        多くのデータベースに組み込まれているメカニズムでは、反対の<span class="bold"><strong>オプティミスティック</strong></span>概念が使用されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_deadlock">デッドロック</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_optimistic">オプティミスティック</a>も参照</p></dd><dt><a name="glos_page"></a><span class="glossterm">ページ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985021376"></a>
        InnoDB がディスク (<span class="bold"><strong>データファイル</strong></span>) とメモリー (<span class="bold"><strong>バッファープール</strong></span>) 間で一度に転送するデータ量を表す単位。ページには 1 つ以上の<span class="bold"><strong>行</strong></span>を含めることができます (各行のデータ量に依存)。行全体が単一ページに収まらない場合、InnoDB はその行に関する情報を 1 ページに格納できるように、追加ポインタスタイルデータ構造を設定します。
      </p><p>
        各ページにより多くのデータを収める方法の 1 つは、<span class="bold"><strong>圧縮行フォーマット</strong></span>を使用ことです。BLOB またはラージテキストフィールドを使用するテーブルの場合、<span class="bold"><strong>コンパクト行フォーマット</strong></span>を使用してこれらのラージカラムを残りの行とは別個に格納することで、これらのカラムを参照しないクエリーの I/O オーバーヘッドとメモリー使用量を減らすことができます。
      </p><p>
        InnoDB は、I/O スループットを増やすためにページセットをバッチとして読み書きするときは、一度に 1 <span class="bold"><strong>エクステント</strong></span>を読み書きします。
      </p><p>
        MySQL インスタンス内のすべての InnoDB ディスクデータ構造は、同じ<span class="bold"><strong>ページサイズ</strong></span>を共有します。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_compact_row_format">コンパクト行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_compressed_row_format">圧縮行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_data_files">データファイル</a>, <a class="glossseealso" href="glossary.html#glos_extent">エクステント</a>, <a class="glossseealso" href="glossary.html#glos_page_size">page size</a>, <a class="glossseealso" href="glossary.html#glos_row">行</a>も参照</p></dd><dt><a name="glos_page_cleaner"></a><span class="glossterm">ページクリーナー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985007664"></a>
        InnoDB バックグラウンド<span class="bold"><strong>スレッド</strong></span>の 1 つ。<span class="bold"><strong>ダーティーページ</strong></span>を<span class="bold"><strong>バッファープール</strong></span>から<span class="bold"><strong>フラッシュ</strong></span>します。MySQL 5.6 より前では、このアクティビティーは<span class="bold"><strong>マスタースレッド</strong></span>によって実行されていました
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_dirty_page">ダーティーページ</a>, <a class="glossseealso" href="glossary.html#glos_flush">フラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_master_thread">マスタースレッド</a>, <a class="glossseealso" href="glossary.html#glos_thread">スレッド</a>も参照</p></dd><dt><a name="glos_concurrency"></a><span class="glossterm">並列性</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978985027280"></a>
        複数の操作 (データベース用語では、<span class="bold"><strong>トランザクション</strong></span>) が互いに干渉することなく同時に実行できること。並列性はパフォーマンスにも関係しています。理論的には、<span class="bold"><strong>ロック</strong></span>の効率的なメカニズムを使用して、複数の同時トランザクションの保護が最小のパフォーマンスオーバーヘッドで機能するためです。
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_change_buffering"></a><span class="glossterm">変更バッファリング</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984956624"></a>
        <span class="bold"><strong>変更バッファー</strong></span>を使用する機能の汎用用語で、<span class="bold"><strong>挿入バッファリング</strong></span>、<span class="bold"><strong>削除バッファリング</strong></span>、および<span class="bold"><strong>パージバッファリング</strong></span>から構成されます。SQL ステートメントから生じるインデックス変更は、通常はランダム I/O 操作を使用し、バックグラウンド<span class="bold"><strong>スレッド</strong></span>によって保持されて定期的に実行されます。この操作シーケンスは、値が即座にディスクに書き込まれる場合よりも効率的に、一連のインデックス値のディスクブロックを書き込むことができます。<code class="literal">innodb_change_buffering</code> および <code class="literal">innodb_change_buffer_max_size</code> 構成オプションによって制御されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_change_buffer">変更バッファー</a>, <a class="glossseealso" href="glossary.html#glos_delete_buffering">削除バッファリング</a>, <a class="glossseealso" href="glossary.html#glos_insert_buffering">挿入バッファリング</a>, <a class="glossseealso" href="glossary.html#glos_purge_buffering">パージバッファリング</a>も参照</p></dd><dt><a name="glos_change_buffer"></a><span class="glossterm">変更バッファー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984985648"></a>
        <span class="bold"><strong>セカンダリインデックス</strong></span>内の<span class="bold"><strong>ページ</strong></span>への変更を記録する特殊なデータ構造。これらの値は、SQL <code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、または <code class="literal">DELETE</code> ステートメント (<span class="bold"><strong>DML</strong></span>) の結果として発生する可能性があります。変更バッファーを使用する一連の機能は、まとめて<span class="bold"><strong>変更バッファリング</strong></span>と呼ばれ、<span class="bold"><strong>挿入バッファリング</strong></span>、<span class="bold"><strong>削除バッファリング</strong></span>、および<span class="bold"><strong>パージバッファリング</strong></span>から構成されています。
      </p><p>
        セカンダリインデックスからの関連ページが<span class="bold"><strong>バッファープール</strong></span>に存在しない場合、変更は変更バッファーにのみ記録されます。関連付けられた変更が変更バッファー内にまだあるときに該当するインデックスページがバッファープールに読み取られた場合、そのページに関する変更は、変更バッファーからのデータを使用してバッファープールに適用 (<span class="bold"><strong>マージ</strong></span>) されます。システムがほとんどアイドル状態になっているとき、または低速シャットダウン中に実行する<span class="bold"><strong>パージ</strong></span>操作は、定期的に新しいインデックスページをディスクに書き込みます。パージ操作は、それぞれの値を即座にディスクに書き込む場合よりも効率的に、一連のインデックス値のディスクブロックを書き込むことができます。
      </p><p>
        物理的に変更バッファーは、<span class="bold"><strong>システムテーブルスペース</strong></span>の一部なので、インデックス変更はデータベースの再起動をまたがってバッファーに残ります。変更は、ほかの読み取り操作によってページがバッファープールに読み取られたときにのみ、適用 (<span class="bold"><strong>マージ</strong></span>) されます。
      </p><p>
        変更バッファーに格納されたデータの種類と容量は、<code class="literal">innodb_change_buffering</code> および <code class="literal">innodb_change_buffer_max_size</code> 構成オプションで制御されます。変更バッファー内の現在のデータに関する情報を確認するには、<code class="literal">SHOW ENGINE INNODB STATUS</code> コマンドを発行してください。
      </p><p>
        以前には<span class="bold"><strong>挿入バッファー</strong></span>と呼ばれていました。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_change_buffering">変更バッファリング</a>, <a class="glossseealso" href="glossary.html#glos_delete_buffering">削除バッファリング</a>, <a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_insert_buffer">挿入バッファー</a>, <a class="glossseealso" href="glossary.html#glos_insert_buffering">挿入バッファリング</a>, <a class="glossseealso" href="glossary.html#glos_merge">マージ</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>, <a class="glossseealso" href="glossary.html#glos_purge">パージ</a>, <a class="glossseealso" href="glossary.html#glos_purge_buffering">パージバッファリング</a>, <a class="glossseealso" href="glossary.html#glos_secondary_index">セカンダリインデックス</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ホ</h3><dl><dt><a name="glos_hot"></a><span class="glossterm">ホット</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984935168"></a>
        行、テーブル、または内部データ構造が非常に頻繁にアクセスされ、何らかの形式のロックまたは相互排他が必要になり、結果としてパフォーマンスまたはスケーラビリティーの問題が発生する状況。
      </p><p>
        「ホット」は一般に望ましくない状態を示しますが、<span class="bold"><strong>ホットバックアップ</strong></span>は優先されるタイプのバックアップです。
      </p><p><a class="glossseealso" href="glossary.html#glos_hot_backup">ホットバックアップ</a>も参照</p></dd><dt><a name="glos_hot_backup"></a><span class="glossterm">ホットバックアップ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984930352"></a>
        データベースが実行中で、アプリケーションがそれに対して読み取りおよび書き込みを行なっている間に取得されるバックアップ。バックアップはデータファイルを単純にコピーするだけではありません。バックアップが進行していた間に挿入または更新されたデータを含める必要があり、バックアップが進行していた間に削除されたデータを排除する必要があり、コミットされなかった変更を無視する必要があります。
      </p><p>
        InnoDB テーブルだけでなく、特に MyISAM およびほかのストレージエンジンからのテーブルのホットバックアップも実行する Oracle 製品は、<span class="bold"><strong>MySQL Enterprise Backup</strong></span> として知られています。
      </p><p>
        ホットバックアッププロセスは 2 つのステージから構成されます。データファイルの初期コピーは <span class="bold"><strong>raw バックアップ</strong></span>を生成します。<span class="bold"><strong>適用</strong></span>ステップにより、バックアップの実行中に行われたデータベースへの変更が組み込まれます。変更の適用により、<span class="bold"><strong>準備された</strong></span>バックアップが生成されます。これらのファイルは、必要な場合はいつでもリストアできる状態です。
      </p><p><a class="glossseealso" href="glossary.html#glos_apply">適用</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_prepared_backup">準備されたバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_raw_backup">raw バックアップ</a>も参照</p></dd><dt><a name="glos_bottleneck"></a><span class="glossterm">ボトルネック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984920656"></a>
        システム内で、全体的なスループットを制限する影響を持つ、サイズまたは容量に制約がある部分。たとえば、メモリー領域が必要な容量に満たないことがありますが、この場合、必要な単一リソースにアクセスするだけで、複数の CPU コアが同時に実行できなくなったり、ディスク I/O が完了するまで待機することで、CPU がフル稼働できなくなったりする可能性があります。ボトルネックを取り除くと、<span class="bold"><strong>並列性</strong></span>が改善する傾向があります。たとえば、複数の InnoDB <span class="bold"><strong>バッファープール</strong></span>インスタンスを持つことができれば、複数のセッションが同時にこのバッファープールに対して読み取り/書き込みするときの競合が軽減します。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_concurrency">並列性</a>も参照</p></dd><dt><a name="glos_point_in_time_recovery"></a><span class="glossterm">ポイントインタイムリカバリ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984945456"></a>
        特定日時のデータベースの状態を再作成するために<span class="bold"><strong>バックアップ</strong></span>をリストアするプロセス。一般に <span class="bold"><strong>PITR</strong></span> と略記されます。指定した時間がバックアップの時点に正確に対応する可能性は低いので、この方法は通常、<span class="bold"><strong>物理バックアップ</strong></span>および<span class="bold"><strong>論理バックアップ</strong></span>と組み合わせる必要があります。たとえば、<span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品では、指定した特定の時点より前に取得した最後のバックアップをリストアしてから、そのバックアップ時点から PITR 時点までの<span class="bold"><strong>バイナリログ</strong></span>から変更を再現します。
      </p><p><a class="glossseealso" href="glossary.html#glos_backup">バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_logical_backup">論理バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_physical_backup">物理バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_pitr">PITR</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">マ</h3><dl><dt><a name="glos_master_server"></a><span class="glossterm">マスターサーバー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984906768"></a>
        よく「マスター」と短縮されます。<span class="bold"><strong>レプリケーション</strong></span>シナリオでのデータベースサーバーマシンで、データの初期挿入、更新、および削除リクエストを処理します。これらの変更は、<span class="bold"><strong>スレーブサーバー</strong></span>と呼ばれるほかのサーバーに伝播されて、再現されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_replication">レプリケーション</a>, <a class="glossseealso" href="glossary.html#glos_slave_server">スレーブサーバー</a>も参照</p></dd><dt><a name="glos_master_thread"></a><span class="glossterm">マスタースレッド</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984901616"></a>
        バックグラウンドでさまざまなタスクを実行する InnoDB <span class="bold"><strong>スレッド</strong></span>。これらのタスクのほとんどは、<span class="bold"><strong>挿入バッファー</strong></span>からの変更を適切なセカンダリインデックスに書き込むなど、I/O 関連です。
      </p><p>
        <span class="bold"><strong>並列性</strong></span>を改善するために、アクションがマスタースレッドから個別のバックグラウンドスレッドに移される場合があります。たとえば、MySQL 5.6 以降では、<span class="bold"><strong>ダーティーページ</strong></span>は、マスタースレッドではなく<span class="bold"><strong>ページクリーナー</strong></span>スレッドで、<span class="bold"><strong>バッファープール</strong></span>から<span class="bold"><strong>フラッシュ</strong></span>されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_dirty_page">ダーティーページ</a>, <a class="glossseealso" href="glossary.html#glos_flush">フラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_insert_buffer">挿入バッファー</a>, <a class="glossseealso" href="glossary.html#glos_page_cleaner">ページクリーナー</a>, <a class="glossseealso" href="glossary.html#glos_thread">スレッド</a>も参照</p></dd><dt><a name="glos_multi_core"></a><span class="glossterm">マルチコア</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984890256"></a>
        MySQL Server などのマルチスレッドプログラムを活用できるタイプのプロセッサ。
      </p></dd><dt><a name="glos_multiversion_concurrency_control"></a><span class="glossterm">マルチバージョン並列性制御</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_mvcc">MVCC</a>も参照</p></dd><dt><a name="glos_merge"></a><span class="glossterm">マージ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984914432"></a>
        ページが<span class="bold"><strong>バッファープール</strong></span>に読み込まれたときや、<span class="bold"><strong>変更バッファー</strong></span>に記録された適用可能な変更がバッファープール内のページに組み込まれたときなどに、メモリーにキャッシュされたデータに変更を適用すること。更新されたデータは最終的に、<span class="bold"><strong>フラッシュ</strong></span>メカニズムによって<span class="bold"><strong>テーブルスペース</strong></span>に書き込まれます。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_change_buffer">変更バッファー</a>, <a class="glossseealso" href="glossary.html#glos_flush">フラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_tablespace">テーブルスペース</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ミ</h3><dl><dt><a name="glos_midpoint_insertion_strategy"></a><span class="glossterm">ミッドポイント挿入戦略</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984885968"></a>
        InnoDB <span class="bold"><strong>バッファープール</strong></span>リストの「最新の」末尾ではなく、中間のどこかに<span class="bold"><strong>ページ</strong></span>を最初に読み込ませる方法。このポイントの正確な位置は、<code class="literal">innodb_old_blocks_pct</code> オプションの設定に基づいて変わります。その意図は、<span class="bold"><strong>フルテーブルスキャン</strong></span>中などに一度だけ読み取られるブロックが、厳密な <span class="bold"><strong>LRU</strong></span> アルゴリズムを使用した場合よりも早くバッファープールからエージアウトできるということです。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_full_table_scan">テーブルの完全スキャン</a>, <a class="glossseealso" href="glossary.html#glos_lru">LRU</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>も参照</p></dd><dt><a name="glos_mini_transaction"></a><span class="glossterm">ミニトランザクション</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984877024"></a>
        <span class="bold"><strong>DML</strong></span> 操作中に内部データ構造に<span class="bold"><strong>物理</strong></span>レベルで変更を行うときの、InnoDB 処理の内部フェーズ。ミニトランザクション (mtr) には<span class="bold"><strong>ロールバック</strong></span>の概念はありません。単一<span class="bold"><strong>トランザクション</strong></span>内で複数のミニトランザクションを発生できます。ミニトランザクションは、<span class="bold"><strong>クラッシュリカバリ</strong></span>中に使用される <span class="bold"><strong>Redo ログ</strong></span>に情報を書き込みます。ミニトランザクションは、たとえばバックグラウンドスレッドによる<span class="bold"><strong>パージ</strong></span>処理中など、通常のトランザクションのコンテキスト外でも発生できます。
      </p><p><a class="glossseealso" href="glossary.html#glos_commit">コミット</a>, <a class="glossseealso" href="glossary.html#glos_crash_recovery">クラッシュリカバリ</a>, <a class="glossseealso" href="glossary.html#glos_dml">DML</a>, <a class="glossseealso" href="glossary.html#glos_physical">物理</a>, <a class="glossseealso" href="glossary.html#glos_purge">パージ</a>, <a class="glossseealso" href="glossary.html#glos_redo_log">Redo ログ</a>, <a class="glossseealso" href="glossary.html#glos_rollback">ロールバック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">メ</h3><dl><dt><a name="glos_metadata_lock"></a><span class="glossterm">メタデータロック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984864496"></a>
        別の<span class="bold"><strong>トランザクション</strong></span>によって同時に使用されているテーブルでの <span class="bold"><strong>DDL</strong></span> 操作を防止するタイプの<span class="bold"><strong>ロック</strong></span>。詳細は、<a class="xref" href="optimization.html#metadata-locking" title="8.10.4 メタデータのロック">セクション8.10.4「メタデータのロック」</a>を参照してください。
      </p><p>
        <span class="bold"><strong>オンライン</strong></span>操作への拡張機能は (特に MySQL 5.6 以降)、メタデータロックの量を減らすことに注力しています。その目標は、ほかのトランザクションによってテーブルに照会や更新などが行われている間に、テーブル構造を変更しない DDL 操作 (<code class="literal">InnoDB</code> テーブルに対する <code class="literal">CREATE INDEX</code> や <code class="literal">DROP INDEX</code> など) を進行できるようにすることです。
      </p><p><a class="glossseealso" href="glossary.html#glos_ddl">DDL</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_online">オンライン</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_metrics_counter"></a><span class="glossterm">メトリックカウンタ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984852544"></a>
        MySQL 5.6 以降で、<span class="bold"><strong>information_schema</strong></span> の <code class="literal">innodb_metrics</code> テーブルによって実装された機能。低レベル InnoDB 操作に関する<span class="bold"><strong>カウント</strong></span>および合計を照会し、その結果を <span class="bold"><strong>performance_schema</strong></span> からのデータと組み合わせてパフォーマンスチューニングに使用できます。
      </p><p><a class="glossseealso" href="glossary.html#glos_counter">カウンタ</a>, <a class="glossseealso" href="glossary.html#glos_information_schema">INFORMATION_SCHEMA</a>, <a class="glossseealso" href="glossary.html#glos_performance_schema">パフォーマンススキーマ</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ユ</h3><dl><dt><a name="glos_row"></a><span class="glossterm">行</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984844608"></a>
        <span class="bold"><strong>カラム</strong></span>セットによって定義される論理データ構造。行セットが<span class="bold"><strong>テーブル</strong></span>を構成します。InnoDB <span class="bold"><strong>データファイル</strong></span>内で、各<span class="bold"><strong>ページ</strong></span>には 1 つまたは複数の行を含められます。
      </p><p>
        InnoDB は MySQL 構文との一貫性のために用語<span class="bold"><strong>行フォーマット</strong></span>を使用しますが、行フォーマットは各テーブルのプロパティーであり、そのテーブル内のすべての行に適用されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_column">カラム</a>, <a class="glossseealso" href="glossary.html#glos_data_files">データファイル</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>, <a class="glossseealso" href="glossary.html#glos_row_format">行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>も参照</p></dd><dt><a name="glos_row_format"></a><span class="glossterm">行フォーマット</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984835328"></a>
        InnoDB <span class="bold"><strong>テーブル</strong></span>からの<span class="bold"><strong>行</strong></span>のディスクストレージフォーマット。InnoDB に圧縮などの新しい機能が用意されるのに伴い、ストレージの効率性とパフォーマンスの向上をサポートするために新しい行フォーマットが導入されます。
      </p><p>
        テーブルごとに独自の行フォーマットがあり、<code class="literal">ROW_FORMAT</code> オプションを通じて指定されます。各 InnoDB テーブルの行フォーマットを確認するには、コマンド <code class="literal">SHOW TABLE STATUS</code> を発行します。システムテーブルスペース内のすべてのテーブルが同じ行フォーマットを共有するので、ほかの行フォーマットを活用するには通常、各テーブルは個別のテーブルスペースに格納されるように <code class="literal">innodb_file_per_table</code> オプションを設定する必要があります。
      </p><p><a class="glossseealso" href="glossary.html#glos_compact_row_format">コンパクト行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_compressed_row_format">圧縮行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_dynamic_row_format">動的行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_fixed_row_format">固定行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_redundant_row_format">冗長行フォーマット</a>, <a class="glossseealso" href="glossary.html#glos_row">行</a>, <a class="glossseealso" href="glossary.html#glos_table">テーブル</a>も参照</p></dd><dt><a name="glos_row_level_locking"></a><span class="glossterm">行レベルロック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984823664"></a>
        <span class="bold"><strong>InnoDB</strong></span> テーブルに使用される<span class="bold"><strong>ロック</strong></span>メカニズム。<span class="bold"><strong>テーブルロック</strong></span>ではなく<span class="bold"><strong>行ロック</strong></span>に依存します。複数の<span class="bold"><strong>トランザクション</strong></span>が同時に同じテーブルを変更できます。2 つのトランザクションが同じ行を変更しようとした場合にのみ、トランザクションの一方は他方が終わる (およびその行ロックを解放する) まで待機します。
      </p><p><a class="glossseealso" href="glossary.html#glos_innodb">InnoDB</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_row_lock">行ロック</a>, <a class="glossseealso" href="glossary.html#glos_table_lock">テーブルロック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ヨ</h3><dl><dt><a name="glos_read_view"></a><span class="glossterm">読み取りビュー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984805600"></a>
        InnoDB の <span class="bold"><strong>MVCC</strong></span> メカニズムで使用される内部スナップショット。ある種の<span class="bold"><strong>トランザクション</strong></span>は、その<span class="bold"><strong>分離レベル</strong></span> に応じて、トランザクション (または、場合によってはステートメント) が開始した時点のデータ値を見ます。読み取りビューを使用する分離レベルは、<span class="bold"><strong>REPEATABLE READ</strong></span>、<span class="bold"><strong>READ COMMITTED</strong></span>、および <span class="bold"><strong>READ UNCOMMITTED</strong></span> です。
      </p><p><a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_mvcc">MVCC</a>, <a class="glossseealso" href="glossary.html#glos_read_committed">READ COMMITTED</a>, <a class="glossseealso" href="glossary.html#glos_read_uncommitted">READ UNCOMMITTED</a>, <a class="glossseealso" href="glossary.html#glos_repeatable_read">REPEATABLE READ</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_read_only_transaction"></a><span class="glossterm">読み取り専用トランザクション</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984814176"></a>
        トランザクションごとの<span class="bold"><strong>読み取りビュー</strong></span>を作成することに関係する管理の一部を省略することによって、<code class="literal">InnoDB</code> テーブルに最適化できるタイプのトランザクション。<span class="bold"><strong>非ロック読み取り</strong></span>クエリーだけを実行できます。構文 <code class="literal">START TRANSACTION READ ONLY</code> で明示的に開始したり、特定の条件下で自動的に開始したりできます。詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-performance-ro-txn" title="14.13.14 InnoDB の読み取り専用トランザクションの最適化">セクション14.13.14「InnoDB の読み取り専用トランザクションの最適化」</a>を参照してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_non_locking_read">非ロック読み取り</a>, <a class="glossseealso" href="glossary.html#glos_read_view">読み取りビュー</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ラ</h3><dl><dt><a name="glos_latch"></a><span class="glossterm">ラッチ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984794768"></a>
        独自の内部メモリー構造に<span class="bold"><strong>ロック</strong></span>を実装するために InnoDB で使用される軽量構造で、通常はミリ秒またはマイクロ秒単位で計測される短い期間保持されます。<span class="bold"><strong>相互排他ロック</strong></span> (排他アクセスの場合) と<span class="bold"><strong>読み書きロック</strong></span> (共有アクセスの場合) の両方を含む一般用語。ある種のラッチは、<span class="bold"><strong>データディクショナリ</strong></span>相互排他ロックなど、InnoDB パフォーマンスチューニングにとって重要です。ラッチの使用と競合に関する統計は、<span class="bold"><strong>パフォーマンススキーマ</strong></span>インタフェースから入手できます。
      </p><p><a class="glossseealso" href="glossary.html#glos_data_dictionary">データディクショナリ</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_mutex">相互排他ロック</a>, <a class="glossseealso" href="glossary.html#glos_performance_schema">パフォーマンススキーマ</a>, <a class="glossseealso" href="glossary.html#glos_rw_lock">rw ロック (読み書きロック)</a>も参照</p></dd><dt><a name="glos_random_dive"></a><span class="glossterm">ランダムダイブ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984785168"></a>
        カラム内のさまざまな値の数 (カラムのカーディナリティー) をすばやく見積もる方法。InnoDB は、インデックスからランダムにページをサンプリングし、そのデータを使用してさまざまな値の数を見積もります。この操作は、各テーブルが最初に開かれるときに発生します。
      </p><p>
        従来は、サンプリングされるページ数は 8 に固定されていました。現在は、<code class="literal">innodb_stats_sample_pages</code> パラメータの設定によって決定されます。
      </p><p>
        ランダムページが選択される方法は、innodb_use_legacy_cardinality_algorithm パラメータの設定に応じて変わります。デフォルト設定 (OFF) のランダム性は古いリリースのものより向上しています。
      </p><p><a class="glossseealso" href="glossary.html#glos_cardinality">カーディナリティー</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">リ</h3><dl><dt><a name="glos_list"></a><span class="glossterm">リスト</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984778544"></a>
        InnoDB <span class="bold"><strong>バッファープール</strong></span>は、メモリー<span class="bold"><strong>ページ</strong></span>のリストとして表されます。リストは、新しいページがアクセスされてバッファープールに読み込まれたとき、バッファープール内のページが再度アクセスされてより新しいと見なされたとき、長時間アクセスされていないページがバッファープールから<span class="bold"><strong>削除</strong></span>されたときに、並べ替えられます。バッファープールは、実際には<span class="bold"><strong>サブリスト</strong></span>に分割され、その置換ポリシーはよく知られた <span class="bold"><strong>LRU</strong></span> 手法のバリエーションです。
      </p><p><a class="glossseealso" href="glossary.html#glos_buffer_pool">バッファープール</a>, <a class="glossseealso" href="glossary.html#glos_eviction">エビクション</a>, <a class="glossseealso" href="glossary.html#glos_lru">LRU</a>, <a class="glossseealso" href="glossary.html#glos_sublist">サブリスト</a>も参照</p></dd><dt><a name="glos_restore"></a><span class="glossterm">リストア</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984770016"></a>
        <span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品からのバックアップファイルセットを MySQL で使用できるように準備するプロセス。この操作は、破損したデータベースを修復して、以前のどこか特定の時点に戻したり、(<span class="bold"><strong>レプリケーション</strong></span>コンテキストで) 新しい<span class="bold"><strong>スレーブデータベース</strong></span>を設定したりするために実行できます。<span class="bold"><strong>MySQL Enterprise Backup</strong></span> 製品では、この操作は <code class="literal">mysqlbackup</code> コマンドの <code class="literal">copy-back</code> オプションで実行されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_hot_backup">ホットバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>, <a class="glossseealso" href="glossary.html#glos_mysqlbackup_command">mysqlbackup コマンド</a>, <a class="glossseealso" href="glossary.html#glos_prepared_backup">準備されたバックアップ</a>, <a class="glossseealso" href="glossary.html#glos_replication">レプリケーション</a>も参照</p></dd><dt><a name="glos_relational"></a><span class="glossterm">リレーショナル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984760336"></a>
        現代のデータベースシステムの重要な側面。データベースサーバーは、1 対 1、1 対多、多対 1、一意性などの関係をエンコードし適用します。たとえば、住所データベースでは、ある人にゼロ個、1 個、または複数個の電話番号が関連付けられていたり、単一電話番号が家族の複数のメンバーに関連付けられていたりします。金融データベースでは、1 人の人に正確に 1 つの納税者 ID が割り当てられる必要があり、納税者 ID は 1 人の人にのみ関連付けることができます。
      </p><p>
        データベースサーバーは、これらの関係を使用して、不良データが挿入されるのを防ぎ、情報をルックアップする効率的な方法を見つけることができます。たとえば、値が一意であると宣言されている場合、サーバーは、最初の一致が見つかるとすぐに検索を停止し、同じ値の 2 番目のコピーを挿入しようとする試みを拒否できます。
      </p><p>
        データベースレベルではこれらの関係は、テーブル内の<span class="bold"><strong>カラム</strong></span>、一意および <code class="literal">NOT NULL</code> <span class="bold"><strong>制約</strong></span>、<span class="bold"><strong>外部キー</strong></span>、さまざまな種類の結合操作などの SQL 機能を通じて表されます。複雑な関係には通常、複数のテーブル間で分割されたデータが使用されます。多くの場合、データは<span class="bold"><strong>正規化</strong></span>されるので、1 対多の関係での重複値は一度だけ格納されます。
      </p><p>
        数学的なコンテキストでは、データベース内の関係は集合論から派生されます。たとえば、<code class="literal">WHERE</code> 句の <code class="literal">OR</code> および <code class="literal">AND</code> 演算子は、論理和と論理積の概念を表します。
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_constraint">制約</a>, <a class="glossseealso" href="glossary.html#glos_foreign_key">外部キー</a>, <a class="glossseealso" href="glossary.html#glos_normalized">正規化</a>も参照</p></dd><dt><a name="glos_history_list"></a><span class="glossterm">履歴リスト</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984746352"></a>
        削除マークが付けられたレコードが <code class="literal">InnoDB</code> <span class="bold"><strong>パージ</strong></span>操作で処理されるようにスケジュールされている<span class="bold"><strong>トランザクション</strong></span>のリスト。<span class="bold"><strong>Undo ログ</strong></span>に記録されます。履歴リストの長さはコマンド <code class="literal">SHOW ENGINE INNODB STATUS</code> で報告されます。履歴リストが <code class="literal">innodb_max_purge_lag</code> 構成オプションの値よりも長くなった場合、パージ操作が削除済みレコードの<span class="bold"><strong>フラッシュ</strong></span>を完了できるように各 <span class="bold"><strong>DML</strong></span> 操作が少し遅くなります。
      </p><p>
        <span class="bold"><strong>パージラグ</strong></span>とも呼ばれます。
      </p><p><a class="glossseealso" href="glossary.html#glos_flush">フラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_purge">パージ</a>, <a class="glossseealso" href="glossary.html#glos_purge_lag">パージ遅延</a>, <a class="glossseealso" href="glossary.html#glos_rollback_segment">ロールバックセグメント</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>, <a class="glossseealso" href="glossary.html#glos_undo_log">Undo ログ</a>も参照</p></dd><dt><a name="glos_neighbor_page"></a><span class="glossterm">隣接ページ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984733184"></a>
        特定のページと同じ<span class="bold"><strong>エクステント</strong></span>内の<span class="bold"><strong>ページ</strong></span>。ページが<span class="bold"><strong>フラッシュ</strong></span>の対象として選択されると、<span class="bold"><strong>ダーティー</strong></span>である隣接ページがある場合は、通常はそれらも従来ハードディスクの I/O 最適化としてフラッシュされます。MySQL 5.6 以降では、この動作は構成変数 <code class="literal">innodb_flush_neighbors</code> で制御できます。小さなデータバッチをランダムな場所に書き込むため同じオーバーヘッドは発生しない SSD ドライブでは、この設定をオフにできます。
      </p><p><a class="glossseealso" href="glossary.html#glos_dirty_page">ダーティーページ</a>, <a class="glossseealso" href="glossary.html#glos_extent">エクステント</a>, <a class="glossseealso" href="glossary.html#glos_flush">フラッシュ</a>, <a class="glossseealso" href="glossary.html#glos_page">ページ</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">レ</h3><dl><dt><a name="glos_record_lock"></a><span class="glossterm">レコードロック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984723744"></a>
        インデックスレコードでの<a class="link" href="glossary.html#glos_lock" title="ロック">ロック</a>。たとえば、<code class="literal">SELECT c1 FOR UPDATE FROM t WHERE c1 = 10;</code> は、ほかのトランザクションの、<code class="literal">t.c1</code> の値が 10 である行が挿入、更新、削除されるのを回避します。<span class="bold"><strong>ギャップロック</strong></span>および<span class="bold"><strong>ネクストキーロック</strong></span>と対比してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_gap_lock">ギャップロック</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_next_key_lock">ネクストキーロック</a>も参照</p></dd><dt><a name="glos_replication"></a><span class="glossterm">レプリケーション</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984715776"></a>
        すべてのデータベースが同じデータを持つように、<span class="bold"><strong>マスターデータベース</strong></span>から 1 つまたは複数の<span class="bold"><strong>スレーブデータベース</strong></span>に変更を送信する作業。この方法は、スケーラビリティー向上のためのロードバランシング、ディザスタリカバリ、ソフトウェアアップグレードおよび構成変更のテストなど、幅広く使用されます。変更は、<span class="bold"><strong>行ベースレプリケーション</strong></span>および<span class="bold"><strong>ステートメントベースレプリケーション</strong></span>と呼ばれる方法によって、データベース間で送信できます。
      </p><p><a class="glossseealso" href="glossary.html#glos_row_based_replication">行ベースレプリケーション</a>, <a class="glossseealso" href="glossary.html#glos_statement_based_replication">ステートメントベースレプリケーション</a>も参照</p></dd><dt><a name="glos_concatenated_index"></a><span class="glossterm">連結されたインデックス</span></dt><dd><p><a class="glosssee" href="glossary.html#glos_composite_index">複合インデックス</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ロ</h3><dl><dt><a name="glos_log"></a><span class="glossterm">ログ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984694528"></a>
        InnoDB コンテキストでは、「ログ」または「ログファイル」は通常、<span class="bold"><strong>ib_logfile*</strong></span> ファイルによって表される <span class="bold"><strong>Redo ログ</strong></span>を示します。もう 1 つのログ領域 (物理的には<span class="bold"><strong>システムテーブルスペース</strong></span>の一部) は <span class="bold"><strong>Undo ログ</strong></span>です。
      </p><p>
        MySQL で重要なほかの種類のログには、<span class="bold"><strong>エラーログ</strong></span> (起動および実行時の問題を診断するため), <span class="bold"><strong>バイナリログ</strong></span> (レプリケーションを操作し、特定時点のリストアを実行するため)、<span class="bold"><strong>一般クエリーログ</strong></span> (アプリケーションの問題を診断するため)、および<span class="bold"><strong>スロークエリーログ</strong></span> (パフォーマンスの問題を診断するため) があります。
      </p><p><a class="glossseealso" href="glossary.html#glos_binary_log">バイナリログ</a>, <a class="glossseealso" href="glossary.html#glos_error_log">エラーログ</a>, <a class="glossseealso" href="glossary.html#glos_general_query_log">一般クエリーログ</a>, <a class="glossseealso" href="glossary.html#glos_ib_logfile">ib_logfile</a>, <a class="glossseealso" href="glossary.html#glos_redo_log">Redo ログ</a>, <a class="glossseealso" href="glossary.html#glos_slow_query_log">スロークエリーログ</a>, <a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_undo_log">Undo ログ</a>も参照</p></dd><dt><a name="glos_log_group"></a><span class="glossterm">ロググループ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984680896"></a>
        <span class="bold"><strong>Redo ログ</strong></span>を構成するファイルのセット。通常、<code class="literal">ib_logfile0</code> および <code class="literal">ib_logfile1</code> の名前が付けられています。(この理由のため、<span class="bold"><strong>ib_logfile</strong></span> と総称される場合があります。)
      </p><p><a class="glossseealso" href="glossary.html#glos_ib_logfile">ib_logfile</a>, <a class="glossseealso" href="glossary.html#glos_redo_log">Redo ログ</a>も参照</p></dd><dt><a name="glos_log_buffer"></a><span class="glossterm">ログバッファー</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984674448"></a>
        <span class="bold"><strong>Redo ログ</strong></span>を構成する<span class="bold"><strong>ログファイル</strong></span>に書き込まれるデータを保持するメモリー領域。これは、<code class="literal">innodb_log_buffer_size</code> 構成オプションで制御されます。
      </p><p><a class="glossseealso" href="glossary.html#glos_log_file">ログファイル</a>, <a class="glossseealso" href="glossary.html#glos_redo_log">Redo ログ</a>も参照</p></dd><dt><a name="glos_log_file"></a><span class="glossterm">ログファイル</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984668576"></a>
        <span class="bold"><strong>Redo ログ</strong></span>を構成する <code class="literal">ib_logfile<em class="replaceable"><code>N</code></em></code> ファイルの 1 つ。データは、<span class="bold"><strong>ログバッファー</strong></span>メモリー領域からこれらのファイルに書き込まれます。
      </p><p><a class="glossseealso" href="glossary.html#glos_ib_logfile">ib_logfile</a>, <a class="glossseealso" href="glossary.html#glos_log_buffer">ログバッファー</a>, <a class="glossseealso" href="glossary.html#glos_redo_log">Redo ログ</a>も参照</p></dd><dt><a name="glos_lock"></a><span class="glossterm">ロック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984662240"></a>
        <span class="bold"><strong>ロック</strong></span>戦略の一環として、テーブル、行、内部データ構造などのリソースへのアクセスを制御するオブジェクトの高レベル概念。パフォーマンスを集中的にチューニングする場合は、<span class="bold"><strong>相互排他ロック</strong></span>や<span class="bold"><strong>ラッチ</strong></span>など、ロックを実装する実際の構造を徹底的に調べることができます。
      </p><p><a class="glossseealso" href="glossary.html#glos_latch">ラッチ</a>, <a class="glossseealso" href="glossary.html#glos_lock_mode">lock mode</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_mutex">相互排他ロック</a>も参照</p></dd><dt><a name="glos_locking"></a><span class="glossterm">ロック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984655408"></a>
        ほかのトランザクションによって照会または変更されているデータを<span class="bold"><strong>トランザクション</strong></span>が見たり変更したりすることを防止するシステム。ロック戦略は、データベース操作の信頼性および一貫性 (<span class="bold"><strong>ACID</strong></span> 概念の原則) と、良質な<span class="bold"><strong>並列性</strong></span>に必要なパフォーマンスとのバランスを取る必要があります。ロック戦略を調整するときは、多くの場合、<span class="bold"><strong>分離レベル</strong></span>を選択し、すべてのデータベース操作がその分離レベルについて安全で信頼性を持つことを保証する必要があります。
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_concurrency">並列性</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_latch">ラッチ</a>, <a class="glossseealso" href="glossary.html#glos_lock">ロック</a>, <a class="glossseealso" href="glossary.html#glos_mutex">相互排他ロック</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_lock_escalation"></a><span class="glossterm">ロックエスカレーション</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984645840"></a>
        一部のデータベースシステムで使用される、多くの行ロックを単一テーブルロックに変換する操作。メモリー領域を節約しながら、テーブルへの並列アクセスを減らします。InnoDB は、行ロックに領域効率のよい表現を使用するので、ロックエスカレーションは必要ありません。
      </p><p><a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_row_lock">行ロック</a>, <a class="glossseealso" href="glossary.html#glos_table_lock">テーブルロック</a>も参照</p></dd><dt><a name="glos_locking_read"></a><span class="glossterm">ロック読み取り</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984641344"></a>
        <code class="literal">InnoDB</code> テーブルでの<span class="bold"><strong>ロック</strong></span>操作も実行する <code class="literal">SELECT</code> ステートメント。<code class="literal">SELECT ... FOR UPDATE</code> または <code class="literal">SELECT ... LOCK IN SHARE MODE</code> のどちらか。トランザクションの<span class="bold"><strong>分離レベル</strong></span>に応じて、<span class="bold"><strong>デッドロック</strong></span>を発生させる可能性があります。<span class="bold"><strong>非ロック読み取り</strong></span>の反対。<span class="bold"><strong>読み取り専用トランザクション</strong></span>内のグローバルテーブルには許可されません。
      </p><p><a class="glossseealso" href="glossary.html#glos_deadlock">デッドロック</a>, <a class="glossseealso" href="glossary.html#glos_isolation_level">分離レベル</a>, <a class="glossseealso" href="glossary.html#glos_locking">ロック</a>, <a class="glossseealso" href="glossary.html#glos_non_locking_read">非ロック読み取り</a>, <a class="glossseealso" href="glossary.html#glos_read_only_transaction">読み取り専用トランザクション</a>も参照</p></dd><dt><a name="glos_rollback"></a><span class="glossterm">ロールバック</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984707024"></a>
        <span class="bold"><strong>トランザクション</strong></span>が行なった変更を元に戻してトランザクションを終了する <span class="bold"><strong>SQL</strong></span> ステートメント。これは、トランザクションで行われた変更を永続的にする<span class="bold"><strong>コミット</strong></span>の反対です。
      </p><p>
        MySQL はデフォルトで、各 SQL ステートメントに続いてコミットを自動的に発行する<span class="bold"><strong>自動コミット</strong></span>設定を使用します。ロールバック方法を使用する前に、この設定を変更する必要があります。
      </p><p><a class="glossseealso" href="glossary.html#glos_acid">ACID</a>, <a class="glossseealso" href="glossary.html#glos_commit">コミット</a>, <a class="glossseealso" href="glossary.html#glos_transaction">トランザクション</a>も参照</p></dd><dt><a name="glos_rollback_segment"></a><span class="glossterm">ロールバックセグメント</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984699296"></a>
        <span class="bold"><strong>Undo ログ</strong></span>を含むストレージ領域。<span class="bold"><strong>システムテーブルスペース</strong></span>の一部です。
      </p><p><a class="glossseealso" href="glossary.html#glos_system_tablespace">システムテーブルスペース</a>, <a class="glossseealso" href="glossary.html#glos_undo_log">Undo ログ</a>も参照</p></dd><dt><a name="glos_logical"></a><span class="glossterm">論理</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984628544"></a>
        テーブル、クエリー、インデックス、その他の SQL 概念など、高レベル抽象側面を含むタイプの操作。論理側面は通常、データベース管理およびアプリケーション開発を便利で使用可能なものにするために重要です。<span class="bold"><strong>物理</strong></span>と対比してください。
      </p><p><a class="glossseealso" href="glossary.html#glos_logical_backup">論理バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_physical">物理</a>も参照</p></dd><dt><a name="glos_logical_backup"></a><span class="glossterm">論理バックアップ</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984623856"></a>
        実際のデータファイルをコピーせずにテーブル構造とデータを再生成する<span class="bold"><strong>バックアップ</strong></span>。たとえば、<span class="bold"><strong><code class="literal">mysqldump</code></strong></span> コマンドは論理バックアップを生成します。その出力に、データを再作成できる <code class="literal">CREATE TABLE</code> や <code class="literal">INSERT</code> などのステートメントが含まれるためです。<span class="bold"><strong>物理バックアップ</strong></span>と対比してください。論理バックアップは柔軟性 (たとえば、リストア前に、テーブル定義を編集したりステートメントを挿入したりできます) を提供しますが、物理バックアップよりも<span class="bold"><strong>リストア</strong></span>にかなり長い時間がかかる可能性があります。
      </p><p><a class="glossseealso" href="glossary.html#glos_backup">バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_mysqldump">mysqldump</a>, <a class="glossseealso" href="glossary.html#glos_physical_backup">物理バックアップ</a>, <a class="glossseealso" href="glossary.html#glos_restore">リストア</a>も参照</p></dd></dl></div><div class="glossdiv"><h3 class="title">ワ</h3><dl><dt><a name="glos_workload"></a><span class="glossterm">ワークロード</span></dt><dd class="glossdef"><p>
<a class="indexterm" name="idm139978984613424"></a>
        標準またはピーク使用時にデータベースアプリケーションによって実行される、<span class="bold"><strong>SQL</strong></span> およびほかのデータベース操作の組み合わせおよび量。<span class="bold"><strong>ボトルネック</strong></span>を識別するパフォーマンステスト中や容量計画中に、データベースに特定のワークロードを課すことができます。
      </p><p><a class="glossseealso" href="glossary.html#glos_bottleneck">ボトルネック</a>, <a class="glossseealso" href="glossary.html#glos_cpu_bound">CPU バウンド</a>, <a class="glossseealso" href="glossary.html#glos_disk_bound">ディスクバウンド</a>, <a class="glossseealso" href="glossary.html#glos_sql">SQL</a>も参照</p></dd></dl></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="restrictions.html">前</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="licenses-third-party.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">付録 D 制約と制限 </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 付録 E サードパーティーコンポーネントライセンス</td></tr></table></div><div class="copyright-footer"></div></body></html>
