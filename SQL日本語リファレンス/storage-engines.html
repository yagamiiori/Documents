<html lang="ja"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>第 15 章 代替ストレージエンジン</title><link rel="stylesheet" type="text/css" href="mvl.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="MySQL 5.6 リファレンスマニュアル"><link rel="up" href="index.html" title="MySQL 5.6 リファレンスマニュアル"><link rel="prev" href="innodb-storage-engine.html" title="第 14 章 InnoDB ストレージエンジン"><link rel="next" href="ha-overview.html" title="第 16 章 高可用性と拡張性">
<script language="javascript" type="text/javascript">
  function addOnload(theFunc)
  {
    var previous = window.onload;
    if (typeof window.onload != 'function')
    {
      window.onload = theFunc;
    }
    else
    {
      window.onload = function()
      {
        previous();
        theFunc();
      }
    }
  }

  addOnload(function()
  {
    var base = new Date(1442918127*1000);
    var now = new Date();
    var diff = ((now-base)/1000)/(24*3600);

    if (diff > 90) {
      var nodes = document.getElementsByClassName('titlepage');
      nodes[0].innerHTML = '<p style="border: 5px #ff0000 solid; padding: 5px; margin 5px">' +
        'This copy of the manual is more than 90 days old. We encourage you to download a ' +
        'new version from <a href="http://dev.mysql.com">dev.mysql.com/doc</a>.</p>' + nodes[0].innerHTML;
    }
  });
</script>
<noscript></noscript>
</head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第 15 章 代替ストレージエンジン</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="innodb-storage-engine.html">前</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ha-overview.html">次へ</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="storage-engines"></a>第 15 章 代替ストレージエンジン</h1></div></div></div><div class="toc"><p><b>目次</b></p><dl class="toc"><dt><span class="section"><a href="storage-engines.html#storage-engine-setting">15.1 ストレージエンジンの設定</a></span></dt><dt><span class="section"><a href="storage-engines.html#myisam-storage-engine">15.2 MyISAM ストレージエンジン</a></span></dt><dd><dl><dt><span class="section"><a href="storage-engines.html#myisam-start">15.2.1 MyISAM 起動オプション</a></span></dt><dt><span class="section"><a href="storage-engines.html#key-space">15.2.2 キーに必要な容量</a></span></dt><dt><span class="section"><a href="storage-engines.html#myisam-table-formats">15.2.3 MyISAM テーブルのストレージフォーマット</a></span></dt><dt><span class="section"><a href="storage-engines.html#myisam-table-problems">15.2.4 MyISAM テーブルの問題点</a></span></dt></dl></dd><dt><span class="section"><a href="storage-engines.html#memory-storage-engine">15.3 MEMORY ストレージエンジン</a></span></dt><dt><span class="section"><a href="storage-engines.html#csv-storage-engine">15.4 CSV ストレージエンジン</a></span></dt><dd><dl><dt><span class="section"><a href="storage-engines.html#se-csv-repair">15.4.1 CSV テーブルの修復と確認</a></span></dt><dt><span class="section"><a href="storage-engines.html#se-csv-limitations">15.4.2 CSV の制限</a></span></dt></dl></dd><dt><span class="section"><a href="storage-engines.html#archive-storage-engine">15.5 ARCHIVE ストレージエンジン</a></span></dt><dt><span class="section"><a href="storage-engines.html#blackhole-storage-engine">15.6 BLACKHOLE ストレージエンジン</a></span></dt><dt><span class="section"><a href="storage-engines.html#merge-storage-engine">15.7 MERGE ストレージエンジン</a></span></dt><dd><dl><dt><span class="section"><a href="storage-engines.html#merge-table-advantages">15.7.1 MERGE テーブルの長所と短所</a></span></dt><dt><span class="section"><a href="storage-engines.html#merge-table-problems">15.7.2 MERGE テーブルの問題点</a></span></dt></dl></dd><dt><span class="section"><a href="storage-engines.html#federated-storage-engine">15.8 FEDERATED ストレージエンジン</a></span></dt><dd><dl><dt><span class="section"><a href="storage-engines.html#federated-description">15.8.1 FEDERATED ストレージエンジンの概要</a></span></dt><dt><span class="section"><a href="storage-engines.html#federated-create">15.8.2 FEDERATED テーブルの作成方法</a></span></dt><dt><span class="section"><a href="storage-engines.html#federated-usagenotes">15.8.3 FEDERATED ストレージエンジンの注記とヒント</a></span></dt><dt><span class="section"><a href="storage-engines.html#federated-storage-engine-resources">15.8.4 FEDERATED ストレージエンジンのリソース</a></span></dt></dl></dd><dt><span class="section"><a href="storage-engines.html#example-storage-engine">15.9 EXAMPLE ストレージエンジン</a></span></dt><dt><span class="section"><a href="storage-engines.html#storage-engines-other">15.10 ほかのストレージエンジン</a></span></dt><dt><span class="section"><a href="storage-engines.html#pluggable-storage-overview">15.11 MySQL ストレージエンジンアーキテクチャーの概要</a></span></dt><dd><dl><dt><span class="section"><a href="storage-engines.html#pluggable-storage">15.11.1 プラガブルストレージエンジンのアーキテクチャー</a></span></dt><dt><span class="section"><a href="storage-engines.html#pluggable-storage-common-layer">15.11.2 共通データベースサーバーレイヤー</a></span></dt></dl></dd></dl></div><a class="indexterm" name="idm139979060014352"></a><a class="indexterm" name="idm139979060012240"></a><a class="indexterm" name="idm139979060010176"></a><a class="indexterm" name="idm139979060008144"></a><a class="indexterm" name="idm139979060006736"></a><a class="indexterm" name="idm139979060005328"></a><a class="indexterm" name="idm139979060003920"></a><a class="indexterm" name="idm139979060002512"></a><a class="indexterm" name="idm139979060001104"></a><a class="indexterm" name="idm139979059999696"></a><a class="indexterm" name="idm139979059998288"></a><a class="indexterm" name="idm139979059996880"></a><a class="indexterm" name="idm139979059995472"></a><a class="indexterm" name="idm139979059994048"></a><p>
    ストレージエンジンは、さまざまなテーブル型に対する SQL 操作を処理する MySQL コンポーネントです。<code class="literal">InnoDB</code> はデフォルトでもっとも汎用のストレージエンジンであり、Oracle は、特別なユースケースを除くテーブルについては、このエンジンの使用を推奨します。(デフォルトでは、MySQL 5.6 の <code class="literal">CREATE TABLE</code> ステートメントは <code class="literal">InnoDB</code> テーブルを作成します。)
  </p><p>
    MySQL Server は、ストレージエンジンが、動作中の MySQL サーバーにロードされたり、MySQL サーバーからアンロードされたりできる、プラガブルストレージエンジンアーキテクチャーを採用しています。
  </p><p>
    ご使用のサーバーがサポートするストレージエンジンを調べるには、<code class="literal">SHOW ENGINES</code> ステートメントを使用します。<code class="literal">サポート</code>カラムの値は、エンジンを使用できるかどうかを示します。<code class="literal">YES</code>、<code class="literal">NO</code>、または <code class="literal">DEFAULT</code> の値は、エンジンが「使用可能」、「使用可能でない」、または「デフォルトのストレージエンジンとして使用可能であり、現在設定されている」を表しています。
  </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW ENGINES\G</code></strong>
*************************** 1. row ***************************
      Engine: PERFORMANCE_SCHEMA
     Support: YES
     Comment: Performance Schema
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 2. row ***************************
      Engine: InnoDB
     Support: DEFAULT
     Comment: Supports transactions, row-level locking, and foreign keys
Transactions: YES
          XA: YES
  Savepoints: YES
*************************** 3. row ***************************
      Engine: MRG_MYISAM
     Support: YES
     Comment: Collection of identical MyISAM tables
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 4. row ***************************
      Engine: BLACKHOLE
     Support: YES
     Comment: /dev/null storage engine (anything you write to it disappears)
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 5. row ***************************
      Engine: MyISAM
     Support: YES
     Comment: MyISAM storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
...
  </pre><p>
    この章では、特別な目的の MySQL ストレージエンジンのユースケースについて説明します。<a class="xref" href="innodb-storage-engine.html" title="第 14 章 InnoDB ストレージエンジン">第14章「<i>InnoDB ストレージエンジン</i>」</a>および <a class="xref" href="mysql-cluster.html" title="第 18 章 MySQL Cluster NDB 7.3 および MySQL Cluster NDB 7.4">第18章「<i>MySQL Cluster NDB 7.3 および MySQL Cluster NDB 7.4</i>」</a>で説明するデフォルトの <code class="literal">InnoDB</code> ストレージエンジンまたは <code class="literal">NDB</code> ストレージエンジンについては説明しません。上級ユーザーのために、この章ではプラガブルストレージエンジンアーキテクチャーについても説明します (<a class="xref" href="storage-engines.html#pluggable-storage-overview" title="15.11 MySQL ストレージエンジンアーキテクチャーの概要">セクション15.11「MySQL ストレージエンジンアーキテクチャーの概要」</a>を参照してください)。
  </p><p>
    商用 MySQL Server バイナリで提供されるストレージエンジンのサポートについては、MySQL Web サイトの <a class="ulink" href="http://www.mysql.com/products/enterprise/server.html" target="_top"><em class="citetitle">MySQL Enterprise Server 5.6</em></a> を参照してください。使用可能なストレージエンジンは、使用中の Enterprise Server のエディションによって異なる場合があります。
  </p><p>
    MySQL ストレージエンジンに関するよくある質問の回答については、<a class="xref" href="faqs.html#faqs-storage-engines" title="A.2 MySQL 5.6 FAQ: ストレージエンジン">セクションA.2「MySQL 5.6 FAQ: ストレージエンジン」</a>を参照してください。
  </p><h2><a name="idm139979059971664"></a>MySQL 5.6 がサポートするストレージエンジン</h2><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <a class="link" href="innodb-storage-engine.html" title="第 14 章 InnoDB ストレージエンジン"><code class="literal">InnoDB</code></a>: MySQL 5.6 のデフォルトのストレージエンジン。<code class="literal">InnoDB</code> はトランザクションセーフな (ACID に準拠した) MySQL 用のストレージエンジンであり、ユーザーデータを保護するためのコミット、ロールバック、およびクラッシュリカバリ機能を備えています。<code class="literal">InnoDB</code> の行レベルロック (より粒度の粗いロックへのエスカレーションは行わない) と Oracle スタイルの一貫性非ロック読み取りにより、マルチユーザーの並列性とパフォーマンスが向上します。<code class="literal">InnoDB</code> では、主キーに基づいた一般的なクエリーの入出力を低減するため、クラスタ化されたインデックス内にユーザーデータが格納されます。<code class="literal">InnoDB</code> ではデータの整合性を維持できるように、<code class="literal">FOREIGN KEY</code> 参照整合性制約もサポートされています。<code class="literal">InnoDB</code> の詳細については、<a class="xref" href="innodb-storage-engine.html" title="第 14 章 InnoDB ストレージエンジン">第14章「<i>InnoDB ストレージエンジン</i>」</a>を参照してください。
      </p></li><li class="listitem"><p>
        <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2 MyISAM ストレージエンジン"><code class="literal">MyISAM</code></a>: これらのテーブルのフットプリントは小さくなります。<a class="link" href="glossary.html#glos_table_lock" title="テーブルロック">テーブルレベルのロック</a> では、読み取り/書き込みの作業負荷でのパフォーマンスが抑えられるため、Web およびデータウェアハウス構成の読み取り専用または読み取りが大半の作業負荷の場合に使用されるのが一般的です。
      </p></li><li class="listitem"><p>
        <a class="link" href="storage-engines.html#memory-storage-engine" title="15.3 MEMORY ストレージエンジン"><code class="literal">メモリー</code></a>: すべてのデータを RAM に格納します (重要でないデータの短時間での検索が必要な環境で高速にアクセスするため)。このエンジンは以前は <code class="literal">HEAP</code> エンジンとして知られていました。このユースケースは減少しています。バッファープールのメモリー領域を持つ <code class="literal">InnoDB</code> は、ほとんどのデータまたはすべてのデータをメモリーに保持する汎用的で永続的な方法を提供し、<code class="literal">NDBCLUSTER</code> は大規模な分散データセットでキー値の高速な検索ができます。
      </p></li><li class="listitem"><p>
        <a class="link" href="storage-engines.html#csv-storage-engine" title="15.4 CSV ストレージエンジン"><code class="literal">CSV</code></a>: このテーブルは、カンマ区切り値を持つ実際のテキストファイルです。CSV テーブルにより、CSV フォーマットでデータをインポートしたりダンプしたりして、同じフォーマットを読み込んだり書き込んだりするスクリプトおよびアプリケーションとデータを交換できます。CSV テーブルはインデックス化されないため、通常の操作時はデータを <code class="literal">InnoDB</code> テーブルに保持し、インポートまたはエクスポートの段階でのみ CSV テーブルを使用するのが一般的です。
      </p></li><li class="listitem"><p>
        <a class="link" href="storage-engines.html#archive-storage-engine" title="15.5 ARCHIVE ストレージエンジン"><code class="literal">アーカイブ</code></a>: これらのインデックス化されていないコンパクトなテーブルは、ほとんど参照されない大量の履歴情報、アーカイブされた情報、またはセキュリティー監査情報を格納したり、検索したりするためのテーブルです。
      </p></li><li class="listitem"><p>
        <a class="link" href="storage-engines.html#blackhole-storage-engine" title="15.6 BLACKHOLE ストレージエンジン"><code class="literal">Blackhole</code></a>: Blackhole ストレージエンジンはデータを受け付けますが、Unix <code class="literal">/dev/null</code> デバイスと同じように、格納しません。クエリーは常に空のセットを返します。これらのテーブルは、DML ステートメントはスレーブサーバーに送られますが、マスターサーバーはデータの独自のコピーを保持しないレプリケーション構成で使用できます。
      </p></li><li class="listitem"><p>
        <code class="literal">NDB</code> (<code class="literal">NDBCLUSTER</code> としても知られています) - クラスタ化されたこのデータベースエンジンは、稼働時間と可用性の程度ができるだけ高くなくてはいけないアプリケーションに特に適しています。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">NDB</code> ストレージエンジンは、標準の MySQL 5.6 リリースではサポートされていません。現在サポートされている MySQL Cluster リリースには、MySQL 5.1 がベースの MySQL Cluster NDB 7.1、MySQL 5.5 がベースの MySQL Cluster NDB 7.2、MySQL 5.6 がベースの MySQL Cluster NDB 7.3 が含まれています。MySQL Server がベースである間、これらのリリースには <code class="literal">NDB</code> のサポートも含まれます。MySQL 5.6 もベースにした現在開発中の MySQL Cluster NDB 7.4 が、Developer Milestone リリースでも使用できるようになりました。
        </p></div></li><li class="listitem"><p>
        <a class="link" href="storage-engines.html#merge-storage-engine" title="15.7 MERGE ストレージエンジン"><code class="literal">マージ</code></a>: MySQL DBA または開発者は、一連のまったく同じ <code class="literal">MyISAM</code> テーブルを論理的にグループ分けして、それらを 1 つのオブジェクトとして参照します。データウェアハウスなどの VLDB 環境に適しています。
      </p></li><li class="listitem"><p>
        <a class="link" href="storage-engines.html#federated-storage-engine" title="15.8 FEDERATED ストレージエンジン"><code class="literal">Federated</code></a>: 多くの物理サーバーから 1 つの論理サーバーを作成するために別々の MySQL サーバーをリンクする機能を提供します。分散またはデータマート環境に非常に適しています。
      </p></li><li class="listitem"><p>
        <a class="link" href="storage-engines.html#example-storage-engine" title="15.9 EXAMPLE ストレージエンジン"><code class="literal">例</code></a>: このエンジンは、新しいストレージエンジンの書き込みを開始する方法を示す MySQL ソースコードの例として機能します。これは、主に開発者が対象です。ストレージエンジンは何もしない <span class="quote">「<span class="quote">stub</span>」</span> です。このエンジンでテーブルを作成できますが、それらにデータを格納したり、それらからデータを取り出したりすることはできません。
      </p></li></ul></div><p>
    サーバー全体またはスキーマ全体に同じストレージエンジンを使用するという制限はありません。いずれのテーブルにもストレージエンジンを指定できます。たとえばアプリケーションでは、<code class="literal">InnoDB</code> テーブルを使用している場合がほとんどであり、データをスプレッドシートにエクスポートするための <code class="literal">CSV</code> テーブルを 1 つ、テンポラリワークスペース用に <code class="literal">MEMORY</code> テーブルをいくつか持っています。
  </p><p>
    <span class="bold"><strong>ストレージエンジンの選択</strong></span>
  </p><p>
    MySQL が提供するさまざまなストレージエンジンは、異なるユースケースで使用されることを想定して設計されています。次の表は、MySQL が提供するいくつかのストレージエンジンの概要について示しています。
  </p><div class="table"><a name="idm139979059921920"></a><p class="title"><b>表 15.1 ストレージエンジンの機能サマリー</b></p><div class="table-contents"><table summary="ストレージエンジンの機能サマリー" border="1"><colgroup><col class="feature"><col class="myisam"><col class="memory"><col class="innodb"><col class="archive"><col class="ndb"></colgroup><thead><tr><th scope="col">機能</th><th scope="col">MyISAM</th><th scope="col">メモリー</th><th scope="col">InnoDB</th><th scope="col">アーカイブ</th><th scope="col">NDB</th></tr></thead><tbody><tr><td scope="row">ストレージの制限</td><td>256T バイト</td><td>RAM</td><td>64T バイト</td><td>なし</td><td>384E バイト</td></tr><tr><td scope="row">トランザクション</td><td>いいえ</td><td>いいえ</td><td>はい</td><td>いいえ</td><td>はい</td></tr><tr><td scope="row">ロック粒度</td><td>テーブル</td><td>テーブル</td><td>行</td><td>テーブル</td><td>行</td></tr><tr><td scope="row">MVCC</td><td>いいえ</td><td>いいえ</td><td>はい</td><td>いいえ</td><td>いいえ</td></tr><tr><td scope="row">地理空間データ型のサポート</td><td>はい</td><td>いいえ</td><td>はい</td><td>はい</td><td>はい</td></tr><tr><td scope="row">地理空間インデックスのサポート</td><td>はい</td><td>いいえ</td><td>はい<a href="#ftn.idm139979059899344" class="footnote" name="idm139979059899344"><sup class="footnote">[a]</sup></a></td><td>いいえ</td><td>いいえ</td></tr><tr><td scope="row">B ツリーインデックス</td><td>はい</td><td>はい</td><td>はい</td><td>いいえ</td><td>いいえ</td></tr><tr><td scope="row">T ツリーインデックス</td><td>いいえ</td><td>いいえ</td><td>いいえ</td><td>いいえ</td><td>はい</td></tr><tr><td scope="row">ハッシュインデックス</td><td>いいえ</td><td>はい</td><td>いいえ<a href="#ftn.idm139979059890768" class="footnote" name="idm139979059890768"><sup class="footnote">[b]</sup></a></td><td>いいえ</td><td>はい</td></tr><tr><td scope="row">全文検索インデックス</td><td>はい</td><td>いいえ</td><td>はい<a href="#ftn.idm139979059887440" class="footnote" name="idm139979059887440"><sup class="footnote">[c]</sup></a></td><td>いいえ</td><td>いいえ</td></tr><tr><td scope="row">クラスタ化されたインデックス</td><td>いいえ</td><td>いいえ</td><td>はい</td><td>いいえ</td><td>いいえ</td></tr><tr><td scope="row">データキャッシュ</td><td>いいえ</td><td>N/A</td><td>はい</td><td>いいえ</td><td>はい</td></tr><tr><td scope="row">インデックスキャッシュ</td><td>はい</td><td>N/A</td><td>はい</td><td>いいえ</td><td>はい</td></tr><tr><td scope="row">圧縮データ</td><td>はい<a href="#ftn.idm139979059877136" class="footnote" name="idm139979059877136"><sup class="footnote">[d]</sup></a></td><td>いいえ</td><td>はい<a href="#ftn.idm139979059875664" class="footnote" name="idm139979059875664"><sup class="footnote">[e]</sup></a></td><td>はい</td><td>いいえ</td></tr><tr><td scope="row">暗号化データ<a href="#ftn.idm139979059873776" class="footnote" name="idm139979059873776"><sup class="footnote">[f]</sup></a></td><td>はい</td><td>はい</td><td>はい</td><td>はい</td><td>はい</td></tr><tr><td scope="row">クラスタデータベースのサポート</td><td>いいえ</td><td>いいえ</td><td>いいえ</td><td>いいえ</td><td>はい</td></tr><tr><td scope="row">レプリケーションのサポート<a href="#ftn.idm139979059867968" class="footnote" name="idm139979059867968"><sup class="footnote">[g]</sup></a></td><td>はい</td><td>はい</td><td>はい</td><td>はい</td><td>はい</td></tr><tr><td scope="row">外部キーのサポート</td><td>いいえ</td><td>いいえ</td><td>はい</td><td>いいえ</td><td>いいえ</td></tr><tr><td scope="row">バックアップ/ポイントインタイムリカバリ<a href="#ftn.idm139979059862176" class="footnote" name="idm139979059862176"><sup class="footnote">[h]</sup></a></td><td>はい</td><td>はい</td><td>はい</td><td>はい</td><td>はい</td></tr><tr><td scope="row">クエリーキャッシュのサポート</td><td>はい</td><td>はい</td><td>はい</td><td>はい</td><td>はい</td></tr><tr><td scope="row">データディクショナリ向け更新統計</td><td>はい</td><td>はい</td><td>はい</td><td>はい</td><td>はい</td></tr></tbody><tbody class="footnotes"><tr><td colspan="6"><div id="ftn.idm139979059899344" class="footnote"><p><a href="#idm139979059899344" class="para"><sup class="para">[a] </sup></a>InnoDB の地理空間インデックスサポートは MySQL 5.7.5 以降で使用できます。</p></div><div id="ftn.idm139979059890768" class="footnote"><p><a href="#idm139979059890768" class="para"><sup class="para">[b] </sup></a>InnoDB は、アダプティブハッシュインデックス機能に対して、内部的にハッシュインデックスを利用します。</p></div><div id="ftn.idm139979059887440" class="footnote"><p><a href="#idm139979059887440" class="para"><sup class="para">[c] </sup></a>InnoDB の FULLTEXT インデックスサポートは MySQL 5.6.4 以降で使用できます。</p></div><div id="ftn.idm139979059877136" class="footnote"><p><a href="#idm139979059877136" class="para"><sup class="para">[d] </sup></a>圧縮された MyISAM テーブルがサポートされているのは、圧縮行フォーマットを使用している場合だけです。MyISAM で圧縮行フォーマットを使用するテーブルは、読み取り専用です。</p></div><div id="ftn.idm139979059875664" class="footnote"><p><a href="#idm139979059875664" class="para"><sup class="para">[e] </sup></a>圧縮された InnoDB テーブルは InnoDB Barracuda ファイルフォーマットを必要とします。</p></div><div id="ftn.idm139979059873776" class="footnote"><p><a href="#idm139979059873776" class="para"><sup class="para">[f] </sup></a>ストレージエンジン内ではなくサーバー内で (暗号化関数を使って) 実装されています。</p></div><div id="ftn.idm139979059867968" class="footnote"><p><a href="#idm139979059867968" class="para"><sup class="para">[g] </sup></a>ストレージエンジン内ではなくサーバー内で実装されています。</p></div><div id="ftn.idm139979059862176" class="footnote"><p><a href="#idm139979059862176" class="para"><sup class="para">[h] </sup></a>ストレージエンジン内ではなくサーバー内で実装されています。</p></div></td></tr></tbody></table></div></div><br class="table-break"><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="storage-engine-setting"></a>15.1 ストレージエンジンの設定</h2></div></div></div><p>
      新しいテーブルを作成するときに、<code class="literal">ENGINE</code> テーブルオプションを <code class="literal">CREATE TABLE</code> ステートメントに加えることによって、どのストレージエンジンを利用するかを指定できます。
    </p><pre class="programlisting">
-- ENGINE=INNODB not needed unless you have set a different
-- default storage engine.
CREATE TABLE t1 (i INT) ENGINE = INNODB;
-- Simple table definitions can be switched from one to another.
CREATE TABLE t2 (i INT) ENGINE = CSV;
CREATE TABLE t3 (i INT) ENGINE = MEMORY;
</pre><p>
      <code class="literal">ENGINE</code> オプションを省略した場合、デフォルトのストレージエンジンが使用されます。デフォルトのエンジンは MySQL 5.6 の <code class="literal">InnoDB</code> です。デフォルトのエンジンを指定するには、<code class="option">--default-storage-engine</code> サーバースタートアップオプションを使用するか、<code class="filename">my.cnf</code> 構成ファイルにある <code class="option">default-storage-engine</code> オプションを設定するかします。
    </p><p>
      現在のセッションにデフォルトのストレージエンジンを設定するには、<code class="literal">default_storage_engine</code> 変数を設定します。
    </p><pre class="programlisting">
SET default_storage_engine=NDBCLUSTER;
</pre><p>
      MySQL 5.6.3 以降では、<code class="literal">CREATE TEMPORARY TABLE</code> で作成された <code class="literal">TEMPORARY</code> テーブルのストレージエンジンは、スタートアップ時または実行時のいずれかに <code class="literal">default_tmp_storage_engine</code> を設定することで、永続的なテーブルのエンジンから個別に設定できます。MySQL 5.6.3 より前は、<code class="literal">default_storage_engine</code> で永続および <code class="literal">TEMPORARY</code> の両方のテーブルのエンジンを設定します。
    </p><p>
      テーブルを別のストレージエンジンに変換するには、新しいエンジンを指定する <code class="literal">ALTER TABLE</code> ステートメントを使用します。
    </p><pre class="programlisting">
ALTER TABLE t ENGINE = InnoDB;
</pre><p>
      <a class="xref" href="sql-syntax.html#create-table" title="13.1.17 CREATE TABLE 構文">セクション13.1.17「CREATE TABLE 構文」</a>および <a class="xref" href="sql-syntax.html#alter-table" title="13.1.7 ALTER TABLE 構文">セクション13.1.7「ALTER TABLE 構文」</a>を参照してください。
    </p><p>
      コンパイルされていないストレージエンジン、またはコンパイルされているが無効化されたストレージエンジンを使用する場合、MySQL はその代わりに、デフォルトのストレージエンジンを使用してテーブルを作成します。たとえばレプリケーションのセットアップで、マスターサーバーは、最大限の安全性を得るために <code class="literal">InnoDB</code> テーブルを使用し、スレーブサーバーは持続性と一貫性を犠牲にして速度を得るために、代替ストレージエンジンを使用する場合があります。
    </p><p>
      デフォルトでは、<code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> がデフォルトのストレージエンジンを使用できない場合は、常に警告が生成されます。目的のエンジンが使用できない場合に、混乱を起こす意図しない動作をしないようにするには、<code class="literal">NO_ENGINE_SUBSTITUTION</code> SQL モードを有効にします。目的のエンジンが使用できない場合、この設定によって、警告の代わりにエラーが起こり、テーブルが作成されたり変更されたりしません。<a class="xref" href="server-administration.html#sql-mode" title="5.1.7 サーバー SQL モード">セクション5.1.7「サーバー SQL モード」</a>を参照してください。
    </p><p>
      新しいテーブルの場合、MySQL はテーブルとカラムの定義を保持するために <code class="filename">.frm</code> ファイルを必ず作成します。テーブルのインデックスとデータは、ストレージエンジンによっても異なりますが、1 つまたは複数の別のファイルに格納してもかまいません。サーバーがストレージエンジンレベルの上位に <code class="filename">.frm</code> ファイルを作成します。個々のストレージエンジンは、それらが管理するテーブルに必要なファイルをさらに作成します。テーブル名に特殊文字が含まれている場合は、<a class="xref" href="language-structure.html#identifier-mapping" title="9.2.3 識別子とファイル名のマッピング">セクション9.2.3「識別子とファイル名のマッピング」</a>で説明されているように、その文字のエンコードされたバージョンがテーブルファイルの名前に含まれます。
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="myisam-storage-engine"></a>15.2 MyISAM ストレージエンジン</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="storage-engines.html#myisam-start">15.2.1 MyISAM 起動オプション</a></span></dt><dt><span class="section"><a href="storage-engines.html#key-space">15.2.2 キーに必要な容量</a></span></dt><dt><span class="section"><a href="storage-engines.html#myisam-table-formats">15.2.3 MyISAM テーブルのストレージフォーマット</a></span></dt><dt><span class="section"><a href="storage-engines.html#myisam-table-problems">15.2.4 MyISAM テーブルの問題点</a></span></dt></dl></div><a class="indexterm" name="idm139979059819200"></a><a class="indexterm" name="idm139979059817712"></a><p>
    <code class="literal">MyISAM</code> は古い (そしてすでに使用できない) <code class="literal">ISAM</code> ストレージエンジンに基づいていますが、多くの役に立つ拡張機能を持っています。
  </p><div class="table"><a name="idm139979059813664"></a><p class="title"><b>表 15.2 <code class="literal">MyISAM</code> ストレージエンジンの機能</b></p><div class="table-contents"><table summary="MyISAM ストレージエンジンの機能" border="1"><colgroup><col class="featurev0"><col class="featurevalue0"><col class="featurev1"><col class="featurevalue1"><col class="featurev2"><col class="featurevalue2"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>ストレージの制限</strong></span></td><td>256T バイト</td><td><span class="bold"><strong>トランザクション</strong></span></td><td>いいえ</td><td><span class="bold"><strong>ロック粒度</strong></span></td><td>テーブル</td></tr><tr><td scope="row"><span class="bold"><strong>MVCC</strong></span></td><td>いいえ</td><td><span class="bold"><strong>地理空間データ型のサポート</strong></span></td><td>はい</td><td><span class="bold"><strong>地理空間インデックスのサポート</strong></span></td><td>はい</td></tr><tr><td scope="row"><span class="bold"><strong>B ツリーインデックス</strong></span></td><td>はい</td><td><span class="bold"><strong>T ツリーインデックス</strong></span></td><td>いいえ</td><td><span class="bold"><strong>ハッシュインデックス</strong></span></td><td>いいえ</td></tr><tr><td scope="row"><span class="bold"><strong>全文検索インデックス</strong></span></td><td>はい</td><td><span class="bold"><strong>クラスタ化されたインデックス</strong></span></td><td>いいえ</td><td><span class="bold"><strong>データキャッシュ</strong></span></td><td>いいえ</td></tr><tr><td scope="row"><span class="bold"><strong>インデックスキャッシュ</strong></span></td><td>はい</td><td><span class="bold"><strong>圧縮データ</strong></span></td><td>はい<a href="#ftn.idm139979059790112" class="footnote" name="idm139979059790112"><sup class="footnote">[a]</sup></a></td><td><span class="bold"><strong>暗号化データ<a href="#ftn.idm139979059788656" class="footnote" name="idm139979059788656"><sup class="footnote">[b]</sup></a></strong></span></td><td>はい</td></tr><tr><td scope="row"><span class="bold"><strong>クラスタデータベースのサポート</strong></span></td><td>いいえ</td><td><span class="bold"><strong>レプリケーションのサポート<a href="#ftn.idm139979059785504" class="footnote" name="idm139979059785504"><sup class="footnote">[c]</sup></a></strong></span></td><td>はい</td><td><span class="bold"><strong>外部キーのサポート</strong></span></td><td>いいえ</td></tr><tr><td scope="row"><span class="bold"><strong>バックアップ/ポイントインタイムリカバリ<a href="#ftn.idm139979059782368" class="footnote" name="idm139979059782368"><sup class="footnote">[d]</sup></a></strong></span></td><td>はい</td><td><span class="bold"><strong>クエリーキャッシュのサポート</strong></span></td><td>はい</td><td><span class="bold"><strong>データディクショナリ向け更新統計</strong></span></td><td>はい</td></tr></tbody><tbody class="footnotes"><tr><td colspan="6"><div id="ftn.idm139979059790112" class="footnote"><p><a href="#idm139979059790112" class="para"><sup class="para">[a] </sup></a>圧縮された MyISAM テーブルがサポートされているのは、圧縮行フォーマットを使用している場合だけです。MyISAM で圧縮行フォーマットを使用するテーブルは、読み取り専用です。</p></div><div id="ftn.idm139979059788656" class="footnote"><p><a href="#idm139979059788656" class="para"><sup class="para">[b] </sup></a>ストレージエンジン内ではなくサーバー内で (暗号化関数を使って) 実装されています。</p></div><div id="ftn.idm139979059785504" class="footnote"><p><a href="#idm139979059785504" class="para"><sup class="para">[c] </sup></a>ストレージエンジン内ではなくサーバー内で実装されています。</p></div><div id="ftn.idm139979059782368" class="footnote"><p><a href="#idm139979059782368" class="para"><sup class="para">[d] </sup></a>ストレージエンジン内ではなくサーバー内で実装されています。</p></div></td></tr></tbody></table></div></div><br class="table-break"><p>
    各 <code class="literal">MyISAM</code> テーブルはディスク上に 3 つのファイルとして格納されます。そのファイル名はテーブル名で始まり、ファイルタイプを示す拡張子が付きます。<code class="filename">.frm</code> ファイルはテーブルフォーマットを格納します。データファイルには <code class="filename">.MYD</code> (<code class="literal">MYData</code>) 拡張子が付きます。インデックスファイルには <code class="filename">.MYI</code> (<code class="literal">MYIndex</code>) 拡張子が付きます。
  </p><p>
    <code class="literal">MyISAM</code> テーブルが必要であることを明示的に指定するには、<code class="literal">ENGINE</code> テーブルオプションで指定します。
  </p><pre class="programlisting">
CREATE TABLE t (i INT) ENGINE = MYISAM;
</pre><p>
    MySQL 5.6 では通常、<code class="literal">InnoDB</code> がデフォルトエンジンであるため、<code class="literal">ENGINE</code> を使用して <code class="literal">MyISAM</code> ストレージエンジンを指定する必要があります。
  </p><p>
    <span class="command"><strong>mysqlcheck</strong></span> クライアントか <span class="command"><strong>myisamchk</strong></span> ユーティリティーで <code class="literal">MyISAM</code> テーブルをチェックしたり修正したりできます。容量を節約するために <span class="command"><strong>myisampack</strong></span>を使って <code class="literal">MyISAM</code> テーブルを圧縮することもできます。<a class="xref" href="programs.html#mysqlcheck" title="4.5.3 mysqlcheck — テーブル保守プログラム">セクション4.5.3「<span class="command"><strong>mysqlcheck</strong></span> — テーブル保守プログラム」</a>、<a class="xref" href="programs.html#myisamchk" title="4.6.3 myisamchk — MyISAM テーブルメンテナンスユーティリティー">セクション4.6.3「<span class="command"><strong>myisamchk</strong></span> — MyISAM テーブルメンテナンスユーティリティー」</a>、<a class="xref" href="programs.html#myisampack" title="4.6.5 myisampack — 圧縮された読み取り専用の MyISAM テーブルの生成">セクション4.6.5「<span class="command"><strong>myisampack</strong></span> — 圧縮された読み取り専用の MyISAM テーブルの生成」</a>を参照してください。
  </p><p>
    <code class="literal">MyISAM</code> テーブルには次のような特徴があります。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        すべてのデータ値は、下位バイトから順に格納されます。これにより、データマシンとオペレーティングシステムは依存しなくなります。バイナリポータビリティーのための唯一の要件は、2 の補数の符号付き整数と IEEE 浮動小数点フォーマットを使用することです。これらの要件は主流のマシンで幅広く使用されています。バイナリポータビリティーは、組み込みシステムには適用されない可能性があります。特別のプロセッサを使用している場合があるためです。
      </p><p>
        下位バイトから順にデータを格納するため、大きな速度低下はありません。通常、テーブル行のバイトは整列しておらず、順番に未整列のバイトを読み込む処理は逆の順番に読み込む処理より時間がかかりません。また、カラム値をフェッチするサーバーのコードは、ほかのコードに比べて速度は重視されません。
      </p></li><li class="listitem"><p>
        インデックスを効率良く圧縮ができるため、すべての数値キー値は上位バイトから順に格納されます。
      </p></li><li class="listitem"><p>
        大きなファイル (最大 63 ビットのファイル長) は、大きなファイルをサポートするファイルシステムとオペレーティングシステムでサポートされます。
      </p></li><li class="listitem"><p>
        <code class="literal">MyISAM</code> テーブルの行数は、(2<sup>32</sup>)<sup>2</sup> (1.844E+19) の制限があります。
      </p></li><li class="listitem"><p>
        1 つの <code class="literal">MyISAM</code> テーブルの最大インデックス数は 64 です。
      </p><p>
        1 つのインデックスの最大カラム数は 16 です。
      </p></li><li class="listitem"><p>
        最大キー長は 1000 バイトです。これは、ソースを変更して再コンパイルしても変えることができます。キーが 250 バイトより長いと、キーのブロックサイズはデフォルト値の 1024 バイトより大きい値が使用されます。
      </p></li><li class="listitem"><p>
        ソートされた順番で行が挿入されたとき (<code class="literal">AUTO_INCREMENT</code> カラムを使用しているときと同様に)、上位のノードが 1 つのキーだけを含むように、インデックスツリーが分割されます。これにより、インデックスツリーの領域の利用率が向上します。
      </p></li><li class="listitem"><p>
        テーブルごとに 1 つの <code class="literal">AUTO_INCREMENT</code> カラムの内部処理がサポートされます。<code class="literal">MyISAM</code> は <code class="literal">INSERT</code> 操作と <code class="literal">UPDATE</code> 操作でこのカラムを自動的に更新します。これにより、<code class="literal">AUTO_INCREMENT</code> カラムは速くなります (少なくとも 10 %)。シーケンスの一番上の値は、削除されると、再利用されません。(<code class="literal">AUTO_INCREMENT</code> カラムがマルチカラムインデックスの最後のカラムとして定義された場合、シーケンスの最上部から削除された値が再利用されます。)<code class="literal">AUTO_INCREMENT</code> 値は <code class="literal">ALTER TABLE</code> や <span class="command"><strong>myisamchk</strong></span> でリセットできます。
      </p></li><li class="listitem"><p>
        動的サイズの行は、削除を更新および挿入と併用すると、フラグメント化がかなり減少します。これは、削除された隣接ブロックを自動的に結合し、次のブロックが削除されたときにブロックを拡張することで行われます。
      </p></li><li class="listitem"><p>
        <code class="literal">MyISAM</code> は同時挿入をサポートしています。テーブルのデータファイルの途中に空きブロックがなければ、ほかのスレッドがテーブルから読み取るのと同時に新しい行をそれに <code class="literal">INSERT</code> できます。行を削除した結果として、または動的長の行を現在の内容より多くのデータで更新した結果として、空きブロックが発生する可能性があります。すべての空きブロックが完全に使用されると (埋まると)、その後の挿入はふたたび並列になります。<a class="xref" href="optimization.html#concurrent-inserts" title="8.10.3 同時挿入">セクション8.10.3「同時挿入」</a>を参照してください。
      </p></li><li class="listitem"><p>
        データファイルとインデックスファイルを異なる物理デバイス上の異なるディレクトリに置き、<code class="literal">DATA DIRECTORY</code> および <code class="literal">INDEX DIRECTORY</code> テーブルオプションを <code class="literal">CREATE TABLE</code> に付けて速度を上げることができます。<a class="xref" href="sql-syntax.html#create-table" title="13.1.17 CREATE TABLE 構文">セクション13.1.17「CREATE TABLE 構文」</a>を参照してください。
      </p></li><li class="listitem"><p>
        <code class="literal">BLOB</code> と <code class="literal">TEXT</code> カラムはインデックスを付けることができます。
      </p></li><li class="listitem"><p>
        インデックスを付けたカラムでは <code class="literal">NULL</code> 値が許可されます。これには、キー当たり 0 - 1 バイトが必要です。
      </p></li><li class="listitem"><p>
        文字カラムごとに異なる文字セットを持つことができます。<a class="xref" href="globalization.html#charset" title="10.1 文字セットのサポート">セクション10.1「文字セットのサポート」</a>を参照してください。
      </p></li><li class="listitem"><p>
        <code class="literal">MyISAM</code> インデックスファイルの中に、テーブルが正しく閉じられたかどうかを表すフラグがあります。<span class="command"><strong>mysqld</strong></span> が <code class="option">--myisam-recover-options</code> オプションで起動された場合、<code class="literal">MyISAM</code> テーブルはいつ開かれたかが自動的に確認され、正しく閉じられていなかった場合は修復されます。
      </p></li><li class="listitem"><p>
        <span class="command"><strong>myisamchk</strong></span> は <code class="option">--update-state</code> オプションを付けて実行したかどうかをテーブルにマークします。<span class="command"><strong>myisamchk --fast</strong></span> はこのマークがないテーブルだけを確認します。
      </p></li><li class="listitem"><p>
        <span class="command"><strong>myisamchk --analyze</strong></span> はキー全体に対してするのと同様に、キーの一部分に対する統計データを格納します。
      </p></li><li class="listitem"><p>
        <span class="command"><strong>myisampack</strong></span> は <code class="literal">BLOB</code> と <code class="literal">VARCHAR</code> カラムを圧縮できます。
      </p></li></ul></div><p>
    <code class="literal">MyISAM</code> は次のような機能もサポートしています。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        真の <code class="literal">VARCHAR</code> 型をサポートしています。<code class="literal">VARCHAR</code> カラムは 1 バイトか 2 バイトで格納される長さから始まります。
      </p></li><li class="listitem"><p>
        <code class="literal">VARCHAR</code> カラムを持つテーブルの行の長さは固定でも動的でもかまいません。
      </p></li><li class="listitem"><p>
        テーブル内の <code class="literal">VARCHAR</code> と <code class="literal">CHAR</code> カラムの長さの合計は、最大で 64K バイトになる場合があります。
      </p></li><li class="listitem"><p>
        任意の長さの <code class="literal">UNIQUE</code> 制約。
      </p></li></ul></div><h3><a name="idm139979059696784"></a>追加のリソース</h3><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="literal">MyISAM</code> ストレージエンジンに特化したフォーラムは <a class="ulink" href="http://forums.mysql.com/list.php?21" target="_top">http://forums.mysql.com/list.php?21</a>で参照できます。
      </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="myisam-start"></a>15.2.1 MyISAM 起動オプション</h3></div></div></div><p>
      <code class="literal">MyISAM</code> テーブルの振る舞いを変えるために、次の <span class="command"><strong>mysqld</strong></span> オプションを使用できます。追加情報については <a class="xref" href="server-administration.html#server-options" title="5.1.3 サーバーコマンドオプション">セクション5.1.3「サーバーコマンドオプション」</a>を参照してください。
    </p><div class="table"><a name="idm139979059689712"></a><p class="title"><b>表 15.3 <code class="literal">MyISAM</code> オプション/変数リファレンス</b></p><div class="table-contents"><table summary="MyISAM オプション/変数リファレンス" border="1"><colgroup><col class="name"><col class="cmd-line"><col class="option_file"><col class="system_var"><col class="status_var"><col class="var_scope"><col class="dynamic"></colgroup><thead><tr><th scope="col">名前</th><th scope="col">コマンド行</th><th scope="col">オプションファイル</th><th scope="col">システム変数</th><th scope="col">ステータス変数</th><th scope="col">変数スコープ</th><th scope="col">動的</th></tr></thead><tbody><tr><td scope="row"><a class="link" href="server-administration.html#sysvar_bulk_insert_buffer_size">bulk_insert_buffer_size</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>両方</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#sysvar_concurrent_insert">concurrent_insert</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#option_mysqld_delay-key-write">delay-key-write</a></td><td>はい</td><td>はい</td><td> </td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"> - <span class="emphasis"><em>変数</em></span>: <a class="link" href="server-administration.html#sysvar_delay_key_write">delay_key_write</a></td><td> </td><td> </td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#sysvar_have_rtree_keys">have_rtree_keys</a></td><td> </td><td> </td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#sysvar_key_buffer_size">key_buffer_size</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#option_mysqld_log-isam">log-isam</a></td><td>はい</td><td>はい</td><td> </td><td> </td><td> </td><td> </td></tr><tr><td scope="row"><a class="link" href="server-administration.html#option_mysqld_myisam-block-size">myisam-block-size</a></td><td>はい</td><td>はい</td><td> </td><td> </td><td> </td><td> </td></tr><tr><td scope="row"><a class="link" href="server-administration.html#sysvar_myisam_data_pointer_size">myisam_data_pointer_size</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#sysvar_myisam_max_sort_file_size">myisam_max_sort_file_size</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#sysvar_myisam_mmap_size">myisam_mmap_size</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#option_mysqld_myisam-recover-options">myisam-recover-options</a></td><td>はい</td><td>はい</td><td> </td><td> </td><td> </td><td> </td></tr><tr><td scope="row"> - <span class="emphasis"><em>変数</em></span>: <a class="link" href="server-administration.html#sysvar_myisam_recover_options">myisam_recover_options</a></td><td> </td><td> </td><td> </td><td> </td><td> </td><td> </td></tr><tr><td scope="row"><a class="link" href="server-administration.html#sysvar_myisam_recover_options">myisam_recover_options</a></td><td> </td><td> </td><td>はい</td><td> </td><td>グローバル</td><td>いいえ</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#sysvar_myisam_repair_threads">myisam_repair_threads</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>両方</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#sysvar_myisam_sort_buffer_size">myisam_sort_buffer_size</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>両方</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#sysvar_myisam_stats_method">myisam_stats_method</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>両方</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#sysvar_myisam_use_mmap">myisam_use_mmap</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>グローバル</td><td>はい</td></tr><tr><td scope="row"><a class="link" href="server-administration.html#option_mysqld_skip-concurrent-insert">skip-concurrent-insert</a></td><td>はい</td><td>はい</td><td> </td><td> </td><td> </td><td> </td></tr><tr><td scope="row"> - <span class="emphasis"><em>変数</em></span>: <a class="link" href="server-administration.html#sysvar_concurrent_insert">concurrent_insert</a></td><td> </td><td> </td><td> </td><td> </td><td> </td><td> </td></tr><tr><td scope="row"><a class="link" href="server-administration.html#sysvar_tmp_table_size">tmp_table_size</a></td><td>はい</td><td>はい</td><td>はい</td><td> </td><td>両方</td><td>はい</td></tr></tbody></table></div></div><br class="table-break"><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="indexterm" name="idm139979059609056"></a> <a class="indexterm" name="idm139979059606816"></a> <code class="option">--myisam-recover-options=<em class="replaceable"><code>モード</code></em></code>
        </p><p>
          クラッシュした <code class="literal">MyISAM</code> テーブルの自動リカバリにモードを設定します。
        </p></li><li class="listitem"><p>
          <a class="indexterm" name="idm139979059601712"></a> <a class="indexterm" name="idm139979059599504"></a> <code class="option">--delay-key-write=ALL</code>
        </p><p>
          <code class="literal">MyISAM</code> テーブルへの書き込みの間にキーバッファーをフラッシュしないでください。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            これを行う場合、<code class="literal">MyISAM</code> テーブルの使用中に別のプログラムから (別の MySQL サーバーから、<span class="command"><strong>myisamchk</strong></span> を使用して、など)、このテーブルにアクセスしないでください。そのようにすると、インデックスが破損するおそれがあります。<code class="option">--external-locking</code> を利用しても、このリスクは回避されません。
          </p></div></li></ul></div><p>
      次のシステム変数は <code class="literal">MyISAM</code> テーブルの振る舞いに影響を与えます。追加情報については <a class="xref" href="server-administration.html#server-system-variables" title="5.1.4 サーバーシステム変数">セクション5.1.4「サーバーシステム変数」</a>を参照してください。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">bulk_insert_buffer_size</code>
        </p><p>
          大量挿入の最適化に使用されるツリーキャッシュのサイズです。
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
            これは、<span class="emphasis"><em>スレッド当たりの</em></span>制限値です。
          </p></div></li><li class="listitem"><p>
          <code class="literal">myisam_max_sort_file_size</code>
        </p><p>
          <code class="literal">MyISAM</code> インデックスを再作成するとき (<code class="literal">REPAIR TABLE</code>、<code class="literal">ALTER TABLE</code>、または <code class="literal">LOAD DATA INFILE</code> 中に)、MySQL が使用を許可されている一時ファイルの最大サイズ。ファイルサイズがこの値より大きい場合、さらに低速なキーキャッシュを代わりに使用してインデックスが作成されます。値はバイト単位で指定されます。
        </p></li><li class="listitem"><p>
          <code class="literal">myisam_sort_buffer_size</code>
        </p><p>
          テーブルのリカバリ時に使用されるバッファーのサイズを設定します。
        </p></li></ul></div><p>
      自動リカバリが有効になるのは、<span class="command"><strong>mysqld</strong></span> を <code class="option">--myisam-recover-options</code> オプションで起動した場合です。この場合、サーバーが <code class="literal">MyISAM</code> テーブルを開いたときに、テーブルにクラッシュのマークが付いているかどうかや、テーブルのオープンカウント変数が 0 でないかどうか、そして外部ロックが使用不可能な状態でサーバーを作動させているかどうかを確認します。これらの条件のいずれかが true である場合、次のことが起こります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          サーバーは、テーブルにエラーがあるかどうかを確認します。
        </p></li><li class="listitem"><p>
          サーバーがエラーを検出した場合、迅速なテーブル修復を行います (データファイルのソートは行いますが、再作成は行いません)。
        </p></li><li class="listitem"><p>
          データファイルの中にエラーがあるために (たとえば、重複キーエラーなど) 修復が失敗した場合、サーバーは再試行して、今度はデータファイルを再作成します。
        </p></li><li class="listitem"><p>
          それでも修復が失敗した場合、サーバーはもう一度古い修復オプション方式で試行します (ソートをせずに行ごとに書き込みます)。この方法は、どのタイプのエラーも修復できるはずであり、ディスク容量の要件は低くなっています。
        </p></li></ul></div><p>
      このリカバリで、前に実行したステートメントからすべての行をリカバリできず、<code class="literal">FORCE</code> を <code class="option">--myisam-recover-options</code> オプションの値に指定しなかった場合、自動修復はエラーメッセージをエラーログに書いて中止します。
    </p><pre class="programlisting">
Error: Couldn't repair table: test.g00pages
</pre><p>
      <code class="literal">FORCE</code> を指定すると、代わりにこのような警告が書かれます。
    </p><pre class="programlisting">
Warning: Found 344 of 354 rows when repairing ./test/g00pages
</pre><p>
      自動リカバリの値に <code class="literal">BACKUP</code> が含まれていると、リカバリプロセスはフォーム <code class="filename"><em class="replaceable"><code>tbl_name-datetime</code></em>.BAK</code> の名前を持つファイルを作成します。これらのファイルを自動的にデータベースディレクトリからバックアップメディアに移動する <span class="command"><strong>cron</strong></span> スクリプトを持つことをお勧めします。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="key-space"></a>15.2.2 キーに必要な容量</h3></div></div></div><a class="indexterm" name="idm139979059557760"></a><p>
      <code class="literal">MyISAM</code> テーブルは B ツリーインデックスを使用します。インデックスファイルのサイズは、キーを <code class="literal">(key_length+4)/0.67</code> と計算し、すべてのキーに対してその値を合計して概算できます。これは、すべてのキーがソート順に挿入され、テーブル内のキーが圧縮されていなときの最悪なケースです。
    </p><p>
      文字列のインデックスはスペース圧縮されています。最初のインデックス部が文字列の場合、プリフィクスも圧縮されています。文字列カラムに含まれる後続の空白が長い場合、またはそのカラムが <code class="literal">VARCHAR</code> カラムであるために、必ずしもその長さがフルに使用されることがない場合は、スペース圧縮によってインデックスファイルが最悪の数値よりも小さくなります。プリフィクスの圧縮は文字列から始まるキーで使用されます。多くの文字列が同一のプリフィクスで始まる場合、プリフィクスの圧縮が役に立ちます。
    </p><p>
      <code class="literal">MyISAM</code> テーブルでは、テーブルの作成時に <code class="literal">PACK_KEYS=1</code> テーブルオプションを指定することで、数値のプリフィクスを圧縮することもできます。数値は上位バイトから順に格納されるため、同一のプリフィクスを持つ整数キーが多数あるときに役立ちます。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="myisam-table-formats"></a>15.2.3 MyISAM テーブルのストレージフォーマット</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="storage-engines.html#static-format">15.2.3.1 静的 (固定長) テーブルの特長</a></span></dt><dt><span class="section"><a href="storage-engines.html#dynamic-format">15.2.3.2 動的テーブルの特徴</a></span></dt><dt><span class="section"><a href="storage-engines.html#compressed-format">15.2.3.3 圧縮テーブルの特徴</a></span></dt></dl></div><p>
      <code class="literal">MyISAM</code> は 3 つの異なるストレージフォーマットをサポートします。使用するカラムの型によって、固定フォーマットと動的フォーマットの 2 つが自動的に選択されます。3 つ目は圧縮フォーマットで、<span class="command"><strong>myisampack</strong></span> ユーティリティーを使用した場合にのみ作成できます (<a class="xref" href="programs.html#myisampack" title="4.6.5 myisampack — 圧縮された読み取り専用の MyISAM テーブルの生成">セクション4.6.5「<span class="command"><strong>myisampack</strong></span> — 圧縮された読み取り専用の MyISAM テーブルの生成」</a>を参照してください)。
    </p><p>
      <code class="literal">BLOB</code> または <code class="literal">TEXT</code> カラムを持たないテーブルに対して、<code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> を使用する場合、<code class="literal">ROW_FORMAT</code> テーブルオプションで、テーブルフォーマットを強制的に <code class="literal">FIXED</code> または <code class="literal">DYNAMIC</code> にできます。
    </p><p>
      <code class="literal">ROW_FORMAT</code> についての情報は、<a class="xref" href="sql-syntax.html#create-table" title="13.1.17 CREATE TABLE 構文">セクション13.1.17「CREATE TABLE 構文」</a>を参照してください。
    </p><p>
      圧縮された <code class="literal">MyISAM</code> テーブルを <span class="command"><strong>myisamchk <code class="option">--unpack</code></strong></span> を使用して解凍 (アンパック) できます。詳細については、<a class="xref" href="programs.html#myisamchk" title="4.6.3 myisamchk — MyISAM テーブルメンテナンスユーティリティー">セクション4.6.3「<span class="command"><strong>myisamchk</strong></span> — MyISAM テーブルメンテナンスユーティリティー」</a>を参照してください。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="static-format"></a>15.2.3.1 静的 (固定長) テーブルの特長</h4></div></div></div><p>
        <code class="literal">MyISAM</code> テーブルでは、静的フォーマットがデフォルトです。テーブルに可変長のカラムが含まれない場合に使用されます (<code class="literal">VARCHAR</code>、<code class="literal">VARBINARY</code>、<code class="literal">BLOB</code>、または <code class="literal">TEXT</code>)。各行は固定バイト数で格納されます。
      </p><p>
        3 つの <code class="literal">MyISAM</code> ストレージフォーマットの中で、静的フォーマットが一番シンプルで安全です (一番破損しにくい)。またこれは、ディスク上でデータファイルの中の行が容易に検出できるという理由で、オンディスクフォーマットの中でもっとも高速です。インデックスの中の行数に基づいて行を検索するには、行数に行長を掛けて行の位置を計算します。また、テーブルをスキャンするときに、ディスクの読み込み操作ごとに一定の行数を読み込むことが容易です。
      </p><p>
        MySQL サーバーが固定フォーマットの <code class="literal">MyISAM</code> ファイルに書き込んでいる最中にコンピュータがクラッシュした場合、その安全性が証明されます。この場合、<span class="command"><strong>myisamchk</strong></span> はそれぞれの行がどこで始まりどこで終わるかを簡単に判断できるため、通常、一部が書き込まれた行を除くすべての行を再利用できます。<code class="literal">MyISAM</code> テーブルインデックスは、データ行に基づいていつでも再構築できます。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          固定長の行フォーマットは、<code class="literal">BLOB</code> または <code class="literal">TEXT</code> カラムがないテーブルでのみ使用できます。明示的な <code class="literal">ROW_FORMAT</code> 句を持つカラムでテーブルを作成すると、エラーや警告は発生しません。フォーマットの仕様は無視されます。
        </p></div><p>
        静的フォーマットのテーブルには、次の特徴があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CHAR</code> および <code class="literal">VARCHAR</code> カラムには、特定のカラム幅にスペースが埋め込まれます (しかし、カラムの型は変わりません)。<code class="literal">BINARY</code> および <code class="literal">VARBINARY</code> カラムには、カラム幅に <code class="literal">0x00</code> バイトが埋め込まれます。
          </p></li><li class="listitem"><p>
            非常に高速です。
          </p></li><li class="listitem"><p>
            キャッシュが容易です。
          </p></li><li class="listitem"><p>
            行が固定位置にあるため、クラッシュしたあとも再構築が容易です。
          </p></li><li class="listitem"><p>
            大量の行を削除して、空きディスク容量をオペレーティングシステムに戻す場合を除いて、再編成の必要はありません。これを行うには、<code class="literal">OPTIMIZE TABLE</code> または <span class="command"><strong>myisamchk -r</strong></span> を使用します。
          </p></li><li class="listitem"><p>
            通常は、動的フォーマットテーブルよりも多くのディスク容量を必要とします。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="dynamic-format"></a>15.2.3.2 動的テーブルの特徴</h4></div></div></div><a class="indexterm" name="idm139979059500304"></a><a class="indexterm" name="idm139979059498832"></a><p>
        <code class="literal">MyISAM</code> テーブルが可変長カラムを含んでいる場合 (<code class="literal">VARCHAR</code>、<code class="literal">VARBINARY</code>、<code class="literal">BLOB</code>、または <code class="literal">TEXT</code>)、またはテーブルが <code class="literal">ROW_FORMAT=DYNAMIC</code> テーブルオプションで作成された場合は、動的ストレージフォーマットが使用されます。
      </p><p>
        動的フォーマットは、それぞれの行に行の長さを示すヘッダーがあるため、静的フォーマットよりも少し複雑です。更新の結果として行が長くなった場合、行がフラグメント化される可能性があります (非連続的な断片で格納されます)。
      </p><a class="indexterm" name="idm139979059489696"></a><p>
        <code class="literal">OPTIMIZE TABLE</code> または <span class="command"><strong>myisamchk -r</strong></span> を使用して、テーブルをデフラグできます。可変長カラムも含んだテーブルで、固定長カラムに頻繁にアクセスしたり変更したりする場合、可変長カラムを他のテーブルに移動して、フラグメンテーションを回避する方法が良い場合があります。
      </p><p>
        動的フォーマットのテーブルには、次の特徴があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            長さが 4 未満のカラムを除くすべての文字列カラムは動的です。
          </p></li><li class="listitem"><p>
            それぞれの行の先頭には、どのカラムが空の文字列 (文字列カラムの場合) またはゼロ (数値カラムの場合) を含むかを示すビットマップが付いています。これには、<code class="literal">NULL</code> 値を含むカラムが含まれていません。後続スペースを削除したあとに文字列カラムの長さがゼロであったり、数値カラムの値がゼロであったりした場合、ビットマップの中でマークが付きますが、ディスクには保存されません。空ではない文字列は、長さバイトに文字列コンテンツを加えて保存されます。
          </p></li><li class="listitem"><p>
            通常、固定長テーブルに比べると、必要なディスク容量がかなり少なくなります。
          </p></li><li class="listitem"><p>
            それぞれの行は、必要とする容量だけを使用します。ただし、行がさらに大きくなると、必要な数の断片に分割され、行のフラグメンテーションが起こることになります。たとえば、行の長さを延長する情報を使って行を更新すると、その行はフラグメント化されます。このような場合、パフォーマンスを上げるために、ときどき <code class="literal">OPTIMIZE TABLE</code> または <span class="command"><strong>myisamchk -r</strong></span> を実行しなければいけないかもしれません。<span class="command"><strong>myisamchk -ei</strong></span> を使用して、テーブルの統計を取得します。
          </p></li><li class="listitem"><p>
            行がいくつもの断片にフラグメント化されている場合や、リンク (フラグメント) が失われている場合があるため、クラッシュ後の再構築は、静的フォーマットテーブルよりも難しくなります。
          </p></li><li class="listitem"><p>
            動的サイズの行の予想される行長は、次の式で計算されます。
          </p><pre class="programlisting">
3
+ (<em class="replaceable"><code>number of columns</code></em> + 7) / 8
+ (<em class="replaceable"><code>number of char columns</code></em>)
+ (<em class="replaceable"><code>packed size of numeric columns</code></em>)
+ (<em class="replaceable"><code>length of strings</code></em>)
+ (<em class="replaceable"><code>number of NULL columns</code></em> + 7) / 8
</pre><p>
            それぞれのリンクには 6 バイトのペナルティーがあります。更新によって行が拡大される場合は、必ず動的行がリンクされます。新しいリンクはそれぞれ少なくとも 20 バイトであるため、おそらく次の拡張は同じリンクになります。そうでない場合、別のリンクが作成されます。<span class="command"><strong>myisamchk -ed</strong></span> を利用してリンク数を確認できます。<code class="literal">OPTIMIZE TABLE</code> または <span class="command"><strong>myisamchk -r</strong></span> を使用すると、すべてのリンクを削除できます。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="compressed-format"></a>15.2.3.3 圧縮テーブルの特徴</h4></div></div></div><a class="indexterm" name="idm139979059465088"></a><a class="indexterm" name="idm139979059462944"></a><a class="indexterm" name="idm139979059461584"></a><a class="indexterm" name="idm139979059459536"></a><p>
        圧縮ストレージフォーマットは、<span class="command"><strong>myisampack</strong></span> ツールで生成される読み取り専用のフォーマットです。圧縮テーブルは <span class="command"><strong>myisamchk</strong></span> を使って解凍できます。
      </p><p>
        圧縮テーブルには次のような特徴があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            圧縮テーブルに必要なディスク容量はごくわずかです。これによりディスクの使用量は最少になるため、低速のディスクを使用する場合に役立ちます (CD-ROM など)。
          </p></li><li class="listitem"><p>
            それぞれの行は個々に圧縮されるため、アクセスのオーバーヘッドはごくわずかです。行のヘッダーに必要なバイト数は、テーブル中の一番大きい行によって異なりますが、1 - 3 バイトです。各カラムは別々に圧縮されます。カラムごとに異なる Huffman ツリーがあるのが一般的です。圧縮タイプのいくつかは次のとおりです。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                サフィクススペース圧縮。
              </p></li><li class="listitem"><p>
                プリフィクススペース圧縮。
              </p></li><li class="listitem"><p>
                値が 0 の数値は 1 ビットで格納されます。
              </p></li><li class="listitem"><p>
                値の範囲が小さい整数カラムは、可能なかぎり小さな型を使って格納されます。たとえば、<code class="literal">BIGINT</code> カラム (8 バイト) のすべての値が <code class="literal">-128</code> から <code class="literal">127</code> の範囲内にある場合は、このカラムを <code class="literal">TINYINT</code> カラム (1 バイト) として格納できます。
              </p></li><li class="listitem"><p>
                カラムの可能値が少ない場合は、データの型を <code class="literal">ENUM</code>に変換します。
              </p></li><li class="listitem"><p>
                カラムに、上記の圧縮型を組み合わせて使用してもかまいません。
              </p></li></ul></div></li><li class="listitem"><p>
            固定長または動的長の行を使用できます。
          </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          圧縮テーブルは読み取り専用なので、テーブルの行を更新したり、行を追加したりはできませんが、DDL (データ定義言語) 操作は有効です。たとえば、<code class="literal">DROP</code> を使用してテーブルを削除しても、<code class="literal">TRUNCATE TABLE</code> を使用してテーブルを空にしてもかまいません。
        </p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="myisam-table-problems"></a>15.2.4 MyISAM テーブルの問題点</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="storage-engines.html#corrupted-myisam-tables">15.2.4.1 MyISAM テーブルの破損</a></span></dt><dt><span class="section"><a href="storage-engines.html#myisam-table-close">15.2.4.2 適切に閉じられなかったテーブルの問題</a></span></dt></dl></div><p>
      MySQL がデータの格納に使用するファイルフォーマットは幅広い検査を受けていますが、データベーステーブルの破損を招きかねない状況は常に存在します。次に、これがどのようにして起こるのか、またどのように対処すればよいのかについて説明します。
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="corrupted-myisam-tables"></a>15.2.4.1 MyISAM テーブルの破損</h4></div></div></div><p>
        <code class="literal">MyISAM</code> のテーブルフォーマットは、きわめて信頼性の高いフォーマットです (SQL ステートメントが行うテーブルに対するすべての変更は、そのステートメントが戻る前に書き込まれます) が、それでも次の状況が発生した場合、テーブルが破損するおそれがあります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <span class="command"><strong>mysqld</strong></span> プロセスは、書き込みの最中に強制終了されます。
          </p></li><li class="listitem"><p>
            コンピュータが予期せずシャットダウンされます (たとえば、コンピューターの電源が切られた場合など)。
          </p></li><li class="listitem"><p>
            ハードウェア障害。
          </p></li><li class="listitem"><p>
            サーバーが修正中のテーブルを、外部プログラム (<span class="command"><strong>myisamchk</strong></span>など) を使用して同時に修正しています。
          </p></li><li class="listitem"><p>
            MySQL または <code class="literal">MyISAM</code> コードのソフトウェアバグです。
          </p></li></ul></div><p>
        テーブルが破損した場合の典型的な兆候は、次のとおりです。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            テーブルからデータを選択するときに、次のエラーが表示されます。
          </p><pre class="programlisting">
Incorrect key file for table: '...'. Try to repair it
</pre></li><li class="listitem"><p>
            クエリーが、テーブル内で行を検出しない、または不完全な結果を返します。
          </p></li></ul></div><p>
        <code class="literal">MyISAM</code> テーブルのヘルスを <code class="literal">CHECK TABLE</code> ステートメントを利用して確認でき、破損した <code class="literal">MyISAM</code> テーブルを <code class="literal">REPAIR TABLE</code> を利用して修復できます。<span class="command"><strong>mysqld</strong></span> が動作していない場合は、<span class="command"><strong>myisamchk</strong></span> コマンドを利用してテーブルを確認したり修復したりすることもできます。<a class="xref" href="sql-syntax.html#check-table" title="13.7.2.2 CHECK TABLE 構文">セクション13.7.2.2「CHECK TABLE 構文」</a>、<a class="xref" href="sql-syntax.html#repair-table" title="13.7.2.5 REPAIR TABLE 構文">セクション13.7.2.5「REPAIR TABLE 構文」</a>、および <a class="xref" href="programs.html#myisamchk" title="4.6.3 myisamchk — MyISAM テーブルメンテナンスユーティリティー">セクション4.6.3「<span class="command"><strong>myisamchk</strong></span> — MyISAM テーブルメンテナンスユーティリティー」</a> を参照してください。
      </p><p>
        テーブルが頻繁に破損する場合は、その原因を突き止めるようにしてください。もっとも重要なのは、サーバーのクラッシュによってテーブルが破損されたかどうかを確認することです。エラーログの最新の <code class="literal">restarted mysqld</code> メッセージを探すと、簡単に検証できます。このようなメッセージがある場合、テーブルの破損はサーバーのダウンによる可能性が高くなります。そうでなければ、破損は通常作業の最中に起きた可能性があります。これはバグです。問題点を明らかにする再現可能なテストケースを作成するべきです。<a class="xref" href="error-handling.html#crashing" title="B.5.4.2 MySQL が繰り返しクラッシュする場合の対処方法">セクションB.5.4.2「MySQL が繰り返しクラッシュする場合の対処方法」</a>および <a class="xref" href="extending-mysql.html#porting" title="24.4 MySQL のデバッグおよび移植">セクション24.4「MySQL のデバッグおよび移植」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="myisam-table-close"></a>15.2.4.2 適切に閉じられなかったテーブルの問題</h4></div></div></div><p>
        各 <code class="literal">MyISAM</code> インデックスファイル (<code class="filename">.MYI</code> ファイル) には、テーブルが適切に閉じられたかどうかをチェックするために使用できるカウンタがヘッダーの中にあります。<code class="literal">CHECK TABLE</code> または <span class="command"><strong>myisamchk</strong></span> から次のような警告が表示された場合、このカウンタの同期が取れていないことを示しています。
      </p><pre class="programlisting">
clients are using or haven't closed the table properly
</pre><p>
        この警告は、必ずしもテーブルが破損されたという意味ではありませんが、少なくともテーブルを確認したほうがよいでしょう。
      </p><p>
        カウンターは次のように機能します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            MySQL でテーブルが最初に更新されるときに、インデックスファイルのヘッダー内にあるカウンタが増えます。
          </p></li><li class="listitem"><p>
            その後の更新ではカウンタは変更されません。
          </p></li><li class="listitem"><p>
            テーブルの最後のインスタンスが閉じられるとき (<code class="literal">FLUSH TABLES</code> 操作が行われたため、またはテーブルキャッシュの中に場所がないため) に、それまでにテーブルが更新されていると、カウンタの値が減少します。
          </p></li><li class="listitem"><p>
            テーブルを修復するか、チェックして問題がなかった場合は、カウンタがゼロにリセットされます。
          </p></li><li class="listitem"><p>
            テーブルを検査する可能性のあるほかのプロセスとの相互作用の問題を回避するため、カウンタがゼロである場合は、テーブルを閉じる際にカウンタの値は減りません。
          </p></li></ul></div><p>
        つまり、カウンタが不正確になる可能性があるのは、次のような場合だけです。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">MyISAM</code> テーブルのコピーが、最初に <code class="literal">LOCK TABLES</code> と <code class="literal">FLUSH TABLES</code> を発行しないで行われる。
          </p></li><li class="listitem"><p>
            MySQL が更新されてから閉じられるまでの間にクラッシュした。(ただし、MySQL は各ステートメントで生じたすべての書き込みを常に発行するため、テーブルに問題がない可能性もあります)。
          </p></li><li class="listitem"><p>
            <span class="command"><strong>mysqld</strong></span> と同時に使用した <span class="command"><strong>myisamchk --recover</strong></span> か <span class="command"><strong>myisamchk --update-state</strong></span> によって、テーブルが修正された。
          </p></li><li class="listitem"><p>
            別のサーバーによって使用されている最中に、複数の <span class="command"><strong>mysqld</strong></span> サーバーがテーブルを使用し、1 つのサーバーが <code class="literal">REPAIR TABLE</code> または <code class="literal">CHECK TABLE</code> をテーブルで実行した。このセットアップでは、ほかのサーバーから警告を受ける可能性がありますが、<code class="literal">CHECK TABLE</code> の使用が安全です。しかし、あるサーバーがデータファイルを新しいファイルに置き換えた場合、別のサーバーには通知されないため、<code class="literal">REPAIR TABLE</code> は避けるべきです。
          </p><p>
            一般的に、複数のサーバー間でデータディレクトリを共有することは推奨されません。追加情報については、<a class="xref" href="server-administration.html#multiple-servers" title="5.3 1 つのマシン上での複数の MySQL インスタンスの実行">セクション5.3「1 つのマシン上での複数の MySQL インスタンスの実行」</a>を参照してください。
          </p></li></ul></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="memory-storage-engine"></a>15.3 MEMORY ストレージエンジン</h2></div></div></div><a class="indexterm" name="idm139979059375664"></a><a class="indexterm" name="idm139979059374176"></a><a class="indexterm" name="idm139979059372768"></a><a class="indexterm" name="idm139979059370848"></a><p>
    <code class="literal">MEMORY</code> ストレージエンジン (従来は <code class="literal">HEAP</code> と呼ばれていました) は、メモリーに格納された内容で特定用途のテーブルを作成します。データは、クラッシュ、ハードウェア問題、または電源停止に弱いため、これらのテーブルは、一時的な作業領域またはほかのテーブルから抽出されたデータの読み取り専用キャッシュとして使用されるだけです。
  </p><div class="table"><a name="idm139979059366336"></a><p class="title"><b>表 15.4 <code class="literal">MEMORY</code> ストレージエンジンの機能</b></p><div class="table-contents"><table summary="MEMORY ストレージエンジンの機能" border="1"><colgroup><col class="featurev0"><col class="featurevalue0"><col class="featurev1"><col class="featurevalue1"><col class="featurev2"><col class="featurevalue2"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>ストレージの制限</strong></span></td><td>RAM</td><td><span class="bold"><strong>トランザクション</strong></span></td><td>いいえ</td><td><span class="bold"><strong>ロック粒度</strong></span></td><td>テーブル</td></tr><tr><td scope="row"><span class="bold"><strong>MVCC</strong></span></td><td>いいえ</td><td><span class="bold"><strong>地理空間データ型のサポート</strong></span></td><td>いいえ</td><td><span class="bold"><strong>地理空間インデックスのサポート</strong></span></td><td>いいえ</td></tr><tr><td scope="row"><span class="bold"><strong>B ツリーインデックス</strong></span></td><td>はい</td><td><span class="bold"><strong>T ツリーインデックス</strong></span></td><td>いいえ</td><td><span class="bold"><strong>ハッシュインデックス</strong></span></td><td>はい</td></tr><tr><td scope="row"><span class="bold"><strong>全文検索インデックス</strong></span></td><td>いいえ</td><td><span class="bold"><strong>クラスタ化されたインデックス</strong></span></td><td>いいえ</td><td><span class="bold"><strong>データキャッシュ</strong></span></td><td>N/A</td></tr><tr><td scope="row"><span class="bold"><strong>インデックスキャッシュ</strong></span></td><td>N/A</td><td><span class="bold"><strong>圧縮データ</strong></span></td><td>いいえ</td><td><span class="bold"><strong>暗号化データ<a href="#ftn.idm139979059342080" class="footnote" name="idm139979059342080"><sup class="footnote">[a]</sup></a></strong></span></td><td>はい</td></tr><tr><td scope="row"><span class="bold"><strong>クラスタデータベースのサポート</strong></span></td><td>いいえ</td><td><span class="bold"><strong>レプリケーションのサポート<a href="#ftn.idm139979059338928" class="footnote" name="idm139979059338928"><sup class="footnote">[b]</sup></a></strong></span></td><td>はい</td><td><span class="bold"><strong>外部キーのサポート</strong></span></td><td>いいえ</td></tr><tr><td scope="row"><span class="bold"><strong>バックアップ/ポイントインタイムリカバリ<a href="#ftn.idm139979059335792" class="footnote" name="idm139979059335792"><sup class="footnote">[c]</sup></a></strong></span></td><td>はい</td><td><span class="bold"><strong>クエリーキャッシュのサポート</strong></span></td><td>はい</td><td><span class="bold"><strong>データディクショナリ向け更新統計</strong></span></td><td>はい</td></tr></tbody><tbody class="footnotes"><tr><td colspan="6"><div id="ftn.idm139979059342080" class="footnote"><p><a href="#idm139979059342080" class="para"><sup class="para">[a] </sup></a>ストレージエンジン内ではなくサーバー内で (暗号化関数を使って) 実装されています。</p></div><div id="ftn.idm139979059338928" class="footnote"><p><a href="#idm139979059338928" class="para"><sup class="para">[b] </sup></a>ストレージエンジン内ではなくサーバー内で実装されています。</p></div><div id="ftn.idm139979059335792" class="footnote"><p><a href="#idm139979059335792" class="para"><sup class="para">[c] </sup></a>ストレージエンジン内ではなくサーバー内で実装されています。</p></div></td></tr></tbody></table></div></div><br class="table-break"><p><a name="memory-compared-cluster"></a><b>MEMORY または MySQL Cluster を使用する場合 </b>
      重要で更新頻度の高い高可用性のデータに対して <code class="literal">MEMORY</code> ストレージエンジンを使用するアプリケーションを配備しようとする開発者は、MySQL Cluster がより良い選択かどうかを検討するはずです。<code class="literal">MEMORY</code> エンジンの典型的なユースケースには、次の特徴があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        セッション管理やキャッシングなどの一時的で重要でないデータに関連する操作。MySQL サーバーが停止または再起動したときに、<code class="literal">MEMORY</code> テーブルのデータは失われます。
      </p></li><li class="listitem"><p>
        高速アクセスおよび低待機時間のためのインメモリー保存。データボリュームはメモリー内に完全に収まり、オペレーティングシステムによる仮想メモリーページのスワップアウトはありません。
      </p></li><li class="listitem"><p>
        読み取り専用または読み取りが大半のデータのアクセスパターン (更新が制限されています)。
      </p></li></ul></div><p>
    MySQL Cluster は、<code class="literal">MEMORY</code> エンジンと同じ機能をより高いパフォーマンスレベルで提供し、<code class="literal">MEMORY</code> で利用できない追加機能を提供します。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        クライアント間で競合の少ない行レベルロックとマルチスレッド操作。
      </p></li><li class="listitem"><p>
        書き込みを含むステートメント混在時の拡張性。
      </p></li><li class="listitem"><p>
        データ持続性のためのディスクバックアップ式操作 (オプション)。
      </p></li><li class="listitem"><p>
        単一障害点がない、シェアードナッシングアーキテクチャーと複数ホスト操作。99.999% の可用性を実現できます。
      </p></li><li class="listitem"><p>
        ノードをまたがる自動データ分散。アプリケーションの開発者はカスタムの共有またはパーティション化ソリューションを作る必要がありません。
      </p></li><li class="listitem"><p>
        可変長データ型 (<code class="literal">MEMORY</code> がサポートしない <code class="literal">BLOB</code> および <code class="literal">TEXT</code> を含みます) をサポートします。
      </p></li></ul></div><p>
    <code class="literal">MEMORY</code> ストレージエンジンと MySQL Cluster の詳細な比較に関するホワイトペーパーについては、<a class="ulink" href="http://www.mysql.com/why-mysql/white-papers/mysql-wp_cluster-7.0_Cluster_MEMORY.php" target="_top">MySQL Cluster による Web サービスの拡張: MySQL Memory ストレージエンジンの代替</a>を参照してください。このホワイトペーパーには、2 つの技術のパフォーマンス調査と、既存の <code class="literal">MEMORY</code> ユーザーが MySQL Cluster にどのように移行できるかについて説明するステップバイステップガイドが含まれています。
  </p><h3><a name="idm139979059308496"></a>パフォーマンスの特徴</h3><p>
    <code class="literal">MEMORY</code> のパフォーマンスは、更新処理時のシングルスレッド実行とテーブルロックオーバーヘッドが原因の競合によって抑制されます。このため、負荷が増えたときに拡張性が制限されます (特に、書き込みを含むステートメント混在時)。
  </p><p>
    <code class="literal">MEMORY</code> テーブルのインメモリー処理にかかわらず、それらは、汎用目的クエリーのために、または読み取り/書き込み負荷では、必ずしもビジーサーバーの <code class="literal">InnoDB</code> テーブルより高速である必要はありません。特に、更新実行に関与するテーブルロックは、複数セッションからの <code class="literal">MEMORY</code> テーブルの並列使用の速度を低下させる可能性があります。
  </p><p>
    <code class="literal">MEMORY</code> テーブルで実行されるクエリーの種類によっては、デフォルトのハッシュデータ構造 (一意キーで 1 つの値を検索する場合)、または汎用目的の B ツリーデータ構造 (等号、不等号、未満または「- を超える」などの範囲演算子などを含むすべての種類のクエリーの場合) のいずれかとしてインデックスを作成する場合があります。次のセクションでは、両方の種類のインデックスを作成するための構文について説明します。パフォーマンス面でよくある問題は、B ツリーインデックスがより効率的な作業負荷で、デフォルトのハッシュインデックスを使用していることです。
  </p><h3><a name="idm139979059299824"></a>MEMORY テーブルの物理特性</h3><p>
    <code class="literal">MEMORY</code> ストレージエンジンは、各テーブルと 1 つのディスクファイル (テーブルの定義を格納 (データではありません)) を関連付けます。ファイル名はテーブル名から始まり、<code class="filename">.frm</code> 拡張子が付きます。
  </p><p>
    <code class="literal">MEMORY</code> テーブルには次のような特徴があります。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="literal">MEMORY</code> テーブルの領域は小さなブロックに割り当てられます。テーブルは、挿入に 100% 動的ハッシュを使用します。オーバーフロー領域や余分なキー領域は必要ありません。フリーリスト用の余分な領域は必要ありません。削除された行はリンクリストに置かれ、新しいデータをテーブルに挿入するときに再利用されます。<code class="literal">MEMORY</code> テーブルでは、ハッシュテーブルで一般的に削除 + 挿入に関連付けられる問題も起こりません。
      </p></li><li class="listitem"><p>
        <code class="literal">MEMORY</code> テーブルは固定長の行ストレージフォーマットを使用します。<code class="literal">VARCHAR</code> などの可変長型は、固定長を使用して格納されます。
      </p></li><li class="listitem"><p>
        <code class="literal">MEMORY</code> テーブルは <code class="literal">BLOB</code> または <code class="literal">TEXT</code> カラムを含むことができません。
      </p></li><li class="listitem"><p>
        <code class="literal">MEMORY</code> は <code class="literal">AUTO_INCREMENT</code> カラムのサポートを含みます。
      </p></li><li class="listitem"><p>
        <code class="literal">TEMPORARY</code> <code class="literal">MEMORY</code> でないテーブルは、ほかの <code class="literal">TEMPORARY</code> でないテーブルと同様に、すべてのクライアントで共有されます。
      </p></li></ul></div><h3><a name="idm139979059280320"></a>MEMORY テーブルへの DDL 操作</h3><p>
    <code class="literal">MEMORY</code> テーブルを作成するには、<code class="literal">CREATE TABLE</code> ステートメントで <code class="literal">ENGINE=MEMORY</code> 句を指定します。
  </p><pre class="programlisting">
CREATE TABLE t (i INT) ENGINE = MEMORY;
</pre><p>
    エンジンの名前が表すように、<code class="literal">MEMORY</code> テーブルはメモリーに格納されます。デフォルトではハッシュインデックスを使用するため、単一値の検索には非常に高速であり、一時テーブルの作成には非常に役立ちます。ただし、サーバーがシャットダウンすると、<code class="literal">MEMORY</code> テーブルに格納されたすべての行が失われます。テーブルの定義はディスク上の <code class="filename">.frm</code> ファイルに格納されているため、テーブル自体は引き続き存在しますが、サーバーが再起動したときにテーブルは空になります。
  </p><p>
    この例は、<code class="literal">MEMORY</code> テーブルをどのように作成、使用、および削除できるかを示しています。
  </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE test ENGINE=MEMORY</code></strong>
    -&gt;     <strong class="userinput"><code>SELECT ip,SUM(downloads) AS down</code></strong>
    -&gt;     <strong class="userinput"><code>FROM log_table GROUP BY ip;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT COUNT(ip),AVG(down) FROM test;</code></strong>
mysql&gt; <strong class="userinput"><code>DROP TABLE test;</code></strong>
</pre><p>
    <code class="literal">MEMORY</code> テーブルの最大サイズは <code class="literal">max_heap_table_size</code> システム変数によって制限されます (デフォルト値は 16M バイト)。<code class="literal">MEMORY</code> テーブルに異なるサイズ制限を適用するには、この変数値を変更します。<code class="literal">CREATE TABLE</code>、それに続く <code class="literal">ALTER TABLE</code> または <code class="literal">TRUNCATE TABLE</code> の実質的な値は、テーブルの有効期限に使用される値です。サーバーを再起動しても、既存の <code class="literal">MEMORY</code> テーブルの最大サイズがグローバルの <code class="literal">max_heap_table_size</code> 値に設定されます。各テーブルのサイズをこのセクションの後半で説明するように設定できます。
  </p><h3><a name="idm139979059257920"></a>インデックス</h3><p>
    <code class="literal">MEMORY</code> ストレージエンジンは <code class="literal">HASH</code> と <code class="literal">BTREE</code> の両方のインデックスをサポートしています。ここに示すように <code class="literal">USING</code> 句を追加することによりどちらであるかを指定できます。
  </p><pre class="programlisting">
CREATE TABLE lookup
    (id INT, INDEX USING HASH (id))
    ENGINE = MEMORY;
CREATE TABLE lookup
    (id INT, INDEX USING BTREE (id))
    ENGINE = MEMORY;
</pre><p>
    B ツリーとハッシュインデックスの一般的な特徴については、<a class="xref" href="optimization.html#mysql-indexes" title="8.3.1 MySQL のインデックスの使用の仕組み">セクション8.3.1「MySQL のインデックスの使用の仕組み」</a>を参照してください。
  </p><p>
    <code class="literal">MEMORY</code> テーブルでは、テーブル当たり最大で 64 個のインデックス、インデックス当たり 16 個のカラム、3072 バイトの最大キー長を持つことができます。
  </p><p>
    <code class="literal">MEMORY</code> テーブルのハッシュインデックスでキーの重複の程度が高いと (同じ値を含むインデックスエントリが多い)、キー値に影響を与えるテーブルへの更新処理とすべての削除処理の速度が大きく低下します。この低下の程度は重複の程度に比例します (または、インデックスカーディナリティーに反比例します)。<code class="literal">BTREE</code> インデックスを使用することで、この問題を回避できます。
  </p><p>
    <code class="literal">MEMORY</code> テーブルには、非一意キーを持つことができます。(これは、ハッシュインデックスの実装ではまれな特徴です。)
  </p><p>
    インデックスが付けられたカラムに <code class="literal">NULL</code> 値を含むことができます。
  </p><h3><a name="idm139979059244752"></a>ユーザー作成の一時テーブル</h3><p>
    <code class="literal">MEMORY</code> テーブルの内容はメモリーに格納されます。これは <code class="literal">MEMORY</code> テーブルが、クエリーの処理中にその場でサーバーが作成する内部一時テーブルと共有する特性です。ただし、2 つのタイプのテーブルには違いがあり、<code class="literal">MEMORY</code> テーブルはストレージ変換の影響を受けませんが、内部一時テーブルは次のような影響があります。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        内部一時テーブルが大きくなりすぎると、<a class="xref" href="optimization.html#internal-temporary-tables" title="8.4.4 MySQL が内部一時テーブルを使用する仕組み">セクション8.4.4「MySQL が内部一時テーブルを使用する仕組み」</a>で説明したように、サーバーは自動的にオンディスクストレージに変換します。
      </p></li><li class="listitem"><p>
        ユーザー作成の <code class="literal">MEMORY</code> テーブルは、決してディスクテーブルに変換されません。
      </p></li></ul></div><h3><a name="idm139979059236832"></a>データのロード</h3><p>
    MySQL サーバーの起動時に <code class="literal">MEMORY</code> テーブルを移入するには、<code class="option">--init-file</code> オプションを使用できます。たとえば、このファイルで <code class="literal">INSERT INTO ... SELECT</code> や <code class="literal">LOAD DATA INFILE</code> などのステートメントを実行することで、永続データソースからテーブルをロードできます。<a class="xref" href="server-administration.html#server-options" title="5.1.3 サーバーコマンドオプション">セクション5.1.3「サーバーコマンドオプション」</a>および<a class="xref" href="sql-syntax.html#load-data" title="13.2.6 LOAD DATA INFILE 構文">セクション13.2.6「LOAD DATA INFILE 構文」</a>を参照してください。
  </p><p>
    同時に別のセッションでアクセスされた <code class="literal">MEMORY</code> テーブルにデータをロードするため、<code class="literal">MEMORY</code> は <code class="literal">INSERT DELAYED</code> をサポートしています。<a class="xref" href="sql-syntax.html#insert-delayed" title="13.2.5.2 INSERT DELAYED 構文">セクション13.2.5.2「INSERT DELAYED 構文」</a>を参照してください。
  </p><h3><a name="idm139979059226112"></a>MEMORY テーブルとレプリケーション</h3><p>
    サーバーの <code class="literal">MEMORY</code> テーブルは、シャットダウンされて再起動されたときに空になります。サーバーがレプリケーションマスターの場合は、そのスレーブはこれらのテーブルが空になったことを認識しないため、スレーブのテーブルからデータを選択した場合に内容が古いことがわかります。マスターとスレーブの <code class="literal">MEMORY</code> テーブルの同期を取るため、<code class="literal">MEMORY</code> テーブルが起動してからマスター側で最初に使用されたときに、スレーブ側でもテーブルを空にするため、<code class="literal">DELETE</code> ステートメントがマスターのバイナリログに書かれます。スレーブでは、マスターの再起動とテーブルの最初の使用までの間は、テーブルのデータが古いままです。スレーブへの直接クエリーが古いデータを戻す可能性があるこの期間を避けるには、<code class="option">--init-file</code> オプションを使用して起動時にマスター上の <code class="literal">MEMORY</code> テーブルを移入してください。
  </p><h3><a name="idm139979059218592"></a>メモリー使用量の管理</h3><p>
    サーバーには、同時に使用されるすべての <code class="literal">MEMORY</code> テーブルを保持するための十分なメモリーが必要です。
  </p><p>
    <code class="literal">MEMORY</code> テーブルから各行を削除しても、メモリーは再利用されません。テーブル全体が削除された場合にのみ、メモリーが再利用されます。削除された行に以前に使用されたメモリーは同じテーブル内の新しい行に再利用されます。<code class="literal">MEMORY</code> テーブルの内容が必要でなくなったときに、それが使用していたすべてのメモリーを解放するには、<code class="literal">DELETE</code> または <code class="literal">TRUNCATE TABLE</code> を実行してすべての行を削除するか、<code class="literal">DROP TABLE</code> を使用してテーブルを完全に削除します。削除された行が使用していたメモリーを解放するには、<code class="literal">ALTER TABLE ENGINE=MEMORY</code> を使用してテーブルを強制的に再作成します。
  </p><p>
    <code class="literal">MEMORY</code> テーブルで 1 つの行に必要なメモリーは、次の式で計算されます。
  </p><pre class="programlisting">
SUM_OVER_ALL_BTREE_KEYS(<em class="replaceable"><code>max_length_of_key</code></em> + sizeof(char*) * 4)
+ SUM_OVER_ALL_HASH_KEYS(sizeof(char*) * 2)
+ ALIGN(<em class="replaceable"><code>length_of_row</code></em>+1, sizeof(char*))
</pre><p>
    <code class="literal">ALIGN()</code> は行の長さを <code class="literal">char</code> ポインタサイズのちょうど倍数にするための切り上げ係数を表します。<code class="literal">sizeof(char*)</code> は 32 ビットマシンでは 4、64 ビットマシンでは 8 です。
  </p><p>
    前に述べたように、<code class="literal">max_heap_table_size</code> システム変数は <code class="literal">MEMORY</code> テーブルの最大サイズの制限値を設定します。各テーブルの最大サイズを制御するには、各テーブルを作成する前に、この変数のセッション値を設定します。(すべてのクライアントが作成した <code class="literal">MEMORY</code> テーブルに、グローバル <code class="literal">max_heap_table_size</code> 値を使用するのでなければ、この値を変更しないでください。)次は、2 つの <code class="literal">MEMORY</code> テーブル (最大サイズがそれぞれ 1M バイトと 2M バイト) を作成する例です。
  </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET max_heap_table_size = 1024*1024;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (id INT, UNIQUE(id)) ENGINE = MEMORY;</code></strong>
Query OK, 0 rows affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>SET max_heap_table_size = 1024*1024*2;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>CREATE TABLE t2 (id INT, UNIQUE(id)) ENGINE = MEMORY;</code></strong>
Query OK, 0 rows affected (0.00 sec)
</pre><p>
    両方のテーブルは、サーバーが再起動した場合、サーバーのグローバル <code class="literal">max_heap_table_size</code> 値に戻ります。
  </p><p>
    <code class="literal">MEMORY</code> テーブルに対して <code class="literal">CREATE TABLE</code> ステートメントの <code class="literal">MAX_ROWS</code> テーブルオプションを指定して、テーブルに格納する予定の行数に関するヒントを提供することもできます。これによって <code class="literal">max_heap_table_size</code> 値 (引き続き最大テーブルサイズの制約として機能) を超えてテーブルが拡大できなくなります。<code class="literal">MAX_ROWS</code> を使用できるだけの最大限の柔軟性を得るには、少なくとも各 <code class="literal">MEMORY</code> テーブルが拡大できる値程度に <code class="literal">max_heap_table_size</code> を設定してください。
  </p><h3><a name="idm139979059185504"></a>追加のリソース</h3><p>
    <code class="literal">MEMORY</code> ストレージエンジンに特化したフォーラムは、<a class="ulink" href="http://forums.mysql.com/list.php?92" target="_top">http://forums.mysql.com/list.php?92</a>で参照できます。
  </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="csv-storage-engine"></a>15.4 CSV ストレージエンジン</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="storage-engines.html#se-csv-repair">15.4.1 CSV テーブルの修復と確認</a></span></dt><dt><span class="section"><a href="storage-engines.html#se-csv-limitations">15.4.2 CSV の制限</a></span></dt></dl></div><a class="indexterm" name="idm139979059181808"></a><a class="indexterm" name="idm139979059180320"></a><p>
    <code class="literal">CSV</code> ストレージエンジンは、カンマ区切り値形式を使用してデータをテキストファイルに保存します。
  </p><p>
    <code class="literal">CSV</code> ストレージエンジンは、常に MySQL サーバーにコンパイルされます。
  </p><p>
    <code class="literal">CSV</code> エンジンのソースを調べるには、MySQL ソース配布の <code class="filename">storage/csv</code> ディレクトリを検索します。
  </p><p>
    <code class="literal">CSV</code> テーブルを作成するときに、サーバーはデータベースディレクトリにテーブル形式ファイルを作成します。ファイルはテーブル名から始まり <code class="filename">.frm</code> 拡張子が付きます。ストレージエンジンはデータファイルも作成します。その名前はテーブル名で始まり <code class="filename">.CSV</code> 拡張子を持ちます。データファイルはプレーンテキストファイルです。データをテーブルに保存するとき、ストレージエンジンはデータファイルにカンマ区切り値形式で保存します。
  </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE test (i INT NOT NULL, c CHAR(10) NOT NULL)</code></strong>
    -&gt; <strong class="userinput"><code>ENGINE = CSV;</code></strong>
Query OK, 0 rows affected (0.12 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO test VALUES(1,'record one'),(2,'record two');</code></strong>
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT * FROM test;</code></strong>
+------+------------+
| i    | c          |
+------+------------+
|    1 | record one |
|    2 | record two |
+------+------------+
2 rows in set (0.00 sec)
</pre><p>
    CSV テーブルを作成すると、テーブルの状態とテーブルに存在する行数を格納する、対応するメタファイルが作成されます。このファイルの名前は <code class="filename">CSM</code> 拡張子のついたテーブル名と同じです。
  </p><p>
    前のステートメントの実行で作成されたデータベースディレクトリにある <code class="filename">test.CSV</code> ファイルを調べると、その内容は次のようであるはずです。
  </p><pre class="programlisting">
"1","record one"
"2","record two"
</pre><p>
    この形式は、Microsoft Excel や StarOffice Calc などのスプレッドシートアプリケーションで読み取ったり書き込んだりできます。
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="se-csv-repair"></a>15.4.1 CSV テーブルの修復と確認</h3></div></div></div><p>
      CSV ストレージエンジンは、CSV テーブルを検証したり、可能な場合は壊れた CSV テーブルを修復したりする <code class="literal">CHECK</code> および <code class="literal">REPAIR</code> ステートメントをサポートしています。
    </p><p>
      <code class="literal">CHECK</code> ステートメントを実行すると、正しいフィールドセパレータ、エスケープされたフィールド (引用符の対応または不足)、正しいフィールド数 (テーブル定義と比較)、および対応する CSV メタファイルの存在を探すことで、CSV ファイルの有効性がチェックされます。検出された最初の不正な行はエラーを報告します。有効なテーブルをチェックすると、次のような出力が生成されます。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>check table csvtest;</code></strong>
+--------------+-------+----------+----------+
| Table        | Op    | Msg_type | Msg_text |
+--------------+-------+----------+----------+
| test.csvtest | check | status   | OK       |
+--------------+-------+----------+----------+
1 row in set (0.00 sec)</pre><p>
      壊れたデータをチェックすると、障害が返ります。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>check table csvtest;</code></strong>
+--------------+-------+----------+----------+
| Table        | Op    | Msg_type | Msg_text |
+--------------+-------+----------+----------+
| test.csvtest | check | error    | Corrupt  |
+--------------+-------+----------+----------+
1 row in set (0.01 sec)</pre><p>
      チェックが失敗した場合、テーブルはクラッシュ (破損) とマークされます。テーブルが破損とマークされると、次に <code class="literal">CHECK</code> を実行したときや <code class="literal">SELECT</code> ステートメントを実行したときに自動的に修復されます。対応する破損ステータスや新しいステータスは、<code class="literal">CHECK</code>を実行したときに表示されます。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>check table csvtest;</code></strong>
+--------------+-------+----------+----------------------------+
| Table        | Op    | Msg_type | Msg_text                   |
+--------------+-------+----------+----------------------------+
| test.csvtest | check | warning  | Table is marked as crashed |
| test.csvtest | check | status   | OK                         |
+--------------+-------+----------+----------------------------+
2 rows in set (0.08 sec)</pre><p>
      テーブルを修正するために <code class="literal">REPAIR</code> を使用できます。これは既存の CSV データからできるだけ多くの有効な行をコピーしてから、既存の CSV ファイルをリカバリされた行で置き換えます。破損したデータ以降のすべての行は失われます。
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>repair table csvtest;</code></strong>
+--------------+--------+----------+----------+
| Table        | Op     | Msg_type | Msg_text |
+--------------+--------+----------+----------+
| test.csvtest | repair | status   | OK       |
+--------------+--------+----------+----------+
1 row in set (0.02 sec)</pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
        修復時、破損した最初の行までの CSV ファイルの行だけが新しいテーブルにコピーされます。破損した最初の行からテーブルの最後までのほかのすべての行は、有効な行であっても削除されます。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="se-csv-limitations"></a>15.4.2 CSV の制限</h3></div></div></div><p>
      <code class="literal">CSV</code> ストレージエンジンはインデックスをサポートしていません。
    </p><p>
      パーティション化は、<code class="literal">CSV</code> ストレージエンジンを使ったテーブルではサポートされていません。
    </p><p>
      <code class="literal">CSV</code> ストレージエンジンを使用して作成したすべてのテーブルには、すべてのカラムに <code class="literal">NOT NULL</code> 属性が必要です。ただし、下位互換性のため、以前の MySQL リリースで作成した、null許容カラムを持つテーブルを引き続き使用できます。(Bug #32050)
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="archive-storage-engine"></a>15.5 ARCHIVE ストレージエンジン</h2></div></div></div><a class="indexterm" name="idm139979059135008"></a><a class="indexterm" name="idm139979059133520"></a><p>
    <code class="literal">ARCHIVE</code> ストレージエンジンは、非常に小さなフットプリントに大量のインデックス化されていないデータを格納する、特別な目的のテーブルを作成します。
  </p><div class="table"><a name="idm139979059130016"></a><p class="title"><b>表 15.5 <code class="literal">ARCHIVE</code> ストレージエンジンの機能</b></p><div class="table-contents"><table summary="ARCHIVE ストレージエンジンの機能" border="1"><colgroup><col class="featurev0"><col class="featurevalue0"><col class="featurev1"><col class="featurevalue1"><col class="featurev2"><col class="featurevalue2"></colgroup><tbody><tr><td scope="row"><span class="bold"><strong>ストレージの制限</strong></span></td><td>なし</td><td><span class="bold"><strong>トランザクション</strong></span></td><td>いいえ</td><td><span class="bold"><strong>ロック粒度</strong></span></td><td>テーブル</td></tr><tr><td scope="row"><span class="bold"><strong>MVCC</strong></span></td><td>いいえ</td><td><span class="bold"><strong>地理空間データ型のサポート</strong></span></td><td>はい</td><td><span class="bold"><strong>地理空間インデックスのサポート</strong></span></td><td>いいえ</td></tr><tr><td scope="row"><span class="bold"><strong>B ツリーインデックス</strong></span></td><td>いいえ</td><td><span class="bold"><strong>T ツリーインデックス</strong></span></td><td>いいえ</td><td><span class="bold"><strong>ハッシュインデックス</strong></span></td><td>いいえ</td></tr><tr><td scope="row"><span class="bold"><strong>全文検索インデックス</strong></span></td><td>いいえ</td><td><span class="bold"><strong>クラスタ化されたインデックス</strong></span></td><td>いいえ</td><td><span class="bold"><strong>データキャッシュ</strong></span></td><td>いいえ</td></tr><tr><td scope="row"><span class="bold"><strong>インデックスキャッシュ</strong></span></td><td>いいえ</td><td><span class="bold"><strong>圧縮データ</strong></span></td><td>はい</td><td><span class="bold"><strong>暗号化データ<a href="#ftn.idm139979059105664" class="footnote" name="idm139979059105664"><sup class="footnote">[a]</sup></a></strong></span></td><td>はい</td></tr><tr><td scope="row"><span class="bold"><strong>クラスタデータベースのサポート</strong></span></td><td>いいえ</td><td><span class="bold"><strong>レプリケーションのサポート<a href="#ftn.idm139979059102512" class="footnote" name="idm139979059102512"><sup class="footnote">[b]</sup></a></strong></span></td><td>はい</td><td><span class="bold"><strong>外部キーのサポート</strong></span></td><td>いいえ</td></tr><tr><td scope="row"><span class="bold"><strong>バックアップ/ポイントインタイムリカバリ<a href="#ftn.idm139979059099376" class="footnote" name="idm139979059099376"><sup class="footnote">[c]</sup></a></strong></span></td><td>はい</td><td><span class="bold"><strong>クエリーキャッシュのサポート</strong></span></td><td>はい</td><td><span class="bold"><strong>データディクショナリ向け更新統計</strong></span></td><td>はい</td></tr></tbody><tbody class="footnotes"><tr><td colspan="6"><div id="ftn.idm139979059105664" class="footnote"><p><a href="#idm139979059105664" class="para"><sup class="para">[a] </sup></a>ストレージエンジン内ではなくサーバー内で (暗号化関数を使って) 実装されています。</p></div><div id="ftn.idm139979059102512" class="footnote"><p><a href="#idm139979059102512" class="para"><sup class="para">[b] </sup></a>ストレージエンジン内ではなくサーバー内で実装されています。</p></div><div id="ftn.idm139979059099376" class="footnote"><p><a href="#idm139979059099376" class="para"><sup class="para">[c] </sup></a>ストレージエンジン内ではなくサーバー内で実装されています。</p></div></td></tr></tbody></table></div></div><br class="table-break"><p>
    <code class="literal">ARCHIVE</code> ストレージエンジンは MySQL バイナリ配布に含まれています。ソースから MySQL を構築する場合にこのストレージエンジンを有効にするには、<span class="command"><strong>CMake</strong></span> を <code class="option">-DWITH_ARCHIVE_STORAGE_ENGINE</code> オプションで呼び出します。
  </p><p>
    <code class="literal">ARCHIVE</code> エンジンのソースを調べるには、MySQL ソース配布の <code class="filename">storage/archive</code> ディレクトリを検索します。
  </p><p>
    <code class="literal">ARCHIVE</code> ストレージエンジンが <code class="literal">SHOW ENGINES</code> ステートメントで使用できるかどうかを確認できます。
  </p><p>
    <code class="literal">ARCHIVE</code> テーブルを作成するときに、サーバーはデータベースディレクトリにテーブル形式ファイルを作成します。ファイルはテーブル名から始まり <code class="filename">.frm</code> 拡張子が付きます。ストレージエンジンはほかのファイルを作成します。そのすべてのファイル名はテーブル名で始まります。データファイルの拡張子は <code class="filename">.ARZ</code> です。最適化操作中に <code class="filename">.ARN</code> ファイルが現れる場合があります。
  </p><p>
    <code class="literal">ARCHIVE</code> エンジンは <code class="literal">INSERT</code> と <code class="literal">SELECT</code> をサポートしていますが、<code class="literal">DELETE</code>、<code class="literal">REPLACE</code>、または <code class="literal">UPDATE</code> をサポートしていません。<code class="literal">ORDER BY</code> 操作、<code class="literal">BLOB</code> カラム、基本的に空間データ型を除くすべてのデータ型をサポートしています (<a class="xref" href="data-types.html#spatial-datatypes" title="11.5.1 空間データ型">セクション11.5.1「空間データ型」</a>を参照してください)。<code class="literal">ARCHIVE</code> エンジンは低レベルロックを使用します。
  </p><p>
    <code class="literal">ARCHIVE</code> エンジンは <code class="literal">AUTO_INCREMENT</code> カラム属性をサポートしています。<code class="literal">AUTO_INCREMENT</code> カラムには、一意のインデックスまたは一意でないインデックスのどちらかを付けることができます。ほかのカラムにインデックスを作成しようとすると、エラーになります。<code class="literal">ARCHIVE</code> エンジンは、それぞれ、新しいテーブルの最初のシーケンス値を指定したり、既存テーブルのシーケンス値をリセットしたりする <code class="literal">CREATE TABLE</code> ステートメントの <code class="literal">AUTO_INCREMENT</code> テーブルオプションもサポートしています。
  </p><p>
    <code class="literal">ARCHIVE</code> は、現在の最大カラム値未満の値を <code class="literal">AUTO_INCREMENT</code> カラムに挿入する機能をサポートしていません。そのようにしようとすると、<code class="literal">ER_DUP_KEY</code> エラーになります。
  </p><p>
    <code class="literal">ARCHIVE</code> エンジンは <code class="literal">BLOB</code> カラムが要求されない場合はそれらを無視して、読み取り中にそれらを通り過ぎてスキャンします。
  </p><p>
    <span class="bold"><strong>ストレージ:</strong></span> 行は挿入されるときに圧縮されます。<code class="literal">ARCHIVE</code> エンジンは <code class="literal">zlib</code> ロスレスデータ圧縮を使用します (<a class="ulink" href="http://www.zlib.net/" target="_top">http://www.zlib.net/</a>を参照してください)。<code class="literal">OPTIMIZE TABLE</code> を使用してテーブルを解析したり、より小さいフォーマットにテーブルを圧縮したりできます (<code class="literal">OPTIMIZE TABLE</code> を利用する理由については、このセクションの後半を参照して下さい)。このエンジンは <code class="literal">CHECK TABLE</code>もサポートしています。使用される挿入のタイプはいくつかあります。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="literal">INSERT</code> ステートメントは行を圧縮バッファーに単純に入れ、バッファーは必要に応じてフラッシュします。バッファーへの挿入はロックで保護されています。<code class="literal">SELECT</code> は、入ってきた挿入が <code class="literal">INSERT DELAYED</code> (必要に応じてフラッシュ) だけだった場合を除いて、強制的にフラッシュを発生させます。<a class="xref" href="sql-syntax.html#insert-delayed" title="13.2.5.2 INSERT DELAYED 構文">セクション13.2.5.2「INSERT DELAYED 構文」</a>を参照してください。
      </p></li><li class="listitem"><p>
        大量挿入は、ほかの挿入が同時に発生した場合を除いて (その場合は部分的に可視になります)、完了後にのみ可視になります。<code class="literal">SELECT</code> は、ロード中に通常の挿入が発生した場合を除いて、大量挿入をフラッシュすることはありません。
      </p></li></ul></div><p>
    <span class="bold"><strong>取り出し</strong></span>: 取り出しの際、要求によって行が圧縮解除され、行キャッシュはありません。<code class="literal">SELECT</code> 操作によって完全なテーブルスキャンが実行されます。<code class="literal">SELECT</code> が発生すると、現在使用できる行数を検出し、その行数を読み取ります。<code class="literal">SELECT</code> は一貫性読み取りとして実行されます。大量挿入または遅延挿入だけが使用された場合を除き、挿入時の多くの <code class="literal">SELECT</code> ステートメントが圧縮品質を低下させることがあります。圧縮品質を高めるために、<code class="literal">OPTIMIZE TABLE</code> または <code class="literal">REPAIR TABLE</code> を使用できます。<code class="literal">SHOW TABLE STATUS</code> によって報告される <code class="literal">ARCHIVE</code> テーブルの行数は常に正確です。<a class="xref" href="sql-syntax.html#optimize-table" title="13.7.2.4 OPTIMIZE TABLE 構文">セクション13.7.2.4「OPTIMIZE TABLE 構文」</a>、<a class="xref" href="sql-syntax.html#repair-table" title="13.7.2.5 REPAIR TABLE 構文">セクション13.7.2.5「REPAIR TABLE 構文」</a>、および<a class="xref" href="sql-syntax.html#show-table-status" title="13.7.5.37 SHOW TABLE STATUS 構文">セクション13.7.5.37「SHOW TABLE STATUS 構文」</a>を参照してください。
  </p><h3><a name="idm139979059035648"></a>追加のリソース</h3><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="literal">ARCHIVE</code> ストレージエンジンに特化したフォーラムは <a class="ulink" href="http://forums.mysql.com/list.php?112" target="_top">http://forums.mysql.com/list.php?112</a> で参照できます。
      </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="blackhole-storage-engine"></a>15.6 BLACKHOLE ストレージエンジン</h2></div></div></div><a class="indexterm" name="idm139979059031120"></a><a class="indexterm" name="idm139979059029632"></a><p>
    <code class="literal">BLACKHOLE</code> ストレージエンジンは、データを受け取るけれども破棄して格納しない<span class="quote">「<span class="quote">ブラックホール</span>」</span>として機能します。検索は、常に空の結果を返します。
  </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE test(i INT, c CHAR(10)) ENGINE = BLACKHOLE;</code></strong>
Query OK, 0 rows affected (0.03 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO test VALUES(1,'record one'),(2,'record two');</code></strong>
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT * FROM test;</code></strong>
Empty set (0.00 sec)
</pre><p>
    ソースから MySQL を構築する場合に <code class="literal">BLACKHOLE</code> ストレージエンジンを有効にするには、<span class="command"><strong>CMake</strong></span> を <code class="option">-DWITH_BLACKHOLE_STORAGE_ENGINE</code> オプションで呼び出します。
  </p><p>
    <code class="literal">BLACKHOLE</code> エンジンのソースを調べるには、MySQL ソース配布の <code class="filename">sql</code> ディレクトリを検索します。
  </p><p>
    <code class="literal">BLACKHOLE</code> テーブルを作成するときに、サーバーはデータベースディレクトリ上にテーブルフォーマットファイルを作成します。ファイルはテーブル名から始まり <code class="filename">.frm</code> 拡張子が付きます。テーブルに関連するファイルはほかにありません。
  </p><p>
    <code class="literal">BLACKHOLE</code> ストレージエンジンはすべての種類のインデックスをサポートしています。すなわち、テーブル定義にインデックス宣言を含めることができます。
  </p><p>
    <code class="literal">BLACKHOLE</code> ストレージエンジンが <code class="literal">SHOW ENGINES</code> ステートメントで使用できるかどうかを確認できます。
  </p><p>
    <code class="literal">BLACKHOLE</code> テーブルへの挿入はデータを格納しませんが、ステートメントベースバイナリロギングが有効になっている場合は、SQL ステートメントはログが記録されてスレーブサーバーに複製されます。これは、繰り返しまたはフィルタメカニズムとして役立つ場合があります。
  </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
      バイナリログに行ベースフォーマットを使用すると、更新と削除はスキップされ、ログも適用されません。このため、バイナリロギングフォーマットには ROW や MIXED ではなく STATEMENT を使用してください。
    </p></div><p>
    アプリケーションがスレーブ側フィルタリングルールを要求するけれども、すべてのバイナリログデータを最初にスレーブに転送するとトラフィックが多すぎるとします。そのような場合は、次に示すようにマスターホスト上に、デフォルトストレージエンジンが <code class="literal">BLACKHOLE</code> である <span class="quote">「<span class="quote">dummy</span>」</span>スレーブプロセスをセットアップできます。
  </p><div class="mediaobject"><img src="images/blackhole-1.png" width="520" height="245" alt="フィルタリングに BLACKHOLE を使用するレプリケーション"></div><p>
    マスターはそのバイナリログに書き込みます。<span class="quote">「<span class="quote">dummy</span>」</span> <span class="command"><strong>mysqld</strong></span> プロセスはスレーブとして機能し、<code class="literal">replicate-do-*</code> および <code class="literal">replicate-ignore-*</code> ルールの適切な組み合わせを適用し、それ自体のフィルタリングされた新しいバイナリログを書き込みます。<a class="xref" href="replication.html#replication-options" title="17.1.4 レプリケーションおよびバイナリロギングのオプションと変数">セクション17.1.4「レプリケーションおよびバイナリロギングのオプションと変数」</a>を参照してください。フィルタリングされたこのログはスレーブに提供されます。
  </p><p>
    ダミープロセスは実際にはデータを保存しないため、レプリケーションマスターホスト上で追加 <span class="command"><strong>mysqld</strong></span> プロセスを実行することによる処理オーバーヘッドはほとんどありません。この種類のセットアップは、ほかのレプリケーションスレーブで繰り返すことができます。
  </p><p>
    <code class="literal">BLACKHOLE</code> テーブルの <code class="literal">INSERT</code> トリガーは期待どおりに機能します。しかし、実際には <code class="literal">BLACKHOLE</code> テーブルはデータを格納しないため、<code class="literal">UPDATE</code> および <code class="literal">DELETE</code> トリガーは有効ではありません。トリガー定義の <code class="literal">FOR EACH ROW</code> 句は、行がないために適用されません。
  </p><p>
    <code class="literal">BLACKHOLE</code> ストレージエンジンのその他の利用方法は、次のとおりです。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        ダンプファイル構文の検証。
      </p></li><li class="listitem"><p>
        バイナリロギングのオーバーヘッドを測定 (バイナリロギングが有効である場合と有効でない場合のパフォーマンスを <code class="literal">BLACKHOLE</code> を利用して比較することで)。
      </p></li><li class="listitem"><p>
        <code class="literal">BLACKHOLE</code> は本質的には <span class="quote">「<span class="quote">no-op</span>」</span>ストレージエンジンであるため、ストレージエンジン自体には関係ないパフォーマンスボトルネックの検出に使用される場合があります。
      </p></li></ul></div><p>
    コミットされたトランザクションはバイナリログに書き込まれ、ロールバックされたトランザクションは書き込まれないという意味で、<code class="literal">BLACKHOLE</code> エンジンはトランザクション対応です。
  </p><p>
    <span class="bold"><strong>Blackhole エンジンと自動インクリメントカラム</strong></span>
  </p><p>
    Blackhole エンジンは no-op エンジンです。Blackhole を使用してテーブルで実行される操作は効果がありません。このことは、自動的に増分する主キーカラムの動作を考慮するときに念頭におくようにしてください。このエンジンはフィールド値を自動的に増分せず、自動インクリメントフィールドの状態を保持しません。これは、レプリケーションで重要な意味を持ちます。
  </p><p>
    次の 3 つの条件がすべて適用される次のレプリケーションシナリオを検討します。
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
        マスターサーバーには、主キーである自動インクリメントフィールドを持つブラックホールテーブルがあります。
      </p></li><li class="listitem"><p>
        スレーブには同じテーブルが存在しますが、MyISAM エンジンを使用します。
      </p></li><li class="listitem"><p>
        <code class="literal">INSERT</code> ステートメント自身で自動インクリメント値を明示的に設定せずに、つまり <code class="literal">SET INSERT_ID</code> ステートメントを使用して、マスターのテーブルへの挿入が実行されます。
      </p></li></ol></div><p>
    このシナリオでは、レプリケーションは主キーカラムでの重複エントリーエラーで失敗します。
  </p><p>
    ステートメントベースのレプリケーションでは、コンテキストイベントの <code class="literal">INSERT_ID</code> の値は常に同じになります。このため、主キーカラムで重複値を持つ行を挿入しようとすると、レプリケーションは失敗します。
  </p><p>
    行ベースのレプリケーションでは、エンジンが戻す行の値は、各挿入で常に同じです。このため、スレーブは主キーカラムで同じ値を使用する 2 つの挿入ログエントリーを再生しようとして、レプリケーションは失敗します。
  </p><p>
    <span class="bold"><strong>カラムのフィルタリング</strong></span>
  </p><p>
    行ベースのレプリケーション (<code class="literal">binlog_format=ROW</code>) を使用すると、 <a class="xref" href="replication.html#replication-features-differing-tables" title="17.4.1.9 テーブル定義が異なるマスターとスレーブでのレプリケーション">セクション17.4.1.9「テーブル定義が異なるマスターとスレーブでのレプリケーション」</a>セクションで説明されたように、最後のカラムがテーブルから失われたスレーブがサポートされます。
  </p><p>
    このフィルタリングはスレーブ側で機能します。すなわち、カラムはフィルタリングされる前にスレーブにコピーされます。スレーブにカラムをコピーすることが望ましくないケースが少なくとも 2 つあります。
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
        データが機密の場合、スレーブサーバーはアクセスすべきではありません。
      </p></li><li class="listitem"><p>
        マスターが多くのスレーブを持つ場合、スレーブに送る前にフィルタリングすると、ネットワークトラフィックが削減される可能性があります。
      </p></li></ol></div><p>
    マスターカラムのフィルタリングは、<code class="literal">BLACKHOLE</code> エンジンを使用して実現できます。これは、マスターテーブルフィルタリングの実現方法 (<code class="literal">BLACKHOLE</code> エンジンと <code class="option">--replicate-do-table</code> または <code class="option">--replicate-ignore-table</code> オプションを使用) に類似した方法で実行されます。
  </p><p>
    マスターのセットアップは次のとおりです。
  </p><pre class="programlisting">
CREATE TABLE t1 (public_col_1, ..., public_col_N,
                 secret_col_1, ..., secret_col_M) ENGINE=MyISAM;
</pre><p>
    信頼されたスレーブのセットアップは次のとおりです。
  </p><pre class="programlisting">
CREATE TABLE t1 (public_col_1, ..., public_col_N) ENGINE=BLACKHOLE;
</pre><p>
    信頼されないスレーブのセットアップは次のとおりです。
  </p><pre class="programlisting">CREATE TABLE t1 (public_col_1, ..., public_col_N) ENGINE=MyISAM;</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="merge-storage-engine"></a>15.7 MERGE ストレージエンジン</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="storage-engines.html#merge-table-advantages">15.7.1 MERGE テーブルの長所と短所</a></span></dt><dt><span class="section"><a href="storage-engines.html#merge-table-problems">15.7.2 MERGE テーブルの問題点</a></span></dt></dl></div><a class="indexterm" name="idm139979058951344"></a><a class="indexterm" name="idm139979058949856"></a><a class="indexterm" name="idm139979058947936"></a><a class="indexterm" name="idm139979058945792"></a><a class="indexterm" name="idm139979058943744"></a><p>
    <code class="literal">MRG_MyISAM</code> エンジンとしても知られている <code class="literal">MERGE</code> ストレージエンジンは、1 つのテーブルとして使用できる同一の <code class="literal">MyISAM</code> テーブルの集まりです。<span class="quote">「<span class="quote">同一の</span>」</span>というのは、すべてのテーブルが同一のカラムとインデックス情報を持つという意味です。カラムが異なる順番でリストされていたり、完全に同じカラムでなかったり、インデックスの順番が違っていたりすると <code class="literal">MyISAM</code> テーブルをマージできません。しかし、<code class="literal">MyISAM</code> テーブルのすべてまたはいずれかを <span class="command"><strong>myisampack</strong></span> で圧縮できます。<a class="xref" href="programs.html#myisampack" title="4.6.5 myisampack — 圧縮された読み取り専用の MyISAM テーブルの生成">セクション4.6.5「<span class="command"><strong>myisampack</strong></span> — 圧縮された読み取り専用の MyISAM テーブルの生成」</a>を参照してください。<code class="literal">AVG_ROW_LENGTH</code>、<code class="literal">MAX_ROWS</code>、<code class="literal">PACK_KEYS</code> などのテーブルオプションの違いは問題ではありません。
  </p><p>
    <code class="literal">MERGE</code> テーブルに代わるものはパーティション化されたテーブルであり、1 つのテーブルのパーティションを別々のファイルに格納します。パーティション化によって、一部の操作がより効率的に実行でき、<code class="literal">MyISAM</code> ストレージエンジンに制限されません。詳細については、<a class="xref" href="partitioning.html" title="第 19 章 パーティション化">第19章「<i>パーティション化</i>」</a>を参照してください。
  </p><p>
    <code class="literal">MERGE</code> テーブルを作成するときに、MySQL はディスク上に 2 つファイルを作成します。そのファイル名はテーブル名で始まり、ファイルタイプを示す拡張子が付きます。<code class="filename">.frm</code> ファイルはテーブルフォーマットを格納し、<code class="filename">.MRG</code> ファイルは 1 つのテーブルとして使用すべき基礎 <code class="literal">MyISAM</code> テーブル名を含みます。これらのテーブルは、<code class="literal">MERGE</code> テーブルと同じデータベースにある必要はありません。
  </p><p>
    <code class="literal">MERGE</code> テーブルでは、<code class="literal">SELECT</code>、<code class="literal">DELETE</code>、<code class="literal">UPDATE</code>、および <code class="literal">INSERT</code> を使用できます。<code class="literal">MERGE</code> テーブルにマッピングする <code class="literal">MyISAM</code> テーブルに対して <code class="literal">SELECT</code>、<code class="literal">DELETE</code>、および <code class="literal">UPDATE</code> 権限が必要です。
  </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
      <code class="literal">MERGE</code> テーブルの利用は、次のセキュリティーに関する問題を引き起こします。ユーザーが <code class="literal">MyISAM</code> テーブル <em class="replaceable"><code>t</code></em> に対するアクセス権限を持っていると、そのユーザーは <em class="replaceable"><code>t</code></em> にアクセスできる <code class="literal">MERGE</code> テーブル <em class="replaceable"><code>m</code></em> を作成できます。しかし、<em class="replaceable"><code>t</code></em> に対するユーザーの権限があとで破棄された場合、ユーザーは <em class="replaceable"><code>m</code></em> を介してアクセスすることで <em class="replaceable"><code>t</code></em> にアクセスを続けることができます。
    </p></div><p>
    <code class="literal">DROP TABLE</code> を <code class="literal">MERGE</code> テーブルに使用すると、<code class="literal">MERGE</code> 指定だけが削除されます。基礎テーブルは影響を受けません。
  </p><p>
    <code class="literal">MERGE</code> テーブルを作成するには、どの <code class="literal">MyISAM</code> テーブルを使用するかを示す <code class="literal">UNION=(<em class="replaceable"><code>list-of-tables</code></em>)</code> オプションを指定する必要があります。オプションとして、<code class="literal">INSERT_METHOD</code> オプションを指定して <code class="literal">MERGE</code> テーブルへの挿入方法を制御できます。<code class="literal">FIRST</code> または <code class="literal">LAST</code> の値を使用すると、それぞれ最初のまたは最後の基礎テーブルで挿入が実行されることになります。<code class="literal">INSERT_METHOD</code> オプションを指定しないか、または値 <code class="literal">NO</code> 付きでこのオプションを指定すると、<code class="literal">MERGE</code> テーブルへの挿入は許可されず、挿入の試みはエラーとなります。
  </p><p>
    次の例は、<code class="literal">MERGE</code> テーブルの作成方法を紹介しています。
  </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (</code></strong>
    -&gt;    <strong class="userinput"><code>a INT NOT NULL AUTO_INCREMENT PRIMARY KEY,</code></strong>
    -&gt;    <strong class="userinput"><code>message CHAR(20)) ENGINE=MyISAM;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE TABLE t2 (</code></strong>
    -&gt;    <strong class="userinput"><code>a INT NOT NULL AUTO_INCREMENT PRIMARY KEY,</code></strong>
    -&gt;    <strong class="userinput"><code>message CHAR(20)) ENGINE=MyISAM;</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t1 (message) VALUES ('Testing'),('table'),('t1');</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t2 (message) VALUES ('Testing'),('table'),('t2');</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE TABLE total (</code></strong>
    -&gt;    <strong class="userinput"><code>a INT NOT NULL AUTO_INCREMENT,</code></strong>
    -&gt;    <strong class="userinput"><code>message CHAR(20), INDEX(a))</code></strong>
    -&gt;    <strong class="userinput"><code>ENGINE=MERGE UNION=(t1,t2) INSERT_METHOD=LAST;</code></strong>
</pre><p>
    カラム <code class="literal">a</code> は <code class="literal">PRIMARY KEY</code> として基礎 <code class="literal">MyISAM</code> テーブルではインデックスが付けられていますが、<code class="literal">MERGE</code> テーブルではインデックスが付けられていません。<code class="literal">MERGE</code> テーブルは基礎テーブルセットに一意性を適用できないため、インデックスは設定されますが、<code class="literal">PRIMARY KEY</code> としては設定されません。(同様に、基礎テーブルで <code class="literal">UNIQUE</code> インデックスを持つカラムには、<code class="literal">MERGE</code> テーブルでインデックスが付けられますが、<code class="literal">UNIQUE</code> インデックスとしては付けられないはずです。)
  </p><p>
    <code class="literal">MERGE</code> テーブルを作成したあと、このテーブルを使用して、テーブルのグループにまとめて操作を行うクエリーを発行できます。
  </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT * FROM total;</code></strong>
+---+---------+
| a | message |
+---+---------+
| 1 | Testing |
| 2 | table   |
| 3 | t1      |
| 1 | Testing |
| 2 | table   |
| 3 | t2      |
+---+---------+
</pre><p>
    <code class="literal">MERGE</code> テーブルを <code class="literal">MyISAM</code> テーブルの別のコレクションに対して再マッピングするには、次のいずれかの方法を利用できます。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="literal">MERGE</code> テーブルを <code class="literal">DROP</code> して、再作成する。
      </p></li><li class="listitem"><p>
        基礎テーブルのリストを変更するために、<code class="literal">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> UNION=(...)</code> を利用する。
      </p><p>
        <code class="literal">ALTER TABLE ... UNION=()</code> (つまり、空の <code class="literal">UNION</code> 句) を使用してすべての基礎テーブルを削除することもできます。ただしこの場合、テーブルは実質的には空であり、新しい行を取得する基礎テーブルがないために挿入は失敗します。このようなテーブルは、新しい <code class="literal">MERGE</code> テーブルを <code class="literal">CREATE TABLE ... LIKE</code> で作成するためのテンプレートとして役立つ場合があります。
      </p></li></ul></div><p>
    基礎テーブルの定義とインデックスは、<code class="literal">MERGE</code> テーブルの定義と厳密に一致する必要があります。一致がチェックされるのは、<code class="literal">MERGE</code> テーブルが作成されたときではなく、<code class="literal">MERGE</code> テーブルの一部のテーブルが開いたときです。いずれのテーブルも一致チェックに失敗した場合、テーブルのオープンをトリガーした操作は失敗します。すなわち、<code class="literal">MERGE</code> 内のテーブルの定義を変更すると、<code class="literal">MERGE</code> テーブルがアクセスされたときに失敗の原因となる可能性があります。それぞれのテーブルに適用される一致チェックは次のとおりです。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        基礎テーブルと <code class="literal">MERGE</code> テーブルのカラム数は同じでなければいけません。
      </p></li><li class="listitem"><p>
        基礎テーブルと <code class="literal">MERGE</code> テーブルのカラムの順番は一致する必要があります。
      </p></li><li class="listitem"><p>
        また、親の <code class="literal">MERGE</code> テーブル内の対応する各カラムの指定と基礎テーブルの指定を比較して、次のチェック内容を満たす必要があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
            基礎テーブルと <code class="literal">MERGE</code> テーブルのカラムの型は一致する必要がある。
          </p></li><li class="listitem"><p>
            基礎テーブルと <code class="literal">MERGE</code> テーブルのカラムの長さは一致する必要がある。
          </p></li><li class="listitem"><p>
            基礎テーブルと <code class="literal">MERGE</code> テーブルのカラムは <code class="literal">NULL</code> でもかまわない。
          </p></li></ul></div></li><li class="listitem"><p>
        基礎テーブルは、少なくとも <code class="literal">MERGE</code> テーブルと同じ数のインデックスを持つ必要がある。基礎テーブルのインデックスの数は <code class="literal">MERGE</code> テーブルより多くてもかまわないが、少なくすることはできない。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          同じカラムのインデックスは、<code class="literal">MERGE</code> テーブルと基礎 <code class="literal">MyISAM</code> テーブルの両方でまったく同じ順番でなければならないという、既知の問題が存在します。バグ #33653 を参照してください。
        </p></div><p>
        各インデックスは次のチェック内容を満たす必要があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
            基礎テーブルと <code class="literal">MERGE</code> テーブルのインデックスの型は一致する必要がある。
          </p></li><li class="listitem"><p>
            基礎テーブルと <code class="literal">MERGE</code> テーブルのインデックス定義でのインデックス部の数 (すなわち、複合インデックス内に複数のカラム) は一致する必要があります。
          </p></li><li class="listitem"><p>
            各インデックス部について。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                インデックス部の長さは同じでなければいけない。
              </p></li><li class="listitem"><p>
                インデックス部の型は同じでなければいけない。
              </p></li><li class="listitem"><p>
                インデックス部の言語は同じでなければいけない。
              </p></li><li class="listitem"><p>
                インデックス部が <code class="literal">NULL</code> でかまわないかどうかをチェックする。
              </p></li></ul></div></li></ul></div></li></ul></div><p>
    <code class="literal">MERGE</code> テーブルが基礎テーブルの問題のために、開いたり使用したりできない場合、<code class="literal">CHECK TABLE</code> は問題の原因となったテーブルに関する情報を表示します。
  </p><h3><a name="idm139979058825008"></a>追加のリソース</h3><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="literal">MERGE</code> ストレージエンジンに特化したフォーラムは、<a class="ulink" href="http://forums.mysql.com/list.php?93" target="_top">http://forums.mysql.com/list.php?93</a>で参照できます。
      </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="merge-table-advantages"></a>15.7.1 MERGE テーブルの長所と短所</h3></div></div></div><p>
      <code class="literal">MERGE</code> テーブルは、次のような問題を解決するのに役立つことがあります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          ログテーブルセットを簡単に管理する。たとえば、異なる月のデータを別々のテーブルに入力し、<span class="command"><strong>myisampack</strong></span> を利用してそれらの一部を圧縮してから、1 つのものとして利用するために <code class="literal">MERGE</code> テーブルを作成できます。
        </p></li><li class="listitem"><p>
          スピードを上げる。大きな読み取り専用テーブルを同じ基準で分割し、個々のテーブルを異なるディスクに置くことができます。このように構成された <code class="literal">MERGE</code> テーブルは、1 つの大きなテーブルを使用するよりも、速度がかなり速くなる可能性があります。
        </p></li><li class="listitem"><p>
          より効率的に検索を行う。検索する対象が正確にわかっている場合、あるクエリーで基礎テーブルの 1つだけを検索し、別のクエリーで <code class="literal">MERGE</code> テーブルを使用できます。重複するテーブルセットを使用する、多数の異なる <code class="literal">MERGE</code> テーブルを持つこともできます。
        </p></li><li class="listitem"><p>
          より効率的な修復を行う。1 つの大きなテーブルを修復するよりも、<code class="literal">MERGE</code> テーブルにマッピングされた個々の小さいテーブルを修復する方が簡単です。
        </p></li><li class="listitem"><p>
          多くのテーブルを瞬時に 1 つのテーブルとしてマッピングする。<code class="literal">MERGE</code> テーブルは個々のテーブルのインデックスを利用するので、それ自体のインデックスを保守する必要はありません。その結果、<code class="literal">MERGE</code> テーブルコレクションは、作成や再マッピングを<span class="emphasis"><em>非常に</em></span>速く行うことができます。(<code class="literal">MERGE</code> テーブルを作成するときは、インデックスが作成されない場合でも、インデックスの定義を指定する必要があります。)
        </p></li><li class="listitem"><p>
          テーブルセットがあり、それらからオンデマンドで大きなテーブルを作成する場合は、代わりにそれらからオンデマンドで <code class="literal">MERGE</code> テーブルを作成できます。この方が、速度がかなり速くなり、多くのディスク容量が節約されます。
        </p></li><li class="listitem"><p>
          オペレーティングシステムのファイルサイズ制限を超える。個々の <code class="literal">MyISAM</code> テーブルはこの制限に制約されますが、<code class="literal">MyISAM</code> テーブルのコレクションは制約されません。
        </p></li><li class="listitem"><p>
          <code class="literal">MyISAM</code> テーブルにマッピングする <code class="literal">MERGE</code> テーブルを定義することで、その単一テーブルのエイリアスやシノニムを作成できます。これを行なっても、特に顕著なパフォーマンス面の影響はないはずです (個々の読み取りのためにいくつかの間接呼び出しや <code class="literal">memcpy()</code> 呼び出しがあるだけです)。
        </p></li></ul></div><p>
      <code class="literal">MERGE</code> テーブルの短所は次のとおりです。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">MERGE</code> テーブルに対して、同一の <code class="literal">MyISAM</code> テーブルしか使用できません。
        </p></li><li class="listitem"><p>
          <code class="literal">MyISAM</code> 機能のいくつかは <code class="literal">MERGE</code> テーブルでは使用できません。たとえば、<code class="literal">MERGE</code> テーブルに <code class="literal">FULLTEXT</code> インデックスを作成できません。(基礎 <code class="literal">MyISAM</code> テーブルに <code class="literal">FULLTEXT</code> インデックスを作成できますが、<code class="literal">MERGE</code> テーブルを全文検索で検索できません。)
        </p></li><li class="listitem"><p>
          <code class="literal">MERGE</code> テーブルが非一時的である場合、すべての基礎 <code class="literal">MyISAM</code> テーブルは非一時的である必要があります。<code class="literal">MERGE</code> テーブルが一時的である場合、<code class="literal">MyISAM</code> テーブルは一時的なテーブルと非一時的なテーブルが混在してもかまいません。
        </p></li><li class="listitem"><p>
          <code class="literal">MERGE</code> テーブルは <code class="literal">MyISAM</code> テーブルより多くのファイルディスクリプタを使用します。10 個のクライアントが、10 個のテーブルにマッピングする <code class="literal">MERGE</code> テーブルを使用する場合、サーバーは (10 × 10) + 10 個のファイルディスクリプタを使用します。(10 個のクライアントに対してそれぞれ 10 個のデータファイルディスクリプタに加えて、クライアント間で共有される 10 個のインデックスファイルディスクリプタです。)
        </p></li><li class="listitem"><p>
          インデックスの読み取りは低下します。インデックスを読み取るときに、<code class="literal">MERGE</code> ストレージエンジンはすべての基礎テーブルに読み取りを発行して、渡されたインデックス値に厳密に一致するかをチェックする必要があります。次のインデックス値を読み取るために、<code class="literal">MERGE</code> ストレージエンジンは読み取りバッファーを検索して次の値を探す必要があります。1 つのインデックスバッファーが使い果たされていた場合にのみ、ストレージエンジンは次のインデックスブロックを読み取る必要があります。これで、<code class="literal">MERGE</code> インデックスは <code class="literal">eq_ref</code> 検索をかなり遅くしますが、<code class="literal">ref</code> 検索ではそれほど低下しません。<code class="literal">eq_ref</code> および <code class="literal">ref</code> の詳細情報については、<a class="xref" href="sql-syntax.html#explain" title="13.8.2 EXPLAIN 構文">セクション13.8.2「EXPLAIN 構文」</a>を参照してください。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="merge-table-problems"></a>15.7.2 MERGE テーブルの問題点</h3></div></div></div><p>
      <code class="literal">MERGE</code> テーブルの既知の問題点は次のとおりです。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          5.1.23 バージョンより前の MySQL Server では、MyISAM の非一時的な子供のテーブルを持つ一時的なマージテーブルを作成できました。
        </p><p>
          バージョン 5.1.23 からは、MERGE の子供は親のテーブルを介してロックされました。親が一時的であった場合、親がロックされなかったため、子供もロックされませんでした。MyISAM テーブルを同時に使用すると、テーブルが破損しました。
        </p></li><li class="listitem"><p>
          <code class="literal">ALTER TABLE</code> を使用して <code class="literal">MERGE</code> テーブルを別のストレージエンジンに変えると、基礎テーブルへのマッピングが失われます。その代わり、変更されたテーブルに基礎 <code class="literal">MyISAM</code> テーブルの行がコピーされ、そのときに、指定されたストレージエンジンを使用します。
        </p></li><li class="listitem"><p>
          <code class="literal">MERGE</code> テーブルの <code class="literal">INSERT_METHOD</code> テーブルオプションは、<code class="literal">MERGE</code> テーブルへの挿入にどの基礎 <code class="literal">MyISAM</code> テーブルを使用するかを示します。ただし、その <code class="literal">MyISAM</code> テーブルに <code class="literal">AUTO_INCREMENT</code> テーブルオプションを使用しても、1 つ以上の行が <code class="literal">MyISAM</code> テーブルに直接挿入されるまで、<code class="literal">MERGE</code> テーブルへの挿入は有効になりません。
        </p></li><li class="listitem"><p>
          <code class="literal">MERGE</code> テーブルは、テーブル全体に一意制約を保持できません。<code class="literal">INSERT</code> を実行すると、データは最初または最後の <code class="literal">MyISAM</code> テーブル (<code class="literal">INSERT_METHOD</code> オプションで指定されます) に入ります。MySQL は一意のキー値が <code class="literal">MyISAM</code> テーブル内で一意のままであることを保証しますが、コレクション内のすべての基礎テーブルには保証しません。
        </p></li><li class="listitem"><p>
          <code class="literal">MERGE</code> エンジンは基本テーブルセットに一意性を適用できないため、<code class="literal">REPLACE</code> は期待どおりに機能しません。次の 2 つの重要な事実があります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">REPLACE</code> は、書き込もうとする基礎テーブルでのみ一意キー違反を検出できます (<code class="literal">INSERT_METHOD</code> オプションで指定されます)。これは <code class="literal">MERGE</code> テーブル自体の違反とは異なります。
            </p></li><li class="listitem"><p>
              <code class="literal">REPLACE</code> が一意キー違反を検出した場合、書き込んでいる基礎テーブルの対応する行だけを変更します。すなわち、<code class="literal">INSERT_METHOD</code> オプションで指定される最初または最後のテーブルです。
            </p></li></ul></div><p>
          <code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> についても同様な考慮が適用されます。
        </p></li><li class="listitem"><p>
          <code class="literal">MERGE</code> テーブルはパーティション化をサポートしていません。つまり、<code class="literal">MERGE</code> テーブルも、<code class="literal">MERGE</code> テーブルの基礎 <code class="literal">MyISAM</code> テーブルもパーティション化できません。
        </p></li><li class="listitem"><p>
          開いた <code class="literal">MERGE</code> テーブルにマッピングされたどのテーブルにも、<code class="literal">ANALYZE TABLE</code>、<code class="literal">REPAIR TABLE</code>、<code class="literal">OPTIMIZE TABLE</code>、<code class="literal">ALTER TABLE</code>、<code class="literal">DROP TABLE</code>、<code class="literal">DELETE</code> (<code class="literal">WHERE</code> 句なし)、または <code class="literal">TRUNCATE TABLE</code> を使用すべきではありません。そうする場合、<code class="literal">MERGE</code> テーブルは引き続き元のテーブルを参照しているため、予期しない結果となる可能性があります。この問題に対処するには、名前付きの操作を行う前に <code class="literal">FLUSH TABLES</code> ステートメントを発行することで、確実に <code class="literal">MERGE</code> テーブルが開いたままにならないようにします。
        </p><p>
          予期しない結果には、<code class="literal">MERGE</code> テーブルに対する操作によってテーブルの破損が報告される可能性が含まれます。基礎 <code class="literal">MyISAM</code> テーブルで名前付き操作のあとにこれが発生した場合、破損メッセージは偽りです。これに対処するには、<code class="literal">MyISAM</code> テーブルを変更したあとで <code class="literal">FLUSH TABLES</code> ステートメントを発行します。
        </p></li><li class="listitem"><p>
          <code class="literal">MERGE</code> ストレージエンジンのテーブルマッピングは MySQL の上位レイヤーから隠れているので、<code class="literal">MERGE</code> テーブルによって使用されているテーブルでの <code class="literal">DROP TABLE</code> は Windows では機能しません。Windows では開いているファイルの削除を許可しないため、最初にすべての <code class="literal">MERGE</code> テーブルをフラッシュするか (<code class="literal">FLUSH TABLES</code> を使用します)、テーブルを削除する前に <code class="literal">MERGE</code> テーブルを削除する必要があります。
        </p></li><li class="listitem"><p>
          <code class="literal">MyISAM</code> テーブルと <code class="literal">MERGE</code> テーブルの定義は、テーブルにアクセスするときにチェックされます (たとえば、<code class="literal">SELECT</code> または <code class="literal">INSERT</code> ステートメントの一部として)。このチェックは、テーブルの定義と親の <code class="literal">MERGE</code> テーブルの定義が、カラムの順番、タイプ、サイズ、および関連するインデックスを比較することで一致することを保証します。テーブル間で違いがある場合、エラーが戻され、ステートメントは失敗します。テーブルが開いたときにこれらのチェックが行われるため、1 つのテーブルの定義に変更を加えると (カラムの変更、カラムの順序付け、エンジンの変更など)、ステートメントが失敗する原因になります。
        </p></li><li class="listitem"><p>
          <code class="literal">MERGE</code> テーブルと、その基礎テーブルのインデックスの順番は同一でなければいけません。<code class="literal">ALTER TABLE</code> を使用して、<code class="literal">MERGE</code> テーブル内で使用されるテーブルに <code class="literal">UNIQUE</code> インデックスを追加し、次に <code class="literal">ALTER TABLE</code> を使用して <code class="literal">MERGE</code> テーブル上に一意でないインデックスを追加した場合、基礎テーブル内に一意でないインデックスがすでに存在していると、それらのテーブルのインデックス順序は異なります。(これが発生するのは、重複キーをすばやく検出できるように <code class="literal">ALTER TABLE</code> が一意でないインデックスの前に <code class="literal">UNIQUE</code> インデックスを配置するためです。)その結果、このようなインデックスを持つテーブルに対するクエリーは予想外の結果をもたらす可能性があります。
        </p></li><li class="listitem"><p>
          <span class="errortext">ERROR 1017 (HY000): Can't find file: '<em class="replaceable"><code>tbl_name</code></em>.MRG' (errno: 2)</span>エラーメッセージが表示された場合、一般的に、いくつかの基礎テーブルが <code class="literal">MyISAM</code> ストレージエンジンを使用していないことを表しています。これらのテーブルがすべて <code class="literal">MyISAM</code> であることを確認してください。
        </p></li><li class="listitem"><p>
          <code class="literal">MERGE</code> テーブルの行の最大値は 2<sup>64</sup> です (~1.844E+19 で、<code class="literal">MyISAM</code> テーブルの場合と同じ)。複数の <code class="literal">MyISAM</code> テーブルを、この数よりも多くの行を含む単一の <code class="literal">MERGE</code> テーブルにマージできません。
        </p></li><li class="listitem"><p>
          <code class="literal">MERGE</code> ストレージエンジンは、<code class="literal">INSERT DELAYED</code> ステートメントをサポートしていません。
        </p></li><li class="listitem"><p>
          親の <code class="literal">MERGE</code> テーブルを持つ、異なる行フォーマットの基礎 <code class="literal">MyISAM</code> テーブルを使用すると、現在失敗することが知られています。バグ #32364 を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">LOCK TABLES</code> が実施されているときは、非一時的な <code class="literal">MERGE</code> テーブルの結合リストを変更できません。次は動作<span class="emphasis"><em>しません</em></span>。
        </p><pre class="programlisting">
CREATE TABLE m1 ... ENGINE=MRG_MYISAM ...;
LOCK TABLES t1 WRITE, t2 WRITE, m1 WRITE;
ALTER TABLE m1 ... UNION=(t1,t2) ...;
</pre><p>
          ただし、一時的な <code class="literal">MERGE</code> テーブルではこれを行うことができます。
        </p></li><li class="listitem"><p>
          一時的な <code class="literal">MERGE</code> としても、非一時的な <code class="literal">MERGE</code> テーブルとしても、<code class="literal">CREATE ... SELECT</code> で <code class="literal">MERGE</code> テーブルを作成できません。例:
        </p><pre class="programlisting">CREATE TABLE m1 ... ENGINE=MRG_MYISAM ... SELECT ...;</pre><p>
          これを試みると、<em class="replaceable"><code>tbl_name</code></em> は <code class="literal">BASE TABLE</code> ではないというエラーとなります。
        </p></li><li class="listitem"><p>
          あるケースでは、<code class="literal">MERGE</code> と基礎テーブル間で <code class="literal">PACK_KEYS</code> テーブルオプション値が異なると、基礎テーブルに <code class="literal">CHAR</code> または <code class="literal">BINARY</code> カラムが含まれている場合、予期しない結果になります。回避策として、<code class="literal">ALTER TABLE</code> を使用して、関係するすべてのテーブルの <code class="literal">PACK_KEYS</code> 値が同じであることを保証します。(Bug #50646)
        </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="federated-storage-engine"></a>15.8 FEDERATED ストレージエンジン</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="storage-engines.html#federated-description">15.8.1 FEDERATED ストレージエンジンの概要</a></span></dt><dt><span class="section"><a href="storage-engines.html#federated-create">15.8.2 FEDERATED テーブルの作成方法</a></span></dt><dt><span class="section"><a href="storage-engines.html#federated-usagenotes">15.8.3 FEDERATED ストレージエンジンの注記とヒント</a></span></dt><dt><span class="section"><a href="storage-engines.html#federated-storage-engine-resources">15.8.4 FEDERATED ストレージエンジンのリソース</a></span></dt></dl></div><a class="indexterm" name="idm139979058661344"></a><a class="indexterm" name="idm139979058659856"></a><p>
    <code class="literal">FEDERATED</code> ストレージエンジンを使用すると、レプリケーションまたはクラスタの技術を使用しないで、リモートの MySQL データベースのデータにアクセスできます。ローカルの <code class="literal">FEDERATED</code> テーブルにクエリーを発行すると、リモート (連合) テーブルからデータを自動的に取得します。データはローカルテーブルに格納されません。
  </p><p>
    ソースから MySQL を構築する場合に <code class="literal">FEDERATED</code> ストレージエンジンを含めるには、<span class="command"><strong>CMake</strong></span> を <code class="option">-DWITH_FEDERATED_STORAGE_ENGINE</code> オプションで呼び出します。
  </p><p>
    <code class="literal">FEDERATED</code> ストレージエンジンは、デフォルトでは動作中のサーバーで有効になっていません。<code class="literal">FEDERATED</code> を有効にするには、<code class="option">--federated</code> オプションを使用して MySQL サーバーバイナリを起動する必要があります。
  </p><p>
    <code class="literal">FEDERATED</code> エンジンのソースを調べるには、MySQL ソース配布の <code class="filename">storage/federated</code> ディレクトリを検索します。
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="federated-description"></a>15.8.1 FEDERATED ストレージエンジンの概要</h3></div></div></div><p>
      標準のストレージエンジン (<code class="literal">MyISAM</code>、<code class="literal">CSV</code>、<code class="literal">InnoDB</code> など) のいずれかを使用してテーブルを作成すると、そのテーブルはテーブルの定義と関連データで構成されます。<code class="literal">FEDERATED</code> テーブルを作成すると、テーブル定義は同じですが、データの物理ストレージはリモートサーバーで処理されます。
    </p><p>
      <code class="literal">FEDERATED</code> テーブルは 2 つの要素で構成されます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          データベーステーブルを持つ <span class="emphasis"><em>リモートサーバー</em></span>。テーブル定義 (<code class="filename">.frm</code> ファイルに格納されます) と関連テーブルで構成されます。リモートテーブルのテーブルタイプは、<code class="literal">MyISAM</code> や <code class="literal">InnoDB</code> を含む、リモート <code class="literal">mysqld</code> サーバーがサポートするいずれのタイプであってもかまいません。
        </p></li><li class="listitem"><p>
          データベーステーブルを持つ <span class="emphasis"><em>ローカルサーバー</em></span>。テーブルの定義は、リモートサーバー上の対応するテーブルの定義に一致します。テーブル定義は <code class="filename">.frm</code> ファイルに格納されます。ただし、ローカルサーバーにデータファイルはありません。その代わり、テーブル定義にはリモートテーブルをポイントする接続文字列が含まれています。
        </p></li></ul></div><p>
      ローカルサーバーで <code class="literal">FEDERATED</code> テーブルにクエリーやステートメントを実行すると、一般的にローカルデータファイルの情報を挿入、更新、または削除する操作は、実行するために代わりにリモートサーバーに送られ、そこでリモートサーバーのデータファイルを更新したり、リモートサーバーから一致する行を戻したりします。
    </p><p>
      <code class="literal">FEDERATED</code> テーブルのセットアップの基本的な構造は <a class="xref" href="storage-engines.html#figure-se-federated-structure" title="図 15.1 FEDERATED テーブルの構造">図15.1「FEDERATED テーブルの構造」</a>で示します。
    </p><div class="figure"><a name="figure-se-federated-structure"></a><p class="title"><b>図 15.1 FEDERATED テーブルの構造</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/se-federated-structure.png" width="475" height="269" alt="FEDERATED テーブルの構造"></div></div></div><br class="figure-break"><p>
      <code class="literal">FEDERATED</code> テーブルを参照する SQL ステートメントをクライアントが発行する場合、ローカルサーバー (SQL ステートメントが実行される場所) とリモートサーバー (データが物理的に格納される場所) の間の情報の流れは次のとおりです。
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          ストレージエンジンは <code class="literal">FEDERATED</code> テーブルが持つ各カラムを調べて、リモートテーブルを参照する適当な SQL ステートメントを構築します。
        </p></li><li class="listitem"><p>
          ステートメントは MySQL クライアント API を使用してリモートサーバーに送られます。
        </p></li><li class="listitem"><p>
          リモートサーバーはステートメントを処理し、ローカルサーバーはステートメントが作成した結果 (影響を受けた行の数や結果セット) を取得します。
        </p></li><li class="listitem"><p>
          ステートメントが結果セットを作成する場合、各カラムは <code class="literal">FEDERATED</code> エンジンが求める内部ストレージエンジン形式に変換され、元のステートメントを発行したクライアントに結果を表示するために使用できます。
        </p></li></ol></div><p>
      ローカルサーバーは、MySQL クライアントの C API 関数を使用してリモートサーバーと通信します。<code class="literal">mysql_real_query()</code> を呼び出して、ステートメントを送信します。結果セットを読み取るために、<code class="literal">mysql_store_result()</code> を使用し、<code class="literal">mysql_fetch_row()</code> を使用して 1 つずつ行をフェッチします。
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="federated-create"></a>15.8.2 FEDERATED テーブルの作成方法</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="storage-engines.html#federated-create-connection">15.8.2.1 CONNECTION を使用した FEDERATED テーブルの作成</a></span></dt><dt><span class="section"><a href="storage-engines.html#federated-create-server">15.8.2.2 CREATE SERVER を使用した FEDERATED テーブルの作成</a></span></dt></dl></div><p>
      <code class="literal">FEDERATED</code> テーブルを作成するときは、次の手順に従うようにしてください。
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          リモートサーバーにテーブルを作成します。または、<code class="literal">SHOW CREATE TABLE</code> ステートメントを使用するなどして、既存テーブルのテーブル定義のメモを取ります。
        </p></li><li class="listitem"><p>
          同一のテーブル定義でローカルサーバーにデーブルを作成しますが、ローカルテーブルをリモートテーブルにリンクする接続情報を追加してください。
        </p></li></ol></div><p>
      たとえば、リモートサーバーに次のテーブルを作成できます。
    </p><pre class="programlisting">
CREATE TABLE test_table (
    id     INT(20) NOT NULL AUTO_INCREMENT,
    name   VARCHAR(32) NOT NULL DEFAULT '',
    other  INT(20) NOT NULL DEFAULT '0',
    PRIMARY KEY  (id),
    INDEX name (name),
    INDEX other_key (other)
)
ENGINE=MyISAM
DEFAULT CHARSET=latin1;
</pre><p>
      リモートテーブルに連合したローカルテーブルを作成するには、2 つのオプションが使用できます。ローカルテーブルを作成し、<code class="literal">CONNECTION</code> を使用してリモートテーブルへの接続に使用される接続文字列 (サーバー名、ログイン、パスワードを含みます) を指定するか、<code class="literal">CREATE SERVER</code> ステートメントを使用してすでに作成された既存の接続を使用できます。
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        ローカルテーブルを作成する場合、リモートテーブルに同一のフィールド定義を持つ<span class="emphasis"><em>必要があります</em></span>。
      </p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
        インデックスをホストのテーブルに追加することで、<code class="literal">FEDERATED</code> テーブルのパフォーマンスを向上できます。リモートサーバーに送られたクエリーには <code class="literal">WHERE</code> 句の内容が含まれており、それがリモートサーバーに送られてローカルに実行されるため、最適化が起こります。これにより、そうしないとローカル処理のためにサーバーからテーブル全体を要求することになるネットワークトラフィックが削減されます。
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="federated-create-connection"></a>15.8.2.1 CONNECTION を使用した FEDERATED テーブルの作成</h4></div></div></div><p>
        最初の方法を使用するには、<code class="literal">CREATE TABLE</code> ステートメントのエンジンタイプの後ろに <code class="literal">CONNECTION</code> 文字列を指定する必要があります。例:
      </p><pre class="programlisting">
CREATE TABLE federated_table (
    id     INT(20) NOT NULL AUTO_INCREMENT,
    name   VARCHAR(32) NOT NULL DEFAULT '',
    other  INT(20) NOT NULL DEFAULT '0',
    PRIMARY KEY  (id),
    INDEX name (name),
    INDEX other_key (other)
)
ENGINE=FEDERATED
DEFAULT CHARSET=latin1
CONNECTION='mysql://fed_user@remote_host:9306/federated/test_table';
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">CONNECTION</code> は MySQL の以前のバージョンで使われた <code class="literal">COMMENT</code> を置き換えるものです。
        </p></div><p>
        <code class="literal">CONNECTION</code> 文字列には、データを物理的に格納するために使用されるテーブルを含む、リモートサーバーへの接続に必要な情報が含まれています。接続文字列には、サーバー名、ログイン資格証明、ポート番号、およびデータベース/テーブル情報を指定します。この例では、リモートテーブルはサーバー <code class="literal">remote_host</code> 上にあり、ポート 9306 を使用します。名前とポート番号は、リモートテーブルとして使用するリモート MySQL サーバーのホスト名 (または IP アドレス) とポート番号に一致するべきです。
      </p><p>
        接続文字列の書式は次のとおりです。
      </p><pre class="programlisting">
<em class="replaceable"><code>scheme</code></em>://<em class="replaceable"><code>user_name</code></em>[:<em class="replaceable"><code>password</code></em>]@<em class="replaceable"><code>host_name</code></em>[:<em class="replaceable"><code>port_num</code></em>]/<em class="replaceable"><code>db_name</code></em>/<em class="replaceable"><code>tbl_name</code></em>
</pre><p>
        ここでは:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <em class="replaceable"><code>scheme</code></em>: 認識された接続プロトコル。この時点では、<code class="literal">mysql</code> だけが <em class="replaceable"><code>scheme</code></em> 値としてサポートされています。
          </p></li><li class="listitem"><p>
            <em class="replaceable"><code>user_name</code></em>: 接続のためのユーザー名。このユーザーは、リモートサーバー上に作成されている必要があり、リモートテーブルで必要なアクション (<code class="literal">SELECT</code>、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code> など) を実行するのに適した権限を持つ必要があります。
          </p></li><li class="listitem"><p>
            <em class="replaceable"><code>password</code></em>: (オプション) <em class="replaceable"><code>user_name</code></em> に対応するパスワード。
          </p></li><li class="listitem"><p>
            <em class="replaceable"><code>host_name</code></em>: リモートサーバーのホスト名または IP アドレス。
          </p></li><li class="listitem"><p>
            <em class="replaceable"><code>port_num</code></em>: (オプション) リモートサーバーのポート番号。デフォルトは 3306 です。
          </p></li><li class="listitem"><p>
            <em class="replaceable"><code>db_name</code></em>: リモートテーブルを保持するデータベースの名前。
          </p></li><li class="listitem"><p>
            <em class="replaceable"><code>tbl_name</code></em>: リモートテーブルの名前。ローカルテーブルとリモートテーブルの名前が一致する必要はありません。
          </p></li></ul></div><p>
        接続文字列の例は次のとおりです。
      </p><pre class="programlisting">
CONNECTION='mysql://username:password@hostname:port/database/tablename'
CONNECTION='mysql://username@hostname/database/tablename'
CONNECTION='mysql://username:password@hostname/database/tablename'
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="federated-create-server"></a>15.8.2.2 CREATE SERVER を使用した FEDERATED テーブルの作成</h4></div></div></div><p>
        多くの <code class="literal">FEDERATED</code> テーブルを同じサーバーに作成する場合、または <code class="literal">FEDERATED</code> テーブルの作成プロセスを単純化する必要がある場合、<code class="literal">CREATE SERVER</code> ステートメントを使用してサーバー接続パラメータを定義できます (<code class="literal">CONNECTION</code> 文字列の場合と同様)。
      </p><p>
        <code class="literal">CREATE SERVER</code> ステートメントの書式は次のとおりです。
      </p><pre class="programlisting">CREATE SERVER
<em class="replaceable"><code>server_name</code></em>
FOREIGN DATA WRAPPER <em class="replaceable"><code>wrapper_name</code></em>
OPTIONS (<em class="replaceable"><code>option</code></em> [, <em class="replaceable"><code>option</code></em>] ...)</pre><p>
        <em class="replaceable"><code>server_name</code></em> は <code class="literal">FEDERATED</code> テーブルを作成するときに接続文字列で使用されます。
      </p><p>
        たとえば <code class="literal">CONNECTION</code> 文字列と同一のサーバー接続を作成するには、次のとおりです。
      </p><pre class="programlisting">CONNECTION='mysql://fed_user@remote_host:9306/federated/test_table';</pre><p>
        次のステートメントを使用することになります。
      </p><pre class="programlisting">CREATE SERVER fedlink
FOREIGN DATA WRAPPER mysql
OPTIONS (USER 'fed_user', HOST 'remote_host', PORT 9306, DATABASE 'federated');</pre><p>
        この接続を使用する <code class="literal">FEDERATED</code> テーブルを作成するには、<code class="literal">CONNECTION</code> キーワードも使用しますが、<code class="literal">CREATE SERVER</code> ステートメントで使用した名前を指定します。
      </p><pre class="programlisting">CREATE TABLE test_table (
    id     INT(20) NOT NULL AUTO_INCREMENT,
    name   VARCHAR(32) NOT NULL DEFAULT '',
    other  INT(20) NOT NULL DEFAULT '0',
    PRIMARY KEY  (id),
    INDEX name (name),
    INDEX other_key (other)
)
ENGINE=FEDERATED
DEFAULT CHARSET=latin1
CONNECTION='fedlink/test_table';</pre><p>
        この例の接続名には、接続の名前 (<code class="literal">fedlink</code>) とリンクするテーブルの名前 (<code class="literal">test_table</code>) が含まれます (区切りはスラッシュ)。テーブル名なしで接続名だけを指定した場合、代わりにローカルテーブルのテーブル名が使用されます。
      </p><p>
        <code class="literal">CREATE SERVER</code> の詳細情報については、<a class="xref" href="sql-syntax.html#create-server" title="13.1.16 CREATE SERVER 構文">セクション13.1.16「CREATE SERVER 構文」</a>を参照してください。
      </p><p>
        <code class="literal">CREATE SERVER</code> ステートメントは、<code class="literal">CONNECTION</code> 文字列と同じ引数を受け入れます。<code class="literal">CREATE SERVER</code> ステートメントは <code class="literal">mysql.servers</code> テーブルの中の行を更新します。接続文字列のパラメータ間の通信、<code class="literal">CREATE SERVER</code> ステートメントのオプション、および <code class="literal">mysql.servers</code> テーブルのカラムに関する情報については、次の表を参照してください。参考までに、<code class="literal">CONNECTION</code> 文字列の書式は次のとおりです。
      </p><pre class="programlisting">
<em class="replaceable"><code>scheme</code></em>://<em class="replaceable"><code>user_name</code></em>[:<em class="replaceable"><code>password</code></em>]@<em class="replaceable"><code>host_name</code></em>[:<em class="replaceable"><code>port_num</code></em>]/<em class="replaceable"><code>db_name</code></em>/<em class="replaceable"><code>tbl_name</code></em>
</pre><div class="informaltable"><table summary="この表では、接続文字列のパラメータ間の通信、CREATE SERVER ステートメントのオプション、および mysql.servers テーブルのカラムについて説明します。" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th scope="col">説明</th><th scope="col"><code class="literal">CONNECTION</code> 文字列</th><th scope="col"><code class="literal">CREATE SERVER</code> オプション</th><th scope="col"><code class="literal">mysql.servers</code> カラム</th></tr></thead><tbody><tr><td scope="row">接続スキーム</td><td><em class="replaceable"><code>scheme</code></em></td><td><code class="literal">wrapper_name</code></td><td><code class="literal">Wrapper</code></td></tr><tr><td scope="row">リモートユーザー</td><td><em class="replaceable"><code>user_name</code></em></td><td><code class="literal">USER</code></td><td><code class="literal">Username</code></td></tr><tr><td scope="row">リモートパスワード</td><td><em class="replaceable"><code>password</code></em></td><td><code class="literal">PASSWORD</code></td><td><code class="literal">Password</code></td></tr><tr><td scope="row">リモートホスト</td><td><em class="replaceable"><code>host_name</code></em></td><td><code class="literal">HOST</code></td><td><code class="literal">Host</code></td></tr><tr><td scope="row">リモートポート</td><td><em class="replaceable"><code>port_num</code></em></td><td><code class="literal">PORT</code></td><td><code class="literal">Port</code></td></tr><tr><td scope="row">リモートデータベース</td><td><em class="replaceable"><code>db_name</code></em></td><td><code class="literal">DATABASE</code></td><td><code class="literal">Db</code></td></tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="federated-usagenotes"></a>15.8.3 FEDERATED ストレージエンジンの注記とヒント</h3></div></div></div><p>
      <code class="literal">FEDERATED</code> ストレージエンジンを使用するときは、次の点に注意することをお勧めします。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">FEDERATED</code> テーブルをほかのスレーブに複製してもかまいませんが、スレーブサーバーが <code class="literal">CONNECTION</code> 文字列 (または <code class="literal">mysql.servers</code> テーブルの行) で定義されたユーザーとパスワードの組み合わせを使用してリモートサーバーに接続できることを確認する必要があります。
        </p></li></ul></div><p>
      次の項目は、<code class="literal">FEDERATED</code> ストレージエンジンがサポートしている機能とサポートしていない機能を示します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          リモートサーバーは MySQL サーバーでなくてはいけません。
        </p></li><li class="listitem"><p>
          <code class="literal">FEDERATED</code> テーブルがポイントするリモートテーブルは、<code class="literal">FEDERATED</code> テーブルを介してそのテーブルにアクセスを試みる前に、存在<span class="emphasis"><em>している必要があります</em></span>。
        </p></li><li class="listitem"><p>
          ある <code class="literal">FEDERATED</code> テーブルがほかのテーブルをポイントすることは可能ですが、ループを作らないように注意する必要があります。
        </p></li><li class="listitem"><p>
          <code class="literal">FEDERATED</code> テーブルは本質的にインデックスをサポートしていません。テーブルへのアクセスがリモートで処理されるため、リモートテーブルがインデックスをサポートします。同等の <code class="literal">MyISAM</code> やほかのテーブルからのインデックス定義がサポートされていない可能性があるため、<code class="literal">FEDERATED</code> テーブルを作成するときは注意を払うようにしてください。たとえば、<code class="literal">VARCHAR</code>、<code class="literal">TEXT</code>、または <code class="literal">BLOB</code> カラムにインデックスプリフィクスを付けた <code class="literal">FEDERATED</code> テーブルを作成すると、失敗します。<code class="literal">MyISAM</code> の次の定義は有効です。
        </p><pre class="programlisting">CREATE TABLE `T1`(`A` VARCHAR(100),UNIQUE KEY(`A`(30))) ENGINE=MYISAM;</pre><p>
          この例のキープリフィクスは <code class="literal">FEDERATED</code> エンジンと互換性がないため、同等のステートメントは失敗します。
        </p><pre class="programlisting">CREATE TABLE `T1`(`A` VARCHAR(100),UNIQUE KEY(`A`(30))) ENGINE=FEDERATED
  CONNECTION='MYSQL://127.0.0.1:3306/TEST/T1';</pre><p>
          可能であれば、これらのインデックスの問題を回避するため、リモートサーバーとローカルサーバーの両方にテーブルを作成する場合、カラムとインデックスの定義を分けるようにしてください。
        </p></li><li class="listitem"><p>
          内部的に、実装は <code class="literal">SELECT</code>、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、および <code class="literal">DELETE</code> を使用しますが、<code class="literal">HANDLER</code> は使用しません。
        </p></li><li class="listitem"><p>
          <code class="literal">FEDERATED</code> ストレージエンジンは、<code class="literal">SELECT</code>、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、<code class="literal">DELETE</code>、<code class="literal">TRUNCATE TABLE</code>、およびインデックスをサポートしています。<code class="literal">DROP TABLE</code> を除いて、<code class="literal">ALTER TABLE</code> や、テーブルの構造に直接影響を与えるデータ定義言語ステートメントをサポートしていません。現在の実装は、プリペアドステートメントを使用しません。

          
        </p></li><li class="listitem"><p>
          <code class="literal">FEDERATED</code> は <code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> ステートメントを受け入れますが、重複キー違反が起こった場合、ステートメントはエラーで失敗します。
        </p></li><li class="listitem"><p>
          大量の挿入を実行する場合 (たとえば、<code class="literal">INSERT INTO ... SELECT ...</code> ステートメント) の <code class="literal">FEDERATED</code> テーブルのパフォーマンスは、選択された各行が <code class="literal">FEDERATED</code> テーブルで個々の <code class="literal">INSERT</code> ステートメントとして処理されるため、ほかのテーブルタイプに比べて低下します。
        </p></li><li class="listitem"><p>
          トランザクションはサポートされていません。
        </p></li><li class="listitem"><p>
          <code class="literal">FEDERATED</code> は、複数の行がバッチでリモートテーブルに送られるように大量挿入処理を実行します。これでパフォーマンスは向上し、リモートテーブルは改善を実行できます。また、リモートテーブルがトランザクション対応の場合、エラーが発生したときにリモートストレージエンジンはステートメントロールバックを適切に実行できます。この機能には次の制限があります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              挿入のサイズは、サーバー間の最大パケットサイズを超えることはできません。挿入がこのサイズを超えた場合、複数のパケットに分割され、ロールバック問題が発生する可能性があります。
            </p></li><li class="listitem"><p>
              大量挿入処理は <code class="literal">INSERT ... ON DUPLICATE KEY UPDATE</code> では起こりません。
            </p></li></ul></div></li><li class="listitem"><p>
          <code class="literal">FEDERATED</code> エンジンは、リモートテーブルが変わったかどうかを知る方法がありません。その理由は、このテーブルが、データベースシステム以外の何かによって決して書き込まれることのないデータファイルのように動作する必要があるためです。リモートデータベースに変更が加えられた場合に、ローカルテーブルのデータの完全性が損なわれる可能性があります。
        </p></li><li class="listitem"><p>
          <code class="literal">CONNECTION</code> 文字列を使用する場合、パスワードに '@' 文字を使用できません。<code class="literal">CREATE SERVER</code> ステートメントを使用してサーバー接続を作成することで、この制限を回避できます。
        </p></li><li class="listitem"><p>
          <code class="literal">insert_id</code> および <code class="literal">timestamp</code> オプションはデータプロバイダには伝達されません。
        </p></li><li class="listitem"><p>
          <code class="literal">FEDERATED</code> テーブルに対して発行された <code class="literal">DROP TABLE</code> ステートメントは、ローカルテーブルだけを削除し、リモートテーブルは削除しません。
        </p></li><li class="listitem"><p>
          <code class="literal">FEDERATED</code> テーブルはクエリーキャッシュでは機能しません。
        </p></li><li class="listitem"><p>
          ユーザー定義のパーティション化は、<code class="literal">FEDERATED</code> テーブルではサポートされていません。
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="federated-storage-engine-resources"></a>15.8.4 FEDERATED ストレージエンジンのリソース</h3></div></div></div><p>
      次の追加リソースは、<code class="literal">FEDERATED</code> ストレージエンジンで利用できます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">FEDERATED</code> ストレージエンジンに特化したフォーラムは <a class="ulink" href="http://forums.mysql.com/list.php?105" target="_top">http://forums.mysql.com/list.php?105</a> で参照できます。
        </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example-storage-engine"></a>15.9 EXAMPLE ストレージエンジン</h2></div></div></div><a class="indexterm" name="idm139979058421328"></a><a class="indexterm" name="idm139979058419840"></a><p>
    <code class="literal">EXAMPLE</code> ストレージエンジンは、何もしないスタブエンジンです。その目的は、新しいストレージエンジンの書き込みを開始する方法を示す MySQL ソースコードの例として機能することです。このため、主に開発者を対象としています。
  </p><p>
    ソースから MySQL を構築する場合に <code class="literal">EXAMPLE</code> ストレージエンジンを有効にするには、<span class="command"><strong>CMake</strong></span> を <code class="option">-DWITH_EXAMPLE_STORAGE_ENGINE</code> オプションで呼び出します。
  </p><p>
    <code class="literal">EXAMPLE</code> エンジンのソースを調べるには、MySQL ソース配布の <code class="filename">storage/example</code> ディレクトリを検索します。
  </p><p>
    <code class="literal">EXAMPLE</code> テーブルを作成すると、サーバーはデータベースディレクトリ上にテーブル形式ファイルを作成します。ファイルはテーブル名から始まり <code class="filename">.frm</code> 拡張子が付きます。ほかのファイルは作成されません。データをテーブルに格納できません。検索は空の結果を返します。
  </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE test (i INT) ENGINE = EXAMPLE;</code></strong>
Query OK, 0 rows affected (0.78 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO test VALUES(1),(2),(3);</code></strong>
ERROR 1031 (HY000): Table storage engine for 'test' doesn't »
                    have this option

mysql&gt; <strong class="userinput"><code>SELECT * FROM test;</code></strong>
Empty set (0.31 sec)
</pre><p>
    <code class="literal">EXAMPLE</code> ストレージエンジンはインデックスをサポートしていません。
  </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="storage-engines-other"></a>15.10 ほかのストレージエンジン</h2></div></div></div><p>
      ストレージエンジンは、カスタムストレージエンジンのインタフェースを使用したサードパーティーおよびコミュニティーメンバーの別のストレージエンジンを使用できる場合があります。
    </p><p>
      サードパーティーのエンジンは MySQL によってサポートされていません。これらのエンジンに関する詳細情報、ドキュメント、インストールガイド、バグレポート、ヘルプや支援については、そのエンジンの開発者に直接問い合わせてください。
    </p><p>
      プラガブルストレージエンジンアーキテクチャーで使用できるお客様のストレージエンジンの開発に関する詳細については、「<a class="ulink" href="http://dev.mysql.com/doc/internals/en/custom-engine.html" target="_top">MySQL Internals: Writing a Custom Storage Engine</a>」を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="pluggable-storage-overview"></a>15.11 MySQL ストレージエンジンアーキテクチャーの概要</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="storage-engines.html#pluggable-storage">15.11.1 プラガブルストレージエンジンのアーキテクチャー</a></span></dt><dt><span class="section"><a href="storage-engines.html#pluggable-storage-common-layer">15.11.2 共通データベースサーバーレイヤー</a></span></dt></dl></div><p>
      MySQL プラガブルストレージエンジンアーキテクチャーを採用すると、データベースの専門家は、特定のアプリケーションニーズに特化したストレージエンジンを選択でき、さらにアプリケーションの特定のコーディング要件を管理する必要が完全になくなります。MySQL サーバーのアーキテクチャーにより、アプリケーションプログラマと DBA はストレージレベルのすべての実装詳細から解放され、一貫した容易なアプリケーションモデルと API が得られます。したがって、異なるストレージエンジンの機能には違いがありますが、アプリケーションはその違いから解放されます。
    </p><p>
      プラガブルストレージエンジンのアーキテクチャーは、すべての基になるストレージエンジンに共通の管理およびサポートサービスの標準セットを提供します。ストレージエンジン自身は、物理サーバーレベルで保守される基になるデータに対してアクションを実際に実行するデータベースサーバーのコンポーネントです。
    </p><p>
      この効率的なモジュール形式のアーキテクチャーは、データウェアハウス、トランザクション処理、高可用性状況など、特別なアプリケーションニーズを特に対象にしたい人、またどれか 1 つのストレージエンジンに依存しないインタフェースとサービスのセットを利用するメリットを享受したい人にとって、大きなメリットが得られます。
    </p><p>
      アプリケーションプログラマと DBA は、コネクタ API およびストレージエンジンの上位にあるサービスレイヤーを介して MySQL データベースと対話します。アプリケーションの変更によって、基になるストレージエンジンの変更を求める要件が発生した場合、または新しいニーズをサポートするために 1 つ以上のストレージエンジンが追加された場合、これをうまく行うためにコーディングやプロセスを大幅に変更する必要はありません。MySQL サーバーのアーキテクチャーは、ストレージエンジンに適用される、一貫して使いやすい API を提供することで、ストレージエンジンの内在する複雑さからアプリケーションを解放します。
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="pluggable-storage"></a>15.11.1 プラガブルストレージエンジンのアーキテクチャー</h3></div></div></div><p>
        MySQL Server は、ストレージエンジンが、動作中の MySQL サーバーにロードされたり、MySQL サーバーからアンロードされたりできる、プラガブルストレージエンジンアーキテクチャーを採用しています。
      </p><p>
        <span class="bold"><strong>ストレージエンジンのプラグイン</strong></span>
      </p><p>
        ストレージエンジンを使用する前に、<code class="literal">INSTALL PLUGIN</code> ステートメントを利用してストレージエンジンのプラグイン共用ライブラリを MySQL にロードする必要があります。たとえば、<code class="literal">EXAMPLE</code> エンジンのプラグインの名前が <code class="literal">example</code> で、共有ライブラリの名前が <code class="filename">ha_example.so</code> である場合、次のステートメントを使用してロードします。
      </p><pre class="programlisting">
mysql&gt; INSTALL PLUGIN example SONAME 'ha_example.so';
</pre><p>
        プラガブルストレージエンジンをインストールするには、プラグインファイルは MySQL プラグインディレクトリにある必要があり、<code class="literal">INSTALL PLUGIN</code> ステートメントを発行するユーザーには、<code class="literal">mysql.plugin</code> テーブルの <code class="literal">INSERT</code> 権限が必要です。
      </p><p>
        共有ライブラリは MySQL サーバーのプラグインディレクトリの中にある必要があり、その場所は <code class="literal">plugin_dir</code>システム変数によって指示されます。
      </p><p>
        <span class="bold"><strong>ストレージエンジンのアンプラグ</strong></span>
      </p><p>
        ストレージエンジンをアンプラグするには、<code class="literal">UNINSTALL PLUGIN</code> ステートメントを利用します。
      </p><pre class="programlisting">
mysql&gt; UNINSTALL PLUGIN example;
</pre><p>
        既存のテーブルが必要とするストレージエンジンをアンプラグした場合、それらのテーブルはアクセスできなくなりますが、引き続きディスク上 (適切な場所) に存在します。ストレージエンジンをアンプラグする前に、そのストレージエンジンを使用しているテーブルがないことを確認してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="pluggable-storage-common-layer"></a>15.11.2 共通データベースサーバーレイヤー</h3></div></div></div><p>
        MySQL プラガブルストレージエンジンは、データベースに対して実データの I/O 操作を行なったり、特定のアプリケーションニーズを対象とする機能セットを有効にしたり適用したりする役割を担う、MySQL データベースサーバーのコンポーネントです。特定のストレージエンジンを使用する主なメリットは、特定のアプリケーションに必要な機能だけが配布されるため、データベースのオーバーヘッドが小さくなり、データベースパフォーマンスが効率的になり向上します。これは、MySQL がこのように高パフォーマンスであると以前から知られてきた理由の 1 つであり、業界標準ベンチマークで独占的な地位を占める強力なデータベースに匹敵または対抗できる要因になっています。
      </p><p>
        技術的に見て、ストレージエンジンを支える独自のインフラストラクチャー要素は何でしょうか。機能を差別化している主な要素は次のとおりです。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <span class="emphasis"><em>並列性</em></span>: いくつかのアプリケーションは、ほかのアプリケーションよりさらに粒度の細かいロック要件 (低レベルロックなど) を持ちます。適切なロック方式を選択すると、オーバーヘッドが低減されるため、全体のパフォーマンスが向上します。また、この分野はマルチバージョンの並列処理制御や<span class="quote">「<span class="quote">スナップショット</span>」</span>の読み込みのような機能もサポートします。
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>トランザクションサポート</em></span>: 必ずしもすべてのアプリケーションがトランザクションを必要としていませんが、必要な場合、ACID 準拠などの非常に明確な要件があります。
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>参照整合性</em></span>: サーバーは DDL 定義の外部キーでリレーショナルデータベースの参照整合性を適用する必要があります。
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>物理ストレージ</em></span>: これには、テーブルとインデックスの全体ページサイズやデータの物理ディスクへの格納に使用されるフォーマットのすべてが関係します。
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>インデックスサポート</em></span>: アプリケーションシナリオによっては、別のインデックス方式からメリットが得られる傾向があります。通常、各ストレージエンジンには独自のインデックス方式がありますが、ほぼすべてのエンジンに共通の方式 (B ツリーインデックスなど) もあります。
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>メモリーキャッシュ</em></span>: アプリケーションによってはあるメモリーキャッシュ方式の方がほかより応答が良いものがあり、あるメモリーキャッシュはすべてのストレージエンジンに共通だけれども (ユーザー接続または MySQL の高速クエリーキャッシュに使用されるものなど)、特定のストレージエンジンが動作するときにのみ独自に定義されるものもあります。
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>パフォーマンスエイド</em></span>: これには、並列操作用のマルチ I/O スレッド、スレッド並列処理、データベースチェックポイント、大量の挿入処理などが含まれます。
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>その他のターゲット機能</em></span>: これには、地理空間操作、データ操作のセキュリティー面の制限事項、およびその他の類似機能に対するサポートが含まれます。
          </p></li></ul></div><p>
        プラガブルストレージエンジンの各インフラストラクチャーコンポーネントセットは、特定のアプリケーション向けの利点を提供できるように設計されています。反対に、あるコンポーネント機能セットを回避することは、不必要なオーバーヘッドを削減するのに役立ちます。特定アプリケーションの要件セットを理解して、適切な MySQL ストレージエンジンを選択することは、当然のことながらシステム全体の効率とパフォーマンスに大きな影響を与える可能性があります。
      </p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="innodb-storage-engine.html">前</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ha-overview.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第 14 章 InnoDB ストレージエンジン </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 第 16 章 高可用性と拡張性</td></tr></table></div><div class="copyright-footer"></div></body></html>
