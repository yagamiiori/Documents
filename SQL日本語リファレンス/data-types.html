<html lang="ja"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>第 11 章 データ型</title><link rel="stylesheet" type="text/css" href="mvl.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="MySQL 5.6 リファレンスマニュアル"><link rel="up" href="index.html" title="MySQL 5.6 リファレンスマニュアル"><link rel="prev" href="globalization.html" title="第 10 章 グローバリゼーション"><link rel="next" href="functions.html" title="第 12 章 関数と演算子">
<script language="javascript" type="text/javascript">
  function addOnload(theFunc)
  {
    var previous = window.onload;
    if (typeof window.onload != 'function')
    {
      window.onload = theFunc;
    }
    else
    {
      window.onload = function()
      {
        previous();
        theFunc();
      }
    }
  }

  addOnload(function()
  {
    var base = new Date(1442918127*1000);
    var now = new Date();
    var diff = ((now-base)/1000)/(24*3600);

    if (diff > 90) {
      var nodes = document.getElementsByClassName('titlepage');
      nodes[0].innerHTML = '<p style="border: 5px #ff0000 solid; padding: 5px; margin 5px">' +
        'This copy of the manual is more than 90 days old. We encourage you to download a ' +
        'new version from <a href="http://dev.mysql.com">dev.mysql.com/doc</a>.</p>' + nodes[0].innerHTML;
    }
  });
</script>
<noscript></noscript>
</head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第 11 章 データ型</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="globalization.html">前</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="functions.html">次へ</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="data-types"></a>第 11 章 データ型</h1></div></div></div><div class="toc"><p><b>目次</b></p><dl class="toc"><dt><span class="section"><a href="data-types.html#data-type-overview">11.1 データ型の概要</a></span></dt><dd><dl><dt><span class="section"><a href="data-types.html#numeric-type-overview">11.1.1 数値型の概要</a></span></dt><dt><span class="section"><a href="data-types.html#date-and-time-type-overview">11.1.2 日付と時間型の概要</a></span></dt><dt><span class="section"><a href="data-types.html#string-type-overview">11.1.3 文字列型の概要</a></span></dt></dl></dd><dt><span class="section"><a href="data-types.html#numeric-types">11.2 数値型</a></span></dt><dd><dl><dt><span class="section"><a href="data-types.html#integer-types">11.2.1 整数型 (真数値) - INTEGER、INT、SMALLINT、TINYINT、MEDIUMINT、BIGINT</a></span></dt><dt><span class="section"><a href="data-types.html#fixed-point-types">11.2.2 固定小数点型 (真数値) - DECIMAL、NUMERIC</a></span></dt><dt><span class="section"><a href="data-types.html#floating-point-types">11.2.3 浮動小数点型 (概数値) - FLOAT、DOUBLE</a></span></dt><dt><span class="section"><a href="data-types.html#bit-type">11.2.4 ビット値型 - BIT</a></span></dt><dt><span class="section"><a href="data-types.html#numeric-type-attributes">11.2.5 数値型の属性</a></span></dt><dt><span class="section"><a href="data-types.html#out-of-range-and-overflow">11.2.6 範囲外およびオーバーフローの処理</a></span></dt></dl></dd><dt><span class="section"><a href="data-types.html#date-and-time-types">11.3 日付と時間型</a></span></dt><dd><dl><dt><span class="section"><a href="data-types.html#datetime">11.3.1 DATE、DATETIME、および TIMESTAMP 型</a></span></dt><dt><span class="section"><a href="data-types.html#time">11.3.2 TIME 型</a></span></dt><dt><span class="section"><a href="data-types.html#year">11.3.3 YEAR 型</a></span></dt><dt><span class="section"><a href="data-types.html#migrating-to-year4">11.3.4 YEAR(2) の制限と YEAR(4) への移行</a></span></dt><dt><span class="section"><a href="data-types.html#timestamp-initialization">11.3.5 TIMESTAMP および DATETIME の自動初期化および更新機能</a></span></dt><dt><span class="section"><a href="data-types.html#fractional-seconds">11.3.6 時間値での小数秒</a></span></dt><dt><span class="section"><a href="data-types.html#date-and-time-type-conversion">11.3.7 日付と時間型間での変換</a></span></dt><dt><span class="section"><a href="data-types.html#two-digit-years">11.3.8 日付での 2 桁の年</a></span></dt></dl></dd><dt><span class="section"><a href="data-types.html#string-types">11.4 文字列型</a></span></dt><dd><dl><dt><span class="section"><a href="data-types.html#char">11.4.1 CHAR および VARCHAR 型</a></span></dt><dt><span class="section"><a href="data-types.html#binary-varbinary">11.4.2 BINARY および VARBINARY 型</a></span></dt><dt><span class="section"><a href="data-types.html#blob">11.4.3 BLOB 型と TEXT 型</a></span></dt><dt><span class="section"><a href="data-types.html#enum">11.4.4 ENUM 型</a></span></dt><dt><span class="section"><a href="data-types.html#set">11.4.5 SET 型</a></span></dt></dl></dd><dt><span class="section"><a href="data-types.html#spatial-extensions">11.5 空間データの拡張</a></span></dt><dd><dl><dt><span class="section"><a href="data-types.html#spatial-datatypes">11.5.1 空間データ型</a></span></dt><dt><span class="section"><a href="data-types.html#opengis-geometry-model">11.5.2 OpenGIS 幾何モデル</a></span></dt><dt><span class="section"><a href="data-types.html#using-spatial-data">11.5.3 空間データの使用</a></span></dt></dl></dd><dt><span class="section"><a href="data-types.html#data-type-defaults">11.6 データ型デフォルト値</a></span></dt><dt><span class="section"><a href="data-types.html#storage-requirements">11.7 データ型のストレージ要件</a></span></dt><dt><span class="section"><a href="data-types.html#choosing-types">11.8 カラムに適した型の選択</a></span></dt><dt><span class="section"><a href="data-types.html#other-vendor-data-types">11.9 その他のデータベースエンジンのデータ型の使用</a></span></dt></dl></div><p>
    MySQL では、数値型、日付と時間型、文字列 (文字およびバイト) 型、空間型という複数のカテゴリにわたる多数の <a class="link" href="glossary.html#glos_sql" title="SQL">SQL</a> データ型をサポートしています。この章では、これらのデータ型の概要、各カテゴリの型のプロパティーに関する詳細、およびデータ型ストレージ要件のサマリーについて説明します。最初の概要は意図的に簡単なものにしています。値を指定可能な許可される形式など、特定のデータ型に関する追加情報については、この章で後述する詳細な説明を参照してください。
  </p><a class="indexterm" name="idm139979104550912"></a><a class="indexterm" name="idm139979104549488"></a><a class="indexterm" name="idm139979104547456"></a><a class="indexterm" name="idm139979104545424"></a><p>
    データ型の説明では、次の規則を使用しています。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <a class="indexterm" name="idm139979104542064"></a> <a class="indexterm" name="idm139979104540720"></a> <a class="indexterm" name="idm139979104538688"></a> <a class="indexterm" name="idm139979104537344"></a> <a class="indexterm" name="idm139979104535312"></a> <a class="indexterm" name="idm139979104533968"></a> <em class="replaceable"><code>M</code></em> は整数型の最大表示幅を示します。浮動小数点型と固定小数点型の場合、<em class="replaceable"><code>M</code></em> は格納可能な桁数の合計 (精度) です。文字列型の場合は、<em class="replaceable"><code>M</code></em> は最大長です。<em class="replaceable"><code>M</code></em> の許可される最大値は、データ型によって異なります。
      </p></li><li class="listitem"><p>
        <a class="indexterm" name="idm139979104528992"></a> <a class="indexterm" name="idm139979104527648"></a> <a class="indexterm" name="idm139979104525616"></a> <a class="indexterm" name="idm139979104524272"></a> <em class="replaceable"><code>D</code></em> は、浮動小数点型と固定小数点型に適用され、小数点以下の桁数 (スケール) を表します。指定可能な最大値は 30 ですが、<em class="replaceable"><code>M</code></em>−2 以下にしてください。
      </p></li><li class="listitem"><p>
        <a class="indexterm" name="idm139979104520976"></a> <a class="indexterm" name="idm139979104519616"></a> <em class="replaceable"><code>fsp</code></em> は、<code class="literal">TIME</code>、<code class="literal">DATETIME</code>、および <code class="literal">TIMESTAMP</code> 型に適用され、小数秒の精度、つまり、秒の小数部における小数点以下の桁数を表します。<em class="replaceable"><code>fsp</code></em> 値を指定する場合、0 から 6 の範囲にする必要があります。0 の値は、小数部がないことを表します。省略した場合、デフォルトの精度は 0 です。(これは、以前の MySQL バージョンと互換性を保つため、標準 SQL のデフォルトである 6 とは異なっています。)
      </p></li><li class="listitem"><p>
        <a class="indexterm" name="idm139979104512224"></a> <a class="indexterm" name="idm139979104510080"></a> 角括弧 (<span class="quote">「<span class="quote"><code class="literal">[</code></span>」</span>と<span class="quote">「<span class="quote"><code class="literal">]</code></span>」</span>) は型定義のオプションの部分を表します。
      </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="data-type-overview"></a>11.1 データ型の概要</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="data-types.html#numeric-type-overview">11.1.1 数値型の概要</a></span></dt><dt><span class="section"><a href="data-types.html#date-and-time-type-overview">11.1.2 日付と時間型の概要</a></span></dt><dt><span class="section"><a href="data-types.html#string-type-overview">11.1.3 文字列型の概要</a></span></dt></dl></div><a class="indexterm" name="idm139979104505520"></a><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="numeric-type-overview"></a>11.1.1 数値型の概要</h3></div></div></div><a class="indexterm" name="idm139979104502400"></a><a class="indexterm" name="idm139979104501056"></a><a class="indexterm" name="idm139979104499712"></a><p>
        数値データ型のサマリーについて説明します。数値型のプロパティーおよびストレージ要件の追加情報については、<a class="xref" href="data-types.html#numeric-types" title="11.2 数値型">セクション11.2「数値型」</a>および<a class="xref" href="data-types.html#storage-requirements" title="11.7 データ型のストレージ要件">セクション11.7「データ型のストレージ要件」</a>を参照してください。
      </p><p>
        <em class="replaceable"><code>M</code></em> は整数型の最大表示幅を示します。最大表示幅は 255 です。<a class="xref" href="data-types.html#numeric-types" title="11.2 数値型">セクション11.2「数値型」</a>で説明しているように、表示幅はその型に含めることができる値の範囲とは関係ありません。浮動小数点型と固定小数点型の場合、<em class="replaceable"><code>M</code></em> は格納可能な桁数の合計です。
      </p><p>
        数値カラムに対して <code class="literal">ZEROFILL</code> を指定すると、MySQL は自動的にそのカラムに <code class="literal">UNSIGNED</code> 属性を追加します。
      </p><p>
        <code class="literal">UNSIGNED</code> 属性を許可している数値データ型は、<code class="literal">SIGNED</code> も許可します。ただし、このデータ型はデフォルトで符号付きになっているため、<code class="literal">SIGNED</code> 属性を指定しても効果はありません。
      </p><p>
        <code class="literal">SERIAL</code> は <code class="literal">BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE</code> のエイリアスです。
      </p><p>
        整数カラム定義の中の <code class="literal">SERIAL DEFAULT VALUE</code> は <code class="literal">NOT NULL AUTO_INCREMENT UNIQUE</code> のエイリアスです。
      </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">警告</div><p>
          一方が <code class="literal">UNSIGNED</code> 型のときに 2 つの整数値の間で減算を行うと、<code class="literal">NO_UNSIGNED_SUBTRACTION</code> SQL モードが有効でないかぎり、結果の値は符号なしになります。<a class="xref" href="functions.html#cast-functions" title="12.10 キャスト関数と演算子">セクション12.10「キャスト関数と演算子」</a>を参照してください。
        </p></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <a class="indexterm" name="idm139979104479408"></a> <a class="indexterm" name="idm139979104477936"></a> <code class="literal">BIT[(<em class="replaceable"><code>M</code></em>)]</code>
          </p><p>
            ビットフィールド型。<em class="replaceable"><code>M</code></em> は、値あたりのビット数 (1 から 64) を表します。<em class="replaceable"><code>M</code></em> を省略した場合のデフォルトは 1 です。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979104469792"></a> <a class="indexterm" name="idm139979104468304"></a> <code class="literal">TINYINT[(<em class="replaceable"><code>M</code></em>)] [UNSIGNED] [ZEROFILL]</code>
          </p><p>
            非常に小さい整数。符号付きの範囲は <code class="literal">-128</code> から <code class="literal">127</code> です。符号なしの範囲は <code class="literal">0</code> から <code class="literal">255</code> です。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979104458272"></a> <a class="indexterm" name="idm139979104456784"></a> <a class="indexterm" name="idm139979104455424"></a> <a class="indexterm" name="idm139979104453504"></a> <code class="literal">BOOL</code>、<code class="literal">BOOLEAN</code>
          </p><p>
            これらの型は <code class="literal">TINYINT(1)</code> のシノニムです。ゼロの値は false と見なされます。ゼロ以外の値は true と見なされます。
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT IF(0, 'true', 'false');</code></strong>
+------------------------+
| IF(0, 'true', 'false') |
+------------------------+
| false                  |
+------------------------+

mysql&gt; <strong class="userinput"><code>SELECT IF(1, 'true', 'false');</code></strong>
+------------------------+
| IF(1, 'true', 'false') |
+------------------------+
| true                   |
+------------------------+

mysql&gt; <strong class="userinput"><code>SELECT IF(2, 'true', 'false');</code></strong>
+------------------------+
| IF(2, 'true', 'false') |
+------------------------+
| true                   |
+------------------------+
</pre><p>
            ただし、ここに示されているように、<code class="literal">TRUE</code> 値と <code class="literal">FALSE</code> 値はそれぞれ、<code class="literal">1</code> と <code class="literal">0</code> の単なるエイリアスです。
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT IF(0 = FALSE, 'true', 'false');</code></strong>
+--------------------------------+
| IF(0 = FALSE, 'true', 'false') |
+--------------------------------+
| true                           |
+--------------------------------+

mysql&gt; <strong class="userinput"><code>SELECT IF(1 = TRUE, 'true', 'false');</code></strong>
+-------------------------------+
| IF(1 = TRUE, 'true', 'false') |
+-------------------------------+
| true                          |
+-------------------------------+

mysql&gt; <strong class="userinput"><code>SELECT IF(2 = TRUE, 'true', 'false');</code></strong>
+-------------------------------+
| IF(2 = TRUE, 'true', 'false') |
+-------------------------------+
| false                         |
+-------------------------------+

mysql&gt; <strong class="userinput"><code>SELECT IF(2 = FALSE, 'true', 'false');</code></strong>
+--------------------------------+
| IF(2 = FALSE, 'true', 'false') |
+--------------------------------+
| false                          |
+--------------------------------+
</pre><p>
            最後の 2 つのステートメントは、<code class="literal">2</code> が <code class="literal">1</code> とも <code class="literal">0</code> とも等しくないために示される結果を表示します。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979104429920"></a> <a class="indexterm" name="idm139979104428432"></a> <code class="literal">SMALLINT[(<em class="replaceable"><code>M</code></em>)] [UNSIGNED] [ZEROFILL]</code>
          </p><p>
            小さい整数。符号付きの範囲は <code class="literal">-32768</code> から <code class="literal">32767</code> です。符号なしの範囲は <code class="literal">0</code> から <code class="literal">65535</code> です。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979104418352"></a> <a class="indexterm" name="idm139979104416848"></a> <code class="literal">MEDIUMINT[(<em class="replaceable"><code>M</code></em>)] [UNSIGNED] [ZEROFILL]</code>
          </p><p>
            中間サイズの整数。符号付きの範囲は <code class="literal">-8388608</code> から <code class="literal">8388607</code> です。符号なしの範囲は <code class="literal">0</code> から <code class="literal">16777215</code> です。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979104406768"></a> <a class="indexterm" name="idm139979104405296"></a> <code class="literal">INT[(<em class="replaceable"><code>M</code></em>)] [UNSIGNED] [ZEROFILL]</code>
          </p><p>
            普通サイズの整数。符号付きの範囲は <code class="literal">-2147483648</code> から <code class="literal">2147483647</code> です。符号なしの範囲は <code class="literal">0</code> から <code class="literal">4294967295</code> です。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979104395968"></a> <a class="indexterm" name="idm139979104394480"></a> <code class="literal">INTEGER[(<em class="replaceable"><code>M</code></em>)] [UNSIGNED] [ZEROFILL]</code>
          </p><p>
            この型は <code class="literal">INT</code> のシノニムです。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979104386352"></a> <a class="indexterm" name="idm139979104384880"></a> <a class="indexterm" name="idm139979104382960"></a> <code class="literal">BIGINT[(<em class="replaceable"><code>M</code></em>)] [UNSIGNED] [ZEROFILL]</code>
          </p><p>
            大きい整数。符号付きの範囲は <code class="literal">-9223372036854775808</code> から <code class="literal">9223372036854775807</code> です。符号なしの範囲は <code class="literal">0</code> から <code class="literal">18446744073709551615</code> です。
          </p><p>
            <code class="literal">SERIAL</code> は <code class="literal">BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE</code> のエイリアスです。
          </p><p>
            <code class="literal">BIGINT</code> カラムについて注意の必要な点は、次のとおりです。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <a class="indexterm" name="idm139979104371904"></a> すべての演算は符号付きの <code class="literal">BIGINT</code> 値または <code class="literal">DOUBLE</code> 値を使用して行われるため、ビット関数を使用しないかぎり、<code class="literal">9223372036854775807</code> (63 ビット) よりも大きい符号なしの整数を使用しないでください。そのようにした場合、<code class="literal">BIGINT</code> 値から <code class="literal">DOUBLE</code> 値への変換時に、丸め誤差のために結果の最後の数桁に誤差が生じる可能性があります。
              </p><p>
                MySQL は、次の場合に、<code class="literal">BIGINT</code> を扱うことができます。
              </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                    符号なしの大きな値を <code class="literal">BIGINT</code> カラムに格納するために整数を使用するとき。
                  </p></li><li class="listitem"><p>
                    <code class="literal">MIN(<em class="replaceable"><code>col_name</code></em>)</code> または <code class="literal">MAX(<em class="replaceable"><code>col_name</code></em>)</code> 内。ここで <em class="replaceable"><code>col_name</code></em> は <code class="literal">BIGINT</code> カラムを指します。
                  </p></li><li class="listitem"><p>
                    演算子 (<code class="literal">+</code>、<code class="literal">-</code>、<code class="literal">*</code> など) を使用する場合。ここで両方のオペランドは整数です。
                  </p></li></ul></div></li><li class="listitem"><p>
                文字列を使用して格納すると、いつでも正確な整数値を <code class="literal">BIGINT</code> カラムに格納できます。この場合、MySQL は、中間倍精度表現を含まない文字列から数値に変換します。
              </p></li><li class="listitem"><p>
                両方のオペランドが整数値の場合、<code class="literal">-</code>、<code class="literal">+</code>、および <code class="literal">*</code> の演算子は、<code class="literal">BIGINT</code> 演算を使用します。これは、2 つの大きい整数 (または整数を返す関数からの結果) を掛け合わした場合、その結果が <code class="literal">9223372036854775807</code> より大きいときには、予期しない結果になるということを意味します。
              </p></li></ul></div></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979104339280"></a> <a class="indexterm" name="idm139979104337792"></a> <code class="literal">DECIMAL[(<em class="replaceable"><code>M</code></em>[,<em class="replaceable"><code>D</code></em>])] [UNSIGNED] [ZEROFILL]</code>
          </p><p>
            パックされた<span class="quote">「<span class="quote">正確な</span>」</span>固定小数点数。<em class="replaceable"><code>M</code></em> は桁数の合計 (精度) で、<em class="replaceable"><code>D</code></em> は小数点以下の桁数 (スケール) です。小数点と、負の数に対する<span class="quote">「<span class="quote"><code class="literal">-</code></span>」</span>の記号は <em class="replaceable"><code>M</code></em> にはカウントされません。<em class="replaceable"><code>D</code></em> が 0 のときは、小数点や小数部はありません。<code class="literal">DECIMAL</code> の最大桁数 (<em class="replaceable"><code>M</code></em>) は 65 です。サポートされる小数部の最大桁数 (<em class="replaceable"><code>D</code></em>) は 30 です。<em class="replaceable"><code>D</code></em> が省略された場合のデフォルトは 0 です。<em class="replaceable"><code>M</code></em> が省略された場合のデフォルトは 10 です。
          </p><p>
            <code class="literal">UNSIGNED</code> が指定されている場合、負の値は許可されません。
          </p><p>
            <code class="literal">DECIMAL</code> カラムを使用したすべての基本的な計算 (<code class="literal">+, -, *, /</code>) は、65 桁の精度で行われます。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979104320464"></a> <a class="indexterm" name="idm139979104318992"></a> <a class="indexterm" name="idm139979104317616"></a> <a class="indexterm" name="idm139979104316256"></a> <a class="indexterm" name="idm139979104314400"></a> <a class="indexterm" name="idm139979104312368"></a> <code class="literal">DEC[(<em class="replaceable"><code>M</code></em>[,<em class="replaceable"><code>D</code></em>])] [UNSIGNED] [ZEROFILL]</code>, <code class="literal">NUMERIC[(<em class="replaceable"><code>M</code></em>[,<em class="replaceable"><code>D</code></em>])] [UNSIGNED] [ZEROFILL]</code>, <code class="literal">FIXED[(<em class="replaceable"><code>M</code></em>[,<em class="replaceable"><code>D</code></em>])] [UNSIGNED] [ZEROFILL]</code>
          </p><p>
            これらの型は <code class="literal">DECIMAL</code> のシノニムです。<code class="literal">FIXED</code> シノニムは、ほかのデータベースシステムとの互換性のために使用できます。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979104298960"></a> <a class="indexterm" name="idm139979104297488"></a> <code class="literal">FLOAT[(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)] [UNSIGNED] [ZEROFILL]</code>
          </p><p>
            小さい (単精度) 浮動小数点数。許可される値は、<code class="literal">-3.402823466E+38</code> から <code class="literal">-1.175494351E-38</code>、<code class="literal">0</code>、および <code class="literal">1.175494351E-38</code> から <code class="literal">3.402823466E+38</code> です。これらは、IEEE スタンダードに基づいた理論的な限度です。使用しているハードウェアまたはオペレーティングシステムによっては、実際の範囲は少し小さくなる場合があります。
          </p><p>
            <em class="replaceable"><code>M</code></em> は桁数の合計で、<em class="replaceable"><code>D</code></em> は小数点以下の桁数です。<em class="replaceable"><code>M</code></em> と <em class="replaceable"><code>D</code></em> を省略した場合、値はハードウェアで許可された限度まで格納されます。単精度小数点数はおおよそ小数第 7 位まで正確です。
          </p><p>
            <code class="literal">UNSIGNED</code> が指定されている場合、負の値は許可されません。
          </p><p>
            MySQL ではすべての計算が倍精度で行われているので、<code class="literal">FLOAT</code> を使用すると、予想外の問題が起きることがあります。<a class="xref" href="error-handling.html#no-matching-rows" title="B.5.5.7 一致する行がない場合の問題の解決">セクションB.5.5.7「一致する行がない場合の問題の解決」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979104279520"></a> <a class="indexterm" name="idm139979104278048"></a> <a class="indexterm" name="idm139979104276688"></a> <a class="indexterm" name="idm139979104274768"></a> <code class="literal">DOUBLE[(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)] [UNSIGNED] [ZEROFILL]</code>
          </p><p>
            普通サイズ (倍精度) の浮動小数点数。許可されている値は、<code class="literal">-1.7976931348623157E+308</code> から <code class="literal">-2.2250738585072014E-308</code>、<code class="literal">0</code>、および <code class="literal">2.2250738585072014E-308</code> から <code class="literal">1.7976931348623157E+308</code> です。これらは、IEEE スタンダードに基づいた理論的な限度です。使用しているハードウェアまたはオペレーティングシステムによっては、実際の範囲は少し小さくなる場合があります。
          </p><p>
            <em class="replaceable"><code>M</code></em> は桁数の合計で、<em class="replaceable"><code>D</code></em> は小数点以下の桁数です。<em class="replaceable"><code>M</code></em> と <em class="replaceable"><code>D</code></em> を省略した場合、値はハードウェアで許可された限度まで格納されます。倍精度小数点数はおおよそ小数第 15 位まで正確です。
          </p><p>
            <code class="literal">UNSIGNED</code> が指定されている場合、負の値は許可されません。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979104259888"></a> <a class="indexterm" name="idm139979104258368"></a> <a class="indexterm" name="idm139979104257008"></a> <a class="indexterm" name="idm139979104255088"></a> <code class="literal">DOUBLE PRECISION[(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)] [UNSIGNED] [ZEROFILL]</code>, <code class="literal">REAL[(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)] [UNSIGNED] [ZEROFILL]</code>
          </p><p>
            これらの型は <code class="literal">DOUBLE</code> のシノニムです。例外: <code class="literal">REAL_AS_FLOAT</code> SQL モードが有効な場合は、<code class="literal">DOUBLE</code> ではなく <code class="literal">REAL</code> が <code class="literal">FLOAT</code> のシノニムになります。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979104242576"></a> <a class="indexterm" name="idm139979104241104"></a> <a class="indexterm" name="idm139979104239744"></a> <code class="literal">FLOAT(<em class="replaceable"><code>p</code></em>) [UNSIGNED] [ZEROFILL]</code>
          </p><p>
            浮動小数点数です。<em class="replaceable"><code>p</code></em> は精度をビットで表現しますが、MySQL は、結果として得られるデータ型に対して <code class="literal">FLOAT</code> または <code class="literal">DOUBLE</code> のどちらを使用するかを決めるためだけにこの値を使用します。<em class="replaceable"><code>p</code></em> が 0 から 24 のとき、そのデータ型は <em class="replaceable"><code>M</code></em> 値も <em class="replaceable"><code>D</code></em> 値もない <code class="literal">FLOAT</code> になります。<em class="replaceable"><code>p</code></em> が 25 から 53 のとき、そのデータ型は <em class="replaceable"><code>M</code></em> 値も <em class="replaceable"><code>D</code></em> 値もない <code class="literal">DOUBLE</code> になります。結果となるカラムの範囲は、このセクションで前述した単精度 <code class="literal">FLOAT</code> または倍精度 <code class="literal">DOUBLE</code> データ型の場合と同じです。
          </p><p>
            <a class="indexterm" name="idm139979104225776"></a> <a class="indexterm" name="idm139979104224272"></a> <code class="literal">FLOAT(<em class="replaceable"><code>p</code></em>)</code> 構文は ODBC との互換性を確保するために用意されています。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="date-and-time-type-overview"></a>11.1.2 日付と時間型の概要</h3></div></div></div><p>
        時間データ型のサマリーについて説明します。時間型のプロパティーおよびストレージ要件の追加情報については、<a class="xref" href="data-types.html#date-and-time-types" title="11.3 日付と時間型">セクション11.3「日付と時間型」</a>および<a class="xref" href="data-types.html#storage-requirements" title="11.7 データ型のストレージ要件">セクション11.7「データ型のストレージ要件」</a>を参照してください。時間値を演算する関数の説明については、<a class="xref" href="functions.html#date-and-time-functions" title="12.7 日付および時間関数">セクション12.7「日付および時間関数」</a>を参照してください。
      </p><p>
        <code class="literal">DATE</code> および <code class="literal">DATETIME</code> 範囲の説明では、<span class="quote">「<span class="quote">サポートされている</span>」</span>とは、以前の値は機能するが、保証はないことを意味します。
      </p><a class="indexterm" name="idm139979104213360"></a><a class="indexterm" name="idm139979104211888"></a><p>
        MySQL 5.6.4 以降では、マイクロ秒 (6 桁) までの精度を持つ <code class="literal">TIME</code>、<code class="literal">DATETIME</code>、および <code class="literal">TIMESTAMP</code> 値の小数秒に対応できるようになりました。小数秒部を含むカラムを定義するには、<code class="literal"><em class="replaceable"><code>type_name</code></em>(<em class="replaceable"><code>fsp</code></em>)</code> の構文を使用します。ここで、<em class="replaceable"><code>type_name</code></em> は <code class="literal">TIME</code>、<code class="literal">DATETIME</code>、または <code class="literal">TIMESTAMP</code> であり、<em class="replaceable"><code>fsp</code></em> は小数秒の精度です。例:
      </p><pre class="programlisting">
CREATE TABLE t1 (t TIME(3), dt DATETIME(6));
</pre><p>
        <em class="replaceable"><code>fsp</code></em> 値を指定する場合、0 から 6 の範囲にする必要があります。0 の値は、小数部がないことを表します。省略した場合、デフォルトの精度は 0 です。(これは、以前の MySQL バージョンと互換性を保つため、標準 SQL のデフォルトである 6 とは異なっています。)
      </p><p>
        MySQL 5.6.5 には、時間型の拡張された自動初期化および更新機能が導入されました。テーブルごとに最大 1 つのカラムではなく、テーブル内のすべての <code class="literal">TIMESTAMP</code> カラムにこれらのプロパティーを割り当てられます。さらに、これらのプロパティーは、<code class="literal">DATETIME</code> カラムで使用できるようになりました。
      </p><p>
        <code class="literal">YEAR(2)</code> データ型には、使用する前に考慮する必要のある特定の問題があります。MySQL 5.6.6 以降、<code class="literal">YEAR(2)</code> は非推奨です。既存のテーブル内の <code class="literal">YEAR(2)</code> カラムは以前のとおりに扱われますが、新規または変更したテーブルでは <code class="literal">YEAR(2)</code> は <code class="literal">YEAR(4)</code> に変換されます。詳細は、<a class="xref" href="data-types.html#migrating-to-year4" title="11.3.4 YEAR(2) の制限と YEAR(4) への移行">セクション11.3.4「YEAR(2) の制限と YEAR(4) への移行」</a>を参照してください。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <a class="indexterm" name="idm139979104187568"></a> <a class="indexterm" name="idm139979104186096"></a> <code class="literal">DATE</code>
          </p><p>
            日付です。サポートしている範囲は <code class="literal">'1000-01-01'</code> から <code class="literal">'9999-12-31'</code> です。MySQL は <code class="literal">'YYYY-MM-DD'</code> の形式で <code class="literal">DATE</code> 値を表示しますが、文字列または数値のどちらかを使用した <code class="literal">DATE</code> カラムへの値の割り当てを許可しています。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979104175600"></a> <a class="indexterm" name="idm139979104174112"></a> <code class="literal">DATETIME[(<em class="replaceable"><code>fsp</code></em>)]</code>
          </p><p>
            日付と時間の組み合わせです。サポートしている範囲は <code class="literal">'1000-01-01 00:00:00.000000'</code> から <code class="literal">'9999-12-31 23:59:59.999999'</code> です。MySQL は、<code class="literal">'YYYY-MM-DD HH:MM:SS[.fraction]'</code> の形式で <code class="literal">DATETIME</code> 値を表示しますが、文字列または数値のどちらかを使用した <code class="literal">DATETIME</code> カラムへの値の割り当てを許可しています。
          </p><p>
            MySQL 5.6.4 以降では、小数秒の精度を指定するために 0 から 6 の範囲でオプションの <em class="replaceable"><code>fsp</code></em> 値を指定できます。0 の値は、小数部がないことを表します。省略した場合、デフォルトの精度は 0 です。
          </p><p>
            MySQL 5.6.5 以降、<code class="literal">DATETIME</code> カラムに対する自動初期化および現在の日時への自動更新は、<a class="xref" href="data-types.html#timestamp-initialization" title="11.3.5 TIMESTAMP および DATETIME の自動初期化および更新機能">セクション11.3.5「TIMESTAMP および DATETIME の自動初期化および更新機能」</a>で説明しているように、<code class="literal">DEFAULT</code> および <code class="literal">ON UPDATE</code> カラム定義句を使用して指定できます。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979104157184"></a> <a class="indexterm" name="idm139979104155680"></a> <code class="literal">TIMESTAMP[(<em class="replaceable"><code>fsp</code></em>)]</code>
          </p><p>
            タイムスタンプです。範囲は <code class="literal">'1970-01-01 00:00:01.000000'</code> UTC から <code class="literal">'2038-01-19 03:14:07.999999'</code> UTC です。<code class="literal">TIMESTAMP</code> 値は、エポック (<code class="literal">'1970-01-01 00:00:00'</code> UTC) からの秒数として格納されます。<code class="literal">TIMESTAMP</code> は、<code class="literal">'1970-01-01 00:00:00'</code> という値を表すことはできません。これは、エポックからの秒数が 0 であることと同等で、0 という値は <code class="literal">'0000-00-00 00:00:00'</code>、つまり<span class="quote">「<span class="quote">ゼロ</span>」</span>の <code class="literal">TIMESTAMP</code> 値を表すために予約されているからです。
          </p><p>
            MySQL 5.6.4 以降では、小数秒の精度を指定するために 0 から 6 の範囲でオプションの <em class="replaceable"><code>fsp</code></em> 値を指定できます。0 の値は、小数部がないことを表します。省略した場合、デフォルトの精度は 0 です。
          </p><p>
            サーバーで <code class="literal">TIMESTAMP</code> 定義をどのように扱うかは、<code class="literal">explicit_defaults_for_timestamp</code> システム変数の値によって異なります (<a class="xref" href="server-administration.html#server-system-variables" title="5.1.4 サーバーシステム変数">セクション5.1.4「サーバーシステム変数」</a>を参照してください)。デフォルトでは、<code class="literal">explicit_defaults_for_timestamp</code> は無効であり、サーバーは次のように <code class="literal">TIMESTAMP</code> を扱います。
          </p><p>
            特に指定されていないかぎり、テーブル内の最初の <code class="literal">TIMESTAMP</code> カラムは、明示的に値が割り当てられていなければもっとも新しい変更の日時に自動的に設定されるように定義されています。これにより、<code class="literal">TIMESTAMP</code> は、<code class="literal">INSERT</code> または <code class="literal">UPDATE</code> 操作のタイムスタンプの記録に役立ちます。<code class="literal">NULL</code> 値を許可するように <code class="literal">NULL</code> 属性で定義されていないかぎり、<code class="literal">NULL</code> 値を割り当てることによって、すべての <code class="literal">TIMESTAMP</code> カラムを現在の日付と時間に設定することもできます。
          </p><p>
            自動初期化および現在の日付と時間への自動更新は、<code class="literal">DEFAULT CURRENT_TIMESTAMP</code> および <code class="literal">ON UPDATE CURRENT_TIMESTAMP</code> カラム定義句を使用して指定できます。デフォルトでは、前述のように最初の <code class="literal">TIMESTAMP</code> カラムにこれらのプロパティーが含まれます。MySQL 5.6.5 以降では、テーブル内のどの <code class="literal">TIMESTAMP</code> カラムでもこれらのプロパティーを割り当てるように定義できます。5.6.5 より前では、これらを割り当てられる <code class="literal">TIMESTAMP</code> カラムはテーブルごとに最大 1 つにかぎられますが、最初のカラムでは抑制し、代わりに別の <code class="literal">TIMESTAMP</code> カラムに割り当てることが可能です。<a class="xref" href="data-types.html#timestamp-initialization" title="11.3.5 TIMESTAMP および DATETIME の自動初期化および更新機能">セクション11.3.5「TIMESTAMP および DATETIME の自動初期化および更新機能」</a>を参照してください。
          </p><p>
            <code class="literal">explicit_defaults_for_timestamp</code> が有効な場合、すべての <code class="literal">TIMESTAMP</code> カラムへの <code class="literal">DEFAULT CURRENT_TIMESTAMP</code> または <code class="literal">ON UPDATE CURRENT_TIMESTAMP</code> 属性の自動的な割り当ては行われません。これらはカラム定義に明示的に含める必要があります。また、<code class="literal">NOT NULL</code> として明示的に宣言されていないすべての <code class="literal">TIMESTAMP</code> は、<code class="literal">NULL</code> 値を許可します。
          </p><p>
            <code class="literal">explicit_defaults_for_timestamp</code> は、MySQL 5.6.6 以降で使用できます。5.6.6 より前では、サーバーは、<code class="literal">explicit_defaults_for_timestamp</code> が無効の場合について説明したように <code class="literal">TIMESTAMP</code> を扱います。これらの動作は、デフォルトのままになっていますが、標準外であり、5.6.6 以降では非推奨です。<code class="literal">explicit_defaults_for_timestamp</code> を有効化したインストールのアップグレードに関する説明については、<a class="xref" href="installing.html#upgrading-from-previous-series" title="2.11.1.3 MySQL 5.5 から 5.6 へのアップグレード">セクション2.11.1.3「MySQL 5.5 から 5.6 へのアップグレード」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979104105712"></a> <a class="indexterm" name="idm139979104104240"></a> <code class="literal">TIME[(<em class="replaceable"><code>fsp</code></em>)]</code>
          </p><p>
            時間です。範囲は、<code class="literal">'-838:59:59.000000'</code> から <code class="literal">'838:59:59.000000'</code> です。MySQL は、<code class="literal">'HH:MM:SS[.fraction]'</code> 形式で <code class="literal">TIME</code> 値を表示しますが、文字列または数値のどちらかを使用した <code class="literal">TIME</code> カラムの値への割り当てを許可します。
          </p><p>
            MySQL 5.6.4 以降では、小数秒の精度を指定するために 0 から 6 の範囲でオプションの <em class="replaceable"><code>fsp</code></em> 値を指定できます。0 の値は、小数部がないことを表します。省略した場合、デフォルトの精度は 0 です。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979104092080"></a> <a class="indexterm" name="idm139979104090608"></a> <code class="literal">YEAR[(2|4)]</code>
          </p><p>
            2 桁または 4 桁の形式の年です。デフォルトは 4 桁の形式です。<code class="literal">YEAR(2)</code> と <code class="literal">YEAR(4)</code> は表示形式が違いますが、値の範囲は同じです。4 桁の形式では、値は <code class="literal">1901</code> から <code class="literal">2155</code> と <code class="literal">0000</code> として表示されます。2 桁の形式では、値は <code class="literal">70</code> から <code class="literal">69</code> として表示され、1970 から 2069 の年を表します。MySQL では、<code class="literal">YEAR</code> 値は <code class="literal">YYYY</code> または <code class="literal">YY</code> の形式で表示されますが、文字列または数値を使用して <code class="literal">YEAR</code> カラムに値を割り当てられます。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              <code class="literal">YEAR(2)</code> データ型には、使用する前に考慮する必要のある特定の問題があります。MySQL 5.6.6 以降、<code class="literal">YEAR(2)</code> は非推奨です。既存のテーブル内の <code class="literal">YEAR(2)</code> カラムは以前のとおりに扱われますが、新規または変更したテーブルでは <code class="literal">YEAR(2)</code> は <code class="literal">YEAR(4)</code> に変換されます。詳細は、<a class="xref" href="data-types.html#migrating-to-year4" title="11.3.4 YEAR(2) の制限と YEAR(4) への移行">セクション11.3.4「YEAR(2) の制限と YEAR(4) への移行」</a>を参照してください。
            </p></div><p>
            入力値の <code class="literal">YEAR</code> の表示形式および解釈に関する追加情報については、<a class="xref" href="data-types.html#year" title="11.3.3 YEAR 型">セクション11.3.3「YEAR 型」</a>を参照してください。
          </p></li></ul></div><p>
        <code class="literal">SUM()</code> および <code class="literal">AVG()</code> 集計関数は時間値を扱いません。(これらは値を数字に変換するので、最初の数字以外の文字のあとのすべての情報が失われます。)この問題を回避するには、数値単位に変換し、集計操作を実行してから、時間値に戻します。例:
      </p><pre class="programlisting">
SELECT SEC_TO_TIME(SUM(TIME_TO_SEC(<em class="replaceable"><code>time_col</code></em>))) FROM <em class="replaceable"><code>tbl_name</code></em>;
SELECT FROM_DAYS(SUM(TO_DAYS(<em class="replaceable"><code>date_col</code></em>))) FROM <em class="replaceable"><code>tbl_name</code></em>;
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          MySQL Server は、<code class="literal">MAXDB</code> SQL モードを有効にして実行できます。この場合、<code class="literal">TIMESTAMP</code> は <code class="literal">DATETIME</code> と同じです。テーブルの作成時にこのモードが有効になっている場合、<code class="literal">TIMESTAMP</code> カラムは <code class="literal">DATETIME</code> カラムとして作成されます。その結果、このようなカラムでは <code class="literal">DATETIME</code> 表示形式が使用され、値の範囲は同じになり、自動初期化や現在の日付と時間への自動更新は行われなくなります。<a class="xref" href="server-administration.html#sql-mode" title="5.1.7 サーバー SQL モード">セクション5.1.7「サーバー SQL モード」</a>を参照してください。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="string-type-overview"></a>11.1.3 文字列型の概要</h3></div></div></div><p>
        文字列データ型のサマリーについて説明します。文字列型のプロパティーおよびストレージ要件の追加情報については、<a class="xref" href="data-types.html#string-types" title="11.4 文字列型">セクション11.4「文字列型」</a>および<a class="xref" href="data-types.html#storage-requirements" title="11.7 データ型のストレージ要件">セクション11.7「データ型のストレージ要件」</a>を参照してください。
      </p><p>
        MySQL は、文字列カラムを <code class="literal">CREATE TABLE</code> または <code class="literal">ALTER TABLE</code> ステートメントで与えられている型とは異なる型に変更することがあります。<a class="xref" href="sql-syntax.html#silent-column-changes" title="13.1.17.3 暗黙のカラム指定の変更">セクション13.1.17.3「暗黙のカラム指定の変更」</a>を参照してください。
      </p><p>
        MySQL は、文字カラム定義の長さ指定を文字単位で解釈します。これは、<code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、および <code class="literal">TEXT</code> 型に適応されます。
      </p><p>
        多くの文字列データ型のカラム定義には、カラムの文字セットまたは照合順序を指定する属性を含めることができます。これらの属性は <code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、<code class="literal">TEXT</code> 型、<code class="literal">ENUM</code>、および <code class="literal">SET</code> データ型に適用されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">CHARACTER SET</code> 属性は文字セットを指定し、<code class="literal">COLLATE</code> 属性は文字セットの照合順序を指定します。例:
          </p><pre class="programlisting">
CREATE TABLE t
(
    c1 VARCHAR(20) CHARACTER SET utf8,
    c2 TEXT CHARACTER SET latin1 COLLATE latin1_general_cs
);
</pre><p>
            このテーブル定義は、<code class="literal">utf8</code> の文字セットとその文字セットのデフォルト照合順序を持つ <code class="literal">c1</code> という名前のカラムと、<code class="literal">latin1</code> の文字セットと大文字と小文字を区別する照合順序を持つ <code class="literal">c2</code> という名前のカラムを作成します。
          </p><p>
            <code class="literal">CHARACTER SET</code> 属性または <code class="literal">COLLATE</code> 属性、あるいはその両方がない場合に、文字セットや照合順序を割り当てるためのルールは、<a class="xref" href="globalization.html#charset-column" title="10.1.3.4 カラム文字セットおよび照合順序">セクション10.1.3.4「カラム文字セットおよび照合順序」</a>で説明しています。
          </p><p>
            <code class="literal">CHARSET</code> は <code class="literal">CHARACTER SET</code> のシノニムです。
          </p></li><li class="listitem"><p>
            文字データ型に <code class="literal">CHARACTER SET binary</code> 属性を指定すると、カラムは対応するバイナリデータ型として作成されます。つまり、<code class="literal">CHAR</code> は <code class="literal">BINARY</code> になり、<code class="literal">VARCHAR</code> は <code class="literal">VARBINARY</code> になり、<code class="literal">TEXT</code> は <code class="literal">BLOB</code> になります。<code class="literal">ENUM</code> および <code class="literal">SET</code> データ型では、これは行われず、宣言されたとおりに作成されます。この定義を使用して、テーブルを指定したとします。
          </p><pre class="programlisting">
CREATE TABLE t
(
  c1 VARCHAR(10) CHARACTER SET binary,
  c2 TEXT CHARACTER SET binary,
  c3 ENUM('a','b','c') CHARACTER SET binary
);
</pre><p>
            結果のテーブルには、この定義が含まれています。
          </p><pre class="programlisting">
CREATE TABLE t
(
  c1 VARBINARY(10),
  c2 BLOB,
  c3 ENUM('a','b','c') CHARACTER SET binary
);
</pre></li><li class="listitem"><p>
            <code class="literal">ASCII</code> 属性は <code class="literal">CHARACTER SET latin1</code> の短縮形です。
          </p></li><li class="listitem"><p>
            <code class="literal">UNICODE</code> 属性は <code class="literal">CHARACTER SET ucs2</code> の短縮形です。
          </p></li><li class="listitem"><p>
            <code class="literal">BINARY</code> 属性は、カラム文字セットのバイナリ照合順序を指定する短縮形です。この場合、ソートと比較は数字の値に基づきます。
          </p></li></ul></div><p>
        文字カラムのソートと比較は、カラムに割り当てられた文字セットに基づきます。<code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、<code class="literal">TEXT</code>、<code class="literal">ENUM</code>、および <code class="literal">SET</code> データ型では、辞書順ではなくベースとなる文字コード値をソートおよび比較で使用できるように、バイナリ照合順序または <code class="literal">BINARY</code> 属性を持つカラムを宣言できます。
      </p><p>
        <a class="xref" href="globalization.html#charset" title="10.1 文字セットのサポート">セクション10.1「文字セットのサポート」</a>では、MySQL の文字セットの使用に関する追加情報が記述されています。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <a class="indexterm" name="idm139979103997760"></a> <a class="indexterm" name="idm139979103996288"></a> <a class="indexterm" name="idm139979103994896"></a> <a class="indexterm" name="idm139979103993536"></a> <a class="indexterm" name="idm139979103992144"></a> <a class="indexterm" name="idm139979103990224"></a> <a class="indexterm" name="idm139979103988192"></a> <a class="indexterm" name="idm139979103986160"></a> <code class="literal">[NATIONAL] CHAR[(<em class="replaceable"><code>M</code></em>)] [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>] [COLLATE <em class="replaceable"><code>collation_name</code></em>]</code>
          </p><p>
            格納時に必ず、指定された長さになるように右側がスペースで埋められる固定長文字列です。<em class="replaceable"><code>M</code></em> はカラムの長さを文字数で表します。<em class="replaceable"><code>M</code></em> の範囲は 0 から 255 です。<em class="replaceable"><code>M</code></em> を省略すると、長さは 1 になります。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              <code class="literal">PAD_CHAR_TO_FULL_LENGTH</code> SQL モードが有効になっていないかぎり、<code class="literal">CHAR</code> 値が取り出されるときに末尾のスペースは削除されます。
            </p></div><p>
            <code class="literal">CHAR</code> は <code class="literal">CHARACTER</code> の短縮形です。<code class="literal">NATIONAL CHAR</code> (またはそれと同等の短縮形である <code class="literal">NCHAR</code>) は、<code class="literal">CHAR</code> カラムが事前に定義された文字セットを使用する必要があることを定義する標準 SQL の方法です。MySQL 4.1 以降では、この事前に定義された文字セットとして <code class="literal">utf8</code> を使用します。<a class="xref" href="globalization.html#charset-national" title="10.1.3.6 各国文字セット">セクション10.1.3.6「各国文字セット」</a>を参照してください。
          </p><p>
            <code class="literal">CHAR BYTE</code> データ型は <code class="literal">BINARY</code> データ型のエイリアスです。これは互換性機能です。
          </p><p>
            MySQL では、<code class="literal">CHAR(0)</code> の型のカラムを作成できます。これは主に、カラムの存在に依存するが、実際にはその値を使用しない古いアプリケーションに準拠する必要があるときに役立ちます。<code class="literal">CHAR(0)</code> は、2 つの値しか取れないカラムが必要な場合にも非常に便利です。<code class="literal">CHAR(0) NULL</code> として定義されたカラムは 1 ビットだけを占め、<code class="literal">NULL</code> と <code class="literal">''</code> (空の文字列) 値だけを取ることができます。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979103956256"></a> <a class="indexterm" name="idm139979103954768"></a> <a class="indexterm" name="idm139979103953360"></a> <a class="indexterm" name="idm139979103951968"></a> <a class="indexterm" name="idm139979103950576"></a> <a class="indexterm" name="idm139979103949168"></a> <a class="indexterm" name="idm139979103947792"></a> <a class="indexterm" name="idm139979103945872"></a> <a class="indexterm" name="idm139979103943840"></a> <a class="indexterm" name="idm139979103941808"></a> <a class="indexterm" name="idm139979103939776"></a> <a class="indexterm" name="idm139979103937744"></a> <code class="literal">[NATIONAL] VARCHAR(<em class="replaceable"><code>M</code></em>) [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>] [COLLATE <em class="replaceable"><code>collation_name</code></em>]</code>
          </p><p>
            可変長文字列です。<em class="replaceable"><code>M</code></em> はカラムの最大長を文字数で表します。<em class="replaceable"><code>M</code></em> の範囲は 0 から 65,535 です。<code class="literal">VARCHAR</code> の有効な最大長は、最大行サイズ (65,535 バイト、すべてのカラムで共有されます) と使用される文字セットによって決まります。たとえば、<code class="literal">utf8</code> の文字は 1 文字につき最大 3 バイトを必要とする場合があるため、<code class="literal">utf8</code> の文字セットを使用する <code class="literal">VARCHAR</code> カラムは、最大 21,844 文字になるように宣言できます。<a class="xref" href="restrictions.html#column-count-limit" title="D.10.4 テーブルカラム数と行サイズの制限">セクションD.10.4「テーブルカラム数と行サイズの制限」</a>を参照してください。
          </p><p>
            MySQL は、<code class="literal">VARCHAR</code> 値を 1 バイトまたは 2 バイト長のプリフィクスが付いたデータとして格納します。長さプリフィクスは、値に含まれるバイト数を示します。<code class="literal">VARCHAR</code> カラムは、格納できる値が 255 バイト以下の場合は 1 バイト長のプリフィクスを使用し、255 バイトより大きい場合は 2 バイト長のプリフィクスを使用します。
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
              MySQL 5.6 は、標準 SQL 仕様に従い、<code class="literal">VARCHAR</code> 値から末尾のスペースを削除<span class="emphasis"><em>しません</em></span>。
            </p></div><p>
            <code class="literal">VARCHAR</code> は <code class="literal">CHARACTER VARYING</code> の短縮形です。<code class="literal">NATIONAL VARCHAR</code> は、<code class="literal">VARCHAR</code> カラムが事前定義された文字セットを使用する必要があることを定義するための標準 SQL の方法です。MySQL 4.1 以降では、この事前に定義された文字セットとして <code class="literal">utf8</code> を使用します。<a class="xref" href="globalization.html#charset-national" title="10.1.3.6 各国文字セット">セクション10.1.3.6「各国文字セット」</a>を参照してください。<code class="literal">NVARCHAR</code> は <code class="literal">NATIONAL VARCHAR</code> の短縮形です。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979103910720"></a> <a class="indexterm" name="idm139979103909248"></a> <code class="literal">BINARY(<em class="replaceable"><code>M</code></em>)</code>
          </p><p>
            <code class="literal">BINARY</code> 型は <code class="literal">CHAR</code> 型と似ていますが、非バイナリ文字列ではなく、バイナリバイト文字列を格納します。<em class="replaceable"><code>M</code></em> はカラムの長さをバイト数で表します。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979103900240"></a> <a class="indexterm" name="idm139979103898736"></a> <code class="literal">VARBINARY(<em class="replaceable"><code>M</code></em>)</code>
          </p><p>
            <code class="literal">VARBINARY</code> 型は <code class="literal">VARCHAR</code> 型と似ていますが、非バイナリ文字列ではなく、バイナリバイト文字列を格納します。<em class="replaceable"><code>M</code></em> はカラムの最大の長さをバイト数で表します。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979103889712"></a> <a class="indexterm" name="idm139979103888224"></a> <code class="literal">TINYBLOB</code>
          </p><p>
            最大長が 255 (2<sup>8</sup> − 1) バイトの <code class="literal">BLOB</code> カラム。各 <code class="literal">TINYBLOB</code> 値は、値のバイト数を示す 1 バイト長のプリフィクスを使用して格納されます。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979103879584"></a> <a class="indexterm" name="idm139979103878096"></a> <code class="literal">TINYTEXT [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>] [COLLATE <em class="replaceable"><code>collation_name</code></em>]</code>
          </p><p>
            最大長が 255 (2<sup>8</sup> − 1) 文字の <code class="literal">TEXT</code> カラム。値にマルチバイト文字が含まれる場合、有効な最大長は少なくなります。各 <code class="literal">TINYTEXT</code> 値は、値のバイト数を示す 1 バイト長のプリフィクスを使用して格納されます。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979103868112"></a> <a class="indexterm" name="idm139979103866640"></a> <code class="literal">BLOB[(<em class="replaceable"><code>M</code></em>)]</code>
          </p><p>
            最大長が 65,535 (2<sup>16</sup> − 1) バイトの <code class="literal">BLOB</code> カラム。各 <code class="literal">BLOB</code> 値は、値のバイト数を示す 2 バイト長のプリフィクスを使用して格納されます。
          </p><p>
            この型には、オプションの長さ <em class="replaceable"><code>M</code></em> を指定できます。これが行われた場合、MySQL は <em class="replaceable"><code>M</code></em> バイトの長さの値を保持するのに十分な最小の <code class="literal">BLOB</code> 型としてカラムを作成します。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979103854960"></a> <a class="indexterm" name="idm139979103853488"></a> <code class="literal">TEXT[(<em class="replaceable"><code>M</code></em>)] [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>] [COLLATE <em class="replaceable"><code>collation_name</code></em>]</code>
          </p><p>
            最大長が 65,535 (2<sup>16</sup> − 1) 文字の <code class="literal">TEXT</code> カラム。値にマルチバイト文字が含まれる場合、有効な最大長は少なくなります。各 <code class="literal">TEXT</code> 値は、値のバイト数を示す 2 バイト長のプリフィクスを使用して格納されます。
          </p><p>
            この型には、オプションの長さ <em class="replaceable"><code>M</code></em> を指定できます。これが行われた場合、MySQL は <em class="replaceable"><code>M</code></em> 文字の長さの値を保持するのに十分な最小 <code class="literal">TEXT</code> 型としてカラムを作成します。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979103840736"></a> <a class="indexterm" name="idm139979103839232"></a> <code class="literal">MEDIUMBLOB</code>
          </p><p>
            最大長が 16,777,215 (2<sup>24</sup> − 1) バイトの <code class="literal">BLOB</code> カラム。各 <code class="literal">MEDIUMBLOB</code> 値は、値のバイト数を示す 3 バイト長のプリフィクスを使用して格納されます。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979103830576"></a> <a class="indexterm" name="idm139979103829072"></a> <code class="literal">MEDIUMTEXT [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>] [COLLATE <em class="replaceable"><code>collation_name</code></em>]</code>
          </p><p>
            最大長が 16,777,215 (2<sup>24</sup> − 1) 文字の <code class="literal">TEXT</code> カラム。値にマルチバイト文字が含まれる場合、有効な最大長は少なくなります。各 <code class="literal">MEDIUMTEXT</code> 値は、値のバイト数を示す 3 バイト長のプリフィクスを使用して格納されます。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979103818368"></a> <a class="indexterm" name="idm139979103816880"></a> <code class="literal">LONGBLOB</code>
          </p><p>
            最大長が 4,294,967,295 または 4G バイト (2<sup>32</sup> − 1) バイトの <code class="literal">BLOB</code> カラム。<code class="literal">LONGBLOB</code> カラムの有効な最大長は、クライアント/サーバープロトコルと使用可能なメモリー内の構成済み最大パケットサイズにより決まります。各 <code class="literal">LONGBLOB</code> 値は、値のバイト数を示す 4 バイト長のプリフィクスを使用して格納されます。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979103806816"></a> <a class="indexterm" name="idm139979103805328"></a> <code class="literal">LONGTEXT [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>] [COLLATE <em class="replaceable"><code>collation_name</code></em>]</code>
          </p><p>
            最大長が 4,294,967,295 または 4G バイト (2<sup>32</sup> − 1) 文字の <code class="literal">TEXT</code> カラム。値にマルチバイト文字が含まれる場合、有効な最大長は少なくなります。<code class="literal">LONGTEXT</code> カラムの有効な最大長もまた、クライアント/サーバープロトコルと使用可能メモリー内の構成済みの最大パケットサイズにより決まります。各 <code class="literal">LONGTEXT</code> 値は、値のバイト数を示す 4 バイト長のプリフィクスを使用して格納されます。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979103793392"></a> <a class="indexterm" name="idm139979103791920"></a> <code class="literal">ENUM('<em class="replaceable"><code>value1</code></em>','<em class="replaceable"><code>value2</code></em>',...) [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>] [COLLATE <em class="replaceable"><code>collation_name</code></em>]</code>
          </p><p>
            列挙です。<code class="literal">'<em class="replaceable"><code>value1</code></em>'</code>、<code class="literal">'<em class="replaceable"><code>value2</code></em>'</code>、<code class="literal">...</code> の値、<code class="literal">NULL</code>、または特殊な <code class="literal">''</code> エラー値のリストから選択された値を 1 つだけを持つことができる文字列オブジェクトです。<code class="literal">ENUM</code> 値は、内部では整数として表されます。
          </p><p>
            <code class="literal">ENUM</code> カラムには、最大 65,535 個の個別の要素を含めることができます。(実用的な限度は 3000 個までです。)テーブルには、グループと見なされる <code class="literal">ENUM</code> および <code class="literal">SET</code> カラムの中の一意の要素リスト定義を、255 個以下を含めることができます。これらの制限の詳細は、<a class="xref" href="restrictions.html#limits-frm-file" title="D.10.5 .frm ファイル構造により課せられる制限">セクションD.10.5「.frm ファイル構造により課せられる制限」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979103773696"></a> <a class="indexterm" name="idm139979103772224"></a> <code class="literal">SET('<em class="replaceable"><code>value1</code></em>','<em class="replaceable"><code>value2</code></em>',...) [CHARACTER SET <em class="replaceable"><code>charset_name</code></em>] [COLLATE <em class="replaceable"><code>collation_name</code></em>]</code>
          </p><p>
            セットです。ゼロ個以上の値を持つことができる文字列オブジェクトであり、そのそれぞれの値は、<code class="literal">'<em class="replaceable"><code>value1</code></em>'</code>、<code class="literal">'<em class="replaceable"><code>value2</code></em>'</code>、<code class="literal">...</code> 値のリストから選択する必要があります。<code class="literal">SET</code> 値は整数として内部で表されます。
          </p><p>
            <code class="literal">SET</code> カラムには最大 64 個の個別のメンバーを含めることができます。テーブルには、グループと見なされる <code class="literal">ENUM</code> および <code class="literal">SET</code> カラムの中の一意の要素リスト定義を、255 個以下を含めることができます。この制限の詳細は、<a class="xref" href="restrictions.html#limits-frm-file" title="D.10.5 .frm ファイル構造により課せられる制限">セクションD.10.5「.frm ファイル構造により課せられる制限」</a>を参照してください。
          </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="numeric-types"></a>11.2 数値型</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="data-types.html#integer-types">11.2.1 整数型 (真数値) - INTEGER、INT、SMALLINT、TINYINT、MEDIUMINT、BIGINT</a></span></dt><dt><span class="section"><a href="data-types.html#fixed-point-types">11.2.2 固定小数点型 (真数値) - DECIMAL、NUMERIC</a></span></dt><dt><span class="section"><a href="data-types.html#floating-point-types">11.2.3 浮動小数点型 (概数値) - FLOAT、DOUBLE</a></span></dt><dt><span class="section"><a href="data-types.html#bit-type">11.2.4 ビット値型 - BIT</a></span></dt><dt><span class="section"><a href="data-types.html#numeric-type-attributes">11.2.5 数値型の属性</a></span></dt><dt><span class="section"><a href="data-types.html#out-of-range-and-overflow">11.2.6 範囲外およびオーバーフローの処理</a></span></dt></dl></div><a class="indexterm" name="idm139979103756192"></a><a class="indexterm" name="idm139979103754848"></a><a class="indexterm" name="idm139979103753504"></a><p>
      MySQL はすべての標準 SQL 数値データ型をサポートします。これらの型は、概数値データ型 (<code class="literal">FLOAT</code>、<code class="literal">REAL</code>、<code class="literal">DOUBLE PRECISION</code>) だけでなく、真数値データ型 (<code class="literal">INTEGER</code>、<code class="literal">SMALLINT</code>、<code class="literal">DECIMAL</code>、<code class="literal">NUMERIC</code>) を含みます。キーワード <code class="literal">INT</code> は <code class="literal">INTEGER</code> のシノニムで、キーワード <code class="literal">DEC</code> および <code class="literal">FIXED</code> は <code class="literal">DECIMAL</code> のシノニムです。MySQL では、<code class="literal">DOUBLE</code> は <code class="literal">DOUBLE PRECISION</code> (非標準の拡張) のシノニムと見なされます。また、<code class="literal">REAL_AS_FLOAT</code> SQL モードが有効でないかぎり、<code class="literal">REAL</code> は <code class="literal">DOUBLE PRECISION</code> (非標準のバリエーション) のシノニムと見なされます。
    </p><p>
      <code class="literal">BIT</code> データ型は、ビットフィールド値を格納し、<code class="literal">MyISAM</code>、<code class="literal">MEMORY</code>、<code class="literal">InnoDB</code>、および <code class="literal">NDB</code> テーブルでサポートされています。
    </p><p>
      範囲外の値のカラムへの割り当てと、式の評価中のオーバーフローに対する MySQL での処理の詳細は、<a class="xref" href="data-types.html#out-of-range-and-overflow" title="11.2.6 範囲外およびオーバーフローの処理">セクション11.2.6「範囲外およびオーバーフローの処理」</a>を参照してください。
    </p><p>
      数値型のストレージの要件の詳細は、<a class="xref" href="data-types.html#storage-requirements" title="11.7 データ型のストレージ要件">セクション11.7「データ型のストレージ要件」</a>を参照してください。
    </p><p>
      数値オペランドで計算の結果に使用されるデータ型は、オペランドの型と実行される演算によって異なります。詳細は、<a class="xref" href="functions.html#arithmetic-functions" title="12.6.1 算術演算子">セクション12.6.1「算術演算子」</a>を参照してください。
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="integer-types"></a>11.2.1 整数型 (真数値) - INTEGER、INT、SMALLINT、TINYINT、MEDIUMINT、BIGINT</h3></div></div></div><p>
        MySQL では、<code class="literal">INTEGER</code> (または <code class="literal">INT</code>) および <code class="literal">SMALLINT</code> の SQL 標準整数型をサポートします。標準に対する拡張として、MySQL では、<code class="literal">TINYINT</code>、<code class="literal">MEDIUMINT</code>、および <code class="literal">BIGINT</code> の整数型もサポートします。次の表に、整数型ごとの必要なストレージと範囲を示します。
      </p><div class="informaltable"><table summary="次の表は、MySQL でサポートする整数型の必要なストレージおよび範囲を示します。" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th scope="col">型</th><th scope="col">ストレージ</th><th scope="col">最小値</th><th scope="col">最大値</th></tr><tr><th scope="col"> </th><th scope="col">(バイト)</th><th scope="col">(符号付き/符号なし)</th><th scope="col">(符号付き/符号なし)</th></tr></thead><tbody><tr><td scope="row"><code class="literal">TINYINT</code></td><td>1</td><td><code class="literal">-128</code></td><td><code class="literal">127</code></td></tr><tr><td scope="row"> </td><td> </td><td><code class="literal">0</code></td><td><code class="literal">255</code></td></tr><tr><td scope="row"><code class="literal">SMALLINT</code></td><td>2</td><td><code class="literal">-32768</code></td><td><code class="literal">32767</code></td></tr><tr><td scope="row"> </td><td> </td><td><code class="literal">0</code></td><td><code class="literal">65535</code></td></tr><tr><td scope="row"><code class="literal">MEDIUMINT</code></td><td>3</td><td><code class="literal">-8388608</code></td><td><code class="literal">8388607</code></td></tr><tr><td scope="row"> </td><td> </td><td><code class="literal">0</code></td><td><code class="literal">16777215</code></td></tr><tr><td scope="row"><code class="literal">INT</code></td><td>4</td><td><code class="literal">-2147483648</code></td><td><code class="literal">2147483647</code></td></tr><tr><td scope="row"> </td><td> </td><td><code class="literal">0</code></td><td><code class="literal">4294967295</code></td></tr><tr><td scope="row"><code class="literal">BIGINT</code></td><td>8</td><td><code class="literal">-9223372036854775808</code></td><td><code class="literal">9223372036854775807</code></td></tr><tr><td scope="row"> </td><td> </td><td><code class="literal">0</code></td><td><code class="literal">18446744073709551615</code></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="fixed-point-types"></a>11.2.2 固定小数点型 (真数値) - DECIMAL、NUMERIC</h3></div></div></div><p>
        <code class="literal">DECIMAL</code> および <code class="literal">NUMERIC</code> 型は真数値データ値を格納します。これらの型は、金銭データを扱う場合など、正確な精度を保持することが重要な場合に使用されます。MySQL では、<code class="literal">NUMERIC</code> は <code class="literal">DECIMAL</code> として実装されるので、<code class="literal">DECIMAL</code> に関する次の注意事項が <code class="literal">NUMERIC</code> にも同様に適用されます。
      </p><p>
        MySQL 5.6 は <code class="literal">DECIMAL</code> 値をバイナリ形式で格納します。<a class="xref" href="functions.html#precision-math" title="12.20 高精度計算">セクション12.20「高精度計算」</a>を参照してください。
      </p><p>
        <code class="literal">DECIMAL</code> カラム宣言で、精度およびスケールはたとえば次のように指定できます (通常は指定されています)。
      </p><pre class="programlisting">
salary DECIMAL(5,2)
</pre><p>
        この例では、<code class="literal">5</code> が精度で、<code class="literal">2</code> がスケールです。精度は、その値に格納された有効な桁数を表し、スケールは小数点以下に格納できる桁数を表しています。
      </p><p>
        標準 SQL では、<code class="literal">DECIMAL(5,2)</code> には小数部が 2 桁の合計 5 桁の値を格納できる必要があるので、<code class="literal">salary</code> カラムに格納できる値は、<code class="literal">-999.99</code> から <code class="literal">999.99</code> の範囲になります。
      </p><p>
        標準 SQL では、構文 <code class="literal">DECIMAL(<em class="replaceable"><code>M</code></em>)</code> は、<code class="literal">DECIMAL(<em class="replaceable"><code>M</code></em>,0)</code> と同等です。同様に、構文 <code class="literal">DECIMAL</code> は <code class="literal">DECIMAL(<em class="replaceable"><code>M</code></em>,0)</code> と同等です。<em class="replaceable"><code>M</code></em> の値を決定するために、実装は許可されています。MySQL は、<code class="literal">DECIMAL</code> 構文のこれらのバリアント形式をどちらもサポートします。<em class="replaceable"><code>M</code></em> のデフォルト値は 10 です。
      </p><p>
        スケールが 0 の場合、<code class="literal">DECIMAL</code> 値には小数点も小数部も含まれません。
      </p><p>
        <code class="literal">DECIMAL</code> の最大桁数は 65 ですが、指定した <code class="literal">DECIMAL</code> カラムの実際の範囲は、その指定したカラムの精度またはスケールによって制約される場合があります。指定のスケールで許可されている数より多くの桁が小数点以下にある値が、このようなカラムに割り当てられた場合、値はそのスケールに変換されます。(正確な動作はオペレーティングシステム固有ですが、一般的には効果は許可されている桁数に切り捨てられます。)
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="floating-point-types"></a>11.2.3 浮動小数点型 (概数値) - FLOAT、DOUBLE</h3></div></div></div><p>
        <code class="literal">FLOAT</code> および <code class="literal">DOUBLE</code> 型は概数値データ値を表します。MySQL は、単精度値には 4 バイトを、倍精度値には 8 バイトを使用します。
      </p><p>
        <code class="literal">FLOAT</code> については、SQL 標準では、オプションで、キーワード <code class="literal">FLOAT</code> に続く括弧内のビットで (指数の範囲ではなく) 精度を指定できます。MySQL はまた、このオプションの精度指定もサポートしますが、その精度値はストレージサイズを決定するためだけに使用されます。0 から 23 の精度は、4 バイト単精度の <code class="literal">FLOAT</code> カラムになります。24 から 53 の精度は、8 バイト倍精度の <code class="literal">DOUBLE</code> カラムになります。
      </p><p>
        MySQL は、<code class="literal">FLOAT(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)</code> または <code class="literal">REAL(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)</code> または <code class="literal">DOUBLE PRECISION(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)</code> の非標準の構文を許可します。ここで、<span class="quote">「<span class="quote"><code class="literal">(<em class="replaceable"><code>M</code></em>、<em class="replaceable"><code>D</code></em>)</code></span>」</span> は、値は合計で <em class="replaceable"><code>M</code></em> 桁まで格納でき、そのうちの <em class="replaceable"><code>D</code></em> 桁は小数点以下です。たとえば、<code class="literal">FLOAT(7,4)</code> として定義されたカラムは、表示されたときには <code class="literal">-999.9999</code> のようになります。MySQL は、値を格納するときに丸めを行うので、<code class="literal">FLOAT(7,4)</code> カラムに <code class="literal">999.00009</code> を挿入すると、近似の結果は <code class="literal">999.0001</code> になります。
      </p><p>
        浮動小数点値は概数値であり、真数値としては格納されないので、比較で値を真数値として扱おうとすると、問題が発生することがあります。これらはまた、プラットフォームまたは実装の依存関係にも従います。詳細は、<a class="xref" href="error-handling.html#problems-with-float" title="B.5.5.8 浮動小数点値に関する問題">セクションB.5.5.8「浮動小数点値に関する問題」</a>を参照してください。
      </p><p>
        移植性を最大にするために、概数値データ値のストレージを必要とするコードでは、精度または桁数が指定されていない <code class="literal">FLOAT</code> または <code class="literal">DOUBLE PRECISION</code> を使用する必要があります。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="bit-type"></a>11.2.4 ビット値型 - BIT</h3></div></div></div><p>
        <code class="literal">BIT</code> データ型は、ビットフィールド値を格納するのに使用されます。<code class="literal">BIT(<em class="replaceable"><code>M</code></em>)</code> の型は、<em class="replaceable"><code>M</code></em> ビット値のストレージを有効にします。<em class="replaceable"><code>M</code></em> の範囲は 1 から 64 までが可能です。
      </p><p>
        ビット値を指定するには、<code class="literal">b'<em class="replaceable"><code>value</code></em>'</code> 表記を使用できます。<em class="replaceable"><code>value</code></em> は、0 と 1 で書かれたバイナリ値です。たとえば、<code class="literal">b'111'</code> と <code class="literal">b'10000000'</code> はそれぞれ 7 と 128 を表しています。<a class="xref" href="language-structure.html#bit-field-literals" title="9.1.6 ビットフィールドリテラル">セクション9.1.6「ビットフィールドリテラル」</a>を参照してください。
      </p><p>
        <em class="replaceable"><code>M</code></em> ビット長よりも短い <code class="literal">BIT(<em class="replaceable"><code>M</code></em>)</code> カラムに値を割り当てた場合、その値の左側はゼロで埋められます。たとえば、<code class="literal">b'101'</code> という値を <code class="literal">BIT(6)</code> カラムに割り当てると、実際には <code class="literal">b'000101'</code> を割り当てた場合と同じことになります。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="numeric-type-attributes"></a>11.2.5 数値型の属性</h3></div></div></div><p>
        MySQL では、整数データ型の基本キーワードに続く括弧内で、その型の表示幅をオプションで指定する拡張をサポートしています。たとえば、<code class="literal">INT(4)</code> は、4 桁の表示幅の <code class="literal">INT</code> を指定しています。このオプションの表示幅は、左側をスペースでパディングすることによって、カラムに対して指定された幅よりも狭く整数値を表示するために、アプリケーションで使用される場合があります。(つまり、この幅は結果セットで返されるメタデータの中にあります。これを使用するかどうかは、アプリケーションしだいです。)
      </p><p>
        表示幅は、カラムに格納できない値の範囲を制約<span class="emphasis"><em>しません</em></span>。カラムの表示幅より広い値が正しく表示されなくなることもありません。たとえば、<code class="literal">SMALLINT(3)</code> として指定されたカラムには、<code class="literal">-32768</code> から <code class="literal">32767</code> の通常の <code class="literal">SMALLINT</code> 範囲があり、3 桁が許可されたこの範囲外の値は、4 桁以上を使用してすべて表示されます。
      </p><p>
        オプション (非標準) の属性 <code class="literal">ZEROFILL</code> と一緒に使用すると、デフォルトのスペースのパディングはゼロに置き換えられます。たとえば、<code class="literal">INT(4) ZEROFILL</code> として宣言されたカラムの場合、<code class="literal">5</code> の値は <code class="literal">0005</code> として取得されます。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">ZEROFILL</code> 属性は、カラムが式や <code class="literal">UNION</code> クエリーに含まれているときは無視されます。
        </p><p>
          <code class="literal">ZEROFILL</code> 属性を持つ整数カラムに表示幅より大きな値を格納した場合、MySQL が一部の複雑な結合に対して一時テーブルを生成するときに問題が発生することがあります。これらの場合、MySQL は、カラムの表示幅内でデータ値が適合すると想定します。
        </p></div><p>
        すべての整数型には、オプション (非標準) 属性 <code class="literal">UNSIGNED</code> を指定できます。符号なしの型は、カラムで負ではない数値しか許可しないとき、またはカラムの上限の数値範囲を大きくする必要があるときに使用できます。たとえば、<code class="literal">INT</code> カラムが <code class="literal">UNSIGNED</code> である場合、カラム範囲のサイズは同じですが、その終点は <code class="literal">-2147483648</code> と <code class="literal">2147483647</code> から、<code class="literal">0</code> と <code class="literal">4294967295</code> に変化します。
      </p><p>
        浮動小数点と固定小数点も <code class="literal">UNSIGNED</code> になり得ます。整数型と同じように、この属性は負の値がカラムに格納されるのを防ぎます。整数型とは異なり、カラム値の上限範囲は変わりません。
      </p><p>
        数値カラムに対して <code class="literal">ZEROFILL</code> を指定すると、MySQL は自動的にそのカラムに <code class="literal">UNSIGNED</code> 属性を追加します。
      </p><p>
        整数または浮動小数点のデータ型には、追加の属性 <code class="literal">AUTO_INCREMENT</code> を指定できます。インデックスが設定された <code class="literal">AUTO_INCREMENT</code> カラムに <code class="literal">NULL</code> (推奨) または <code class="literal">0</code> の値を挿入すると、カラムは次のシーケンス値に設定されます。通常、これは <code class="literal"><em class="replaceable"><code>value</code></em>+1</code> です。ここで <em class="replaceable"><code>value</code></em> は現在テーブルにあるカラムの最大値です。<code class="literal">AUTO_INCREMENT</code> シーケンスは <code class="literal">1</code> で始まります。(<code class="literal">AUTO_INCREMENT</code> 値を生成するために <code class="literal">NULL</code> を挿入する場合、カラムを <code class="literal">NOT NULL</code> と宣言する必要があります。カラムを <code class="literal">NULL</code> と宣言した場合、<code class="literal">NULL</code> を挿入すると <code class="literal">NULL</code> が格納されます。)
      </p><p>
        MySQL 5.6.9 以降では、<code class="literal">AUTO_INCREMENT</code> カラムの負の値はサポートされません。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="out-of-range-and-overflow"></a>11.2.6 範囲外およびオーバーフローの処理</h3></div></div></div><a class="indexterm" name="idm139979103575024"></a><a class="indexterm" name="idm139979103573600"></a><p>
        MySQL が、カラムデータ型の許可できる範囲外にある数値カラムに値を格納すると、結果は、その時点で有効な SQL モードによって異なります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            厳密な SQL モードが有効な場合、SQL 標準に従って、MySQL は範囲外の値を拒否してエラーを表示し、挿入は失敗します。
          </p></li><li class="listitem"><p>
            制限の強いモードが有効になっていない場合、MySQL は、範囲の適切な終点に値を切り落とし、その結果の値を代わりに格納します。
          </p><p>
            範囲外の値が整数カラムに割り当てられると、MySQL は、カラムデータ型の範囲の対応する終点を表す値を格納します。<code class="literal">TINYINT</code> または <code class="literal">TINYINT UNSIGNED</code> カラムに 256 を格納すると、MySQL はそれぞれに 127 または 255 を格納します。
          </p><p>
            浮動小数点または固定小数点カラムに、指定された (またはデフォルトの) 精度とスケールによって暗示された範囲を超えた値が割り当てられると、MySQL はその範囲の対応する終点を表す値を格納します。
          </p></li></ul></div><p>
        MySQL が厳密モードで動作していないときの切り落としのために起きるカラム割り当て変換は、<code class="literal">ALTER TABLE</code>、<code class="literal">LOAD DATA INFILE</code>、<code class="literal">UPDATE</code>、および複数行の <code class="literal">INSERT</code> ステートメントに対する警告としてレポートされます。厳密モードでは、これらのステートメントは失敗し、テーブルがトランザクションテーブルかどうかやほかの要因に応じて、一部またはすべての値が挿入または変更されません。詳細は、<a class="xref" href="server-administration.html#sql-mode" title="5.1.7 サーバー SQL モード">セクション5.1.7「サーバー SQL モード」</a>を参照してください。
      </p><p>
        MySQL 5.6 では、数値式評価中のオーバーフローはエラーになります。たとえば、符号付きの <code class="literal">BIGINT</code> の最大値は 9223372036854775807 なので、次の式ではエラーが発生します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT 9223372036854775807 + 1;</code></strong>
ERROR 1690 (22003): BIGINT value is out of range in '(9223372036854775807 + 1)'
</pre><p>
        この場合に演算を成功させるには、値を符号なしに変換します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT CAST(9223372036854775807 AS UNSIGNED) + 1;</code></strong>
+-------------------------------------------+
| CAST(9223372036854775807 AS UNSIGNED) + 1 |
+-------------------------------------------+
|                       9223372036854775808 |
+-------------------------------------------+
</pre><p>
        オーバーフローが起きるかどうかはオペランドの範囲に応じて異なります。したがって、前述の式を処理するもう 1 つの方法として、<code class="literal">DECIMAL</code> 値に整数より大きな範囲があるので正確な値の演算を使用します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT 9223372036854775807.0 + 1;</code></strong>
+---------------------------+
| 9223372036854775807.0 + 1 |
+---------------------------+
|     9223372036854775808.0 |
+---------------------------+
</pre><p>
        一方が <code class="literal">UNSIGNED</code> 型のときに 2 つの整数値の間で減算を行うと、デフォルトでは符号なしの結果が生成されます。MySQL 5.5.5 より前では、それ以外では結果が負になっていた場合、最大の整数値になります。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET sql_mode = '';</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT CAST(0 AS UNSIGNED) - 1;</code></strong>
+-------------------------+
| CAST(0 AS UNSIGNED) - 1 |
+-------------------------+
|    18446744073709551615 |
+-------------------------+
</pre><p>
        MySQL 5.5.5 以降では、それ以外では結果が負になっていた場合、エラーになります。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET sql_mode = '';</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT CAST(0 AS UNSIGNED) - 1;</code></strong>
<span class="errortext">ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in '(cast(0 as unsigned) - 1)'</span>
</pre><p>
        <code class="literal">NO_UNSIGNED_SUBTRACTION</code> SQL モードが有効な場合は、結果は負になります。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET sql_mode = 'NO_UNSIGNED_SUBTRACTION';</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT CAST(0 AS UNSIGNED) - 1;</code></strong>
+-------------------------+
| CAST(0 AS UNSIGNED) - 1 |
+-------------------------+
|                      -1 |
+-------------------------+
</pre><p>
        このような演算の結果を使用して <code class="literal">UNSIGNED</code> 整数カラムが更新されると、結果はそのカラム型の最大値に切り落とされます。<code class="literal">NO_UNSIGNED_SUBTRACTION</code> が有効になっている場合は、0 に切り落とされます。厳密な SQL モードが有効になっている場合は、エラーが発生し、カラムは変わりません。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="date-and-time-types"></a>11.3 日付と時間型</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="data-types.html#datetime">11.3.1 DATE、DATETIME、および TIMESTAMP 型</a></span></dt><dt><span class="section"><a href="data-types.html#time">11.3.2 TIME 型</a></span></dt><dt><span class="section"><a href="data-types.html#year">11.3.3 YEAR 型</a></span></dt><dt><span class="section"><a href="data-types.html#migrating-to-year4">11.3.4 YEAR(2) の制限と YEAR(4) への移行</a></span></dt><dt><span class="section"><a href="data-types.html#timestamp-initialization">11.3.5 TIMESTAMP および DATETIME の自動初期化および更新機能</a></span></dt><dt><span class="section"><a href="data-types.html#fractional-seconds">11.3.6 時間値での小数秒</a></span></dt><dt><span class="section"><a href="data-types.html#date-and-time-type-conversion">11.3.7 日付と時間型間での変換</a></span></dt><dt><span class="section"><a href="data-types.html#two-digit-years">11.3.8 日付での 2 桁の年</a></span></dt></dl></div><a class="indexterm" name="idm139979103534640"></a><a class="indexterm" name="idm139979103532496"></a><p>
      時間値を表すための日付と時間型は、<code class="literal">DATE</code>、<code class="literal">TIME</code>, <code class="literal">DATETIME</code>、<code class="literal">TIMESTAMP</code>、および <code class="literal">YEAR</code> です。それぞれの時間型には、一定範囲の有効な値のほかに、MySQL では表すことのできない無効な値の指定時に使用できる<span class="quote">「<span class="quote">ゼロ</span>」</span>値があります。<code class="literal">TIMESTAMP</code> 型には、後述するように、特殊な自動更新処理があります。時間型のストレージ要件については、<a class="xref" href="data-types.html#storage-requirements" title="11.7 データ型のストレージ要件">セクション11.7「データ型のストレージ要件」</a>を参照してください。
    </p><p>
      日付と時間型を処理するときに、次の考慮事項に留意してください。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          MySQL は、標準出力形式で所定の日付または時間型の値を取得しますが、(たとえば、日付または時間型に割り当てたり、比較したりする値を指定するときに) 入力した入力値に対してさまざまな形式を解釈しようとします。日付と時間型に許可されている形式の説明については、<a class="xref" href="language-structure.html#date-and-time-literals" title="9.1.3 日付リテラルと時間リテラル">セクション9.1.3「日付リテラルと時間リテラル」</a>を参照してください。有効な値を入力する必要があります。ほかの形式で値を使用すると、予期しない結果が生じることがあります。
        </p></li><li class="listitem"><p>
          MySQL は、複数の形式で値を解釈しようとしますが、日付の部分は、ほかでは一般的に使用される月-日-年や日-月-年の順 (<code class="literal">'09-04-98'</code> や <code class="literal">'04-09-98'</code> など) ではなく、年-月-日の順 (<code class="literal">'98-09-04'</code> など) で常に指定する必要があります。
        </p></li><li class="listitem"><p>
          2 桁の年を含む日付の値は、世紀が不明なためあいまいです。MySQL は次のルールを使用して 2 桁の年の値を解釈します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
              <code class="literal">70-99</code> の範囲の値は <code class="literal">1970-1999</code> に変換されます。
            </p></li><li class="listitem"><p>
              <code class="literal">00-69</code> の範囲の値は <code class="literal">2000-2069</code> に変換されます。
            </p></li></ul></div><p>
          <a class="xref" href="data-types.html#two-digit-years" title="11.3.8 日付での 2 桁の年">セクション11.3.8「日付での 2 桁の年」</a>も参照してください。
        </p></li><li class="listitem"><p>
          ある時間型から別の時間型への値の変換は、<a class="xref" href="data-types.html#date-and-time-type-conversion" title="11.3.7 日付と時間型間での変換">セクション11.3.7「日付と時間型間での変換」</a>でのルールに従って行われます。
        </p></li><li class="listitem"><p>
          MySQL は自動的に、値が数値のコンテキストで使用される場合には日付または時間値を数値に、またはその反対に変換します。
        </p></li><li class="listitem"><p>
          デフォルトで MySQL は、日付または時間型の値で、範囲外であるか、それ以外で型にとって無効である値を見つけた場合、値をその型の<span class="quote">「<span class="quote">ゼロ</span>」</span>値に変換します。その例外では、範囲外の <code class="literal">TIME</code> 値は <code class="literal">TIME</code> 範囲の適切な終点に切り落とされます。
        </p></li><li class="listitem"><p>
          SQL モードを適切な値に設定することで、MySQL がサポートする日付の種類をより正確に指定できます。(<a class="xref" href="server-administration.html#sql-mode" title="5.1.7 サーバー SQL モード">セクション5.1.7「サーバー SQL モード」</a>を参照してください。)<code class="literal">ALLOW_INVALID_DATES</code> SQL モードを有効にすることによって、<code class="literal">'2009-11-31'</code> などの特定の日付を MySQL に受け入れさせることができます。これは、ユーザーが今後の処理のために、(たとえば Web フォームで) 指定した<span class="quote">「<span class="quote">間違っている可能性のある</span>」</span>値をデータベースに格納するときに役立ちます。このモードでは、MySQL は、月が 1 から 12 までの範囲にあることと、日付が 1 から 31 までの範囲にあることのみ検証します。
        </p></li><li class="listitem"><p>
          MySQL では、<code class="literal">DATE</code> または <code class="literal">DATETIME</code> カラムに、日がゼロ、または月および日がゼロである日付の格納を許可しています。これは、正確な日付がわかっていない可能性のある生年月日を格納する必要があるアプリケーションで役立ちます。この場合は、単に日付を <code class="literal">'2009-00-00'</code> または <code class="literal">'2009-01-00'</code> として格納します。このような日付を格納する場合は、<code class="literal">DATE_SUB()</code> や <code class="literal">DATE_ADD()</code> などの完全な日付を必要とする関数で正しい結果が返されることは期待しないでください。日付でゼロの月または日の部分を無効にするには、<code class="literal">NO_ZERO_IN_DATE</code> SQL モードを有効にします。
        </p></li><li class="listitem"><p>
          MySQL では、<span class="quote">「<span class="quote">ダミーの日付</span>」</span>として <code class="literal">'0000-00-00'</code> の<span class="quote">「<span class="quote">ゼロ</span>」</span>の値を格納できます。場合によっては、これは、<code class="literal">NULL</code> 値を使用するよりも便利であり、使用するデータおよびインデックススペースが少なくなります。<code class="literal">'0000-00-00'</code> を無効にするには、<code class="literal">NO_ZERO_DATE</code> SQL モードを有効にします。
        </p></li><li class="listitem"><p>
          Connector/ODBC で使用される<span class="quote">「<span class="quote">ゼロ</span>」</span>の日付または時間の値は、ODBC がこのような値を処理できないため、<code class="literal">NULL</code> に自動的に変換されます。
        </p></li></ul></div><p>
      次の表に、それぞれの型の<span class="quote">「<span class="quote">ゼロ</span>」</span>値の形式を示します。<span class="quote">「<span class="quote">ゼロ</span>」</span>値は特別ですが、表に示されている値を使用して、格納したり、明示的に参照したりできます。また、より簡単に記述できる <code class="literal">'0'</code> や <code class="literal">0</code> の値を使用してこれを行うこともできます。日付部分 (<code class="literal">DATE</code>、<code class="literal">DATETIME</code>、および <code class="literal">TIMESTAMP</code>) を含む時間型では、<code class="literal">NO_ZERO_DATE</code> SQL モードが有効な場合、これらの値を使用すると警告が発生します。
    </p><div class="informaltable"><table summary="次の表は、時間データ型のゼロ値の形式を示します。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">データ型</th><th scope="col"><span class="quote">「<span class="quote">ゼロ</span>」</span>値</th></tr></thead><tbody><tr><td scope="row"><code class="literal">DATE</code></td><td><code class="literal">'0000-00-00'</code></td></tr><tr><td scope="row"><code class="literal">TIME</code></td><td><code class="literal">'00:00:00'</code></td></tr><tr><td scope="row"><code class="literal">DATETIME</code></td><td><code class="literal">'0000-00-00 00:00:00'</code></td></tr><tr><td scope="row"><code class="literal">TIMESTAMP</code></td><td><code class="literal">'0000-00-00 00:00:00'</code></td></tr><tr><td scope="row"><code class="literal">YEAR</code></td><td><code class="literal">0000</code></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="datetime"></a>11.3.1 DATE、DATETIME、および TIMESTAMP 型</h3></div></div></div><a class="indexterm" name="idm139979103456256"></a><a class="indexterm" name="idm139979103454800"></a><a class="indexterm" name="idm139979103453440"></a><a class="indexterm" name="idm139979103452048"></a><a class="indexterm" name="idm139979103450128"></a><a class="indexterm" name="idm139979103448096"></a><p>
        <code class="literal">DATE</code>、<code class="literal">DATETIME</code>、および <code class="literal">TIMESTAMP</code> 型は関連しています。このセクションでは、これらの特徴、似ている点、および異なる点について説明します。MySQL は、<a class="xref" href="language-structure.html#date-and-time-literals" title="9.1.3 日付リテラルと時間リテラル">セクション9.1.3「日付リテラルと時間リテラル」</a>で説明している複数の形式で、<code class="literal">DATE</code>、<code class="literal">DATETIME</code>、および <code class="literal">TIMESTAMP</code> 値を認識します。<code class="literal">DATE</code> および <code class="literal">DATETIME</code> 範囲の説明では、<span class="quote">「<span class="quote">サポートされている</span>」</span>とは、以前の値は機能するが、保証はないということを意味します。
      </p><p>
        <code class="literal">DATE</code> 型は、日付部分を含むが時間部分は含まない値に使用されます。MySQL では、<code class="literal">DATE</code> 値の取得と表示は <code class="literal">'YYYY-MM-DD'</code> 形式で行われます。サポートしている範囲は <code class="literal">'1000-01-01'</code> から <code class="literal">'9999-12-31'</code> です。
      </p><p>
        <code class="literal">DATETIME</code> 型は、日付と時間の両方の部分を含む値に使用されます。MySQL では、<code class="literal">DATETIME</code> 値の取得と表示は <code class="literal">'YYYY-MM-DD HH:MM:SS'</code> 形式で行われます。サポートしている範囲は <code class="literal">'1000-01-01 00:00:00'</code> から <code class="literal">'9999-12-31 23:59:59'</code> です。
      </p><p>
        <code class="literal">TIMESTAMP</code> データ型は、日付と時間の両方の部分を含む値に使用されます。<code class="literal">TIMESTAMP</code> には、<code class="literal">'1970-01-01 00:00:01'</code> UTC から <code class="literal">'2038-01-19 03:14:07'</code> UTC の範囲があります。
      </p><p>
        <code class="literal">DATETIME</code> または <code class="literal">TIMESTAMP</code> 値には、マイクロ秒 (6 桁) までの精度で後続の小数秒部分を含めることができます。特に、MySQL 5.6.4 以降では、<code class="literal">DATETIME</code> または <code class="literal">TIMESTAMP</code> カラムに挿入された値の小数部はすべて破棄されずに格納されます。小数部が含まれる場合、これらの値の形式は <code class="literal">'YYYY-MM-DD HH:MM:SS[.fraction]'</code> であり、<code class="literal">DATETIME</code> 値の範囲は <code class="literal">'1000-01-01 00:00:00.000000'</code> から <code class="literal">'9999-12-31 23:59:59.999999'</code> であり、<code class="literal">TIMESTAMP</code> 値の範囲は <code class="literal">'1970-01-01 00:00:01.000000'</code> から <code class="literal">'2038-01-19 03:14:07.999999'</code> です。小数部は、常に時間の残りの部分から小数点で区分する必要があります。これ以外の小数秒区切り文字は認識されません。MySQL の小数秒のサポートの詳細は、<a class="xref" href="data-types.html#fractional-seconds" title="11.3.6 時間値での小数秒">セクション11.3.6「時間値での小数秒」</a>を参照してください。
      </p><p>
        <code class="literal">TIMESTAMP</code> および (MySQL 5.6.5 以降の) <code class="literal">DATETIME</code> データ型では、自動初期化と現在の日付および時間への自動更新機能が用意されています。詳細は、<a class="xref" href="data-types.html#timestamp-initialization" title="11.3.5 TIMESTAMP および DATETIME の自動初期化および更新機能">セクション11.3.5「TIMESTAMP および DATETIME の自動初期化および更新機能」</a>を参照してください。
      </p><p>
        MySQL は、<code class="literal">TIMESTAMP</code> 値を、ストレージでは現在のタイムゾーンを UTC に変換し、取得では UTC から現在のタイムゾーンに戻します。(<code class="literal">DATETIME</code> などのほかの型ではこれは行われません。)デフォルトでは、接続ごとの現在のタイムゾーンはサーバーの時間です。タイムゾーンは接続ごとに設定できます。タイムゾーン設定が一定であるかぎり、格納した値と同じ値に戻すことができます。<code class="literal">TIMESTAMP</code> 値を格納したあとで、タイムゾーンを変更して値を取り出すと、取り出された値は格納した値とは異なります。これは、同じタイムゾーンが両方向への変換に使用されなかったために起こります。現在のタイムゾーンは、<code class="literal">time_zone</code> システム変数の値として使用できます。詳細は、<a class="xref" href="globalization.html#time-zone-support" title="10.6 MySQL Server でのタイムゾーンのサポート">セクション10.6「MySQL Server でのタイムゾーンのサポート」</a>を参照してください。
      </p><p>
        無効な <code class="literal">DATE</code>、<code class="literal">DATETIME</code>、または <code class="literal">TIMESTAMP</code> 値は、適切な型の<span class="quote">「<span class="quote">ゼロ</span>」</span>値 (<code class="literal">'0000-00-00'</code> または <code class="literal">'0000-00-00 00:00:00'</code>) に変換されます。
      </p><a class="indexterm" name="idm139979103402736"></a><a class="indexterm" name="idm139979103400592"></a><p>
        MySQL では日付値解釈の特定のプロパティーに注意してください。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            MySQL は、文字列として指定された値に、<span class="quote">「<span class="quote">緩やかな</span>」</span>形式を使用でき、この形式では、どの句読点文字でも日付部分と時間部分の区切り文字として使用できます。場合によっては、この構文は偽りになることがあります。たとえば、<code class="literal">'10:11:12'</code> などの値は、<span class="quote">「<span class="quote"><code class="literal">:</code></span>」</span>区切り文字のために時間値のように見えることがありますが、日付のコンテキストで使用された場合は、<code class="literal">'2010-11-12'</code> の年と解釈されます。値 <code class="literal">'10:45:15'</code> は、<code class="literal">'45'</code> が有効な月ではないので、<code class="literal">'0000-00-00'</code> に変換されます。
          </p><p>
            日付および時間の部分と小数秒部分との間の区切り文字として認識される唯一の文字が小数点です。
          </p></li><li class="listitem"><p>
            サーバーは、月と日の値が、それぞれが 1 から 12 と 1 から 31 の範囲内にあるだけではなく、有効である必要があります。厳密モードが無効になっていると、<code class="literal">'2004-04-31'</code> のような無効な日付は <code class="literal">'0000-00-00'</code> に変換され、警告メッセージが表示されます。厳密モードが有効なときは、無効な日付によってエラーが発生します。このような日付を許可するには、<code class="literal">ALLOW_INVALID_DATES</code> を有効にします。詳細は、<a class="xref" href="server-administration.html#sql-mode" title="5.1.7 サーバー SQL モード">セクション5.1.7「サーバー SQL モード」</a>を参照してください。
          </p></li><li class="listitem"><p>
            MySQL は、日または月カラムにゼロを含んだ <code class="literal">TIMESTAMP</code> 値や、無効な日付の値を受け入れません。このルールに対する唯一の例外は、特殊な<span class="quote">「<span class="quote">ゼロ</span>」</span>値である <code class="literal">'0000-00-00 00:00:00'</code> です。
          </p></li><li class="listitem"><p>
            MySQL 5.6.4 より前では、テーブルから選択しない場合、<code class="literal">CAST()</code> は <code class="literal">TIMESTAMP</code> 値を文字列として扱います。(これは、<code class="literal">FROM DUAL</code> を指定した場合にも当てはまります。)<a class="xref" href="functions.html#cast-functions" title="12.10 キャスト関数と演算子">セクション12.10「キャスト関数と演算子」</a>を参照してください。
          </p></li><li class="listitem"><p>
            2 桁の年を含む日付の値は、世紀が不明なためあいまいです。MySQL は次のルールを使用して 2 桁の年の値を解釈します。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                <code class="literal">00-69</code> の範囲の値は <code class="literal">2000-2069</code> に変換されます。
              </p></li><li class="listitem"><p>
                <code class="literal">70-99</code> の範囲の値は <code class="literal">1970-1999</code> に変換されます。
              </p></li></ul></div><p>
            <a class="xref" href="data-types.html#two-digit-years" title="11.3.8 日付での 2 桁の年">セクション11.3.8「日付での 2 桁の年」</a>も参照してください。
          </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          MySQL Server は、<code class="literal">MAXDB</code> SQL モードを有効にして実行できます。この場合、<code class="literal">TIMESTAMP</code> は <code class="literal">DATETIME</code> と同じです。テーブル作成時にこのモードが有効になっている場合、<code class="literal">TIMESTAMP</code> カラムは <code class="literal">DATETIME</code> カラムとして作成されます。この結果、このようなカラムは <code class="literal">DATETIME</code> 表示形式を使用し、同じ範囲の値を持ち、自動初期化機能や、現在の日付と時間に自動的に更新する機能はありません。<a class="xref" href="server-administration.html#sql-mode" title="5.1.7 サーバー SQL モード">セクション5.1.7「サーバー SQL モード」</a>を参照してください。
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="time"></a>11.3.2 TIME 型</h3></div></div></div><a class="indexterm" name="idm139979103363008"></a><a class="indexterm" name="idm139979103361536"></a><p>
        MySQL では、<code class="literal">TIME</code> 値の取り出しと表示は <code class="literal">'HH:MM:SS'</code> 形式 (時間の部分の値が大きい場合は <code class="literal">'HHH:MM:SS'</code> 形式) で行われます。<code class="literal">TIME</code> 値の範囲は、<code class="literal">'-838:59:59'</code> から <code class="literal">'838:59:59'</code> です。<code class="literal">TIME</code> 型は、時間 (24 時間以下にする必要があります) を表すだけでなく、経過時間や、2 つのイベント間の時間 (24 時間よりも非常に長くなる場合も、負になる場合もあります) を表すこともできるので、時間の部分は非常に大きくなる可能性があります。
      </p><p>
        MySQL が <code class="literal">TIME</code> 値を認識する形式は複数あり、そのいくつかにはマイクロ秒 (6 秒) までの精度で後続の小数秒部分を含めることができます。<a class="xref" href="language-structure.html#date-and-time-literals" title="9.1.3 日付リテラルと時間リテラル">セクション9.1.3「日付リテラルと時間リテラル」</a>を参照してください。MySQL の小数秒のサポートの詳細は、<a class="xref" href="data-types.html#fractional-seconds" title="11.3.6 時間値での小数秒">セクション11.3.6「時間値での小数秒」</a>を参照してください。特に、MySQL 5.6.4 以降では、<code class="literal">TIME</code> カラムに挿入された値の小数部はすべて破棄されずに格納されます。小数部が含まれている場合、<code class="literal">TIME</code> 値の範囲は <code class="literal">'-838:59:59.000000'</code> から <code class="literal">'838:59:59.000000'</code> です。
      </p><p>
        <code class="literal">TIME</code> カラムに省略された値を割り当てる場合は注意してください。MySQL は、コロン付きの省略された <code class="literal">TIME</code> 値を時間と解釈します。つまり、<code class="literal">'11:12'</code> は <code class="literal">'00:11:12'</code> ではなく <code class="literal">'11:12:00'</code> を意味します。MySQL は、右端の 2 桁が秒を表すという仮定を使用して (つまり、時間としてではなく経過時間として)、コロンのない省略された値を解釈します。たとえば、<code class="literal">'1112'</code> と <code class="literal">1112</code> は <code class="literal">'11:12:00'</code> (11 時 12 分) を表すように見えますが、MySQL では <code class="literal">'00:11:12'</code> (11 分 12 秒) と解釈されます。同様に、<code class="literal">'12'</code> や <code class="literal">12</code> は <code class="literal">'00:00:12'</code> と解釈されます。
      </p><p>
        時間部分と小数秒部分との間の区切り文字として認識される唯一の文字が小数点です。
      </p><p>
        デフォルトでは、<code class="literal">TIME</code> 範囲外にあるが、それ以外は有効な値は、範囲のもっとも近い終点に切り落とされます。たとえば、<code class="literal">'-850:00:00'</code> と <code class="literal">'850:00:00'</code> は、それぞれ <code class="literal">'-838:59:59'</code> と <code class="literal">'838:59:59'</code> に変換されます。無効な <code class="literal">TIME</code> 値は、<code class="literal">'00:00:00'</code> に変換されます。<code class="literal">'00:00:00'</code> はそれ自体が有効な <code class="literal">TIME</code> 値なので、元の値が <code class="literal">'00:00:00'</code> と指定されたのかどうか、無効であったかどうか、テーブルに格納された <code class="literal">'00:00:00'</code> の値から判断できません。
      </p><p>
        無効な <code class="literal">TIME</code> 値の制限を厳しくするには、エラーが発生するように厳密な SQL モードを有効にしてください。<a class="xref" href="server-administration.html#sql-mode" title="5.1.7 サーバー SQL モード">セクション5.1.7「サーバー SQL モード」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="year"></a>11.3.3 YEAR 型</h3></div></div></div><a class="indexterm" name="idm139979103324096"></a><a class="indexterm" name="idm139979103322624"></a><p>
        <code class="literal">YEAR</code> 型は年の値を表すために使用される 1 バイトの型です。これは <code class="literal">YEAR(4)</code> または <code class="literal">YEAR(2)</code> と宣言して、4 文字または 2 文字の表示幅を指定できます。幅が指定されていない場合、デフォルトは 4 文字になります。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">YEAR(2)</code> データ型には、使用する前に考慮する必要のある特定の問題があります。また、MySQL 5.6.6 以降では、<code class="literal">YEAR(2)</code> は非推奨です。既存のテーブル内の <code class="literal">YEAR(2)</code> カラムは以前のとおりに扱われますが、新規または変更したテーブルでは <code class="literal">YEAR(2)</code> は <code class="literal">YEAR(4)</code> に変換されます。詳細は、<a class="xref" href="data-types.html#migrating-to-year4" title="11.3.4 YEAR(2) の制限と YEAR(4) への移行">セクション11.3.4「YEAR(2) の制限と YEAR(4) への移行」</a>を参照してください。
        </p></div><p>
        <code class="literal">YEAR(4)</code> と <code class="literal">YEAR(2)</code> は表示形式が異なりますが、値の範囲は同じです。4 桁の形式の場合、MySQL は、<code class="literal">YYYY</code> の形式と <code class="literal">1901</code> から <code class="literal">2155</code>、または <code class="literal">0000</code> の範囲で、<code class="literal">YEAR</code> 値を表示します。2 桁形式の場合、MySQL は、<code class="literal">70</code> (1970 または 2070) や <code class="literal">69</code> (2069) など、最後 (最下位) の 2 桁だけを表示します。
      </p><p>
        <code class="literal">YEAR</code> の入力値は、次に示すさまざまな形式で指定できます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">1901</code> から <code class="literal">2155</code> の範囲の 4 桁の数値として。
          </p></li><li class="listitem"><p>
            <code class="literal">'1901'</code> から <code class="literal">'2155'</code> の範囲の 4 桁の文字列として。
          </p></li><li class="listitem"><p>
            <code class="literal">1</code> から <code class="literal">99</code> の範囲の 1 桁または 2 桁の数値として。MySQL は、<code class="literal">1</code> から <code class="literal">69</code> と <code class="literal">70</code> から <code class="literal">99</code> の範囲の値を、<code class="literal">2001</code> から <code class="literal">2069</code> と <code class="literal">1970</code> から <code class="literal">1999</code> の範囲の <code class="literal">YEAR</code> 値に変換します。
          </p></li><li class="listitem"><p>
            <code class="literal">'0'</code> から <code class="literal">'99'</code> の範囲の 1 桁または 2 桁の文字列として。MySQL は、<code class="literal">'0'</code> から <code class="literal">'69'</code> と <code class="literal">'70'</code> から <code class="literal">'99'</code> の範囲の値を、<code class="literal">2000</code> から <code class="literal">2069</code> と <code class="literal">1970</code> から <code class="literal">1999</code> の範囲の <code class="literal">YEAR</code> 値に変換します。
          </p></li><li class="listitem"><p>
            数値 <code class="literal">0</code> を挿入した場合、その効果は <code class="literal">YEAR(2)</code> と <code class="literal">YEAR(4)</code> で異なります。<code class="literal">YEAR(2)</code> の場合、<code class="literal">00</code> の表示値と <code class="literal">2000</code> の内部値の結果になります。<code class="literal">YEAR(4)</code> の場合、<code class="literal">0000</code> の表示値と <code class="literal">0000</code> の内部値の結果になります。<code class="literal">YEAR(4)</code> にゼロを指定し、これを <code class="literal">2000</code> として解釈させるには、文字列 <code class="literal">'0'</code> または <code class="literal">'00'</code> としてこれを指定します。
          </p></li><li class="listitem"><p>
            <code class="literal">NOW()</code> などの <code class="literal">YEAR</code> コンテキストで許容される値を返す関数の結果として。
          </p></li></ul></div><p>
        MySQL は無効な <code class="literal">YEAR</code> 値を <code class="literal">0000</code> に変換します。
      </p><p>
        <a class="xref" href="data-types.html#two-digit-years" title="11.3.8 日付での 2 桁の年">セクション11.3.8「日付での 2 桁の年」</a>も参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="migrating-to-year4"></a>11.3.4 YEAR(2) の制限と YEAR(4) への移行</h3></div></div></div><p>
        このセクションでは、<code class="literal">YEAR(2)</code> の使用時に生じる可能性のある問題を取り上げ、既存の <code class="literal">YEAR(2)</code> カラムを <code class="literal">YEAR(4)</code> に変換するための情報について説明します。
      </p><p>
        <code class="literal">YEAR(4)</code> と <code class="literal">YEAR(2)</code> の値の内部範囲は同じですが (<code class="literal">1901</code> から <code class="literal">2155</code>、および <code class="literal">0000</code>)、<code class="literal">YEAR(2)</code> の表示幅は、表示値が内部値の最後の 2 桁しか示さず、世紀を表す最初の 2 桁を省略するので、その型があいまいになります。特定の状況下では情報が失われる結果になることもあります。このため、<code class="literal">YEAR</code> データ型が必要なときは必ず、アプリケーション全体で <code class="literal">YEAR(2)</code> の使用を避け、<code class="literal">YEAR(4)</code> を使用するよう検討してください。MySQL 5.6.6 以降では、4 以外の表示値の <code class="literal">YEAR</code> データ型 (特に <code class="literal">YEAR(2)</code>) のサポートが縮小し、今後のリリースで完全に廃止される予定なので、ある時点で変換が必要になります。
      </p><h4><a name="idm139979103247712"></a>YEAR(2) の制限</h4><p>
        <code class="literal">YEAR(2)</code> データ型に関する問題には、表示値のあいまいさと、値のダンプおよびリロード時または文字列への変換時に情報損失の可能性があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">YEAR(2)</code> の表示値はあいまいな場合があります。次の例で示すように、異なる内部値を持つ最大 3 つの <code class="literal">YEAR(2)</code> 値を同じ表示値にできます。
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE t (y2 YEAR(2), y4 YEAR(4));</code></strong>
Query OK, 0 rows affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO t (y2) VALUES(1912),(2012),(2112);</code></strong>
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql&gt; <strong class="userinput"><code>UPDATE t SET y4 = y2;</code></strong>
Query OK, 3 rows affected (0.00 sec)
Rows matched: 3  Changed: 3  Warnings: 0

mysql&gt; <strong class="userinput"><code>SELECT * FROM t;</code></strong>
+------+------+
| y2   | y4   |
+------+------+
|   12 | 1912 |
|   12 | 2012 |
|   12 | 2112 |
+------+------+
3 rows in set (0.00 sec)
</pre></li><li class="listitem"><p>
            <span class="command"><strong>mysqldump</strong></span> を使用して、前述の項目に作成されたテーブルをダンプする場合、ダンプファイルは、同じ 2 桁の表現 (<code class="literal">12</code>) を使用してすべての <code class="literal">y2</code> 値を表します。ダンプファイルからテーブルをリロードした場合、すべての結果の行に内部値 <code class="literal">2012</code> と表示値 <code class="literal">12</code> を含まれるので、これらの違いが失われます。
          </p></li><li class="listitem"><p>
            <code class="literal">YEAR(2)</code> または <code class="literal">YEAR(4)</code> データ値を文字列形式に変換した場合、<code class="literal">YEAR</code> 型の表示幅が使用されます。<code class="literal">YEAR(2)</code> と <code class="literal">YEAR(4)</code> の両方のカラムに <code class="literal">1970</code> の値が含まれるとします。それぞれのカラムを文字列に割り当てた結果、それぞれ <code class="literal">'70'</code> と <code class="literal">'1970'</code> の値になります。つまり、<code class="literal">YEAR(2)</code> から文字列への変換で情報の損失が起こります。
          </p></li><li class="listitem"><p>
            <code class="literal">1970</code> から <code class="literal">2069</code> の範囲から外れた値は、<code class="literal">CSV</code> テーブルの <code class="literal">YEAR(2)</code> カラムに挿入されるときに、間違って格納されます。たとえば、<code class="literal">2111</code> を挿入すると、表示値は <code class="literal">11</code> になりますが、内部値は <code class="literal">2011</code> になります。
          </p></li></ul></div><p>
        これらの問題を避けるには、<code class="literal">YEAR(2)</code> ではなく <code class="literal">YEAR(4)</code> を使用してください。移行戦略に関した提案は、このセクションで後述します。
      </p><h4><a name="idm139979103213776"></a>MySQL 5.6 の YEAR(2) サポートの縮小</h4><p>
        MySQL 5.6.6 以降で、<code class="literal">YEAR(2)</code> のサポートは縮小されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            新しいテーブルの <code class="literal">YEAR(2)</code> カラム定義は、<code class="literal">YEAR(4)</code> に (警告付きで) 変換されます。
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (y YEAR(2));</code></strong>
Query OK, 0 rows affected, 1 warning (0.03 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS\G</code></strong>
*************************** 1. row ***************************
  Level: Warning
   Code: 1818
Message: YEAR(2) column type is deprecated. Creating YEAR(4) column instead.
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE t1\G</code></strong>
*************************** 1. row ***************************
       Table: t1
Create Table: CREATE TABLE `t1` (
  `y` year(4) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1
1 row in set (0.00 sec)
</pre></li><li class="listitem"><p>
            既存のテーブルの <code class="literal">YEAR(2)</code> は <code class="literal">YEAR(2)</code> として残され、古いバージョンの MySQL と同様にクエリーで処理されます。ただし、複数のプログラムまたはステートメントが、<code class="literal">YEAR(2)</code> を <code class="literal">YEAR(4)</code> に自動的に変換します。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                テーブルの再構築を招く <code class="literal">ALTER TABLE</code> ステートメント。
              </p></li><li class="listitem"><p>
                <code class="literal">REPAIR TABLE</code> (<code class="literal">YEAR(2)</code> カラムがテーブルに含まれることが <code class="literal">CHECK TABLE</code> で検出された場合に、使用するように推奨されます)。
              </p></li><li class="listitem"><p>
                <span class="command"><strong>mysql_upgrade</strong></span> (<code class="literal">REPAIR TABLE</code> を使用します)。
              </p></li><li class="listitem"><p>
                <span class="command"><strong>mysqldump</strong></span> でのダンプおよびダンプファイルのリロード。上記の 3 つの項目が実行する変換とは異なり、ダンプとリロードは値を変更する可能性があります。
              </p></li></ul></div><p>
            MySQL アップグレードでは通常、最後の 2 つの項目のうち少なくとも 1 つを含みます。ただし、<code class="literal">YEAR(2)</code> については <span class="command"><strong>mysql_upgrade</strong></span> をお勧めします。前述のように値を変更する可能性があるので、<span class="command"><strong>mysqldump</strong></span> は使用しないでください。
          </p></li></ul></div><h4><a name="idm139979103185264"></a>YEAR(2) から YEAR(4) への移行</h4><p>
        <code class="literal">YEAR(2)</code> カラムを <code class="literal">YEAR(4)</code> に変換するには、手動でアップグレードなしにいつでも行えます。または、<code class="literal">YEAR(2)</code> のサポートが縮小したバージョンの MySQL (MySQL 5.6.6 以降) にアップグレードしてから、MySQL で <code class="literal">YEAR(2)</code> カラムを自動的に変換できます。後者の場合は、データのダンプとリロードによるアップグレードは行わないでください。データ値を変更する可能性があります。さらに、レプリケーションを使用する場合は、注意の必要なアップグレードに関する考慮事項があります。
      </p><p>
        <code class="literal">YEAR(2)</code> カラムを <code class="literal">YEAR(4)</code> に手動で変換するには、<code class="literal">ALTER TABLE</code> を使用してください。テーブル <code class="literal">t1</code> に次の定義があるとします。
      </p><pre class="programlisting">
CREATE TABLE t1 (ycol YEAR(2) NOT NULL DEFAULT '70');
</pre><p>
        次のように <code class="literal">ALTER TABLE</code> を使用してカラムを変更します。必ず、<code class="literal">NOT NULL</code> や <code class="literal">DEFAULT</code> などのすべてのカラム属性を含めてください。
      </p><pre class="programlisting">
ALTER TABLE t1 MODIFY ycol YEAR(4) NOT NULL DEFAULT '1970';
</pre><p>
        <code class="literal">ALTER TABLE</code> ステートメントは、<code class="literal">YEAR(2)</code> 値を変更しないでテーブルを変換します。サーバーがレプリケーションマスターである場合、<code class="literal">ALTER TABLE</code> ステートメントはスレーブに複製され、各対応するテーブルを変更します。
      </p><p>
        別の移行方法では、バイナリアップグレードを実行します。データのダンプおよびリロードを行わないで MySQL 5.6.6 以降をインストールします。続いて、<span class="command"><strong>mysql_upgrade</strong></span> を実行します。これは、<code class="literal">REPAIR TABLE</code> を使用して、データ値を変更しないで <code class="literal">YEAR(2)</code> カラムを <code class="literal">YEAR(4)</code> に変換します。サーバーがレプリケーションマスターである場合、<code class="option">--skip-write-binlog</code> オプションを付けて <span class="command"><strong>mysql_upgrade</strong></span> を呼び出さないかぎり、<code class="literal">REPAIR TABLE</code> ステートメントはスレーブに複製され、各対応するテーブルを変更します。
      </p><p>
        レプリケーションサーバーへのアップグレードでは通常、新しいバージョンの MySQL へのスレーブのアップグレードと、マスターのアップグレードが行われます。たとえば、マスターとスレーブの両方で MySQL 5.5 が実行している場合、通常のアップグレードシーケンスでは、スレーブを 5.6 にアップグレードしてからマスターを 5.6 にアップグレードします。MySQL 5.6.6 以降での <code class="literal">YEAR(2)</code> の異なる扱いに関しては、このアップグレードシーケンスにより問題が生じます。スレーブがアップグレードされているが、マスターがまだアップグレードされていないとします。この場合、マスター上に <code class="literal">YEAR(2)</code> カラムを含んだテーブルを作成すると、スレーブ上では <code class="literal">YEAR(4)</code> カラムを含むテーブルが作成されます。この結果、ステートメントベースのレプリケーションを使用した場合、これらの操作はマスターとスレーブで異なる結果になります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            数値 <code class="literal">0</code> の挿入。結果の値は、マスター上では <code class="literal">2000</code> の内部値になりますが、スレーブ上では <code class="literal">0000</code> の内部値になります。
          </p></li><li class="listitem"><p>
            文字列への <code class="literal">YEAR(2)</code> の変換。この操作は、マスター上では <code class="literal">YEAR(2)</code> の表示値を使用しますが、スレーブ上では <code class="literal">YEAR(4)</code> の表示値を使用します。
          </p></li></ul></div><p>
        このような問題を避けるには、次の戦略のいずれかを使用します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            ステートメントベースのレプリケーションの代わりに行ベースのレプリケーションを使用します。
          </p></li><li class="listitem"><p>
            アップグレード前に、マスター上のすべての <code class="literal">YEAR(2)</code> カラムを <code class="literal">YEAR(4)</code> に変更します。(前述のように <code class="literal">ALTER TABLE</code> を使用します。)続いて、<code class="literal">YEAR(2)</code> から <code class="literal">YEAR(4)</code> の移行でマスターとスレーブ間で違いが生じることなく、通常どおりに (最初にスレーブ、次にマスター) アップグレードできます)。
          </p></li></ul></div><p>
        <span class="command"><strong>mysqldump</strong></span> でデータをダンプし、アップグレードしたあとにダンプファイルをリロードするという移行方法は使用しないでください。前述のように、これは <code class="literal">YEAR(2)</code> 値を変更する可能性があります。
      </p><p>
        <code class="literal">YEAR(2)</code> から <code class="literal">YEAR(4)</code> への移行では、次のような条件下で動作が変更された可能性がないかどうかアプリケーションコードの検査も行う必要があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">YEAR</code> カラムを選択すれば正確に 2 桁が生成されると予想しているコード。
          </p></li><li class="listitem"><p>
            <code class="literal">0</code> を <code class="literal">YEAR(2)</code> または <code class="literal">YEAR(4)</code> に挿入すると、それぞれ <code class="literal">2000</code> または <code class="literal">0000</code> の内部値になるという、数値 <code class="literal">0</code> の挿入に対する別々の処理に対応していないコード。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="timestamp-initialization"></a>11.3.5 TIMESTAMP および DATETIME の自動初期化および更新機能</h3></div></div></div><a class="indexterm" name="idm139979103122720"></a><p>
        MySQL 5.6.5 以降では、<code class="literal">TIMESTAMP</code> および <code class="literal">DATETIME</code> カラムを自動的に初期化でき、現在の日付および時間 (つまり、現在のタイムスタンプ) に自動的に更新できます。5.6.5 より前では、これは <code class="literal">TIMESTAMP</code> にしか当てはまらず、テーブルあたり最大で 1 つの <code class="literal">TIMESTAMP</code> カラムにしか当てはまりません。次の注意事項では、最初に、MySQL 5.6.5 以降での自動初期化および更新機能について、次に 5.6.5 より前のバージョンでの相違点について説明します。
      </p><p>
        テーブル内のあらゆる <code class="literal">TIMESTAMP</code> または <code class="literal">DATETIME</code> カラムに対して、デフォルト値または自動更新値、あるいはその両方として、現在のタイムスタンプを割り当てることができます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            自動初期化されたカラムは、カラムに値を指定しない挿入行に対して現在のタイムスタンプに設定されます。
          </p></li><li class="listitem"><p>
            自動更新されたカラムは、行内のほかのカラムの値がその現在の値から変更されると、現在のタイムスタンプに自動的に更新されます。自動更新されたカラムは、ほかのすべてのカラムがその現在の値に設定されていれば、変更されないまま保持されます。ほかのカラムが変更したときに、自動更新したカラムが更新しないようにするには、明示的にこれを現在の値に設定します。ほかのカラムが変更しない場合でも、自動更新カラムを更新するには、明示的にこれを必要な値に設定します (たとえば <code class="literal">CURRENT_TIMESTAMP</code> に設定します)。
          </p></li></ul></div><p>
        さらに、<code class="literal">NULL</code> 属性を使用して <code class="literal">NULL</code> 値を許可するように定義されていないかぎり、<code class="literal">NULL</code> 値を割り当てることによって、すべての <code class="literal">TIMESTAMP</code> カラムを初期化したり、現在の日付と時間に更新したりできます。
      </p><p>
        自動プロパティーを指定するには、カラム定義で <code class="literal">DEFAULT CURRENT_TIMESTAMP</code> および <code class="literal">ON UPDATE CURRENT_TIMESTAMP</code> 句を使用します。句の順序は関係ありません。両方がカラム定義にある場合、どちらも最初に実行できます。<code class="literal">CURRENT_TIMESTAMP</code> のシノニムのいずれも、<code class="literal">CURRENT_TIMESTAMP</code> と同じ意味があります。これらは、<code class="literal">CURRENT_TIMESTAMP()</code>、<code class="literal">NOW()</code>、<code class="literal">LOCALTIME</code>、<code class="literal">LOCALTIME()</code>、<code class="literal">LOCALTIMESTAMP</code>、および <code class="literal">LOCALTIMESTAMP()</code> です。
      </p><p>
        <code class="literal">DEFAULT CURRENT_TIMESTAMP</code> および <code class="literal">ON UPDATE CURRENT_TIMESTAMP</code> の使用は、<code class="literal">TIMESTAMP</code> および <code class="literal">DATETIME</code> に固有です。<code class="literal">DEFAULT</code> 句も、<code class="literal">DEFAULT 0</code> や <code class="literal">DEFAULT '2000-01-01 00:00:00'</code> などの一定 (非自動) のデフォルト値を指定するために使用できます。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          <code class="literal">DEFAULT 0</code> を使用した次の例は、<code class="literal">NO_ZERO_DATE</code> SQL モードが有効な場合には機能しません。このモードでは<span class="quote">「<span class="quote">ゼロ</span>」</span>の日付値 (たとえば <code class="literal">0</code> <code class="literal">'0000-00-00 00:00:00'</code> として指定) が拒否されるからです。<code class="literal">TRADITIONAL</code> SQL モードに <code class="literal">NO_ZERO_DATE</code> が含まれています。
        </p></div><p>
        <code class="literal">TIMESTAMP</code> または <code class="literal">DATETIME</code> カラム定義では、現在のタイムスタンプをデフォルト値と自動更新値の両方に対して指定することも、どちらか一方について指定することも、両方について指定しないこともできます。異なるカラムは、自動プロパティーの別々の組み合わせを持つことができます。次のルールは可能性のある場合について記述しています。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">DEFAULT CURRENT_TIMESTAMP</code> と <code class="literal">ON UPDATE CURRENT_TIMESTAMP</code> の両方を使用した場合、カラムは、デフォルト値が現在のタイムスタンプになり、現在のタイムスタンプに自動的に更新されます。
          </p><pre class="programlisting">
CREATE TABLE t1 (
  ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  dt DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
</pre></li><li class="listitem"><p>
            <code class="literal">DEFAULT</code> 句を使用するが <code class="literal">ON UPDATE CURRENT_TIMESTAMP</code> 句を使用しない場合、カラムには所定のデフォルト値が設定され、現在のタイムスタンプに自動的に更新されません。
          </p><p>
            デフォルトは、<code class="literal">DEFAULT</code> 句で <code class="literal">CURRENT_TIMESTAMP</code> を指定するか定数値を指定するかに応じて異なります。<code class="literal">CURRENT_TIMESTAMP</code> を使用した場合、デフォルトは現在のタイムスタンプになります。
          </p><pre class="programlisting">
CREATE TABLE t1 (
  ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  dt DATETIME DEFAULT CURRENT_TIMESTAMP
);
</pre><p>
            定数を使用した場合、デフォルトは所定の値になります。この場合、カラムには自動的なプロパティーはありません。
          </p><pre class="programlisting">
CREATE TABLE t1 (
  ts TIMESTAMP DEFAULT 0,
  dt DATETIME DEFAULT 0
);
</pre></li><li class="listitem"><p>
            <code class="literal">ON UPDATE CURRENT_TIMESTAMP</code> 句と定数の <code class="literal">DEFAULT</code> 句を使用した場合、カラムは、現在のタイムスタンプに自動的に更新され、所定の定数のデフォルト値があります。
          </p><pre class="programlisting">
CREATE TABLE t1 (
  ts TIMESTAMP DEFAULT 0 ON UPDATE CURRENT_TIMESTAMP,
  dt DATETIME DEFAULT 0 ON UPDATE CURRENT_TIMESTAMP
);
</pre></li><li class="listitem"><p>
            <code class="literal">ON UPDATE CURRENT_TIMESTAMP</code> 句を使用するが <code class="literal">DEFAULT</code> 句を使用しない場合、カラムは、自動的に現在のタイムスタンプに更新され、そのデフォルト値に現在のタイムスタンプは使用されません。
          </p><p>
            この場合のデフォルトは型により異なります。<code class="literal">TIMESTAMP</code> は、<code class="literal">NULL</code> 属性を使用して定義されていないかぎり (この場合はデフォルトは <code class="literal">NULL</code> です)、デフォルトは 0 です。
          </p><pre class="programlisting">
CREATE TABLE t1 (
  ts1 TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,     -- default 0
  ts2 TIMESTAMP NULL ON UPDATE CURRENT_TIMESTAMP -- default NULL
);
</pre><p>
            <code class="literal">DATETIME</code> は、<code class="literal">NOT NULL</code> 属性で定義されていないかぎり (この場合、デフォルトは 0 です)、デフォルトは <code class="literal">NULL</code> です。
          </p><pre class="programlisting">
CREATE TABLE t1 (
  dt1 DATETIME ON UPDATE CURRENT_TIMESTAMP,         -- default NULL
  dt2 DATETIME NOT NULL ON UPDATE CURRENT_TIMESTAMP -- default 0
);
</pre></li></ul></div><p>
        <code class="literal">TIMESTAMP</code> および <code class="literal">DATETIME</code> カラムには、明示的に指定されないかぎり自動プロパティーはありません。ただし、<code class="literal">DEFAULT CURRENT_TIMESTAMP</code> と <code class="literal">ON UPDATE CURRENT_TIMESTAMP</code> がどちらも明示的に指定されていない場合は、デフォルトで<span class="emphasis"><em>最初の</em></span> <code class="literal">TIMESTAMP</code> カラムに両方とも存在します。最初の <code class="literal">TIMESTAMP</code> カラムについて自動プロパティーを抑制するには、次のいずれかの戦略を使用します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">explicit_defaults_for_timestamp</code> システム変数を有効にします。この変数が有効な場合、自動初期化および更新機能を指定する <code class="literal">DEFAULT CURRENT_TIMESTAMP</code> および <code class="literal">ON UPDATE CURRENT_TIMESTAMP</code> 句は使用可能ですが、カラム定義に明示的に含まれていないかぎり、どの <code class="literal">TIMESTAMP</code> カラムにも割り当てられません。
          </p></li><li class="listitem"><p>
            または、<code class="literal">explicit_defaults_for_timestamp</code> が無効な場合 (デフォルト)、次のどちらかを行います。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                定数のデフォルト値を指定する <code class="literal">DEFAULT</code> 句を含むカラムを定義します。
              </p></li><li class="listitem"><p>
                <code class="literal">NULL</code> 属性を指定します。またこれにより、カラムで <code class="literal">NULL</code> 値が許可されます。つまり、カラムを <code class="literal">NULL</code> に設定することによって現在のタイムスタンプを割り当てることができなくなります。<code class="literal">NULL</code> を割り当てると、カラムは <code class="literal">NULL</code> に設定されます。
              </p></li></ul></div></li></ul></div><p>
        次のテーブル定義を考慮してください。
      </p><pre class="programlisting">
CREATE TABLE t1 (
  ts1 TIMESTAMP DEFAULT 0,
  ts2 TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                ON UPDATE CURRENT_TIMESTAMP);
CREATE TABLE t2 (
  ts1 TIMESTAMP NULL,
  ts2 TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                ON UPDATE CURRENT_TIMESTAMP);
CREATE TABLE t3 (
  ts1 TIMESTAMP NULL DEFAULT 0,
  ts2 TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                ON UPDATE CURRENT_TIMESTAMP);
</pre><p>
        テーブルには次のプロパティーがあります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            各テーブル定義において、最初の <code class="literal">TIMESTAMP</code> カラムには、自動初期化または更新機能はありません。
          </p></li><li class="listitem"><p>
            各テーブルでは、<code class="literal">ts1</code> カラムで <code class="literal">NULL</code> 値を処理する方法が異なります。<code class="literal">t1</code> の場合、<code class="literal">ts1</code> は <code class="literal">NOT NULL</code> であり、これに <code class="literal">NULL</code> の値を割り当てると、現在のタイムスタンプに設定されます。<code class="literal">t2</code> と <code class="literal">t3</code> の場合、<code class="literal">ts1</code> では <code class="literal">NULL</code> を使用でき、これに <code class="literal">NULL</code> の値を割り当てると、<code class="literal">NULL</code> に設定されます。
          </p></li><li class="listitem"><p>
            <code class="literal">t2</code> と <code class="literal">t3</code> では、<code class="literal">ts1</code> のデフォルト値が異なります。<code class="literal">t2</code> の場合、<code class="literal">ts1</code> は、<code class="literal">NULL</code> を許可するように定義されているので、明示的な <code class="literal">DEFAULT</code> 句がない場合はデフォルトも <code class="literal">NULL</code> です。<code class="literal">t3</code> の場合、<code class="literal">ts1</code> は <code class="literal">NULL</code> を使用できますが、明示的なデフォルトは 0 です。
          </p></li></ul></div><p>
        <code class="literal">TIMESTAMP</code> または <code class="literal">DATETIME</code> カラム定義のいずれかの場所に明示的な小数秒精度値が含まれる場合、カラム定義全体で同じ値を使用する必要があります。次の場合は許可されます。
      </p><pre class="programlisting">
CREATE TABLE t1 (
  ts TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6)
);
</pre><p>
        次の場合は許可されません。
      </p><pre class="programlisting">
CREATE TABLE t1 (
  ts TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP(3)
);
</pre><h4><a name="idm139979103002400"></a>MySQL 5.6.5 より前の自動タイムスタンププロパティー</h4><p>
        MySQL 5.6.5 より前では、自動初期化および更新機能のサポートは非常に限定的です。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">DEFAULT CURRENT_TIMESTAMP</code> と <code class="literal">ON UPDATE CURRENT_TIMESTAMP</code> は、<code class="literal">DATETIME</code> カラムで使用できません。
          </p></li><li class="listitem"><p>
            <code class="literal">DEFAULT CURRENT_TIMESTAMP</code> と <code class="literal">ON UPDATE CURRENT_TIMESTAMP</code> は、テーブルあたり最大で 1 つの <code class="literal">TIMESTAMP</code> カラムでしか使用できません。現在のタイムスタンプを、あるカラムのデフォルト値にして、別のカラムの自動更新値にはできません。
          </p></li></ul></div><p>
        これらのプロパティーを使用するかどうか、どの <code class="literal">TIMESTAMP</code> カラムで必要になるかを選択できます。これは、自動的に初期化される、または現在のタイムスタンプに自動的に更新されるテーブル内の最初のカラムにする必要はありません。別の <code class="literal">TIMESTAMP</code> カラムに対して自動初期化または更新を指定するには、前述のように、最初のカラムに対する自動プロパティーを制約する必要があります。この場合、ほかの <code class="literal">TIMESTAMP</code> カラムでは、<code class="literal">DEFAULT</code> および <code class="literal">ON UPDATE</code> 句のルールは、最初の <code class="literal">TIMESTAMP</code> カラムの場合と同じですが、両方の句を省略した場合、自動初期化も更新も行われません。
      </p><h4><a name="idm139979102986336"></a>TIMESTAMP の初期化と NULL 属性</h4><p>
        デフォルトでは、<code class="literal">TIMESTAMP</code> カラムは <code class="literal">NOT NULL</code> であり、<code class="literal">NULL</code> 値を含めることはできず、<code class="literal">NULL</code> を割り当てると現在のタイムスタンプが割り当てられます。<code class="literal">NULL</code> を含めるように <code class="literal">TIMESTAMP</code> カラムを許可するには、<code class="literal">NULL</code> 属性で明示的に宣言します。この場合、別のデフォルト値を指定する <code class="literal">DEFAULT</code> 句でオーバーライドされないかぎり、デフォルト値も <code class="literal">NULL</code> になります。<code class="literal">DEFAULT NULL</code> を使用すると、デフォルト値として <code class="literal">NULL</code> を明示的に指定できます。(<code class="literal">NULL</code> 属性が宣言されていない <code class="literal">TIMESTAMP</code> カラムの場合、<code class="literal">DEFAULT NULL</code> は無効です。)<code class="literal">TIMESTAMP</code> カラムで <code class="literal">NULL</code> 値を許可する場合、<code class="literal">NULL</code> を割り当てると、このカラムは現在のタイムスタンプではなく <code class="literal">NULL</code> に設定されます。
      </p><p>
        次のテーブルには、<code class="literal">NULL</code> 値を許可している複数の <code class="literal">TIMESTAMP</code> カラムが含まれています。
      </p><pre class="programlisting">
CREATE TABLE t
(
  ts1 TIMESTAMP NULL DEFAULT NULL,
  ts2 TIMESTAMP NULL DEFAULT 0,
  ts3 TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP
);
</pre><p>
        <code class="literal">NULL</code> 値を許可する <code class="literal">TIMESTAMP</code> カラムは、次のいずれかの状況に当てはまる場合を除き、挿入時に現在のタイムスタンプを取り<span class="emphasis"><em>ません</em></span>。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            デフォルト値が <code class="literal">CURRENT_TIMESTAMP</code> と定義され、カラムに対して値が指定されていない
          </p></li><li class="listitem"><p>
            <code class="literal">CURRENT_TIMESTAMP</code>、または<code class="literal">NOW()</code> などのそのいずれかのシノニムが明示的にカラムに挿入されている
          </p></li></ul></div><p>
        つまり、<code class="literal">NULL</code> 値を許可するように定義されている <code class="literal">TIMESTAMP</code> カラムは、その定義に <code class="literal">DEFAULT CURRENT_TIMESTAMP</code> が含まれている場合にのみ自動初期化します。
      </p><pre class="programlisting">
CREATE TABLE t (ts TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP);
</pre><p>
        <code class="literal">TIMESTAMP</code> カラムで <code class="literal">NULL</code> 値を許可しているが、定義に <code class="literal">DEFAULT CURRENT_TIMESTAMP</code> が含まれていない場合、現在の日付と時間に対応する値を明示的に挿入する必要があります。<code class="literal">t1</code> および <code class="literal">t2</code> テーブルに次の定義があるとします。
      </p><pre class="programlisting">
CREATE TABLE t1 (ts TIMESTAMP NULL DEFAULT '0000-00-00 00:00:00');
CREATE TABLE t2 (ts TIMESTAMP NULL DEFAULT NULL);
</pre><p>
        挿入時にどちらかのテーブルの <code class="literal">TIMESTAMP</code> カラムを現在のタイムスタンプに設定するには、明示的にそのカラムにこの値を割り当てます。例:
      </p><pre class="programlisting">
INSERT INTO t1 VALUES (NOW());
INSERT INTO t2 VALUES (CURRENT_TIMESTAMP);
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="fractional-seconds"></a>11.3.6 時間値での小数秒</h3></div></div></div><p>
        MySQL 5.6.4 より前では、時間値で小数秒部分が許可されているインスタンスは制限されています。後続の小数部は、リテラル値などのコンテキストで許可され、一部の時間関数への引数またはそこからの戻り値で許可されています。例:
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT MICROSECOND('2010-12-10 14:12:09.019473');</code></strong>
+-------------------------------------------+
| MICROSECOND('2010-12-10 14:12:09.019473') |
+-------------------------------------------+
|                                     19473 |
+-------------------------------------------+
</pre><p>
        ただし、MySQL は時間データ型のカラムに値を格納するときに、小数部を破棄し、それを格納しません。
      </p><p>
        MySQL 5.6.4 以降では、マイクロ秒 (6 桁) までの精度を持つ <code class="literal">TIME</code>、<code class="literal">DATETIME</code>、および <code class="literal">TIMESTAMP</code> 値に対して小数秒のサポートを拡張しています。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            小数秒部を含むカラムを定義するには、<code class="literal"><em class="replaceable"><code>type_name</code></em>(<em class="replaceable"><code>fsp</code></em>)</code> の構文を使用します。ここで、<em class="replaceable"><code>type_name</code></em> は <code class="literal">TIME</code>、<code class="literal">DATETIME</code>、または <code class="literal">TIMESTAMP</code> であり、<em class="replaceable"><code>fsp</code></em> は小数秒の精度です。例:
          </p><pre class="programlisting">
CREATE TABLE t1 (t TIME(3), dt DATETIME(6));
</pre><p>
            <em class="replaceable"><code>fsp</code></em> 値を指定する場合、0 から 6 の範囲にする必要があります。0 の値は、小数部がないことを表します。省略した場合、デフォルトの精度は 0 です。(これは、以前の MySQL バージョンと互換性を保つため、標準 SQL のデフォルトである 6 とは異なっています。)
          </p></li><li class="listitem"><p>
            小数秒部分を持つ <code class="literal">TIME</code>、<code class="literal">DATE</code>、または <code class="literal">TIMESTAMP</code> 値を同じ型のカラムに挿入するが、小数部の桁数が少ない場合、次の例に示すように丸めが行われます。
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE fractest( c1 TIME(2), c2 DATETIME(2), c3 TIMESTAMP(2) );</code></strong>
Query OK, 0 rows affected (0.33 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO fractest VALUES</code></strong> 
     &gt; <strong class="userinput"><code>('17:51:04.777', '2014-09-08 17:51:04.777', '2014-09-08 17:51:04.777');</code></strong>
Query OK, 1 row affected (0.03 sec)

mysql&gt; <strong class="userinput"><code>SELECT * FROM fractest;</code></strong>
+-------------+------------------------+------------------------+
| c1          | c2                     | c3                     |
+-------------+------------------------+------------------------+
| 17:51:04.78 | 2014-09-08 17:51:04.78 | 2014-09-08 17:51:04.78 |
+-------------+------------------------+------------------------+
1 row in set (0.00 sec)
</pre><p>
            このような丸め行われたときに、警告やエラーは表示されません。この動作は、SQL 標準に従い、サーバーの <code class="literal">sql_mode</code> 設定の影響は受けません。
          </p></li><li class="listitem"><p>
            時間引数を取る関数は、小数秒を含む値を受け入れます。時間関数からの戻り値には、必要に応じて小数秒が含まれます。たとえば、引数を付けない <code class="literal">NOW()</code> は、小数部のない現在の日付と時間を返しますが、0 から 6 のオプション引数を取って、その桁数の小数秒部が戻り値に含まれていることを指定します。
          </p></li><li class="listitem"><p>
            時間リテラルの構文は、<code class="literal">DATE '<em class="replaceable"><code>str</code></em>'</code>、<code class="literal">TIME '<em class="replaceable"><code>str</code></em>'</code>、および <code class="literal">TIMESTAMP '<em class="replaceable"><code>str</code></em>'</code> の時間値と ODBC 構文同等の値を生み出します。指定されている場合、結果の値には後続の小数秒部分が含まれます。以前は、時間型キーワードは無視され、これらの構造は文字列値を生成していました。<a class="xref" href="language-structure.html#date-and-time-standard-sql-literals" title="標準 SQL と ODBC の日付および時間リテラル">標準 SQL と ODBC の日付および時間リテラル</a>を参照してください。
          </p></li></ul></div><p>
        場合によっては、以前に受け入れられていた構文が別の結果を生成することがあります。次の項目は、問題を回避するために既存のコードのどの箇所を変更する必要があるかを示します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            式の中には、以前の結果とは異なる結果を生成するものがあります。例: <code class="literal">timestamp</code> システム変数は、整数ではなくマイクロ秒小数部を含む値を返します。現在の時間を含む結果を返す関数 (<code class="literal">CURTIME()</code>、<code class="literal">SYSDATE()</code>、<code class="literal">UTC_TIMESTAMP()</code> など) は、<em class="replaceable"><code>fsp</code></em> 値として引数を解釈し、戻り値にはその桁の小数秒部分が含まれます。以前には、これらの関数は引数を許可していましたが、無視していました。
          </p></li><li class="listitem"><p>
            <code class="literal">TIME</code> 値は、現在の日付に時間を追加することにより <code class="literal">DATETIME</code> に変換されます。(これは、時間値が <code class="literal">'00:00:00'</code> から <code class="literal">'23:59:59'</code> の範囲から外れている場合に、結果の日付部分が現在の日付と異なることを意味します。)以前には、<code class="literal">TIME</code> 値の <code class="literal">DATETIME</code> への変換は信頼性がありませんでした。<a class="xref" href="data-types.html#date-and-time-type-conversion" title="11.3.7 日付と時間型間での変換">セクション11.3.7「日付と時間型間での変換」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <code class="literal">TIMESTAMP(<em class="replaceable"><code>N</code></em>)</code> は古い MySQL バージョンで許可されていましたが、<em class="replaceable"><code>N</code></em> は小数秒精度ではなく表示幅でした。この動作のサポートは MySQL 5.5.3 で廃止されたので、適度に最新の状態に維持されているアプリケーションであれば、この問題の影響を受けません。それ以外の場合では、コードを書き換える必要があります。
          </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="date-and-time-type-conversion"></a>11.3.7 日付と時間型間での変換</h3></div></div></div><p>
        ある程度まで、ある時間型から別の時間型に値を変換できます。ただし、値の変更や情報の損失が生じることがあります。どの場合でも、時間型間の変換は、変換される型で有効な値の範囲に依存します。たとえば、<code class="literal">DATE</code>、<code class="literal">DATETIME</code>、および <code class="literal">TIMESTAMP</code> 値はすべて、同じセットの形式を使用して指定できますが、すべての型で値の範囲が同じであるわけではありません。<code class="literal">TIMESTAMP</code> 値は、<code class="literal">1970</code> UTC より古い値にしたり、<code class="literal">'2038-01-19 03:14:07'</code> UTC より新しい値にしたりできません。つまり、<code class="literal">'1968-01-01'</code> などの日付は、<code class="literal">DATE</code> または <code class="literal">DATETIME</code> 値としては有効ですが、<code class="literal">TIMESTAMP</code> 値としては有効ではなく、<code class="literal">0</code> に変換されます。
      </p><p>
        <code class="literal">DATE</code> 値の変換:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">DATE</code> 値には時間情報が含まれないので、<code class="literal">DATETIME</code> または <code class="literal">TIMESTAMP</code> 値に変換すると、<code class="literal">'00:00:00'</code> の時間部分が追加されます。
          </p></li><li class="listitem"><p>
            <code class="literal">TIME</code> 値への変換は有用ではありません。結果は <code class="literal">'00:00:00'</code> になります。
          </p></li></ul></div><p>
        <code class="literal">DATETIME</code> および <code class="literal">TIMESTAMP</code> 値の変換:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">DATE</code> 型には時間情報が含まれないので、<code class="literal">DATE</code> 値に変換すると時間部分が破棄されます。
          </p></li><li class="listitem"><p>
            <code class="literal">TIME</code> 型には日付情報が含まれないので、<code class="literal">TIME</code> 値に変換すると日付部分が破棄されます。
          </p></li></ul></div><p>
        <code class="literal">TIME</code> 値のほかの時間型への変換はバージョンによって異なります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            MySQL 5.6.4 以降では、<code class="literal">CURRENT_DATE()</code> の値が日付部分に使用されます。<code class="literal">TIME</code> は (時間ではなく) 経過時間として解釈され、日付に追加されます。これは、時間値が <code class="literal">'00:00:00'</code> から <code class="literal">'23:59:59'</code> の範囲から外れている場合に、結果の日付部分が現在の日付と異なることを意味します。
          </p><p>
            現在の日付が <code class="literal">'2012-01-01'</code> であるとします。<code class="literal">'12:00:00'</code>、<code class="literal">'24:00:00'</code>、<code class="literal">'-12:00:00'</code> の <code class="literal">TIME</code> 値は、<code class="literal">DATETIME</code> または <code class="literal">TIMESTAMP</code> 値に変換されると、それぞれ <code class="literal">'2012-01-01 12:00:00'</code>、<code class="literal">'2012-01-02 00:00:00'</code>、<code class="literal">'2011-12-31 12:00:00'</code> になります。
          </p><p>
            <code class="literal">TIME</code> から <code class="literal">DATE</code> への変換も同様ですが、結果から時間部分が破棄され、それぞれ <code class="literal">'2012-01-01'</code>、<code class="literal">'2012-01-02'</code>、<code class="literal">'2011-12-31'</code> になります。
          </p></li><li class="listitem"><p>
            5.6.4 より前の MySQL では、時間の文字列を日付または日付時間として解析することによって、時間値を日付または日付時間値に変換します。これが役立つ可能性はありません。たとえば、<code class="literal">'23:12:31'</code> は、日付として解釈されると <code class="literal">'2023-12-31'</code> になります。日付として有効でない時間は <code class="literal">'0000-00-00'</code> または <code class="literal">NULL</code> になります。
          </p></li></ul></div><p>
        明示的な変換を使用して暗黙的な変換をオーバーライドできます。たとえば、<code class="literal">DATE</code> および <code class="literal">DATETIME</code> 値の比較で、<code class="literal">DATE</code> 値は、<code class="literal">'00:00:00'</code> の時間部分を追加することにより、強制的に <code class="literal">DATETIME</code> 型に変更されます。代わりに <code class="literal">DATETIME</code> 値の時間部分を無視して比較を実行するには、次の方法で <code class="literal">CAST()</code> 関数を使用します。
      </p><pre class="programlisting">
<em class="replaceable"><code>date_col</code></em> = CAST(<em class="replaceable"><code>datetime_col</code></em> AS DATE)
</pre><p>
        <code class="literal">TIME</code> および <code class="literal">DATETIME</code> 値の数値形式への (<code class="literal">+0</code> の追加などによる) 変換は、次のように行われます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            MySQL 5.6.4 以降では、<code class="literal">TIME(<em class="replaceable"><code>N</code></em>)</code> または <code class="literal">DATETIME(<em class="replaceable"><code>N</code></em>)</code> は、<em class="replaceable"><code>N</code></em> が 0 (または省略) の場合は整数に、<em class="replaceable"><code>N</code></em> が正の数の場合は <em class="replaceable"><code>N</code></em> の 10 進数を含む <code class="literal">DECIMAL</code> 値に変換されます。
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT CURTIME(), CURTIME()+0, CURTIME(3)+0;</code></strong>
+-----------+-------------+--------------+
| CURTIME() | CURTIME()+0 | CURTIME(3)+0 |
+-----------+-------------+--------------+
| 09:28:00  |       92800 |    92800.887 |
+-----------+-------------+--------------+
mysql&gt; <strong class="userinput"><code>SELECT NOW(), NOW()+0, NOW(3)+0;</code></strong>
+---------------------+----------------+--------------------+
| NOW()               | NOW()+0        | NOW(3)+0           |
+---------------------+----------------+--------------------+
| 2012-08-15 09:28:00 | 20120815092800 | 20120815092800.889 |
+---------------------+----------------+--------------------+
</pre></li><li class="listitem"><p>
            MySQL 5.6.4 より前では、変換の結果は、マイクロ秒部分が <code class="literal">.000000</code> である倍精度値になります。
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT CURTIME(), CURTIME()+0;</code></strong>
+-----------+--------------+
| CURTIME() | CURTIME()+0  |
+-----------+--------------+
| 09:28:00  | 92800.000000 |
+-----------+--------------+
mysql&gt; <strong class="userinput"><code>SELECT NOW(), NOW()+0;</code></strong>
+---------------------+-----------------------+
| NOW()               | NOW()+0               |
+---------------------+-----------------------+
| 2012-08-15 09:28:00 | 20120815092800.000000 |
+---------------------+-----------------------+
</pre></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="two-digit-years"></a>11.3.8 日付での 2 桁の年</h3></div></div></div><p>
        2 桁の年を含む日付の値は、世紀が不明なためあいまいです。MySQL では、年は内部的に 4 桁で格納されるため、そのような値は 4 桁の形式に変換する必要があります。
      </p><p>
        <code class="literal">DATETIME</code>、<code class="literal">DATE</code>、および <code class="literal">TIMESTAMP</code> 型では、MySQL は、次のルールを使用して、あいまいな年の値で指定された日付を変換します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">00-69</code> の範囲の値は <code class="literal">2000-2069</code> に変換されます。
          </p></li><li class="listitem"><p>
            <code class="literal">70-99</code> の範囲の値は <code class="literal">1970-1999</code> に変換されます。
          </p></li></ul></div><p>
        <code class="literal">YEAR</code> ではルールは同じですが、<code class="literal">YEAR(4)</code> に挿入された数値 <code class="literal">00</code> は <code class="literal">2000</code> ではなく <code class="literal">0000</code> になります。<code class="literal">YEAR(4)</code> にゼロを指定し、これを <code class="literal">2000</code> として解釈させるには、文字列 <code class="literal">'0'</code> または <code class="literal">'00'</code> としてこれを指定します。
      </p><p>
        これらのルールは、データ値が何を表すかを妥当に推測する単なる経験則であることを覚えておいてください。MySQL で使用されるルールで必要な値が生成されない場合、4 桁の年を含む明確な入力値を指定する必要があります。
      </p><p>
        <code class="literal">ORDER BY</code> は、2 桁の年を持つ <code class="literal">YEAR</code> 値を正しくソートします。
      </p><p>
        <code class="literal">MIN()</code> や <code class="literal">MAX()</code> などの一部の関数は、<code class="literal">YEAR</code> を数値に変換します。つまり、2 桁の年の値は、これらの関数では正しく機能しません。この場合の解決策としては、<code class="literal">YEAR</code> を 4 桁の年の形式に変換します。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="string-types"></a>11.4 文字列型</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="data-types.html#char">11.4.1 CHAR および VARCHAR 型</a></span></dt><dt><span class="section"><a href="data-types.html#binary-varbinary">11.4.2 BINARY および VARBINARY 型</a></span></dt><dt><span class="section"><a href="data-types.html#blob">11.4.3 BLOB 型と TEXT 型</a></span></dt><dt><span class="section"><a href="data-types.html#enum">11.4.4 ENUM 型</a></span></dt><dt><span class="section"><a href="data-types.html#set">11.4.5 SET 型</a></span></dt></dl></div><a class="indexterm" name="idm139979102785648"></a><a class="indexterm" name="idm139979102783504"></a><a class="indexterm" name="idm139979102782160"></a><a class="indexterm" name="idm139979102780800"></a><a class="indexterm" name="idm139979102779424"></a><a class="indexterm" name="idm139979102777504"></a><p>
      文字列型には、<code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、<code class="literal">BINARY</code>、<code class="literal">VARBINARY</code>、<code class="literal">BLOB</code>、<code class="literal">TEXT</code>、<code class="literal">ENUM</code>、および <code class="literal">SET</code> があります。このセクションでは、これらの型の機能と、クエリーでの使用方法について説明します。文字列型のストレージ要件については、<a class="xref" href="data-types.html#storage-requirements" title="11.7 データ型のストレージ要件">セクション11.7「データ型のストレージ要件」</a>を参照してください。
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="char"></a>11.4.1 CHAR および VARCHAR 型</h3></div></div></div><p>
        <code class="literal">CHAR</code> 型と <code class="literal">VARCHAR</code> 型は似ていますが、格納および取得方法が異なります。また、最大長と、末尾のスペースが保持されるかどうかという点でも異なります。
      </p><p>
        <code class="literal">CHAR</code> 型と <code class="literal">VARCHAR</code> 型には、格納する最大文字数を表す長さが宣言されています。たとえば、<code class="literal">CHAR(30)</code> には最大 30 文字を格納できます。
      </p><p>
        <code class="literal">CHAR</code> カラムの長さは、テーブルを作成したときに宣言した長さに修正されます。この長さには、0 から 255 までの任意の値を指定できます。<code class="literal">CHAR</code> 値は格納されると、指定された長さになるように右側がスペースで埋められます。<code class="literal">PAD_CHAR_TO_FULL_LENGTH</code> SQL モードが有効になっていないかぎり、<code class="literal">CHAR</code> 値が取り出されるときに、末尾のスペースが削除されます。
      </p><p>
        <code class="literal">VARCHAR</code> カラム内の値は可変長の文字列です。長さは 0 から 65,535 までの値で指定できます。<code class="literal">VARCHAR</code> カラムの有効な最大長は、最大行サイズ (65,535 バイト、すべてのカラムで共有される) と使用される文字セットによって決まります。<a class="xref" href="restrictions.html#column-count-limit" title="D.10.4 テーブルカラム数と行サイズの制限">セクションD.10.4「テーブルカラム数と行サイズの制限」</a>を参照してください。
      </p><p>
        <code class="literal">CHAR</code> とは対照的に、<code class="literal">VARCHAR</code> 値は、1 バイトまたは 2 バイト長のプリフィクスの付いたデータとして格納されます。長さプリフィクスは、値に含まれるバイト数を示します。255 バイト以下の値を格納するカラムでは 1 バイト長のプリフィクスを使用し、255 バイトよりも大きい値を格納するカラムでは 2 バイト長のプリフィクスを使用します。
      </p><p>
        厳密な SQL モードが有効でない場合に、<code class="literal">CHAR</code> または <code class="literal">VARCHAR</code> カラムにその最大長を超える値を割り当てると、その値はカラムの最大長に合わせて切り捨てられ、警告メッセージが表示されます。スペース以外の文字の切り捨てに関しては、厳密な SQL モードを使用することで、警告ではなくエラーを発生させて、その値の挿入を抑制できます。<a class="xref" href="server-administration.html#sql-mode" title="5.1.7 サーバー SQL モード">セクション5.1.7「サーバー SQL モード」</a>を参照してください。
      </p><p>
        <code class="literal">VARCHAR</code> カラムの場合、使用している SQL モードに関係なく、カラム長を超える末尾のスペースは挿入前に切り捨てられ、警告メッセージが表示されます。<code class="literal">CHAR</code> カラムの場合、SQL モードに関係なく、超過した末尾のスペースは通知なしに挿入される値から切り捨てられます。
      </p><p>
        <code class="literal">VARCHAR</code> 値は格納されるときに埋められません。標準 SQL に従い、値を格納し取り出すときに末尾のスペースは保持されます。
      </p><p>
        次の表は、<code class="literal">CHAR(4)</code> カラムと <code class="literal">VARCHAR(4)</code> カラムにさまざまな文字列値を格納した結果を表示して、<code class="literal">CHAR</code> と <code class="literal">VARCHAR</code> の違いを示しています (カラムには <code class="literal">latin1</code> などのシングルバイト文字セットを使用するものとします)。
      </p><div class="informaltable"><table summary="次の表は、CHAR(4) カラムと VARCHAR(4) カラム内のさまざまな文字列値に必要なストレージを示すことにより、CHAR と VARCHAR のストレージ要件の違いを示します。" border="1"><colgroup><col><col><col><col><col></colgroup><thead><tr><th scope="col">値</th><th scope="col"><code class="literal">CHAR(4)</code></th><th scope="col">必要なストレージ</th><th scope="col"><code class="literal">VARCHAR(4)</code></th><th scope="col">必要なストレージ</th></tr></thead><tbody><tr><td scope="row"><code class="literal">''</code></td><td><code class="literal">'    '</code></td><td>4 バイト</td><td><code class="literal">''</code></td><td>1 バイト</td></tr><tr><td scope="row"><code class="literal">'ab'</code></td><td><code class="literal">'ab  '</code></td><td>4 バイト</td><td><code class="literal">'ab'</code></td><td>3 バイト</td></tr><tr><td scope="row"><code class="literal">'abcd'</code></td><td><code class="literal">'abcd'</code></td><td>4 バイト</td><td><code class="literal">'abcd'</code></td><td>5 バイト</td></tr><tr><td scope="row"><code class="literal">'abcdefgh'</code></td><td><code class="literal">'abcd'</code></td><td>4 バイト</td><td><code class="literal">'abcd'</code></td><td>5 バイト</td></tr></tbody></table></div><p>
        テーブルの最終行に格納済みとして示されている値は、<span class="emphasis"><em>厳密モードを使用していないときにだけ</em></span>当てはまります。MySQL が厳密モードで実行されている場合、カラム長を超える値は<span class="emphasis"><em>格納されず</em></span>、エラーが発生します。
      </p><p>
        所定の値が <code class="literal">CHAR(4)</code> および <code class="literal">VARCHAR(4)</code> カラムに格納されると、取り出しのときに末尾のスペースが <code class="literal">CHAR</code> カラムから削除されるので、カラムから取り出された値は必ずしも同じではありません。次の例はこの違いを示しています。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE vc (v VARCHAR(4), c CHAR(4));</code></strong>
Query OK, 0 rows affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO vc VALUES ('ab  ', 'ab  ');</code></strong>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT CONCAT('(', v, ')'), CONCAT('(', c, ')') FROM vc;</code></strong>
+---------------------+---------------------+
| CONCAT('(', v, ')') | CONCAT('(', c, ')') |
+---------------------+---------------------+
| (ab  )              | (ab)                |
+---------------------+---------------------+
1 row in set (0.06 sec)
</pre><p>
        <code class="literal">CHAR</code> カラムと <code class="literal">VARCHAR</code> カラムの値は、そのカラムに割り当てられた文字セットの照合順序に従ってソートおよび比較されます。
      </p><p>
        MySQL のすべての照合順序は、<code class="literal">PADSPACE</code> 型のものです。これは、MySQL 内のすべての <code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、および <code class="literal">TEXT</code> 値が、末尾のスペースに関係なく比較されることを意味します。このコンテキストでの<span class="quote">「<span class="quote">比較</span>」</span>には、末尾のスペースが意味を持つ <code class="literal">LIKE</code> パターンマッチング演算子は含まれません。例:
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE names (myname CHAR(10));</code></strong>
Query OK, 0 rows affected (0.03 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO names VALUES ('Monty');</code></strong>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT myname = 'Monty', myname = 'Monty  ' FROM names;</code></strong>
+------------------+--------------------+
| myname = 'Monty' | myname = 'Monty  ' |
+------------------+--------------------+
|                1 |                  1 |
+------------------+--------------------+
1 row in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT myname LIKE 'Monty', myname LIKE 'Monty  ' FROM names;</code></strong>
+---------------------+-----------------------+
| myname LIKE 'Monty' | myname LIKE 'Monty  ' |
+---------------------+-----------------------+
|                   1 |                     0 |
+---------------------+-----------------------+
1 row in set (0.00 sec)
</pre><p>
        これは MySQL のすべてのバージョンに当てはまり、サーバーの SQL モードの影響は受けません。
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">注記</div><p>
          MySQL の文字セットおよび照合順序の詳細は、<a class="xref" href="globalization.html#charset" title="10.1 文字セットのサポート">セクション10.1「文字セットのサポート」</a>を参照してください。ストレージ要件の追加情報については、<a class="xref" href="data-types.html#storage-requirements" title="11.7 データ型のストレージ要件">セクション11.7「データ型のストレージ要件」</a>を参照してください。
        </p></div><p>
        末尾の埋め込み文字が取り除かれたり、比較で無視されたりする場合では、一意の値を必要とするインデックスがカラムに含まれていれば、末尾の埋め込み文字の個数だけが異なるカラム値への挿入は、重複キーエラーになります。たとえば、テーブルに <code class="literal">'a'</code> が含まれている場合、<code class="literal">'a '</code> を格納しようとすると、重複キーエラーが発生します。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="binary-varbinary"></a>11.4.2 BINARY および VARBINARY 型</h3></div></div></div><a class="indexterm" name="idm139979102684496"></a><a class="indexterm" name="idm139979102683056"></a><a class="indexterm" name="idm139979102681664"></a><a class="indexterm" name="idm139979102679744"></a><p>
        <code class="literal">BINARY</code> および <code class="literal">VARBINARY</code> 型は、<code class="literal">CHAR</code> および <code class="literal">VARCHAR</code> 型に似ていますが、非バイナリ文字列ではなく、バイナリ文字列を格納します。つまり、それらには文字の文字列ではなく、バイトの文字列が含まれています。これは、それらに文字セットがなく、ソートおよび比較は値の中のバイトの数値に基づいていることを意味します。
      </p><p>
        <code class="literal">BINARY</code> および <code class="literal">VARBINARY</code> で許可される最大長は、<code class="literal">CHAR</code> および <code class="literal">VARCHAR</code> の場合と同じですが、<code class="literal">BINARY</code> および <code class="literal">VARBINARY</code> の長さが文字数ではなくバイト数で表される点が異なります。
      </p><p>
        <code class="literal">BINARY</code> および <code class="literal">VARBINARY</code> データ型は <code class="literal">CHAR BINARY</code> および <code class="literal">VARCHAR BINARY</code> データ型とは異なります。後者の型は、<code class="literal">BINARY</code> 属性によってカラムがバイナリ文字列カラムとして扱われることはありません。その代わり、これによってカラムの文字セットのバイナリ照合順序が使用され、カラム自体にはバイナリバイト文字列ではなく非バイナリ文字列が格納されます。たとえば、<code class="literal">CHAR(5) BINARY</code> は、デフォルト文字セットが <code class="literal">latin1</code> とすれば、<code class="literal">CHAR(5) CHARACTER SET latin1 COLLATE latin1_bin</code> として扱われます。これは、文字セットや照合順序を持たない 5 バイトのバイナリ文字列を格納する <code class="literal">BINARY(5)</code> とは異なります。非バイナリ文字列のバイナリ照合順序とバイナリ文字列の違いについては、<a class="xref" href="globalization.html#charset-binary-collations" title="10.1.7.6 _bin および binary 照合順序">セクション10.1.7.6「_bin および binary 照合順序」</a>を参照してください。
      </p><p>
        厳密な SQL モードが有効でない場合に、<code class="literal">BINARY</code> または <code class="literal">VARBINARY</code> カラムにその最大長を超える値を割り当てると、その値はカラムの最大長に合わせて切り捨てられ、警告メッセージが表示されます。値を切り捨てる場合、厳密な SQL モードを使用することで、警告ではなくエラーを発生させて、その値の挿入を抑制できます。<a class="xref" href="server-administration.html#sql-mode" title="5.1.7 サーバー SQL モード">セクション5.1.7「サーバー SQL モード」</a>を参照してください。
      </p><p>
        <code class="literal">BINARY</code> 値は格納されると、特定の長さまで右側がパッド値で埋められます。パッド値は <code class="literal">0x00</code> (ゼロバイト) です。値は挿入時には右側が <code class="literal">0x00</code> で埋められ、選択時に後続のバイトは削除されません。すべてのバイトは、<code class="literal">ORDER BY</code> および <code class="literal">DISTINCT</code> 操作を含め比較で意味があります。<code class="literal">0x00</code> バイトとスペースは比較では異なり、<code class="literal">0x00</code> &lt; スペースです。
      </p><p>
        例: <code class="literal">BINARY(3)</code> カラムの場合、<code class="literal">'a '</code> は挿入時に <code class="literal">'a \0'</code> になります。<code class="literal">'a\0'</code> は挿入時に <code class="literal">'a\0\0'</code> になります。選択時、挿入された両方の値は変更されません。
      </p><p>
        <code class="literal">VARBINARY</code> では、挿入時にパディングされることも、選択時にバイトが削除されることもありません。すべてのバイトは、<code class="literal">ORDER BY</code> および <code class="literal">DISTINCT</code> 操作を含め比較で意味があります。<code class="literal">0x00</code> バイトとスペースは比較では異なり、<code class="literal">0x00</code> &lt; スペースです。
      </p><p>
        後続のパッドバイトが取り除かれたり、比較で無視されたりする場合では、一意の値を必要とするインデックスがカラムに含まれていれば、後続のパッドバイトの個数だけが異なるカラム値への挿入は、重複キーエラーになります。たとえば、テーブルに <code class="literal">'a'</code> が含まれている場合、<code class="literal">'a\0'</code> を格納しようとすると、重複キーエラーが発生します。
      </p><p>
        バイナリデータの格納に <code class="literal">BINARY</code> データ型を使用する予定であり、取り出した値を格納した値とまったく同じにする必要がある場合は、先行のパディングと削除文字を考慮する必要があります。次の例は、<code class="literal">BINARY</code> 値の <code class="literal">0x00</code> パディングによって、カラム値の比較がどのような影響を受けるかについて示しています。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE t (c BINARY(3));</code></strong>
Query OK, 0 rows affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>INSERT INTO t SET c = 'a';</code></strong>
Query OK, 1 row affected (0.01 sec)

mysql&gt; <strong class="userinput"><code>SELECT HEX(c), c = 'a', c = 'a\0\0' from t;</code></strong>
+--------+---------+-------------+
| HEX(c) | c = 'a' | c = 'a\0\0' |
+--------+---------+-------------+
| 610000 |       0 |           1 |
+--------+---------+-------------+
1 row in set (0.09 sec)
</pre><p>
        取り出される値を、パディングなしのストレージに指定した値と同じにする必要がある場合は、代わりに <code class="literal">VARBINARY</code> か、いずれかの <code class="literal">BLOB</code> データ型を使用することをお勧めします。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="blob"></a>11.4.3 BLOB 型と TEXT 型</h3></div></div></div><a class="indexterm" name="idm139979102626240"></a><a class="indexterm" name="idm139979102624768"></a><a class="indexterm" name="idm139979102623408"></a><a class="indexterm" name="idm139979102621488"></a><a class="indexterm" name="idm139979102619456"></a><a class="indexterm" name="idm139979102617984"></a><p>
        <code class="literal">BLOB</code> はさまざまな容量のデータを保持できる大きなバイナリオブジェクトです。<code class="literal">BLOB</code> 型は、<code class="literal">TINYBLOB</code>、<code class="literal">BLOB</code>、<code class="literal">MEDIUMBLOB</code>、および <code class="literal">LONGBLOB</code> の 4 つがあります。これらの違いは、保持できる値の最大長だけです。<code class="literal">TEXT</code> 型は、<code class="literal">TINYTEXT</code>、<code class="literal">TEXT</code>、<code class="literal">MEDIUMTEXT</code>、および <code class="literal">LONGTEXT</code> の 4 つがあります。これらは 4 つの <code class="literal">BLOB</code> 型に対応し、最大長とストレージ要件は同じです。<a class="xref" href="data-types.html#storage-requirements" title="11.7 データ型のストレージ要件">セクション11.7「データ型のストレージ要件」</a>を参照してください。
      </p><p>
        <code class="literal">BLOB</code> 値はバイナリ文字列 (バイトの文字列) として扱われます。これらには文字セットがなく、ソートおよび比較はカラム値内のバイトの数値に基づきます。<code class="literal">TEXT</code> 値は非バイナリ文字列 (文字の文字列) として扱われます。これらには文字セットがあり、値は文字セットの照合順序に基づいてソートおよび比較されます。
      </p><p>
        厳密な SQL モードが有効でない場合に、<code class="literal">BLOB</code> または <code class="literal">TEXT</code> カラムにその最大長を超える値を割り当てると、その値はカラムの最大長に合わせて切り捨てられ、警告メッセージが表示されます。スペース以外の文字の切り捨てに関しては、厳密な SQL モードを使用することで、警告ではなくエラーを発生させて、その値の挿入を抑制できます。<a class="xref" href="server-administration.html#sql-mode" title="5.1.7 サーバー SQL モード">セクション5.1.7「サーバー SQL モード」</a>を参照してください。
      </p><p>
        <code class="literal">TEXT</code> カラムに挿入される値から、超過した末尾のスペースを切り捨てると、SQL モードには関係なく、常に警告が生成されます。
      </p><p>
        <code class="literal">TEXT</code> および <code class="literal">BLOB</code> カラムでは、挿入時にパディングは行われず、選択時にバイトは削除されません。
      </p><p>
        <code class="literal">TEXT</code> カラムにインデックスが設定されている場合、インデックスエントリの比較では末尾がスペースで埋められます。これは、インデックスに一意の値が必要な場合、末尾のスペースの個数だけが異なる値に対して重複キーエラーが発生するということを意味します。たとえば、テーブルに <code class="literal">'a'</code> が含まれている場合、<code class="literal">'a '</code> を格納しようとすると、重複キーエラーが発生します。これは <code class="literal">BLOB</code> カラムには当てはまりません。
      </p><p>
        ほとんどの点で、<code class="literal">BLOB</code> カラムを、任意の長さに設定できる <code class="literal">VARBINARY</code> カラムと見なすことができます。同様に、<code class="literal">TEXT</code> カラムを <code class="literal">VARCHAR</code> カラムと見なすことができます。<code class="literal">BLOB</code> と <code class="literal">TEXT</code> は、次の点で <code class="literal">VARBINARY</code> と <code class="literal">VARCHAR</code> とは異なっています。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">BLOB</code> と <code class="literal">TEXT</code> カラムのインデックスには、インデックスプリフィクス長を指定する必要があります。<code class="literal">CHAR</code> と <code class="literal">VARCHAR</code> では、プリフィクス長はオプションです。<a class="xref" href="optimization.html#column-indexes" title="8.3.4 カラムインデックス">セクション8.3.4「カラムインデックス」</a>を参照してください。
          </p></li><li class="listitem"><p>
            <a class="indexterm" name="idm139979102577792"></a> <a class="indexterm" name="idm139979102575616"></a> <a class="indexterm" name="idm139979102573568"></a> <code class="literal">BLOB</code> および <code class="literal">TEXT</code> カラムに <code class="literal">DEFAULT</code> 値を含めることはできません。
          </p></li></ul></div><p>
        <code class="literal">BINARY</code> 属性を <code class="literal">TEXT</code> データ型と一緒に使用した場合、カラム文字セットのバイナリ照合順序がそのカラムに割り当てられます。
      </p><p>
        <code class="literal">LONG</code> と <code class="literal">LONG VARCHAR</code> は <code class="literal">MEDIUMTEXT</code> データ型にマップします。これは互換性機能です。
      </p><p>
        MySQL Connector/ODBC は <code class="literal">BLOB</code> 値を <code class="literal">LONGVARBINARY</code> として、<code class="literal">TEXT</code> 値を <code class="literal">LONGVARCHAR</code> として定義します。
      </p><p>
        <code class="literal">BLOB</code> 値と <code class="literal">TEXT</code> 値は非常に長くなる可能性があるので、使用するときに次の制約が生じることがあります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            ソート時には、カラムの <code class="literal">max_sort_length</code> バイトだけが使用されます。<code class="literal">max_sort_length</code> のデフォルト値は 1024 です。サーバーの起動時または実行時に、<code class="literal">max_sort_length</code> の値を増やすことによって、ソートまたはグループ化に影響するバイトを増やすことができます。すべてのクライアントで <code class="literal">max_sort_length</code> セッション変数の値を変更できます。
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET max_sort_length = 2000;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT id, comment FROM t</code></strong>
    -&gt; <strong class="userinput"><code>ORDER BY comment;</code></strong>
</pre></li><li class="listitem"><p>
            一時テーブルを使用して処理されるクエリーの結果に <code class="literal">BLOB</code> カラムまたは <code class="literal">TEXT</code> カラムのインスタンスがあると、<code class="literal">MEMORY</code> ストレージエンジンがこれらのデータ型をサポートしていないので、サーバーはメモリー内ではなくディスク上でテーブルを使用します (<a class="xref" href="optimization.html#internal-temporary-tables" title="8.4.4 MySQL が内部一時テーブルを使用する仕組み">セクション8.4.4「MySQL が内部一時テーブルを使用する仕組み」</a>を参照してください)。ディスクの使用はパフォーマンスの低下を伴うので、クエリーの結果に <code class="literal">BLOB</code> カラムまたは <code class="literal">TEXT</code> カラムを含めるのは必要な場合に限定してください。たとえば、<code class="literal">SELECT *</code> はすべてのカラムを選択するので使用しないでください。
          </p></li><li class="listitem"><p>
            <code class="literal">BLOB</code> または <code class="literal">TEXT</code> オブジェクトの最大サイズはその型で決まりますが、クライアントとサーバー間で実際に送信できる最大値は、使用可能なメモリーの容量と通信バッファーのサイズで決まります。<code class="literal">max_allowed_packet</code> 変数の値を変更することでメッセージバッファーサイズを変更できますが、サーバーとクライアントプログラムの両方で変更する必要があります。たとえば、<span class="command"><strong>mysql</strong></span> と <span class="command"><strong>mysqldump</strong></span> のどちらを使用しても、クライアント側の <code class="literal">max_allowed_packet</code> 値を変更できます。<a class="xref" href="optimization.html#server-parameters" title="8.11.2 サーバーパラメータのチューニング">セクション8.11.2「サーバーパラメータのチューニング」</a>、<a class="xref" href="programs.html#mysql" title="4.5.1 mysql — MySQL コマンド行ツール">セクション4.5.1「<span class="command"><strong>mysql</strong></span> — MySQL コマンド行ツール」</a>、<a class="xref" href="programs.html#mysqldump" title="4.5.4 mysqldump — データベースバックアッププログラム">セクション4.5.4「<span class="command"><strong>mysqldump</strong></span> — データベースバックアッププログラム」</a>を参照してください。パケットサイズおよびソートしているデータオブジェクトのサイズを、ストレージ要件と比較することもできます。<a class="xref" href="data-types.html#storage-requirements" title="11.7 データ型のストレージ要件">セクション11.7「データ型のストレージ要件」</a>を参照してください。
          </p></li></ul></div><p>
        <code class="literal">BLOB</code> 値または <code class="literal">TEXT</code> 値はそれぞれ、別々に割り当てられたオブジェクトによって内部的に表現されます。これは、テーブルが開かれるときにカラムごとに一度ストレージが割り当てられる、ほかのすべてのデータ型と対照的です。
      </p><p>
        メディアファイルなどのバイナリデータを <code class="literal">BLOB</code> または <code class="literal">TEXT</code> カラムに格納するほうがよい場合もあります。このようなデータの処理には、MySQL の文字列操作関数が役立つことがあります。<a class="xref" href="functions.html#string-functions" title="12.5 文字列関数">セクション12.5「文字列関数」</a>を参照してください。セキュリティーなどの理由のために、通常は、アプリケーションユーザーに <code class="literal">FILE</code> 権限を与えるのではなく、アプリケーションコードを使用して実行することをお勧めします。MySQL フォーラム (<a class="ulink" href="http://forums.mysql.com/" target="_top">http://forums.mysql.com/</a>) では、さまざまな言語やプラットフォームの詳細について話し合うことができます。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="enum"></a>11.4.4 ENUM 型</h3></div></div></div><a class="indexterm" name="idm139979102524144"></a><a class="indexterm" name="idm139979102522672"></a><p>
        <code class="literal">ENUM</code> は、テーブル作成時にカラム仕様に明示的に列挙された、許可されている値のリストから選択された値を持つ文字列オブジェクトです。これには次の利点があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            指定可能な値のセットがカラムで制限されている状況でのコンパクトなデータストレージ。入力値として指定した文字列は自動的に数値としてエンコードされます。<code class="literal">ENUM</code> 型のストレージ要件については、<a class="xref" href="data-types.html#storage-requirements" title="11.7 データ型のストレージ要件">セクション11.7「データ型のストレージ要件」</a>を参照してください。
          </p></li><li class="listitem"><p>
            読みやすいクエリーと出力。数値は、クエリー結果で対応する文字列に戻されます。
          </p></li></ul></div><p>
        また、次のような考慮が必要な問題が生じる可能性があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <a class="xref" href="data-types.html#enum-limits" title="列挙の制限">Enumeration Limitations</a>で説明しているように、数値のように見える列挙値を作成した場合、リテラル値とその内部インデックス番号を混同しやすくなります。
          </p></li><li class="listitem"><p>
            <a class="xref" href="data-types.html#enum-sorting" title="列挙のソート">Enumeration Sorting</a>で説明しているように、<code class="literal">ORDER BY</code> 句で <code class="literal">ENUM</code> カラムを使用するには特に注意が必要です。
          </p></li></ul></div><h4><a name="enum-using"></a>ENUM カラムの作成と使用</h4><p>
        列挙値は引用符で囲んだ文字列リテラルにする必要があります。たとえば、次のように <code class="literal">ENUM</code> カラムを持つテーブルを作成できます。
      </p><pre class="programlisting">
CREATE TABLE shirts (
    name VARCHAR(40),
    size ENUM('x-small', 'small', 'medium', 'large', 'x-large')
);
INSERT INTO shirts (name, size) VALUES ('dress shirt','large'), ('t-shirt','medium'),
  ('polo shirt','small');
SELECT name, size FROM shirts WHERE size = 'medium';
+---------+--------+
| name    | size   |
+---------+--------+
| t-shirt | medium |
+---------+--------+
UPDATE shirts SET size = 'small' WHERE size = 'large';
COMMIT;
</pre><p>
        <code class="literal">'medium'</code> の値を持つ 100 万個の行をこのテーブルに挿入するには、100 万バイトのストレージが必要ですが、実際の文字列 <code class="literal">'medium'</code> を <code class="literal">VARCHAR</code> カラムに格納した場合は、600 万バイト必要になります。
      </p><h4><a name="enum-indexes"></a>列挙リテラルのインデックス値</h4><p>
        それぞれの列挙値にはインデックスが設定されています。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            カラム仕様にリストされている要素には、1 から始まるインデックス番号が割り当てられています。
          </p></li><li class="listitem"><p>
            空の文字列エラー値のインデックス値は 0 です。つまり、次の <code class="literal">SELECT</code> ステートメントを使用して、無効な <code class="literal">ENUM</code> 値が割り当てられた行を検索できます。
          </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>enum_col</code></em>=0;</code></strong>
</pre></li><li class="listitem"><p>
            <code class="literal">NULL</code> 値のインデックスは <code class="literal">NULL</code> です。
          </p></li><li class="listitem"><p>
            ここでの<span class="quote">「<span class="quote">インデックス</span>」</span>という語は、列挙値のリスト内での位置を示します。これは、テーブルインデックスとはまったく関係ありません。
          </p></li></ul></div><p>
        たとえば、<code class="literal">ENUM('Mercury', 'Venus', 'Earth')</code> と指定されたカラムには、次に示すどの値でも含めることができます。それぞれの値のインデックスも示しています。
      </p><div class="informaltable"><table summary="この表は、ENUM('Mercury', 'Venus', 'Earth') と指定されたカラムで指定可能な値を示します。表にはそれぞれの値のインデックスも示されています。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">値</th><th scope="col">インデックス</th></tr></thead><tbody><tr><td scope="row"><code class="literal">NULL</code></td><td><code class="literal">NULL</code></td></tr><tr><td scope="row"><code class="literal">''</code></td><td>0</td></tr><tr><td scope="row"><code class="literal">'Mercury'</code></td><td>1</td></tr><tr><td scope="row"><code class="literal">'Venus'</code></td><td>2</td></tr><tr><td scope="row"><code class="literal">'Earth'</code></td><td>3</td></tr></tbody></table></div><p>
        <code class="literal">ENUM</code> カラムには、最大 65,535 個の個別の要素を含めることができます。(実用的な限度は 3000 個までです。)テーブルには、グループと見なされる <code class="literal">ENUM</code> および <code class="literal">SET</code> カラムの中の一意の要素リスト定義を、255 個以下を含めることができます。これらの制限の詳細は、<a class="xref" href="restrictions.html#limits-frm-file" title="D.10.5 .frm ファイル構造により課せられる制限">セクションD.10.5「.frm ファイル構造により課せられる制限」</a>を参照してください。
      </p><p>
        <code class="literal">ENUM</code> 値を数値コンテキストで取得した場合、カラム値のインデックスが返されます。たとえば、次のように <code class="literal">ENUM</code> カラムから数値を取得できます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT <em class="replaceable"><code>enum_col</code></em>+0 FROM <em class="replaceable"><code>tbl_name</code></em>;</code></strong>
</pre><p>
        数値引数を取る <code class="literal">SUM()</code> や <code class="literal">AVG()</code> などの関数は、必要に応じて引数を数値にキャストします。<code class="literal">ENUM</code> 値の計算にはインデックス番号が使用されます。
      </p><h4><a name="enum-literals"></a>列挙リテラルの処理</h4><p>
        テーブルが作成されるときに、テーブル定義内の <code class="literal">ENUM</code> メンバー値から末尾のスペースが自動的に削除されます。
      </p><p>
        <code class="literal">ENUM</code> カラムに格納された値は、取得されたときに、カラム定義で使用された大文字/小文字で表示されます。<code class="literal">ENUM</code> カラムには文字セットと照合順序を割り当てられています。バイナリ照合順序、または大文字と小文字を区別する照合順序の場合、カラムに値を割り当てるときに、大文字/小文字が考慮されます。
      </p><p>
        <code class="literal">ENUM</code> カラムに数字を格納すると、その数字は指定可能な値のインデックスとして扱われ、格納された値がそのインデックスを持つ列挙メンバーとなります。(ただし、これはすべての入力を文字列として扱う <code class="literal">LOAD DATA</code> では機能 <span class="emphasis"><em>しません</em></span>。)数値が引用符で囲まれている場合、列挙値のリストに一致する文字列がなければ、そのままインデックスとして解釈されます。これらの理由により、<code class="literal">ENUM</code> カラムを数字のように見える列挙値で定義することは、混乱を招きやすくなるのでお勧めできません。たとえば、次のカラムには <code class="literal">'0'</code>、<code class="literal">'1'</code>、および <code class="literal">'2'</code> の文字列値を持つ列挙メンバーが指定されていますが、数値インデックス値は <code class="literal">1</code>、<code class="literal">2</code>、および <code class="literal">3</code> です。
      </p><pre class="programlisting">
numbers ENUM('0','1','2')
</pre><p>
        <code class="literal">2</code> を格納すると、それはインデックス値と解釈され、<code class="literal">'1'</code> (インデックス 2 の値) になります。<code class="literal">'2'</code> を格納すると、それは列挙値と一致するので、<code class="literal">'2'</code> として格納されます。<code class="literal">'3'</code> を格納すると、どの列挙値とも一致しないのでインデックスとして扱われ、<code class="literal">'2'</code> (インデックス 3 の値) になります。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>INSERT INTO t (numbers) VALUES(2),('2'),('3');</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT * FROM t;</code></strong>
+---------+
| numbers |
+---------+
| 1       |
| 2       |
| 2       |
+---------+
</pre><p>
        <code class="literal">ENUM</code> カラムのすべての指定可能な値を特定するには、<code class="literal">SHOW COLUMNS FROM <em class="replaceable"><code>tbl_name</code></em> LIKE '<em class="replaceable"><code>enum_col</code></em>'</code> を使用して、出力の <code class="literal">Type</code> カラム内の <code class="literal">ENUM</code> 定義を構文解析します。
      </p><p>
        C API では、<code class="literal">ENUM</code> 値は文字列として返されます。結果セットのメタデータを使用してこれらをほかの文字列から区別する方法については、<a class="xref" href="connectors-apis.html#c-api-data-structures" title="23.8.5 C API データ構造">セクション23.8.5「C API データ構造」</a>を参照してください。
      </p><h4><a name="enum-nulls"></a>空または NULL の列挙値</h4><p>
        以下のような特定の状況下では、列挙値は、空の文字列 (<code class="literal">''</code>) や <code class="literal">NULL</code> になることもあります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">ENUM</code> に無効な値 (つまり、許可された値のリストに存在しない文字列) を挿入すると、特殊なエラー値として空の文字列が代わりに挿入されます。この文字列は、この文字列に 0 の数値が含まれていることで、<span class="quote">「<span class="quote">通常</span>」</span>の空の文字列と区別できます。列挙値の数値インデックスの詳細は、<a class="xref" href="data-types.html#enum-indexes" title="列挙リテラルのインデックス値">Index Values for Enumeration Literals</a>を参照してください。
          </p><p>
            厳密な SQL モードが有効な場合は、無効な <code class="literal">ENUM</code> 値を挿入しようとするとエラーが発生します。
          </p></li><li class="listitem"><p>
            <code class="literal">ENUM</code> カラムが <code class="literal">NULL</code> を許可するように宣言されている場合、<code class="literal">NULL</code> 値は、そのカラムに対して有効な値であり、デフォルト値は <code class="literal">NULL</code> になります。<code class="literal">ENUM</code> カラムが <code class="literal">NOT NULL</code> として宣言されている場合、デフォルト値は許可されている値のリストの最初の要素になります。
          </p></li></ul></div><h4><a name="enum-sorting"></a>列挙のソート</h4><p>
        <code class="literal">ENUM</code> 値は、インデックス番号に基づいてソートされますが、この数値は、カラム仕様で列挙メンバーがリストされていた順序に従います。たとえば、<code class="literal">ENUM('b', 'a')</code> の場合、<code class="literal">'b'</code> は <code class="literal">'a'</code> の前にソートされます。空の文字列は空ではない文字列の前にソートされ、<code class="literal">NULL</code> 値はその他のすべての列挙値の前にソートされます。
      </p><p>
        <code class="literal">ENUM</code> カラムで <code class="literal">ORDER BY</code> 句の使用時に予想外の結果になることを回避するには、次のいずれかの手法を使用します。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            アルファベット順で <code class="literal">ENUM</code> リストを指定します。
          </p></li><li class="listitem"><p>
            <code class="literal">ORDER BY CAST(<em class="replaceable"><code>col</code></em> AS CHAR)</code> または <code class="literal">ORDER BY CONCAT(<em class="replaceable"><code>col</code></em>)</code> をコード化することにより、カラムがインデックス番号ではなく、辞書順でソートされることを確認します。
          </p></li></ul></div><h4><a name="enum-limits"></a>列挙の制限</h4><p>
        列挙値は、文字列値に評価されるものであっても、式にはできません。
      </p><p>
        たとえば、次の <code class="literal">CREATE TABLE</code> ステートメントは、<code class="literal">CONCAT</code> 関数を列挙値の構築に使用できないので、機能<span class="emphasis"><em>しません</em></span>。
      </p><pre class="programlisting">
CREATE TABLE sizes (
    size ENUM('small', CONCAT('med','ium'), 'large')
);
</pre><p>
        ユーザー変数を列挙値として使用することもできません。次のステートメントのペアは機能<span class="emphasis"><em>しません</em></span>。
      </p><pre class="programlisting">
SET @mysize = 'medium';

CREATE TABLE sizes (
    size ENUM('small', @mysize, 'large')
);
</pre><p>
        数字を列挙値として使用<span class="emphasis"><em>しない</em></span>ことを強くお勧めします。これは、適切な <code class="literal">TINYINT</code> または <code class="literal">SMALLINT</code> 型よりもストレージを節約するわけでもなく、<code class="literal">ENUM</code> 値を間違って引用符で囲んだ場合には、文字列とベースになる数値とを混同しやすくなる (同じでない場合もあります) からです。数字を列挙値として使用する場合は、必ず引用符で囲んでください。引用符を省略した場合は、その数字はインデックスと見なされます。<a class="xref" href="data-types.html#enum-literals" title="列挙リテラルの処理">Handling of Enumeration Literals</a>を参照して、引用符で囲まれた数字でも間違って数字のインデックス値として使用されるか場合について確認してください。
      </p><p>
        定義の中に重複した値が含まれていると、警告 (厳密な SQL モードが有効になっている場合はエラー) が発生します。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="set"></a>11.4.5 SET 型</h3></div></div></div><a class="indexterm" name="idm139979102391168"></a><a class="indexterm" name="idm139979102389696"></a><p>
        <code class="literal">SET</code> は、ゼロ以上の値を取ることができる文字列オブジェクトであり、それぞれの値は、テーブルの作成時に指定された許可される値のリストから選択する必要があります。<code class="literal">SET</code> カラム値が複数のセットメンバーで構成される場合は、各メンバーはカンマ (<span class="quote">「<span class="quote"><code class="literal">,</code></span>」</span>) で区切って指定されます。このため、<code class="literal">SET</code> メンバーの値自体にはカンマを含めないでください。
      </p><p>
        たとえば、<code class="literal">SET('one', 'two') NOT NULL</code> として指定したカラムは、次に示す値のいずれかを取ります。
      </p><pre class="programlisting">
''
'one'
'two'
'one,two'
</pre><p>
        <code class="literal">SET</code> カラムには最大 64 個の個別のメンバーを含めることができます。テーブルには、グループと見なされる <code class="literal">ENUM</code> および <code class="literal">SET</code> カラムの中の一意の要素リスト定義を、255 個以下を含めることができます。この制限の詳細は、<a class="xref" href="restrictions.html#limits-frm-file" title="D.10.5 .frm ファイル構造により課せられる制限">セクションD.10.5「.frm ファイル構造により課せられる制限」</a>を参照してください。
      </p><p>
        定義の中に重複した値が含まれていると、警告 (厳密な SQL モードが有効になっている場合はエラー) が発生します。
      </p><p>
        テーブルが作成されるときに、テーブル定義内の <code class="literal">SET</code> メンバー値から末尾のスペースが自動的に削除されます。
      </p><p>
        <code class="literal">SET</code> カラムに格納された値は、取得されるときに、カラム定義で使用されていた大文字/小文字で表示されます。<code class="literal">SET</code> カラムには、文字セットと照合順序を割り当てることができます。バイナリ照合順序、または大文字と小文字を区別する照合順序の場合、カラムに値を割り当てるときに、大文字/小文字が考慮されます。
      </p><p>
        MySQL は、最初のセットメンバーに対応する格納値の低位ビットを使用して <code class="literal">SET</code> 値を数値で格納します。<code class="literal">SET</code> 値を数値コンテキストで取得した場合、その取得された値には、カラム値を構成するセットメンバーに対応するビットセットが含まれます。たとえば、次のように <code class="literal">SET</code> カラムから数値を取得できます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT <em class="replaceable"><code>set_col</code></em>+0 FROM <em class="replaceable"><code>tbl_name</code></em>;</code></strong>
</pre><p>
        メンバーが <code class="literal">SET</code> カラムに格納されると、その数字のバイナリ表現に設定されているビットからカラム値のセットメンバーが特定されます。カラムが <code class="literal">SET('a','b','c','d')</code> として指定されている場合、セットメンバーは次の 10 進値と 2 進値を持ちます。
      </p><div class="informaltable"><table summary="この表は、SET('a','b','c','d') として指定されたカラムのメンバーの 10 進値と 2 進値を示します。" border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col"><code class="literal">SET</code> メンバー</th><th scope="col">10 進値</th><th scope="col">2 進値</th></tr></thead><tbody><tr><td scope="row"><code class="literal">'a'</code></td><td><code class="literal">1</code></td><td><code class="literal">0001</code></td></tr><tr><td scope="row"><code class="literal">'b'</code></td><td><code class="literal">2</code></td><td><code class="literal">0010</code></td></tr><tr><td scope="row"><code class="literal">'c'</code></td><td><code class="literal">4</code></td><td><code class="literal">0100</code></td></tr><tr><td scope="row"><code class="literal">'d'</code></td><td><code class="literal">8</code></td><td><code class="literal">1000</code></td></tr></tbody></table></div><p>
        このカラムに <code class="literal">9</code> の値を割り当てた場合、2 進数では <code class="literal">1001</code> となるため、<code class="literal">SET</code> 値の最初と 4 番目のメンバーである <code class="literal">'a'</code> と <code class="literal">'d'</code> が選択され、結果として得られる値は <code class="literal">'a,d'</code> になります。
      </p><p>
        1 つ以上の <code class="literal">SET</code> 要素を含む値には、値を挿入するときに要素がどの順序でリストされているかは関係ありません。また、所定の要素が値の中で何回リストされているかも関係ありません。あとから値を取得するときに、値内のそれぞれの要素は、テーブル作成時に指定された順序に従って、一度表示されます。たとえば、カラムが <code class="literal">SET('a','b','c','d')</code> と指定されているとします。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE myset (col SET('a', 'b', 'c', 'd'));</code></strong>
</pre><p>
        <code class="literal">'a,d'</code>、<code class="literal">'d,a'</code>、<code class="literal">'a,d,d'</code>、<code class="literal">'a,d,a'</code>、および <code class="literal">'d,a,d'</code> の値を挿入した場合、
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>INSERT INTO myset (col) VALUES </code></strong>
-&gt; ('a,d'), ('d,a'), ('a,d,a'), ('a,d,d'), ('d,a,d');
Query OK, 5 rows affected (0.01 sec)
Records: 5  Duplicates: 0  Warnings: 0
</pre><p>
        これらの値はすべて、取得されるときに <code class="literal">'a,d'</code> と表示されます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT col FROM myset;</code></strong>
+------+
| col  |
+------+
| a,d  |
| a,d  |
| a,d  |
| a,d  |
| a,d  |
+------+
5 rows in set (0.04 sec)
</pre><p>
        サポートされていない値に <code class="literal">SET</code> カラムを設定すると、その値は無視され警告が表示されます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>INSERT INTO myset (col) VALUES ('a,d,d,s');</code></strong>
Query OK, 1 row affected, 1 warning (0.03 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS;</code></strong>
+---------+------+------------------------------------------+
| Level   | Code | Message                                  |
+---------+------+------------------------------------------+
| Warning | 1265 | Data truncated for column 'col' at row 1 |
+---------+------+------------------------------------------+
1 row in set (0.04 sec)

mysql&gt; <strong class="userinput"><code>SELECT col FROM myset;</code></strong>
+------+
| col  |
+------+
| a,d  |
| a,d  |
| a,d  |
| a,d  |
| a,d  |
| a,d  |
+------+
6 rows in set (0.01 sec)
</pre><p>
        厳密な SQL モードが有効な場合、無効な <code class="literal">SET</code> 値を挿入しようとするとエラーが発生します。
      </p><p>
        <code class="literal">SET</code> 値は数値でソートされます。<code class="literal">NULL</code> 値は非 <code class="literal">NULL</code> <code class="literal">SET</code> 値の前にソートされます。
      </p><p>
        数値引数を取る <code class="literal">SUM()</code> や <code class="literal">AVG()</code> などの関数は、必要に応じて引数を数値にキャストします。<code class="literal">SET</code> 値の場合は、キャスト操作によって数値が使用されます。
      </p><p>
        通常は、<code class="literal">FIND_IN_SET()</code> 関数か <code class="literal">LIKE</code> 演算子を使用して <code class="literal">SET</code> 値を検索します。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE FIND_IN_SET('<em class="replaceable"><code>value</code></em>',<em class="replaceable"><code>set_col</code></em>)&gt;0;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>set_col</code></em> LIKE '%<em class="replaceable"><code>value</code></em>%';</code></strong>
</pre><p>
        最初のステートメントは <em class="replaceable"><code>set_col</code></em> が <em class="replaceable"><code>value</code></em> セットメンバーを含む行を見つけます。2 番目も似ていますが、同じではありません。ほかのセットメンバーの部分文字列としてであっても、<em class="replaceable"><code>set_col</code></em> が <em class="replaceable"><code>value</code></em> を含む行を見つけます。
      </p><p>
        次のステートメントも使用できます。
      </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>set_col</code></em> &amp; 1;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>set_col</code></em> = '<em class="replaceable"><code>val1</code></em>,<em class="replaceable"><code>val2</code></em>';</code></strong>
</pre><p>
        これらのうち最初のステートメントが最初のセットメンバーを含む値を探します。2 番目のステートメントは正確に一致する値を探します。2 番目の型は慎重に比較してください。セット値を <code class="literal">'<em class="replaceable"><code>val1</code></em>,<em class="replaceable"><code>val2</code></em>'</code> と比較すると、値を <code class="literal">'<em class="replaceable"><code>val2</code></em>,<em class="replaceable"><code>val1</code></em>'</code> と比較した場合とは異なる結果が返されます。カラム定義にリストされている順序どおりに値を指定する必要があります。
      </p><p>
        <code class="literal">SET</code> カラムの指定可能な値をすべて特定するには、<code class="literal">SHOW COLUMNS FROM <em class="replaceable"><code>tbl_name</code></em> LIKE <em class="replaceable"><code>set_col</code></em></code> を使用して、出力の <code class="literal">Type</code> カラム内の <code class="literal">SET</code> 定義を構文解析します。
      </p><p>
        C API では、<code class="literal">SET</code> 値は文字列として返されます。結果セットのメタデータを使用してこれらをほかの文字列から区別する方法については、<a class="xref" href="connectors-apis.html#c-api-data-structures" title="23.8.5 C API データ構造">セクション23.8.5「C API データ構造」</a>を参照してください。
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spatial-extensions"></a>11.5 空間データの拡張</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="data-types.html#spatial-datatypes">11.5.1 空間データ型</a></span></dt><dt><span class="section"><a href="data-types.html#opengis-geometry-model">11.5.2 OpenGIS 幾何モデル</a></span></dt><dt><span class="section"><a href="data-types.html#using-spatial-data">11.5.3 空間データの使用</a></span></dt></dl></div><a class="indexterm" name="idm139979102287152"></a><a class="indexterm" name="idm139979102285648"></a><a class="indexterm" name="idm139979102284432"></a><p>
      Open Geospatial Consortium (OGC) は、空間データを管理するあらゆる種類のアプリケーションで役立つ、公的に利用可能な概念的ソリューションの開発に携わっている 250 以上の企業、機関、および大学の国際的なコンソーシアムです。
    </p><p>
      空間データをサポートするように SQL RDBMS を拡張するための複数の概念的な方法を提案したドキュメントとして、Open Geospatial Consortium から「<em class="citetitle">OpenGIS® Implementation Standard for Geographic information - Simple feature access - Part 2: SQL option</em>」が発行されています。この仕様書は、OGC Web サイト (<a class="ulink" href="http://www.opengeospatial.org/standards/sfs" target="_top">http://www.opengeospatial.org/standards/sfs</a>) から入手できます。
    </p><p>
      MySQL は、OGC の仕様書に従って、<span class="bold"><strong>幾何型を含む SQL</strong></span> 環境のサブセットとして空間拡張を実装しています。この用語は、一連の幾何型で拡張された SQL 環境を意味しています。幾何値を含む SQL カラムは、幾何型のカラムとして実装されています。仕様書では、一連の SQL 幾何型のほか、幾何値を作成し分析するためにこれらの型に対して行われる関数について説明しています。
    </p><p>
      MySQL 空間拡張により、地理的特性の生成、ストレージ、および分析が可能になります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          空間値を表すデータ型
        </p></li><li class="listitem"><p>
          空間値を操作する関数
        </p></li><li class="listitem"><p>
          空間カラムへのアクセス時間を改善するための空間インデックス設定
        </p></li></ul></div><p>
      データ型と関数は、<code class="literal">MyISAM</code>、<code class="literal">InnoDB</code>、<code class="literal">NDB</code>、および <code class="literal">ARCHIVE</code> テーブルで使用できます。空間カラムのインデックス設定については、<code class="literal">MyISAM</code> は、<code class="literal">SPATIAL</code> インデックスと非 <code class="literal">SPATIAL</code> インデックスの両方をサポートします。その他のストレージエンジンは、<a class="xref" href="sql-syntax.html#create-index" title="13.1.13 CREATE INDEX 構文">セクション13.1.13「CREATE INDEX 構文」</a>で説明しているように、非 <code class="literal">SPATIAL</code> インデックスをサポートします。
    </p><a class="indexterm" name="idm139979102265184"></a><p>
      <span class="bold"><strong>地理的特性</strong></span>とは、位置を特定できる世界中のあらゆるもののことです。特性は次のいずれかになります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          実体。山、池、都市など。
        </p></li><li class="listitem"><p>
          領域。町の区域や熱帯地域など。
        </p></li><li class="listitem"><p>
          定義可能な位置。2 つの道路が交差する特定の場所となる交差点など。
        </p></li></ul></div><a class="indexterm" name="idm139979102259408"></a><p>
      ドキュメントによっては、<span class="bold"><strong>地理空間特性</strong></span>という用語を地理的特性の意味で使用している場合もあります。
    </p><a class="indexterm" name="idm139979102256768"></a><p>
      <span class="bold"><strong>幾何図形</strong></span>も地理的特性を表す用語です。<span class="bold"><strong>幾何図形</strong></span>という用語はもともと、地球の測量を意味していました。地図作成者が世界のマッピングに使用する幾何特性を指す別の意味は、地図作成の分野からのものです。
    </p><p>
      ここでの説明では、<span class="bold"><strong>地理的特性</strong></span>、<span class="bold"><strong>地理空間特性</strong></span>、<span class="bold"><strong>特性</strong></span>、<span class="bold"><strong>幾何図形</strong></span>の用語をシノニムと見なします。もっともよく使用される用語は<span class="bold"><strong>幾何図形</strong></span>であり、<span class="emphasis"><em>位置を特定できる世界中のあらゆるものを表す地点または地点の集約</em></span>として定義されています。
    </p><p>
      次の資料では次のトピックを取り上げます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          MySQL モデルに実装された空間データ型
        </p></li><li class="listitem"><p>
          OpenGIS 幾何モデルでの空間拡張の基本
        </p></li><li class="listitem"><p>
          空間データを表現するためのデータ形式
        </p></li><li class="listitem"><p>
          MySQL で空間データを使用する方法
        </p></li><li class="listitem"><p>
          空間データのインデックスの使用方法
        </p></li><li class="listitem"><p>
          OpenGIS 仕様と MySQL 実装との差異
        </p></li></ul></div><p>
      空間データを演算する関数の詳細は、<a class="xref" href="functions.html#spatial-analysis-functions" title="12.15 空間分析関数">セクション12.15「空間分析関数」</a>を参照してください。
    </p><h3><a name="idm139979102240688"></a>MySQL の GIS に対する適合性と互換性</h3><p>
      MySQL は次の GIS 機能を実装していません。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          追加のメタデータビュー
        </p><p>
          OpenGIS の仕様書では追加メタデータビューがいくつか提案されています。たとえば、<code class="literal">GEOMETRY_COLUMNS</code> という名前のシステムビューには、データベース内の幾何カラムごとに 1 行ずつ、幾何カラムの記述が含まれます。
        </p></li><li class="listitem"><p>
          <code class="literal">LineString</code> および <code class="literal">MultiLineString</code> での OpenGIS 関数 <code class="literal">Length()</code> は、MySQL で <code class="literal">GLength()</code> として呼び出す必要があります。
        </p><p>
          これは、文字列値の長さを計算する既存の SQL 関数 <code class="literal">Length()</code> が存在していますが、この関数がテキスト、空間のどちらのコンテキストで呼び出されたのかを判定できない場合があるからです。
        </p></li></ul></div><h3><a name="idm139979102230128"></a>追加のリソース</h3><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          空間データをサポートするように SQL RDBMS を拡張するための複数の概念的な方法を提案したドキュメントとして、Open Geospatial Consortium から「<em class="citetitle">OpenGIS® Implementation Standard for Geographic information - Simple feature access - Part 2: SQL option</em>」が発行されています。Open Geospatial Consortium (OGC) は、<a class="ulink" href="http://www.opengeospatial.org/" target="_top">http://www.opengeospatial.org/</a> で Web サイトを管理しています。仕様書は <a class="ulink" href="http://www.opengeospatial.org/standards/sfs" target="_top">http://www.opengeospatial.org/standards/sfs</a> で入手できます。ここでの資料に関連した追加情報が用意されています。
        </p></li><li class="listitem"><p>
          MySQL に対する空間拡張の使用について質問や関心がある場合は、GIS フォーラム (<a class="ulink" href="http://forums.mysql.com/list.php?23" target="_top">http://forums.mysql.com/list.php?23</a>) で議論できます。
        </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="spatial-datatypes"></a>11.5.1 空間データ型</h3></div></div></div><a class="indexterm" name="idm139979102223072"></a><a class="indexterm" name="idm139979102221584"></a><a class="indexterm" name="idm139979102220224"></a><a class="indexterm" name="idm139979102218832"></a><a class="indexterm" name="idm139979102217456"></a><a class="indexterm" name="idm139979102216064"></a><a class="indexterm" name="idm139979102214656"></a><a class="indexterm" name="idm139979102213264"></a><a class="indexterm" name="idm139979102211856"></a><a class="indexterm" name="idm139979102209936"></a><a class="indexterm" name="idm139979102207904"></a><a class="indexterm" name="idm139979102205872"></a><a class="indexterm" name="idm139979102203840"></a><a class="indexterm" name="idm139979102201808"></a><a class="indexterm" name="idm139979102199776"></a><a class="indexterm" name="idm139979102197744"></a><p>
        MySQL には OpenGIS クラスに対応するデータ型が用意されています。これらのデータ型の中には、次のように単一の幾何値を格納するものがあります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">GEOMETRY</code>
          </p></li><li class="listitem"><p>
            <code class="literal">POINT</code>
          </p></li><li class="listitem"><p>
            <code class="literal">LINESTRING</code>
          </p></li><li class="listitem"><p>
            <code class="literal">POLYGON</code>
          </p></li></ul></div><p>
        <code class="literal">GEOMETRY</code> にはどの型の幾何値でも格納できます。その他の単一値型 (<code class="literal">POINT</code>、<code class="literal">LINESTRING</code>、および <code class="literal">POLYGON</code>) では、特定の幾何型に値が制限されます。
      </p><p>
        次に示すその他のデータ型には、値のコレクションが格納されます。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <code class="literal">MULTIPOINT</code>
          </p></li><li class="listitem"><p>
            <code class="literal">MULTILINESTRING</code>
          </p></li><li class="listitem"><p>
            <code class="literal">MULTIPOLYGON</code>
          </p></li><li class="listitem"><p>
            <code class="literal">GEOMETRYCOLLECTION</code>
          </p></li></ul></div><p>
        <code class="literal">GEOMETRYCOLLECTION</code> には、任意の型のオブジェクトのコレクションを格納できます。その他のコレクション型 (<code class="literal">MULTIPOINT</code>、<code class="literal">MULTILINESTRING</code>、<code class="literal">MULTIPOLYGON</code>、および <code class="literal">GEOMETRYCOLLECTION</code>) では、コレクションのメンバーは、特定の幾何型を持つメンバーに制限されます。
      </p><p>
        MySQL 空間データは、<a class="xref" href="data-types.html#opengis-geometry-model" title="11.5.2 OpenGIS 幾何モデル">セクション11.5.2「OpenGIS 幾何モデル」</a>で説明しているように、OpenGIS 幾何モデルに基づいています。MySQL で空間データ型を使用する方法を示した例については、<a class="xref" href="data-types.html#using-spatial-data" title="11.5.3 空間データの使用">セクション11.5.3「空間データの使用」</a>を参照してください。
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="opengis-geometry-model"></a>11.5.2 OpenGIS 幾何モデル</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="data-types.html#gis-geometry-class-hierarchy">11.5.2.1 幾何クラスの階層</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-geometry">11.5.2.2 Geometry クラス</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-point">11.5.2.3 Point クラス</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-curve">11.5.2.4 Curve クラス</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-linestring">11.5.2.5 LineString クラス</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-surface">11.5.2.6 Surface クラス</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-polygon">11.5.2.7 Polygon クラス</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-geometrycollection">11.5.2.8 GeometryCollection クラス</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-multipoint">11.5.2.9 MultiPoint クラス</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-multicurve">11.5.2.10 MultiCurve クラス</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-multilinestring">11.5.2.11 MultiLineString クラス</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-multisurface">11.5.2.12 MultiSurface クラス</a></span></dt><dt><span class="section"><a href="data-types.html#gis-class-multipolygon">11.5.2.13 MultiPolygon クラス</a></span></dt></dl></div><p>
        OGC の<span class="bold"><strong>幾何型を含む SQL</strong></span> 環境で提案されている一連の幾何型は、<span class="bold"><strong>OpenGIS 幾何モデル</strong></span>に基づいています。このモデルの各幾何オブジェクトには、次のような一般的なプロパティーがあります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            オブジェクトが定義されている座標空間を記述する空間参照システムに関連付けられています。
          </p></li><li class="listitem"><p>
            特定の幾何クラスに属しています。
          </p></li></ul></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="gis-geometry-class-hierarchy"></a>11.5.2.1 幾何クラスの階層</h4></div></div></div><p>
          幾何クラスの階層は次のように定義されています。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">Geometry</code> (インスタンス化不可能)
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  <code class="literal">Point</code> (インスタンス化可能)
                </p></li><li class="listitem"><p>
                  <code class="literal">Curve</code> (インスタンス化不可能)
                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                      <code class="literal">LineString</code> (インスタンス化可能)
                    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                          <code class="literal">Line</code>
                        </p></li><li class="listitem"><p>
                          <code class="literal">LinearRing</code>
                        </p></li></ul></div></li></ul></div></li><li class="listitem"><p>
                  <code class="literal">Surface</code> (インスタンス化不可能)
                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                      <code class="literal">Polygon</code> (インスタンス化可能)
                    </p></li></ul></div></li><li class="listitem"><p>
                  <code class="literal">GeometryCollection</code> (インスタンス化可能)
                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                      <code class="literal">MultiPoint</code> (インスタンス化可能)
                    </p></li><li class="listitem"><p>
                      <code class="literal">MultiCurve</code> (インスタンス化不可能)
                    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                          <code class="literal">MultiLineString</code> (インスタンス化可能)
                        </p></li></ul></div></li><li class="listitem"><p>
                      <code class="literal">MultiSurface</code> (インスタンス化不可能)
                    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                          <code class="literal">MultiPolygon</code> (インスタンス化可能)
                        </p></li></ul></div></li></ul></div></li></ul></div></li></ul></div><p>
          インスタンス化不可能なクラスのオブジェクトは作成できません。インスタンス化可能なクラスのオブジェクトは作成できます。どのクラスもプロパティーを持ちますが、インスタンス化可能なクラスはさらに表明 (有効なクラスインスタンスを定義するルール) も持つことができます。
        </p><p>
          <code class="literal">Geometry</code> は基本クラスです。これは抽象クラスです。<code class="literal">Geometry</code> のインスタンス化可能なサブクラスは、2 次元座標空間内に存在する 0 次元、1 次元、および 2 次元の幾何オブジェクトに限定されます。インスタンス化可能な幾何クラスはすべて、幾何クラスの有効なインスタンスが位相的に閉じている (つまり、定義されたすべての幾何図形に境界が含まれる) ように定義されています。
        </p><p>
          <code class="literal">Geometry</code> 基本クラスには、<code class="literal">Point</code>、<code class="literal">Curve</code>、<code class="literal">Surface</code>、および <code class="literal">GeometryCollection</code> のサブクラスがあります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">Point</code> は 0 次元のオブジェクトを表します。
            </p></li><li class="listitem"><p>
              <code class="literal">Curve</code> は 1 次元のオブジェクトを表し、そのサブクラス <code class="literal">LineString</code> は、<code class="literal">Line</code> と <code class="literal">LinearRing</code> をサブクラスに持ちます。
            </p></li><li class="listitem"><p>
              <code class="literal">Surface</code> は 2 次元のオブジェクト用に設計されたもので、<code class="literal">Polygon</code> をサブクラスに持ちます。
            </p></li><li class="listitem"><p>
              <code class="literal">GeometryCollection</code> には <code class="literal">MultiPoint</code>、<code class="literal">MultiLineString</code>、<code class="literal">MultiPolygon</code> という 0、1、2 次元の特殊化コレクションクラスが用意されており、それぞれ <code class="literal">Points</code>、<code class="literal">LineStrings</code>、<code class="literal">Polygons</code> のコレクションに対応する幾何図形をモデル化しています。<code class="literal">MultiCurve</code> と <code class="literal">MultiSurface</code> は、このコレクションインタフェースを汎化して <code class="literal">Curves</code> および <code class="literal">Surfaces</code> を処理できるよう抽象スーパークラスとして導入されたものです。
            </p></li></ul></div><p>
          <code class="literal">Geometry</code>、<code class="literal">Curve</code>、<code class="literal">Surface</code>、<code class="literal">MultiCurve</code>、および <code class="literal">MultiSurface</code> は、インスタンス化不可能なクラスとして定義されています。これらはサブクラスに共通する一連のメソッドを定義しており、今後の拡張に含められます。
        </p><p>
          <code class="literal">Point</code>、<code class="literal">LineString</code>、<code class="literal">Polygon</code>、<code class="literal">GeometryCollection</code>、<code class="literal">MultiPoint</code>、<code class="literal">MultiLineString</code>、および <code class="literal">MultiPolygon</code> はインスタンス化可能なクラスです。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="gis-class-geometry"></a>11.5.2.2 Geometry クラス</h4></div></div></div><p>
          <code class="literal">Geometry</code> は階層のルートクラスです。これはインスタンス化不可能なクラスですが、次のリストに説明しているように、<code class="literal">Geometry</code> サブクラスのいずれかから作成したすべての幾何値に共通である多数のプロパティーがあります。個々のサブクラスも独自のプロパティーを備えていますが、これについては後述します。
        </p><p>
          <span class="bold"><strong>Geometry のプロパティー</strong></span>
        </p><p>
          幾何値に含まれるプロパティーは次のとおりです。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              その<span class="bold"><strong>型</strong></span>。各幾何図形は、階層内のインスタンス化可能クラスのいずれかに属します。
            </p></li><li class="listitem"><p>
              その <span class="bold"><strong>SRID</strong></span>、つまり空間参照識別子。この値は、幾何図形に関連付けられた、その幾何オブジェクトが定義されている座標空間を記述する空間参照システムを識別します。
            </p><p>
              MySQL の SRID 値は、幾何値に関連付けられた整数です。すべての計算はユークリッド (平面) 幾何学を前提にして実行されます。使用可能な SRID の最大値は 2<sup>32</sup>−1 です。より大きな値が指定されると、低位の 32 ビットだけが使用されます。
            </p></li><li class="listitem"><p>
              空間参照システムでの<span class="bold"><strong>座標</strong></span>は、倍精度 (8 バイト) 数として表現されます。空でない幾何図形には必ず、(X,Y) 座標ペアが少なくとも 1 つ含まれます。空の幾何図形には座標は含まれません。
            </p><p>
              座標は SRID に対する相対的なものです。たとえば、異なる座標系では、オブジェクトの座標が同じ場合でも、2 つのオブジェクト間の距離が異なることがあります。これは、<span class="bold"><strong>平面</strong></span>座標系での距離と<span class="bold"><strong>地球を中心とした</strong></span>系 (地球表面の座標) の距離は異なるためです。
            </p></li><li class="listitem"><p>
              <span class="bold"><strong>内部</strong></span>、<span class="bold"><strong>境界</strong></span>、<span class="bold"><strong>外部</strong></span>。
            </p><p>
              幾何図形は必ず、ある位置の領域を占有します。幾何図形の外部とは、その幾何図形によって占有されていないすべての領域のことです。内部とは、その幾何図形によって占有されている領域のことです。境界とは、幾何図形の内部と外部が接する部分のことです。
            </p></li><li class="listitem"><p>
              その <span class="bold"><strong>MBR</strong></span> (最小外接矩形)、または包絡線。これは範囲を規定する幾何図形であり、次のように最小および最大の (X,Y) 座標から形成されます。
            </p><pre class="programlisting">
((MINX MINY, MAXX MINY, MAXX MAXY, MINX MAXY, MINX MINY))
</pre></li><li class="listitem"><p>
              値が<span class="bold"><strong>単純である</strong></span>、<span class="bold"><strong>単純でない</strong></span>のいずれであるか。<code class="literal">LineString</code>、<code class="literal">MultiPoint</code>、<code class="literal">MultiLineString</code> の型の幾何値は「単純である」、「単純でない」のいずれかになります。「単純である」、「単純でない」のいずれであるかの表明は、型ごとに決定されます。
            </p></li><li class="listitem"><p>
              値が<span class="bold"><strong>閉じている</strong></span>、<span class="bold"><strong>閉じていない</strong></span>のいずれであるか。<code class="literal">LineString</code>、<code class="literal">MultiString</code> の型の幾何値は「閉じている」「閉じていない」のいずれかになります。「閉じている」、「閉じていない」のいずれであるかの表明は、型ごとに決定されます。
            </p></li><li class="listitem"><p>
              値が<span class="bold"><strong>空である</strong></span>、<span class="bold"><strong>空でない</strong></span>のいずれであるか。点を 1 つも含まない幾何図形は空です。空の幾何図形の外部、内部、および境界は定義されていません (つまり、それらは <code class="literal">NULL</code> 値で表されます)。空の幾何図形は、常に単純で面積が 0 になるように定義されています。
            </p></li><li class="listitem"><p>
              その<span class="bold"><strong>次元</strong></span>。幾何図形には −1、0、1、または 2 の次元があります。
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                  −1 は、空の幾何図形を表します。
                </p></li><li class="listitem"><p>
                  0 は長さも面積も持たない幾何図形を表します。
                </p></li><li class="listitem"><p>
                  1 は、長さがゼロ以外で面積がゼロの幾何図形を表します。
                </p></li><li class="listitem"><p>
                  2 は、面積がゼロ以外の幾何図形を表します。
                </p></li></ul></div><p>
              <code class="literal">Point</code> オブジェクトの次元は 0 です。<code class="literal">LineString</code> オブジェクトの次元は 1 です。<code class="literal">Polygon</code> オブジェクトの次元は 2 です。<code class="literal">MultiPoint</code>、<code class="literal">MultiLineString</code>、および <code class="literal">MultiPolygon</code> オブジェクトの次元は、構成要素の次元と同じになります。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="gis-class-point"></a>11.5.2.3 Point クラス</h4></div></div></div><p>
          <code class="literal">Point</code> は、座標空間内の単一の位置を表す幾何図形です。
        </p><p>
          <span class="bold"><strong><code class="literal">Point</code> の例</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              多数の都市を含む大規模な世界地図を想像してください。<code class="literal">Point</code> オブジェクトは各都市を表すことができます。
            </p></li><li class="listitem"><p>
              市内地図で、<code class="literal">Point</code> オブジェクトはバス停を表すことができます。
            </p></li></ul></div><p>
          <span class="bold"><strong><code class="literal">Point</code> のプロパティー</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              X 座標値。
            </p></li><li class="listitem"><p>
              Y 座標値。
            </p></li><li class="listitem"><p>
              <code class="literal">Point</code> は 0 次元の幾何図形として定義されています。
            </p></li><li class="listitem"><p>
              <code class="literal">Point</code> の境界は空セットになります。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="gis-class-curve"></a>11.5.2.4 Curve クラス</h4></div></div></div><p>
          <code class="literal">Curve</code> は 1 次元の幾何図形であり、通常は一連の点で表されます。点の間の補間方法は、<code class="literal">Curve</code> の特定のサブクラスで定義されています。<code class="literal">Curve</code> はインスタンス化不可能なクラスです。
        </p><p>
          <span class="bold"><strong><code class="literal">Curve</code> のプロパティー</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">Curve</code> はその点の座標を持ちます。
            </p></li><li class="listitem"><p>
              <code class="literal">Curve</code> は 1 次元の幾何図形として定義されています。
            </p></li><li class="listitem"><p>
              同じ点を 2 度通過しなければ、<code class="literal">Curve</code> は単純です。
            </p></li><li class="listitem"><p>
              始点と終点が等しい場合、<code class="literal">Curve</code> は閉じています。
            </p></li><li class="listitem"><p>
              閉じた <code class="literal">Curve</code> の境界は、空になります。
            </p></li><li class="listitem"><p>
              閉じていない <code class="literal">Curve</code> の境界は、その 2 つの端点から構成されます。
            </p></li><li class="listitem"><p>
              単純で閉じた <code class="literal">Curve</code> としては、<code class="literal">LinearRing</code> が挙げられます。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="gis-class-linestring"></a>11.5.2.5 LineString クラス</h4></div></div></div><p>
          <code class="literal">LineString</code> は、点の間を直線で補間した <code class="literal">Curve</code> です。
        </p><p>
          <span class="bold"><strong><code class="literal">LineString</code> の例</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              世界地図で、<code class="literal">LineString</code> オブジェクトは河川を表すことができます。
            </p></li><li class="listitem"><p>
              市内地図で、<code class="literal">LineString</code> オブジェクトは通りを表すことができます。
            </p></li></ul></div><p>
          <span class="bold"><strong><code class="literal">LineString</code> のプロパティー</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">LineString</code> は、隣り合う 1 対の点で定義される各線分の座標を持ちます。
            </p></li><li class="listitem"><p>
              ちょうど 2 つの点から構成されている場合、<code class="literal">LineString</code> は <code class="literal">Line</code> になります。
            </p></li><li class="listitem"><p>
              閉じていて、かつ単純である場合は、<code class="literal">LineString</code> は <code class="literal">LinearRing</code> になります。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="gis-class-surface"></a>11.5.2.6 Surface クラス</h4></div></div></div><p>
          <code class="literal">Surface</code> は 2 次元の幾何図形です。これはインスタンス化不可能なクラスです。その唯一のインスタンス化可能なサブクラスは、<code class="literal">Polygon</code> です。
        </p><p>
          <span class="bold"><strong><code class="literal">Surface</code> のプロパティー</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">Surface</code> は 2 次元の幾何図形として定義されています。
            </p></li><li class="listitem"><p>
              OpenGIS 仕様では、単純な <code class="literal">Surface</code> が、1 個の外側の境界と 0 個以上の内側の境界に関連付けられた単一の<span class="quote">「<span class="quote">パッチ</span>」</span>からなる幾何図形として定義されています。
            </p></li><li class="listitem"><p>
              単純な <code class="literal">Surface</code> の境界は、その外側と内側の境界に対応する一連の閉じた曲線になります。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="gis-class-polygon"></a>11.5.2.7 Polygon クラス</h4></div></div></div><p>
          <code class="literal">Polygon</code> は、多辺の幾何図形を表す平面 <code class="literal">Surface</code> です。これは 1 個の外側の境界と 0 個以上の内側の境界で定義されますが、それらの内側の各境界によって <code class="literal">Polygon</code> 内の 1 個の穴が定義されます。
        </p><p>
          <span class="bold"><strong><code class="literal">Polygon</code> の例</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              地域マップで、<code class="literal">Polygon</code> オブジェクトは森林や区域などを表すことができます。
            </p></li></ul></div><p>
          <span class="bold"><strong><code class="literal">Polygon</code> の表明</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">Polygon</code> の境界は、外側と内側の境界を構成する一連の <code class="literal">LinearRing</code> オブジェクト (つまり、単純かつ閉じた <code class="literal">LineString</code> オブジェクト) から構成されます。
            </p></li><li class="listitem"><p>
              <code class="literal">Polygon</code> のリングは交差しません。<code class="literal">Polygon</code> の境界に含まれるリングは、<code class="literal">Point</code> で交わりますが、接することしかできません。
            </p></li><li class="listitem"><p>
              <code class="literal">Polygon</code> には線分、突起、亀裂は含まれません。
            </p></li><li class="listitem"><p>
              <code class="literal">Polygon</code> は、連続した点集合からなる内部を持ちます。
            </p></li><li class="listitem"><p>
              <code class="literal">Polygon</code> は穴を持つことができます。穴のある <code class="literal">Polygon</code> の外部は、連続していません。それぞれの穴が、連続した 1 つの外部コンポーネントを定義します。
            </p></li></ul></div><p>
          以上の表明により、<code class="literal">Polygon</code> は単純な幾何図形になります。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="gis-class-geometrycollection"></a>11.5.2.8 GeometryCollection クラス</h4></div></div></div><p>
          <code class="literal">GeometryCollection</code> は、任意のクラスに属する 1 つ以上の幾何図形のコレクションとなる幾何図形です。
        </p><p>
          <code class="literal">GeometryCollection</code> の各要素の空間参照システム (つまり座標系) はすべて同じである必要があります。<code class="literal">GeometryCollection</code> の要素に関する制約はこれだけですが、後続の各セクションで説明する <code class="literal">GeometryCollection</code> のサブクラスでは、メンバーシップに関する制限が課される可能性があります。これらの制限は次の情報に基づくことがあります。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              要素の型 (たとえば、<code class="literal">MultiPoint</code> に格納できるのは <code class="literal">Point</code> 要素だけです)
            </p></li><li class="listitem"><p>
              次元
            </p></li><li class="listitem"><p>
              要素間の空間的な重なり具合に関する制約
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="gis-class-multipoint"></a>11.5.2.9 MultiPoint クラス</h4></div></div></div><p>
          <code class="literal">MultiPoint</code> は、<code class="literal">Point</code> 要素から構成される幾何図形コレクションです。点の接続や順序付けは一切行われません。
        </p><p>
          <span class="bold"><strong><code class="literal">MultiPoint</code> の例</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              世界地図で、<code class="literal">MultiPoint</code> は一連の小さな島々を表すことができます。
            </p></li><li class="listitem"><p>
              市内地図で、<code class="literal">MultiPoint</code> はチケットオフィスの系列店を表すことができます。
            </p></li></ul></div><p>
          <span class="bold"><strong><code class="literal">MultiPoint</code> のプロパティー</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">MultiPoint</code> は 0 次元の幾何図形です。
            </p></li><li class="listitem"><p>
              この 2 つの <code class="literal">Point</code> の値 (座標値) が等しくない場合は、<code class="literal">MultiPoint</code> は単純になります。
            </p></li><li class="listitem"><p>
              <code class="literal">MultiPoint</code> の境界は空セットになります。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="gis-class-multicurve"></a>11.5.2.10 MultiCurve クラス</h4></div></div></div><p>
          <code class="literal">MultiCurve</code> は、<code class="literal">Curve</code> 要素から構成される幾何図形コレクションです。<code class="literal">MultiCurve</code> はインスタンス化不可能なクラスです。
        </p><p>
          <span class="bold"><strong><code class="literal">MultiCurve</code> のプロパティー</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">MultiCurve</code> は 1 次元の幾何図形です。
            </p></li><li class="listitem"><p>
              <code class="literal">MultiCurve</code> が単純になるのは、そのすべての要素が単純である場合だけです。2 つの要素の唯一の交点は、両方の要素の境界上にある点になります。
            </p></li><li class="listitem"><p>
              <code class="literal">MultiCurve</code> の境界を取得するには、<span class="quote">「<span class="quote">mod 2 union ルール</span>」</span> (<span class="quote">「<span class="quote">odd-even ルール</span>」</span>とも呼ばれます) を適用します。ある点が <code class="literal">MultiCurve</code> の境界に含まれるのは、その点が、奇数個の <code class="literal">MultiCurve</code> 要素の境界に含まれている場合です。
            </p></li><li class="listitem"><p>
              すべての要素が閉じている場合、<code class="literal">MultiCurve</code> は閉じています。
            </p></li><li class="listitem"><p>
              閉じた <code class="literal">MultiCurve</code> の境界は、常に空になります。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="gis-class-multilinestring"></a>11.5.2.11 MultiLineString クラス</h4></div></div></div><p>
          <code class="literal">MultiLineString</code> は、<code class="literal">LineString</code> 要素から構成される <code class="literal">MultiCurve</code> 幾何図形コレクションです。
        </p><p>
          <span class="bold"><strong><code class="literal">MultiLineString</code> の例</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              地域マップで、<code class="literal">MultiLineString</code> は河川系や高速道路システムを表すことができます。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="gis-class-multisurface"></a>11.5.2.12 MultiSurface クラス</h4></div></div></div><p>
          <code class="literal">MultiSurface</code> は、面要素から構成される幾何図形コレクションです。<code class="literal">MultiSurface</code> はインスタンス化不可能なクラスです。その唯一のインスタンス化可能なサブクラスは、<code class="literal">MultiPolygon</code> です。
        </p><p>
          <span class="bold"><strong><code class="literal">MultiSurface</code> の表明</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">MultiSurface</code> の 2 つの面の内部が交差することはありません。
            </p></li><li class="listitem"><p>
              <code class="literal">MultiSurface</code> の 2 つの要素の境界が無限個の点で交わることはありません。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="gis-class-multipolygon"></a>11.5.2.13 MultiPolygon クラス</h4></div></div></div><p>
          <code class="literal">MultiPolygon</code> は、<code class="literal">Polygon</code> 要素から構成される <code class="literal">MultiSurface</code> オブジェクトです。
        </p><p>
          <span class="bold"><strong><code class="literal">MultiPolygon</code> の例</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              地域マップで、<code class="literal">MultiPolygon</code> は湖の系列を表すことができます。
            </p></li></ul></div><p>
          <span class="bold"><strong><code class="literal">MultiPolygon</code> の表明</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">MultiPolygon</code> のどの 2 つの <code class="literal">Polygon</code> 要素も、交差する内部を持つことはありません。
            </p></li><li class="listitem"><p>
              <code class="literal">MultiPolygon</code> のどの 2 つの <code class="literal">Polygon</code> 要素も、交差したり (交差は 1 つ前の表明でも禁止されています)、無限個の点で接したりしません。
            </p></li><li class="listitem"><p>
              <code class="literal">MultiPolygon</code> にカットライン、突起、亀裂を含めることはできません。<code class="literal">MultiPolygon</code> は通常の閉じた点集合です。
            </p></li><li class="listitem"><p>
              複数の <code class="literal">Polygon</code> を含む <code class="literal">MultiPolygon</code> は、連続していない内部を持ちます。<code class="literal">MultiPolygon</code> の連続する内部コンポーネントの個数は、<code class="literal">MultiPolygon</code> 内の <code class="literal">Polygon</code> 値の数と等しくなります。
            </p></li></ul></div><p>
          <span class="bold"><strong><code class="literal">MultiPolygon</code> のプロパティー</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">MultiPolygon</code> は 2 次元の幾何図形です。
            </p></li><li class="listitem"><p>
              <code class="literal">MultiPolygon</code> の境界は、その <code class="literal">Polygon</code> 要素の境界に対応する一連の閉じた曲線 (<code class="literal">LineString</code> 値) になります。
            </p></li><li class="listitem"><p>
              <code class="literal">MultiPolygon</code> の境界に含まれる各 <code class="literal">Curve</code> は、どれか 1 つの <code class="literal">Polygon</code> 要素の境界にのみ含まれます。
            </p></li><li class="listitem"><p>
              <code class="literal">Polygon</code> 要素の境界に含まれる <code class="literal">Curve</code> は必ず、<code class="literal">MultiPolygon</code> の境界にも含まれます。
            </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="using-spatial-data"></a>11.5.3 空間データの使用</h3></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="data-types.html#gis-data-formats">11.5.3.1 サポートされる空間データ形式</a></span></dt><dt><span class="section"><a href="data-types.html#creating-spatial-columns">11.5.3.2 空間カラムの作成</a></span></dt><dt><span class="section"><a href="data-types.html#populating-spatial-columns">11.5.3.3 空間カラムへのデータ移入</a></span></dt><dt><span class="section"><a href="data-types.html#fetching-spatial-data">11.5.3.4 空間データのフェッチ</a></span></dt><dt><span class="section"><a href="data-types.html#optimizing-spatial-analysis">11.5.3.5 空間分析の最適化</a></span></dt><dt><span class="section"><a href="data-types.html#creating-spatial-indexes">11.5.3.6 空間インデックスの作成</a></span></dt><dt><span class="section"><a href="data-types.html#using-spatial-indexes">11.5.3.7 空間インデックスの使用</a></span></dt></dl></div><p>
        このセクションでは、空間データ型カラムを含むテーブルの作成方法と、空間情報の操作方法について説明します。
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="gis-data-formats"></a>11.5.3.1 サポートされる空間データ形式</h4></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="data-types.html#gis-wkt-format">11.5.3.1.1 WKT (Well-Known Text) 形式</a></span></dt><dt><span class="section"><a href="data-types.html#gis-wkb-format">11.5.3.1.2 WKB (Well-Known Binary) 形式</a></span></dt></dl></div><p>
          クエリーで幾何オブジェクトを表現するために、次の 2 つの標準空間データ形式が使用されます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              WKT (Well-Known Text) 形式
            </p></li><li class="listitem"><p>
              WKB (Well-Known Binary) 形式
            </p></li></ul></div><p>
          MySQL の内部では、WKT、WKB のどちらの形式とも異なる形式で幾何値が格納されます。
        </p><p>
          異なるデータ形式間の変換に使用できる関数があります。<a class="xref" href="functions.html#gis-format-conversion-functions" title="12.15.6 幾何形式変換関数">セクション12.15.6「幾何形式変換関数」</a>を参照してください。
        </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="gis-wkt-format"></a>11.5.3.1.1 WKT (Well-Known Text) 形式</h5></div></div></div><a class="indexterm" name="idm139979101859920"></a><a class="indexterm" name="idm139979101858496"></a><p>
            幾何値の WKT (Well-Known Text) 表現は、ASCII 形式の幾何データを交換するために設計されています。OpenGIS 仕様書には、WKT 値を書き込むための公式の運用ルールを指定するバッカス-ナウア記法が用意されています (<a class="xref" href="data-types.html#spatial-extensions" title="11.5 空間データの拡張">セクション11.5「空間データの拡張」</a>を参照してください)。
          </p><p>
            幾何オブジェクトの WKT 表現の例: 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                <code class="literal">Point</code>:
              </p><pre class="programlisting">
POINT(15 20)
</pre><p>
                点の座標は、区切り用のカンマなしに指定されます。これは、座標間にカンマを必要とする SQL <code class="literal">Point()</code> 関数の構文とは異なります。特定の空間演算のコンテキストに適した構文を慎重に使用してください。たとえば、次のステートメントはどちらも、<code class="literal">Point</code> オブジェクトから X 座標を抽出します。最初の場合は、<code class="literal">Point()</code> 関数を直接使用してオブジェクトを生成します。2 番目の場合は、<code class="literal">GeomFromText()</code> で <code class="literal">Point</code> に変換された WKT 表現を使用します。
              </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT X(POINT(15, 20));</code></strong>
+------------------+
| X(POINT(15, 20)) |
+------------------+
|               15 |
+------------------+

mysql&gt; <strong class="userinput"><code>SELECT X(GeomFromText('POINT(15 20)'));</code></strong>
+---------------------------------+
| X(GeomFromText('POINT(15 20)')) |
+---------------------------------+
|                              15 |
+---------------------------------+
</pre></li><li class="listitem"><p>
                4 つの点を含む <code class="literal">LineString</code>:
              </p><pre class="programlisting">
LINESTRING(0 0, 10 10, 20 25, 50 60)
</pre><p>
                点の座標のペアはカンマで区切られます。
              </p></li><li class="listitem"><p>
                外側のリングと内側のリングを 1 つずつ含む <code class="literal">Polygon</code>:
              </p><pre class="programlisting">
POLYGON((0 0,10 0,10 10,0 10,0 0),(5 5,7 5,7 7,5 7, 5 5))
</pre></li><li class="listitem"><p>
                3 つの <code class="literal">Point</code> 値を含む <code class="literal">MultiPoint</code>:
              </p><pre class="programlisting">
MULTIPOINT(0 0, 20 20, 60 60)
</pre></li><li class="listitem"><p>
                2 つの <code class="literal">LineString</code> 値を含む <code class="literal">MultiLineString</code>:
              </p><pre class="programlisting">
MULTILINESTRING((10 10, 20 20), (15 15, 30 15))
</pre></li><li class="listitem"><p>
                2 つの <code class="literal">Polygon</code> 値を含む <code class="literal">MultiPolygon</code>:
              </p><pre class="programlisting">
MULTIPOLYGON(((0 0,10 0,10 10,0 10,0 0)),((5 5,7 5,7 7,5 7, 5 5)))
</pre></li><li class="listitem"><p>
                2 つの <code class="literal">Point</code> 値と 1 つの <code class="literal">LineString</code> から構成された <code class="literal">GeometryCollection</code>:
              </p><pre class="programlisting">
GEOMETRYCOLLECTION(POINT(10 10), POINT(30 30), LINESTRING(15 15, 20 20))
</pre></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="gis-wkb-format"></a>11.5.3.1.2 WKB (Well-Known Binary) 形式</h5></div></div></div><a class="indexterm" name="idm139979101822160"></a><a class="indexterm" name="idm139979101820736"></a><p>
            幾何値の WKB (Well-Known Binary) 表現は、幾何 WKB 情報を含む <code class="literal">BLOB</code> 値によって表現されたバイナリストリームとして幾何データを交換するために使用されます。この形式は、OpenGIS 仕様によって定義されています (<a class="xref" href="data-types.html#spatial-extensions" title="11.5 空間データの拡張">セクション11.5「空間データの拡張」</a>を参照してください)。これはまた、ISO の <em class="citetitle">SQL/MM Part 3: Spatial</em> 標準でも定義されています。
          </p><p></p><p>
            WKB は、1 バイトの符号なしの整数、4 バイトの符号なしの整数、および 8 バイトの倍精度数 (IEEE 754 形式) を使用します。1 バイトは 8 ビットです。
          </p><p>
            たとえば、<code class="literal">POINT(1 1)</code> に対応する WKB 値は、それぞれ 2 つの 16 進数で表された次の 21 バイトのシーケンスから構成されます。
          </p><pre class="programlisting">
0101000000000000000000F03F000000000000F03F
</pre><p>
            このシーケンスは次のコンポーネントから構成されます。
          </p><pre class="programlisting">
Byte order:   01
WKB type:     01000000
X coordinate: 000000000000F03F
Y coordinate: 000000000000F03F
</pre><p>
            各コンポーネントが表す内容は次のとおりです。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                バイト順序は 1 または 0 のどちらかで、リトルエンディアンまたはビッグエンディアンストレージを示します。リトルエンディアンバイト順序、ビッグエンディアンバイト順序はそれぞれ NDR (Network Data Representation)、XDR (External Data Representation) とも呼ばれます。
              </p></li><li class="listitem"><p>
                WKB 型は幾何型を示すコードです。1 から 7 の値は <code class="literal">Point</code>、<code class="literal">LineString</code>、<code class="literal">Polygon</code>、<code class="literal">MultiPoint</code>、<code class="literal">MultiLineString</code>、<code class="literal">MultiPolygon</code>、および <code class="literal">GeometryCollection</code> を示します。
              </p></li><li class="listitem"><p>
                <code class="literal">Point</code> 値には X 座標と Y 座標が含まれますが、それぞれ倍精度値として表現されます。
              </p></li></ul></div><p>
            さらに複雑な幾何値の WKB 値は、OpenGIS 仕様書に詳しく記されているように、より複雑なデータ構造になります。
          </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="creating-spatial-columns"></a>11.5.3.2 空間カラムの作成</h4></div></div></div><p>
          MySQL には、<code class="literal">CREATE TABLE</code> や <code class="literal">ALTER TABLE</code> を使用する方法など、幾何型の空間カラムを作成するための標準的な方法が用意されています。空間カラムは、<code class="literal">MyISAM</code>、<code class="literal">InnoDB</code>、<code class="literal">NDB</code>、および <code class="literal">ARCHIVE</code> テーブルでサポートされています。<a class="xref" href="data-types.html#creating-spatial-indexes" title="11.5.3.6 空間インデックスの作成">セクション11.5.3.6「空間インデックスの作成」</a>の空間インデックスに関するノートも参照してください。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              空間カラムを含むテーブルを作成するには、<code class="literal">CREATE TABLE</code> ステートメントを使用します。
            </p><pre class="programlisting">
CREATE TABLE geom (g GEOMETRY);
</pre></li><li class="listitem"><p>
              既存のテーブルに対して空間カラムの追加や削除を行うには、<code class="literal">ALTER TABLE</code> ステートメントを使用します。
            </p><pre class="programlisting">
ALTER TABLE geom ADD pt POINT;
ALTER TABLE geom DROP pt;
</pre></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="populating-spatial-columns"></a>11.5.3.3 空間カラムへのデータ移入</h4></div></div></div><p>
          空間カラムを作成し終わったら、空間データを移入できます。
        </p><p>
          値は内部幾何形式で格納する必要がありますが、WKT (Well-Known Text)、WKB (Well-Known Binary) のいずれの形式からでも、その形式に値を変換できます。次の例は、WKT 値を内部幾何形式に変換することによって、幾何値をテーブルに挿入する方法を示しています。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              次のように <code class="literal">INSERT</code> ステートメント内で直接変換を実行します。
            </p><pre class="programlisting">
INSERT INTO geom VALUES (GeomFromText('POINT(1 1)'));

SET @g = 'POINT(1 1)';
INSERT INTO geom VALUES (GeomFromText(@g));
</pre></li><li class="listitem"><p>
              次のように <code class="literal">INSERT</code> の前に変換を実行します。
            </p><pre class="programlisting">
SET @g = GeomFromText('POINT(1 1)');
INSERT INTO geom VALUES (@g);
</pre></li></ul></div><p>
          次の例では、より複雑な幾何図形をテーブルに挿入しています。
        </p><pre class="programlisting">
SET @g = 'LINESTRING(0 0,1 1,2 2)';
INSERT INTO geom VALUES (GeomFromText(@g));

SET @g = 'POLYGON((0 0,10 0,10 10,0 10,0 0),(5 5,7 5,7 7,5 7, 5 5))';
INSERT INTO geom VALUES (GeomFromText(@g));

SET @g =
'GEOMETRYCOLLECTION(POINT(1 1),LINESTRING(0 0,1 1,2 2,3 3,4 4))';
INSERT INTO geom VALUES (GeomFromText(@g));
</pre><p>
          前述の例では、<code class="literal">GeomFromText()</code> を使用して幾何値を作成しています。次のように型に固有の関数を使用することもできます。
        </p><pre class="programlisting">
SET @g = 'POINT(1 1)';
INSERT INTO geom VALUES (PointFromText(@g));

SET @g = 'LINESTRING(0 0,1 1,2 2)';
INSERT INTO geom VALUES (LineStringFromText(@g));

SET @g = 'POLYGON((0 0,10 0,10 10,0 10,0 0),(5 5,7 5,7 7,5 7, 5 5))';
INSERT INTO geom VALUES (PolygonFromText(@g));

SET @g =
'GEOMETRYCOLLECTION(POINT(1 1),LINESTRING(0 0,1 1,2 2,3 3,4 4))';
INSERT INTO geom VALUES (GeomCollFromText(@g));
</pre><p>
          幾何値の WKB 表現を使用するクライアントアプリケーションプログラムが、クエリーで正しく作成された WKB のサーバーへの送信を担います。この要件を満たす方法は複数あります。例:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              次のように、16 進リテラル構文を使用して、<code class="literal">POINT(1 1)</code> 値を挿入します。
            </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>INSERT INTO geom VALUES</code></strong>
    -&gt; <strong class="userinput"><code>(GeomFromWKB(0x0101000000000000000000F03F000000000000F03F));</code></strong>
</pre></li><li class="listitem"><p>
              ODBC アプリケーションは、<code class="literal">BLOB</code> 型の引数を使用して WKB 表現をプレースホルダにバインドし、WKB 表現を送信できます。
            </p><pre class="programlisting">
INSERT INTO geom VALUES (GeomFromWKB(?))
</pre><p>
              ほかのプログラミングインタフェースも似たようなプレースホルダメカニズムをサポートしている可能性があります。
            </p></li><li class="listitem"><p>
              C プログラムでは、<code class="literal">mysql_real_escape_string()</code> を使用してバイナリ値をエスケープし、その結果をクエリー文字列に含めてサーバーに送信できます。<a class="xref" href="connectors-apis.html#mysql-real-escape-string" title="23.8.7.54 mysql_real_escape_string()">セクション23.8.7.54「mysql_real_escape_string()」</a>を参照してください。
            </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="fetching-spatial-data"></a>11.5.3.4 空間データのフェッチ</h4></div></div></div><p>
          テーブルに格納された幾何値は内部形式でフェッチできます。WKT 形式から WKB 形式に変換することもできます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              内部形式での空間データのフェッチ:
            </p><p>
              内部形式で幾何値をフェッチする方法は、テーブル間でデータの転送を行う場合に便利です。
            </p><pre class="programlisting">
CREATE TABLE geom2 (g GEOMETRY) SELECT g FROM geom;
</pre></li><li class="listitem"><p>
              WKT 形式での空間データのフェッチ:
            </p><p>
              <code class="literal">AsText()</code> 関数は幾何図形を内部形式から WKT 文字列に変換します。
            </p><pre class="programlisting">
SELECT AsText(g) FROM geom;
</pre></li><li class="listitem"><p>
              WKB 形式での空間データのフェッチ:
            </p><p>
              <code class="literal">AsBinary()</code> 関数は幾何図形を内部形式から WKB 値を含む <code class="literal">BLOB</code> に変換します。
            </p><pre class="programlisting">
SELECT AsBinary(g) FROM geom;
</pre></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="optimizing-spatial-analysis"></a>11.5.3.5 空間分析の最適化</h4></div></div></div><p>
          <code class="literal">MyISAM</code> テーブルの場合、空間データを含むカラムでの検索操作は、<code class="literal">SPATIAL</code> インデックスを使用して最適化できます。もっとも典型的な操作は次のとおりです。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              指定された点を含むすべてのオブジェクトを検索する点クエリー
            </p></li><li class="listitem"><p>
              所定の領域と重なるすべてのオブジェクトを検索する領域クエリー
            </p></li></ul></div><p>
          MySQL では、<span class="bold"><strong>2 次分割 R ツリー</strong></span>を使用して空間カラムの <code class="literal">SPATIAL</code> インデックスが実装されています。<code class="literal">SPATIAL</code> インデックスは、幾何図形の最小外接矩形 (MBR) を使用して構築されます。大部分の幾何図形では、MBR はその幾何図形を囲む最小矩形となります。水平または垂直方向のライン文字列では、MBR は矩形からライン文字列に縮退します。点の場合、MBR は矩形から点に縮退します。
        </p><p>
          空間カラムに通常のインデックスを作成することも可能です。非 <code class="literal">SPATIAL</code> インデックスでは、<code class="literal">POINT</code> カラムを除くすべての空間カラムでプリフィクスを宣言する必要があります。
        </p><p>
          <code class="literal">MyISAM</code> は、<code class="literal">SPATIAL</code> インデックスと非 <code class="literal">SPATIAL</code> インデックスの両方をサポートします。その他のストレージエンジンは<a class="xref" href="sql-syntax.html#create-index" title="13.1.13 CREATE INDEX 構文">セクション13.1.13「CREATE INDEX 構文」</a>で説明しているように、非 <code class="literal">SPATIAL</code> インデックスをサポートします。
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="creating-spatial-indexes"></a>11.5.3.6 空間インデックスの作成</h4></div></div></div><p>
          <code class="literal">MyISAM</code> テーブルでは、MySQL は、通常のインデックスを作成するための似た構文を使用するが、<code class="literal">SPATIAL</code> キーワードを使用して、空間インデックスを作成できます。空間インデックスのカラムは、<code class="literal">NOT NULL</code> と宣言する必要があります。次の各例では空間インデックスの作成方法を示します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">CREATE TABLE</code> を使用する場合:
            </p><pre class="programlisting">
CREATE TABLE geom (g GEOMETRY NOT NULL, SPATIAL INDEX(g)) ENGINE=MyISAM;
</pre></li><li class="listitem"><p>
              <code class="literal">ALTER TABLE</code> を使用する場合:
            </p><pre class="programlisting">
ALTER TABLE geom ADD SPATIAL INDEX(g);
</pre></li><li class="listitem"><p>
              <code class="literal">CREATE INDEX</code> を使用する場合:
            </p><pre class="programlisting">
CREATE SPATIAL INDEX sp_index ON geom (g);
</pre></li></ul></div><p>
          <code class="literal">SPATIAL INDEX</code> は R ツリーインデックスを作成します。空間カラムの非空間インデックスをサポートするストレージエンジンでは、B ツリーインデックスが作成されます。空間値に対する B ツリーインデックスは、正確な値の検索に役立ちますが、範囲スキャンには役立ちません。
        </p><p>
          空間カラムのインデックス作成の詳細については、<a class="xref" href="sql-syntax.html#create-index" title="13.1.13 CREATE INDEX 構文">セクション13.1.13「CREATE INDEX 構文」</a>を参照してください。
        </p><p>
          空間インデックスを削除するには、次のように <code class="literal">ALTER TABLE</code> または <code class="literal">DROP INDEX</code> を使用します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="literal">ALTER TABLE</code> を使用する場合:
            </p><pre class="programlisting">
ALTER TABLE geom DROP INDEX g;
</pre></li><li class="listitem"><p>
              <code class="literal">DROP INDEX</code> を使用する場合:
            </p><pre class="programlisting">
DROP INDEX sp_index ON geom;
</pre></li></ul></div><p>
          例: テーブル <code class="literal">geom</code> に 32,000 件を超える幾何図形が含まれていて、それらの図形が型 <code class="literal">GEOMETRY</code> のカラム <code class="literal">g</code> に格納されているものとします。またこのテーブルには、オブジェクト ID の値を格納するための <code class="literal">AUTO_INCREMENT</code> カラム <code class="literal">fid</code> も含まれています。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>DESCRIBE geom;</code></strong>
+-------+----------+------+-----+---------+----------------+
| Field | Type     | Null | Key | Default | Extra          |
+-------+----------+------+-----+---------+----------------+
| fid   | int(11)  |      | PRI | NULL    | auto_increment |
| g     | geometry |      |     |         |                |
+-------+----------+------+-----+---------+----------------+
2 rows in set (0.00 sec)

mysql&gt; <strong class="userinput"><code>SELECT COUNT(*) FROM geom;</code></strong>
+----------+
| count(*) |
+----------+
|    32376 |
+----------+
1 row in set (0.00 sec)
</pre><p>
          カラム <code class="literal">g</code> に空間インデックスを追加するには、次のステートメントを使用します。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>ALTER TABLE geom ADD SPATIAL INDEX(g) ENGINE=MyISAM;</code></strong>
Query OK, 32376 rows affected (4.05 sec)
Records: 32376  Duplicates: 0  Warnings: 0
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="using-spatial-indexes"></a>11.5.3.7 空間インデックスの使用</h4></div></div></div><p>
          オプティマイザは、<code class="literal">WHERE</code> 句で <code class="literal">MBRContains()</code> や <code class="literal">MBRWithin()</code> などの関数が使用されているクエリーの検索に、使用可能な空間インデックスを含めることができるかどうかを調べます。次のクエリーは、所定の矩形に含まれるすべてのオブジェクトを検索します。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET @poly =</code></strong>
    -&gt; <strong class="userinput"><code>'Polygon((30000 15000,
                 31000 15000,
                 31000 16000,
                 30000 16000,
                 30000 15000))';</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT fid,AsText(g) FROM geom WHERE</code></strong>
    -&gt; <strong class="userinput"><code>MBRContains(GeomFromText(@poly),g);</code></strong>
+-----+---------------------------------------------------------------+
| fid | AsText(g)                                                     |
+-----+---------------------------------------------------------------+
|  21 | LINESTRING(30350.4 15828.8,30350.6 15845,30333.8 15845,30 ... |
|  22 | LINESTRING(30350.6 15871.4,30350.6 15887.8,30334 15887.8, ... |
|  23 | LINESTRING(30350.6 15914.2,30350.6 15930.4,30334 15930.4, ... |
|  24 | LINESTRING(30290.2 15823,30290.2 15839.4,30273.4 15839.4, ... |
|  25 | LINESTRING(30291.4 15866.2,30291.6 15882.4,30274.8 15882. ... |
|  26 | LINESTRING(30291.6 15918.2,30291.6 15934.4,30275 15934.4, ... |
| 249 | LINESTRING(30337.8 15938.6,30337.8 15946.8,30320.4 15946. ... |
|   1 | LINESTRING(30250.4 15129.2,30248.8 15138.4,30238.2 15136. ... |
|   2 | LINESTRING(30220.2 15122.8,30217.2 15137.8,30207.6 15136, ... |
|   3 | LINESTRING(30179 15114.4,30176.6 15129.4,30167 15128,3016 ... |
|   4 | LINESTRING(30155.2 15121.4,30140.4 15118.6,30142 15109,30 ... |
|   5 | LINESTRING(30192.4 15085,30177.6 15082.2,30179.2 15072.4, ... |
|   6 | LINESTRING(30244 15087,30229 15086.2,30229.4 15076.4,3024 ... |
|   7 | LINESTRING(30200.6 15059.4,30185.6 15058.6,30186 15048.8, ... |
|  10 | LINESTRING(30179.6 15017.8,30181 15002.8,30190.8 15003.6, ... |
|  11 | LINESTRING(30154.2 15000.4,30168.6 15004.8,30166 15014.2, ... |
|  13 | LINESTRING(30105 15065.8,30108.4 15050.8,30118 15053,3011 ... |
| 154 | LINESTRING(30276.2 15143.8,30261.4 15141,30263 15131.4,30 ... |
| 155 | LINESTRING(30269.8 15084,30269.4 15093.4,30258.6 15093,30 ... |
| 157 | LINESTRING(30128.2 15011,30113.2 15010.2,30113.6 15000.4, ... |
+-----+---------------------------------------------------------------+
20 rows in set (0.00 sec)
</pre><p>
          このクエリーがどのように実行されているのかを、<code class="literal">EXPLAIN</code> を使用して確認します。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET @poly =</code></strong>
    -&gt; <strong class="userinput"><code>'Polygon((30000 15000,
                 31000 15000,
                 31000 16000,
                 30000 16000,
                 30000 15000))';</code></strong>
mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT fid,AsText(g) FROM geom WHERE</code></strong>
    -&gt; <strong class="userinput"><code>MBRContains(GeomFromText(@poly),g)\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: geom
         type: range
possible_keys: g
          key: g
      key_len: 32
          ref: NULL
         rows: 50
        Extra: Using where
1 row in set (0.00 sec)
</pre><p>
          空間インデックスがないとどうなるのかを確認します。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET @poly =</code></strong>
    -&gt; <strong class="userinput"><code>'Polygon((30000 15000,
                 31000 15000,
                 31000 16000,
                 30000 16000,
                 30000 15000))';</code></strong>
mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT fid,AsText(g) FROM g IGNORE INDEX (g) WHERE</code></strong>
    -&gt; <strong class="userinput"><code>MBRContains(GeomFromText(@poly),g)\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: geom
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 32376
        Extra: Using where
1 row in set (0.00 sec)
</pre><p>
          空間インデックスを使用せずに <code class="literal">SELECT</code> ステートメントを実行しても結果は同じになりますが、実行時間は 0.00 秒から 0.46 秒に増大します。
        </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>SET @poly =</code></strong>
    -&gt; <strong class="userinput"><code>'Polygon((30000 15000,
                 31000 15000,
                 31000 16000,
                 30000 16000,
                 30000 15000))';</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT fid,AsText(g) FROM geom IGNORE INDEX (g) WHERE</code></strong>
    -&gt; <strong class="userinput"><code>MBRContains(GeomFromText(@poly),g);</code></strong>
+-----+---------------------------------------------------------------+
| fid | AsText(g)                                                     |
+-----+---------------------------------------------------------------+
|   1 | LINESTRING(30250.4 15129.2,30248.8 15138.4,30238.2 15136. ... |
|   2 | LINESTRING(30220.2 15122.8,30217.2 15137.8,30207.6 15136, ... |
|   3 | LINESTRING(30179 15114.4,30176.6 15129.4,30167 15128,3016 ... |
|   4 | LINESTRING(30155.2 15121.4,30140.4 15118.6,30142 15109,30 ... |
|   5 | LINESTRING(30192.4 15085,30177.6 15082.2,30179.2 15072.4, ... |
|   6 | LINESTRING(30244 15087,30229 15086.2,30229.4 15076.4,3024 ... |
|   7 | LINESTRING(30200.6 15059.4,30185.6 15058.6,30186 15048.8, ... |
|  10 | LINESTRING(30179.6 15017.8,30181 15002.8,30190.8 15003.6, ... |
|  11 | LINESTRING(30154.2 15000.4,30168.6 15004.8,30166 15014.2, ... |
|  13 | LINESTRING(30105 15065.8,30108.4 15050.8,30118 15053,3011 ... |
|  21 | LINESTRING(30350.4 15828.8,30350.6 15845,30333.8 15845,30 ... |
|  22 | LINESTRING(30350.6 15871.4,30350.6 15887.8,30334 15887.8, ... |
|  23 | LINESTRING(30350.6 15914.2,30350.6 15930.4,30334 15930.4, ... |
|  24 | LINESTRING(30290.2 15823,30290.2 15839.4,30273.4 15839.4, ... |
|  25 | LINESTRING(30291.4 15866.2,30291.6 15882.4,30274.8 15882. ... |
|  26 | LINESTRING(30291.6 15918.2,30291.6 15934.4,30275 15934.4, ... |
| 154 | LINESTRING(30276.2 15143.8,30261.4 15141,30263 15131.4,30 ... |
| 155 | LINESTRING(30269.8 15084,30269.4 15093.4,30258.6 15093,30 ... |
| 157 | LINESTRING(30128.2 15011,30113.2 15010.2,30113.6 15000.4, ... |
| 249 | LINESTRING(30337.8 15938.6,30337.8 15946.8,30320.4 15946. ... |
+-----+---------------------------------------------------------------+
20 rows in set (0.46 sec)
</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="data-type-defaults"></a>11.6 データ型デフォルト値</h2></div></div></div><a class="indexterm" name="idm139979101659248"></a><a class="indexterm" name="idm139979101657824"></a><a class="indexterm" name="idm139979101655792"></a><a class="indexterm" name="idm139979101654416"></a><a class="indexterm" name="idm139979101652384"></a><a class="indexterm" name="idm139979101651008"></a><p>
      データ型仕様の <code class="literal">DEFAULT <em class="replaceable"><code>value</code></em></code> 句は、カラムのデフォルト値を示しています。例外が 1 つあります。デフォルト値は定数である必要があるので、関数または式にはできません。これは、たとえば日付カラムのデフォルト値に <code class="literal">NOW()</code> や <code class="literal">CURRENT_DATE</code> などの関数の値を設定できないことを意味します。例外では、<code class="literal">CURRENT_TIMESTAMP</code> を、<code class="literal">TIMESTAMP</code> および <code class="literal">DATETIME</code> カラムのデフォルトとして指定できます。<a class="xref" href="data-types.html#timestamp-initialization" title="11.3.5 TIMESTAMP および DATETIME の自動初期化および更新機能">セクション11.3.5「TIMESTAMP および DATETIME の自動初期化および更新機能」</a>を参照してください。
    </p><p>
      <code class="literal">BLOB</code> および <code class="literal">TEXT</code> カラムにはデフォルト値を割り当てられません。
    </p><p>
      カラム定義に明示的な <code class="literal">DEFAULT</code> 値が含まれていない場合、MySQL はデフォルト値を次のように特定します。
    </p><p>
      <code class="literal">NULL</code> を値として取ることができる場合は、そのカラムは明示的な <code class="literal">DEFAULT NULL</code> 句で定義ができます。
    </p><p>
      <code class="literal">NULL</code> を値として取ることができない場合は、MySQL は明示的な <code class="literal">DEFAULT</code> 句でカラムを定義できません。例外: カラムが <code class="literal">PRIMARY KEY</code> の一部として定義されているが、<code class="literal">NOT NULL</code> として明示的には定義されていない場合、MySQL はこれを <code class="literal">NOT NULL</code> カラムとして作成します (<code class="literal">PRIMARY KEY</code> カラムは <code class="literal">NOT NULL</code> である必要があるので) が、暗黙的なデフォルト値を使用してこれに <code class="literal">DEFAULT</code> 句も割り当てます。これを防止するには、すべての <code class="literal">PRIMARY KEY</code> カラムの定義に明示的な <code class="literal">NOT NULL</code> を含めてください。
    </p><p>
      明示的な <code class="literal">DEFAULT</code> 句のない <code class="literal">NOT NULL</code> カラムに対するデータエントリでは、<code class="literal">INSERT</code> または <code class="literal">REPLACE</code> ステートメントにカラムの値を含まれていない場合、または <code class="literal">UPDATE</code> ステートメントがカラムを <code class="literal">NULL</code> に設定する場合、MySQL はその時点で有効な SQL モードに従ってカラムを処理します。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          厳密な SQL モードを有効にした場合、トランザクションテーブルに対してエラーが発生し、ステートメントがロールバックされます。非トランザクションテーブルではエラーが起きるが、これが複数行ステートメントの 2 行目以降の行に対するエラーの場合、先行する行が挿入されています。
        </p></li><li class="listitem"><p>
          厳密モードが有効でない場合、MySQL はカラムデータ型の暗黙的なデフォルト値にカラムを設定します。
        </p></li></ul></div><p>
      テーブル <code class="literal">t</code> が次のように定義されるとします。
    </p><pre class="programlisting">
CREATE TABLE t (i INT NOT NULL);
</pre><p>
      この場合、<code class="literal">i</code> は明示的なデフォルトがないので、厳密モードでは次のそれぞれはステートメントはエラーになり、行は挿入されません。厳密モードを使用しない場合、3 番目のステートメントだけでエラーが発生します。最初の 2 つのステートメントでは暗黙のデフォルトが挿入されますが、<code class="literal">DEFAULT(i)</code> が値を生成できないので 3 番目のステートメントは失敗します。
    </p><pre class="programlisting">
INSERT INTO t VALUES();
INSERT INTO t VALUES(DEFAULT);
INSERT INTO t VALUES(DEFAULT(i));
</pre><p>
      <a class="xref" href="server-administration.html#sql-mode" title="5.1.7 サーバー SQL モード">セクション5.1.7「サーバー SQL モード」</a>を参照してください。
    </p><p>
      所定のテーブルに対して、<code class="literal">SHOW CREATE TABLE</code> ステートメントを使用すると、どのカラムに明示的な <code class="literal">DEFAULT</code> 句があるかを確認できます。
    </p><p>
      暗黙的なデフォルトは次のように定義されます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          数値型のデフォルトは <code class="literal">0</code> です。ただし、例外として <code class="literal">AUTO_INCREMENT</code> 属性で宣言された整数型または浮動小数点型のデフォルトは、そのシーケンスの次の値になります。
        </p></li><li class="listitem"><p>
          <code class="literal">TIMESTAMP</code> 以外の日付と時間型のデフォルトには、<span class="quote">「<span class="quote">ゼロ</span>」</span>値が適切です。<code class="literal">explicit_defaults_for_timestamp</code> システム変数が有効な場合、これは <code class="literal">TIMESTAMP</code> にも当てはまります (<a class="xref" href="server-administration.html#server-system-variables" title="5.1.4 サーバーシステム変数">セクション5.1.4「サーバーシステム変数」</a>を参照してください)。それ以外の場合、テーブルの最初の <code class="literal">TIMESTAMP</code> カラムのデフォルト値は現在の日付と時間になります。<a class="xref" href="data-types.html#date-and-time-types" title="11.3 日付と時間型">セクション11.3「日付と時間型」</a>を参照してください。
        </p></li><li class="listitem"><p>
          <code class="literal">ENUM</code> ではない文字列型のデフォルト値は空の文字列です。<code class="literal">ENUM</code> のデフォルトは、最初の列挙値です。
        </p></li></ul></div><a class="indexterm" name="idm139979101595744"></a><p>
      整数カラム定義の中の <code class="literal">SERIAL DEFAULT VALUE</code> は <code class="literal">NOT NULL AUTO_INCREMENT UNIQUE</code> のエイリアスです。
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="storage-requirements"></a>11.7 データ型のストレージ要件</h2></div></div></div><a class="indexterm" name="idm139979101591200"></a><a class="indexterm" name="idm139979101589072"></a><p>
      ディスク上のテーブルデータのストレージ要件は、複数の要因によって異なります。別々のストレージエンジンは異なる方法でデータ型を表し、ローデータを格納します。カラムか行全体のどちらかでテーブルデータを圧縮できますが、テーブルまたはカラムのストレージ要件の計算が複雑になります。
    </p><p>
      ディスク上のストレージレイアウトが違っていても、テーブル行に関する情報を通信および交換する内部 MySQL API は、すべてのストレージエンジンにわたって適用される一貫したデータ構造を使用します。
    </p><p>
      このセクションでは、データ型の固定サイズ表現を使用するストレージエンジンの内部形式およびサイズを含め、MySQL がサポートするデータ型ごとのストレージ要件に関するガイドラインおよび情報について説明します。情報はカテゴリまたはストレージエンジンごとに示します。
    </p><a class="indexterm" name="idm139979101584032"></a><p>
      テーブルの内部表現の最大行サイズは 65,535 バイトであり、ストレージエンジンがこれ以上のサイズの行をサポートできる場合でもこのサイズになります。<code class="literal">BLOB</code> または <code class="literal">TEXT</code> カラムはこのサイズに 9 から 12 バイトしか関与しないので、これらのカラムはこのサイズに含まれません。<code class="literal">BLOB</code> および <code class="literal">TEXT</code> データについての情報は、行バッファーとは異なるメモリー領域に内部的に格納されます。それぞれのストレージエンジンは、対応する型の処理に使用する方法に従って異なる方法で、このデータの割り当ておよびストレージを扱います。詳細は、<a class="xref" href="storage-engines.html" title="第 15 章 代替ストレージエンジン">第15章「<i>代替ストレージエンジン</i>」</a>および<a class="xref" href="restrictions.html#column-count-limit" title="D.10.4 テーブルカラム数と行サイズの制限">セクションD.10.4「テーブルカラム数と行サイズの制限」</a>を参照してください。
    </p><h3><a name="idm139979101575056"></a>InnoDB テーブルのストレージ要件</h3><a class="indexterm" name="idm139979101574288"></a><p>
      <code class="literal">InnoDB</code> テーブルのストレージ要件の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-physical-record" title="14.2.13.7 物理的な行構造">セクション14.2.13.7「物理的な行構造」</a>を参照してください。
    </p><h3><a name="idm139979101570352"></a>NDBCLUSTER テーブルのストレージ要件</h3><a class="indexterm" name="idm139979101569552"></a><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">重要</div><p>
        <code class="literal">NDB</code> テーブルは、<em class="firstterm">4 バイトアライメント</em>を使用します。すべての <code class="literal">NDB</code> データストレージは、4 バイトの倍数で行われます。したがって、通常であれば 15 バイトを使用するカラム値は、<code class="literal">NDB</code> テーブルでは 16 バイトを必要とします。たとえば、<code class="literal">NDB</code> テーブルでは、<code class="literal">TINYINT</code>、<code class="literal">SMALLINT</code>、<code class="literal">MEDIUMINT</code>、および <code class="literal">INTEGER</code> (<code class="literal">INT</code>) カラム型はそれぞれ、アライメント係数により、レコードあたり 4 バイトのストレージが必要になります。
      </p><p>
        各 <code class="literal">BIT(<em class="replaceable"><code>M</code></em>)</code> カラムは <em class="replaceable"><code>M</code></em> ビットのストレージ領域を使用します。各 <code class="literal">BIT</code> カラムは 4 バイトアライメントが行われて<span class="emphasis"><em>いません</em></span>が、<code class="literal">NDB</code> は、<code class="literal">BIT</code> カラムに必要な最初の 1 から 32 ビットに行あたり 4 バイト (32 ビット) を、33 から 64 ビットに別の 4 ビットを、というように予約します。
      </p><p>
        <code class="literal">NULL</code> 自体はストレージ領域を必要としませんが、<code class="literal">NDB</code> は、テーブル定義に <code class="literal">NULL</code> として定義されたカラム (最大 32 の <code class="literal">NULL</code> カラム) が含まれる場合、行あたり 4 バイトを予約します。(MySQL Cluster テーブルが 32 以上の <code class="literal">NULL</code> カラムから 64 の <code class="literal">NULL</code> カラムで定義されている場合、行あたり 8 バイトが予約されます。)
      </p></div><p>
      <code class="literal">NDB</code> ストレージエンジンを使用するすべてのテーブルで主キーが必要になります。主キーを定義していない場合、<span class="quote">「<span class="quote">非表示</span>」</span>の主キーが <code class="literal">NDB</code> によって作成されます。この非表示の主キーはテーブルレコードあたり 31 から 35 バイトを消費します。
    </p><a class="indexterm" name="idm139979101542496"></a><p>
      <span class="command"><strong>ndb_size.pl</strong></span> Perl スクリプトを使用して、<code class="literal">NDB</code> ストレージ要件を評価します。これは、(MySQL Cluster ではなく) 現在の MySQL データベースに接続し、そのデータベースが <code class="literal">NDB</code> ストレージエンジンを使用した場合にどれだけの領域を必要とするかについてレポート作成します。詳細は、<a class="xref" href="mysql-cluster.html#mysql-cluster-programs-ndb-size-pl" title="18.4.25 ndb_size.pl — NDBCLUSTER サイズ要件エスティメータ">セクション18.4.25「<span class="command"><strong>ndb_size.pl</strong></span> — NDBCLUSTER サイズ要件エスティメータ」</a>を参照してください。
    </p><h3><a name="idm139979101536592"></a>数値型のストレージ要件</h3><a class="indexterm" name="idm139979101535872"></a><a class="indexterm" name="idm139979101534416"></a><div class="informaltable"><table summary="この表は、数値データ型に必要なストレージを示しています。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">データ型</th><th scope="col">必要なストレージ</th></tr></thead><tbody><tr><td scope="row"><code class="literal">TINYINT</code></td><td>1 バイト</td></tr><tr><td scope="row"><code class="literal">SMALLINT</code></td><td>2 バイト</td></tr><tr><td scope="row"><code class="literal">MEDIUMINT</code></td><td>3 バイト</td></tr><tr><td scope="row"><code class="literal">INT</code>、<code class="literal">INTEGER</code></td><td>4 バイト</td></tr><tr><td scope="row"><code class="literal">BIGINT</code></td><td>8 バイト</td></tr><tr><td scope="row"><code class="literal">FLOAT(<em class="replaceable"><code>p</code></em>)</code></td><td>0 &lt;= <em class="replaceable"><code>p</code></em> &lt;= 24 の場合は 4 バイト、25 &lt;= <em class="replaceable"><code>p</code></em> &lt;= 53 の場合は 8 バイト</td></tr><tr><td scope="row"><code class="literal">FLOAT</code></td><td>4 バイト</td></tr><tr><td scope="row"><code class="literal">DOUBLE [PRECISION]</code>、<code class="literal">REAL</code></td><td>8 バイト</td></tr><tr><td scope="row"><code class="literal">DECIMAL(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)</code>、<code class="literal">NUMERIC(<em class="replaceable"><code>M</code></em>,<em class="replaceable"><code>D</code></em>)</code></td><td>変動; 次の説明を参照</td></tr><tr><td scope="row"><code class="literal">BIT(<em class="replaceable"><code>M</code></em>)</code></td><td>約 (<em class="replaceable"><code>M</code></em>+7)/8 バイト</td></tr></tbody></table></div><p>
      <code class="literal">DECIMAL</code> (および <code class="literal">NUMERIC</code>) カラムの値は、9 桁の 10 進数 (10 進法) を 4 バイトにパックするバイナリ形式を使用して表現されます。各値の整数部と小数部のストレージは、個別に決定されます。9 桁の倍ごとに 4 バイトが必要であり、<span class="quote">「<span class="quote">余りの</span>」</span>桁には 4 バイトのうちの一部が必要です。余りの桁に必要なストレージ要件を次の表に示します。
    </p><div class="informaltable"><table summary="この表は、余りの桁で必要なストレージを示します。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">余りの桁</th><th scope="col">バイト数</th></tr></thead><tbody><tr><td scope="row">0</td><td>0</td></tr><tr><td scope="row">1</td><td>1</td></tr><tr><td scope="row">2</td><td>1</td></tr><tr><td scope="row">3</td><td>2</td></tr><tr><td scope="row">4</td><td>2</td></tr><tr><td scope="row">5</td><td>3</td></tr><tr><td scope="row">6</td><td>3</td></tr><tr><td scope="row">7</td><td>4</td></tr><tr><td scope="row">8</td><td>4</td></tr></tbody></table></div><h3><a name="data-types-storage-reqs-date-time"></a>日付と時間型のストレージ要件</h3><a class="indexterm" name="idm139979101483440"></a><a class="indexterm" name="idm139979101481984"></a><a class="indexterm" name="idm139979101480640"></a><a class="indexterm" name="idm139979101478608"></a><p>
      <code class="literal">TIME</code>、<code class="literal">DATETIME</code>、および <code class="literal">TIMESTAMP</code> カラムの場合、MySQL 5.6.4 よりも前に作成されたテーブルに必要なストレージは、5.6.4 以降で作成されたテーブルとは異なります。これは、5.6.4 で、0 から 3 バイトを必要とする小数部をこれらの型が持つことを許可するように変更されたためです。
    </p><div class="informaltable"><table summary="この表は、MySQL 5.6.4 より前と MySQL 5.6.4 以降の日付と時間型で必要なストレージを示しています。" border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">データ型</th><th scope="col">MySQL 5.6.4 より前で必要なストレージ</th><th scope="col">MySQL 5.6.4 以降で必要なストレージ</th></tr></thead><tbody><tr><td scope="row"><code class="literal">YEAR</code></td><td>1 バイト</td><td>1 バイト</td></tr><tr><td scope="row"><code class="literal">DATE</code></td><td>3 バイト</td><td>3 バイト</td></tr><tr><td scope="row"><code class="literal">TIME</code></td><td>3 バイト</td><td>3 バイト + 小数秒ストレージ</td></tr><tr><td scope="row"><code class="literal">DATETIME</code></td><td>8 バイト</td><td>5 バイト + 小数秒ストレージ</td></tr><tr><td scope="row"><code class="literal">TIMESTAMP</code></td><td>4 バイト</td><td>4 バイト + 小数秒ストレージ</td></tr></tbody></table></div><p>
      MySQL 5.6.4 以降、<code class="literal">YEAR</code> および <code class="literal">DATE</code> のストレージは変更ありません。ただし、<code class="literal">TIME</code>、<code class="literal">DATETIME</code>、および <code class="literal">TIMESTAMP</code> は異なって表現されます。<code class="literal">DATETIME</code> はより効率的にパックされ、非小数部に必要なバイト数は 8 バイトではなく 5 バイトであり、3 つの部分すべてに、格納値の小数秒精度に応じて 0 から 3 バイトが必要な小数部があります。
    </p><div class="informaltable"><table summary="この表は、小数秒精度に必要なストレージを示します。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">小数秒精度</th><th scope="col">必要なストレージ</th></tr></thead><tbody><tr><td scope="row">0</td><td>0 バイト</td></tr><tr><td scope="row">1、2</td><td>1 バイト</td></tr><tr><td scope="row">3、4</td><td>2 バイト</td></tr><tr><td scope="row">5、6</td><td>3 バイト</td></tr></tbody></table></div><p>
      たとえば、<code class="literal">TIME(0)</code>、<code class="literal">TIME(2)</code>、<code class="literal">TIME(4)</code>、および <code class="literal">TIME(6)</code> はそれぞれ 3、4、5、6 バイトを使用します。<code class="literal">TIME</code> と <code class="literal">TIME(0)</code> は同等で、必要なストレージは同じです。
    </p><p>
      時間値の内部表現の詳細は、「<a class="ulink" href="http://dev.mysql.com/doc/internals/en/algorithms.html" target="_top">MySQL Internals: Important Algorithms and Structures</a>」を参照してください。
    </p><h3><a name="idm139979101430400"></a>文字列型のストレージ要件</h3><a class="indexterm" name="idm139979101429680"></a><a class="indexterm" name="idm139979101428224"></a><p>
      次の表では、<em class="replaceable"><code>M</code></em> は宣言されたカラムの長さを、非バイナリ文字列型の場合は文字数で、バイナリ文字列型の場合はバイト数で表します。<em class="replaceable"><code>L</code></em> は指定された文字列値の実際の長さをバイト数で表します。
    </p><div class="informaltable"><table summary="この表は、文字列データ型に必要なストレージを示しています。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">データ型</th><th scope="col">必要なストレージ</th></tr></thead><tbody><tr><td scope="row"><code class="literal">CHAR(<em class="replaceable"><code>M</code></em>)</code></td><td><em class="replaceable"><code>M</code></em> × <em class="replaceable"><code>w</code></em> バイト、0 <code class="literal">&lt;= <em class="replaceable"><code>M</code></em> &lt;=</code> 255、ここで <em class="replaceable"><code>w</code></em> は、文字セット内の最大長の文字に必要なバイト数です。<code class="literal">InnoDB</code> テーブルの <code class="literal">CHAR</code> データ型のストレージ要件の詳細は、<a class="xref" href="innodb-storage-engine.html#innodb-physical-record" title="14.2.13.7 物理的な行構造">セクション14.2.13.7「物理的な行構造」</a>を参照してください。</td></tr><tr><td scope="row"><code class="literal">BINARY(<em class="replaceable"><code>M</code></em>)</code></td><td><em class="replaceable"><code>M</code></em> バイト、0 <code class="literal">&lt;= <em class="replaceable"><code>M</code></em> &lt;=</code> 255</td></tr><tr><td scope="row"><code class="literal">VARCHAR(<em class="replaceable"><code>M</code></em>)</code>、<code class="literal">VARBINARY(<em class="replaceable"><code>M</code></em>)</code></td><td>カラム値が 0 から 255 バイトを必要とする場合は、<em class="replaceable"><code>L</code></em> + 1 バイト、値が 255 バイト以上を必要とする可能性のある場合は、<em class="replaceable"><code>L</code></em> + 2 バイト</td></tr><tr><td scope="row"><code class="literal">TINYBLOB</code>、<code class="literal">TINYTEXT</code></td><td><em class="replaceable"><code>L</code></em> + 1 バイト、ここで <em class="replaceable"><code>L</code></em> &lt; 2<sup>8</sup></td></tr><tr><td scope="row"><code class="literal">BLOB</code>、<code class="literal">TEXT</code></td><td><em class="replaceable"><code>L</code></em> + 2 バイト、ここで <em class="replaceable"><code>L</code></em> &lt; 2<sup>16</sup></td></tr><tr><td scope="row"><code class="literal">MEDIUMBLOB</code>、<code class="literal">MEDIUMTEXT</code></td><td><em class="replaceable"><code>L</code></em> + 3 バイト、ここで <em class="replaceable"><code>L</code></em> &lt; 2<sup>24</sup></td></tr><tr><td scope="row"><code class="literal">LONGBLOB</code>、<code class="literal">LONGTEXT</code></td><td><em class="replaceable"><code>L</code></em> + 4 バイト、ここで <em class="replaceable"><code>L</code></em> &lt; 2<sup>32</sup></td></tr><tr><td scope="row"><code class="literal">ENUM('<em class="replaceable"><code>value1</code></em>','<em class="replaceable"><code>value2</code></em>',...)</code></td><td>列挙値の数 (最大 65,535 個の値) により 1 または 2 バイト</td></tr><tr><td scope="row"><code class="literal">SET('<em class="replaceable"><code>value1</code></em>','<em class="replaceable"><code>value2</code></em>',...)</code></td><td>セットメンバーの数 (最大 64 メンバー) により、1、2、3、4、または 8 バイト</td></tr></tbody></table></div><p>
      可変長の文字列型は、長さプリフィクスが付いたデータを使用して格納されます。長さプリフィクスにはデータ型に応じて 1 から 4 バイトが必要で、プリフィクスの値は <em class="replaceable"><code>L</code></em> (文字列のバイト長) です。たとえば、<code class="literal">MEDIUMTEXT</code> 値のストレージには、値を格納するための <em class="replaceable"><code>L</code></em> バイトに加えて、値の長さを格納するための 3 バイトが必要です。
    </p><p>
      特定の <code class="literal">CHAR</code>、<code class="literal">VARCHAR</code>、または <code class="literal">TEXT</code> カラム値の格納に使用されるバイト数を計算するには、そのカラムに使用される文字セットと、値にマルチバイト文字が含まれるかどうかを考慮する必要があります。特に、<code class="literal">utf8</code> (または <code class="literal">utf8mb4</code>) Unicode 文字セットを使用する場合、すべての文字セットが同じバイト数を使用するわけではなく、文字あたり最大 3 (4) バイトを必要とするわけではないことに注意する必要があります。<code class="literal">utf8</code> または <code class="literal">utf8mb4</code> 文字の異なるカテゴリに使用されるストレージの詳細は、<a class="xref" href="globalization.html#charset-unicode" title="10.1.10 Unicode のサポート">セクション10.1.10「Unicode のサポート」</a>を参照してください。
    </p><a class="indexterm" name="idm139979101373536"></a><a class="indexterm" name="idm139979101371408"></a><a class="indexterm" name="idm139979101369376"></a><p>
      <code class="literal">VARCHAR</code>、<code class="literal">VARBINARY</code>、および <code class="literal">BLOB</code> と <code class="literal">TEXT</code> 型は可変長型です。それぞれのストレージ要件は次の要因によって決まります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          カラム値の実際の長さ
        </p></li><li class="listitem"><p>
          カラムの可能な最大の長さ
        </p></li><li class="listitem"><p>
          カラムに使用される文字セット。一部の文字セットにはマルチバイト文字が含まれるため。
        </p></li></ul></div><p>
      たとえば、<code class="literal">VARCHAR(255)</code> カラムには最大 255 文字の長さの文字列を格納できます。そのカラムが <code class="literal">latin1</code> 文字セット (1 文字あたり 1 バイト) を使用すると仮定すると、実際に必要なストレージは文字列の長さ (<em class="replaceable"><code>L</code></em>) に、文字列の長さを記録するための 1 バイトを加えた大きさとなります。文字列 <code class="literal">'abcd'</code> の場合、<em class="replaceable"><code>L</code></em> は 4 で、ストレージ要件は 5 バイトになります。同じカラムが代わりにダブルバイト文字セット <code class="literal">ucs2</code> を使用するように宣言されている場合、ストレージ要件は 10 バイトになります。<code class="literal">'abcd'</code> の長さは 8 バイトで、カラムの最大長が 255 よりも大きい (最大 510 バイト) ため、長さを格納するために 2 バイト必要になります。
    </p><p>
      <code class="literal">VARCHAR</code> または <code class="literal">VARBINARY</code> カラムに格納できる有効な最大<span class="emphasis"><em>バイト数</em></span>は最大行サイズ (65,535 バイト、すべてのカラムで共有される) によって決まります。複数バイト文字を格納する <code class="literal">VARCHAR</code> カラムの場合、<span class="emphasis"><em>文字</em></span>の有効な最大数は少なくなります。たとえば、<code class="literal">utf8</code> の文字は 1 文字につき最大 3 バイトを必要とする場合があるため、<code class="literal">utf8</code> の文字セットを使用する <code class="literal">VARCHAR</code> カラムは、最大 21,844 文字になるように宣言できます。<a class="xref" href="restrictions.html#column-count-limit" title="D.10.4 テーブルカラム数と行サイズの制限">セクションD.10.4「テーブルカラム数と行サイズの制限」</a>を参照してください。
    </p><p>
      <code class="literal">NDB</code> ストレージエンジンは可変幅カラムをサポートします。これは、MySQL Cluster テーブル内の <code class="literal">VARCHAR</code> カラムは、このような値に対して 4 バイトアライメントが行われる点を除き、ほかのストレージエンジンと同じ容量のストレージを必要とするということを意味します。したがって、<code class="literal">latin1</code> 文字セットを使用して <code class="literal">VARCHAR(50)</code> カラムに格納された文字列 <code class="literal">'abcd'</code> は、(<code class="literal">MyISAM</code> テーブル内の同じカラム値に対する 5 バイトではなく) 8 バイトを必要とします。
    </p><p>
      <code class="literal">TEXT</code> と <code class="literal">BLOB</code> カラムは、<code class="literal">NDB</code> ストレージエンジンでは異なって実装されます。ここでは、<code class="literal">TEXT</code> カラム内の各行は 2 つの別々の部分から構成されています。そのうちの 1 つは固定サイズ (256 バイト) で、実際に元のテーブルに格納されます。もう 1 つは 256 バイトを超えるデータで構成され、非表示のテーブルに格納されます。2 番目のテーブルの行の長さは常に 2,000 バイトです。これは、<em class="replaceable"><code>size</code></em> &lt;= 256 (ここで <em class="replaceable"><code>size</code></em> は行のサイズを表します) の場合、<code class="literal">TEXT</code> カラムのサイズが 256 であり、それ以外の場合はサイズが 256 + <em class="replaceable"><code>size</code></em> + (2000 − (<em class="replaceable"><code>size</code></em> − 256) % 2000) であることを意味します。
    </p><a class="indexterm" name="idm139979101330928"></a><p>
      <code class="literal">ENUM</code> オブジェクトのサイズは異なる列挙値の数によって決まります。最大 255 の値を持つ列挙に 1 バイトが使用されます。256 から 65,535 の値を持つ列挙に 2 バイトが使用されます。<a class="xref" href="data-types.html#enum" title="11.4.4 ENUM 型">セクション11.4.4「ENUM 型」</a>を参照してください。
    </p><a class="indexterm" name="idm139979101326336"></a><p>
      <code class="literal">SET</code> オブジェクトのサイズは異なるセットメンバーの数によって決まります。セットサイズが <em class="replaceable"><code>N</code></em> である場合、オブジェクトは 1、2、3、4、または 8 バイトに丸められた <code class="literal">(<em class="replaceable"><code>N</code></em>+7)/8</code> バイトを占めます。<code class="literal">SET</code> は最大 64 メンバーを持つことができます。<a class="xref" href="data-types.html#set" title="11.4.5 SET 型">セクション11.4.5「SET 型」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="choosing-types"></a>11.8 カラムに適した型の選択</h2></div></div></div><a class="indexterm" name="idm139979101318048"></a><a class="indexterm" name="idm139979101315936"></a><p>
      最適なストレージのために、毎回もっとも正確な型を使用するよう試みる必要があります。たとえば、整数カラムを <code class="literal">1</code> から <code class="literal">99999</code> の範囲の値に使用する場合、<code class="literal">MEDIUMINT UNSIGNED</code> が最適な型になります。必要なすべての値を表す型の中で、これが、使用するストレージの容量がもっとも少ない型になります。
    </p><p>
      <code class="literal">DECIMAL</code> カラムを使用した基本的なすべての計算 (<code class="literal">+</code>、<code class="literal">-</code>、<code class="literal">*</code>、および <code class="literal">/</code>) は、65 桁 (10 進法) の精度で行われます。<a class="xref" href="data-types.html#numeric-type-overview" title="11.1.1 数値型の概要">セクション11.1.1「数値型の概要」</a>を参照してください。
    </p><p>
      精度がそれほど重要でない場合や、スピードが最優先事項である場合は、<code class="literal">DOUBLE</code> 型で十分と考えられます。精度を高めるために、<code class="literal">BIGINT</code> に格納されている固定小数点型にいつでも変換できます。これにより、64 ビット整数のすべての計算を行い、続いて必要に応じて結果を浮動小数点値に戻すことができます。
    </p><p>
      <code class="literal">PROCEDURE ANALYSE</code> を使用すると、最適なカラムデータ型の選択に役立つ情報を入手できます。詳細は、<a class="xref" href="optimization.html#procedure-analyse" title="8.4.2.4 PROCEDURE ANALYSE の使用">セクション8.4.2.4「PROCEDURE ANALYSE の使用」</a>を参照してください。
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="other-vendor-data-types"></a>11.9 その他のデータベースエンジンのデータ型の使用</h2></div></div></div><a class="indexterm" name="idm139979101299056"></a><a class="indexterm" name="idm139979101296944"></a><a class="indexterm" name="idm139979101294912"></a><a class="indexterm" name="idm139979101292880"></a><a class="indexterm" name="idm139979101290960"></a><p>
      ほかのベンダーからの SQL 実装用に作成されたコードを使用しやすくするために、次の表に示すように、MySQL はデータ型をマップします。これらのマッピングにより、ほかのデータベースシステムから MySQL へのテーブル定義の取り込みが簡単に行えるようになります。
    </p><div class="informaltable"><table summary="この表は、MySQL のデータ型とほかのベンダーのデータ型とのマッピングを示しています。" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">その他のベンダーの型</th><th scope="col">MySQL の型</th></tr></thead><tbody><tr><td scope="row"><code class="literal">BOOL</code></td><td><code class="literal">TINYINT</code></td></tr><tr><td scope="row"><code class="literal">BOOLEAN</code></td><td><code class="literal">TINYINT</code></td></tr><tr><td scope="row"><code class="literal">CHARACTER VARYING(<em class="replaceable"><code>M</code></em>)</code></td><td><code class="literal">VARCHAR(<em class="replaceable"><code>M</code></em>)</code></td></tr><tr><td scope="row"><code class="literal">FIXED</code></td><td><code class="literal">DECIMAL</code></td></tr><tr><td scope="row"><code class="literal">FLOAT4</code></td><td><code class="literal">FLOAT</code></td></tr><tr><td scope="row"><code class="literal">FLOAT8</code></td><td><code class="literal">DOUBLE</code></td></tr><tr><td scope="row"><code class="literal">INT1</code></td><td><code class="literal">TINYINT</code></td></tr><tr><td scope="row"><code class="literal">INT2</code></td><td><code class="literal">SMALLINT</code></td></tr><tr><td scope="row"><code class="literal">INT3</code></td><td><code class="literal">MEDIUMINT</code></td></tr><tr><td scope="row"><code class="literal">INT4</code></td><td><code class="literal">INT</code></td></tr><tr><td scope="row"><code class="literal">INT8</code></td><td><code class="literal">BIGINT</code></td></tr><tr><td scope="row"><code class="literal">LONG VARBINARY</code></td><td><code class="literal">MEDIUMBLOB</code></td></tr><tr><td scope="row"><code class="literal">LONG VARCHAR</code></td><td><code class="literal">MEDIUMTEXT</code></td></tr><tr><td scope="row"><code class="literal">LONG</code></td><td><code class="literal">MEDIUMTEXT</code></td></tr><tr><td scope="row"><code class="literal">MIDDLEINT</code></td><td><code class="literal">MEDIUMINT</code></td></tr><tr><td scope="row"><code class="literal">NUMERIC</code></td><td><code class="literal">DECIMAL</code></td></tr></tbody></table></div><p>
      データ型のマッピングはテーブル作成時に行われ、作成後に元の型の仕様は破棄されます。ほかのベンダーで使用されている型でテーブルを作成したあとで、<code class="literal">DESCRIBE <em class="replaceable"><code>tbl_name</code></em></code> ステートメントを発行した場合、MySQL は、その型と同等の MySQL の型を使用したテーブル構造をレポートします。例:
    </p><pre class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE TABLE t (a BOOL, b FLOAT8, c LONG VARCHAR, d NUMERIC);</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>DESCRIBE t;</code></strong>
+-------+---------------+------+-----+---------+-------+
| Field | Type          | Null | Key | Default | Extra |
+-------+---------------+------+-----+---------+-------+
| a     | tinyint(1)    | YES  |     | NULL    |       |
| b     | double        | YES  |     | NULL    |       |
| c     | mediumtext    | YES  |     | NULL    |       |
| d     | decimal(10,0) | YES  |     | NULL    |       |
+-------+---------------+------+-----+---------+-------+
4 rows in set (0.01 sec)
</pre></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="globalization.html">前</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="functions.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第 10 章 グローバリゼーション </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 第 12 章 関数と演算子</td></tr></table></div><div class="copyright-footer"></div></body></html>
